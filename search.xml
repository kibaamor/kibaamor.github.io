<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>iptables简介</title>
      <link href="iptables-jian-jie/"/>
      <url>iptables-jian-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="一、netfilter-项目"><a href="#一、netfilter-项目" class="headerlink" title="一、netfilter 项目"></a>一、netfilter 项目</h2><p><a href="https://www.netfilter.org/">netfilter 项目</a>是 <a href="https://www.kernel.org/">Linux</a> 内核中用于数据包过滤的框架。</p><p>netfilter 项目有两个常用的子项目：iptables 和 nftables。</p><p><a href="https://www.nftables.org/projects/iptables/index.html">iptables 项目</a>中包含了一系列用于配置 Linux 内核中包过滤规则集命令行工具：iptables，ip6tables，arptables，ebtables。</p><p><a href="https://www.nftables.org/projects/nftables/index.html">nftables 项目</a>则是 iptables 项目的继承者，它允许更灵活、可扩展和性能更高的数据包分类。</p><p><strong>本文只介绍使用 iptables 命令行工具管理 ip 协议时所需的相关内容。</strong></p><h2 id="二、iptables-中的基本概念"><a href="#二、iptables-中的基本概念" class="headerlink" title="二、iptables 中的基本概念"></a>二、iptables 中的基本概念</h2><p>netfilter 框架的核心是在 Linux 内核处理数据包过程中的几个关键地方调用 <code>NF_HOOK</code> 函数，拦截数据包来进行处理。</p><p><img src="/images/iptables简介/nf-hooks.png" alt="nf-hooks"></p><blockquote><p>图片来源：<a href="https://wiki.nftables.org/wiki-nftables/index.php/Netfilter_hooks">Netfilter hooks</a></p></blockquote><p>利用 netfilter 框架可实现的功能包括检查、修改、转发、重定向和/或丢弃数据包。</p><ol><li>根据用途的不同，将内核中处理数据包的代码组织成了几个不同的表（table）。</li><li>表由一组的链（chain）组成。</li><li>链中包含一系列规则（rule）。</li><li>规则由匹配条件和相应的执行动作组成（如果条件匹配成功，则执行相应的动作）。</li><li>链中的规则会按顺序的逐一执行，直到某个匹配的动作处理的结果是终止处理或<a href="#预定义的链">预定义的链</a>内的规则都执行完。</li></ol><h3 id="2-1-表"><a href="#2-1-表" class="headerlink" title="2.1 表"></a>2.1 表</h3><p>netfilter 中总共包含五个表：</p><ol><li><strong>raw</strong>：用于标记数据包，让它不被连接跟踪系统跟踪；</li><li><strong>filter</strong>：用于过滤数据包；</li><li><strong>nat</strong>：用来完成<a href="https://en.wikipedia.org/wiki/Network_address_translation">网络地址转换（NAT）</a>功能；</li><li><strong>mangle</strong>：用于修改数据包；</li><li><strong>security</strong>：用于<a href="https://en.wikipedia.org/wiki/Mandatory_access_control">强制访问控制（MAC）</a>网络规则（比如SELinux，<a href="https://lwn.net/Articles/267140/">更多相关信息</a>）。</li></ol><h3 id="2-2-预定义的链"><a href="#2-2-预定义的链" class="headerlink" title="2.2 预定义的链"></a>2.2 预定义的链</h3><p>链的本质其实是 Linux 内核处理数据包的过程中，netfilter 框架嵌入 HOOK 函数的地方。</p><p>netfilter 框架在 Linux 内核处理很多协议（比如：ip，ip6，arp等）的过程中都嵌入了 HOOK 函数，本文只关注 iptables 处理 ip 协议用到的。</p><p>iptables 在每一个嵌入了 HOOK 函数的地方都预定义了一些链：</p><ol><li><strong>PREROUTING</strong>：接收到数据包但是还未判断其目的地是否是本机。</li><li><strong>INPUT</strong>：数据包的目的地是本机但是还未交给协议栈的上层处理。</li><li><strong>OUTPUT</strong>：数据包是由本机发出的。</li><li><strong>FORWARD</strong>：数据包的目的地不是本机的。</li><li><strong>POSTROUTING</strong>：数据包在离开本机之前。</li></ol><p><img src="/images/iptables简介/iptables预定义的链.jpg" alt="iptables预定义的链"></p><p>预定义的链支持设置默认的数据包处理策略。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 将 INPUT 链的默认数据包处理策略设置为 ACCEPT（允许包通过）</span><span class="token function">sudo</span> iptables -P INPUT ACCEPT<span class="token comment"># 将 FORWARD 链的默认数据包处理策略设置为 DROP（丢弃所有的包）</span><span class="token function">sudo</span> iptables -P FORWARD DROP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-表和预定义的链"><a href="#2-3-表和预定义的链" class="headerlink" title="2.3 表和预定义的链"></a>2.3 表和预定义的链</h3><p>根据表的功能和链所在的位置，并不是每个表都需要所有的链。</p><ol><li><p>raw 表</p><p> raw 表用于就是标记数据包，让它不被连接跟踪系统跟踪。</p><ul><li><strong>PREROUTING</strong>：标记收到的所有数据包；</li><li><strong>OUTPUT</strong>：标记本机发出的所有数据包。</li></ul></li><li><p>filter 表</p><p> filter 表用于过滤数据包。</p><ul><li><strong>INPUT</strong>：过滤发给本机的包；</li><li><strong>OUTPUT</strong>：过滤本机发出的包；</li><li><strong>FORWARD</strong>：过滤从本机经过的但不是发给本机的包。</li></ul></li><li><p>nat 表</p><p> nat 表用于完成 NAT 功能。</p><ul><li><strong>PREROUTING</strong>：修改数据包的目的地址，完成 DNAT 功能；</li><li><strong>INPUT</strong>：修改发给本机数据包的源地址，完成 SNAT 功能；</li><li><strong>OUTPUT</strong>：修改本机发出数据包的目的地址，完成 DNAT 功能；</li><li><strong>POSTROUTING</strong>：修改数据包的源地址，完成 SNAT 功能。</li></ul></li><li><p>mangle 表</p><p> mangle 表用于修改数据包。</p><ul><li><strong>PREROUTING</strong>；</li><li><strong>INPUT</strong>；</li><li><strong>OUTPUT</strong>；</li><li><strong>FORWARD</strong>；</li><li><strong>POSTROUTING</strong>。</li></ul></li><li><p>security 表</p><p> security 表用于完成与安全相关的标记功能。</p><ul><li><strong>INPUT</strong>；</li><li><strong>OUTPUT</strong>；</li><li><strong>FORWARD</strong>。</li></ul></li></ol><p><img src="/images/iptables简介/iptables的表和预定义的链.png" alt="iptables的表和预定义的链"></p><h3 id="2-4-自定义的链"><a href="#2-4-自定义的链" class="headerlink" title="2.4 自定义的链"></a>2.4 自定义的链</h3><p>除了使用预定的链外，iptables还支持自定义链。数据包在处理的过程中能够通过 jump 动作跳转到同一个表的另一个链（这个链必须是自定义的，不能是预定于的）上继续处理。</p><p>同时，自定义的链不支持设置默认数据包处理策略，其默认的处理策略是返回父链中继续进行处理。</p><p>在下面的图中，在链 1 中的 规则 3 时匹配成功，跳到链 2 从头开始执行，最后通过链 2 返回到链 1 的规则 4 继续执行。</p><p><img src="/images/iptables简介/iptables自定义的链.jpg" alt="iptables自定义的链"></p><blockquote><p>图片来源：<a href="https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html#USERTABLES">User specified chains</a></p></blockquote><h3 id="2-5-连接状态"><a href="#2-5-连接状态" class="headerlink" title="2.5 连接状态"></a>2.5 连接状态</h3><p>Linux 内核中一个名为 <code>conntrack</code> 的模块提供了连接状态的跟踪功能，可以跟踪各种协议的连接并标记状态。<strong>需要注意的是，连接跟踪中的连接与 TCP/IP 中 TCP 的连接不是同一个概念。</strong></p><p>连接主要有五种状态：</p><ol><li><p><strong>NEW</strong></p><p> 此状态表示数据包是系统看到的某个连接上的第一个数据包。比如，对于 TCP 来说，三次握手收到的一个包的状态就是这个状态。</p><blockquote><p>不管是收到的第一个数据包，还是发出的第一个数据包都都算是第一个。</p><p>不管数据包是否是正常的，只要是第一个数据包都算。比如，对于 TCP 的三次握手来说，正常握手的第一个包中仅包括 SYN 标记，但是如果第一个包中包含了错误的标记（如：SYN，RST），也会算是第一个数据包。</p></blockquote></li><li><p><strong>ESTABLISHED</strong></p><p> 此状态表示系统在通信的双向都看到了流量通信，并且后续的数据包都会是这个状态。只需要一个机器发送一个数据包，并收到想要的应答数据包后，连接就会进入此状态（即使收到的是一个 ICMP 的错误报告）。</p></li><li><p><strong>RELATED</strong></p><p> 此状态表明一个连接和另一个已经处于 <strong>ESTABLISHED</strong> 状态的连接有关时，就会被认为是这个状态。</p><p> 连接进入此状态的前提是已有一个处于 <strong>ESTABLISHED</strong> 状态，<strong>并且 Linux 内核能够理解这个连接</strong>，同时这个连接另外再产生了一个新的连接，这个新的连接的状态就是 <strong>RELATED</strong> 。比如 FTP 的 Data 连接就是根据 FTP 的 Control 连接产生的，所以 FTP 的 Control 连接是 <strong>ESTABLISHED</strong> 状态，FTP 的 Data 连接是 <strong>RELATED</strong> 状态。</p></li><li><p><strong>INVALID</strong></p><p> 此状态表明数据包不能被识别或者它没有任何状态。导致的原因可能是系统内存不足或是 ICMP 的错误报告不能匹配上本地的任何连接。一般而言，推荐丢弃此状态的数据包。</p></li><li><p><strong>UNTRACKED</strong></p><p> 此状态表明数据包被标记为了不跟踪，同时与此连接相关的原本是 <strong>RELATED</strong> 状态的连接也会是此状态。</p></li></ol><h2 id="三、iptables-规则的匹配条件"><a href="#三、iptables-规则的匹配条件" class="headerlink" title="三、iptables 规则的匹配条件"></a>三、iptables 规则的匹配条件</h2><p>参考：<a href="https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html#MATCHES">Iptables matches</a>。</p><h2 id="四、iptables-规则的执行动作"><a href="#四、iptables-规则的执行动作" class="headerlink" title="四、iptables 规则的执行动作"></a>四、iptables 规则的执行动作</h2><p>参考：<a href="https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html#TARGETS">Iptables targets and jumps</a>。</p><h2 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h2><ol><li><a href="https://wiki.archlinux.org/title/Iptables">iptables</a></li><li><a href="https://wiki.nftables.org/wiki-nftables/index.php/Configuring_chains">Configuring chains</a></li><li><a href="https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html">Iptables Tutorial 1.2.2</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netfilter </tag>
            
            <tag> iptables </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP中的keepalive机制</title>
      <link href="tcp-zhong-de-keepalive-ji-zhi/"/>
      <url>tcp-zhong-de-keepalive-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、RFC1122"><a href="#一、RFC1122" class="headerlink" title="一、RFC1122"></a>一、RFC1122</h2><p>关于 TCP 中 keepalive 机制的描述在 <a href="https://datatracker.ietf.org/doc/html/rfc1122#page-101">RFC1122 中的 4.2.3.6 小结</a> ，内容不多，总结一下有下面几点：</p><ol><li>TCP 实现中 <strong>可以</strong> 包含 keepalive 这个功能，也可以不包含。</li><li>如果实现了 keepalive 这个功能，那么 <strong>必须</strong> 能为每个 TCP 连接开启或者关闭 keepalive 功能。同时，此功能默认 <strong>必须</strong> 是关闭的。</li><li><strong>必须</strong> 在规定的时间间隔内，既没有收到包含数据包，也没有收到包含 ACK 标记的包时，才能发送 keepalive 的包。这个时间间隔 <strong>必须</strong> 是可配置的，并且默认 <strong>必须</strong> 不能小于两个小时。</li><li>TCP 不能保证没有数据仅有 ACK 标记的包一定会被对端接收到。所以，如果实现了 keepalive 机制，<strong>必须</strong> 不能把任何特定探测失败的连接标记为死链接。</li><li>keepalive 的实现 <strong>应该</strong> 是发送一个不包含数据的 keepalive 包。但是为了与不规范的 TCP 实现兼容，<strong>可以</strong> 配置在 keepalive 包中包含一个垃圾的字节，来避免第 4 点的情况。</li><li>一些 TCP 实现 keepalive 的方式是：发送一个 Seq 编号为 Next-1 （如果是正常的数据发送 Seq 的值应为 Next ），并且可能包含或者不包含一个垃圾字节的包给对端。因为 keepalive 包中的 Seq 值在对端 TCP 的滑动窗口之外（因为已经确认收到了），所以对端会回应一个包含有 ACK 标记的包，并据此来判断对端是否存活。如果对端网络故障或者崩溃，则会回应一个带有 RST 标记的包来重置连接。</li><li>一些不够完善的 TCP 实现可能不能正确的响应 Seq 编号为 Next-1 且不带数据的 keepalive 包，但是却可以响应带有一个字节垃圾信息的包。所以在实现 keepalive 机制时，需要判断这种情况，并据此决定在发送 keepalive 包时，是否要带上一字节的垃圾数据。</li><li>TCP 的 keepalive 机制应该仅用在服务器的程序中，因为如果客户端崩溃，服务器就能及时的释放资源。</li></ol><h2 id="二、相关设置"><a href="#二、相关设置" class="headerlink" title="二、相关设置"></a>二、相关设置</h2><h3 id="1-SO-KEEPALIVE"><a href="#1-SO-KEEPALIVE" class="headerlink" title="1. SO_KEEPALIVE"></a>1. SO_KEEPALIVE</h3><p>默认情况下，新创建出来的套接字的 keepalive 功能都是关闭的。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> keepalive <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token function">setsockopt</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> SOL_SOCKET<span class="token punctuation">,</span> SO_KEEPALIVE<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>keepalive<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>keepalive<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-TCP-KEEPIDLE"><a href="#2-TCP-KEEPIDLE" class="headerlink" title="2. TCP_KEEPIDLE"></a>2. TCP_KEEPIDLE</h3><p>这个选项用于控制经过多久后，既没有收到包含数据包，也没有收到包含 ACK 标记的包时，就发送 keepalive 的包。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> keepidle <span class="token operator">=</span> <span class="token number">7200</span><span class="token punctuation">;</span><span class="token function">setsockopt</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> SOL_TCP<span class="token punctuation">,</span> TCP_KEEPIDLE<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>keepidle<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>keepidle<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>Windows下，代码中的 <code>SOL_TCP</code> 要替换成 <code>IPPROTO_TCP</code>，下同。</p></blockquote><h3 id="3-TCP-KEEPINTVL"><a href="#3-TCP-KEEPINTVL" class="headerlink" title="3. TCP_KEEPINTVL"></a>3. TCP_KEEPINTVL</h3><p>这个选项用于控制一旦开始发送了 keepalive 后，经过多久时间后再发送下一个包。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> keepintvl <span class="token operator">=</span> <span class="token number">75</span><span class="token punctuation">;</span><span class="token function">setsockopt</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> SOL_TCP<span class="token punctuation">,</span> TCP_KEEPINTVL<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>keepintvl<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>keepintvl<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="4-TCP-KEEPCNT"><a href="#4-TCP-KEEPCNT" class="headerlink" title="4. TCP_KEEPCNT"></a>4. TCP_KEEPCNT</h3><p>这个选项用于控制在经过发送了多少个 keepalive 包但是都没有收到回复后，可以认为连接已经断开了。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> keepcnt <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span><span class="token function">setsockopt</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> SOL_TCP<span class="token punctuation">,</span> TCP_KEEPCNT<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>keepcnt<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>keepcnt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="5-默认值"><a href="#5-默认值" class="headerlink" title="5. 默认值"></a>5. 默认值</h3><p>Linux下，系统的默认值可以通过命令来查看：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /proc/sys/net/ipv4/tcp_keepalive_time <span class="token comment">#7200</span><span class="token function">cat</span> /proc/sys/net/ipv4/tcp_keepalive_intvl <span class="token comment">#75</span><span class="token function">cat</span> /proc/sys/net/ipv4/tcp_keepalive_probes <span class="token comment">#9</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>上面参数的意义是：在未收到包含数据或 ACK 标志的包 7200 秒后，开始发送 keepalive 包，并每隔 75 秒重发一次，如果连发 9 次都没有响应，就认为网络已断开。但是如果 9 次内的某次收到了 keepalive 包对应的 ACK 包，则又会在未收到包含数据或ACK 标志的包 7200 秒后重新开始发 keepalive 包。</p></blockquote><p>Windows下，不同系统版本默认值不同，一般是7200秒，1秒，10次。具体的可以参考：<a href="https://docs.microsoft.com/en-us/windows/win32/winsock/sio-keepalive-vals#remarks">https://docs.microsoft.com/en-us/windows/win32/winsock/sio-keepalive-vals#remarks</a>。</p><h2 id="三、平台实现"><a href="#三、平台实现" class="headerlink" title="三、平台实现"></a>三、平台实现</h2><h3 id="1-测试代码"><a href="#1-测试代码" class="headerlink" title="1. 测试代码"></a>1. 测试代码</h3><p>写一段代码简单的测试一下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// file: keepalive.c</span><span class="token comment">// gcc -o keepalive keepalive.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">_WIN32</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;WinSock2.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;Ws2tcpip.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">comment</span><span class="token punctuation">(</span>lib<span class="token punctuation">,</span> </span><span class="token string">"ws2_32.lib"</span><span class="token expression"><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">socklen_t <span class="token keyword">int</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">SOL_TCP IPPROTO_TCP</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netinet/in.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netinet/tcp.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">SOCKET <span class="token keyword">int</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">IP </span><span class="token string">"192.168.104.106"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">PORT <span class="token number">9876</span></span></span><span class="token keyword">void</span> <span class="token function">print_sock_opt</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">,</span> SOCKET sockfd<span class="token punctuation">,</span> <span class="token keyword">int</span> level<span class="token punctuation">,</span> <span class="token keyword">int</span> optname<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> optval <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    socklen_t optlen <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>optval<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getsockopt</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> level<span class="token punctuation">,</span> optname<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>optval<span class="token punctuation">,</span> <span class="token operator">&amp;</span>optlen<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"getsockopt failed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s: %d\n"</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> optval<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">print_sock_keepalive</span><span class="token punctuation">(</span>SOCKET sockfd<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">print_sock_opt</span><span class="token punctuation">(</span><span class="token string">"keepalive"</span><span class="token punctuation">,</span> sockfd<span class="token punctuation">,</span> SOL_SOCKET<span class="token punctuation">,</span> SO_KEEPALIVE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print_sock_opt</span><span class="token punctuation">(</span><span class="token string">"keepidle"</span><span class="token punctuation">,</span> sockfd<span class="token punctuation">,</span> SOL_TCP<span class="token punctuation">,</span> TCP_KEEPIDLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print_sock_opt</span><span class="token punctuation">(</span><span class="token string">"keepintvl"</span><span class="token punctuation">,</span> sockfd<span class="token punctuation">,</span> SOL_TCP<span class="token punctuation">,</span> TCP_KEEPINTVL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print_sock_opt</span><span class="token punctuation">(</span><span class="token string">"keepcnt"</span><span class="token punctuation">,</span> sockfd<span class="token punctuation">,</span> SOL_TCP<span class="token punctuation">,</span> TCP_KEEPCNT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">set_sock_opt</span><span class="token punctuation">(</span>SOCKET sockfd<span class="token punctuation">,</span> <span class="token keyword">int</span> level<span class="token punctuation">,</span> <span class="token keyword">int</span> optname<span class="token punctuation">,</span> <span class="token keyword">int</span> optval<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">setsockopt</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> level<span class="token punctuation">,</span> optname<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>optval<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>optval<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"setsockopt failed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">set_sock_keepalive</span><span class="token punctuation">(</span>SOCKET sockfd<span class="token punctuation">,</span> <span class="token keyword">int</span> keepalive<span class="token punctuation">,</span> <span class="token keyword">int</span> idle<span class="token punctuation">,</span> <span class="token keyword">int</span> intvl<span class="token punctuation">,</span> <span class="token keyword">int</span> cnt<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">set_sock_opt</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> SOL_SOCKET<span class="token punctuation">,</span> SO_KEEPALIVE<span class="token punctuation">,</span> keepalive<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">set_sock_opt</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> SOL_TCP<span class="token punctuation">,</span> TCP_KEEPIDLE<span class="token punctuation">,</span> idle<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">set_sock_opt</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> SOL_TCP<span class="token punctuation">,</span> TCP_KEEPINTVL<span class="token punctuation">,</span> intvl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">set_sock_opt</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> SOL_TCP<span class="token punctuation">,</span> TCP_KEEPCNT<span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">_WIN32</span></span>    WSADATA wsaData<span class="token punctuation">;</span>    <span class="token function">WSAStartup</span><span class="token punctuation">(</span><span class="token function">MAKEWORD</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>wsaData<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    SOCKET sockfd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> addr<span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>addr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    addr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>    addr<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>PORT<span class="token punctuation">)</span><span class="token punctuation">;</span>    addr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">inet_addr</span><span class="token punctuation">(</span>IP<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">connect</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>addr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"connect failed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">print_sock_keepalive</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">set_sock_keepalive</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print_sock_keepalive</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">recv</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        buf<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"receive: %s\n"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">send</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-服务器"><a href="#2-服务器" class="headerlink" title="2. 服务器"></a>2. 服务器</h3><p>在 Linux 上安装软件 <code>socat</code>，并运行下面的命令来监听端口9876：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">socat tcp-listen:9876,reuseaddr -<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>服务器的 IP 地址为：192.168.104.106。</p></blockquote><h3 id="3-Linux-下-keepalive-的实现"><a href="#3-Linux-下-keepalive-的实现" class="headerlink" title="3. Linux 下 keepalive 的实现"></a>3. Linux 下 keepalive 的实现</h3><blockquote><p>Linux 的 IP 地址为：192.168.102.63<br>Linux 的内核为：4.15.0-147-generic</p></blockquote><p>首先安装 tcpdump 并运行下面的命令来抓包：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> tcpdump -pni enp0s31f6 -vvv -S <span class="token string">"tcp port 9876"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>其中 <code>enp0s31f6</code> 是网卡的名字，<code>9876</code> 为端口号。</p></blockquote><p>然后运行测试代码编译出来的程序，tcpdump 输出（删除了一些不必要的信息）：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">14:21:17.008786 192.168.102.63.34882 &gt; 192.168.104.106.9876: Flags [S],  seq 3365757301, length 014:21:17.009112 192.168.104.106.9876 &gt; 192.168.102.63.34882: Flags [S.], seq 3674364464, ack 3365757302, length 014:21:17.009152 192.168.102.63.34882 &gt; 192.168.104.106.9876: Flags [.],  seq 3365757302, ack 3674364465, length 014:21:27.142639 192.168.102.63.34882 &gt; 192.168.104.106.9876: Flags [.],  seq 3365757301, ack 3674364465, length 014:21:27.142904 192.168.104.106.9876 &gt; 192.168.102.63.34882: Flags [.],  seq 3674364465, ack 3365757302, length 014:21:37.382671 192.168.102.63.34882 &gt; 192.168.104.106.9876: Flags [.],  seq 3365757301, ack 3674364465, length 014:21:37.383214 192.168.104.106.9876 &gt; 192.168.102.63.34882: Flags [.],  seq 3674364465, ack 3365757302, length 014:21:47.622639 192.168.102.63.34882 &gt; 192.168.104.106.9876: Flags [.],  seq 3365757301, ack 3674364465, length 014:21:47.623224 192.168.104.106.9876 &gt; 192.168.102.63.34882: Flags [.],  seq 3674364465, ack 3365757302, length 014:21:50.787206 192.168.102.63.34882 &gt; 192.168.104.106.9876: Flags [F.], seq 3365757302, ack 3674364465, length 014:21:50.791349 192.168.104.106.9876 &gt; 192.168.102.63.34882: Flags [.],  seq 3674364465, ack 3365757303, length 014:21:51.288252 192.168.104.106.9876 &gt; 192.168.102.63.34882: Flags [F.], seq 3674364465, ack 3365757303, length 014:21:51.288293 192.168.102.63.34882 &gt; 192.168.104.106.9876: Flags [.],  seq 3365757303, ack 3674364466, length 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从输出中可以看出：</p><ol><li>在 TCP 三次握手成功后的 10 秒后，开始发送 keepalive 包。</li><li>Linux 发出的 keepalive 包中，Seq 的值确实是 Next-1 ，且 keepalive 包中并未包含有一个字节的垃圾数据。</li></ol><h3 id="4-Windows"><a href="#4-Windows" class="headerlink" title="4. Windows"></a>4. Windows</h3><blockquote><p>Windows 的 IP 地址为：192.168.104.134<br>Windows 的版本为：Version 21H2(OS Build 22000.51)</p></blockquote><p>首先安装 <a href="https://www.wireshark.org/">wireshark</a> 并使用下面的条件来嗅探网络包：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">tcp.port == 9876<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后使用 VS2017 编译并运行测试代码， wireshark 捕获到：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">10.902771 192.168.104.134 192.168.104.106 2389 → 9876 [SYN]      Seq=0 Len=010.903375 192.168.104.106 192.168.104.134 9876 → 2389 [SYN, ACK] Seq=0 Ack=1 Len=010.903458 192.168.104.134 192.168.104.106 2389 → 9876 [ACK]      Seq=1 Ack=1 Len=020.906729 192.168.104.134 192.168.104.106 2389 → 9876 [ACK]      Seq=0 Ack=1 Len=120.907444 192.168.104.106 192.168.104.134 9876 → 2389 [ACK]      Seq=1 Ack=1 Len=030.907197 192.168.104.134 192.168.104.106 2389 → 9876 [ACK]      Seq=0 Ack=1 Len=130.907740 192.168.104.106 192.168.104.134 9876 → 2389 [ACK]      Seq=1 Ack=1 Len=040.914386 192.168.104.134 192.168.104.106 2389 → 9876 [ACK]      Seq=0 Ack=1 Len=140.915088 192.168.104.106 192.168.104.134 9876 → 2389 [ACK]      Seq=1 Ack=1 Len=042.105023 192.168.104.134 192.168.104.106 2389 → 9876 [RST, ACK] Seq=1 Ack=1 Len=0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从输出中可以看出：</p><ol><li>在 TCP 三次握手成功后的 10 秒后，开始发送 keepalive 包。</li><li>Windows 发出的 keepalive 包中，Seq 的值确实是 Next-1 ，但 keepalive 包中包含有一个字节的垃圾数据。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> keepalive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结合Linux内核源码分析TCP协议状态机</title>
      <link href="jie-he-linux-nei-he-yuan-ma-fen-xi-tcp-xie-yi-zhuang-tai-ji/"/>
      <url>jie-he-linux-nei-he-yuan-ma-fen-xi-tcp-xie-yi-zhuang-tai-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="一、准备环境"><a href="#一、准备环境" class="headerlink" title="一、准备环境"></a>一、准备环境</h2><blockquote><p>环境：Ubuntu18.04</p><p>编辑器：VSCode</p><p>内核版本：<a href="https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.19.194.tar.xz">linux-4.19.194</a></p></blockquote><h3 id="1-下载编译内核源码"><a href="#1-下载编译内核源码" class="headerlink" title="1. 下载编译内核源码"></a>1. 下载编译内核源码</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.19.194.tar.xz<span class="token function">tar</span> xf linux-4.19.194.tar.xz<span class="token builtin class-name">cd</span> linux-4.19.194<span class="token comment"># 想要编译什么架构就指定什么值，所有合法的值在源码的arch文件夹下必须存在同名的文件夹</span><span class="token builtin class-name">export</span> <span class="token assign-left variable">ARCH</span><span class="token operator">=</span>x86 <span class="token comment">#x86架构</span><span class="token comment"># make命令的参数可以通过 make help 获取</span><span class="token function">make</span> x86_64_defconfig <span class="token comment"># 生成64位平台的默认配置</span><span class="token function">make</span> <span class="token comment"># 编译内核</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-分析编译时的宏定义"><a href="#2-分析编译时的宏定义" class="headerlink" title="2. 分析编译时的宏定义"></a>2. 分析编译时的宏定义</h3><p>在第一步 <a href="#1-下载编译内核源码">下载编译内核源码</a> 成功后，源代码目录下会生成一个名为 <code>.config</code> 的文件，该文件指明了编译内核时所用到的设置。可以使用下面的命令来生成编译内核代码时使用的宏定义列表：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">grep</span> <span class="token string">"^CONFIG_.*"</span> .config <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">"s/=y//g"</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">"s/=m/_MODULE/g"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>另外还在加上宏 <code>__KERNEL__</code>。</p><blockquote><p>来自源代码根目录下 <code>Makefile</code> 文件的443行。</p></blockquote><p>将上面命令生成的结果配置到vscode中，可以更加方面有效的查看内核代码。</p><h2 id="二、确定套接字调用对应的内核实现函数"><a href="#二、确定套接字调用对应的内核实现函数" class="headerlink" title="二、确定套接字调用对应的内核实现函数"></a>二、确定套接字调用对应的内核实现函数</h2><blockquote><p>下面以创建套接字的函数 <code>socket</code> 为例。</p></blockquote><h3 id="1-确定socket调用的syscall号"><a href="#1-确定socket调用的syscall号" class="headerlink" title="1. 确定socket调用的syscall号"></a>1. 确定socket调用的syscall号</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// file: main.c</span><span class="token comment">// compile: gcc -ggdb main.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> s<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>GDB反汇编调试socket调用</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">0x7ffff7b04d50 &lt;socket&gt;         mov    $0x29,%eax0x7ffff7b04d55 &lt;socket+5&gt;       syscall<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以发现socket调用的syscall号为0x29（即41）。</p><blockquote><p>命令 <code>man syscall</code> 可以获取更多关于 syscall 调用的信息。</p></blockquote><h3 id="2-确定socket对应的内核实现"><a href="#2-确定socket对应的内核实现" class="headerlink" title="2. 确定socket对应的内核实现"></a>2. 确定socket对应的内核实现</h3><p>系统调用表定义在 <code>arch/x86/entry/syscall_64.c</code> 文件中：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// file: arch/x86/entry/syscall_64.c</span>asmlinkage <span class="token keyword">const</span> sys_call_ptr_t sys_call_table<span class="token punctuation">[</span>__NR_syscall_max<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token comment">/*     * Smells like a compiler bug -- it doesn't work     * when the &amp; below is removed.     */</span>    <span class="token punctuation">[</span><span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> __NR_syscall_max<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>sys_ni_syscall<span class="token punctuation">,</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;asm/syscalls_64.h&gt;</span></span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码中 <code>#include &lt;asm/syscalls_64.h&gt;</code> 对应的文件是 <code>arch/x86/include/generated/asm/syscalls_64.h</code> ：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// file: arch/x86/include/generated/asm/syscalls_64.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_X86</span></span><span class="token function">__SYSCALL_64</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">,</span> __x64_sys_socket<span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span> <span class="token comment">/* CONFIG_UML */</span></span><span class="token function">__SYSCALL_64</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">,</span> sys_socket<span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>arch/x86/include/generated/asm/syscalls_64.h</code> 文件由 <code>arch/x86/entry/syscalls/syscall_64.tbl</code> 文件生成而来。</p></blockquote><p>根据 <a href="#2-分析编译时的宏定义">分析编译时的宏定义</a> 的结果，可以确定宏 <code>CONFIG_X86</code> 是定义了的，所以调用号41对应的实现为 <code>__x64_sys_socket</code> 。</p><p>在源码中却找不到 <code>__x64_sys_socket</code> 的定义，但能在文件 <code>net/socket.c</code> 中找到 <code>__sys_socket</code> 函数的定义：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// file: net/socket.c</span><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>socket<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> family<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> protocol<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">__sys_socket</span><span class="token punctuation">(</span>family<span class="token punctuation">,</span> type<span class="token punctuation">,</span> protocol<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分析宏 <code>SYSCALL_DEFINE3</code> 的定义：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// file: include/linux/syscalls.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">SYSCALL_DEFINEx</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> _</span><span class="token punctuation">##</span><span class="token expression">name<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">SYSCALL_DEFINEx</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> sname<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>              </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token function">SYSCALL_METADATA</span><span class="token punctuation">(</span>sname<span class="token punctuation">,</span> x<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span>         </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token function">__SYSCALL_DEFINEx</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> sname<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着分析宏 <code>__SYSCALL_DEFINEx</code> 的定义：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// file: arch/x86/include/asm/syscall_wrapper.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">__SYSCALL_DEFINEx</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>                 </span><span class="token punctuation">\</span>    <span class="token expression">asmlinkage <span class="token keyword">long</span> __x64_sys</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span>regs<span class="token punctuation">)</span><span class="token punctuation">;</span>    </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token function">ALLOW_ERROR_INJECTION</span><span class="token punctuation">(</span>__x64_sys</span><span class="token punctuation">##</span><span class="token expression">name<span class="token punctuation">,</span> ERRNO<span class="token punctuation">)</span><span class="token punctuation">;</span>          </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">static</span> <span class="token keyword">long</span> __se_sys</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_LONG<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">long</span> __do_sys</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_DECL<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token punctuation">\</span>    <span class="token expression">asmlinkage <span class="token keyword">long</span> __x64_sys</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span>regs<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">{</span>                               </span><span class="token punctuation">\</span>        <span class="token expression"><span class="token keyword">return</span> __se_sys</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">SC_X86_64_REGS_TO_ARGS</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">}</span>                               </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token function">__IA32_SYS_STUBx</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> name<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span>              </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">static</span> <span class="token keyword">long</span> __se_sys</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_LONG<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span>  </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">{</span>                               </span><span class="token punctuation">\</span>        <span class="token expression"><span class="token keyword">long</span> ret <span class="token operator">=</span> __do_sys</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_CAST<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token punctuation">\</span>        <span class="token expression"><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_TEST<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">;</span>             </span><span class="token punctuation">\</span>        <span class="token expression"><span class="token function">__PROTECT</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> ret<span class="token punctuation">,</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_ARGS<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   </span><span class="token punctuation">\</span>        <span class="token expression"><span class="token keyword">return</span> ret<span class="token punctuation">;</span>                     </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">}</span>                               </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">long</span> __do_sys</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_DECL<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以确定，宏 <code>SYSCALL_DEFINE3(socket, int, family, int, type, int, protocol)</code> 展开后，定义了 <code>__x64_sys_socket</code>。</p><p>即 <code>__x64_sys_socket</code> 函数的本体就是 <code>net/socket.c</code> 文件中的 <code>__sys_socket</code> 函数。</p><h2 id="三、分析TCP协议状态机"><a href="#三、分析TCP协议状态机" class="headerlink" title="三、分析TCP协议状态机"></a>三、分析TCP协议状态机</h2><h3 id="1-socket"><a href="#1-socket" class="headerlink" title="1. socket"></a>1. socket</h3><p>调用流程如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">__sys_socket                // net/socket.c:1355    |- sock_create          // net/socket.c:1346        |- __sock_create    // net/socket.c:1316<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>socket</code> 函数最后会调用函数 <code>__sock_create</code> ，其主要代码如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">__sock_create</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">net</span> <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">int</span> family<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span> protocol<span class="token punctuation">,</span>            <span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span><span class="token operator">*</span>res<span class="token punctuation">,</span> <span class="token keyword">int</span> kern<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span>sock<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">net_proto_family</span> <span class="token operator">*</span>pf<span class="token punctuation">;</span>    sock <span class="token operator">=</span> <span class="token function">sock_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pf <span class="token operator">=</span> <span class="token function">rcu_dereference</span><span class="token punctuation">(</span>net_families<span class="token punctuation">[</span>family<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pf<span class="token operator">-&gt;</span><span class="token function">create</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> sock<span class="token punctuation">,</span> protocol<span class="token punctuation">,</span> kern<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>sock_alloc()</code> 函数分配套接字的一些资源后，再从 <code>net_families</code> 取出网络协议簇对应的处理函数，最后创建对应网络协议簇的套接字。</p><p><code>net_families</code> 是一个数组，里面存放了不同的协议簇对应的处理函数。通过函数 <code>sock_register</code> 可以注册到此数组中。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// file: net/ipv4/af_inet.c</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">net_proto_family</span> inet_family_ops <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span>family <span class="token operator">=</span> PF_INET<span class="token punctuation">,</span>    <span class="token punctuation">.</span>create <span class="token operator">=</span> inet_create<span class="token punctuation">,</span>    <span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">inet_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token function">sock_register</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>inet_family_ops<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于 TCP/IPv4 来说，上面代码中的 <code>err = pf-&gt;create(net, sock, protocol, kern)</code> 调用的其实是 <code>inet_create(net, sock, protocol, kern)</code> 。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">inet_create                             // net/ipv4/af_inet.c:1075    |- sock_init_data                   // net/core/sock.c:347        |- sk-&gt;sk_state = TCP_CLOSE     // net/core/sock.c:2790<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>综上，调用 <code>socket()</code> 函数后，套接字的默认状态为 <code>TCP_CLOSE</code> 。</p><h3 id="2-listen"><a href="#2-listen" class="headerlink" title="2. listen"></a>2. listen</h3><p>调用流程如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">__sys_listen                    // net/socket.c:1525    |- sock-&gt;ops-&gt;listen()      // net/socket.c:1516<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对于 TCP/IPv4 来说，上面代码中的 <code>sock-&gt;ops-&gt;listen()</code> 调用的其实是 <code>net/ipv4/af_inet.c</code> 文件中的 <code>inet_listen</code> 函数。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">inet_listen                                     // net/ipv4/af_inet.c:991    |- inet_csk_listen_start                    // net/ipv4/af_inet.c:229        |- inet_sk_state_store(sk, TCP_LISTEN)  // net/ipv4/inet_connection_sock.c:923<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>综上，调用 <code>listen()</code> 函数后，套接字的状态由 <code>TCP_CLOSE</code> 变为 <code>TCP_LISTEN</code> 。</p><h3 id="3-connect"><a href="#3-connect" class="headerlink" title="3. connect"></a>3. connect</h3><p>调用流程如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">__sys_connect                // net/socket.c:1674    |- sock-&gt;ops-&gt;connect()  // net/socket.c:1663<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>同理，对于 TCP/IPv4 来说，上面代码中的 <code>sock-&gt;ops-&gt;connect()</code> 调用的其实是 <code>net/ipv4/af_inet.c</code> 文件中的 <code>inet_stream_connect</code> 函数。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">inet_stream_connect                 // net/ipv4/af_inet.c:985    |- __inet_stream_connect        // net/ipv4/af_inet.c:719        |- sk-&gt;sk_prot-&gt;connect()   // net/ipv4/af_inet.c:655<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面代码中的 <code>sk-&gt;sk_prot-&gt;connect()</code> 调用的其实是 <code>net/ipv4/tcp_ipv4.c</code> 文件中的 <code>tcp_v4_connect</code> 函数。</p><h4 id="1-发送SYN"><a href="#1-发送SYN" class="headerlink" title="1. 发送SYN"></a>1. 发送SYN</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">tcp_v4_connect                                      // net/ipv4/tcp_ipv4.c:2460    |- tcp_set_state(sk, TCP_SYN_SENT)              // net/ipv4/tcp_ipv4.c:280    |- tcp_connect                                  // net/ipv4/tcp_ipv4.c:318        |- tcp_transmit_skb                         // net/ipv4/tcp_output.c:3529            |- __tcp_transmit_skb                   // net/ipv4/tcp_output.c:1164                |- icsk-&gt;icsk_af_ops-&gt;queue_xmit()  // net/ipv4/tcp_output.c:1148<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>tcp_v4_connect</code> 函数先将套接字的状态设置为 <code>TCP_SYN_SENT</code> ，然后再调用 <code>tcp_connect</code> 发送实际的SYN包。</p><p>在函数 <code>__tcp_transmit_skb</code> 中构建网络包的TCP头。构建好后，调用 <code>icsk-&gt;icsk_af_ops-&gt;queue_xmit()</code> 发送TCP包，而函数 <code>icsk-&gt;icsk_af_ops-&gt;queue_xmit()</code> 实际就是 <code>include/net/ip.h</code> 文件中的 <code>ip_queue_xmit</code> 函数。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">ip_queue_xmit                                   // net/ipv4/tcp_ipv4.c:1931    |- __ip_queue_xmit                          // include/net/ip.h:197        |- skb_dst_set_noref(skb, &amp;rt-&gt;dst)     // net/ipv4/ip_output.c:473        |- ip_local_out                         // net/ipv4/ip_output.c:506<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>首先在函数 <code>__ip_queue_xmit</code> 中调用 <code>skb_dst_set_noref(skb, &amp;rt-&gt;dst)</code> 设置发送的目标，然后构建 IP 头并调用函数 <code>ip_local_out</code> 将包含有 SYN 标志的 TCP 包发送出去。</p><h4 id="2-接收到SYN和ACK，并回复ACK"><a href="#2-接收到SYN和ACK，并回复ACK" class="headerlink" title="2. 接收到SYN和ACK，并回复ACK"></a>2. 接收到SYN和ACK，并回复ACK</h4><p>当 IP 层接收到 TCPv4 的包时，会调用函数 <code>tcp_v4_rcv</code> 来处理。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">tcp_v4_rcv                                                  // net/ipv4/af_inet.c:1684    |- tcp_v4_do_rcv                                        // net/ipv4/tcp_ipv4.c:1832        |- tcp_rcv_state_process                            // net/ipv4/tcp_ipv4.c:1569            |- tcp_rcv_synsent_state_process                // net/ipv4/tcp_input.c:6065                |- tcp_finish_connect                       // net/ipv4/tcp_input.c:5898                    |- tcp_set_state(sk, TCP_ESTABLISHED)   // net/ipv4/tcp_input.c:5695                |- tcp_send_ack                             // net/ipv4/tcp_input.c:5928<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>tcp_rcv_synsent_state_process</code> 中，先将套接字的状态设置为 <code>TCP_ESTABLISHED</code> ，然后再调用 <code>tcp_send_ack</code> 发送 ACK 完成 TCP 的三次握手。</p><p>综上，调用 <code>connect()</code> 函数后，套接字的状态由 <code>TCP_CLOSE</code> 变为 <code>TCP_SYN_SENT</code> ，在成功收到 ACK 后，状态再变为 <code>TCP_ESTABLISHED</code> 。</p><h3 id="4-accept"><a href="#4-accept" class="headerlink" title="4. accept"></a>4. accept</h3><p>调用流程如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">__sys_accept4                               // net/socket.c:1630    |- sock-&gt;ops-&gt;accept(sock, newsock)     // net/socket.c:1589<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对于 TCP/IPv4 来说， <code>sock-&gt;ops-&gt;accept()</code> 实际调用的是 <code>net/ipv4/af_inet.c</code> 文件中的 <code>inet_accept</code> 。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">inet_accept                     // net/ipv4/af_inet.c:987    |- sk1-&gt;sk_prot-&gt;accept()   // net/ipv4/af_inet.c:734<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对于 TCP/IPv4 来说， <code>sk1-&gt;sk_prot-&gt;accept()</code> 实际调用的是 <code>net/ipv4/inet_connection_sock.c</code> 文件中的 <code>inet_csk_accept</code> 。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span><span class="token function">inet_csk_accept</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>err<span class="token punctuation">,</span> bool kern<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">reqsk_queue_empty</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> timeo <span class="token operator">=</span> <span class="token function">sock_rcvtimeo</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> flags <span class="token operator">&amp;</span> O_NONBLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* If this is a non blocking socket don't sleep */</span>        error <span class="token operator">=</span> <span class="token operator">-</span>EAGAIN<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timeo<span class="token punctuation">)</span>            <span class="token keyword">goto</span> out_err<span class="token punctuation">;</span>        <span class="token function">inet_csk_wait_for_connect</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> timeo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    req <span class="token operator">=</span> <span class="token function">reqsk_queue_remove</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> sk<span class="token punctuation">)</span><span class="token punctuation">;</span>    newsk <span class="token operator">=</span> req<span class="token operator">-&gt;</span>sk<span class="token punctuation">;</span>    <span class="token keyword">return</span> newsk<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>inet_csk_accept</code> 首先检查监听套接字上的连接队列是否为空，为空且设置了 <code>O_NONBLOCK</code> 标志的话就返回错误 <code>EAGAIN</code> ，否则就等待直到有连接到来。</p><h4 id="1-接收到SYN，发送SYN和ACK"><a href="#1-接收到SYN，发送SYN和ACK" class="headerlink" title="1. 接收到SYN，发送SYN和ACK"></a>1. 接收到SYN，发送SYN和ACK</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">tcp_v4_rcv                                          // net/ipv4/af_inet.c:1684    |- tcp_v4_do_rcv                                // net/ipv4/tcp_ipv4.c:1822        |- tcp_rcv_state_process                    // net/ipv4/tcp_ipv4.c:1569            |- icsk-&gt;icsk_af_ops-&gt;conn_request()    // net/ipv4/tcp_input.c:6051<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>对于 TCP/IPv4 来说，调用 <code>icsk-&gt;icsk_af_ops-&gt;conn_request()</code> 其实是调用 <code>net/ipv4/tcp_ipv4.c</code> 文件中的 <code>tcp_v4_conn_request</code>：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">tcp_v4_conn_request                                 // net/ipv4/tcp_ipv4.c:1935    |- tcp_conn_request                             // net/ipv4/tcp_ipv4.c:1397        |- inet_reqsk_alloc                         // net/ipv4/tcp_input.c:6461            |- ireq-&gt;ireq_state = TCP_NEW_SYN_RECV  // net/ipv4/tcp_input.c:6374        |- af_ops-&gt;send_synack()                    // net/ipv4/tcp_input.c:6556<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在连接请求处理函数 <code>tcp_conn_request</code> 中，首先把新分配的套接字的 <code>request_sock</code> 设置为 <code>TCP_NEW_SYN_RECV</code> 状态。然后调用 <code>af_ops-&gt;send_synack()</code> 来发送 SYN 和 ACK 。对于 TCP/IPv4 来说，调用 <code>af_ops-&gt;send_synack()</code> 其实是调用 <code>net/ipv4/tcp_ipv4.c</code> 文件中的 <code>tcp_v4_send_synack</code> 。而函数 <code>tcp_v4_send_synack</code> 做的也确实是发送一个带有 SYN 和 ACK 标志的包。</p><h4 id="2-接收到ACK"><a href="#2-接收到ACK" class="headerlink" title="2. 接收到ACK"></a>2. 接收到ACK</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">tcp_v4_rcv                                              // net/ipv4/af_inet.c:1684    |- tcp_check_req                                    // net/ipv4/tcp_ipv4.c:1773        |- inet_csk(sk)-&gt;icsk_af_ops-&gt;syn_recv_sock()   // net/ipv4/tcp_minisocks.c:789        |- inet_csk_complete_hashdance                  // net/ipv4/tcp_minisocks.c:797    |- tcp_child_process                                // net/ipv4/tcp_ipv4.c:1792<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>对于 TCP/IPv4 来说，调用 <code>inet_csk(sk)-&gt;icsk_af_ops-&gt;syn_recv_sock()</code> 其实是调用 <code>net/ipv4/tcp_ipv4.c</code> 文件中的 <code>tcp_v4_syn_recv_sock</code>：</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">tcp_v4_syn_recv_sock                                    // net/ipv4/tcp_ipv4.c:1936    |- tcp_create_openreq_child                         // net/ipv4/tcp_ipv4.c:1429        |- inet_csk_clone_lock                          // net/ipv4/tcp_minisocks.c:452            |- inet_sk_set_state(newsk, TCP_SYN_RECV)   // net/ipv4/inet_connection_sock.c:829<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 需要注意的是，新创建的套接字的状态为 <code>TCP_SYN_RECV</code> 。</p></li><li><p>函数 <code>inet_csk_complete_hashdance</code> 主要做的是将请求控制块从未完成连接队列中删除，加入到已完成连接队列中：</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">inet_csk_complete_hashdance                 // net/ipv4/tcp_minisocks.c:797    |- inet_csk_reqsk_queue_drop            // net/ipv4/inet_connection_sock.c:992        |- reqsk_queue_unlink               // net/ipv4/inet_connection_sock.c:703    |- inet_csk_reqsk_queue_add             // net/ipv4/inet_connection_sock.c:994<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>函数 <code>tcp_child_process</code> 进一步对新创建的套接字进行处理并把状态更新为 <code>TCP_ESTABLISHED</code> ：</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">tcp_child_process                               // net/ipv4/tcp_ipv4.c:1792    |- tcp_rcv_state_process                    // net/ipv4/tcp_minisocks.c:851        |- tcp_set_state(sk, TCP_ESTABLISHED)   // net/ipv4/tcp_input.c:6132<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="5-close"><a href="#5-close" class="headerlink" title="5. close"></a>5. close</h3><h4 id="1-发送FIN"><a href="#1-发送FIN" class="headerlink" title="1. 发送FIN"></a>1. 发送FIN</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">tcp_close                                               // net/ipv4/tcp_ipv4.c:2458    |- tcp_close_state                                  // net/ipv4/tcp.c:2393        |- tcp_set_state(sk, ns)                        // net/ipv4/tcp.c:2294    |- tcp_send_fin                                     // net/ipv4/tcp.c:2423        |- TCP_SKB_CB(tskb)-&gt;tcp_flags |= TCPHDR_FIN    // net/ipv4/tcp_output.c:3087    |- sk_stream_wait_close                             // net/ipv4/tcp.c:2426<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于状态是 <code>TCP_ESTABLISHED</code> 的套接字，函数 <code>tcp_close_state</code> 会把套接字的状态更新为 <code>TCP_FIN_WAIT1</code> 。 <code>tcp_send_fin</code> 函数则发送带有 FIN 标记的包给对方。</p><h4 id="2-接收ACK"><a href="#2-接收ACK" class="headerlink" title="2. 接收ACK"></a>2. 接收ACK</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">tcp_v4_rcv                                              // net/ipv4/af_inet.c:1684    |- tcp_v4_do_rcv                                    // net/ipv4/tcp_ipv4.c:1832        |- tcp_rcv_state_process                        // net/ipv4/tcp_ipv4.c:1569            |- tcp_set_state(sk, TCP_FIN_WAIT2)         // net/ipv4/tcp_input.c:6175<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-等待FIN并发送ACK"><a href="#3-等待FIN并发送ACK" class="headerlink" title="3. 等待FIN并发送ACK"></a>3. 等待FIN并发送ACK</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">tcp_v4_rcv                                                      // net/ipv4/af_inet.c:1684    |- tcp_v4_do_rcv                                            // net/ipv4/tcp_ipv4.c:1832        |- tcp_rcv_state_process                                // net/ipv4/tcp_ipv4.c:1569            |- tcp_data_queue                                   // net/ipv4/tcp_input.c:6262                |- tcp_fin                                      // net/ipv4/tcp_input.c:4756                    |- tcp_send_ack(sk)                         // net/ipv4/tcp_input.c:4139                    |- tcp_time_wait(TCP_TIME_WAIT)             // net/ipv4/tcp_input.c:4140                        |- inet_twsk_alloc                      // net/ipv4/tcp_minisocks.c:259                            |- tw-&gt;tw_state = TCP_TIME_WAIT     // net/ipv4/inet_timewait_sock.c:175                            |- timer_setup(tw_timer_handler)    // net/ipv4/inet_timewait_sock.c:188                        |- inet_twsk_schedule()                 // net/ipv4/tcp_minisocks.c:319<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在函数 <code>tcp_fin</code> 中，发送了 ACK 后，并进入 <code>TCP_TIME_WAIT</code> 状态。同时注册一个超时的定时器。</p><blockquote><p>注意，虽然在 <code>inet_twsk_alloc</code> 函数中，修改的是 <code>tw-&gt;tw_state</code> 字段为 <code>TCP_TIME_WAIT</code> 状态。但是查看宏 <code>tw_state</code> 的定义可以知道，<code>tw_state</code> 指向的依旧是结构体 <code>sock_common</code> 中的字段 <code>skc_state</code> 。</p></blockquote><h3 id="6-shutdown"><a href="#6-shutdown" class="headerlink" title="6. shutdown"></a>6. shutdown</h3><p>调用流程如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">__sys_shutdown                                  // net/socket.c:1973    |- sock-&gt;ops-&gt;shutdown()                    // net/socket.c:1965<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对于 TCP/IPv4 来说，调用 <code>sock-&gt;ops-&gt;shutdown()</code> 其实是调用 <code>net/ipv4/tcp_ipv4.c</code> 文件中的 <code>tcp_shutdown</code>：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">tcp_shutdown</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">int</span> how<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>how <span class="token operator">&amp;</span> SEND_SHUTDOWN<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment">/* If we've already sent a FIN, or it's a closed state, skip this. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> sk<span class="token operator">-&gt;</span>sk_state<span class="token punctuation">)</span> <span class="token operator">&amp;</span>        <span class="token punctuation">(</span>TCPF_ESTABLISHED <span class="token operator">|</span> TCPF_SYN_SENT <span class="token operator">|</span>            TCPF_SYN_RECV <span class="token operator">|</span> TCPF_CLOSE_WAIT<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">/* Clear out any half completed packets.  FIN if needed. */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tcp_close_state</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">tcp_send_fin</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与调用 <code>close</code> 类似，</p><h2 id="四、IP层及以下层的工作"><a href="#四、IP层及以下层的工作" class="headerlink" title="四、IP层及以下层的工作"></a>四、IP层及以下层的工作</h2><h3 id="1-IP层发送包"><a href="#1-IP层发送包" class="headerlink" title="1. IP层发送包"></a>1. IP层发送包</h3><p>上层想要发送 IP 包，都会调用函数 <code>ip_local_out</code> 来发送。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">ip_local_out                            // include/net/ip.h:165    |- dst_output                       // net/ipv4/ip_output.c:125        |- skb_dst(skb)-&gt;output()       // include/net/dst.h:455<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对 IP 协议来说， <code>skb_dst(skb)-&gt;output()</code> 实际调用的是 <code>net/ipv4/ip_output.c</code> 文件中的 <code>ip_output</code> 函数。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">ip_output                               // net/ipv4/route.c:1636    |- ip_finish_output                 // net/ipv4/ip_output.c:408        |- ip_finish_output2            // net/ipv4/ip_output.c:318            |- neigh_output             // net/ipv4/ip_output.c:230                |- neigh_hh_output      // include/net/neighbour.h:499                    |- dev_queue_xmit   // include/net/neighbour.h:491<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用 <code>dev_queue_xmit</code> 是将 IP 包交给网络设备子系统来发送，而 <code>dev_queue_xmit</code> 直接调用的函数 <code>__dev_queue_xmit</code> 。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">dev_queue_xmit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">__dev_queue_xmit</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">__dev_queue_xmit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>sb_dev<span class="token punctuation">)</span><span class="token punctuation">{</span>    txq <span class="token operator">=</span> <span class="token function">netdev_pick_tx</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> sb_dev<span class="token punctuation">)</span><span class="token punctuation">;</span>    q <span class="token operator">=</span> <span class="token function">rcu_dereference_bh</span><span class="token punctuation">(</span>txq<span class="token operator">-&gt;</span>qdisc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token operator">-&gt;</span>enqueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">__dev_xmit_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> q<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> txq<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">goto</span> out<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/* The device has no queue. Common case for software devices:     * loopback, all the sorts of tunnels...     */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dev<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> IFF_UP<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">dev_hard_start_xmit</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> txq<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在函数 <code>__dev_queue_xmit</code> 内部：</p><ol><li><p>针对有发送队列的设备</p><p> 首先调用 <code>netdev_pick_tx</code> 选择一个发送队列（现在的网卡一般都支持多个发送队列），然后再调用 <code>__dev_xmit_skb</code> 进行发送。在经过层层调用后，最后会调用的函数 <code>dev_hard_start_xmit</code> 发送包。</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">|- __dev_xmit_skb                               // net/core/dev.c:3807    |- q-&gt;enqueue(skb, q, &amp;to_free)             // net/core/dev.c:3450    |- qdisc_run                                // net/core/dev.c:3451        |- __qdisc_run                          // include/net/pkt_sched.h:120            |- qdisc_restart                    // net/sched/sch_generic.c:403                |- sch_direct_xmit              // net/sched/sch_generic.c:395                    |- dev_hard_start_xmit      // net/sched/sch_generic.c:332<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 需要注意函数 <code>__qdisc_run</code> 的实现：</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">__qdisc_run</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Qdisc</span> <span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> quota <span class="token operator">=</span> dev_tx_weight<span class="token punctuation">;</span>    <span class="token keyword">int</span> packets<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">qdisc_restart</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> <span class="token operator">&amp;</span>packets<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">/*        * Ordered by possible occurrence: Postpone processing if        * 1. we've exceeded packet quota        * 2. another process needs the CPU;        */</span>        quota <span class="token operator">-=</span> packets<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>quota <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">need_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">__netif_schedule</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 如果系统态 CPU 发送网络包不够用的时候，会调用函数 <code>__netif_schedule</code> 进而调用函数 <code>__netif_reschedule</code> 触发一个软中断 <code>NET_TX_SOFTIRQ</code> 。而对应的中断处理函数 <code>net_tx_action</code> 会重新调用 <code>qdisc_run</code> 继续发送剩余的网络包。</p></li><li><p>针对没有发送队列的设备</p><p> 如注释里说的回环地址，隧道网络等，就直接调用 <code>dev_hard_start_xmit</code> 发送包。</p></li></ol><p>所以，不管设备有无发送队列，最后都会调用函数 <code>dev_hard_start_xmit</code> ：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">|- dev_hard_start_xmit                      // net/core/dev.c:3262    |- xmit_one                             // net/core/dev.c:3272        |- netdev_start_xmit                // net/core/dev.c:3256            |- __netdev_start_xmit          // include/linux/netdevice.h:4359                |- ops-&gt;ndo_start_xmit      // include/linux/netdevice.h:4345<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在经过层层调用后，最后调用的 <code>ops-&gt;ndo_start_xmit()</code> 其实是各个网卡驱动的实现了。</p><h3 id="2-Intel的igb网卡驱动的发送流程"><a href="#2-Intel的igb网卡驱动的发送流程" class="headerlink" title="2. Intel的igb网卡驱动的发送流程"></a>2. Intel的igb网卡驱动的发送流程</h3><p>对网卡驱动 <code>drivers/net/ethernet/intel/igb</code> 来说， 函数 <code>ops-&gt;ndo_start_xmit</code> 调用的其实就是 <code>igb_netdev_ops</code> 中的 <code>ndo_start_xmit</code> 的值，即 <code>drivers/net/ethernet/intel/igb/igb_main.c</code> 文件中的 <code>igb_xmit_frame</code> 函数。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">igb_xmit_frame              // drivers/net/ethernet/intel/igb/igb_main.c:2865    |- igb_xmit_frame_ring  // drivers/net/ethernet/intel/igb/igb_main.c:6201        |- igb_tx_map       // drivers/net/ethernet/intel/igb/igb_main.c:6157<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>函数 <code>igb_tx_map</code> 做的主要的工作就是把网络包数据映射到 RAM 的 DMA 区域，然后唤醒设备发送数据。</p><h3 id="3-Intel的igb网卡驱动的初始化"><a href="#3-Intel的igb网卡驱动的初始化" class="headerlink" title="3. Intel的igb网卡驱动的初始化"></a>3. Intel的igb网卡驱动的初始化</h3><ol><li><p>模块加载</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">igb_init_module                                         // drivers/net/ethernet/intel/igb/igb_main.c:680    |- pci_register_driver(&amp;igb_driver)                 // drivers/net/ethernet/intel/igb/igb_main.c:676        |- __pci_register_driver                        // include/linux/pci.h:1289            |- driver_register                          // drivers/pci/pci-driver.c:1409                |- bus_add_driver                       // drivers/base/driver.c:170                    |- driver_attach                    // drivers/base/bus.c:672                        |- __driver_attach              // drivers/base/dd.c:922                            |- driver_probe_device      // drivers/base/dd.c:903                                |- really_probe         // drivers/base/dd.c:667                                    |- drv-&gt;probe(dev)  // drivers/base/dd.c:510<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 最后调用的 <code>drv-&gt;probe(dev)</code> 其实就是 <code>igb_driver</code> 中的 <code>probe</code> 的值，即 <code>drivers/net/ethernet/intel/igb/igb_main.c</code> 文件中的 <code>igb_probe</code> 函数。</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">igb_probe                                       // drivers/net/ethernet/intel/igb/igb_main.c:230    |- netdev-&gt;netdev_ops = &amp;igb_netdev_ops     // drivers/net/ethernet/intel/igb/igb_main.c:3095    |- igb_sw_init                              // drivers/net/ethernet/intel/igb/igb_main.c:3121        |- igb_init_interrupt_scheme            // drivers/net/ethernet/intel/igb/igb_main.c:3888            |- igb_alloc_q_vectors              // drivers/net/ethernet/intel/igb/igb_main.c:1387                |- igb_alloc_q_vector           // drivers/net/ethernet/intel/igb/igb_main.c:1331                    |- netif_napi_add(igb_poll) // drivers/net/ethernet/intel/igb/igb_main.c:1216                        |- napi-&gt;poll = poll    // net/core/dev.c:6194<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 对 Intel 的 igb 网卡来说，模块加载函数 <code>igb_probe</code> 做了：</p><ul><li>初始化了设备相关的操作回调函数信息 <code>igb_netdev_ops</code> 。</li><li>注册了 napi 的轮询回调函数 <code>igb_poll</code> 。</li></ul></li><li><p>启动设备</p><p> 在函数 <code>igb_probe</code> 中，通过语句 <code>netdev-&gt;netdev_ops = &amp;igb_netdev_ops</code> 初始化了网卡相关的操作回调。在网卡启用时，比如执行命令 <code>ifconfig eth0 up</code> 时，系统会依次调用：</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">dev_open                        // net/core/dev.c:1430    |- __dev_open               // net/core/dev.c:1437        |- ops-&gt;ndo_open(dev)   // net/core/dev.c:1402<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 对于网卡驱动 <code>drivers/net/ethernet/intel/igb</code> 来说，函数 <code>ops-&gt;ndo_open(dev)</code> 调用的就是函数 <code>igb_open</code> 。</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">igb_open                                        // drivers/net/ethernet/intel/igb/igb_main.c:2863    |- __igb_open                               // drivers/net/ethernet/intel/igb/igb_main.c:4017        |- igb_request_irq                      // drivers/net/ethernet/intel/igb/igb_main.c:3953            |- igb_request_msix                 // drivers/net/ethernet/intel/igb/igb_main.c:1416                |- request_irq(igb_msix_ring)   // drivers/net/ethernet/intel/igb/igb_main.c:968        |- igb_irq_enable(adapter)              // drivers/net/ethernet/intel/igb/igb_main.c:3978<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 在 <code>igb_open</code> 函数调用的深处，对于多队列网卡，通过 <code>request_irq(igb_msix_ring)</code> 为每个队列都注册了中断处理函数 <code>igb_msix_ring</code> 。设置好中断处理程序后，再调用 <code>igb_irq_enable(adapter)</code> 来开启中断。</p></li></ol><h3 id="4-Intel的igb网卡驱动的接收流程"><a href="#4-Intel的igb网卡驱动的接收流程" class="headerlink" title="4. Intel的igb网卡驱动的接收流程"></a>4. Intel的igb网卡驱动的接收流程</h3><p>当网卡的某个队列中收到网络数据后，会触发一个中断，这个中断的处理函数就是在启动设备时设置的 <code>igb_msix_ring</code> 函数：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">igb_msix_ring                                   // drivers/net/ethernet/intel/igb/igb_main.c:6621    |- napi_schedule                            // drivers/net/ethernet/intel/igb/igb_main.c:6628        |- __napi_schedule                      // include/linux/netdevice.h:445            |- ____napi_schedule                // net/core/dev.c:5892<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>网卡队列中断处理函数最深处的调用 <code>____napi_schedule</code> 主要做两件事：</p><ul><li>保存待处理的数据。</li><li>触发中断 <code>NET_RX_SOFTIRQ</code> 。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">____napi_schedule</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">softnet_data</span> <span class="token operator">*</span>sd<span class="token punctuation">,</span>                    <span class="token keyword">struct</span> <span class="token class-name">napi_struct</span> <span class="token operator">*</span>napi<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">list_add_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>napi<span class="token operator">-&gt;</span>poll_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sd<span class="token operator">-&gt;</span>poll_list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">__raise_softirq_irqoff</span><span class="token punctuation">(</span>NET_RX_SOFTIRQ<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而中断 <code>NET_RX_SOFTIRQ</code> 的处理函数是 <code>net_rx_action</code> ：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">net_rx_action           // net/core/dev.c:9874    |- napi_poll        // net/core/dev.c:6338        |- n-&gt;poll()    // net/core/dev.c:6272<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>中断处理函数 <code>net_rx_action</code> ，最终的会调用函数 <code>n-&gt;poll()</code> 。这函数就是网卡驱动模块加载时注册的处理回调函数 <code>igb_poll</code> ：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">igb_poll                                                // drivers/net/ethernet/intel/igb/igb_main.c:1216    |- igb_clean_rx_irq                                 // drivers/net/ethernet/intel/igb/igb_main.c:7759        |- napi_gro_receive                             // drivers/net/ethernet/intel/igb/igb_main.c:8408            |- napi_skb_finish                          // net/core/dev.c:5631                |- netif_receive_skb_internal           // net/core/dev.c:5600                    |- __netif_receive_skb              // net/core/dev.c:5156                        |- __netif_receive_skb_one_core // net/core/dev.c:5066                            |- __netif_receive_skb_core // net/core/dev.c:4952<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在函数 <code>__netif_receive_skb_core</code> 中：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">__netif_receive_skb_core</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span><span class="token operator">*</span>pskb<span class="token punctuation">,</span> bool pfmemalloc<span class="token punctuation">,</span>                    <span class="token keyword">struct</span> <span class="token class-name">packet_type</span> <span class="token operator">*</span><span class="token operator">*</span>ppt_prev<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">list_for_each_entry_rcu</span><span class="token punctuation">(</span>ptype<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ptype_all<span class="token punctuation">,</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pt_prev<span class="token punctuation">)</span>            ret <span class="token operator">=</span> <span class="token function">deliver_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> pt_prev<span class="token punctuation">,</span> orig_dev<span class="token punctuation">)</span><span class="token punctuation">;</span>        pt_prev <span class="token operator">=</span> ptype<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">list_for_each_entry_rcu</span><span class="token punctuation">(</span>ptype<span class="token punctuation">,</span> <span class="token operator">&amp;</span>skb<span class="token operator">-&gt;</span>dev<span class="token operator">-&gt;</span>ptype_all<span class="token punctuation">,</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pt_prev<span class="token punctuation">)</span>            ret <span class="token operator">=</span> <span class="token function">deliver_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> pt_prev<span class="token punctuation">,</span> orig_dev<span class="token punctuation">)</span><span class="token punctuation">;</span>        pt_prev <span class="token operator">=</span> ptype<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">deliver_ptype_list_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pt_prev<span class="token punctuation">,</span> orig_dev<span class="token punctuation">,</span> type<span class="token punctuation">,</span>                    <span class="token operator">&amp;</span>ptype_base<span class="token punctuation">[</span><span class="token function">ntohs</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token operator">&amp;</span>                        PTYPE_HASH_MASK<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一个循环 <code>list_for_each_entry_rcu(ptype, &amp;ptype_all, list)</code> 中的 <code>ptype_all</code> 是一个设备无关的保存有所有协议处理回调的地方，而第二个循环 <code>list_for_each_entry_rcu(ptype, &amp;skb-&gt;dev-&gt;ptype_all, list)</code> 中的 <code>skb-&gt;dev-&gt;ptype_all</code> 是一个设备有关的保存有所有协议处理回调的地方。这两个循环就能让像 tcpdump 这样的程序监听处理到收到的所有的网络包。</p><p>后面代码 <code>deliver_ptype_list_skb</code> 中的 <code>ptype_base</code> 是保存所有支持的3层协议处理函数的地方。才是将包转发给对应L3处理函数。函数 <code>deliver_ptype_list_skb</code> 的调用流程如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">deliver_ptype_list_skb      // net/core/dev.c:4905    |- deliver_skb          // net/core/dev.c:1971        |- pt_prev-&gt;func()  // net/core/dev.c:1956<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对于 IP 协议来说，其注册到 <code>ptype_base</code> 的流程如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">inet_init                               // net/ipv4/af_inet.c:1890    |- dev_add_pack(&amp;ip_packet_type)    // net/core/dev.c:408<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>dev_add_pack(&amp;ip_packet_type)</code> 函数内部就是把 <code>ip_packet_type</code> 添加到处理 <code>ETH_P_IP</code> 的协议链中。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">packet_type</span> ip_packet_type __read_mostly <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token function">cpu_to_be16</span><span class="token punctuation">(</span>ETH_P_IP<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span>func <span class="token operator">=</span> ip_rcv<span class="token punctuation">,</span>    <span class="token punctuation">.</span>list_func <span class="token operator">=</span> ip_list_rcv<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-接收IP包"><a href="#5-接收IP包" class="headerlink" title="5. 接收IP包"></a>5. 接收IP包</h3><p>所以对 IP 来说 <code>pt_prev-&gt;func()</code> 实际调用的是 <code>ip_rcv</code> 函数。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">ip_rcv                                  // ip_packet_type:1886    |- ip_rcv_finish                    // net/ipv4/ip_input.c:526        |- dst_input                    // net/ipv4/ip_input.c:414            |- skb_dst(skb)-&gt;input(skb) // include/net/dst.h:461<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>对 TCP/IPv4 来说 <code>skb_dst(skb)-&gt;input(skb)</code> 调用的其实是 <code>net/ipv4/ip_input.c</code> 文件中的 <code>ip_local_deliver</code> 。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">ip_local_deliver                // net/ipv4/route.c:1638    |- ip_local_deliver_finish  // net/ipv4/ip_input.c:258        |- ipprot-&gt;handler(skb) // net/ipv4/ip_input.c:215<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里调用的 <code>ipprot-&gt;handler(skb)</code> 就是传输层的处理回调了。 在文件 <code>net/ipv4/af_inet.c</code> 中的函数 <code>inet_init</code> 内初始化：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">inet_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">inet_add_protocol</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>icmp_protocol<span class="token punctuation">,</span> IPPROTO_ICMP<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">inet_add_protocol</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>udp_protocol<span class="token punctuation">,</span> IPPROTO_UDP<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">inet_add_protocol</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tcp_protocol<span class="token punctuation">,</span> IPPROTO_TCP<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">inet_add_protocol</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>igmp_protocol<span class="token punctuation">,</span> IPPROTO_IGMP<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="https://cloud.tencent.com/developer/article/1492374">Linux syscall过程分析（万字长文）</a><br><a href="https://xinqiu.gitbooks.io/linux-insides-cn/content/SysCall/linux-syscall-2.html">Linux 内核如何处理系统调用</a><br><a href="https://blog.packagecloud.io/eng/2017/02/06/monitoring-tuning-linux-networking-stack-sending-data/">Monitoring and Tuning the Linux Networking Stack: Sending Data</a><br><a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/">Monitoring and Tuning the Linux Networking Stack: Receiving Data</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> 内核分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《设计模式之美》学习笔记</title>
      <link href="she-ji-mo-shi-zhi-mei-xue-xi-bi-ji/"/>
      <url>she-ji-mo-shi-zhi-mei-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/《设计模式之美》学习笔记/编写高质量代码.png" alt="编写高质量代码"></p><h2 id="设计原则与思想"><a href="#设计原则与思想" class="headerlink" title="设计原则与思想"></a>设计原则与思想</h2><h3 id="一、代码质量评判标准"><a href="#一、代码质量评判标准" class="headerlink" title="一、代码质量评判标准"></a>一、代码质量评判标准</h3><h4 id="如何评价代码质量的高低？"><a href="#如何评价代码质量的高低？" class="headerlink" title="如何评价代码质量的高低？"></a>如何评价代码质量的高低？</h4><p>代码质量的评价有很强的主观性，描述代码质量的词汇也有很多，比如可读性、可维护性、灵活、优雅、简洁。这些词汇是从不同的维度去评价代码质量的。它们之间有互相作用，并不是独立的，比如，代码的可读性好、可扩展性好就意味着代码的可维护性好。代码质量高低是一个综合各种因素得到的结论。我们并不能通过单一维度去评价一段代码的好坏。</p><h4 id="最常用的评价标准有哪几个？"><a href="#最常用的评价标准有哪几个？" class="headerlink" title="最常用的评价标准有哪几个？"></a>最常用的评价标准有哪几个？</h4><p>最常用到几个评判代码质量的标准有：可维护性、可读性、可扩展性、灵活性、简洁性、可复用性、可测试性。其中，可维护性、可读性、可扩展性又是提到最多的、最重要的三个评价标准。</p><h4 id="如何才能写出高质量的代码？"><a href="#如何才能写出高质量的代码？" class="headerlink" title="如何才能写出高质量的代码？"></a>如何才能写出高质量的代码？</h4><p>要写出高质量代码，我们就需要掌握一些更加细化、更加能落地的编程方法论，这就包含面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等。</p><p><img src="/images/《设计模式之美》学习笔记/代码质量评判标准.jpg" alt="代码质量评判标准"></p><h3 id="二、面向对象"><a href="#二、面向对象" class="headerlink" title="二、面向对象"></a>二、面向对象</h3><h4 id="1-面向对象概述"><a href="#1-面向对象概述" class="headerlink" title="1. 面向对象概述"></a>1. 面向对象概述</h4><p>现在，主流的编程范式或者编程风格有三种，它们分别是面向过程、面向对象和函数式编程。面向对象这种编程风格又是这其中最主流的。现在比较流行的编程语言大部分都是面向对象编程语言。大部分项目也都是基于面向对象编程风格开发的。面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式编码实现的基础。</p><h4 id="2-面向对象四大特性"><a href="#2-面向对象四大特性" class="headerlink" title="2. 面向对象四大特性"></a>2. 面向对象四大特性</h4><p>封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方法来访问内部信息或者数据。它需要编程语言提供权限访问控制语法来支持，例如 Java 中的 private、protected、public 关键字。封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。</p><p>如果说封装主要讲如何隐藏信息、保护数据，那抽象就是讲如何隐藏方法的具体实现，让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。抽象可以通过接口类或者抽象类来实现。抽象存在的意义，一方面是修改实现不需要改变定义；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。</p><p>继承用来表示类之间的 is-a 关系，分为两种模式：单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类。为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持。继承主要是用来解决代码复用的问题。</p><p>多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类、duck-typing。多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。</p><h4 id="3-面向对象-VS-面向过程"><a href="#3-面向对象-VS-面向过程" class="headerlink" title="3. 面向对象 VS 面向过程"></a>3. 面向对象 VS 面向过程</h4><p>面向对象编程相比面向过程编程的优势主要有三个。</p><ul><li>对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。</li><li>面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利用这些特性编写出来的代码，更加易扩展、易复用、易维护。</li><li>从编程语言跟机器打交道方式的演进规律中，我们可以总结出：面向对象编程语言比起面向过程编程语言，更加人性化、更加高级、更加智能。</li></ul><p>面向对象编程一般使用面向对象编程语言来进行，但是，不用面向对象编程语言，我们照样可以进行面向对象编程。反过来讲，即便我们使用面向对象编程语言，写出来的代码也不一定是面向对象编程风格的，也有可能是面向过程编程风格的。</p><p>面向对象和面向过程两种编程风格并不是非黑即白、完全对立的。在用面向对象编程语言开发的软件中，面向过程风格的代码并不少见，甚至在一些标准的开发库（比如 JDK、Apache Commons、Google Guava）中，也有很多面向过程风格的代码。</p><p>不管使用面向过程还是面向对象哪种风格来写代码，我们最终的目的还是写出易维护、易读、易复用、易扩展的高质量代码。只要我们能避免面向过程编程风格的一些弊端，控制好它的副作用，在掌控范围内为我们所用，我们就大可不用避讳在面向对象编程中写面向过程风格的代码。</p><h4 id="4-面向对象分析、设计与编程"><a href="#4-面向对象分析、设计与编程" class="headerlink" title="4. 面向对象分析、设计与编程"></a>4. 面向对象分析、设计与编程</h4><p>面向对象分析（OOA）、面向对象设计（OOD）、面向对象编程（OOP），是面向对象开发的三个主要环节。简单点讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做，面向对象编程就是将分析和设计的的结果翻译成代码的过程。</p><p>需求分析的过程实际上是一个不断迭代优化的过程。我们不要试图一下就给出一个完美的解决方案，而是先给出一个粗糙的、基础的方案，有一个迭代的基础，然后再慢慢优化。这样一个思考过程能让我们摆脱无从下手的窘境。</p><p>面向对象设计和实现要做的事情就是把合适的代码放到合适的类中。至于到底选择哪种划分方法，判定的标准是让代码尽量地满足“松耦合、高内聚”、单一职责、对扩展开放对修改关闭等我们之前讲到的各种设计原则和思想，尽量地做到代码可复用、易读、易扩展、易维护。</p><p>面向对象分析的产出是详细的需求描述。面向对象设计的产出是类。在面向对象设计这一环节中，我们将需求描述转化为具体的类的设计。这个环节的工作可以拆分为下面四个部分。</p><ul><li><p>划分职责进而识别出有哪些类</p><p>  根据需求描述，我们把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否归为同一个类。</p></li><li><p>定义类及其属性和方法</p><p>  我们识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选出真正的方法，把功能点中涉及的名词，作为候选属性，然后同样再进行过滤筛选。</p></li><li><p>定义类与类之间的交互关系</p><p>  UML 统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。我们从更加贴近编程的角度，对类与类之间的关系做了调整，保留了四个关系：泛化、实现、组合、依赖。</p></li><li><p>将类组装起来并提供执行入口</p><p>  我们要将所有的类组装在一起，提供一个执行入口。这个入口可能是一个 main() 函数，也可能是一组给外部用的 API 接口。通过这个入口，我们能触发整个代码跑起来。</p></li></ul><h4 id="5-接口-VS-抽象类"><a href="#5-接口-VS-抽象类" class="headerlink" title="5. 接口 VS 抽象类"></a>5. 接口 VS 抽象类</h4><p>抽象类不允许被实例化，只能被继承。它可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法。接口不能包含属性（Java 可以定义静态常量），只能声明方法，方法不能包含代码实现（Java8 以后可以有默认实现）。类实现接口的时候，必须实现接口中声明的所有方法。</p><p>抽象类是对成员变量和方法的抽象，是一种 is-a 关系，是为了解决代码复用问题。接口仅仅是对方法的抽象，是一种 has-a 关系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。</p><p>什么时候该用抽象类？什么时候该用接口？实际上，判断的标准很简单。如果要表示一种 is-a 的关系，并且是为了解决代码复用问题，我们就用抽象类；如果要表示一种 has-a 关系，并且是为了解决抽象而非代码复用问题，那我们就用接口。</p><h4 id="6-基于接口而非实现编程"><a href="#6-基于接口而非实现编程" class="headerlink" title="6. 基于接口而非实现编程"></a>6. 基于接口而非实现编程</h4><p>应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。</p><p>实际上，“基于接口而非实现编程”这条原则的另一个表述方式是，“基于抽象而非实现编程”。后者的表述方式其实更能体现这条原则的设计初衷。在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。</p><p>越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。</p><h4 id="7-多用组合少用继承"><a href="#7-多用组合少用继承" class="headerlink" title="7. 多用组合少用继承"></a>7. 多用组合少用继承</h4><ul><li><p>为什么不推荐使用继承？</p><p>  继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。在这种情况下，我们应该尽量少用，甚至不用继承。</p></li><li><p>组合相比继承有哪些优势？</p><p>  继承主要有三个作用：表示 is-a 关系、支持多态特性、代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。</p></li><li><p>如何判断该用组合还是继承？</p><p>  尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。在实际的项目开发中，我们还是要根据具体的情况，来选择该用继承还是组合。如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。</p></li></ul><h4 id="8-贫血模型-VS-充血模型"><a href="#8-贫血模型-VS-充血模型" class="headerlink" title="8. 贫血模型 VS 充血模型"></a>8. 贫血模型 VS 充血模型</h4><p>我们平时做 Web 项目的业务开发，大部分都是基于贫血模型的 MVC 三层架构，在专栏中我把它称为传统的开发模式。之所以称之为“传统”，是相对于新兴的基于充血模型的 DDD 开发模式来说的。基于贫血模型的传统开发模式，是典型的面向过程的编程风格。相反，基于充血模型的 DDD 开发模式，是典型的面向对象的编程风格。</p><p>不过，DDD 也并非银弹。对于业务不复杂的系统开发来说，基于贫血模型的传统开发模式简单够用，基于充血模型的 DDD 开发模式有点大材小用，无法发挥作用。相反，对于业务复杂的系统开发来说，基于充血模型的 DDD 开发模式，因为前期需要在设计上投入更多时间和精力，来提高代码的复用性和可维护性，所以相比基于贫血模型的开发模式，更加有优势。</p><p>基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，主要区别在 Service 层。在基于充血模型的开发模式下，我们将部分原来在 Service 类中的业务逻辑移动到了一个充血的 Domain 领域模型中，让 Service 类的实现依赖这个 Domain 类。不过，Service 类并不会完全移除，而是负责一些不适合放在 Domain 类中的功能。比如，负责与 Repository 层打交道、跨领域模型的业务聚合功能、幂等事务等非功能性的工作。</p><p>基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，Controller 层和 Repository 层的代码基本上相同。这是因为，Repository 层的 Entity 生命周期有限，Controller 层的 VO 只是单纯作为一种 DTO。两部分的业务逻辑都不会太复杂。业务逻辑主要集中在 Service 层。所以，Repository 层和 Controller 层继续沿用贫血模型的设计思路是没有问题的。</p><p><img src="/images/《设计模式之美》学习笔记/面向对象.jpg" alt="面向对象"></p><h3 id="三、设计原则"><a href="#三、设计原则" class="headerlink" title="三、设计原则"></a>三、设计原则</h3><h4 id="1-SOLID-原则：SRP-单一职责原则"><a href="#1-SOLID-原则：SRP-单一职责原则" class="headerlink" title="1. SOLID 原则：SRP 单一职责原则"></a>1. SOLID 原则：SRP 单一职责原则</h4><p>一个类只负责完成一个职责或者功能。单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、松耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。</p><p>不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。实际上，一些侧面的判断指标更具有指导意义和可执行性，比如，出现下面这些情况就有可能说明这类的设计不满足单一职责原则：</p><ul><li>类中的代码行数、函数或者属性过多；</li><li>类依赖的其他类过多或者依赖类的其他类过多；</li><li>私有方法过多；</li><li>比较难给类起一个合适的名字；</li><li>类中大量的方法都是集中操作类中的某几个属性。</li></ul><h4 id="2-SOLID-原则：OCP-开闭原则"><a href="#2-SOLID-原则：OCP-开闭原则" class="headerlink" title="2. SOLID 原则：OCP 开闭原则"></a>2. SOLID 原则：OCP 开闭原则</h4><ul><li><p>如何理解“对扩展开放、修改关闭”？</p><p>  添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。关于定义，我们有两点要注意。第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。</p></li><li><p>如何做到“对扩展开放、修改关闭”？</p><p>  我们要时刻具备扩展意识、抽象意识、封装意识。在写代码的时候，我们要多花点时间思考一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活地插入到扩展点上。</p><p>  很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是 23 种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。</p></li></ul><h4 id="3-SOLID-原则：LSP-里式替换原则"><a href="#3-SOLID-原则：LSP-里式替换原则" class="headerlink" title="3. SOLID 原则：LSP 里式替换原则"></a>3. SOLID 原则：LSP 里式替换原则</h4><p>子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</p><p>里式替换原则是用来指导继承关系中子类该如何设计的一个原则。理解里式替换原则，最核心的就是理解“design by contract，按照协议来设计”这几个字。父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数的原有“约定”。这里的“约定”包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。</p><p>理解这个原则，我们还要弄明白，里式替换原则跟多态的区别。虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。</p><h4 id="4-SOLID-原则：ISP-接口隔离原则"><a href="#4-SOLID-原则：ISP-接口隔离原则" class="headerlink" title="4. SOLID 原则：ISP 接口隔离原则"></a>4. SOLID 原则：ISP 接口隔离原则</h4><p>接口隔离原则的描述是：客户端不应该强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。理解“接口隔离原则”的重点是理解其中的“接口”二字。这里有三种不同的理解。</p><p>如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。</p><p>如果把“接口”理解为单个 API 接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。</p><p>如果把“接口”理解为 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。</p><p>单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考的角度也是不同的。接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p><h4 id="5-SOLID-原则：DIP-依赖倒置原则"><a href="#5-SOLID-原则：DIP-依赖倒置原则" class="headerlink" title="5. SOLID 原则：DIP 依赖倒置原则"></a>5. SOLID 原则：DIP 依赖倒置原则</h4><p><strong>控制反转：</strong>实际上，控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计。这里所说的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。</p><p><strong>依赖注入：</strong>依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或“注入”）给类来使用。</p><p><strong>依赖注入框架：</strong>我们通过依赖注入框架提供的扩展点，简单配置一下所有需要的类及其类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。</p><p><strong>依赖反转原则：</strong>依赖反转原则也叫作依赖倒置原则。这条原则跟控制反转有点类似，主要用来指导框架层面的设计。高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不需要依赖具体实现细节，具体实现细节依赖抽象。</p><h4 id="6-KISS、YAGNI-原则"><a href="#6-KISS、YAGNI-原则" class="headerlink" title="6. KISS、YAGNI 原则"></a>6. KISS、YAGNI 原则</h4><p>KISS 原则的中文描述是：尽量保持简单。KISS 原则是保持代码可读和可维护的重要手段。KISS 原则中的“简单“”并不是以代码行数来考量的。代码行数越少并不代表代码越简单，我们还要考虑逻辑复杂度、实现难度、代码的可读性等。而且，本身就复杂的问题，用复杂的方法解决，也并不违背 KISS 原则。除此之外，同样的代码，在某个业务场景下满足 KISS 原则，换一个应用场景可能就不满足了。</p><p>对于如何写出满足 KISS 原则的代码，我总结了下面几条指导原则：</p><ul><li>不要使用同事可能不懂的技术来实现代码；</li><li>不要重复造轮子，善于使用已经有的工具类库；</li><li>不要过度优化。</li></ul><p>YAGNI 原则的英文全称是：You Ain’t Gonna Need It。直译就是：你不会需要它。这条原则也算是万金油了。当用在软件开发中的时候，它的意思是：不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。</p><p>YAGNI 原则跟 KISS 原则并非一回事儿。KISS 原则讲的是“如何做”的问题（尽量保持简单），而 YAGNI 原则说的是“要不要做”的问题（当前不需要的就不要做）。</p><h4 id="7-DRY-原则"><a href="#7-DRY-原则" class="headerlink" title="7. DRY 原则"></a>7. DRY 原则</h4><p>DRY 原则中文描述是：不要重复自己，将它应用在编程中，可以理解为：不要写重复的代码。</p><p>专栏中讲到了三种代码重复的情况：实现逻辑重复、功能语义重复、代码执行重复。实现逻辑重复，但功能语义不重复的代码，并不违反 DRY 原则。实现逻辑不重复，但功能语义重复的代码，也算是违反 DRY 原则。而代码执行重复也算是违反 DRY 原则。</p><p>除此之外，我们还讲到了提高代码复用性的一些手段，包括：减少代码耦合、满足单一职责原则、模块化、业务与非业务逻辑分离、通用代码下沉、继承、多态、抽象、封装、应用模板等设计模式。复用意识也非常重要。在设计每个模块、类、函数的时候，要像设计一个外部 API 一样去思考它的复用性。</p><p>我们在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，那我们就不需要考虑代码的复用性。在之后开发新的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码，让其变得更加可复用。</p><p>相比于代码的可复用性，DRY 原则适用性更强些。我们可以不写可复用的代码，但一定不能写重复的代码。</p><h4 id="8-LOD-原则"><a href="#8-LOD-原则" class="headerlink" title="8. LOD 原则"></a>8. LOD 原则</h4><ul><li><p>如何理解“高内聚、松耦合”？</p><p>  “高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。所谓“松耦合”指的是，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动。</p></li><li><p>如何理解“迪米特法则”？</p><p>  迪米特法则的描述为：不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。</p></li></ul><p><img src="/images/《设计模式之美》学习笔记/设计原则.jpg" alt="设计原则"></p><h3 id="四、规范与重构"><a href="#四、规范与重构" class="headerlink" title="四、规范与重构"></a>四、规范与重构</h3><h4 id="1-重构概述"><a href="#1-重构概述" class="headerlink" title="1. 重构概述"></a>1. 重构概述</h4><ul><li><p>重构的目的：为什么重构（why）？</p><p>  对于项目来言，重构可以保持代码质量持续处于一个可控状态，不至于腐化到无可救药的地步。对于个人而言，重构非常锻炼一个人的代码能力，并且是一件非常有成就感的事情。它是我们学习的经典设计思想、原则、模式、编程规范等理论知识的练兵场。</p></li><li><p>重构的对象：重构什么（what）？</p><p>  按照重构的规模，我们可以将重构大致分为大规模高层次的重构和小规模低层次的重构。大规模高层次重构包括对代码分层、模块化、解耦、梳理类之间的交互关系、抽象复用组件等等。这部分工作利用的更多的是比较抽象、比较顶层的设计思想、原则、模式。小规模低层次的重构包括规范命名、注释、修正函数参数过多、消除超大类、提取重复代码等编程细节问题，主要是针对类、函数级别的重构。小规模低层次的重构更多的是利用编码规范这一理论知识。</p></li><li><p>重构的时机：什么时候重构（when）？</p><p>  我反复强调，我们一定要建立持续重构意识，把重构作为开发必不可少的部分融入到开发中，而不是等到代码出现很大问题的时候，再大刀阔斧地重构。</p></li><li><p>重构的方法：如何重构（how）？</p><p>  大规模高层次的重构难度比较大，需要有组织、有计划地进行，分阶段地小步快跑，时刻保持代码处于一个可运行的状态。而小规模低层次的重构，因为影响范围小，改动耗时短，所以，只要你愿意并且有时间，随时随地都可以去做。</p></li></ul><h4 id="2-单元测试"><a href="#2-单元测试" class="headerlink" title="2. 单元测试"></a>2. 单元测试</h4><ul><li><p>什么是单元测试？</p><p>  单元测试是代码层面的测试，用于测试“自己”编写的代码的逻辑正确性。单元测试顾名思义是测试一个“单元”，这个“单元”一般是类或函数，而不是模块或者系统。</p></li><li><p>为什么要写单元测试？</p><p>  单元测试能有效地发现代码中的 Bug、代码设计上的问题。写单元测试的过程本身就是代码重构的过程。单元测试是对集成测试的有力补充，能帮助我们快速熟悉代码，是 TDD 可落地执行的折中方案。</p></li><li><p>如何编写单元测试？</p><p>  写单元测试就是针对代码设计覆盖各种输入、异常、边界条件的测试用例，并将其翻译成代码的过程。我们可以利用一些测试框架来简化测试代码的编写。对于单元测试，我们需要建立以下正确的认知：</p><ol><li>编写单元测试尽管繁琐，但并不是太耗时；</li><li>我们可以稍微放低单元测试的质量要求；</li><li>覆盖率作为衡量单元测试好坏的唯一标准是不合理的；</li><li>写单元测试一般不需要了解代码的实现逻辑；</li><li>单元测试框架无法测试多半是代码的可测试性不好。</li></ol></li><li><p>单元测试为何难落地执行？</p><p>  一方面，写单元测试本身比较繁琐，技术挑战不大，很多程序员不愿意去写。另一方面，国内研发比较偏向“快糙猛”，容易因为开发进度紧，导致单元测试的执行虎头蛇尾，最后，没有建立对单元测试的正确认识，觉得可有可无，单靠督促很难执行得很好。</p></li></ul><h4 id="3-代码的可测试性"><a href="#3-代码的可测试性" class="headerlink" title="3. 代码的可测试性"></a>3. 代码的可测试性</h4><ul><li><p>什么是代码的可测试性？</p><p>  粗略地讲，所谓代码的可测试性，就是针对代码编写单元测试的难易程度。对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很费劲，需要依靠单元测试框架很高级的特性，那往往就意味着代码设计得不够合理，代码的可测试性不好。</p></li><li><p>编写可测试性代码的最有效手段</p><p>  依赖注入是编写可测试性代码的最有效手段。通过依赖注入，我们在编写单元测试代码的时候，可以通过 mock 的方法将不可控的依赖变得可控，这也是我们在编写单元测试的过程中最有技术挑战的地方。除了 mock 方式，我们还可以利用二次封装来解决某些代码行为不可控的情况。</p></li><li><p>常见的 Anti-Patterns典型的、常见的测试不友好的代码有下面这 5 种：</p><ol><li>代码中包含未决行为逻辑；</li><li>滥用可变全局变量；</li><li>滥用静态方法；</li><li>使用复杂的继承关系；</li><li>高度耦合的代码。</li></ol></li></ul><h4 id="4-大型重构：解耦"><a href="#4-大型重构：解耦" class="headerlink" title="4. 大型重构：解耦"></a>4. 大型重构：解耦</h4><ul><li><p>“解耦”为何如此重要？</p><p>  过于复杂的代码往往在可读性、可维护性上都不友好。解耦，保证代码松耦合、高内聚，是控制代码复杂度的有效手段。如果代码高内聚、松耦合，也就是意味着，代码结构清晰、分层、模块化合理、依赖关系简单、模块或类之间的耦合小，那代码整体的质量就不会差。</p></li><li><p>代码是否需要“解耦”？</p><p>  间接的衡量标准有很多，比如：改动一个模块或类的代码受影响的模块或类是否有很多、改动一个模块或者类的代码依赖的模块或者类是否需要改动、代码的可测试性是否好等等。直接的衡量标准是把模块与模块之间及其类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构。</p></li><li><p>如何给代码“解耦”？</p><p>  给代码解耦的方法有：封装与抽象、中间层、模块化，以及一些其他的设计思想与原则，比如：单一职责原则、基于接口而非实现编程、依赖注入、多用组合少用继承、迪米特法则。当然，还有一些设计模式，比如观察者模式。</p></li></ul><h4 id="5-小型重构：编码规范"><a href="#5-小型重构：编码规范" class="headerlink" title="5. 小型重构：编码规范"></a>5. 小型重构：编码规范</h4><p>前面我们讲了很多设计原则，后面还会讲到很多设计模式，利用好它们都可以有效地改善代码的质量。但是，这些知识的合理应用非常依赖个人经验，有时候用不好会适得其反。但是编码规范正好相反，大部分都简单明了，在代码的细节方面，能立竿见影地改善质量。除此之外，我们前面也讲到，持续低层次小规模重构依赖的基本上都是这些编码规范，也是改善代码可读性的有效手段。</p><p>根据我自己的开发经验，我总结罗列了 20 条我认为最应该关注、最好用的编码规范，分为三个大的方面：命名与注释（Naming and Comments）、代码风格（Code Style）、编程技巧（Coding Tips）。</p><ul><li><p>命名与注释</p><ol><li>命名的关键是能准确的达意。对于不同作用域的命名，我们可以适当的选择不同的长度，作用域小的命名，比如临时变量等，可以适当的选择短一些的命名方式。除此之外，命名中个也可以使用一些耳熟能详的缩写。</li><li>我们借助类的信息来简化属性、函数的命名，利用函数的信息来简化函数参数的命名。</li><li>命名要可读、可搜索。不要使用生僻的、不好读的英文单词来命名。除此之外，命名要符合项目的统一规范，也不要用些反直觉的命名。</li><li>接口有两种命名方式。一种是在接口中带前缀”I”，另一种是在接口的实现类中带后缀“Impl”。两种命名方式都可以，关键是要在项目中统一。对于抽象类的命名，我们更倾向于带有前缀“Abstract”。</li><li>注释的目的就是让代码更容易看懂，只要符合这个要求，你就可以写。总结一下的话，注释主要包含这样三个方面的内容：做什么、为什么、怎么做。对于一些复杂的类和接口，我们可能还需要写明“如何用”。</li><li>注释本身有一定的维护成本，所以并非越多越好。类和函数一定要写注释，而且要写的尽可能全面详细些，而函数内部的注释会相对少一些，一般都是靠好的命名和提炼函数、解释性变量、总结性注释来做到代码易读。</li></ol></li><li><p>代码风格</p><p>  代码风格都没有对错和优劣之分，不同的编程语言风格都不太一样，只要能在团队、项目中统一即可，不过，最好能跟业内推荐的风格、开源项目的代码风格相一致。所以，这里就不展开罗列了，你可以对照着自己熟悉的编程语言的代码风格，自己复习一下。</p></li><li><p>编程技巧</p><ol><li>将复杂的逻辑提炼拆分成函数和类；</li><li>通过拆分成多个函数的方式来处理参数过多的情况；</li><li>通过将参数封装为对象来处理参数过多的情况；</li><li>函数中不要使用参数来做代码执行逻辑的控制；</li><li>移除过深的嵌套层次，方法包括：去掉多余的 if 或 else 语句，使用 continue、break、return 关键字提前退出嵌套，调整执行顺序来减少嵌套，将部分嵌套逻辑抽象成函数；</li><li>用字面常量取代魔法数；</li><li>利用解释性变量来解释复杂表达式。</li></ol></li><li><p>统一编码规范</p><p>  除了细节的知识点之外，最后，还有一条非常重要的，那就是，项目、团队，甚至公司，一定要制定统一的编码规范，并且通过 Code Review 督促执行，这对提高代码质量有立竿见影的效果。</p></li></ul><p><img src="/images/《设计模式之美》学习笔记/规范与重构.jpg" alt="规范与重构"></p><h2 id="设计模式与范式"><a href="#设计模式与范式" class="headerlink" title="设计模式与范式"></a>设计模式与范式</h2><h3 id="一、创建型设计模式"><a href="#一、创建型设计模式" class="headerlink" title="一、创建型设计模式"></a>一、创建型设计模式</h3><p>创建型设计模式包括：单例模式、工厂模式、建造者模式、原型模式。它主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。</p><h4 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1. 单例模式"></a>1. 单例模式</h4><p>单例模式用来创建全局唯一的对象。一个类只允许创建一个对象（或者叫实例），那这个类就是一个单例类，这种设计模式就叫作单例模式。单例有几种经典的实现方式，它们分别是：饿汉式、懒汉式、双重检测、静态内部类、枚举。</p><p>尽管单例是一个很常用的设计模式，在实际的开发中，我们也确实经常用到它，但是，有些人认为单例是一种反模式（anti-pattern），并不推荐使用，主要的理由有以下几点：</p><ul><li>单例对 OOP 特性的支持不友好</li><li>单例会隐藏类之间的依赖关系</li><li>单例对代码的扩展性不友好</li><li>单例对代码的可测试性不友好</li><li>单例不支持有参数的构造函数</li></ul><p>那有什么替代单例的解决方案呢？如果要完全解决这些问题，我们可能要从根上寻找其他方式来实现全局唯一类。比如，通过工厂模式、IOC 容器来保证全局唯一性。</p><p>有人把单例当作反模式，主张杜绝在项目中使用。我个人觉得这有点极端。模式本身没有对错，关键看你怎么用。如果单例类并没有后续扩展的需求，并且不依赖外部系统，那设计成单例类就没有太大问题。对于一些全局类，我们在其他地方 new 的话，还要在类之间传来传去，不如直接做成单例类，使用起来简洁方便。</p><p>除此之外，我们还讲到了进程唯一单例、线程唯一单例、集群唯一单例、多例等扩展知识点，这一部分在实际的开发中并不会被用到，但是可以扩展你的思路、锻炼你的逻辑思维。这里我就不带你回顾了，你可以自己回忆一下。</p><h4 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2. 工厂模式"></a>2. 工厂模式</h4><p>工厂模式包括简单工厂、工厂方法、抽象工厂这 3 种细分模式。其中，简单工厂和工厂方法比较常用，抽象工厂的应用场景比较特殊，所以很少用到，不是我们学习的重点。</p><p>工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。实际上，如果创建对象的逻辑并不复杂，那我们直接通过 new 来创建对象就可以了，不需要使用工厂模式。当创建逻辑比较复杂，是一个“大工程”的时候，我们就考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离。</p><p>当每个对象的创建逻辑都比较简单的时候，我推荐使用简单工厂模式，将多个对象的创建逻辑放到一个工厂类中。当每个对象的创建逻辑都比较复杂的时候，为了避免设计一个过于庞大的工厂类，我们推荐使用工厂方法模式，将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中。</p><p>详细点说，工厂模式的作用有下面 4 个，这也是判断要不要使用工厂模式最本质的参考标准。</p><ul><li>封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。</li><li>代码复用：创建代码抽离到独立的工厂类之后可以复用。</li><li>隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。</li><li>控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。</li></ul><p>除此之外，我们还讲了工厂模式一个非常经典的应用场景：依赖注入框架，比如 Spring IOC、Google Guice，它用来集中创建、组装、管理对象，跟具体业务代码解耦，让程序员聚焦在业务代码的开发上。DI 框架已经成为了我们平时开发的必备框架，在专栏中，我还带你实现了一个简单的 DI 框架，你可以再回过头去看看。</p><h4 id="3-建造者模式"><a href="#3-建造者模式" class="headerlink" title="3. 建造者模式"></a>3. 建造者模式</h4><p>建造者模式用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。建造者模式的原理和实现比较简单，重点是掌握应用场景，避免过度使用。</p><p>如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，我们可以通过构造函数配合 set() 方法来解决。但是，如果存在下面情况中的任意一种，我们就要考虑使用建造者模式了。</p><ul><li>我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填属性通过 set() 方法设置，那校验这些必填属性是否已经填写的逻辑就无处安放了。</li><li>如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合 set() 方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。</li><li>如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露 set() 方法。构造函数配合 set() 方法来设置属性值的方式就不适用了。</li></ul><h4 id="4-原型模式"><a href="#4-原型模式" class="headerlink" title="4. 原型模式"></a>4. 原型模式</h4><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式，来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型模式。</p><p>原型模式有两种实现方法，深拷贝和浅拷贝。浅拷贝只会复制对象中基本数据类型数据和引用对象的内存地址，不会递归地复制引用对象，以及引用对象的引用对象……而深拷贝得到的是一份完完全全独立的对象。所以，深拷贝比起浅拷贝来说，更加耗时，更加耗内存空间。</p><p>如果要拷贝的对象是不可变对象，浅拷贝共享不可变对象是没问题的，但对于可变对象来说，浅拷贝得到的对象和原始对象会共享部分数据，就有可能出现数据被修改的风险，也就变得复杂多了。操作非常耗时的情况下，我们比较推荐使用浅拷贝，否则，没有充分的理由，不要为了一点点的性能提升而使用浅拷贝。</p><h3 id="二、结构型设计模式"><a href="#二、结构型设计模式" class="headerlink" title="二、结构型设计模式"></a>二、结构型设计模式</h3><p>结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。结构型模式包括：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。</p><h4 id="1-代理模式"><a href="#1-代理模式" class="headerlink" title="1. 代理模式"></a>1. 代理模式</h4><p>代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。一般情况下，我们让代理类和原始类实现同样的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式。</p><p>静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板式的“重复”代码，增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动态代理来解决。我们不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。</p><p>代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。除此之外，代理模式还可以用在 RPC、缓存等应用场景中。</p><h4 id="2-桥接模式"><a href="#2-桥接模式" class="headerlink" title="2. 桥接模式"></a>2. 桥接模式</h4><p>桥接模式的代码实现非常简单，但是理解起来稍微有点难度，并且应用场景也比较局限，所以，相对来说，桥接模式在实际的项目中并没有那么常用，你只需要简单了解，见到能认识就可以了，并不是我们学习的重点。</p><p>桥接模式有两种理解方式。第一种理解方式是“将抽象和实现解耦，让它们能独立开发”。这种理解方式比较特别，应用场景也不多。另一种理解方式更加简单，等同于“组合优于继承”设计原则，这种理解方式更加通用，应用场景比较多。不管是哪种理解方式，它们的代码结构都是相同的，都是一种类之间的组合关系。</p><p>对于第一种理解方式，弄懂定义中“抽象”和“实现”两个概念，是理解它的关键。定义中的“抽象”，指的并非“抽象类”或“接口”，而是被抽象出来的一套“类库”，它只包含骨架代码，真正的业务逻辑需要委派给定义中的“实现”来完成。而定义中的“实现”，也并非“接口的实现类”，而是的一套独立的“类库”。“抽象”和“实现”独立开发，通过对象之间的组合关系组装在一起。</p><h4 id="3-装饰器模式"><a href="#3-装饰器模式" class="headerlink" title="3. 装饰器模式"></a>3. 装饰器模式</h4><p>装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承，给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据。除此之外，装饰器模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。为了满足这样的需求，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。</p><h4 id="4-适配器模式"><a href="#4-适配器模式" class="headerlink" title="4. 适配器模式"></a>4. 适配器模式</h4><p>代理模式、装饰器模式提供的都是跟原始类相同的接口，而适配器提供跟原始类不同的接口。适配器模式是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</p><p>适配器模式是一种事后的补救策略，用来补救设计上的缺陷。应用这种模式算是“无奈之举”。如果在设计初期，我们就能规避接口不兼容的问题，那这种模式就无用武之地了。在实际的开发中，什么情况下才会出现接口不兼容呢？我总结下了下面这 5 种场景：</p><ul><li>封装有缺陷的接口设计</li><li>统一多个类的接口设计</li><li>替换依赖的外部系统</li><li>兼容老版本接口</li><li>适配不同格式的数据</li></ul><h4 id="5-门面模式"><a href="#5-门面模式" class="headerlink" title="5. 门面模式"></a>5. 门面模式</h4><p>门面模式原理、实现都非常简单，应用场景比较明确。它通过封装细粒度的接口，提供组合各个细粒度接口的高层次接口，来提高接口的易用性，或者解决性能、分布式事务等问题。</p><h4 id="6-组合模式"><a href="#6-组合模式" class="headerlink" title="6. 组合模式"></a>6. 组合模式</h4><p>组合模式跟我们之前讲的面向对象设计中的“组合关系（通过组合来组装两个类）”，完全是两码事。这里讲的“组合模式”，主要是用来处理树形结构数据。正因为其应用场景的特殊性，数据必须能表示成树形结构，这也导致了这种模式在实际的项目开发中并不那么常用。但是，一旦数据满足树形结构，应用这种模式就能发挥很大的作用，能让代码变得非常简洁。</p><p>组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。组合模式，将一组对象组织成树形结构，将单个对象和组合对象都看作树中的节点，以统一处理逻辑，并且它利用树形结构的特点，递归地处理每个子树，依次简化代码实现。</p><h4 id="7-享元模式"><a href="#7-享元模式" class="headerlink" title="7. 享元模式"></a>7. 享元模式</h4><p>所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。</p><p>具体来讲，当一个系统中存在大量重复对象的时候，我们就可以利用享元模式，将对象设计成享元，在内存中只保留一份实例，供多处代码引用，这样可以减少内存中对象的数量，以起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段），提取出来设计成享元，让这些大量相似对象引用这些享元。</p><h3 id="三、行为型设计模式"><a href="#三、行为型设计模式" class="headerlink" title="三、行为型设计模式"></a>三、行为型设计模式</h3><p>我们知道，创建型设计模式主要解决“对象的创建”问题，结构型设计模式主要解决“类或对象的组合”问题，那行为型设计模式主要解决的就是“类或对象之间的交互”问题。行为型模式比较多，有 11 种，它们分别是：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式、访问者模式、备忘录模式、命令模式、解释器模式、中介模式。</p><h4 id="1-观察者模式"><a href="#1-观察者模式" class="headerlink" title="1. 观察者模式"></a>1. 观察者模式</h4><p>观察者模式将观察者和被观察者代码解耦。观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观察者模式。</p><p>不同的应用场景和需求下，这个模式也有截然不同的实现方式：有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。同步阻塞是最经典的实现方式，主要是为了代码解耦；异步非阻塞除了能实现代码解耦之外，还能提高代码的执行效率；进程间的观察者模式解耦更加彻底，一般是基于消息队列来实现，用来实现不同进程间的被观察者和观察者之间的交互。</p><p>框架的作用有隐藏实现细节，降低开发难度，实现代码复用，解耦业务与非业务代码，让程序员聚焦业务开发。针对异步非阻塞观察者模式，我们也可以将它抽象成 EventBus 框架来达到这样的效果。EventBus 翻译为“事件总线”，它提供了实现观察者模式的骨架代码。我们可以基于此框架非常容易地在自己的业务场景中实现观察者模式，不需要从零开始开发。</p><h4 id="2-模板模式"><a href="#2-模板模式" class="headerlink" title="2. 模板模式"></a>2. 模板模式</h4><p>模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。这里的“算法”，我们可以理解为广义上的“业务逻辑”，并不特指数据结构和算法中的“算法”。这里的算法骨架就是“模板”，包含算法骨架的方法就是“模板方法”，这也是模板方法模式名字的由来。</p><p>模板模式有两大作用：复用和扩展。其中复用指的是，所有的子类可以复用父类中提供的模板方法的代码。扩展指的是，框架通过模板模式提供功能扩展点，让框架用户可以在不修改框架源码的情况下，基于扩展点定制化框架的功能。</p><p>除此之外，我们还讲到回调。它跟模板模式具有相同的作用：代码复用和扩展。在一些框架、类库、组件等的设计中经常会用到，比如 JdbcTemplate 就是用了回调。</p><p>相对于普通的函数调用，回调是一种双向调用关系。A 类事先注册某个函数 F 到 B 类，A 类在调用 B 类的 P 函数的时候，B 类反过来调用 A 类注册给它的 F 函数。这里的 F 函数就是“回调函数”。A 调用 B，B 反过来又调用 A，这种调用机制就叫作“回调”。</p><p>回调可以细分为同步回调和异步回调。从应用场景上来看，同步回调看起来更像模板模式，异步回调看起来更像观察者模式。回调跟模板模式的区别，更多的是在代码实现上，而非应用场景上。回调基于组合关系来实现，模板模式基于继承关系来实现。回调比模板模式更加灵活。</p><h4 id="3-策略模式"><a href="#3-策略模式" class="headerlink" title="3. 策略模式"></a>3. 策略模式</h4><p>策略模式定义一组算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。策略模式用来解耦策略的定义、创建、使用。实际上，一个完整的策略模式就是由这三个部分组成的。</p><p>策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。策略的创建由工厂类来完成，封装策略创建的细节。策略模式包含一组策略可选，客户端代码选择使用哪个策略，有两种确定方法：编译时静态确定和运行时动态确定。其中，“运行时动态确定”才是策略模式最典型的应用场景。</p><p>在实际的项目开发中，策略模式也比较常用。最常见的应用场景是，利用它来避免冗长的 if-else 或 switch 分支判断。不过，它的作用还不止如此。它也可以像模板模式那样，提供框架的扩展点等等。实际上，策略模式主要的作用还是解耦策略的定义、创建和使用，控制代码的复杂度，让每个部分都不至于过于复杂、代码量过多。除此之外，对于复杂代码来说，策略模式还能让其满足开闭原则，添加新策略的时候，最小化、集中化代码改动，减少引入 bug 的风险。</p><h4 id="4-职责链模式"><a href="#4-职责链模式" class="headerlink" title="4. 职责链模式"></a>4. 职责链模式</h4><p>在职责链模式中，多个处理器依次处理同一个请求。一个请求先经过 A 处理器处理，然后再把请求传递给 B 处理器，B 处理器处理完后再传递给 C 处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式。</p><p>在 GoF 的定义中，一旦某个处理器能处理这个请求，就不会继续将请求传递给后续的处理器了。当然，在实际的开发中，也存在对这个模式的变体，那就是请求不会中途终止传递，而是会被所有的处理器都处理一遍。</p><p>职责链模式常用在框架开发中，用来实现过滤器、拦截器功能，让框架的使用者在不需要修改框架源码的情况下，添加新的过滤、拦截功能。这也体现了之前讲到的对扩展开放、对修改关闭的设计原则。</p><h4 id="5-迭代器模式"><a href="#5-迭代器模式" class="headerlink" title="5. 迭代器模式"></a>5. 迭代器模式</h4><p>迭代器模式也叫游标模式，它用来遍历集合对象。这里说的“集合对象”，我们也可以叫“容器”“聚合对象”，实际上就是包含一组对象的对象，比如，数组、链表、树、图、跳表。迭代器模式主要作用是解耦容器代码和遍历代码。大部分编程语言都提供了现成的迭代器可以使用，我们不需要从零开始开发。</p><p>遍历集合一般有三种方式：for 循环、foreach 循环、迭代器遍历。后两种本质上属于一种，都可以看作迭代器遍历。相对于 for 循环遍历，利用迭代器来遍历有 3 个优势：</p><ul><li>迭代器模式封装集合内部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器提供的迭代器即可；</li><li>迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一；</li><li>迭代器模式让添加新的遍历算法更加容易，更符合开闭原则。除此之外，因为迭代器都实现自相同的接口，在开发中，基于接口而非实现编程，替换迭代器也变得更加容易。</li></ul><p>在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。针对这个问题，有两种比较干脆利索的解决方案，来避免出现这种不可预期的运行结果。一种是遍历的时候不允许增删元素，另一种是增删元素之后让遍历报错。第一种解决方案比较难实现，因为很难确定迭代器使用结束的时间点。第二种解决方案更加合理，Java 语言就是采用的这种解决方案。增删元素之后，我们选择 fail-fast 解决方式，让遍历操作直接抛出运行时异常。</p><h4 id="6-状态模式"><a href="#6-状态模式" class="headerlink" title="6. 状态模式"></a>6. 状态模式</h4><p>状态模式一般用来实现状态机，而状态机常用在游戏、工作流引擎等系统开发中。状态机又叫有限状态机，它由 3 个部分组成：状态、事件、动作。其中，事件也称为转移条件。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作。</p><p>针对状态机，我们总结了三种实现方式。</p><ul><li>第一种实现方式叫分支逻辑法。利用 if-else 或者 switch-case 分支逻辑，参照状态转移图，将每一个状态转移原模原样地直译成代码。对于简单的状态机来说，这种实现方式最简单、最直接，是首选。</li><li>第二种实现方式叫查表法。对于状态很多、状态转移比较复杂的状态机来说，查表法比较合适。通过二维数组来表示状态转移图，能极大地提高代码的可读性和可维护性。</li><li>第三种实现方式就是利用状态模式。对于状态并不多、状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能比较复杂的状态机来说，我们首选这种实现方式。</li></ul><h4 id="7-访问者模式"><a href="#7-访问者模式" class="headerlink" title="7. 访问者模式"></a>7. 访问者模式</h4><p>访问者模式允许一个或者多个操作应用到一组对象上，设计意图是解耦操作和对象本身，保持类职责单一、满足开闭原则以及应对代码的复杂性。</p><p>对于访问者模式，学习的主要难点在代码实现。而代码实现比较复杂的主要原因是，函数重载在大部分面向对象编程语言中是静态绑定的。也就是说，调用类的哪个重载函数，是在编译期间，由参数的声明类型决定的，而非运行时，根据参数的实际类型决定的。除此之外，我们还讲到 Double Disptach。如果某种语言支持 Double Dispatch，那就不需要访问者模式了。</p><p>正是因为代码实现难理解，所以，在项目中应用这种模式，会导致代码的可读性比较差。如果你的同事不了解这种设计模式，可能就会读不懂、维护不了你写的代码。所以，除非不得已，不要使用这种模式。</p><h4 id="8-备忘录模式"><a href="#8-备忘录模式" class="headerlink" title="8. 备忘录模式"></a>8. 备忘录模式</h4><p>备忘录模式也叫快照模式，具体来说，就是在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。这个模式的定义表达了两部分内容：一部分是，存储副本以便后期恢复；另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复。</p><p>备忘录模式的应用场景也比较明确和有限，主要用来防丢失、撤销、恢复等。它跟平时我们常说的“备份”很相似。两者的主要区别在于，备忘录模式更侧重于代码的设计和实现，备份更侧重架构设计或产品设计。</p><p>对于大对象的备份来说，备份占用的存储空间会比较大，备份和恢复的耗时会比较长。针对这个问题，不同的业务场景有不同的处理方式。比如，只备份必要的恢复信息，结合最新的数据来恢复；再比如，全量备份和增量备份相结合，低频全量备份，高频增量备份，两者结合来做恢复。</p><h4 id="9-命令模式"><a href="#9-命令模式" class="headerlink" title="9. 命令模式"></a>9. 命令模式</h4><p>命令模式在平时工作中并不常用，你稍微了解一下就可以。</p><p>落实到编码实现，命令模式用到最核心的实现手段，就是将函数封装成对象。我们知道，在大部分编程语言中，函数是没法作为参数传递给其他函数的，也没法赋值给变量。借助命令模式，我们将函数封装成对象，这样就可以实现把函数像对象一样使用。</p><p>命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等，这才是命令模式能发挥独一无二作用的地方。</p><h4 id="10-解释器模式"><a href="#10-解释器模式" class="headerlink" title="10. 解释器模式"></a>10. 解释器模式</h4><p>解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。实际上，这里的“语言”不仅仅指我们平时说的中、英、日、法等各种语言。从广义上来讲，只要是能承载信息的载体，我们都可以称之为“语言”，比如，古代的结绳记事、盲文、哑语、摩斯密码等。</p><p>要想了解“语言”要表达的信息，我们就必须定义相应的语法规则。这样，书写者就可以根据语法规则来书写“句子”（专业点的叫法应该是“表达式”），阅读者根据语法规则来阅读“句子”，这样才能做到信息的正确传递。而我们要讲的解释器模式，其实就是用来实现根据语法规则解读“句子”的解释器。</p><p>解释器模式的代码实现比较灵活，没有固定的模板。我们前面说过，应用设计模式主要是应对代码的复杂性，解释器模式也不例外。它的代码实现的核心思想，就是将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆分一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。</p><h4 id="11-中介模式"><a href="#11-中介模式" class="headerlink" title="11. 中介模式"></a>11. 中介模式</h4><p>中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者说依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要跟 n 个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性。</p><p>观察者模式和中介模式都是为了实现参与者之间的解耦，简化交互关系。两者的不同在于应用场景上。在观察者模式的应用场景中，参与者之间的交互比较有条理，一般都是单向的，一个参与者只有一个身份，要么是观察者，要么是被观察者。而在中介模式的应用场景中，参与者之间的交互关系错综复杂，既可以是消息的发送者、也可以同时是消息的接收者。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 极客时间 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《一线数据库工程师带你深入理解MySQL》学习笔记</title>
      <link href="yi-xian-shu-ju-ku-gong-cheng-shi-dai-ni-shen-ru-li-jie-mysql-xue-xi-bi-ji/"/>
      <url>yi-xian-shu-ju-ku-gong-cheng-shi-dai-ni-shen-ru-li-jie-mysql-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<hr><p>第1章 SQL优化</p><h2 id="01-开篇词"><a href="#01-开篇词" class="headerlink" title="01 开篇词"></a><strong>01 开篇词</strong></h2><h3 id="3-提升-MySQL-水平的方式"><a href="#3-提升-MySQL-水平的方式" class="headerlink" title="3 提升 MySQL 水平的方式"></a>3 提升 MySQL 水平的方式</h3><p>如果你没有 MySQL 的基础，建议可以看下面两本书籍，看完之后，可以简单处理一些优化：</p><ul><li>《MySQL 必知必会》：主要讲 SQL 的写法；</li><li>《深入浅出 MySQL》：比较全面的讲解了 MySQL 的基础知识，也涉及了一些优化。</li></ul><p>如果已经对 MySQL 比较熟悉了，可以看下面的书籍，你会对索引和锁以及事务等有全新的看法：</p><ul><li>《高性能 MySQL》：里面讲了很多 MySQL 优化技巧；</li><li>《MySQL 技术内幕》：讲解了很多 MySQL 原理，强力推荐给想深入学习 MySQL 的同学；</li><li>《MySQL 内核：InnoDB 存储引擎》：想深入研究 MySQL 内核及原理的可以看看；</li><li>《MySQL 运维内参》：对 MySQL 源码感兴趣，可以入手；</li><li>《MySQL Internals Manual》<a href="https://dev.mysql.com/doc/internals/en/">https://dev.mysql.com/doc/internals/en/</a> ；</li><li>《MySQL 5.7 Reference Manual》<a href="https://dev.mysql.com/doc/refman/5.7/en/">https://dev.mysql.com/doc/refman/5.7/en/</a> 。</li></ul><h3 id="4-学习本专栏前的提醒"><a href="#4-学习本专栏前的提醒" class="headerlink" title="4 学习本专栏前的提醒"></a>4 学习本专栏前的提醒</h3><p><strong>本专栏默认使用的 MySQL 版本为 5.7.21，事务隔离级别为 RR，表的存储引擎为 InnoDB。</strong></p><h2 id="02-快速学会分析SQL执行效率（上）"><a href="#02-快速学会分析SQL执行效率（上）" class="headerlink" title="02 快速学会分析SQL执行效率（上）"></a><strong>02 快速学会分析SQL执行效率（上）</strong></h2><h3 id="1-定位慢-SQL"><a href="#1-定位慢-SQL" class="headerlink" title="1 定位慢 SQL"></a>1 定位慢 SQL</h3><h4 id="1-1-通过慢查询日志"><a href="#1-1-通过慢查询日志" class="headerlink" title="1.1 通过慢查询日志"></a>1.1 通过慢查询日志</h4><p>MySQL 的慢查询日志用来记录在 MySQL 中响应时间超过参数 long_query_time（单位秒，默认值 10）设置的值并且扫描记录数不小于 min_examined_row_limit（默认值0）的语句。</p><blockquote><p>默认情况下，慢查询日志中不会记录管理语句，可通过设置 log_slow_admin_statements = on 让管理语句中的慢查询也会记录到慢查询日志中。</p><p>默认情况下，也不会记录查询时间不超过 long_query_time 但是不使用索引的语句，可通过配置log_queries_not_using_indexes = on 让不使用索引的 SQL 都被记录到慢查询日志中（即使查询时间没超过 long_query_time 配置的值）。</p></blockquote><p>使用慢查询日志，一般分为三步：</p><ol><li><p>开启慢查询日志</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">set</span> <span class="token keyword">global</span> slow_query_log <span class="token operator">=</span> <span class="token keyword">on</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>设置慢查询阀值</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">set</span> <span class="token keyword">global</span> long_query_time <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>确定慢查询日志路径</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">global</span> variables <span class="token operator">like</span> <span class="token string">"datadir"</span><span class="token punctuation">;</span> <span class="token comment">/* 慢查询日志的目录 */</span><span class="token keyword">show</span> <span class="token keyword">global</span> variables <span class="token operator">like</span> <span class="token string">"slow_query_log_file"</span><span class="token punctuation">;</span>  <span class="token comment">/* 慢查询日志的文件名 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h4 id="1-2-通过-show-processlist"><a href="#1-2-通过-show-processlist" class="headerlink" title="1.2 通过 show processlist"></a>1.2 通过 show processlist</h4><p>有时慢查询正在执行，已经导致数据库负载偏高了，而由于慢查询还没执行完，因此慢查询日志还看不到任何语句。此时可以使用 <code>show processlist</code> 命令判断正在执行的慢查询。 <code>show processlist</code> 显示哪些线程正在运行。如果有 PROCESS 权限，则可以看到所有线程。否则，只能看到当前会话的线程。</p><blockquote><p>如果不使用 FULL 关键字，在 info 字段中只显示每个语句的前 100 个字符，如果想看语句的全部内容可以使用 full 修饰（<code>show full processlist</code>）。</p></blockquote><h3 id="2-使用-explain-分析慢查询"><a href="#2-使用-explain-分析慢查询" class="headerlink" title="2 使用 explain 分析慢查询"></a>2 使用 explain 分析慢查询</h3><p>为了便于理解，先创建两张测试表</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> muke<span class="token punctuation">;</span>           <span class="token comment">/* 创建测试使用的database，名为muke */</span><span class="token keyword">use</span> muke<span class="token punctuation">;</span>                       <span class="token comment">/* 使用muke这个database */</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t1<span class="token punctuation">;</span>        <span class="token comment">/* 如果表t1存在则删除表t1 */</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t1<span class="token punctuation">`</span> <span class="token punctuation">(</span>             <span class="token comment">/* 创建表t1 */</span>    <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">auto_increment</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>create_time<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'记录创建时间'</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>update_time<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'记录更新时间'</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_a<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_b<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>b<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">procedure</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> insert_t1<span class="token punctuation">;</span> <span class="token comment">/* 如果存在存储过程insert_t1，则删除 */</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">procedure</span> insert_t1<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">/* 创建存储过程insert_t1 */</span><span class="token keyword">begin</span>    <span class="token keyword">declare</span> i <span class="token keyword">int</span><span class="token punctuation">;</span>                    <span class="token comment">/* 声明变量i */</span>    <span class="token keyword">set</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>                          <span class="token comment">/* 设置i的初始值为1 */</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token keyword">do</span>                  <span class="token comment">/* 对满足i&lt;=1000的值进行while循环 */</span>        <span class="token keyword">insert</span> <span class="token keyword">into</span> t1<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 写入表t1中a、b两个字段，值都为i当前的值 */</span>        <span class="token keyword">set</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                      <span class="token comment">/* 将i加1 */</span>    <span class="token keyword">end</span> <span class="token keyword">while</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span>                 <span class="token comment">/* 创建批量写入1000条数据到表t1的存储过程insert_t1 */</span><span class="token keyword">call</span> insert_t1<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">/* 运行存储过程insert_t1 */</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t2<span class="token punctuation">;</span>    <span class="token comment">/* 如果表t2存在则删除表t2 */</span><span class="token keyword">create</span> <span class="token keyword">table</span> t2 <span class="token operator">like</span> t1<span class="token punctuation">;</span>    <span class="token comment">/* 创建表t2，表结构与t1一致 */</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t2 <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1<span class="token punctuation">;</span>   <span class="token comment">/* 将表t1的数据导入到t2 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面尝试使用 explain 分析一条 SQL，例子如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> b<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>得到</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref   | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+|  1 | SIMPLE      | t1    | NULL       | ref  | idx_b         | idx_b | 5       | const |    1 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Explain 的结果各字段解释如下（加粗的列为需要重点关注的项）：</p><div class="table-container"><table><thead><tr><th style="text-align:left">列名</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">id</td><td style="text-align:left">查询编号</td></tr><tr><td style="text-align:left"><strong>select_type</strong></td><td style="text-align:left">查询类型：显示本行是简单还是复杂查询</td></tr><tr><td style="text-align:left">table</td><td style="text-align:left">涉及到的表</td></tr><tr><td style="text-align:left">partitions</td><td style="text-align:left">匹配的分区：查询将匹配记录所在的分区。仅当使用 partition 关键字时才显示该列。对于非分区表，该值为 NULL。</td></tr><tr><td style="text-align:left"><strong>type</strong></td><td style="text-align:left">本次查询的表连接类型</td></tr><tr><td style="text-align:left">possible_keys</td><td style="text-align:left">可能选择的索引</td></tr><tr><td style="text-align:left"><strong>key</strong></td><td style="text-align:left">实际选择的索引</td></tr><tr><td style="text-align:left">key_len</td><td style="text-align:left">被选择的索引长度：一般用于判断联合索引有多少列被选择了</td></tr><tr><td style="text-align:left">ref</td><td style="text-align:left">与索引比较的列</td></tr><tr><td style="text-align:left"><strong>rows</strong></td><td style="text-align:left">预计需要扫描的行数，对 InnoDB 来说，这个值是估值，并不一定准确</td></tr><tr><td style="text-align:left">filtered</td><td style="text-align:left">按条件筛选的行的百分比</td></tr><tr><td style="text-align:left"><strong>Extra</strong></td><td style="text-align:left">附加信息</td></tr></tbody></table></div><p>这里介绍几个比较重要列常包含的值：</p><h4 id="2-1-select-type"><a href="#2-1-select-type" class="headerlink" title="2.1 select_type"></a>2.1 select_type</h4><div class="table-container"><table><thead><tr><th style="text-align:left">select_type 的值</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">SIMPLE</td><td style="text-align:left">简单查询(不使用关联查询或子查询)</td></tr><tr><td style="text-align:left">PRIMARY</td><td style="text-align:left">如果包含关联查询或者子查询，则最外层的查询部分标记为primary</td></tr><tr><td style="text-align:left">UNION</td><td style="text-align:left">联合查询中第二个及后面的查询</td></tr><tr><td style="text-align:left">DEPENDENT UNION</td><td style="text-align:left">满足依赖外部的关联查询中第二个及以后的查询</td></tr><tr><td style="text-align:left">UNION RESULT</td><td style="text-align:left">联合查询的结果</td></tr><tr><td style="text-align:left">SUBQUERY</td><td style="text-align:left">子查询中的第一个查询</td></tr><tr><td style="text-align:left">DEPENDENT SUBQUERY</td><td style="text-align:left">子查询中的第一个查询，并且依赖外部查询</td></tr><tr><td style="text-align:left">DERIVED</td><td style="text-align:left">用到派生表的查询</td></tr><tr><td style="text-align:left">MATERIALIZED</td><td style="text-align:left">被物化的子查询</td></tr><tr><td style="text-align:left">UNCACHEABLE SUBQUERY</td><td style="text-align:left">一个子查询的结果不能被缓存，必须重新评估外层查询的每一行</td></tr><tr><td style="text-align:left">UNCACHEABLE UNION</td><td style="text-align:left">关联查询第二个或后面的语句属于不可缓存的子查询</td></tr></tbody></table></div><h4 id="2-2-type"><a href="#2-2-type" class="headerlink" title="2.2 type"></a>2.2 type</h4><div class="table-container"><table><thead><tr><th style="text-align:left">type的值</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">system</td><td style="text-align:left">查询对象表只有一行数据,且只能用于 MyISAM 和 Memory 引擎的表，这是最好的情况</td></tr><tr><td style="text-align:left">const</td><td style="text-align:left">基于主键或唯一索引查询，最多返回一条结果</td></tr><tr><td style="text-align:left">eq_ref</td><td style="text-align:left">表连接时基于主键或非 NULL 的唯一索引完成扫描</td></tr><tr><td style="text-align:left">ref</td><td style="text-align:left">基于普通索引的等值查询，或者表间等值连接</td></tr><tr><td style="text-align:left">fulltext</td><td style="text-align:left">全文检索</td></tr><tr><td style="text-align:left">ref_or_null</td><td style="text-align:left">表连接类型是 ref，但进行扫描的索引列中可能包含 NULL 值</td></tr><tr><td style="text-align:left">index_merge</td><td style="text-align:left">利用多个索引</td></tr><tr><td style="text-align:left">unique_subquery</td><td style="text-align:left">子查询中使用唯一索引</td></tr><tr><td style="text-align:left">index_subquery</td><td style="text-align:left">子查询中使用普通索引</td></tr><tr><td style="text-align:left">range</td><td style="text-align:left">利用索引进行范围查询</td></tr><tr><td style="text-align:left">index</td><td style="text-align:left">全索引扫描</td></tr><tr><td style="text-align:left">ALL</td><td style="text-align:left">全表扫描</td></tr></tbody></table></div><blockquote><p><strong>上表的这些情况，查询性能从上到下依次是最好到最差。</strong></p></blockquote><h4 id="2-3-Extra"><a href="#2-3-Extra" class="headerlink" title="2.3 Extra"></a>2.3 Extra</h4><div class="table-container"><table><thead><tr><th style="text-align:left">Extra 常见的值</th><th style="text-align:left">解释</th><th style="text-align:left">例子</th></tr></thead><tbody><tr><td style="text-align:left">Using filesort</td><td style="text-align:left">将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序</td><td style="text-align:left">explain select * from t1 order by create_time;</td></tr><tr><td style="text-align:left">Using temporary</td><td style="text-align:left">需要创建一个临时表来存储结构，通常发生对没有索引的列进行 GROUP BY 时</td><td style="text-align:left">explain select * from t1 group by create_time;</td></tr><tr><td style="text-align:left">Using index</td><td style="text-align:left">使用覆盖索引</td><td style="text-align:left">explain select a from t1 where a=111;</td></tr><tr><td style="text-align:left">Using where</td><td style="text-align:left">使用 where 语句来处理结果</td><td style="text-align:left">explain select * from t1 where create_time=’2019-06-18 14:38:24’;</td></tr><tr><td style="text-align:left">Impossible WHERE</td><td style="text-align:left">对 where 子句判断的结果总是 false 而不能选择任何数据</td><td style="text-align:left">explain select * from t1 where 1&lt;0;</td></tr><tr><td style="text-align:left">Using join buffer (Block Nested Loop)</td><td style="text-align:left">关联查询中，被驱动表的关联字段没索引</td><td style="text-align:left">explain select * from t1 straight_join t2 on (t1.create_time=t2.create_time);</td></tr><tr><td style="text-align:left">Using index condition</td><td style="text-align:left">先条件过滤索引，再查数据</td><td style="text-align:left">explain select * from t1 where a &gt;900 and a like “%9”;</td></tr><tr><td style="text-align:left">Select tables optimized away</td><td style="text-align:left">使用某些聚合函数（比如 max、min）来访问存在索引的某个字段是</td><td style="text-align:left">explain select max(a) from t1;</td></tr></tbody></table></div><h2 id="03-快速学会分析SQL执行效率（下）"><a href="#03-快速学会分析SQL执行效率（下）" class="headerlink" title="03 快速学会分析SQL执行效率（下）"></a><strong>03 快速学会分析SQL执行效率（下）</strong></h2><h3 id="1-show-profile-分析慢查询"><a href="#1-show-profile-分析慢查询" class="headerlink" title="1 show profile 分析慢查询"></a>1 show profile 分析慢查询</h3><p>有时需要确定 SQL 到底慢在哪个环节，此时 explain 可能不好确定。在 MySQL 数据库中，通过 profile，能够更清楚地了解 SQL 执行过程的资源使用情况，能让我们知道到底慢在哪个环节。</p><blockquote><p>可以通过配置参数 profiling = 1 来启用 SQL 分析。该参数可以在全局和 session 级别来设置。</p></blockquote><p>使用 profile 分析慢查询的大致步骤如下：</p><h4 id="1-1-确定是否支持-profile"><a href="#1-1-确定是否支持-profile" class="headerlink" title="1.1 确定是否支持 profile"></a>1.1 确定是否支持 profile</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> @<span class="token variable">@have_profiling</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="1-2-查看-profiling-是否关闭的"><a href="#1-2-查看-profiling-是否关闭的" class="headerlink" title="1.2 查看 profiling 是否关闭的"></a>1.2 查看 profiling 是否关闭的</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> @<span class="token variable">@profiling</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="1-3-通过-set-开启-profile"><a href="#1-3-通过-set-开启-profile" class="headerlink" title="1.3 通过 set 开启 profile"></a>1.3 通过 set 开启 profile</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">set</span> profiling<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="1-4-执行-SQL-语句"><a href="#1-4-执行-SQL-语句" class="headerlink" title="1.4 执行 SQL 语句"></a>1.4 执行 SQL 语句</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> b<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="1-5-确定-SQL-的-query-id"><a href="#1-5-确定-SQL-的-query-id" class="headerlink" title="1.5 确定 SQL 的 query id"></a>1.5 确定 SQL 的 query id</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> profiles<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----------+------------+-------------------------------+| Query_ID | Duration   | Query                         |+----------+------------+-------------------------------+|        1 | 0.00982500 | select * from t1 where b=1000 |+----------+------------+-------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-6-查询-SQL-执行详情"><a href="#1-6-查询-SQL-执行详情" class="headerlink" title="1.6 查询 SQL 执行详情"></a>1.6 查询 SQL 执行详情</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> profile <span class="token keyword">for</span> query <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+--------------------------------+----------+| Status                         | Duration |+--------------------------------+----------+| starting                       | 0.001746 || Executing hook on transaction  | 0.000089 || starting                       | 0.000107 || checking permissions           | 0.000120 || Opening tables                 | 0.001553 || init                           | 0.000254 || System lock                    | 0.000276 || optimizing                     | 0.000291 || statistics                     | 0.002640 || preparing                      | 0.000235 || executing                      | 0.001847 || end                            | 0.000133 || query end                      | 0.000031 || waiting for handler commit     | 0.000090 || closing tables                 | 0.000110 || freeing items                  | 0.000242 || cleaning up                    | 0.000062 |+--------------------------------+----------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-trace-分析-SQL-优化器"><a href="#2-trace-分析-SQL-优化器" class="headerlink" title="2 trace 分析 SQL 优化器"></a>2 trace 分析 SQL 优化器</h3><p>从前面学到了 explain 可以查看 SQL 执行计划，但是无法知道它为什么做这个决策，如果想确定多种索引方案之间是如何选择的或者排序时选择的是哪种排序模式，可以使用 trace 查看优化器如何选择执行计划。</p><p>如果需要使用，先开启 trace，设置格式为 JSON，再执行需要分析的 SQL，最后查看 trace 分析结果（在 information_schema.OPTIMIZER_TRACE 中）。</p><p>开启该功能，会对 MySQL 性能有所影响，因此只建议分析问题时临时开启。</p><p>下面一起来看下 trace 的使用方法。使用讲解 explain 时创建的表t1做实验。</p><p>首先构造如下 SQL (表示取出表 t1 中 a 的值大于 900 并且 b 的值大于 910 的数据，然后按照 a 字段排序)：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> a <span class="token operator">&gt;</span><span class="token number">900</span> <span class="token operator">and</span> b <span class="token operator">&gt;</span> <span class="token number">910</span> <span class="token keyword">order</span>  <span class="token keyword">by</span> a<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们首先用 explain 分析下执行计划：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> a <span class="token operator">&gt;</span><span class="token number">900</span> <span class="token operator">and</span> b <span class="token operator">&gt;</span> <span class="token number">910</span> <span class="token keyword">order</span>  <span class="token keyword">by</span> a<span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+----------------------------------------------------+</span><span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span>  <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>   <span class="token operator">|</span> key_len <span class="token operator">|</span> ref  <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra                                              <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+----------------------------------------------------+</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> t1    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> range <span class="token operator">|</span> idx_a<span class="token punctuation">,</span>idx_b   <span class="token operator">|</span> idx_b <span class="token operator">|</span> <span class="token number">5</span>       <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span>   <span class="token number">90</span> <span class="token operator">|</span>    <span class="token number">10.00</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">index</span> condition<span class="token punctuation">;</span> <span class="token keyword">Using</span> <span class="token keyword">where</span><span class="token punctuation">;</span> <span class="token keyword">Using</span> filesort <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+----------------------------------------------------+</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上面执行计划中 key 这个字段可以看出，该语句使用的是 b 字段的索引 idx_b。实际表 t1 中，a、b 两个字段都有索引，为什么条件中有这两个索引字段却偏偏选了 b 字段的索引呢？这时就可以使用 trace 进行分析。大致步骤如下：</p><ol><li><p>开启 trace</p>  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">/* optimizer_trace="enabled=on" 表示开启 trace；end_markers_in_json=on 表示 JSON 输出开启结束标记 */</span><span class="token keyword">set</span> <span class="token keyword">session</span> optimizer_trace<span class="token operator">=</span><span class="token string">"enabled=on"</span><span class="token punctuation">,</span>end_markers_in_json<span class="token operator">=</span><span class="token keyword">on</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>执行需要分析的 SQL</p>  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> a <span class="token operator">&gt;</span><span class="token number">900</span> <span class="token operator">and</span> b <span class="token operator">&gt;</span> <span class="token number">910</span> <span class="token keyword">order</span>  <span class="token keyword">by</span> a<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查看 trace 分析结果</p>  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> information_schema<span class="token punctuation">.</span>OPTIMIZER_TRACE\G<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  结果如下：</p>  <pre class="line-numbers language-text" data-language="text"><code class="language-text">*************************** 1. row ***************************QUERY: select * from t1 where a &gt;900 and b &gt; 910 order  by a    --SQL语句TRACE: {    "steps": [        {           "join_preparation": {--SQL准备阶段               "select#": 1,               "steps": [                   {                       "expanded_query": "/* select#1 */ select `t1`.`id` AS `id`,`t1`.`a` AS `a`,`t1`.`b` AS `b`,`t1`.`create_time` AS `create_time`,`t1`.`update_time` AS `update_time` from `t1` where ((`t1`.`a` &gt; 900) and (`t1`.`b` &gt; 910)) order by `t1`.`a`"                   }               ] /* steps */           } /* join_preparation */       },        {            "join_optimization": {--SQL优化阶段                "select#": 1,                "steps": [                    {                        "condition_processing": {    --条件处理                            "condition": "WHERE",                            "original_condition": "((`t1`.`a` &gt; 900) and (`t1`.`b` &gt; 910))",        --原始条件                            "steps": [                                {                                    "transformation": "equality_propagation",                                    "resulting_condition": "((`t1`.`a` &gt; 900) and (`t1`.`b` &gt; 910))" --等值传递转换                                },                                {                                    "transformation": "constant_propagation",                                    "resulting_condition": "((`t1`.`a` &gt; 900) and (`t1`.`b` &gt; 910))"       --常量传递转换                                },                                {                                    "transformation": "trivial_condition_removal",                                    "resulting_condition": "((`t1`.`a` &gt; 900) and (`t1`.`b` &gt; 910))"        --去除没有的条件后的结构                                }                            ] /* steps */                        } /* condition_processing */                    },                    {                        "substitute_generated_columns": {                        } /* substitute_generated_columns */   --替换虚拟生成列                    },                    {                        "table_dependencies": [--表依赖详情                            {                                "table": "`t1`",                                "row_may_be_null": false,                                "map_bit": 0,                                "depends_on_map_bits": [                                ] /* depends_on_map_bits */                            }                        ] /* table_dependencies */                    },                    {                        "ref_optimizer_key_uses": [                        ] /* ref_optimizer_key_uses */                    },                    {                        "rows_estimation": [--预估表的访问成本                            {                                "table": "`t1`",                                "range_analysis": {                                    "table_scan": {                                        "rows": 1000,       --扫描行数                                        "cost": 207.1       --成本                                    } /* table_scan */,                                    "potential_range_indexes": [    --分析可能使用的索引                                        {                                            "index": "PRIMARY",                                            "usable": false,       --为false，说明主键索引不可用                                            "cause": "not_applicable"                                        },                                        {                                            "index": "idx_a",      --可能使用索引idx_a                                            "usable": true,                                            "key_parts": [                                                "a",                                                "id"                                            ] /* key_parts */                                        },                                        {                                            "index": "idx_b",      --可能使用索引idx_b                                            "usable": true,                                            "key_parts": [                                                "b",                                                "id"                                            ] /* key_parts */                                        }                                    ] /* potential_range_indexes */,                                    "setup_range_conditions": [                                    ] /* setup_range_conditions */,                                    "group_index_range": {                                        "chosen": false,                                        "cause": "not_group_by_or_distinct"                                    } /* group_index_range */,                                    "analyzing_range_alternatives": { --分析各索引的成本                                        "range_scan_alternatives": [                                            {                                                "index": "idx_a",--使用索引idx_a的成本                                                "ranges": [                                                    "900 &lt; a"--使用索引idx_a的范围                                                ] /* ranges */,                                                "index_dives_for_eq_ranges": true, --是否使用index dive（详细描述请看下方的知识扩展）                                                "rowid_ordered": false, --使用该索引获取的记录是否按照主键排序                                                "using_mrr": false,  --是否使用mrr                                                "index_only": false,    --是否使用覆盖索引                                                "rows": 100,            --使用该索引获取的记录数                                                "cost": 121.01,         --使用该索引的成本                                                "chosen": true          --可能选择该索引                                            },                                            {                                                "index": "idx_b",       --使用索引idx_b的成本                                                "ranges": [                                                    "910 &lt; b"                                                ] /* ranges */,                                                "index_dives_for_eq_ranges": true,                                                "rowid_ordered": false,                                                "using_mrr": false,                                                "index_only": false,                                                "rows": 90,                                                "cost": 109.01,                                                "chosen": true             --也可能选择该索引                                            }                                        ] /* range_scan_alternatives */,                                        "analyzing_roworder_intersect": { --分析使用索引合并的成本                                            "usable": false,                                            "cause": "too_few_roworder_scans"                                        } /* analyzing_roworder_intersect */                                    } /* analyzing_range_alternatives */,                                    "chosen_range_access_summary": {  --确认最优方法                                        "range_access_plan": {                                            "type": "range_scan",                                            "index": "idx_b",                                            "rows": 90,                                            "ranges": [                                                "910 &lt; b"                                            ] /* ranges */                                        } /* range_access_plan */,                                        "rows_for_plan": 90,                                        "cost_for_plan": 109.01,                                        "chosen": true                                    } /* chosen_range_access_summary */                                } /* range_analysis */                            }                        ] /* rows_estimation */                    },                    {                        "considered_execution_plans": [  --考虑的执行计划                            {                                "plan_prefix": [                                ] /* plan_prefix */,                                "table": "`t1`",                                "best_access_path": {          --最优的访问路径                                    "considered_access_paths": [ --决定的访问路径                                        {                                            "rows_to_scan": 90,      --扫描的行数                                            "access_type": "range",  --访问类型：为range                                            "range_details": {                                                "used_index": "idx_b"  --使用的索引为：idx_b                                            } /* range_details */,                                            "resulting_rows": 90,    --结果行数                                            "cost": 127.01,          --成本                                            "chosen": true,   --确定选择                                            "use_tmp_table": true                                        }                                    ] /* considered_access_paths */                                } /* best_access_path */,                                "condition_filtering_pct": 100,                                "rows_for_plan": 90,                                "cost_for_plan": 127.01,                                "sort_cost": 90,                                "new_cost_for_plan": 217.01,                                "chosen": true                            }                        ] /* considered_execution_plans */                    },                    {                        "attaching_conditions_to_tables": {  --尝试添加一些其他的查询条件                            "original_condition": "((`t1`.`a` &gt; 900) and (`t1`.`b` &gt; 910))",                            "attached_conditions_computation": [                            ] /* attached_conditions_computation */,                            "attached_conditions_summary": [                                {                                    "table": "`t1`",                                    "attached": "((`t1`.`a` &gt; 900) and (`t1`.`b` &gt; 910))"                                }                            ] /* attached_conditions_summary */                        } /* attaching_conditions_to_tables */                    },                    {                        "clause_processing": {                            "clause": "ORDER BY",                            "original_clause": "`t1`.`a`",                            "items": [                                {                                    "item": "`t1`.`a`"                                }                            ] /* items */,                            "resulting_clause_is_simple": true,                            "resulting_clause": "`t1`.`a`"                        } /* clause_processing */                    },                    {                        "reconsidering_access_paths_for_index_ordering": {                            "clause": "ORDER BY",                            "index_order_summary": {                                "table": "`t1`",                                "index_provides_order": false,                                "order_direction": "undefined",                                "index": "idx_b",                                "plan_changed": false                            } /* index_order_summary */                        } /* reconsidering_access_paths_for_index_ordering */                    },                    {                        "refine_plan": [          --改进的执行计划                            {                                "table": "`t1`",                                "pushed_index_condition": "(`t1`.`b` &gt; 910)",                                "table_condition_attached": "(`t1`.`a` &gt; 900)"                            }                        ] /* refine_plan */                    }                ] /* steps */            } /* join_optimization */        },        {            "join_execution": {             --SQL执行阶段                "select#": 1,                "steps": [                    {                        "filesort_information": [                            {                                "direction": "asc",                                "table": "`t1`",                                "field": "a"                            }                        ] /* filesort_information */,                        "filesort_priority_queue_optimization": {                            "usable": false,             --未使用优先队列优化排序                            "cause": "not applicable (no LIMIT)"     --未使用优先队列排序的原因是没有limit                        } /* filesort_priority_queue_optimization */,                        "filesort_execution": [                        ] /* filesort_execution */,                        "filesort_summary": {           --排序详情                            "rows": 90,                   --预计扫描的行数                            "examined_rows": 90,          --参与排序的行数                            "number_of_tmp_files": 0,     --排序过程中使用的临时文件数                            "sort_buffer_size": 115056,   --sort_buffer 的大小                            "sort_mode": "&lt;sort_key, additional_fields&gt;"   --排序模式（详解请看下方知识扩展）                        } /* filesort_summary */                    }                ] /* steps */            } /* join_execution */        }    ] /* steps */}MISSING_BYTES_BEYOND_MAX_MEM_SIZE: 0--该字段表示分析过程丢弃的文本字节大小，本例为0，说明没丢弃任何文本                    INSUFFICIENT_PRIVILEGES: 0    --查看trace的权限是否不足，0表示有权限查看trace详情1 row in set (0.00 sec)------------------------------------------------<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>关闭trace</p>  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">set</span> <span class="token keyword">session</span> optimizer_trace<span class="token operator">=</span><span class="token string">"enabled=off"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>TRACE 字段中整个文本大致分为三个过程。</p></li></ol><ul><li>准备阶段：对应文本中的 join_preparation</li><li>优化阶段：对应文本中的 join_optimization</li><li>执行阶段：对应文本中的 join_execution</li></ul><p>使用时，重点关注优化阶段和执行阶段。</p><p>由此例可以看出：</p><ul><li>在 trace 结果的 analyzing_range_alternatives 这一项可以看到：使用索引 idx_a 的成本为 121.01，使用索引 idx_b 的成本为 109.01，显然使用索引 idx_b 的成本要低些，因此优化器选择了 idx_b 索引；</li><li>在 trace 结果的 filesort_summary 这一项可以看到：排序模式为 <code>&lt;sort_key, additional_fields&gt;</code> ，表示使用的是单路排序，即一次性取出满足条件行的所有字段，然后在 sort buffer 中进行排序。</li></ul><blockquote><p>知识扩展：</p><p><strong>知识点一：MySQL 常见排序模式：</strong></p><ul><li>&lt; sort_key, rowid &gt;双路排序（又叫回表排序模式）：是首先根据相应的条件取出相应的排序字段和可以直接定位行数据的行 ID，然后在 sort buffer 中进行排序，排序完后需要再次取回其它需要的字段；</li><li>&lt; sort_key, additional_fields &gt;单路排序：是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序；</li><li>&lt; sort_key, packed_additional_fields &gt;打包数据排序模式：将 char 和 varchar 字段存到 sort buffer 中时，更加紧缩。</li></ul><p>三种排序模式比较：</p><p>第二种模式相对第一种模式，避免了二次回表，可以理解为用空间换时间。由于 sort buffer 有限，如果需要查询的数据比较大的话，会增加磁盘排序时间，效率可能比第一种方式更低。</p><p>MySQL 提供了一个参数：max_length_for_sort_data，当“排序的键值对大小” &gt; max_length_for_sort_data 时，MySQL 认为磁盘外部排序的 IO 效率不如回表的效率，会选择第一种排序模式；否则，会选择第二种模式。</p><p>第三种模式主要解决变长字符数据存储空间浪费的问题。</p><p><strong>知识点二：优化器在估计符合条件的行数时有两个选择：</strong></p><ul><li>index diver：dive 到 index 中利用索引完成元组数的估算；特点是速度慢，但可以得到精确的值；</li><li>index statistics：使用索引的统计数值，进行估算；特点是速度快，但是值不一定准确。</li></ul></blockquote><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h3><p>对比一下三种分析 SQL 方法的特点：</p><ul><li>explain：获取 MySQL 中 SQL 语句的执行计划，比如语句是否使用了关联查询、是否使用了索引、扫描行数等；</li><li>profile：可以清楚了解到SQL到底慢在哪个环节；</li><li>trace：查看优化器如何选择执行计划，获取每个可能的索引选择的代价。</li></ul><h2 id="04-条件字段有索引，为什么查询也这么慢"><a href="#04-条件字段有索引，为什么查询也这么慢" class="headerlink" title="04 条件字段有索引，为什么查询也这么慢?"></a><strong>04 条件字段有索引，为什么查询也这么慢?</strong></h2><p>下面会讲解几种有索引但是查询不走索引导致查询慢的场景。</p><h3 id="1-函数操作"><a href="#1-函数操作" class="headerlink" title="1 函数操作"></a>1 函数操作</h3><h4 id="1-1-验证对条件字段做函数操作是否能走索引"><a href="#1-1-验证对条件字段做函数操作是否能走索引" class="headerlink" title="1.1 验证对条件字段做函数操作是否能走索引"></a>1.1 验证对条件字段做函数操作是否能走索引</h4><p>首先创建测试表，建表及数据写入语句如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">use</span> muke<span class="token punctuation">;</span>                       <span class="token comment">/* 使用muke这个database */</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t1<span class="token punctuation">;</span>        <span class="token comment">/* 如果表t1存在则删除表t1 */</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t1<span class="token punctuation">`</span> <span class="token punctuation">(</span>             <span class="token comment">/* 创建表t1 */</span>    <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>c<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_a<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_b<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>b<span class="token punctuation">`</span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_c<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>c<span class="token punctuation">`</span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span>  <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">procedure</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> insert_t1<span class="token punctuation">;</span> <span class="token comment">/* 如果存在存储过程insert_t1，则删除 */</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">procedure</span> insert_t1<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">/* 创建存储过程insert_t1 */</span><span class="token keyword">begin</span>    <span class="token keyword">declare</span> i <span class="token keyword">int</span><span class="token punctuation">;</span>                    <span class="token comment">/* 声明变量i */</span>    <span class="token keyword">set</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>                          <span class="token comment">/* 设置i的初始值为1 */</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token keyword">do</span>                 <span class="token comment">/* 对满足i&lt;=10000的值进行while循环 */</span>        <span class="token keyword">insert</span> <span class="token keyword">into</span> t1<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* 写入表t1中a、b两个字段，值都为i当前的值 */</span>        <span class="token keyword">set</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                        <span class="token comment">/* 将i加1 */</span>    <span class="token keyword">end</span> <span class="token keyword">while</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span><span class="token keyword">call</span> insert_t1<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">/* 运行存储过程insert_t1 */</span><span class="token keyword">update</span> t1 <span class="token keyword">set</span> c <span class="token operator">=</span> <span class="token string">'2019-05-22 00:00:00'</span><span class="token punctuation">;</span>  <span class="token comment">/* 更新表t1的c字段，值都为'2019-05-22 00:00:00' */</span><span class="token keyword">update</span> t1 <span class="token keyword">set</span> c <span class="token operator">=</span> <span class="token string">'2019-05-21 00:00:00'</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">10000</span><span class="token punctuation">;</span> <span class="token comment">/* 将id为10000的行的c字段改为与其它行都不一样的数据，以便后面实验使用 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于上面创建的测试表，比如要查询测试表 t1 单独某一天的所有数据，SQL如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> <span class="token keyword">date</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token string">'2019-05-21'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以使用第 2 节学习的 explain 来分析这条SQL的执行计划，分析结果如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra       |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10302 |   100.00 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看图中的执行计划，type 为 ALL，key 字段结果为 NULL，因此知道该 SQL 是没走索引的全表扫描。</p><p>原因：对条件字段做函数操作走不了索引。</p><h4 id="1-2-对条件字段做函数操作不走索引的原因"><a href="#1-2-对条件字段做函数操作不走索引的原因" class="headerlink" title="1.2 对条件字段做函数操作不走索引的原因"></a>1.2 对条件字段做函数操作不走索引的原因</h4><p>该例中 c 字段普通索引的 B+ 索引树如下：</p><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/c字段普通索引的B+索引树.png" alt="c字段普通索引的B+索引树"></p><p>根据上面结构可以看到，索引树中存储的是列的实际值和主键值。如果拿 ‘2019-05-21’ 去匹配，将无法定位到索引树中的值。因此放弃走索引，而选择全表扫描。</p><h4 id="1-3-函数操作的-SQL-优化"><a href="#1-3-函数操作的-SQL-优化" class="headerlink" title="1.3 函数操作的 SQL 优化"></a>1.3 函数操作的 SQL 优化</h4><p>因此如果需要优化的话，改成 c 字段实际值相匹配的形式。因为 SQL 的目的是查询 2019-05-21 当天所有的记录，因此可以改成范围查询，如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> c<span class="token operator">&gt;=</span><span class="token string">'2019-05-21 00:00:00'</span> <span class="token operator">and</span> c<span class="token operator">&lt;=</span><span class="token string">'2019-05-21 23:59:59'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再用 explain 分析下执行计划的结果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type  | possible_keys | key   | key_len | ref  | rows | filtered | Extra                 |+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+|  1 | SIMPLE      | t1    | NULL       | range | idx_c         | idx_c | 5       | NULL |    1 |   100.00 | Using index condition |+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-隐式转换"><a href="#2-隐式转换" class="headerlink" title="2 隐式转换"></a><strong>2 隐式转换</strong></h3><blockquote><p>什么时隐式转换？</p><p>当操作符与不同类型的操作对象一起使用时，就会发生类型转换以使操作兼容。某些转换是隐式的。</p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/type-conversion.html">关于隐式转换详情请参考MySQL官方手册</a></p></blockquote><p>隐式转换估计是很多 MySQL 使用者踩过的坑，比如联系方式字段。由于有时电话号码带加、减等特殊字符，有时需要以 0 开头，因此一般设计表时会使用 varchar 类型存储，并且会经常做为条件来查询数据，所以会添加索引。</p><p>而有时遇到需要按照手机号码条件（比如 11111111111）去查询数据时，因为查询者看到条件是一串数字，而忽视表中对应手机号字段是 varchar 类型，因此写出了如下不合理的SQL：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> user_name<span class="token punctuation">,</span>tele_phone <span class="token keyword">from</span> user_info <span class="token keyword">where</span> tele_phone <span class="token operator">=</span><span class="token number">11111111111</span><span class="token punctuation">;</span> <span class="token comment">/* SQL 1 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-2-验证隐式转换是否能走索引"><a href="#2-2-验证隐式转换是否能走索引" class="headerlink" title="2.2 验证隐式转换是否能走索引"></a>2.2 验证隐式转换是否能走索引</h4><p>实验过程分为：先创建测试表并写入数据；测试隐式转换的查询并查看执行计划；测试正常查询，再查看执行计划。</p><p>比如我们要查询 a 字段等于 1000 的值，SQL如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>看下 explain 结果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra       |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+|  1 | SIMPLE      | t1    | NULL       | ALL  | idx_a         | NULL | NULL    | NULL | 10302 |    10.00 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 type 这列可以看到是最差的情况 ALL（全表扫描）， 通过 key 这列可以看到没走 a 字段的索引，通过 rows 这列可以看到进行了全表扫描。</p><h4 id="2-3-不走索引的原因"><a href="#2-3-不走索引的原因" class="headerlink" title="2.3 不走索引的原因"></a>2.3 不走索引的原因</h4><p>a 字段类型是 varchar(20)，而语句中 a 字段条件值没加单引号，导致 MySQL 内部会先把a转换成int型，再去做判断，相当于实际执行的 SQL 语句如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> cast<span class="token punctuation">(</span>a <span class="token keyword">as</span> signed <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因此又回到上面说的：<strong>对索引字段做函数操作时，优化器会放弃使用索引</strong>。</p><h4 id="2-4-隐式转换的-SQL-优化"><a href="#2-4-隐式转换的-SQL-优化" class="headerlink" title="2.4 隐式转换的 SQL 优化"></a>2.4 隐式转换的 SQL 优化</h4><p>索引字符串列条件添加单引号，查看执行计划：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token string">'1000'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref   | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+|  1 | SIMPLE      | t1    | NULL       | ref  | idx_a         | idx_a | 83      | const |    1 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 type 这列，可以看到是 ref（基于普通索引的等值查询，比 ALL 性能好很多），通过key这列，可以看到已经走了 a 字段的索引，通过rows这列可以看到通过索引查询后就扫描了一行。</p><h3 id="3-模糊查询"><a href="#3-模糊查询" class="headerlink" title="3 模糊查询"></a><strong>3 模糊查询</strong></h3><h4 id="3-1-分析模糊查询"><a href="#3-1-分析模糊查询" class="headerlink" title="3.1 分析模糊查询"></a>3.1 分析模糊查询</h4><p>很多时候我们想根据某个字段的某几个关键字查询数据，比如会有如下 SQL：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> a <span class="token operator">like</span> <span class="token string">'%1111%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>实际这种情况无法走索引，看下执行计划：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra       |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10302 |    11.11 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重点留意type、key、rows、Extra，发现是全表扫描。</p><h4 id="3-2-模糊查询优化建议"><a href="#3-2-模糊查询优化建议" class="headerlink" title="3.2 模糊查询优化建议"></a>3.2 模糊查询优化建议</h4><p>修改业务，让模糊查询必须包含条件字段前面的值，然后落到数据库的查询为：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> a <span class="token operator">like</span> <span class="token string">'1111%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这种写法是可以用到索引的，explain分析如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type  | possible_keys | key   | key_len | ref  | rows | filtered | Extra                 |+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+|  1 | SIMPLE      | t1    | NULL       | range | idx_a         | idx_a | 83      | NULL |    1 |   100.00 | Using index condition |+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>如果条件只知道中间的值，需要模糊查询去查，那就建议使用ElasticSearch或其它搜索服务器。</p></blockquote><h3 id="4-范围查询"><a href="#4-范围查询" class="headerlink" title="4 范围查询"></a><strong>4 范围查询</strong></h3><h4 id="4-1-构造不能使用索引的范围查询"><a href="#4-1-构造不能使用索引的范围查询" class="headerlink" title="4.1 构造不能使用索引的范围查询"></a>4.1 构造不能使用索引的范围查询</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> b<span class="token operator">&gt;=</span><span class="token number">1</span> <span class="token operator">and</span> b <span class="token operator">&lt;=</span><span class="token number">100000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>看下这条 SQL 的执行计划：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra       |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+|  1 | SIMPLE      | t1    | NULL       | ALL  | idx_b         | NULL | NULL    | NULL | 10302 |    97.07 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发现并不能走b字段的索引。</p><p>原因：优化器会根据检索比例、表大小、I/O块大小等进行评估是否使用索引。比如单次查询的数据量过大，优化器将不走索引。</p><h4 id="4-2-优化范围查询"><a href="#4-2-优化范围查询" class="headerlink" title="4.2 优化范围查询"></a>4.2 优化范围查询</h4><p>降低单次查询范围，分多次查询：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> b<span class="token operator">&gt;=</span><span class="token number">1</span> <span class="token operator">and</span> b <span class="token operator">&lt;=</span><span class="token number">1000</span><span class="token punctuation">;</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> b<span class="token operator">&gt;=</span><span class="token number">1001</span> <span class="token operator">and</span> b <span class="token operator">&lt;=</span><span class="token number">2000</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>查看执行计划（就只看第一条的，第二条同理）：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type  | possible_keys | key   | key_len | ref  | rows | filtered | Extra                 |+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+|  1 | SIMPLE      | t1    | NULL       | range | idx_b         | idx_b | 5       | NULL | 1000 |   100.00 | Using index condition |+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，降低查询范围后，能正常使用索引。</p><blockquote><p>经验分享：</p><p>实际这种范围查询而导致使用不了索引的场景经常出现，比如按照时间段抽取全量数据，每条SQL抽取一个月的；或者某张业务表历史数据的删除。遇到此类操作时，<strong>应该在执行之前对SQL做explain分析，确定能走索引，再进行操作</strong>，否则不但可能导致操作缓慢，在做更新或者删除时，甚至会导致表所有记录锁住，十分危险。</p></blockquote><h3 id="5-计算操作"><a href="#5-计算操作" class="headerlink" title="5 计算操作"></a>5 计算操作</h3><h4 id="5-1-查询条件进行计算操作的-SQL-执行效率"><a href="#5-1-查询条件进行计算操作的-SQL-执行效率" class="headerlink" title="5.1 查询条件进行计算操作的 SQL 执行效率"></a>5.1 查询条件进行计算操作的 SQL 执行效率</h4><p>有时我们与有对条件字段做计算操作的需求，在使用 SQL 查询时，就应该小心了。先看下例：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> b<span class="token operator">-</span><span class="token number">1</span> <span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看执行计划：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra       |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10302 |   100.00 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>原因：对索引字段做运算将使用不了索引。</p></blockquote><h4 id="5-2-计算操作的-SQL-优化"><a href="#5-2-计算操作的-SQL-优化" class="headerlink" title="5.2 计算操作的 SQL 优化"></a>5.2 计算操作的 SQL 优化</h4><p>将计算操作放在等号后面：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> b <span class="token operator">=</span><span class="token number">1000</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看执行计划：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref   | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+|  1 | SIMPLE      | t1    | NULL       | ref  | idx_b         | idx_b | 5       | const |    1 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发现将计算操作放在等号后，能正常使用索引。</p><blockquote><p>经验分享：</p><p><strong>一般需要对条件字段做计算时，建议通过程序代码实现，而不是通过MySQL实现。如果在MySQL中计算的情况避免不了，那必须把计算放在等号后面。</strong></p></blockquote><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h3><p>在写 SQL 时应该注意这些点：</p><ul><li>应该避免隐式转换</li><li>like查询不能以%开头</li><li>范围查询时，包含的数据比例不能太大</li><li>不建议对条件字段做运算及函数操作</li></ul><p>本节涉及到的一些SQL优化如下图：</p><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/MySQL条件字段有索引但是不走索引的场景.png" alt="MySQL条件字段有索引但是不走索引的场景"></p><h2 id="05-如何优化数据导入？"><a href="#05-如何优化数据导入？" class="headerlink" title="05 如何优化数据导入？"></a><strong>05 如何优化数据导入？</strong></h2><h3 id="1-一次插入多行的值"><a href="#1-一次插入多行的值" class="headerlink" title="1 一次插入多行的值"></a>1 一次插入多行的值</h3><p>插入行所需的时间由以下因素决定（参考MySQL 5.7参考手册：<a href="https://dev.mysql.com/doc/refman/5.7/en/insert-optimization.html">8.2.4.1优化INSERT语句</a>）</p><ul><li>连接：30%</li><li>向服务器发送查询：20%</li><li>解析查询：20%</li><li>插入行：10% * 行的大小</li><li>插入索引：10% * 索引数</li><li>结束：10%</li></ul><p>可发现大部分时间耗费在客户端与服务端通信的时间，因此可以使用 insert 包含多个值来减少客户端和服务器之间的通信。</p><h3 id="2-关闭自动提交"><a href="#2-关闭自动提交" class="headerlink" title="2 关闭自动提交"></a>2 关闭自动提交</h3><p>Autocommit 开启时会为每个插入执行提交。可以在InnoDB导入数据时，关闭自动提交。</p><h3 id="3-参数调整"><a href="#3-参数调整" class="headerlink" title="3 参数调整"></a>3 参数调整</h3><p>影响MySQL写入速度的主要两个参数：innodb_flush_log_at_trx_commit、sync_binlog。</p><h4 id="3-1-参数解释"><a href="#3-1-参数解释" class="headerlink" title="3.1 参数解释"></a>3.1 参数解释</h4><p>innodb_flush_log_at_trx_commit：控制重做日志刷新到磁盘的策略，有0 、1和2三种值。</p><ul><li>0：master线程每秒把redo log buffer写到操作系统缓存，再刷到磁盘；</li><li>1：每次提交事务都将redo log buffer写到操作系统缓存，再刷到磁盘；</li><li>2：每次事务提交都将redo log buffer写到操作系统缓存，由操作系统来管理刷盘。</li></ul><p>sync_binlog：控制binlog的刷盘时机，可配置0、1或者大于1的数字。</p><ul><li>0：二进制日志从不同步到磁盘，依赖OS刷盘机制；</li><li>1：二进制日志每次提交都会刷盘；</li><li>n(n&gt;1) : 每n次提交落盘一次。</li></ul><h2 id="06-让order-by、group-by查询更快"><a href="#06-让order-by、group-by查询更快" class="headerlink" title="06 让order by、group by查询更快"></a><strong>06 让order by、group by查询更快</strong></h2><h3 id="1-order-by-原理"><a href="#1-order-by-原理" class="headerlink" title="1 order by 原理"></a>1 order by 原理</h3><p>在优化 order by 语句之前，需要先了解 MySQL 中排序的相关知识点和原理，为了方便讲解过程举例说明，首先创建一张测试表，建表及数据写入语句如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">use</span> muke<span class="token punctuation">;</span>                 <span class="token comment">/* 使用muke这个database */</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t1<span class="token punctuation">;</span>  <span class="token comment">/* 如果表t1存在则删除表t1 */</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t1<span class="token punctuation">`</span> <span class="token punctuation">(</span>      <span class="token comment">/* 创建表t1 */</span>    <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>c<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>d<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_a_b<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>b<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_c<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>c<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4 <span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">procedure</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> insert_t1<span class="token punctuation">;</span> <span class="token comment">/* 如果存在存储过程insert_t1，则删除 */</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">procedure</span> insert_t1<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">/* 创建存储过程insert_t1 */</span><span class="token keyword">begin</span>    <span class="token keyword">declare</span> i <span class="token keyword">int</span><span class="token punctuation">;</span>                  <span class="token comment">/* 声明变量i */</span>    <span class="token keyword">set</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>                        <span class="token comment">/* 设置i的初始值为1 */</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token keyword">do</span>      <span class="token comment">/* 对满足i&lt;=10000的值进行while循环 */</span>        <span class="token keyword">insert</span> <span class="token keyword">into</span> t1<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 写入表t1中a、b两个字段，值都为i当前的值 */</span>        <span class="token keyword">set</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                       <span class="token comment">/* 将i加1 */</span>    <span class="token keyword">end</span> <span class="token keyword">while</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span><span class="token keyword">call</span> insert_t1<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">/* 运行存储过程insert_t1 */</span><span class="token keyword">update</span> t1 <span class="token keyword">set</span> a<span class="token operator">=</span><span class="token number">1000</span> <span class="token keyword">where</span> id <span class="token operator">&gt;</span><span class="token number">9000</span><span class="token punctuation">;</span>    <span class="token comment">/* 将id大于9000的行的a字段更新为1000 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-1-MySQL-的排序方式"><a href="#1-1-MySQL-的排序方式" class="headerlink" title="1.1 MySQL 的排序方式"></a>1.1 MySQL 的排序方式</h4><p>按照排序原理分，MySQL 排序方式分两种：</p><ul><li>通过有序索引直接返回有序数据</li><li>通过 Filesort 进行的排序</li></ul><blockquote><p><strong>怎么确定某条排序的 SQL 所使用的排序方式？</strong></p><p>使用 explain 来查看该排序 SQL 的执行计划，重点关注 Extra 字段：</p><p>如果该字段里显示是 Using index，则表示是通过有序索引直接返回有序数据。</p><p>如果该字段里显示是 Using filesort，则表示该 SQL 是通过 Filesort 进行的排序。</p></blockquote><h4 id="1-2-Filesort-是在内存中还是在磁盘中完成排序的？"><a href="#1-2-Filesort-是在内存中还是在磁盘中完成排序的？" class="headerlink" title="1.2 Filesort 是在内存中还是在磁盘中完成排序的？"></a>1.2 Filesort 是在内存中还是在磁盘中完成排序的？</h4><p>MySQL 中的 Filesort 并不一定是在磁盘文件中进行排序的，也有可能在内存中排序，内存排序还是磁盘排序取决于排序的数据大小和 sort_buffer_size 配置的大小。</p><ul><li>如果 “排序的数据大小” &lt; sort_buffer_size: 内存排序</li><li>如果 “排序的数据大小” &gt; sort_buffer_size: 磁盘排序</li></ul><blockquote><p><strong>怎么确定使用 Filesort 排序的 SQL 是在内存还是在磁盘中进行的排序操作？</strong></p><p>此时就可以使用 trace 进行分析，重点关注 number_of_tmp_files，如果等于 0，则表示排序过程没使用临时文件，在内存中就能完成排序；如果大于0，则表示排序过程中使用了临时文件。</p></blockquote><h4 id="1-3-Filesort-下的排序模式"><a href="#1-3-Filesort-下的排序模式" class="headerlink" title="1.3 Filesort 下的排序模式"></a>1.3 Filesort 下的排序模式</h4><p>Filesort 下的排序模式有三种，具体介绍如下：（参考<a href="https://dev.mysql.com/doc/refman/5.7/en/order-by-optimization.html">《MySQL 5.7 Reference Manual》8.2.1.14 ORDER BY Optimization</a>）</p><ul><li>&lt; sort_key, rowid &gt;双路排序（又叫回表排序模式）：是首先根据相应的条件取出相应的排序字段和可以直接定位行数据的行 ID，然后在 sort buffer 中进行排序，排序完后需要再次取回其它需要的字段；</li><li>&lt; sort_key, additional_fields &gt;单路排序：是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序；</li><li>&lt; sort_key, packed_additional_fields &gt;打包数据排序模式：与单路排序相似，区别是将 char 和 varchar 字段存到 sort buffer 中时，更加紧缩。</li></ul><p>因为打包数据排序模式是单路排序的一种升级模式，因此重点探讨双路排序和单路排序的区别。MySQL 通过比较系统变量 max_length_for_sort_data 的大小和需要查询的字段总大小来判断使用哪种排序模式。</p><ul><li>如果 max_length_for_sort_data 比查询字段的总长度大，那么使用 &lt; sort_key, additional_fields &gt;排序模式；</li><li>如果 max_length_for_sort_data 比查询字段的总长度小，那么使用 <sort_key, rowid=""> 排序模式。</sort_key,></li></ul><p>为什么要添加 max_length_for_sort_data 这个参数让排序使用不同的排序模式呢？</p><p>接下来，我们一起分析下 max_length_for_sort_data 的重要性。比如下面这条 SQL：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> a<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d <span class="token keyword">from</span> t1 <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">1000</span> <span class="token keyword">order</span> <span class="token keyword">by</span> d<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们先看<strong>单路排序</strong>的详细过程：</p><ol><li>从索引 a 找到第一个满足 a = 1000 条件的主键 id</li><li>根据主键 id 取出整行，<strong>取出 a、c、d 三个字段的值，存入 sort_buffer 中</strong></li><li>从索引 a 找到下一个满足 a = 1000 条件的主键 id</li><li>重复步骤 2、3 直到不满足 a = 1000</li><li>对 sort_buffer 中的数据按照字段 d 进行排序</li><li>返回结果给客户端</li></ol><p>我们再看下<strong>双路排序</strong>的详细过程：</p><ol><li>从索引 a 找到第一个满足 a = 1000 的主键 id</li><li>根据主键 id 取出整行，<strong>把排序字段 d 和主键 id 这两个字段放到 sort buffer 中</strong></li><li>从索引 a 取下一个满足 a = 1000 记录的主键 id</li><li>重复 3、4 直到不满足 a = 1000</li><li>对 sort_buffer 中的字段 d 和主键 id 按照字段 d 进行排序</li><li>遍历排序好的 id 和字段 d，按照 id 的值回到原表中取出 a、c、d 三个字段的值返回给客户端</li></ol><p>其实对比两个排序模式，单路排序会把所有需要查询的字段都放到 sort buffer 中，而双路排序只会把主键和需要排序的字段放到 sort buffer 中进行排序，然后再通过主键回到原表查询需要的字段。</p><h3 id="2-order-by-优化"><a href="#2-order-by-优化" class="headerlink" title="2 order by 优化"></a>2 order by 优化</h3><h4 id="2-1-添加合适索引"><a href="#2-1-添加合适索引" class="headerlink" title="2.1 添加合适索引"></a>2.1 添加合适索引</h4><h5 id="2-1-1-排序字段添加索引"><a href="#2-1-1-排序字段添加索引" class="headerlink" title="2.1.1 排序字段添加索引"></a>2.1.1 排序字段添加索引</h5><p>首先我们看下对 d 字段（没有索引）进行排序的执行计划：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> d<span class="token punctuation">,</span>id <span class="token keyword">from</span> t1 <span class="token keyword">order</span> <span class="token keyword">by</span> d<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra          |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10236 |   100.00 | Using filesort |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发现使用的是 filesort（关注 Extra 字段）。</p><p>再看些对 c 字段（有索引）进行排序的执行计划：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> c<span class="token punctuation">,</span>id <span class="token keyword">from</span> t1 <span class="token keyword">order</span> <span class="token keyword">by</span> c<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+| id | select_type | table | partitions | type  | possible_keys | key   | key_len | ref  | rows  | filtered | Extra       |+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+|  1 | SIMPLE      | t1    | NULL       | index | NULL          | idx_c | 5       | NULL | 10236 |   100.00 | Using index |+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，根据有索引的字段排序，在 Extra 中显示的就为 Using index，表示使用的是索引排序。</p><p><strong>因此可以在排序字段上添加索引来优化排序语句。</strong></p><h5 id="2-1-2-多个字段排序优化"><a href="#2-1-2-多个字段排序优化" class="headerlink" title="2.1.2 多个字段排序优化"></a>2.1.2 多个字段排序优化</h5><p>有时面对的需求是要对多个字段进行排序，而这种情况应该怎么优化或者设计索引呢？首先看下面例子：</p><p>对 a、c 两个字段进行排序的执行计划：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>a<span class="token punctuation">,</span>c <span class="token keyword">from</span> t1 <span class="token keyword">order</span> <span class="token keyword">by</span> a<span class="token punctuation">,</span>c<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra          |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10236 |   100.00 | Using filesort |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>观察 Extra 字段，发现使用的是 filesort。</p><p>再看对 a、b（a、b 两个字段有联合索引）两个字段进行排序：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b <span class="token keyword">from</span> t1 <span class="token keyword">order</span> <span class="token keyword">by</span> a<span class="token punctuation">,</span>b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows  | filtered | Extra       |+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+|  1 | SIMPLE      | t1    | NULL       | index | NULL          | idx_a_b | 10      | NULL | 10236 |   100.00 | Using index |+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发现使用的是索引排序。</p><p>多个字段排序的情况，如果要通过添加索引优化，得注意排序字段的顺序与联合索引中列的顺序要一致。</p><p>因此，<strong>如果多个字段排序，可以在多个排序字段上添加联合索引来优化排序语句。</strong></p><h5 id="2-1-3-先等值查询再排序的优化"><a href="#2-1-3-先等值查询再排序的优化" class="headerlink" title="2.1.3 先等值查询再排序的优化"></a>2.1.3 先等值查询再排序的优化</h5><p>我们更多的情况是会先根据某个字段条件查出一部分数据，然后再排序，而这类 SQL 应该如果优化呢？看下面的实验：</p><p>表 t1中，根据 a=1000 过滤数据再根据 d 字段排序的执行计划如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>a<span class="token punctuation">,</span>d <span class="token keyword">from</span> t1 <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">1000</span> <span class="token keyword">order</span> <span class="token keyword">by</span> d<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+---------+---------+-------+------+----------+----------------+| id | select_type | table | partitions | type | possible_keys | key     | key_len | ref   | rows | filtered | Extra          |+----+-------------+-------+------------+------+---------------+---------+---------+-------+------+----------+----------------+|  1 | SIMPLE      | t1    | NULL       | ref  | idx_a_b       | idx_a_b | 5       | const | 1001 |   100.00 | Using filesort |+----+-------------+-------+------------+------+---------------+---------+---------+-------+------+----------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以在 Extra 字段中看到 “Using filesort”，说明使用的是 filesort 排序。</p><p>再看下根据 a=1000 过滤数据在根据 b 字段排序的执行计划（a、b 两个字段有联合索引）：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b <span class="token keyword">from</span> t1 <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">1000</span> <span class="token keyword">order</span> <span class="token keyword">by</span> b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+---------+---------+-------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key     | key_len | ref   | rows | filtered | Extra       |+----+-------------+-------+------------+------+---------------+---------+---------+-------+------+----------+-------------+|  1 | SIMPLE      | t1    | NULL       | ref  | idx_a_b       | idx_a_b | 5       | const | 1001 |   100.00 | Using index |+----+-------------+-------+------------+------+---------------+---------+---------+-------+------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以在 Extra 字段中看到“Using index”，说明使用的是索引排序。</p><p>因此，对于先等值查询再排序的语句，可以通过在条件字段和排序字段添加联合索引来优化此类排序语句。</p><h4 id="2-2-去掉不必要的返回字段"><a href="#2-2-去掉不必要的返回字段" class="headerlink" title="2.2 去掉不必要的返回字段"></a>2.2 去掉不必要的返回字段</h4><p>有时，我们其实并不需要查询出所有字段，但是可能因为习惯问题，就写成查所有字段的数据了。我们看下下面两条 SQL 的执行计划：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">order</span> <span class="token keyword">by</span> a<span class="token punctuation">,</span>b<span class="token punctuation">;</span>           <span class="token comment">/* 根据a和b字段排序查出所有字段的值 */</span><span class="token keyword">select</span> id<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b <span class="token keyword">from</span> t1 <span class="token keyword">order</span> <span class="token keyword">by</span> a<span class="token punctuation">,</span>b<span class="token punctuation">;</span>      <span class="token comment">/* 根据a和b字段排序查出id,a,b字段的值 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">mysql&gt; explain select * from t1 order by a,b;+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra          |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10236 |   100.00 | Using filesort |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+1 row in set, 1 warning (0.00 sec)mysql&gt; explain select id,a,b from t1 order by a,b;+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows  | filtered | Extra       |+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+|  1 | SIMPLE      | t1    | NULL       | index | NULL          | idx_a_b | 10      | NULL | 10236 |   100.00 | Using index |+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+1 row in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个例子中，查询所有字段不走索引的原因是：扫描整个索引并查找到没索引的行的成本比扫描全表的成本更高，所以优化器放弃使用索引。</p><h4 id="2-3-修改参数"><a href="#2-3-修改参数" class="headerlink" title="2.3 修改参数"></a>2.3 修改参数</h4><p>在本节一开始讲 order by 原理的时候，接触到两个跟排序有关的参数：max_length_for_sort_data、sort_buffer_size。</p><ul><li>max_length_for_sort_data：如果觉得排序效率比较低，可以适当加大 max_length_for_sort_data 的值，让优化器优先选择全字段排序。当然不能设置过大，可能会导致 CPU 利用率过低或者磁盘 I/O 过高；</li><li>sort_buffer_size：适当加大 sort_buffer_size 的值，尽可能让排序在内存中完成。但不能设置过大，可能导致数据库服务器 SWAP。</li></ul><h4 id="2-4-几种无法利用索引排序的情况"><a href="#2-4-几种无法利用索引排序的情况" class="headerlink" title="2.4 几种无法利用索引排序的情况"></a>2.4 几种无法利用索引排序的情况</h4><h5 id="2-4-1-使用范围查询再排序"><a href="#2-4-1-使用范围查询再排序" class="headerlink" title="2.4.1 使用范围查询再排序"></a>2.4.1 使用范围查询再排序</h5><p>在本节 2.1.3 中介绍过，对于先等值过滤再排序的语句，可以通过在条件字段和排序字段添加联合索引来优化；但是如果联合索引中前面的字段使用了范围查询，对后面的字段排序是否能用到索引排序呢？下面我们通过实验验证一下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b <span class="token keyword">from</span> t1 <span class="token keyword">where</span> a<span class="token operator">&gt;</span><span class="token number">9000</span> <span class="token keyword">order</span> <span class="token keyword">by</span> b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+------------------------------------------+| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                                    |+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+------------------------------------------+|  1 | SIMPLE      | t1    | NULL       | range | idx_a_b       | idx_a_b | 5       | NULL |    1 |   100.00 | Using where; Using index; Using filesort |+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+------------------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里对上面执行计划做下解释：首先条件 a&gt;9000 使用了索引（关注 key 字段对应的值为 idx_a_b）；在 Extra 中，看到了“Using filesort”，表示使用了 filesort 排序，并没有使用索引排序。所以联合索引中前面的字段使用了范围查询，对后面的字段排序使用不了索引排序。</p><p>原因是：a、b 两个字段的联合索引，对于单个 a 的值，b 是有序的。而对于 a 字段的范围查询，也就是 a 字段会有多个值，取到 a，b 的值 b 就不一定有序了，因此要额外进行排序。联合索引结果如下图（为了便于理解，该图的值与上面所创建的表 t1 数据不一样）：</p><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/使用范围查询再排序.png" alt="使用范围查询再排序"></p><p>如上图所示，对于有 a、b 两个字段联合索引的表，如果对 a 字段范围查询，b 字段整体来看是无序的（如上图 b 的值为：1，2，3，1，2，3······）。</p><h5 id="2-4-2-ASC-和-DESC-混合使用将无法使用索引"><a href="#2-4-2-ASC-和-DESC-混合使用将无法使用索引" class="headerlink" title="2.4.2 ASC 和 DESC 混合使用将无法使用索引"></a>2.4.2 ASC 和 DESC 混合使用将无法使用索引</h5><p>对联合索引多个字段同时排序时，如果一个是顺序，一个是倒序，则使用不了索引，如下例：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b <span class="token keyword">from</span> t1 <span class="token keyword">order</span> <span class="token keyword">by</span> a <span class="token keyword">asc</span><span class="token punctuation">,</span>b <span class="token keyword">desc</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-----------------------------+| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows  | filtered | Extra                       |+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-----------------------------+|  1 | SIMPLE      | t1    | NULL       | index | NULL          | idx_a_b | 10      | NULL | 10236 |   100.00 | Using index; Using filesort |+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-----------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-group-by-优化"><a href="#3-group-by-优化" class="headerlink" title="3 group by 优化"></a>3 group by 优化</h3><p>默认情况，会对 group by 字段排序，因此优化方式与 order by 基本一致，如果目的只是分组而不用排序，可以指定 order by null 禁止排序。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h3><p>首先说到 MySQL 的两种排序方式：</p><ul><li>通过有序索引直接返回有序数据</li><li>通过 Filesort 进行排序</li></ul><p>建议优先考虑索引排序。</p><p>而Filesort又分为两种：</p><ul><li>内存排序</li><li>磁盘文件排序</li></ul><p>优先考虑内存排序。</p><p>Filesort 有三种排序模式：</p><ul><li>&lt; sort_key, rowid &gt;</li><li>&lt; sort_key, additional_fields &gt;</li><li>&lt; sort_key, packed_additional_fields &gt;</li></ul><p><strong>order by 语句的优化，这个是本节的重点：</strong></p><ul><li>通过添加合适索引</li><li>去掉不必要的返回字段</li><li>调整参数：主要是 max_length_for_sort_data 和 sort_buffer_size</li><li>避免几种无法利用索引排序的情况</li></ul><p>最后说到 group by 语句的优化，如果只要分组，没有排序需求的话，可以加 order by null 禁止排序。</p><h2 id="07-换种思路写分页查询"><a href="#07-换种思路写分页查询" class="headerlink" title="07 换种思路写分页查询"></a><strong>07 换种思路写分页查询</strong></h2><p>很多时候，业务上会有分页操作的需求，对应的 SQL 类似下面这条：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c <span class="token keyword">from</span> t1 <span class="token keyword">limit</span> <span class="token number">10000</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表示从表 t1 中取出从 10001 行开始的 10 行记录。看似只查询了 10 条记录，实际这条 SQL 是先读取 10010 条记录，然后抛弃前 10000 条记录，然后读到后面 10 条想要的数据。因此要查询一张大表比较靠后的数据，执行效率是非常低的。本节内容就一起研究下，是否有办法去优化分页查询。</p><p>为了方便验证，首先创建测试表并写入数据：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">use</span> muke<span class="token punctuation">;</span>                       <span class="token comment">/* 使用muke这个database */</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t1<span class="token punctuation">;</span>        <span class="token comment">/* 如果表t1存在则删除表t1 */</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t1<span class="token punctuation">`</span> <span class="token punctuation">(</span>             <span class="token comment">/* 创建表t1 */</span>    <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">auto_increment</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>create_time<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'记录创建时间'</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>update_time<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'记录更新时间'</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_a<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_b<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>b<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">procedure</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> insert_t1<span class="token punctuation">;</span> <span class="token comment">/* 如果存在存储过程insert_t1，则删除 */</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">procedure</span> insert_t1<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">/* 创建存储过程insert_t1 */</span><span class="token keyword">begin</span>    <span class="token keyword">declare</span> i <span class="token keyword">int</span><span class="token punctuation">;</span>                    <span class="token comment">/* 声明变量i */</span>    <span class="token keyword">set</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>                          <span class="token comment">/* 设置i的初始值为1 */</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token keyword">do</span>                  <span class="token comment">/* 对满足i&lt;=100000的值进行while循环 */</span>        <span class="token keyword">insert</span> <span class="token keyword">into</span> t1<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 写入表t1中a、b两个字段，值都为i当前的值 */</span>        <span class="token keyword">set</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                      <span class="token comment">/* 将i加1 */</span>    <span class="token keyword">end</span> <span class="token keyword">while</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span>                 <span class="token comment">/* 创建批量写入10000条数据到表t1的存储过程insert_t1 */</span><span class="token keyword">call</span> insert_t1<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">/* 运行存储过程insert_t1 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-根据自增且连续主键排序的分页查询"><a href="#1-根据自增且连续主键排序的分页查询" class="headerlink" title="1 根据自增且连续主键排序的分页查询"></a>1 根据自增且连续主键排序的分页查询</h3><p>首先来看一个根据自增且连续主键排序的分页查询的例子：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">limit</span> <span class="token number">9000</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该 SQL 表示查询从第 9001 开始的两行数据，没添加单独 order by，表示通过主键排序。我们再看表 t1，因为主键是自增并且连续的，所以可以改写成按照主键去查询从第 9001开始的两行数据，如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> id <span class="token operator">&gt;</span><span class="token number">9000</span> <span class="token keyword">limit</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询的结果是一致的。我们再对比一下执行计划：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">mysql&gt; explain select * from t1 limit 9000,2;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9963 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+1 row in set, 1 warning (0.00 sec)mysql&gt; explain select * from t1 where id &gt;9000 limit 2;+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+|  1 | SIMPLE      | t1    | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL | 1000 |   100.00 | Using where |+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+1 row in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原 SQL 中 key 字段为 NULL，表示未走索引，rows 显示 9963，表示扫描的行数 9963行；</p><p>改写后的 SQL key 字段为 PRIMARY，表示走了主键索引，扫描了1000行。</p><p>显然改写后的 SQL 执行效率更高。</p><p>另外如果原 SQL 是 order by 非主键的字段，按照上面说的方法改写会导致两条 SQL 的结果不一致。所以这种改写得满足以下两个条件：</p><ul><li>主键自增且连续</li><li>结果是按照主键排序的</li></ul><h3 id="2-查询根据非主键字段排序的分页查询"><a href="#2-查询根据非主键字段排序的分页查询" class="headerlink" title="2 查询根据非主键字段排序的分页查询"></a>2 查询根据非主键字段排序的分页查询</h3><p>再看一个根据非主键字段排序的分页查询，SQL 如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">order</span> <span class="token keyword">by</span> a <span class="token keyword">limit</span> <span class="token number">9000</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>看下这条 SQL 的执行计划：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9963 |   100.00 | Using filesort |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发现并没有使用 a 字段的索引（key 字段对应的值为 null），具体原因：<strong>扫描整个索引并查找到没索引的行的成本比扫描全表的成本更高，所以优化器放弃使用索引</strong>。</p><p>知道不走索引的原因，那么怎么优化呢？</p><p>其实关键是<strong>让排序时返回的字段尽可能少</strong>，所以可以让排序和分页操作先查出主键，然后根据主键查到对应的记录，SQL 改写如下（这里参考了《深入浅出 MySQL》18.4.7 优化分页查询）：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 f <span class="token keyword">inner</span> <span class="token keyword">join</span> <span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> t1 <span class="token keyword">order</span> <span class="token keyword">by</span> a <span class="token keyword">limit</span> <span class="token number">9000</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>g <span class="token keyword">on</span> f<span class="token punctuation">.</span>id <span class="token operator">=</span> g<span class="token punctuation">.</span>id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>看下这条 SQL 的执行计划：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+------------+------------+--------+---------------+---------+---------+------+------+----------+-------------+| id | select_type | table      | partitions | type   | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |+----+-------------+------------+------------+--------+---------------+---------+---------+------+------+----------+-------------+|  1 | PRIMARY     | &lt;derived2&gt; | NULL       | ALL    | NULL          | NULL    | NULL    | NULL | 9002 |   100.00 | NULL        ||  1 | PRIMARY     | f          | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | g.id |    1 |   100.00 | NULL        ||  2 | DERIVED     | t1         | NULL       | index  | NULL          | idx_a   | 5       | NULL | 9002 |   100.00 | Using index |+----+-------------+------------+------------+--------+---------------+---------+---------+------+------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原 SQL 使用的是 filesort 排序，而优化后的 SQL 使用的是索引排序。</p><h2 id="08-Join语句可以这样优化"><a href="#08-Join语句可以这样优化" class="headerlink" title="08 Join语句可以这样优化"></a><strong>08 Join语句可以这样优化</strong></h2><p>为了方便理解，首先创建测试表并写入测试数据，语句如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> muke<span class="token punctuation">;</span> <span class="token comment">/* 创建测试使用的database，名为muke */</span><span class="token keyword">use</span> muke<span class="token punctuation">;</span> <span class="token comment">/* 使用muke这个database */</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t1<span class="token punctuation">;</span> <span class="token comment">/* 如果表t1存在则删除表t1 */</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t1<span class="token punctuation">`</span> <span class="token punctuation">(</span> <span class="token comment">/* 创建表t1 */</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">auto_increment</span><span class="token punctuation">,</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>create_time<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'记录创建时间'</span><span class="token punctuation">,</span><span class="token punctuation">`</span>update_time<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token keyword">COMMENT</span> <span class="token string">'记录更新时间'</span><span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_a<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">procedure</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> insert_t1<span class="token punctuation">;</span> <span class="token comment">/* 如果存在存储过程insert_t1，则删除 */</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">procedure</span> insert_t1<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">/* 创建存储过程insert_t1 */</span><span class="token keyword">begin</span><span class="token keyword">declare</span> i <span class="token keyword">int</span><span class="token punctuation">;</span> <span class="token comment">/* 声明变量i */</span><span class="token keyword">set</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* 设置i的初始值为1 */</span><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token keyword">do</span> <span class="token comment">/* 对满足i&lt;=10000的值进行while循环 */</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t1<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 写入表t1中a、b两个字段，值都为i当前的值 */</span><span class="token keyword">set</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* 将i加1 */</span><span class="token keyword">end</span> <span class="token keyword">while</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span> <span class="token comment">/* 创建批量写入10000条数据到表t1的存储过程insert_t1 */</span><span class="token keyword">call</span> insert_t1<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 运行存储过程insert_t1 */</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t2<span class="token punctuation">;</span> <span class="token comment">/* 如果表t2存在则删除表t2 */</span><span class="token keyword">create</span> <span class="token keyword">table</span> t2 <span class="token operator">like</span> t1<span class="token punctuation">;</span> <span class="token comment">/* 创建表t2，表结构与t1一致 */</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t2 <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">limit</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">/* 将表t1的前100行数据导入到t2 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-关联查询的算法"><a href="#1-关联查询的算法" class="headerlink" title="1 关联查询的算法"></a>1 关联查询的算法</h3><p>MySQL 使用以下两种嵌套循环算法或它们的变体在表之间执行连接（参考 《<a href="https://dev.mysql.com/doc/refman/5.7/en/nested-loop-joins.html">MySQL 5.7 Reference Manual》8.2.1.6 Nested-Loop Join Algorithms</a>）：</p><ul><li>Nested-Loop Join 算法</li><li>Block Nested-Loop Join 算法</li></ul><p>另外还有一种算法 Batched Key Access，其实算对 Nested-Loop Join 算法的一种优化。</p><h4 id="1-1-Nested-Loop-Join-算法"><a href="#1-1-Nested-Loop-Join-算法" class="headerlink" title="1.1 Nested-Loop Join 算法"></a>1.1 Nested-Loop Join 算法</h4><p>一个简单的 Nested-Loop Join(NLJ) 算法一次一行循环地从第一张表（称为驱动表）中读取行，在这行数据中取到关联字段，根据关联字段在另一张表（被驱动表）里取出满足条件的行，然后取出两张表的结果合集。</p><p>我们试想一下，如果在被驱动表中这个关联字段没有索引，那么每次取出驱动表的关联字段在被驱动表查找对应的数据时，都会对被驱动表做一次全表扫描，成本是非常高的（比如驱动表数据量是 m，被驱动表数据量是 n，则扫描行数为 m * n ）。</p><p>好在 MySQL 在关联字段有索引时，才会使用 NLJ，如果没索引，就会使用 Block Nested-Loop Join，等下会细说这个算法。我们先来看下在有索引情况的情况下，使用 Nested-Loop Join 的场景（称为：Index Nested-Loop Join）。</p><p>因为 MySQL 在关联字段有索引时，才会使用 NLJ，因此本节后面的内容所用到的 NLJ 都表示 Index Nested-Loop Join。</p><p>如下例：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">inner</span> <span class="token keyword">join</span> t2 <span class="token keyword">on</span> t1<span class="token punctuation">.</span>a <span class="token operator">=</span> t2<span class="token punctuation">.</span>a<span class="token punctuation">;</span>       <span class="token comment">/* sql1 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>表 t1 和表 t2 中的 a 字段都有索引。</p></blockquote><p>怎么确定这条 SQL 使用的是 NLJ 算法？</p><p>我们先来看下 sql1 的执行计划：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+-------+---------+-----------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref       | rows | filtered | Extra       |+----+-------------+-------+------------+------+---------------+-------+---------+-----------+------+----------+-------------+|  1 | SIMPLE      | t2    | NULL       | ALL  | idx_a         | NULL  | NULL    | NULL      |  100 |   100.00 | Using where ||  1 | SIMPLE      | t1    | NULL       | ref  | idx_a         | idx_a | 5       | muke.t2.a |    1 |   100.00 | NULL        |+----+-------------+-------+------------+------+---------------+-------+---------+-----------+------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从执行计划中可以看到这些信息：</p><ul><li>驱动表是 t2，被驱动表是 t1。原因是：explain 分析 join 语句时，在第一行的就是驱动表；选择 t2 做驱动表的原因：如果没固定连接方式（比如没加 straight_join）优化器会优先选择小表做驱动表。<strong>所以使用 inner join 时，前面的表并不一定就是驱动表。</strong></li><li>使用了 NLJ。原因是：一般 join 语句中，如果执行计划 Extra 中未出现 Using join buffer （<em>*</em>）；则表示使用的 join 算法是 NLJ。</li></ul><p>在这个过程中会读取 t2 表的所有数据，因此这里扫描了 100 行，然后遍历这 100 行数据中字段 a 的值，根据 t2 表中 a 的值索引扫描 t1 表中的对应行，这里也扫描了 100 行。因此整个过程扫描了 200 行。</p><p>在前面，我们有说到：如果被驱动表的关联字段没索引，就会使用 Block Nested-Loop Join(简称：BNL)，为什么会选择使用 BNL 算法而不继续使用 Nested-Loop Join呢？下面就一起分析下：</p><h4 id="1-2-Block-Nested-Loop-Join-算法"><a href="#1-2-Block-Nested-Loop-Join-算法" class="headerlink" title="1.2 Block Nested-Loop Join 算法"></a>1.2 Block Nested-Loop Join 算法</h4><p>Block Nested-Loop Join(BNL) 算法的思想是：把驱动表的数据读入到 join_buffer 中，然后扫描被驱动表，把被驱动表每一行取出来跟 join_buffer 中的数据做对比，如果满足 join 条件，则返回结果给客户端。</p><p>我们一起看看下面这条 SQL 语句：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">inner</span> <span class="token keyword">join</span> t2 <span class="token keyword">on</span> t1<span class="token punctuation">.</span>b <span class="token operator">=</span> t2<span class="token punctuation">.</span>b<span class="token punctuation">;</span>       <span class="token comment">/* sql2 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>表 t1 和表 t2 中的 b 字段都没有索引</p></blockquote><p>看下执行计划：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+--------------------------------------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra                                      |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+--------------------------------------------+|  1 | SIMPLE      | t2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   100 |   100.00 | NULL                                       ||  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10225 |    10.00 | Using where; Using join buffer (hash join) |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+--------------------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Extra 发现 Using join buffer (Block Nested Loop)，这个就说明该关联查询使用的是 BNL 算法。</p><p>我们再看下 sql2 的执行流程：</p><ol><li>把 t2 的所有数据放入到 join_buffer 中</li><li>把表 t1 中每一行取出来，跟 join_buffer 中的数据做对比</li><li>返回满足 join 条件的数据</li></ol><p>在这个过程中，对表 t1 和 t2 都做了一次全表扫描，因此扫描的总行数为10000(表 t1 的数据总量) + 100(表 t2 的数据总量) = 10100。并且 join_buffer 里的数据是无序的，因此对表 t1 中的每一行，都要做 100 次判断，所以内存中的判断次数是 100 * 10000= 100 万次。</p><p>下面我们来回答上面提出的一个问题：</p><p>如果被驱动表的关联字段没索引，为什么会选择使用 BNL 算法而不继续使用 Nested-Loop Join 呢？</p><p>在被驱动表的关联字段没索引的情况下，比如 sql2：</p><p>如果使用 Nested-Loop Join，那么扫描行数为 100 * 10000 = 100万次，这个是磁盘扫描。</p><p>如果使用 BNL，那么磁盘扫描是 100 + 10000=10100 次，在内存中判断 100 * 10000 = 100万次。</p><p>显然后者磁盘扫描的次数少很多，因此是更优的选择。因此对于 MySQL 的关联查询，如果被驱动表的关联字段没索引，会使用 BNL 算法。</p><h4 id="1-3-Batched-Key-Access-算法"><a href="#1-3-Batched-Key-Access-算法" class="headerlink" title="1.3 Batched Key Access 算法"></a>1.3 Batched Key Access 算法</h4><p>NLJ 的关键思想是：被驱动表的关联字段有索引。</p><p>BNL 的关键思想是：把驱动表的数据批量提交一部分放到 join_buffer 中。</p><p>从 MySQL 5.6 开始，确实出现了这种集 NLJ 和 BNL 两种算法优点于一体的新算法：<a href="https://dev.mysql.com/doc/refman/5.7/en/bnl-bka-optimization.html">Batched Key Access(BKA)</a>。</p><p>其原理是：</p><ol><li>将驱动表中相关列放入 join_buffer 中</li><li>批量将关联字段的值发送到 Multi-Range Read(MRR) 接口</li><li>MRR 通过接收到的值，根据其对应的主键 ID 进行排序，然后再进行数据的读取和操作</li><li>返回结果给客户端</li></ol><blockquote><p><strong>这里补充下 MRR 相关知识：</strong></p><p>当表很大并且没有存储在缓存中时，使用辅助索引上的范围扫描读取行可能导致对表有很多随机访问。</p><p>而 Multi-Range Read 优化的设计思路是：查询辅助索引时，对查询结果先按照主键进行排序，并按照主键排序后的顺序，进行顺序查找，从而减少随机访问磁盘的次数。</p><p>使用 MRR 时，explain 输出的 Extra 列显示的是 Using MRR。</p><p>optimizer_switch 中 mrr_cost_based 参数的值会影响 MRR。</p><p>如果 mrr_cost_based=on，表示优化器尝试在使用和不使用 MRR 之间进行基于成本的选择。</p><p>如果 mrr_cost_based=off，表示一直使用 MRR。</p><p>更多 MRR 信息请参考官方手册：<a href="https://dev.mysql.com/doc/refman/5.7/en/mrr-optimization.html。">https://dev.mysql.com/doc/refman/5.7/en/mrr-optimization.html。</a></p></blockquote><p>下面尝试开启 BKA ：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">set</span> optimizer_switch<span class="token operator">=</span><span class="token string">'mrr=on,mrr_cost_based=off,batched_key_access=on'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里对上面几个参数做下解释：</p><ul><li>mrr=on 开启 mrr</li><li>mrr_cost_based=off 不需要优化器基于成本考虑使用还是不使用 MRR，也就是一直使用 MRR</li><li>batched_key_access=on 开启 BKA</li></ul><p>然后再看 sql1 的执行计划：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">inner</span> <span class="token keyword">join</span> t2 <span class="token keyword">on</span> t1<span class="token punctuation">.</span>a <span class="token operator">=</span> t2<span class="token punctuation">.</span>a<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+-------+---------+-----------+------+----------+----------------------------------------+| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref       | rows | filtered | Extra                                  |+----+-------------+-------+------------+------+---------------+-------+---------+-----------+------+----------+----------------------------------------+|  1 | SIMPLE      | t2    | NULL       | ALL  | idx_a         | NULL  | NULL    | NULL      |  100 |   100.00 | Using where                            ||  1 | SIMPLE      | t1    | NULL       | ref  | idx_a         | idx_a | 5       | muke.t2.a |    1 |   100.00 | Using join buffer (Batched Key Access) |+----+-------------+-------+------------+------+---------------+-------+---------+-----------+------+----------+----------------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Extra 字段中发现有 Using join buffer (Batched Key Access)，表示确实变成了 BKA 算法。</p><h3 id="2-优化关联查询"><a href="#2-优化关联查询" class="headerlink" title="2 优化关联查询"></a>2 优化关联查询</h3><p>通过上面的知识点，我们知道了关联查询的一些算法，下面一起来讨论下关联查询的优化：</p><h4 id="2-1-关联字段添加索引"><a href="#2-1-关联字段添加索引" class="headerlink" title="2.1 关联字段添加索引"></a>2.1 关联字段添加索引</h4><p>通过上面的内容，我们知道了 BNL、NLJ 和 BKA 的原理，<strong>因此建议在被驱动表的关联字段上添加索引，让 BNL变成 NLJ 或者 BKA ，可明显优化关联查询。</strong></p><h4 id="2-2-小表做驱动表"><a href="#2-2-小表做驱动表" class="headerlink" title="2.2 小表做驱动表"></a>2.2 小表做驱动表</h4><p>前面说到，Index Nested-Loop Join 算法会读取驱动表的所有数据，首先扫描的行数是驱动表的总行数（假设为 n），然后遍历这 n 行数据中关联字段的值，根据驱动表中关联字段的值索引扫描被驱动表中的对应行，这里又会扫描 n 行，因此整个过程扫描了 2n 行。当使用 Index Nested-Loop Join 算法时，扫描行数跟驱动表的数据量成正比。所以<strong>在写 SQL 时，如果确定被关联字段有索引的情况下，建议用小表做驱动表。</strong></p><p>我们来看下以 t2 为驱动表的 SQL：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t2 straight_join t1 <span class="token keyword">on</span> t2<span class="token punctuation">.</span>a <span class="token operator">=</span> t1<span class="token punctuation">.</span>a<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里使用 straight_join 可以固定连接方式，让前面的表为驱动表。</p><h4 id="2-3-临时表"><a href="#2-3-临时表" class="headerlink" title="2.3 临时表"></a>2.3 临时表</h4><p>多数情况我们可以通过在被驱动表的关联字段上加索引来让 join 使用 NLJ 或者 BKA，但有时因为某条关联查询只是临时查一次，如果再去添加索引可能会浪费资源，那么有什么办法优化呢？</p><p>这里提供一种创建临时表的方法。比如下面这条关联查询：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">join</span> t2 <span class="token keyword">on</span> t1<span class="token punctuation">.</span>b<span class="token operator">=</span> t2<span class="token punctuation">.</span>b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>看下执行计划：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+--------------------------------------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra                                      |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+--------------------------------------------+|  1 | SIMPLE      | t2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   100 |   100.00 | NULL                                       ||  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10225 |    10.00 | Using where; Using join buffer (hash join) |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+--------------------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于表 t1 和表 t2 的字段 b都没索引，因此使用的是效率比较低的 BNL 算法。</p><p>现在用临时表的方法对这条 SQL 进行优化：</p><p>首先创建临时表 t1_tmp，表结构与表 t1 一致，只是在关联字段 b 上添加了索引。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TEMPORARY</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t1_tmp<span class="token punctuation">`</span> <span class="token punctuation">(</span>    <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>create_time<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'记录创建时间'</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>update_time<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'记录更新时间'</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_a<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_b<span class="token punctuation">`</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把 t1 表中的数据写入临时表 t1_tmp 中：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">insert</span> <span class="token keyword">into</span> t1_tmp <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行 join 语句：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1_tmp <span class="token keyword">join</span> t2 <span class="token keyword">on</span> t1_tmp<span class="token punctuation">.</span>b<span class="token operator">=</span> t2<span class="token punctuation">.</span>b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们再看下执行计划：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+--------+------------+------+---------------+-------+---------+-----------+------+----------+-------------+| id | select_type | table  | partitions | type | possible_keys | key   | key_len | ref       | rows | filtered | Extra       |+----+-------------+--------+------------+------+---------------+-------+---------+-----------+------+----------+-------------+|  1 | SIMPLE      | t2     | NULL       | ALL  | NULL          | NULL  | NULL    | NULL      |  100 |   100.00 | Using where ||  1 | SIMPLE      | t1_tmp | NULL       | ref  | idx_b         | idx_b | 5       | muke.t2.b |    1 |   100.00 | NULL        |+----+-------------+--------+------------+------+---------------+-------+---------+-----------+------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Extra 没出现 “Block Nested Loop”，说明使用的是 Index Nested-Loop Join，并且扫描行数也大大降低了。</p><p><strong>所以当遇到 BNL 的 join 语句，如果不方便在关联字段上添加索引，不妨尝试创建临时表，然后在临时表中的关联字段上添加索引，然后通过临时表来做关联查询。</strong></p><h2 id="09-为何count-这么慢"><a href="#09-为何count-这么慢" class="headerlink" title="09 为何count(*)这么慢?"></a><strong>09 为何count(*)这么慢?</strong></h2><p>老规矩，先创建测试表并写入数据。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">use</span> muke<span class="token punctuation">;</span> <span class="token comment">/* 使用muke这个database */</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t1<span class="token punctuation">;</span> <span class="token comment">/* 如果表t1存在则删除表t1 */</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t1<span class="token punctuation">`</span> <span class="token punctuation">(</span>    <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>c<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>d<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_a<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_b<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>b<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token operator">=</span><span class="token number">4</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">procedure</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> insert_t1<span class="token punctuation">;</span> <span class="token comment">/* 如果存在存储过程insert_t1，则删除 */</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">procedure</span> insert_t1<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">/* 创建存储过程insert_t1 */</span><span class="token keyword">begin</span><span class="token keyword">declare</span> i <span class="token keyword">int</span><span class="token punctuation">;</span> <span class="token comment">/* 声明变量i */</span><span class="token keyword">set</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* 设置i的初始值为1 */</span><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token keyword">do</span> <span class="token comment">/* 对满足i&lt;=10000的值进行while循环 */</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t1<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 写入表t1中a、b两个字段，值都为i当前的值 */</span><span class="token keyword">set</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* 将i加1 */</span><span class="token keyword">end</span> <span class="token keyword">while</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span> <span class="token comment">/* 创建批量写入10000条数据到表t1的存储过程insert_t1 */</span><span class="token keyword">call</span> insert_t1<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 运行存储过程insert_t1 */</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t1<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token boolean">null</span><span class="token punctuation">,</span><span class="token number">10001</span><span class="token punctuation">,</span><span class="token number">10001</span><span class="token punctuation">,</span><span class="token number">10001</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">10002</span><span class="token punctuation">,</span><span class="token number">10002</span><span class="token punctuation">,</span><span class="token number">10002</span><span class="token punctuation">,</span><span class="token number">10002</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t2<span class="token punctuation">;</span> <span class="token comment">/* 如果表t2存在则删除表t2 */</span><span class="token keyword">create</span> <span class="token keyword">table</span> t2 <span class="token operator">like</span> t1<span class="token punctuation">;</span> <span class="token comment">/* 创建表t2，表结构与t1一致 */</span><span class="token keyword">alter</span> <span class="token keyword">table</span> t2 <span class="token keyword">engine</span> <span class="token operator">=</span>myisam<span class="token punctuation">;</span> <span class="token comment">/* 把t2表改为MyISAM存储引擎 */</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t2 <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1<span class="token punctuation">;</span>  <span class="token comment">/* 把t1表的数据转到t2表 */</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t3<span class="token punctuation">`</span> <span class="token punctuation">(</span>    <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>c<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>d<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span>  <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t3 <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1<span class="token punctuation">;</span>  <span class="token comment">/* 把t1表的数据转到t3表 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-重新认识-count"><a href="#1-重新认识-count" class="headerlink" title="1 重新认识 count()"></a>1 重新认识 count()</h3><h4 id="1-1-count-a-和-count-的区别"><a href="#1-1-count-a-和-count-的区别" class="headerlink" title="1.1 count(a) 和 count(*) 的区别"></a>1.1 count(a) 和 count(*) 的区别</h4><p>当 count() 统计某一列时，比如 count(a)，a 表示列名，是不统计 null 的。</p><p>而 <code>count(*)</code> 无论是否包含空值，都会统计。</p><h4 id="1-2-MyISAM-引擎和-InnoDB-引擎-count-的区别"><a href="#1-2-MyISAM-引擎和-InnoDB-引擎-count-的区别" class="headerlink" title="1.2 MyISAM 引擎和 InnoDB 引擎 count(*) 的区别"></a>1.2 MyISAM 引擎和 InnoDB 引擎 count(*) 的区别</h4><p>对于 MyISAM 引擎，如果没有 where 子句，也没检索其它列，那么 <code>count(*)</code> 将会非常快。因为 MyISAM 引擎会把表的总行数存在磁盘上。</p><p>首先我们看下对 t2 表（存储引擎为 MyISAM）不带 where 子句做 <code>count(*)</code> 的执行计划：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> t2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                        |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | Select tables optimized away |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Extra 字段发现 “Select tables optimized away” 关键字，表示是从 MyISAM 引擎维护的准确行数上获取到的统计值。</p><p>而 InnoDB 并不会保留表中的行数，<strong>因为并发事务可能同时读取到不同的行数</strong>。所以执行 <code>count(*)</code> 时都是临时去计算的，会比 MyISAM 引擎慢很多。</p><p>我们看下对 t1 表（存储引擎为 InnoDB）执行 <code>count(*)</code> 的执行计划：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">mysql&gt; explain select count(*) from t1;+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+| id | select_type | table | partitions | type  | possible_keys | key   | key_len | ref  | rows  | filtered | Extra       |+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+|  1 | SIMPLE      | t1    | NULL       | index | NULL          | idx_b | 4       | NULL | 10147 |   100.00 | Using index |+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发现使用的是 b 字段的索引 idx_b，并且扫描行数是10109，表示会遍历 b 字段的索引树去计算表的总量。</p><p>对比 MyISAM 引擎和 InnoDB 引擎 <code>count(*)</code> 的区别，可以知道：</p><ul><li>MyISAM 会维护表的总行数，放在磁盘中，如果有 <code>count(*)</code> 的需求，直接返回这个数据</li><li>但是 InnoDB 就会去遍历普通索引树，计算表数据总量</li></ul><p>在上面这个例子，InnoDB 表 t1 在执行 <code>count(*)</code> 时，为什么会走 b 字段的索引而不是走主键索引呢？下面我们分析下：</p><h4 id="1-3-MySQL-5-7-18-前后-count-的区别"><a href="#1-3-MySQL-5-7-18-前后-count-的区别" class="headerlink" title="1.3 MySQL 5.7.18 前后 count(*) 的区别"></a>1.3 MySQL 5.7.18 前后 count(*) 的区别</h4><p>在 MySQL 5.7.18 之前，InnoDB 通过扫描聚簇索引来处理 <code>count(*)</code> 语句。</p><p>从 MySQL 5.7.18 开始，通过遍历最小的可用二级索引来处理 <code>count(*)</code> 语句。如果不存在二级索引，则扫描聚簇索引。但是，如果索引记录不完全在缓存池中的话，处理 <code>count(*)</code> 也是比较久的。</p><p>新版本为什么会使用二级索引来处理 <code>count(*)</code> 语句呢？</p><p>原因是 InnoDB 二级索引树的叶子节点上存放的是主键，而主键索引树的叶子节点上存放的是整行数据，所以二级索引树比主键索引树小。因此优化器基于成本的考虑，优先选择的是二级索引。所以 count(主键) 其实没 <code>count (*)</code> 快。</p><h4 id="1-4-count-1-比-count-快吗？"><a href="#1-4-count-1-比-count-快吗？" class="headerlink" title="1.4 count(1) 比 count(*) 快吗？"></a>1.4 count(1) 比 count(*) 快吗？</h4><p>在前面我们知道 <code>count(*)</code> 无论是否包含空值，所有结果都会统计。</p><p>而 count(1)中的 1 是恒真表达式，因此也会统计所有结果。</p><p>所以 count(1) 和 <code>count(*)</code> 统计结果没差别。</p><p>我们来对比 count(1) 和 count(* ) 的执行计划：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">mysql&gt; explain select count(1) from t1;+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+| id | select_type | table | partitions | type  | possible_keys | key   | key_len | ref  | rows  | filtered | Extra       |+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+|  1 | SIMPLE      | t1    | NULL       | index | NULL          | idx_b | 4       | NULL | 10147 |   100.00 | Using index |+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+mysql&gt; explain select count(*) from t1;+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+| id | select_type | table | partitions | type  | possible_keys | key   | key_len | ref  | rows  | filtered | Extra       |+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+|  1 | SIMPLE      | t1    | NULL       | index | NULL          | idx_b | 4       | NULL | 10147 |   100.00 | Using index |+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行计划一样，所以 count(1) 并不比 count(*) 快。</p><h3 id="2-哪些方法可以加快-count"><a href="#2-哪些方法可以加快-count" class="headerlink" title="2 哪些方法可以加快 count()"></a>2 哪些方法可以加快 count()</h3><h4 id="2-1-show-table-status"><a href="#2-1-show-table-status" class="headerlink" title="2.1 show table status"></a>2.1 show table status</h4><p>有时，我们只需要知道某张表的大概数据量，这种情况就可以使用 show table status，具体用法如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">table</span> <span class="token keyword">status</span> <span class="token operator">like</span> <span class="token string">'t1'</span>\G<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">...Rows: 10147...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Rows 这列就表示这张表的行数。这种方式获取 InnoDB 表的行数非常快。</p><p><strong>但是，这个值是个估算值，可能与实际值相差 40% 到 50%</strong>。（对于 Rows 这个字段更详细的解释，可以参考官方手册：<a href="https://dev.mysql.com/doc/refman/5.7/en/show-table-status.html）">https://dev.mysql.com/doc/refman/5.7/en/show-table-status.html）</a></p><h4 id="2-2-用-Redis-做计数器"><a href="#2-2-用-Redis-做计数器" class="headerlink" title="2.2 用 Redis 做计数器"></a>2.2 用 Redis 做计数器</h4><h4 id="2-3-增加计数表"><a href="#2-3-增加计数表" class="headerlink" title="2.3 增加计数表"></a>2.3 增加计数表</h4><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/增加计数表.png" alt="增加计数表"></p><hr><p>第2章 MySQL索引</p><h2 id="10-为什么添加索引能提高查询速度"><a href="#10-为什么添加索引能提高查询速度" class="headerlink" title="10 为什么添加索引能提高查询速度?"></a><strong>10 为什么添加索引能提高查询速度?</strong></h2><p>为了便于理解 MySQL 的索引，我们先了解一些与索引相关的算法。</p><h3 id="1-跟索引相关的一些算法"><a href="#1-跟索引相关的一些算法" class="headerlink" title="1 跟索引相关的一些算法"></a>1 跟索引相关的一些算法</h3><p>对于 MySQL 而言，使用最频繁的就是 B+ 树索引，所以我们必须要知道 B+ 树的结构，而 B+ 树是借鉴了二分查找法、二叉查找树、平衡二叉树、B 树的一些思想构建的。因此我们首先通过了解这些算法，来一层一层拨开 B+ 树的神秘面纱。</p><h4 id="1-1-二分查找法"><a href="#1-1-二分查找法" class="headerlink" title="1.1 二分查找法"></a>1.1 二分查找法</h4><p>二分查找法的查找过程是：将记录按顺序排列，查找时先以有序列的中点位置为比较对象，如果要找的元素值小于该中点元素，则将查询范围缩小为左半部分；如果要找的元素值大于该中点元素，则将查询范围缩小为右半部分。以此类推，直到查到需要的值。<br><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/二分查找法.png" alt="二分查找法"></p><h4 id="1-2-二叉查找树"><a href="#1-2-二叉查找树" class="headerlink" title="1.2 二叉查找树"></a>1.2 二叉查找树</h4><p>二叉查找树中，左子树的键值总是小于根的键值，右子树的键值总是大于根的键值，并且每个节点最多只有两颗子树。<br><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/二叉查找树.png" alt="二叉查找树"></p><h4 id="1-3-平衡二叉树"><a href="#1-3-平衡二叉树" class="headerlink" title="1.3 平衡二叉树"></a>1.3 平衡二叉树</h4><p>平衡二叉树的定义：满足二叉查找树的定义，另外必须满足任何节点的两个子树的高度差最大为 1。<br><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/平衡二叉树.png" alt="平衡二叉树"></p><h4 id="1-4-B-树"><a href="#1-4-B-树" class="headerlink" title="1.4 B 树"></a>1.4 B 树</h4><p>B 树可以理解为一个节点可以拥有多于 2 个子节点的平衡多叉查找树。</p><p>B 树中同一键值不会出现多次，要么在叶子节点，要么在内节点上。</p><p>比如用 1、2、3、5、6、7、9 这些数字构建一个 B 树结构，其图形如下：<br><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/B树.png" alt="B树"></p><p>与平衡二叉树相比，B 树利用多个分支（平衡二叉树只有两个分支）节点，减少获取记录时所经历的节点数。</p><p>B 树也是有缺点的，因为每个节点都包含 key 值和 data 值，因此如果 data 比较大时，每一页存储的 key 会比较少；当数据比较多时，同样会有：“要经历多层节点才能查询在叶子节点的数据”的问题。这时，B+ 树站了出来。</p><h4 id="1-5-B-树"><a href="#1-5-B-树" class="headerlink" title="1.5 B+ 树"></a>1.5 B+ 树</h4><p>B+ 树是 B 树的变体，定义基本与 B 树一致，与 B 树的不同点：</p><ul><li>所有叶子节点中包含了全部关键字的信息</li><li>各叶子节点用指针进行连接</li><li>非叶子节点上只存储 key 的信息，这样相对 B 树，可以增加每一页中存储 key 的数量。</li><li>B 树是纵向扩展，最终变成一个“瘦高个”，而 B+ 树是横向扩展的，最终会变成一个“矮胖子”（这里参考了《MySQL 运维内参》第 8 节 B+ 树及 B 树的区别中的比喻）。</li></ul><p>在 B+ 树中，所有记录节点都是按键值的大小顺序存放在同一层的叶子节点上。B+ 树中的 B 不是代表二叉(binary) 而是代表（balance），B+ 树并不是一个二叉树。</p><p>还是根据前面提到的这组数字（1、2、3、5、6、7、9）举例，它的结构如下：</p><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/Bplus树.png" alt="Bplus树"></p><p>与 1.4 中 B 树的结构最大的区别就是：</p><p>它的键一定会出现在叶子节点上，同时也有可能在非叶子节点中重复出现。而 B 树中同一键值不会出现多次。</p><h3 id="2-B-树索引"><a href="#2-B-树索引" class="headerlink" title="2 B+ 树索引"></a>2 B+ 树索引</h3><p>B+ 树索引就是基于本节前面介绍的 B+ 树发展而来的。在数据库中，B+ 树的高度一般都在 2 ~ 4 层，所以<strong>查找某一行数据最多只需要 2 到 4 次 IO。而没索引的情况，需要逐行扫描，明显效率低很多，这也就是为什么添加索引能提高查询速度。</strong></p><p>B+ 树索引并不能找到一个给定键值的具体行，B+ 树索引能找到的只是被查找数据行所在的页。然后数据库通过把页读入到缓冲池（buffer pool）中，在内存中通过二分查找法进行查找，得到需要的数据。</p><p>InnoDB 中 B+ 树索引分为聚集索引和辅助索引，我们再继续了解这两种索引的特点。</p><p>为了方便理解，我们先创建一张测试表并写入数据：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">use</span> muke<span class="token punctuation">;</span> <span class="token comment">/* 使用muke这个database */</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t8<span class="token punctuation">;</span> <span class="token comment">/* 如果表t1存在则删除表t1 */</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t8<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_a<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span>  <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t8<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">'e'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token string">'f'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token string">'g'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token string">'i'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-聚集索引"><a href="#2-1-聚集索引" class="headerlink" title="2.1 聚集索引"></a>2.1 聚集索引</h4><p>InnoDB 的数据是按照主键顺序存放的，而聚集索引就是按照每张表的主键构造一颗 B+ 树，它的叶子节点存放的是整行数据。</p><p>InnoDB 的主键一定是聚集索引。如果没有定义主键，聚集索引可能是第一个不允许为 null 的唯一索引，也有可能是 row id。</p><p>由于实际的数据页只能按照一颗 B+ 树进行排序，因此每张表只能有一个聚集索引（TokuDB 引擎除外）。查询优化器倾向于采用聚集索引，因为聚集索引能够在 B+ 树索引的叶子节点上直接找到数据。</p><p>聚集索引对于主键的排序查找和范围查找速度非常快。</p><p>对于刚刚创建好的测试表 t8的聚集索引的大致结构如下：</p><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/表t8的聚集索引的大致结构.png" alt="表t8的聚集索引的大致结构"></p><p>两点关键信息：</p><ul><li>根据主键值创建了 B+ 树结构</li><li>每个叶子节点包含了整行数据</li></ul><h4 id="2-2-辅助索引"><a href="#2-2-辅助索引" class="headerlink" title="2.2 辅助索引"></a>2.2 辅助索引</h4><p>我们现在知道了聚集索引的叶子节点存放了整行数据，而 InnoDB 存储引擎辅助索引的叶子节点并不会放整行数据，而存放的是键值和主键 ID。</p><p>当通过辅助索引来寻找数据时，InnoDB 存储引擎会遍历辅助索引树查找到对应记录的主键，然后通过主键索引来找到对应的行数据。</p><p>比如一颗高度为 3 的辅助索引树中查找数据，那需要对这颗辅助索引树遍历 3 次找到指定主键，如果聚集索引树的高度也为 3，那么还需要对聚集索引树进行 3 次查找，最终找到一个完整的行数据所在的页，因此获取数据一共需要6次逻辑 IO 访问。</p><p>我们继续拿表 t8 分析，它的辅助索引 idx_a 结构如下：</p><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/表t8的辅助索引idx_a的大致结构.png" alt="表t8的辅助索引idx_a的大致结构"></p><p>上图中两点关键点需要注意：</p><ul><li>根据 a 字段的值创建了 B+ 树结构</li><li>每个叶子节点保存的是 a 字段自己的键值和主键 ID</li></ul><p>对于表 t8，比如有下面这条查询语句：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t8 <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它先通过 a 字段上的索引树，得到主键 id 为 3，再到 id 的聚集索引树上找到对应的行数据。</p><p>而下面这条 SQL:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t8 <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询到的结果是一样的，而执行过程则只需要搜索 id 的聚集索引树。我们能看出辅助索引的查询比主键查询多扫描一颗索引树，所以，我们应该<strong>尽量使用主键做为条件进行查询</strong>。</p><h2 id="11-哪些情况需要添加索引？"><a href="#11-哪些情况需要添加索引？" class="headerlink" title="11 哪些情况需要添加索引？"></a><strong>11 哪些情况需要添加索引？</strong></h2><p>首先创建测试表并写入数据：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">use</span> muke<span class="token punctuation">;</span> <span class="token comment">/* 使用muke这个database */</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t9_1<span class="token punctuation">;</span> <span class="token comment">/* 如果表t9_1存在则删除表t9_1 */</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t9_1<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>c<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>d<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_a<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_b_c<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>b<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>c<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span>  <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">procedure</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> insert_t9_1<span class="token punctuation">;</span> <span class="token comment">/* 如果存在存储过程insert_t9_1，则删除 */</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">procedure</span> insert_t9_1<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">/* 创建存储过程insert_t9_1 */</span><span class="token keyword">begin</span><span class="token keyword">declare</span> i <span class="token keyword">int</span><span class="token punctuation">;</span> <span class="token comment">/* 声明变量i */</span><span class="token keyword">set</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* 设置i的初始值为1 */</span><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token number">100000</span><span class="token punctuation">)</span><span class="token keyword">do</span> <span class="token comment">/* 对满足i&lt;=100000的值进行while循环 */</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t9_1<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 写入表t9_1中a、b两个字段，值都为i当前的值 */</span><span class="token keyword">set</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* 将i加1 */</span><span class="token keyword">end</span> <span class="token keyword">while</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span> <span class="token comment">/* 创建批量写入100000条数据到表t9_1的存储过程insert_t9_1 */</span><span class="token keyword">call</span> insert_t9_1<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 运行存储过程insert_t9_1 */</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t9_1<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span> <span class="token keyword">select</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d <span class="token keyword">from</span> t9_1<span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t9_1<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span> <span class="token keyword">select</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d <span class="token keyword">from</span> t9_1<span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t9_1<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span> <span class="token keyword">select</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d <span class="token keyword">from</span> t9_1<span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t9_1<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span> <span class="token keyword">select</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d <span class="token keyword">from</span> t9_1<span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t9_1<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span> <span class="token keyword">select</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d <span class="token keyword">from</span> t9_1<span class="token punctuation">;</span><span class="token comment">/*  把t9_1的数据量扩大到160万 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>目前比较常见需要创建索引的场景有：数据检索时在条件字段添加索引、聚合函数对聚合字段添加索引、对排序字段添加索引、为了防止回表添加索引、关联查询在关联字段添加索引等。我们就一一分析这些需要创建索引的场景：</p><h3 id="1-数据检索"><a href="#1-数据检索" class="headerlink" title="1 数据检索"></a>1 数据检索</h3><p>用上面的表 t9_1 做测试，首先把没有索引的字段 d 作为条件进行查询：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t9_1 <span class="token keyword">where</span> d <span class="token operator">=</span> <span class="token number">90000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>发现查询时间需要0.44 秒</p><p>再把有索引的字段 a 作为条件进行查询</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t9_1 <span class="token keyword">where</span> a <span class="token operator">=</span> <span class="token number">90000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>发现查询时间为 0.00 sec，表示执行时间不超过 10 毫秒，非常快。</p><p>我们再对比两条 SQL 的执行计划：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">mysql&gt; explain select * from t9_1 where d = 90000;+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows    | filtered | Extra       |+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+|  1 | SIMPLE      | t9_1  | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 3192096 |    10.00 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+mysql&gt; explain select * from t9_1 where a = 90000;+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref   | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+|  1 | SIMPLE      | t9_1  | NULL       | ref  | idx_a         | idx_a | 5       | const |   32 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>前者 type 字段为 ALL，后者 type 字段为 ref，显然后者性能更好</p><p>rows 这个字段前者是 3192096，而后者是 32，有索引的情况扫描行数大大降低。</p><p>因此建议数据检索时，在条件字段添加索引。</p><h3 id="2-聚合函数"><a href="#2-聚合函数" class="headerlink" title="2 聚合函数"></a>2 聚合函数</h3><p>在测试表 t9_1 中，如果要求出无索引字段 d 的最大值，SQL 如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token function">max</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token keyword">from</span> t9_1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行时间为 0.33 秒。</p><p>再看下求有索引的字段 a 的最大值：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token function">max</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token keyword">from</span> t9_1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行时间为 0.00 秒，表示执行时间不超过 10 毫秒。</p><p>相比对没有索引的字段 d 求最大值（花费330毫秒），<strong>显然索引能提升 max() 函数的效率，同理也能提升 min() 函数的效率</strong>。</p><p>在第 7 节中的 1.3 小节中有介绍 MySQL 5.7.18 之后版本的 <code>count(*)</code> 特点：从 MySQL 5.7.18 开始，通过遍历最小的可用二级索引来处理 <code>count(*)</code> 语句，如果不存在二级索引，则扫描聚簇索引。原因是：InnoDB 二级索引树的叶子节点上存放的是主键，而主键索引树的叶子节点上存放的是整行数据，所以二级索引树比主键索引树小。因此优化器基于成本的考虑，优先选择的是二级索引。</p><p><strong>因此索引对聚合函数 count(*) 也有优化作用。</strong></p><h3 id="3-排序"><a href="#3-排序" class="headerlink" title="3 排序"></a>3 排序</h3><p>在第 4 节 2.1 小节，我们列出了几种通过添加合适索引优化 order by 的方法，这里再做一次总结（如果对下面的总结不是很理解，可以复习第 4 节的内容，有对每种情况举例说明）：</p><ul><li>如果对单个字段排序，则可以在这个排序字段上添加索引来优化排序语句；</li><li>如果是多个字段排序，可以在多个排序字段上添加联合索引来优化排序语句；</li><li>如果是先等值查询再排序，可以通过在条件字段和排序字段添加联合索引来优化排序语句。</li></ul><h3 id="4-避免回表"><a href="#4-避免回表" class="headerlink" title="4 避免回表"></a>4 避免回表</h3><p>比如下面这条 SQL：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> a<span class="token punctuation">,</span>d <span class="token keyword">from</span> t9_1 <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">90000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以走 a 字段的索引，但是在学了第 8 节后，我们知道了辅助索引的结构，如果通过辅助索引来寻找数据，InnoDB 存储引擎会遍历辅助索引树查找到对应记录的主键，然后通过主键索引回表去找对应的行数据。</p><p>但是，如果条件字段和需要查询的字段有联合索引的话，其实回表这一步就省了，因为联合索引中包含了这两个字段的值。像这种索引就已经覆盖了我们的查询需求的场景，我们称为：覆盖索引。比如下面这条 SQL：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> b<span class="token punctuation">,</span>c <span class="token keyword">from</span> t9_1 <span class="token keyword">where</span> b<span class="token operator">=</span><span class="token number">90000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可直接通过联合索引 idx_b_c 找到 b、c 的值（联合索引详细讲解将放在第 11 节）。</p><p><strong>所以可以通过添加覆盖索引让 SQL 不需要回表，从而减少树的搜索次数，让查询更快地返回结果。</strong></p><h3 id="5-关联查询"><a href="#5-关联查询" class="headerlink" title="5 关联查询"></a>5 关联查询</h3><p>在第 6 节中，我们讲到了关联查询的一些优化技巧，其中一个优化方式就是：通过在关联字段添加索引，让 BNL变成 NLJ 或者 BKA。</p><h3 id="6-总结-1"><a href="#6-总结-1" class="headerlink" title="6 总结"></a>6 总结</h3><p>本节讲解了常见需要添加索引的场景：</p><ul><li>数据检索时在条件字段添加索引</li><li>聚合函数对聚合字段添加索引</li><li>对排序字段添加索引</li><li>为了防止回表添加索引</li><li>关联查询在关联字段添加索引</li></ul><h2 id="12-普通索引和唯一索引有哪些区别？"><a href="#12-普通索引和唯一索引有哪些区别？" class="headerlink" title="12 普通索引和唯一索引有哪些区别？"></a><strong>12 普通索引和唯一索引有哪些区别？</strong></h2><p>对于普通索引和唯一索引的区别，也许你已经知道：有普通索引的字段可以写入重复的值，而有唯一索引的字段不可以写入重复的值。其实对于 MySQL 来说，不止这一种区别。今天我们就再深入探究一下普通索引和唯一索引的区别。</p><p>在讨论两者的区别前，我们首先学习一下 Insert Buffer 和 Change Buffer。</p><h3 id="1-Insert-Buffer"><a href="#1-Insert-Buffer" class="headerlink" title="1 Insert Buffer"></a>1 Insert Buffer</h3><p>对于非聚集索引的插入时，先判断插入的非聚集索引页是否在缓冲池中。如果在，则直接插入；如果不在，则先放入 Insert Buffer 中，然后再以一定频率和情况进行 Insert Buffer 和辅助索引页子节点的 merge 操作。这时通常能将多个插入合并到一个操作中（因为在一个索引页中），就大大提高了非聚集索引的插入性能。</p><blockquote><p>增加 Insert Buffer 有两个好处：</p><ul><li>减少磁盘的离散读取</li><li>将多次插入合并为一次操作</li></ul></blockquote><p>但是得注意的是，使用 Insert Buffer 得满足两个条件：</p><ul><li>索引是辅助索引</li><li>索引不是唯一</li></ul><h3 id="2-Change-Buffer"><a href="#2-Change-Buffer" class="headerlink" title="2 Change Buffer"></a>2 Change Buffer</h3><p>InnoDB 从 1.0.x 版本开始引入了 Change Buffer，可以算是对 Insert Buffer 的升级。从这个版本开始，InnoDB 存储引擎可以对 insert、delete、update 都进行缓存。</p><p>影响参数有两个：</p><ul><li>innodb_change_buffering：确定哪些场景使用 Change Buffer，它的值包含：none、inserts、deletes、changes、purges、all。默认为 all，表示启用所有。</li><li>innodb_change_buffer_max_size：控制 Change Buffer 最大使用内存占总 buffer pool 的百分比。默认25，表示最多可以使用 buffer pool 的 25%，最大值50。</li></ul><p>跟 Insert Buffer 一样，Change Buffer 也得满足这两个条件：</p><ul><li>索引是辅助索引</li><li>索引不是唯一</li></ul><p>为什么唯一索引的更新不使用 Change Buffer ?</p><p>原因：唯一索引<strong>必须要将数据页读入内存才能判断是否违反唯一性约束</strong>。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 Change Buffer 了。</p><h3 id="3-普通索引和唯一索引的区别"><a href="#3-普通索引和唯一索引的区别" class="headerlink" title="3 普通索引和唯一索引的区别"></a>3 普通索引和唯一索引的区别</h3><p>通过上面对 Insert Buffer 和 Change Buffer 的了解，也许你已经知道了普通索引和唯一索引的另外一种区别：<strong>如果对数据有修改操作，则普通索引可以用 Change Buffer，而唯一索引不行。</strong></p><p>在上面讲解 Change Buffer 时，也提到了修改唯一索引必须判断是否违反唯一性约束，其实在 RR 隔离级别（事务隔离级别将在第 4 章重点讲解）下，可能会出现一个比较严重的问题：死锁。</p><p>那么查询过程两者的区别呢？</p><p>对于普通索引，查找到满足条件的第一个记录，还需要查找下一个记录，直到不满足条件。</p><p>对于唯一索引来说，查找到第一个记录返回结果就结束了。</p><p>但是 InnoDB 是按页从磁盘读取的，所以很大可能根据该普通索引查询的数据都在一个数据页里，因此如果通过普通索引查找到第一条满足条件所在的数据页，再查找后面的记录很大概率都在之前的数据页里，也就是多了几次内存扫描，实际这种消耗可以忽略不计。</p><p>这里总结一下普通索引和唯一索引的隐藏区别：</p><ul><li>数据修改时，普通索引可以用 Change Buffer，而唯一索引不行。</li><li>数据修改时，唯一索引在 RR 隔离级别下，更容易出现死锁。</li><li>查询数据时，普通索引查到满足条件的第一条记录还需要继续查找下一个记录，而唯一索引查找到第一个记录就可以直接返回结果了，但是普通索引多出的查找次数所消耗的资源多数情况可以忽略不计。</li></ul><h3 id="4-普通索引和唯一索引如何选择"><a href="#4-普通索引和唯一索引如何选择" class="headerlink" title="4 普通索引和唯一索引如何选择"></a>4 普通索引和唯一索引如何选择</h3><p>上面说了普通索引和唯一索引的区别，那么两者应该如何选择呢？</p><p>如果业务要求某个字段唯一，但是代码不能完全保证写入唯一值，则添加唯一索引，让这个字段唯一，该字段新增重复数据时，将报类似如下的错：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">ERROR 1062 (23000): Duplicate entry '1' for key 'f1'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果代码确定某个字段不会有重复的数据写入，则可以选择添加普通索引。 因为普通索引可以使用 Change Buffer，并且出现死锁的概率比唯一索引低。</p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h3><p>普通索引和唯一索引的区别：</p><ul><li>有普通索引的字段可以写入重复的值，而有唯一索引的字段不可以写入重复的值。</li><li>数据修改时，普通索引优于唯一索引，因为普通索引可以用 Change Buffer，并且 RR 隔离级别下，出现死锁的概率比唯一索引低。</li><li>查询数据时，两者性能差别不大。</li></ul><h2 id="13-联合索引有哪些讲究"><a href="#13-联合索引有哪些讲究" class="headerlink" title="13 联合索引有哪些讲究?"></a><strong>13 联合索引有哪些讲究?</strong></h2><h3 id="1-认识联合索引"><a href="#1-认识联合索引" class="headerlink" title="1 认识联合索引"></a>1 认识联合索引</h3><p>联合索引：是指对表上的多个列进行索引。适合 where 条件中的多列组合，在某些场景可以避免回表。</p><p>我们拿讲解 order by 时使用的联合索引 B+ 树图进行理解，如下图：</p><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/使用范围查询再排序.png" alt="使用范围查询再排序"></p><p>联合索引的键值数量大于 1（比如上图中有 a 和 b 两个键值），与单个键值的 B+ 树一样，也是按照键值排序的。<strong>对于 a、b 两个字段都做为条件时，查询是可以走索引的；对于单独 a 字段查询也是可以走索引的。但是对于 b 字段单独查询就走不了索引了。</strong></p><p>联合索引的建议：</p><ul><li>where 条件中，经常同时出现的列放在联合索引中。</li><li>把选择性最大的列放在联合索引的最左边。</li></ul><p>老规矩，创建测试表并写入数据：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">use</span> muke<span class="token punctuation">;</span> <span class="token comment">/* 使用muke这个database */</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t11<span class="token punctuation">;</span> <span class="token comment">/* 如果表t11存在则删除表t11 */</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t11<span class="token punctuation">`</span> <span class="token punctuation">(</span> <span class="token comment">/* 创建表t11 */</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>c<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>d<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_a_b_c<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>b<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>c<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4 <span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t11<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 写入一些数据 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-联合索引使用分析"><a href="#2-联合索引使用分析" class="headerlink" title="2 联合索引使用分析"></a>2 联合索引使用分析</h3><h4 id="2-1-可以完整用到联合索引的情况"><a href="#2-1-可以完整用到联合索引的情况" class="headerlink" title="2 .1 可以完整用到联合索引的情况"></a>2 .1 可以完整用到联合索引的情况</h4><p>下面我们列出几种可以完整用到联合索引的情况，并查看其执行计划，然后进行简短的分析：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t11 <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">and</span> b<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">and</span> c<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* sql1 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref               | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+-----------+---------+-------------------+------+----------+-------+|  1 | SIMPLE      | t11   | NULL       | ref  | idx_a_b_c     | idx_a_b_c | 15      | const,const,const |    1 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+-----------+---------+-------------------+------+----------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>explain 中的 key_len 列用于表示这次查询中，所选择的索引长度有多少字节，常用于判断联合索引有多少列被选择了。下表总结了常用字段类型的 key_len：</p><div class="table-container"><table><thead><tr><th style="text-align:left">列类型</th><th style="text-align:left">KEY_LEN</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">int</td><td style="text-align:left">key_len = 4+1</td><td style="text-align:left">int 为 4 bytes，允许为 NULL，加 1 byte</td></tr><tr><td style="text-align:left">int not null</td><td style="text-align:left">key_len = 4</td><td style="text-align:left">不允许为 NULL</td></tr><tr><td style="text-align:left">bigint</td><td style="text-align:left">key_len=8+1</td><td style="text-align:left">bigint 为 8 bytes，允许为 NULL 加 1 byte</td></tr><tr><td style="text-align:left">bigint not null</td><td style="text-align:left">key_len=8</td><td style="text-align:left">bigint 为 8 bytes</td></tr><tr><td style="text-align:left">char(30) utf8</td><td style="text-align:left">key_len=30*3+1</td><td style="text-align:left">char(n)为：n * 3 ，允许为 NULL 加 1 byte</td></tr><tr><td style="text-align:left">char(30) not null utf8</td><td style="text-align:left">key_len=30*3</td><td style="text-align:left">不允许为 NULL</td></tr><tr><td style="text-align:left">varchar(30) not null utf8</td><td style="text-align:left">key_len=30*3+2</td><td style="text-align:left">utf8 每个字符为 3 bytes，变长数据类型,加 2 bytes</td></tr><tr><td style="text-align:left">varchar(30) utf8</td><td style="text-align:left">key_len=30*3+2+1</td><td style="text-align:left">utf8 每个字符为 3 bytes，允许为 NULL,加 1 byte,变长数据类型，加 2 bytes</td></tr><tr><td style="text-align:left">datetime</td><td style="text-align:left">key_len=8+1 (MySQL 5.6.4之前的版本)；key_len=5+1(MySQL 5.6.4及之后的版本)</td><td style="text-align:left">允许为 NULL，加 1 byte</td></tr></tbody></table></div><p>因为 a、b、c 三个字段都是可以为 NULL 的 int 型。可以知道三个字段的 key_len 都是 5，所以如果完整使用索引 idx_a_b_c，则 key_len 对应的值为 15。再回到上面 sql1 的执行计划中：key_len 显示是 15，而 key 列对应的是 idx_a_b_c，所以 sql1 完整用到了联合索引 idx_a_b_c。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t11 <span class="token keyword">where</span> c<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">and</span> b<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">and</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">/* sql2 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref               | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+-----------+---------+-------------------+------+----------+-------+|  1 | SIMPLE      | t11   | NULL       | ref  | idx_a_b_c     | idx_a_b_c | 15      | const,const,const |    1 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+-----------+---------+-------------------+------+----------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>跟 sql1 的执行计划一样，因此联合索引各字段都做为条件时，各字段的位置不会影响联合索引的使用。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t11 <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">2</span> <span class="token operator">and</span> b <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">and</span> c<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">/* sql3 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type  | possible_keys | key       | key_len | ref  | rows | filtered | Extra                 |+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------+|  1 | SIMPLE      | t11   | NULL       | range | idx_a_b_c     | idx_a_b_c | 15      | NULL |    2 |   100.00 | Using index condition |+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当联合索引前面的字段使用了范围查询，后面的字段做为条件时仍然可以使用完整的联合索引。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t11 <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">and</span> b<span class="token operator">=</span><span class="token number">2</span> <span class="token keyword">order</span> <span class="token keyword">by</span> c<span class="token punctuation">;</span>  <span class="token comment">/* sql4 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref         | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------+|  1 | SIMPLE      | t11   | NULL       | ref  | idx_a_b_c     | idx_a_b_c | 10      | const,const |    4 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>联合索引前面的字段做为条件时，对后面的字段做排序可以使用完整的联合索引。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t11 <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">order</span> <span class="token keyword">by</span> b<span class="token punctuation">,</span>c<span class="token punctuation">;</span>  <span class="token comment">/* sql5 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref   | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-------+|  1 | SIMPLE      | t11   | NULL       | ref  | idx_a_b_c     | idx_a_b_c | 5       | const |    5 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与 sql4 相似，对联合索引第一个字段做条件筛选时，对后面两个字段做排序可以使用完整的联合索引。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c <span class="token keyword">from</span> t11 <span class="token keyword">order</span> <span class="token keyword">by</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">;</span>  <span class="token comment">/* sql6 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type  | possible_keys | key       | key_len | ref  | rows | filtered | Extra       |+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-------------+|  1 | SIMPLE      | t11   | NULL       | index | NULL          | idx_a_b_c | 15      | NULL |   15 |   100.00 | Using index |+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对联合索引的字段同时做排序时（但是排序的三个字段顺序要跟联合索引中三个字段的顺序一致），可以完整用到联合索引。</p><h4 id="2-2-只能使用部分联合索引的情况"><a href="#2-2-只能使用部分联合索引的情况" class="headerlink" title="2.2 只能使用部分联合索引的情况"></a>2.2 只能使用部分联合索引的情况</h4><p>有些场景只能用到部分联合索引，这里就列出几种情况。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t11 <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">and</span> b<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* sql11 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref         | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------+|  1 | SIMPLE      | t11   | NULL       | ref  | idx_a_b_c     | idx_a_b_c | 10      | const,const |    1 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当条件只包含联合索引的前面部分字段时，可以用到部分联合索引。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t11 <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">and</span> c<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* sql12 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-----------------------+| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref   | rows | filtered | Extra                 |+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-----------------------+|  1 | SIMPLE      | t11   | NULL       | ref  | idx_a_b_c     | idx_a_b_c | 5       | const |    5 |    10.00 | Using index condition |+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-----------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于联合索引 idx_a_b_c（a,b,c） ，如果条件中只包含 a 和 c，则只能用到联合索引中 a 的索引。c 这里是用不了索引的。<strong>联合索引 idx_a_b_c(a,b,c) 相当于 (a) 、(a,b) 、(a,b,c) 三种索引，称为联合索引的最左原则。</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t11 <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">2</span>  <span class="token operator">and</span> b <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">order</span> <span class="token keyword">by</span> c<span class="token punctuation">;</span> <span class="token comment">/* sql13 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+---------------------------------------+| id | select_type | table | partitions | type  | possible_keys | key       | key_len | ref  | rows | filtered | Extra                                 |+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+---------------------------------------+|  1 | SIMPLE      | t11   | NULL       | range | idx_a_b_c     | idx_a_b_c | 10      | NULL |    2 |   100.00 | Using index condition; Using filesort |+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+---------------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里可以复习第 4 节 2.4，<strong>当联合索引前面的字段使用了范围查询，对后面的字段排序使用不了索引排序</strong>，也就是只能用到联合索引前面两个字段 a 和 b 的索引。</p><h4 id="2-3-可以用到覆盖索引的情况"><a href="#2-3-可以用到覆盖索引的情况" class="headerlink" title="2.3 可以用到覆盖索引的情况"></a>2.3 可以用到覆盖索引的情况</h4><p>什么是覆盖索引？</p><p>从辅助索引中就可以查询到结果，不需要回表查询聚集索引中的记录。</p><p>使用覆盖索引的优势：因为不需要扫描聚集索引，因此可以减少 SQL 执行过程的 IO 次数。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> b<span class="token punctuation">,</span>c <span class="token keyword">from</span> t11 <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">/* sql21 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref   | rows | filtered | Extra       |+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-------------+|  1 | SIMPLE      | t11   | NULL       | ref  | idx_a_b_c     | idx_a_b_c | 5       | const |    1 |   100.00 | Using index |+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 a 字段上的条件，去联合索引 idx_a_b_c 的索引树上可以直接查找到 b 字段和 c 字段的值，不需要回表，因此 sql21 使用到了覆盖索引。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> c <span class="token keyword">from</span> t11 <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">and</span> b<span class="token operator">=</span><span class="token number">1</span> <span class="token punctuation">;</span> <span class="token comment">/* sql22 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref         | rows | filtered | Extra       |+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------------+|  1 | SIMPLE      | t11   | NULL       | ref  | idx_a_b_c     | idx_a_b_c | 10      | const,const |    1 |   100.00 | Using index |+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>跟 sql21 类似，在联合索引 idx_a_b_c 的索引树上，通过 a 和 b 的值可以直接找到 c 的值，因此 sql22 使用的也是覆盖索引。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> id <span class="token keyword">from</span> t11 <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">and</span> b<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">and</span> c<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* sql23 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref               | rows | filtered | Extra       |+----+-------------+-------+------------+------+---------------+-----------+---------+-------------------+------+----------+-------------+|  1 | SIMPLE      | t11   | NULL       | ref  | idx_a_b_c     | idx_a_b_c | 15      | const,const,const |    1 |   100.00 | Using index |+----+-------------+-------+------------+------+---------------+-----------+---------+-------------------+------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 a、b、c 三个字段的值，去联合索引树的叶子节点找到主键 id，不需要回表，因此 sql23 也使用了覆盖索引。</p><h4 id="2-4-不能使用联合索引的情况"><a href="#2-4-不能使用联合索引的情况" class="headerlink" title="2.4 不能使用联合索引的情况"></a>2.4 不能使用联合索引的情况</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t11 <span class="token keyword">where</span> b<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* sql31 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+|  1 | SIMPLE      | t11   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   15 |    10.00 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果只使用联合索引后面的字段做为条件查询，则使用不了联合索引（联合索引最左匹配）。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t11 <span class="token keyword">order</span> <span class="token keyword">by</span> b<span class="token punctuation">;</span> <span class="token comment">/* sql32 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+|  1 | SIMPLE      | t11   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   15 |   100.00 | Using filesort |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与 sql31 相似，对联合索引后面的字段做排序操作，也使用不了联合索引。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t11 <span class="token keyword">where</span> c<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* sql33 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+|  1 | SIMPLE      | t11   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   15 |    10.00 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与 sql31 类似。c 字段单独做条件使用不了索引。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t11 <span class="token keyword">where</span> b<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">and</span> c<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* sql34 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+|  1 | SIMPLE      | t11   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   15 |     6.67 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>联合索引中，如果第一个字段在条件中没有出现，那么联合索引的后面所有字段作为条件都无法使用这个联合索引。</p><h2 id="14-为什么MySQL会选错索引？"><a href="#14-为什么MySQL会选错索引？" class="headerlink" title="14 为什么MySQL会选错索引？"></a><strong>14 为什么MySQL会选错索引？</strong></h2><p>在工作中，也许我们有时会遇到这种场景：某条 SQL 明明可以走 a 索引，却走了更慢的 b 索引。 今天我们就来讨论这种现象。</p><p>为了方便实验，首先创建测试表并写入测试数据，语句如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">use</span> muke<span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t13<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t13<span class="token punctuation">`</span> <span class="token punctuation">(</span>    <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_a<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_b<span class="token punctuation">`</span><span class="token punctuation">(</span><span class="token punctuation">`</span>b<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">procedure</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> insert_t13<span class="token punctuation">;</span> <span class="token comment">/* 如果存在存储过程insert_t13，则删除 */</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">procedure</span> insert_t13<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">/* 创建存储过程insert_t13 */</span><span class="token keyword">begin</span>    <span class="token keyword">declare</span> i <span class="token keyword">int</span><span class="token punctuation">;</span> <span class="token comment">/* 声明变量i */</span>    <span class="token keyword">set</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* 设置i的初始值为1 */</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token keyword">do</span> <span class="token comment">/* 对满足i&lt;=10000的值进行while循环 */</span>        <span class="token keyword">insert</span> <span class="token keyword">into</span> t13<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 写入表t13中a字段，值为i当前的值 */</span>        <span class="token keyword">set</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* 将i加1 */</span>    <span class="token keyword">end</span> <span class="token keyword">while</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span> <span class="token comment">/* 创建批量写入10000条数据到表t13的存储过程insert_t13 */</span><span class="token keyword">call</span> insert_t13<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 运行存储过程insert_t13 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在分析 MySQL 选错索引的情况之前，先讲 show index 的使用，因为后面会用到。</p><h3 id="1、show-index-的使用"><a href="#1、show-index-的使用" class="headerlink" title="1、show index 的使用"></a>1、show index 的使用</h3><p>当你需要查看某张表的索引详情时，可以使用命令：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">index</span> <span class="token keyword">from</span> t13<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+| t13   |          0 | PRIMARY  |            1 | id          | A         |        9192 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       || t13   |          1 | idx_a    |            1 | a           | A         |        9212 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       || t13   |          1 | idx_b    |            1 | b           | A         |        9212 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对上面几个重要的字段做一下解释：</p><ul><li>Non_unique：如果是唯一索引，则值为 0，如果可以有重复值，则值为 1</li><li>Key_name：索引名字</li><li>Seq_in_index：索引中的列序号，比如联合索引 idx_a_b_c(a,b,c) ，那么三个字段分别对应 1,2,3</li><li>Column_name：字段名</li><li>Collation：字段在索引中的排序方式，A 表示升序，NULL 表示未排序</li><li>Cardinality：索引中不重复记录数量的预估值，该值等会儿会详细讲解</li><li>Sub_part：如果是前缀索引，则会显示索引字符的数量；如果是对整列进行索引，则该字段值为 NULL</li><li>Null：如果列可能包含空值，则该字段为 YES；如果不包含空值，则该字段值为 ‘ ‘</li><li>Index_type：索引类型，包括 BTREE、FULLTEXT、HASH、RTREE 等</li></ul><p>show index 各字段的详细描述可以参考官方文档：<a href="https://dev.mysql.com/doc/refman/5.7/en/show-index.html。">https://dev.mysql.com/doc/refman/5.7/en/show-index.html。</a></p><h3 id="2、Cardinality-取值"><a href="#2、Cardinality-取值" class="headerlink" title="2、Cardinality 取值"></a>2、Cardinality 取值</h3><p>Cardinality 表示该索引不重复记录数量的预估值。如果该值比较小，那就应该考虑是否还有必要创建这个索引。比如性别这种类型的字段，即使加了索引，Cardinality 值比较小，使用性别做条件查询数据时，可能根本用不到已经添加的索引（可以参考第 3 节的第 4 部分：范围查询）。</p><p>Cardinality 统计信息的更新发生在两个操作中：INSERT 和 UPDATE。当然也不是每次 INSERT 或 UPDATE 就更新的，其更新时机为：</p><ul><li>表中 1/16 的数据已经发生过变化</li><li>表中数据发生变化次数超过 2000000000</li></ul><p>Cardinality 值是怎样统计和更新的呢？</p><p>InnoDB 表取出 B+ 树索引中叶子节点的数量，记为 a；随机取出 B+ 树索引中的 8 个（这个数量有参数 innodb_stats_transient_sample_pages 控制，默认为 8）叶子节点，统计每个页中不同记录的个数（假设为 b1，b2，b3，…，b8）。则 Cardinality 的预估值为：</p><p>（b1 + b2 + b3 + … b8）* a/8</p><p>所以 Cardinality 的值是对 8 个叶子节点进行采样获取的，显然这个值并不准确，只供参考。</p><p>下面我们来看下统计 Cardinality 涉及到的几个参数：</p><ul><li>innodb_stats_transient_sample_pages：设置统计 Cardinality 值时每次采样页的数量，默认值为 8。</li><li>innodb_stats_method：用来判断如果对待索引中出现的 NULL 值记录，默认为 nulls_equal，表示将 NULL 值记录视为相等的记录。另外还有 nulls_unequal 和 nulls_ignored。nulls_unequal 表示将 NULL 视为不同的记录，nulls_ignored 表示忽略 NULL 值记录。</li><li>innodb_stats_persistent：是否将 Cardinality 持久化到磁盘。好处是：比如数据库重启，不需要再计算 Cardinality 的值。</li><li>innodb_stats_on_metadata：当通过命令 show table status、show index 及访问 information_chema 库下的 tables 表和 statistics 表时，是否需要重新计算索引的 Cardinality。目的是考虑有些表数据量大，并且辅助索引多时，执行这些操作可能会比较慢，而使用者可能并不需要更新 Cardinality。</li></ul><h3 id="3、统计信息不准确导致选错索引"><a href="#3、统计信息不准确导致选错索引" class="headerlink" title="3、统计信息不准确导致选错索引"></a>3、统计信息不准确导致选错索引</h3><p>在 MySQL 中，<strong>优化器控制着索引的选择。一般情况下，优化器会考虑扫描行数、是否使用临时表、是否排序等因素，然后选择一个最优方案去执行 SQL 语句</strong>。</p><p>而 MySQL 中扫描行数并不会每次执行语句都去计算一次，因为每次都去计算，数据库压力太大了。实际情况是通过统计信息来预估扫描行数。这个统计信息就可以看成 show index 中的 Cardinality。</p><p>而从上面说到 Cardinality 的更新原理可以看出，它的值不一定准确的，因此有时可能就是因为它的值不精准导致选错了索引。这种情况可以使用下面的命令重新统计信息：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">analyze</span> <span class="token keyword">table</span> t13<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4、单次选取的数据量过大导致选错索引"><a href="#4、单次选取的数据量过大导致选错索引" class="headerlink" title="4、单次选取的数据量过大导致选错索引"></a>4、单次选取的数据量过大导致选错索引</h3><p>有时，我们也会遇到这种情况，如果单次选取的数据量过大，可能也会导致“选错”索引。</p><hr><p>第3章 MySQL锁</p><h2 id="15-全局锁和表锁什么场景会用到"><a href="#15-全局锁和表锁什么场景会用到" class="headerlink" title="15 全局锁和表锁什么场景会用到"></a><strong>15 全局锁和表锁什么场景会用到</strong></h2><p>根据加锁的范围，MySQL 中的锁可分为三类：</p><ul><li>全局锁</li><li>表级锁</li><li>行锁</li></ul><p>本节来重点讲解一下全局锁和表锁。</p><h3 id="1-全局锁"><a href="#1-全局锁" class="headerlink" title="1 全局锁"></a><strong>1 全局锁</strong></h3><p>MySQL 全局锁会关闭所有打开的表，并使用全局读锁锁定所有表。其命令为：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">FLUSH <span class="token keyword">TABLES</span> <span class="token keyword">WITH</span> <span class="token keyword">READ</span> <span class="token keyword">LOCK</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>简称：FTWRL，可以使用下面命令解锁：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UNLOCK</span> <span class="token keyword">TABLES</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们来通过实验理解一下全局锁：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">use</span> muke<span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t14<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t14<span class="token punctuation">`</span> <span class="token punctuation">(</span>    <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_a<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t14<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进行 FTWRL 实验：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">FLUSH TABLES WITH READ LOCK;<br>Query OK, 0 rows affected (0.00 sec)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">select <em> from t14 limit 1;<br>… <br>1 row in set (0.00 sec) <br> <em>*（能正常返回结果）</em></em></td><td style="text-align:left">select <em> from t14 limit 1;<br>…<br>1 row in set (0.00 sec) <br> <em>*（能正常返回结果）</em></em></td></tr><tr><td style="text-align:left">insert into t14(a,b) values(2,2);<br>ERROR 1223 (HY000): Can’t execute the query because you have a conflicting read lock <br> <strong>（报错）</strong></td><td style="text-align:left">insert into t14(a,b) values(2,2);/<em> sql1 </em>/ <br> <strong>（等待）</strong></td></tr><tr><td style="text-align:left">UNLOCK TABLES;</td><td style="text-align:left">insert into t14(a,b) values(2,2);/<em> sql1 </em>/<br>Query OK, 1 row affected (5.73 sec) <br> <strong>（session1 解锁后，在等待的 sql1 马上执行成功）</strong></td></tr></tbody></table></div><p>上面的实验中，当 session1 执行 FTWRL 后，本线程 session1 和其它线程 session2 都可以查询，本线程和其它线程都不能更新。</p><p>原因是：<strong>当执行 FTWRL 后，所有的表都变成只读状态，数据更新或者字段更新将会被阻塞。</strong></p><p>那么全局锁一般什么时候会用到呢？</p><p>全局锁一般用在整个库（包含非事务引擎表）做备份（mysqldump 或者 xtrabackup）时。也就是说，在整个备份过程中，整个库都是只读的，其实这样风险挺大的。如果是在主库备份，会导致业务不能修改数据；而如果是在从库备份，就会导致主从延迟。</p><p>好在 mysqldump 包含一个参数 —single-transaction，可以在一个事务中创建一致性快照，然后进行所有表的备份。因此增加这个参数的情况下，备份期间可以进行数据修改。但是需要所有表都是事务引擎表。所以这也是建议使用 InnoDB 存储引擎的原因之一。</p><p>而对于 xtrabackup，可以分开备份 InnoDB 和 MyISAM，或者不执行 —master-data，可以避免使用全局锁。</p><h3 id="2-表级锁"><a href="#2-表级锁" class="headerlink" title="2 表级锁"></a>2 表级锁</h3><p>表级锁有两种：表锁和元数据锁。</p><h4 id="2-1-表锁"><a href="#2-1-表锁" class="headerlink" title="2.1 表锁"></a>2.1 表锁</h4><p>表锁使用场景：</p><ol><li>事务需要更新某张大表的大部分或全部数据。如果使用默认的行锁，不仅事务执行效率低，而且可能造成其它事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高事务执行速度；</li><li>事务涉及多个表，比较复杂，可能会引起死锁，导致大量事务回滚，可以考虑表锁避免死锁。</li></ol><p>其中表锁又分为表读锁和表写锁，命令分别是：</p><p>表读锁：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">lock</span> <span class="token keyword">tables</span> t14 <span class="token keyword">read</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表写锁：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">lock</span> <span class="token keyword">tables</span> t14  <span class="token keyword">write</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面我们分别用实验验证表读锁和表写锁。</p><p>表读锁实验：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">lock tables t14 read; <br>Query OK, 0 rows affected (0.00 sec)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">select id,a,b from t14 limit 1; <br>… <br>1 row in set (0.00 sec) <br> <strong>（能正常返回结果）</strong></td><td style="text-align:left">select id,a,b from t14 limit 1; <br>… <br>1 row in set (0.00 sec) <br> <strong>（能正常返回结果）</strong></td></tr><tr><td style="text-align:left">insert into t14(a,b) values(3,3); <br>ERROR 1099 (HY000): Table ‘t14’ was locked with a READ lock and can’t be updated <br> <strong>（报错）</strong></td><td style="text-align:left">insert into t14(a,b) values(3,3);/<em> sql2 </em>/ <br> <strong>（等待）</strong></td></tr><tr><td style="text-align:left">unlock tables; <br>Query OK, 0 rows affected (0.00 sec)</td><td style="text-align:left">insert into t14(a,b) values(3,3);/<em> sql2 </em>/ <br>Query OK, 1 row affected (10.97 sec) <br> <strong>（session1 解锁后，sql2 立马写入成功）</strong></td></tr></tbody></table></div><p>从上面的实验我们可以看出，在 session1 中对表 t14 加表读锁，session1 和 session2 都可以查询表 t14 的数据；而 session1 执行更新会报错，session2 执行更新会等待（直到 session1 解锁后才更新成功）。</p><p>总结：<strong>对表执行 lock tables xxx read （表读锁）时，本线程和其它线程可以读，本线程写会报错，其它线程写会等待。</strong></p><p>我们再来看一下表写锁实验：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">lock tables t14 write; <br>Query OK, 0 rows affected (0.00 sec)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">select id,a,b from t14 limit 1; <br>… <br>1 row in set (0.00 sec) <br> <strong>（能正常返回结果）</strong></td><td style="text-align:left">select id,a,b from t14 limit 1;/<em> sql3 </em>/ <br> <strong>（等待）</strong></td></tr><tr><td style="text-align:left">unlock tables; <br>Query OK, 0 rows affected (0.01 sec)</td><td style="text-align:left">select id,a,b from t14 limit 1;/<em> sql3 </em>/ <br>… <br>1 row in set (7.16 sec) <br> <strong>（session1 解锁后，sql3 马上返回查询结果）</strong></td></tr><tr><td style="text-align:left">lock tables t14 write; <br>Query OK, 0 rows affected (0.00 sec)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">delete from t14 limit 1; <br>Query OK, 1 row affected, 1 warning (0.00 sec) <br> <strong>（能正常执行删除语句）</strong></td><td style="text-align:left">delete from t14 limit 1;/<em> sql4 </em>/ <br> <strong>（等待）</strong></td></tr><tr><td style="text-align:left">unlock tables; <br>Query OK, 0 rows affected (0.00 sec)</td><td style="text-align:left">delete from t14 limit 1;/<em> sql4 </em>/ <br>Query OK, 1 row affected, 1 warning (14.94 sec) <br> <strong>（session1 解锁后，sql4 立马执行成功）</strong></td></tr></tbody></table></div><p>总结：<strong>对表执行 lock tables xxx write （表写锁）时，本线程可以读写，其它线程读写都会阻塞。</strong></p><h4 id="2-2-元数据锁"><a href="#2-2-元数据锁" class="headerlink" title="2.2 元数据锁"></a>2.2 元数据锁</h4><p>在 MySQL 中，DDL 是不属于事务范畴的。如果事务和 DDL 并行执行同一张表时，可能会出现事务特性被破坏、binlog 顺序错乱等 bug（比如 <a href="https://bugs.mysql.com/bug.php?id=989">bug#989</a>）。为了解决这类问题，从 MySQL 5.5.3 开始，引入了元数据锁（Metadata Locking，简称：MDL 锁）（这段内容参考《淘宝数据库内核月报》<a href="http://mysql.taobao.org/monthly/2015/11/04/">MySQL · 特性分析 · MDL 实现分析</a>）。</p><p>从上面我们知道，MDL 锁的出现解决了同一张表上事务和 DDL 并行执行时可能导致数据不一致的问题。</p><p>但是，我们在工作中，很多情况需要考虑 MDL 的存在，否则可能导致长时间锁等待甚至连接被打满的情况。如下例：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th><th style="text-align:left">session3</th></tr></thead><tbody><tr><td style="text-align:left">select id,a,b,sleep(100) from t14 limit 1;/<em> sql5 </em>/</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">alter table t14 add column c int;/<em> sql6 </em>/ <br> <strong>（等待）</strong></td><td style="text-align:left">select id,a,b from t14 limit 1;/<em> sql7 </em>/ <br> <strong>（等待）</strong></td></tr><tr><td style="text-align:left">select id,a,b,sleep(100) from t14 limit 1;/<em> sql5 </em>/ <br>… <br>1 row in set (1 min 40.00 sec) <br> <strong>（100秒后 sql5 返回结果）</strong></td><td style="text-align:left">alter table t14 add column c int;/<em> sql6 </em>/ <br>Query OK, 0 rows affected (1 min 33.98 sec) Records: 0 Duplicates: 0 Warnings: 0 <br> <strong>（session1 的查询语句执行完成后，sql6 立马执行完毕）</strong></td><td style="text-align:left">select id,a,b from t14 limit 1;/<em> sql7 </em>/ <br>… <br>1 row in set (1 min 26.65 sec) <br> <strong>（session1 的查询语句执行完成后，sql7 立马执行完毕）</strong></td></tr></tbody></table></div><p>上面的实验中，我们在 session1 查询了表 t14 的数据，其中使用了 sleep(100) ，表示在 100 秒后才会返回结果；然后在 session2 执行 DDL 操作时会等待（原因是 session1 执行期间会对表 t14 加一个 MDL，而 session2 又会跟 session1 争抢 MDL）；而 session3 执行查询时也会继续等待。因此如果 session1 的语句一直没结束，其它所有的查询都会等待。这种情况下，如果这张表查询比较频繁，很可能短时间把数据库的连接数打满，导致新的连接无法建立而报错，如果是正式业务，影响是非常恐怖的。</p><p>当然如果出现这种情况，假如你还有 session 连着数据库，可以 kill 掉 session1 中的语句或者终止 session2 中的 DDL 操作，可以让业务恢复。但是出现这种情况的根源其实是：session1 中有长时间未提交的事务。<strong>因此对于开发来说，在工作中应该尽量避免慢查询、尽量保证事务及时提交、避免大事务等，当然对于 DBA 来说，也应该尽量避免在业务高峰执行 DDL 操作。</strong></p><h2 id="16-行锁：InnoDB替代MyISAM的重要原因"><a href="#16-行锁：InnoDB替代MyISAM的重要原因" class="headerlink" title="16 行锁：InnoDB替代MyISAM的重要原因"></a><strong>16 行锁：InnoDB替代MyISAM的重要原因</strong></h2><p>MySQL 5.5 之前的默认存储引擎是 MyISAM，5.5 之后改成了 InnoDB。InnoDB 后来居上最主要的原因就是：</p><ul><li>InnoDB 支持事务：适合在并发条件下要求数据一致的场景。</li><li>InnoDB 支持行锁：有效降低由于删除或者更新导致的锁定。</li></ul><p>在讲解行锁之前，我们首先来看一下两阶段锁协议。</p><h3 id="1-两阶段锁"><a href="#1-两阶段锁" class="headerlink" title="1 两阶段锁"></a>1 两阶段锁</h3><p>传统的关系型数据库加锁的一个原则是：两阶段锁原则。</p><p>两阶段锁：锁操作分为两个阶段，加锁阶段和解锁阶段，并且保证加锁阶段和解锁阶段不相交。</p><p>我们可以通过下面这张表理解两阶段锁：</p><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">MySQL 操作</th><th style="text-align:left">解释</th><th style="text-align:left">锁阶段</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">begin;</td><td style="text-align:left">事务开始</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">insert into …;</td><td style="text-align:left">加 insert 对应的锁</td><td style="text-align:left">加锁阶段</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">update table …;</td><td style="text-align:left">加 update 对应的锁</td><td style="text-align:left">加锁阶段</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">delete from …;</td><td style="text-align:left">加 delete 对应的锁</td><td style="text-align:left">加锁阶段</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">commit;</td><td style="text-align:left">事务结束，同时释放 2、3、4 步骤中加的锁</td><td style="text-align:left">解锁阶段</td></tr></tbody></table></div><h3 id="2-InnoDB-行锁模式"><a href="#2-InnoDB-行锁模式" class="headerlink" title="2 InnoDB 行锁模式"></a>2 InnoDB 行锁模式</h3><p>InnoDB 实现了以下两种类型的行锁：</p><ul><li>共享锁（S）：允许一个事务去读一行，阻止其它事务获得相同数据集的排他锁；</li><li>排他锁（X）：允许获得排他锁的事务更新数据，阻止其它事务取得相同数据集的共享读锁和排他写锁。</li></ul><p>对于普通 select 语句，InnoDB 不会加任何锁，事务可以通过以下语句显式给记录集加共享锁或排他锁：</p><ul><li>共享锁（S）：select * from table_name where … lock in share mode;</li><li>排他锁（X）：select * from table_name where … for update。</li></ul><h3 id="3-InnoDB-行锁算法"><a href="#3-InnoDB-行锁算法" class="headerlink" title="3 InnoDB 行锁算法"></a>3 InnoDB 行锁算法</h3><p>InnoDB 行锁的三种算法：</p><ul><li>Record Lock：单个记录上的索引加锁。</li><li>Gap Lock：间隙锁，对索引项之间的间隙加锁，但不包括记录本身。</li><li>Next-Key Lock：Gap Lock + Record Lock，锁定一个范围，并且锁定记录本身。</li></ul><p>InnoDB 行锁实现特点意味着：如果不通过索引条件检索数据，那么 InnoDB 将对表中所有记录加锁，实际效果跟表锁一样。</p><h3 id="4-事务隔离级别"><a href="#4-事务隔离级别" class="headerlink" title="4 事务隔离级别"></a>4 事务隔离级别</h3><p>不同事务隔离级别对应的行锁也是不一样的，因此在讲解行锁的锁定范围之前，先简单聊聊事务隔离级别。事务隔离级别的详细介绍放在下一章。</p><p>MySQL 的 4 种隔离级别：</p><ul><li>Read uncommitted（读未提交）: 在该隔离级别，所有事务都可以看到其它未提交事务的执行结果。可能会出现脏读。</li><li>Read Committed（读已提交，简称： RC）：一个事务只能看见已经提交事务所做的改变。因为同一事务的其它实例在该实例处理期间可能会有新的 commit，所以可能出现幻读。</li><li>Repeatable Read（可重复读，简称：RR）：这是 MySQL 的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。消除了脏读、不可重复读，默认也不会出现幻读。</li><li>Serializable（串行）：这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。</li></ul><blockquote><ul><li>脏读：读取未提交的事务。</li><li>幻读：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据。</li></ul></blockquote><h3 id="5-RC-隔离级别下的行锁实验"><a href="#5-RC-隔离级别下的行锁实验" class="headerlink" title="5 RC 隔离级别下的行锁实验"></a>5 RC 隔离级别下的行锁实验</h3><p>有时我们可能会思考，某条语句（类似 select * from table_name where a=… for update;）是怎么加锁的？</p><p>要想分析某条 SQL 是怎么加锁的，如果其他信息都不知道，那就得分几种情况了，不同情况加锁的方式也各不一样，比较常见的一些情况如下：</p><ul><li>RC 隔离级别，a 字段没索引。</li><li>RC 隔离级别，a 字段有唯一索引。</li><li>RC 隔离级别，a 字段有非唯一索引。</li><li>RR 隔离级别，a 字段没索引。</li><li>RR 隔离级别，a 字段有唯一索引。</li><li>RR 隔离级别，a 字段有非唯一索引。</li></ul><blockquote><p>Read uncommitted 和 Serializable 这两种隔离级别在生产环境基本不用，就不做分析了。</p></blockquote><p>我们先验证 RC 隔离级别下的几种情况，RR 隔离级别的实验放在下节：</p><p>首先创建测试表及写入数据:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">use</span> muke<span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t16<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t16<span class="token punctuation">`</span> <span class="token punctuation">(</span>    <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>c<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">`</span>uniq_a<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_c<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>c<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span>  <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t16<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>让我们开始实验吧！</p><h4 id="5-1-通过非索引字段查询"><a href="#5-1-通过非索引字段查询" class="headerlink" title="5.1 通过非索引字段查询"></a>5.1 通过非索引字段查询</h4><p>我们首先来看一下条件字段不使用索引的例子：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">set session transaction_isolation=’READ-COMMITTED’;/<em> 设置会话隔离级别为 RC</em>/</td><td style="text-align:left">set session transaction_isolation=’READ-COMMITTED’;/<em> 设置会话隔离级别为 RC</em>/</td></tr><tr><td style="text-align:left">begin;</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">use muke; <br>select * from t16 where b=1 for update; <br>… <br>1 row in set (0.00 sec)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">use muke; <br>select <em> from t16 where b=2 for update; <br> <em>*（等待）</em></em></td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left">select <em> from t16 where b=2 for update; <br>… <br>1 row in set (6.81 sec) <br> <em>*（session1 执行 commit 后立马返回结果）</em></em></td></tr></tbody></table></div><blockquote><p><strong>这里解释一下为什么要用 for update？</strong></p><p>我们常使用的查询语句，比如 select * from t16 where b=1 属于快照读，是不会看到别的事务插入的数据的。</p><p>而在查询语句后面加了 for update 显式给记录集加了排他锁，也就让查询变成了当前读。插入、更新、删除操作，都属于当前读。其实也就可以理解 select … for update 是为了让普通查询获得插入、更新、删除操作时所获得的锁。</p></blockquote><p>表面看起来 session1 只给了 b=1 这一行加了排他锁，但 session2 在请求其它行的排他锁时，却出现了锁等待。看下图：</p><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/RC隔离级别和条件字段无索引.png" alt="RC隔离级别和条件字段无索引"></p><p>由于 b 字段没有索引，因此只能走聚簇索引，进行全表扫描。从上图中可以看到，满足条件的记录有一条，但是聚簇索引上的所有记录，都被加上了 X 锁。</p><p>为什么不是只在满足条件的记录上加锁呢？</p><p>这是因为在 MySQL 中，如果一个条件无法通过索引快速过滤，那么存储引擎层面就会将所有记录加锁后返回，然后由 server 层进行过滤。因此也就把所有记录都锁上了。</p><blockquote><p>当然 MySQL 在这里有一些改进的，在 server 层过滤掉不满足条件的数据后，会把不满足条件的记录放锁。保证了最后只会持有满足条件的锁，但是每条记录的加锁操作还是不会省略。</p></blockquote><p>总结：<strong>没有索引的情况下，InnoDB 的当前读会对所有记录都加锁。所以在工作中应该特别注意 InnoDB 这一特性，否则可能会产生大量的锁冲突。</strong></p><h4 id="5-2-通过唯一索引查询"><a href="#5-2-通过唯一索引查询" class="headerlink" title="5.2 通过唯一索引查询"></a>5.2 通过唯一索引查询</h4><p>我们再来看一下条件字段有唯一索引的例子：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">set session transaction_isolation=’READ-COMMITTED’;/<em> 设置会话隔离级别为 RC</em>/</td><td style="text-align:left">set session transaction_isolation=’READ-COMMITTED’;/<em> 设置会话隔离级别为 RC </em>/</td></tr><tr><td style="text-align:left">begin; <br>use muke; <br>select * from t16 where a=1 for update; <br>… <br>1 row in set (0.00 sec)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">use muke; <br>select * from t16 where a=2 for update; <br>… <br>1 row in set (0.00 sec)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">select <em> from t16 where a=1 for update; <br> <em>*（等待）</em></em></td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left">select <em> from t16 where a=1 for update; <br>… <br>1 row in set (4.70 sec) <br> <em>*（session1 提交后，马上返回结果）</em></em></td></tr></tbody></table></div><p>session1 给了 a=1 这一行加了排他锁，在 session2 中请求其他行的排他锁时，不会发生等待；但是在 session2 中请求 a=1 这一行的排他锁时，会发生等待。看下图：</p><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/RC隔离级别和条件字段有唯一索引.png" alt="RC隔离级别和条件字段有唯一索引"></p><p>由于 a 是唯一索引，因此 select * from t16 where a=1 for update；(后面称为 SQL2) 语句会选择走 a 列的索引进行条件过滤，在找到 a=1 的记录后，会将唯一索引上 a=1 索引记录上加 X 锁，同时，会根据读取到的 id 列，回到聚簇索引，然后将 id=1 对应的聚簇索引项加 X 锁。</p><p>为什么聚簇索引上的记录也要加锁呢？</p><p>比如，并发的一条 SQL，是通过主键索引来更新：update t16 set b=10 where id =1; 如果 SQL2 没有将主键索引上的记录加锁，那么并发的 update 并不知道 SQL2 在执行，所以如果 update 执行了，就违背了同一记录上的更新或者删除需要串行执行的约束。</p><p>总结：<strong>如果查询的条件是唯一索引，那么 SQL 需要在满足条件的唯一索引上加锁，并且会在对应的聚簇索引上加锁。</strong></p><h4 id="5-3-通过非唯一索引查询"><a href="#5-3-通过非唯一索引查询" class="headerlink" title="5.3 通过非唯一索引查询"></a>5.3 通过非唯一索引查询</h4><p>我们再来看一下条件字段有非唯一索引的例子：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th><th style="text-align:left">session3</th></tr></thead><tbody><tr><td style="text-align:left">set session transaction_isolation=’READ-COMMITTED’;/<em> 设置会话隔离级别为 RC</em>/</td><td style="text-align:left">set session transaction_isolation=’READ-COMMITTED’;/<em> 设置会话隔离级别为 RC</em>/</td><td style="text-align:left">set session transaction_isolation=’READ-COMMITTED’;/<em> 设置会话隔离级别为 RC</em>/</td></tr><tr><td style="text-align:left">begin;</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">use muke; <br>select * from t16 where c=3 for update; <br>… <br>2 rows in set (0.00 sec)</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">use muke; <br>select * from t16 where a=1 for update; <br>… <br>1 row in set (0.00 sec)</td><td style="text-align:left">use muke; select * from t16 where a=2 for update; <br>… <br>1 row in set (0.00 sec)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">select <em> from t16 where a=3 for update; <br> <em>*(等待)</em></em></td><td style="text-align:left">select <em> from t16 where a=4 for update; <br> <em>*(等待)</em></em></td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left">select <em> from t16 where a=3 for update; <br>… <br> <em>*(session1 提交后，马上返回结果)</em></em></td><td style="text-align:left">select <em> from t16 where a=4 for update; <br>… <br> <em>*(session1 提交后，马上返回结果)</em></em></td></tr></tbody></table></div><p>我们在满足条件 c=3 的数据上加了排他锁，如上面结果，就是第 3、4 行。因此第 1、2 行的数据没被锁，而 3、4 行的数据被锁了。如下图：</p><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/RC隔离级别和条件字段有非唯一索引.png" alt="RC隔离级别和条件字段有非唯一索引"></p><p>通过上图可以看到，在 a 字段的非唯一索引上，满足 c=3 的所有记录，都被加了锁。同时，对应的主键索引上的记录也都加上了锁。与通过唯一索引查询的情况相比，唯一索引查询最多有一行记录被锁，而非唯一索引将会把满足条件的所有记录都加上锁。</p><p>总结：<strong>如果查询的条件是非唯一索引，那么 SQL 需要在满足条件的非唯一索引上都加上锁，并且会在它们对应的聚簇索引上加锁。</strong></p><h2 id="17-间隙锁的意义"><a href="#17-间隙锁的意义" class="headerlink" title="17 间隙锁的意义"></a><strong>17 间隙锁的意义</strong></h2><h3 id="1-揭晓上一节课后问题的答案"><a href="#1-揭晓上一节课后问题的答案" class="headerlink" title="1 揭晓上一节课后问题的答案"></a>1 揭晓上一节课后问题的答案</h3><p>拿上节的测试表 t16，进行如下实验：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">set session transaction_isolation=’READ-COMMITTED’;/<em> 设置会话隔离级别为 RC</em>/</td><td style="text-align:left">set session transaction_isolation=’READ-COMMITTED’;/<em> 设置会话隔离级别为 RC</em>/</td></tr><tr><td style="text-align:left">begin;</td><td style="text-align:left">begin;</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">use muke; <br>select <em> from t16 where c=3 for update; <br> <em>*Result1</em></em></td></tr><tr><td style="text-align:left">use muke; insert into t16(a,b,c) values (5,5,3);</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">select <em> from t16 where c=3 for update; <br> <em>*Result2</em></em></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">commit;</td></tr></tbody></table></div><p>我们看一下上面的实验结果：Result 1 和 Result 2 结果是不同的。在 session2 中，同一个事务中，按相同的查询条件重新读取以前检索过的数据，却发现了 session1 插入的满足查询条件的新数据，这也就是上一节讲到的幻读情况。</p><p>为什么上面的实验中会出现幻读呢？</p><p>我们来看看下面这张图：</p><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/RC隔离级别和条件字段有非唯一索引（幻读）.png" alt="RC隔离级别和条件字段有非唯一索引（幻读）"></p><p>从图中可以看出，RC 隔离级别下，只锁住了满足 c=3 的当前行，而不会对后面的位置（或者说间隙）加锁，因此导致 session1 的写入语句能正常执行并提交。</p><p>那么应该怎样降低幻读出现的概率呢？</p><p>从上面的分析我们可以知道，产生幻读的原因是：行锁只能锁住当前行，但是新插入的记录，是在被锁住记录之前的间隙。因此，为了降低幻读出现的概率，InnoDB 在 RR 隔离级别下配置了间隙锁（Gap Lock）。</p><h3 id="2-RR-隔离级别下的非唯一索引查询"><a href="#2-RR-隔离级别下的非唯一索引查询" class="headerlink" title="2 RR 隔离级别下的非唯一索引查询"></a>2 RR 隔离级别下的非唯一索引查询</h3><p>我们继续看上面的实验，这里不同点是我们把隔离级别设置成 RR。</p><p>我们再单独建一张表，表结构与上节的表结构一致，为了方便后面分析，数据稍微有改动，语句如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">use</span> muke<span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t17<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t17<span class="token punctuation">`</span> <span class="token punctuation">(</span>    <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>c<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">`</span>uniq_a<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_c<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>c<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span>  <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t17<span class="token punctuation">(</span>id<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>开始RR隔离级别下的实验：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">set session transaction_isolation=’REPEATABLE-READ’;/<em> 设置会话隔离级别为 RR</em>/</td><td style="text-align:left">set session transaction_isolation=’REPEATABLE-READ’;/<em> 设置会话隔离级别为 RR</em>/</td></tr><tr><td style="text-align:left">begin;</td><td style="text-align:left">begin;</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">use muke; <br>select <em> from t17 where c=4 for update; <br> <em>*Result1</em></em></td></tr><tr><td style="text-align:left">use muke; <br>insert into t17(a,b,c) values (7,7,4); /<em> SQL 1 </em>/</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">select <em> from t17 where c=4 for update; <br> <em>*Result2</em></em></td></tr><tr><td style="text-align:left">insert intot17(a,b,c) values (7,7,4); /<em> SQL 1 </em>/<br>Query  OK, 1 row affected (20.73 sec)<br>（等session2 执行commit; 后，SQL1马上返回结果）</td><td style="text-align:left">commit;</td></tr><tr><td style="text-align:left">commit;</td></tr></tbody></table></div><p>根据实验情况，我们在 session2 中，对满足条件 c=4 的数据加上了排他锁，然后在 session1 写入一条 c=4 的记录，此时会出现等待，直到 session2 对事务进行提交后，session1 才会执行成功。这是为什么呢？我们来看下图：</p><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/RR隔离级别和条件字段有非唯一索引.png" alt="RR隔离级别和条件字段有非唯一索引"></p><p>与 RC 隔离级别下的图相似，但是有个比较大的区别是：RR 隔离级别多了 GAP 锁。</p><p>如上图，首先需要考虑哪些位置可以插入新的满足条件 c=4 的项：</p><ul><li>由于 B+ 树索引是有序的，因此 [2,2]（代表 c 和 id 的值，后面就不一一说明了）前面的记录，不可能插入 c=4 的记录了；</li><li>[2,2] 与 [4,4] 之间可以插入 [4,3]；</li><li>[4,4] 与 [4,6] 之间可以插入 [4,5]；</li><li>[4,6] 之后，可以插入的值就很多了：[4,n] (其中 n&gt;6) ；</li></ul><p>为了保证这几个区间不会插入新的满足条件 c=4 的记录，MySQL RR 隔离级别选择了 GAP 锁，将这几个区间锁起来。</p><p>而上面实验中，语句 insert into t17 (a,b,c) values (7,7,4) 其对应插入 c 和 id 的值为 [4,7]，是在最后这个被 GAP Lock 锁住的区间，因此如上面实验，insert 操作会等待。</p><h3 id="3-RR-隔离级别下的非索引字段查询"><a href="#3-RR-隔离级别下的非索引字段查询" class="headerlink" title="3 RR 隔离级别下的非索引字段查询"></a>3 RR 隔离级别下的非索引字段查询</h3><p>上一节中，我们测试了 RC 隔离级别下，非索引字段做条件的当前读会对所有记录都加锁。</p><p>这一节，我们测试一下 RR 隔离级别下，非索引字段做条件的当前读加锁情况。</p><p>首先对 t17 表中的数据做初始化：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">use</span> muke<span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t17<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t17<span class="token punctuation">`</span> <span class="token punctuation">(</span>    <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>c<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">`</span>uniq_a<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_c<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>c<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span>  <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t17<span class="token punctuation">(</span>id<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th><th style="text-align:left">session3</th></tr></thead><tbody><tr><td style="text-align:left">set session transaction_isolation=’REPEATABLE-READ’;/<em> 设置会话隔离级别为 RR</em>/</td><td style="text-align:left">set session transaction_isolation=’REPEATABLE-READ’;/<em> 设置会话隔离级别为 RR</em>/</td><td style="text-align:left">set session transaction_isolation=’REPEATABLE-READ’;/<em> 设置会话隔离级别为 RR</em>/</td></tr><tr><td style="text-align:left">begin;</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">use muke; <br>select * from t17 where b=1 for update; <br>… <br>1 rows in set (0.00 sec)</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">use muke; <br>select <em> from t17 where b=2 for update; <br> <em>*(等待)</em></em></td><td style="text-align:left">insert into t17(a,b,c) values(10,10,10); <br> <strong>(等待)</strong></td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left">select <em> from t17 where b=2 for update; <br>… <br> <em>*(session1 提交后，马上返回结果)</em></em></td><td style="text-align:left">insert into t17(a,b,c) values(10,10,10); <br>… <br> <strong>(session1 提交后，马上写入)</strong></td></tr></tbody></table></div><p>可能你会问？为什么 session3 的 insert 会出现等待？</p><p>我们看看下图：</p><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/RR隔离级别和条件字段无索引.png" alt="RR隔离级别和条件字段无索引"></p><p>如图，所有记录都有 X 锁，除此之外，每个 GAP 也被加上了 GAP 锁。因此这张表在执行完 select * from t17 where b=1 for update; 到 commit 之前，除了不加锁的快照读，其它任何加锁的 SQL，都会等待，如果这是线上业务表，那就是件非常恐怖的事情了。</p><p>总结：RR 隔离级别下，非索引字段做条件的当前读不但会把每条记录都加上 X 锁，还会把每个 GAP 加上 GAP 锁。再次说明，条件字段加索引的重要性。</p><h3 id="4-RR-隔离级别下的唯一索引当前读是否会用到-GAP-锁"><a href="#4-RR-隔离级别下的唯一索引当前读是否会用到-GAP-锁" class="headerlink" title="4 RR 隔离级别下的唯一索引当前读是否会用到 GAP 锁"></a>4 RR 隔离级别下的唯一索引当前读是否会用到 GAP 锁</h3><p>GAP 锁的目的是：为了防止同一事务两次当前读，出现幻读的情况。如果能确保索引字段唯一，那其实一个等值查询，最多就返回一条记录，而且相同索引记录的值，一定不会再新增，因此不会出现 GAP 锁。</p><p>因此以唯一索引为条件的当前读，不会有 GAP 锁。所以 RR 隔离级别下的唯一索引当前读加锁情况与 RC 隔离级别下的唯一索引当前读加锁情况一致。这里就不再实验了。</p><h2 id="18-为什么会出现死锁？"><a href="#18-为什么会出现死锁？" class="headerlink" title="18 为什么会出现死锁？"></a>18 为什么会出现死锁？</h2><h3 id="1-认识死锁"><a href="#1-认识死锁" class="headerlink" title="1 认识死锁"></a>1 认识死锁</h3><p>死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。</p><p>InnoDB 中解决死锁问题有两种方式：</p><ol><li>检测到死锁的循环依赖，立即返回一个错误（这个报错内容请看下面的实验），将参数 innodb_deadlock_detect 设置为 on 表示开启这个逻辑；</li><li>等查询的时间达到锁等待超时的设定后放弃锁请求。这个超时时间由 innodb_lock_wait_timeout 来控制。默认是 50 秒。</li></ol><blockquote><p>一般线上业务都建议使用的第 1 种策略，因为第 2 种策略锁等待时间是 50 秒，对于高并发的线上业务是不能接受的。<br>但是第 1 种策略，也会有死锁检测时的额外 CPU 开销的，比如电商中的秒杀场景。这种情况就可以根据业务开发商量优化程序，如果可以确保业务一定不会出现死锁，可以临时把死锁检测关掉，以提高并发效率。</p></blockquote><h3 id="2-为什么会产生死锁"><a href="#2-为什么会产生死锁" class="headerlink" title="2 为什么会产生死锁"></a>2 为什么会产生死锁</h3><h4 id="2-1-同一张表中"><a href="#2-1-同一张表中" class="headerlink" title="2.1 同一张表中"></a>2.1 同一张表中</h4><p>不同线程并发访问同一张表的多行数据，未按顺序访问导致死锁。</p><h4 id="2-2-不同表之间"><a href="#2-2-不同表之间" class="headerlink" title="2.2 不同表之间"></a>2.2 不同表之间</h4><p>不同线程并发访问多个表时，未按顺序访问导致死锁。</p><h4 id="2-3-事务隔离级别"><a href="#2-3-事务隔离级别" class="headerlink" title="2.3 事务隔离级别"></a>2.3 事务隔离级别</h4><p>RR隔离级别下，由于间隙锁导致死锁。</p><h3 id="3-如何降低死锁概率"><a href="#3-如何降低死锁概率" class="headerlink" title="3 如何降低死锁概率"></a>3 如何降低死锁概率</h3><p>那么应该怎样降低出现死锁的概率呢？这里总结了如下一些经验：</p><ol><li>更新 SQL 的 where 条件尽量用索引；</li><li>基于 primary 或 unique key 更新数据；</li><li>减少范围更新，尤其非主键、非唯一索引上的范围更新；</li><li>加锁顺序一致，尽可能一次性锁定所有需要行；</li><li>将 RR 隔离级别调整为 RC 隔离级别。</li></ol><h3 id="4-分析死锁的方法"><a href="#4-分析死锁的方法" class="headerlink" title="4 分析死锁的方法"></a>4 分析死锁的方法</h3><p>尽管在上面介绍了降低死锁概率的方法，但是在实际工作中，死锁很难完全避免。因此，捕获并处理死锁也是一个好的编程习惯。</p><p>InnoDB 中，可以使用 SHOW INNODB STATUS 命令来查看最后一个死锁的信息。我们可以尝试用下这个命令获取一些死锁信息，如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">engine</span> <span class="token keyword">innodb</span> <span class="token keyword">status</span>\G<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>另外设置 innodb_print_all_deadlocks = on 可以在 err log 中记录全部死锁信息。</p><hr><p>第4章 事务</p><h2 id="19-数据库忽然断电会丢失数据吗？"><a href="#19-数据库忽然断电会丢失数据吗？" class="headerlink" title="19 数据库忽然断电会丢失数据吗？"></a>19 数据库忽然断电会丢失数据吗？</h2><h3 id="1-什么是事务？"><a href="#1-什么是事务？" class="headerlink" title="1 什么是事务？"></a>1 什么是事务？</h3><p>根据《高性能 MySQL》第 3 版 1.3 事务一节中定义：</p><blockquote><p>事务就是一组原子性的 SQL 查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。</p></blockquote><p>一个良好的事务处理系统，必须具备 ACID 特性：</p><ul><li>atomicity（原子性） ：要么全执行，要么全都不执行；</li><li>consistency（一致性）：在事务开始和完成时，数据都必须保持一致状态；</li><li>isolation（隔离性） ：事务处理过程中的中间状态对外部是不可见的；</li><li>durability（持久性） ：事务完成之后，它对于数据的修改是永久性的。</li></ul><p>InnoDB 采用 redo log 机制来保证事务更新的一致性和持久性。</p><h3 id="2-Redo-log"><a href="#2-Redo-log" class="headerlink" title="2 Redo log"></a>2 Redo log</h3><p>Redo log 称为重做日志，用于记录事务操作变化，记录的是数据被修改之后的值。</p><p>Redo log 由两部分组成：</p><ul><li>内存中的重做日志缓冲（redo log buffer）</li><li>重做日志文件（redo log file）</li></ul><p>每次数据更新会先更新 redo log buffer，然后根据 innodb_flush_log_at_trx_commit 来控制 redo log buffer 更新到 redo log file 的时机。innodb_flush_log_at_trx_commit 有三个值可选：</p><p>0：事务提交时，每秒触发一次 redo log buffer 写磁盘操作，并调用操作系统 fsync 刷新 IO 缓存。</p><p>1：事务提交时，InnoDB 立即将缓存中的 redo 日志写到日志文件中，并调用操作系统 fsync 刷新 IO 缓存；</p><p>2：事务提交时，InnoDB 立即将缓存中的 redo 日志写到日志文件中，但不是马上调用 fsync 刷新 IO 缓存，而是每秒只做一次磁盘 IO 缓存刷新操作。</p><p>innodb_flush_log_at_trx_commit 参数的默认值是 1，也就是每个事务提交的时候都会从 log buffer 写更新记录到日志文件，而且会刷新磁盘缓存，这完全满足事务持久化的要求，是最安全的，但是这样会有比较大的性能损失。</p><p>将参数设置为 0 时，如果数据库崩溃，最后 1秒钟的 redo log 可能会由于未及时写入磁盘文件而丢失，这种方式尽管效率最高，但是最不安全。</p><p>将参数设置为 2 时，如果数据库崩溃，由于已经执行了重做日志写入磁盘的操作，只是没有做磁盘 IO 刷新操作，因此，只要不发生操作系统奔溃，数据就不会丢失，这种方式是对性能和安全的一种折中处理。</p><h3 id="3-Binlog"><a href="#3-Binlog" class="headerlink" title="3 Binlog"></a>3 Binlog</h3><p>二进制日志（binlog）记录了所有的 DDL（数据定义语句）和 DML（数据操纵语句），但是不包括 select 和 show 这类操作。Binlog 有以下几个作用：</p><ul><li>恢复：数据恢复时可以使用二进制日志</li><li>复制：通过传输二进制日志到从库，然后进行恢复，以实现主从同步</li><li>审计：可以通过二进制日志进行审计数据的变更操作</li></ul><p>可以通过参数 sync_binlog 来控制累积多少个事务后才将二进制日志 fsync 到磁盘。</p><ul><li>sync_binlog=0，表示每次提交事务都只write，不fsync</li><li>sync_binlog=1，表示每次提交事务都会执行fsync</li><li>sync_binlog=N(N&gt;1)，表示每次提交事务都write，累积N个事务后才fsync</li></ul><p>比如要加快写入数据的速度或者机器磁盘 IO 瓶颈时，可以将 sync_binlog 设置成大于 1 的值，但是如果设置为 N(N&gt;1)时，如果数据库崩溃，可能会丢失最近 N 个事务的 binlog。</p><h3 id="4-怎样确保数据库突然断电不丢数据？"><a href="#4-怎样确保数据库突然断电不丢数据？" class="headerlink" title="4 怎样确保数据库突然断电不丢数据？"></a>4 怎样确保数据库突然断电不丢数据？</h3><p>通过上面的讲解，只要 innodb_flush_log_at_trx_commit 和 sync_binlog 都为 1（通常称为：双一），就能确保 MySQL 机器断电重启后，数据不丢失。</p><p>因此建议在比较重要的库，比如涉及到钱的库，设置为双一，而你的测试环境或者正式业务不那么重要的库（比如日志库）可以将 innodb_flush_log_at_trx_commit 设置为0，sync_binlog 设置成大于100 的数值，提高更新效率。</p><h2 id="20-MVCC怎么实现的"><a href="#20-MVCC怎么实现的" class="headerlink" title="20 MVCC怎么实现的?"></a>20 MVCC怎么实现的?</h2><p>本节跟大家一起聊聊 MVCC（Multi-Version Concurrency Control，多版本并发控制）。为了方便理解，在讲解 MVCC 之前，我们先来聊聊隐藏列、Undo log 和 Read View。</p><h3 id="1-隐藏列"><a href="#1-隐藏列" class="headerlink" title="1 隐藏列"></a>1 隐藏列</h3><p>对于 InnoDB ，每行记录除了我们创建的字段外，其实还包含 3 个隐藏的列：</p><ul><li>ROW ID：隐藏的自增 ID，如果表没有主键，InnoDB 会自动以 ROW ID 产生一个聚集索引树。</li><li>事务 ID：记录最后一次修改该记录的事务 ID。</li><li>回滚指针：指向这条记录的上一个版本。</li></ul><h3 id="2-Undo-log"><a href="#2-Undo-log" class="headerlink" title="2 Undo log"></a>2 Undo log</h3><p>上节我们讲到了 redo log，它记录了事务操作变化。但是事务有时是需要回滚的，这时，Undo log 就发挥了作用。Undo log 是逻辑日志，将数据库逻辑地恢复到原来的样子，所有修改都被逻辑的取消了。</p><ul><li>如果是 insert 操作，其对应的回滚操作就是 delete；</li><li>如果是 delete，则对应的回滚操作是 insert；</li><li>如果是 update，则对应的回滚操作是一个反向的 update 操作。</li></ul><p>Undo log 的作用除了回滚操作，Undo log 的另一个作用是 MVCC，InnoDB 存储引擎中 MVCC 的实现是通过 Undo log 来完成的。当用户读取一行记录时，若该记录已经被其它事务占用，当前事务可以通过 Undo log 读取之前的行版本信息，因为没有事务需要对历史的数据进行修改操作，所以也不需要加锁，以此来实现非锁定读取。</p><h3 id="3-Read-View"><a href="#3-Read-View" class="headerlink" title="3 Read View"></a>3 Read View</h3><p>Read View 是指事务进行快照读操作的那一刻，产生数据库系统当前活跃事务列表的一个快照。</p><p>Read View 中大致包含以下内容：</p><ul><li>trx_ids：数据库系统当前活跃事务 ID 集合；</li><li>low_limit_id：活跃事务中最大的事务 ID +1；</li><li>up_limt_id：活跃事务总最小的事务 ID；</li><li>creator_trx_id：创建这个 Read View 的事务 ID。</li></ul><p>比如某个事务，创建了 Read View，那么它的 creator_trx_id 就为这个事务的 ID，假如需要访问某一行，假设这一行记录的隐藏事务 ID 为 t_id，那么可能出现的情况如下：</p><ul><li>如果 t_id &lt; up_limt_id，说明这行记录在这些活跃的事务创建之前就已经提交了，那么这一行记录对该事务是可见的。</li><li>如果 t_id &gt;= low_limt_id，说明这行记录在这些活跃的事务开始之后创建的，那么这一行记录对该事物是不可见的。</li><li>如果 up_limit_id &lt;= t_id &lt; low_limit_id，说明这行记录可能是在这些活跃的事务中创建的，如果 t_id 也同时在 trx_ids 中，则说明 t_id 还未提交，那么这一行记录对该事物是不可见的；如果 t_id 不在 trx_ids 中，则说明事务 t_id 已经提交了，那么这一行记录对该事物是可见的。</li></ul><p>对于不可见的记录，都是通过查询 Undo log 来查询老的记录。</p><p>了解了上面的原理，我们知道了，Read View 规则帮我们判断当前版本的数据是否可见。下面，我们分析下当查询一条记录时，大致的步骤：</p><ul><li>获取事务本身的事务 ID；</li><li>获取 Read View；</li><li>查询得到的数据，然后与 Read View 中的事务版本号进行比较；</li><li>如果能查询，则直接查询对应的记录；如果不能直接查询，则通过 Undo Log 中获取历史快照；</li><li>最终返回结果。</li></ul><p>另外需要补充的一点就是，在 RR 和 RC 隔离级别下，获取 Read View 的时机也是不一样的：</p><ul><li>在可重复读隔离级别（RR）下，同一个事务中，查询语句只是在第一个读请求发起时获取 Read View，而后面相同的查询语句都会使用这个 Read View。</li><li>在读已提交隔离级别（RC）下，同一个事务中，同样的查询语句在每次读请求发起时都会获得 Read View。</li></ul><h3 id="4-什么是-MVCC？"><a href="#4-什么是-MVCC？" class="headerlink" title="4 什么是 MVCC？"></a>4 什么是 MVCC？</h3><p>在说 MVCC 之前，大家先看看下面这个例子。</p><p>首先创建表并写入测试数据：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">use</span> muke<span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t20<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t20<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_c<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t20<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进行实验：</p><div class="table-container"><table><thead><tr><th></th><th>session1</th><th>session2</th></tr></thead><tbody><tr><td>1</td><td>set session transaction_isolation=’READ-COMMITTED’;/<em> 设置会话隔离级别为 RC</em>/</td><td>set session transaction_isolation=’READ-COMMITTED’;/<em> 设置会话隔离级别为 RC</em>/</td></tr><tr><td>2</td><td>select <em> from t20;<br> <em>*Result1</em></em></td><td></td></tr><tr><td>3</td><td>begin;</td><td></td></tr><tr><td>4</td><td>update t20 set b=666 where a=1;</td><td></td></tr><tr><td>5</td><td></td><td>begin;</td></tr><tr><td>6</td><td></td><td>select <em> from t20;<br> <em>*Result2</em></em></td></tr><tr><td>7</td><td>commit;</td><td></td></tr><tr><td>8</td><td></td><td>select <em> from t20;<br> <em>*Result3</em></em></td></tr><tr><td>9</td><td></td><td>commit;</td></tr></tbody></table></div><p>其中</p><p><strong>Result1</strong>：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+---+---+| id | a | b |+----+---+---+|  1 | 1 | 1 ||  2 | 2 | 2 |+----+---+---+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Result2</strong>：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">mysql&gt; select * from t20;+----+---+---+| id | a | b |+----+---+---+|  1 | 1 | 1 ||  2 | 2 | 2 |+----+---+---+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Result3</strong>：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">mysql&gt; select * from t20;+----+---+-----+| id | a | b   |+----+---+-----+|  1 | 1 | 666 ||  2 | 2 |   2 |+----+---+-----+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 session1 更新了 a=1 这行记录，但还没提交的情况下，在 session2 中，满足 a=1 这条记录，b 的值还是原始值 1，而不是 session 1 更新之后的 666，那么在数据库层面，这是怎么实现的呢？</p><p>其实 InnoDB 就是通过 MVCC 和 Undo log 来实现的。</p><p>什么是 MVCC 呢？</p><p>MVCC， 即多版本并发控制。MVCC 的实现，是通过保存数据在某个时间点的快照来实现的，也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。</p><p>也就是上面实验第 6 步中，为什么 session2 查询的结果还是 session1 修改之前的记录。</p><h3 id="5-MVCC-的实现原理"><a href="#5-MVCC-的实现原理" class="headerlink" title="5 MVCC 的实现原理"></a>5 MVCC 的实现原理</h3><p>我们拿上面的例子，对应解释下 MVCC 的实现原理，如下图：</p><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/MVCC实现原理.png" alt="MVCC实现原理"></p><p>如图，首先 insert 语句向表 t20 中插入了一条数据，a 字段为 1，b 字段为 1， ROW ID 也为 1 ，事务 ID 假设为 1，回滚指针假设为 null。当执行 update t20 set b=666 where a=1 时，大致步骤如下：</p><ul><li>数据库会先对满足 a=1 的行加排他锁；</li><li>然后将原记录复制到 undo 表空间中；</li><li>修改 b 字段的值为 666，修改事务 ID 为 2；</li><li>并通过隐藏的回滚指针指向 Undo log 中的历史记录；</li><li>事务提交，释放前面对满足 a=1 的行所加的排他锁。</li></ul><p>在前面实验的第 6 步中，session2 查询的结果是 session1 修改之前的记录，也就是那个点的 Read View，根据上面将的 Read View 原理，被查询行的隐藏事务 ID 就在当前活跃事务 ID 集合中。因此，这一行记录对该事物（session2 中的事务）是不可见的，可以知道 session2 查询的 a=1 这行记录实际就是来自 Undo log 中。我们看到的现象就是同一条记录在系统中存在了多个版本，这就是 MySQL 的多版本并发控制（MVCC）。</p><p>需要注意的是，MVCC 只在 RC 和 RR 两个隔离级别下工作。因此在上面的实验中，改成 RR 隔离级别，第 6 步中，得到的结果还是 session1 修改之前的记录（但是在第 8 步，结果不一样哦，感兴趣的可以把上面操作放在 RR 隔离级别下实验一下）</p><h3 id="6-MVCC-的优势"><a href="#6-MVCC-的优势" class="headerlink" title="6 MVCC 的优势"></a>6 MVCC 的优势</h3><p>MVCC 最大的好处是读不加锁，读写不冲突，极大地增加了 MySQL 的并发性。</p><p>通过 MVCC，保证了事务 ACID 中的 I（隔离性）特性。</p><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h3><p>我们知道了，MySQL 是通过 Read View 判断是否能直接查询到对应的记录，如果需要查询一些被其它事务正在更新的行，则要取出 Undo log 中历史版本的记录。</p><p>MVCC 实现的原理大致是：</p><p>InnoDB 每一行数据都有一个隐藏的回滚指针，用于指向该行修改前的最后一个历史版本，这个历史版本存放在 Undo log 中。如果要执行更新操作，会将原记录放入 Undo log 中，并通过隐藏的回滚指针指向 Undo log 中的原记录。其它事务此时需要查询时，就是查询 Undo log 中这行数据的最后一个历史版本。</p><p>MVCC 最大的好处是读不加锁，读写不冲突，极大的增加了 MySQL 的并发性，通过 MVCC，也保证了事务 ACID 中的 I（隔离性）特性。</p><h3 id="8-问题"><a href="#8-问题" class="headerlink" title="8 问题"></a>8 问题</h3><p>MVCC 为什么只在 RC 和 RR 两个隔离级别下工作？</p><p>解答：</p><p>从查询方面看，MVCC是解决在并发条件下，同时可能会产生多个值，如何从多个值中选择一个值的技术。</p><p>但在RU和串行的隔离级别下，只会存在一个值。</p><ul><li>RU：每次只取最新的值，不存在多个值的情况。</li><li>串行：每次查询都会加读锁，当有更新时会阻塞住，只有等到查询完锁释放后，才会做更新操作。所以也不存在多个值的情况。</li></ul><h2 id="21-不同事务隔离级别有哪些区别？"><a href="#21-不同事务隔离级别有哪些区别？" class="headerlink" title="21 不同事务隔离级别有哪些区别？"></a>21 不同事务隔离级别有哪些区别？</h2><h3 id="1-通过基本定义认识事务隔离级别"><a href="#1-通过基本定义认识事务隔离级别" class="headerlink" title="1 通过基本定义认识事务隔离级别"></a>1 通过基本定义认识事务隔离级别</h3><p>MySQL 有四种隔离级别，我们来看一下这四种隔离级别的基本定义：</p><ul><li>Read uncommitted（读未提交，简称：RU）: 在该隔离级别，所有事务都可以看到其它未提交的事务的执行结果。可能会出现脏读。</li><li>Read Committed（读已提交，简称： RC）：一个事务只能看见已经提交事务所做的改变。因为同一事务的其它实例在该实例处理期间可能会有新的 commit，所以可能出现幻读。</li><li>Repeatable Read（可重复读，简称：RR）：这是 MySQL 的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。消除了脏读、不可重复读，默认也不会出现幻读。</li><li>Serializable（串行）：这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问<br>题。</li></ul><h3 id="4-如何选择合适的事务隔离级别"><a href="#4-如何选择合适的事务隔离级别" class="headerlink" title="4 如何选择合适的事务隔离级别"></a>4 如何选择合适的事务隔离级别</h3><p>在上面的内容中，我们认识了事务隔离级别，那么应该怎样选择合适的事务隔离级别呢？</p><p>对于 RU 隔离级别，会导致脏读，从性能上看，也不会比其它隔离级别好太多，因此生产环境不建议使用。</p><p>对于 RC 隔离级别，相比 RU 隔离级别，不会出现脏读；但是会出现幻读，一个事务中的两次执行同样的查询，可能得到不一样的结果。</p><p>对于 RR 隔离级别，相比 RC 隔离级别，解决了部分幻读（这个在第 17 节详细讲了，RR 隔离级别通过间隙锁解决了部分幻读），但是相对于 RC，锁的范围可能更大了。</p><p>对于 Serializable 隔离级别，因为它强制事务串行执行，会在读取的每一行数据上都加锁，因此可能会导致大量的超时和锁争用的问题。生成环境很少使用。</p><p>因此总的来说，建议在 RC 和 RR 两个隔离级别中选一种，如果能接受幻读，需要并发高点，就可以配置成 RC，如果不能接受幻读的情况，就设置成 RR 隔离级别。</p><h3 id="22-养成好的事务习惯"><a href="#22-养成好的事务习惯" class="headerlink" title="22 养成好的事务习惯"></a>22 养成好的事务习惯</h3><h3 id="1-不好的事务习惯"><a href="#1-不好的事务习惯" class="headerlink" title="1 不好的事务习惯"></a>1 不好的事务习惯</h3><h4 id="1-1-在循环中提交"><a href="#1-1-在循环中提交" class="headerlink" title="1.1 在循环中提交"></a>1.1 在循环中提交</h4><p>在大多数情况下，MySQL 都是开启自动提交的，如果遇到循环执行 SQL，则相当于每个循环中都会进行一次提交，实际这算一个不好的事务习惯了。下面我创建一张测试表，并定义两个循环写入数据的存储过程：一个是自动提交，另一个是在循环前开启一个事务，在循环后一次性提交。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">use</span> muke<span class="token punctuation">;</span> <span class="token comment">/* 使用muke这个database */</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t22<span class="token punctuation">;</span> <span class="token comment">/* 如果表t22存在则删除表t22 */</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t22<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>c<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>d<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_a<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_b<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>b<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span>  <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">procedure</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> insert_t22_1<span class="token punctuation">;</span> <span class="token comment">/* 如果存在存储过程insert_t22_1，则删除 */</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">procedure</span> insert_t22_1<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">/* 创建存储过程insert_t22_1 */</span><span class="token keyword">begin</span><span class="token keyword">declare</span> i <span class="token keyword">int</span><span class="token punctuation">;</span> <span class="token comment">/* 声明变量i */</span><span class="token keyword">set</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* 设置i的初始值为1 */</span><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token keyword">do</span> <span class="token comment">/* 对满足i&lt;=10000的值进行while循环 */</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t22<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 写入表t22中a、b两个字段，值都为i当前的值 */</span><span class="token keyword">set</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* 将i加1 */</span><span class="token keyword">end</span> <span class="token keyword">while</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span> <span class="token comment">/* 创建批量写入10000条数据到表t22的存储过程insert_t22_1 */</span><span class="token keyword">drop</span> <span class="token keyword">procedure</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> insert_t22_2<span class="token punctuation">;</span> <span class="token comment">/* 如果存在存储过程insert_t22_2，则删除 */</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">procedure</span> insert_t22_2<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">/* 创建存储过程insert_t22_2 */</span><span class="token keyword">begin</span><span class="token keyword">declare</span> i <span class="token keyword">int</span><span class="token punctuation">;</span> <span class="token comment">/* 声明变量i */</span><span class="token keyword">set</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* 设置i的初始值为1 */</span><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token keyword">do</span> <span class="token comment">/* 对满足i&lt;=10000的值进行while循环 */</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t22<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 写入表t22中a、b两个字段，值都为i当前的值 */</span><span class="token keyword">set</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* 将i加1 */</span><span class="token keyword">end</span> <span class="token keyword">while</span><span class="token punctuation">;</span><span class="token keyword">commit</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span> <span class="token comment">/* 创建批量写入10000条数据到表t22的存储过程insert_t22_2 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们来对比两个存储过程的速度：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">mysql&gt; call insert_t22_1(); /* insert_t22_1 */Query OK, 1 row affected (28.36 sec)mysql&gt; call insert_t22_2(); /* insert_t22_2 */Query OK, 0 rows affected (0.37 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>明显第二种方式快的多。因为 insert_t22_1 每一次提交都要写一次重做日志，实际写了 10000 次重做日志，而存储过程 insert_t22_2 只写了 1 次重做日志。</p><p>因此，在类似这种循环写入的情况，如果循环次数不是太多，建议在循环前开启一个事务，循环结束后统一提交。</p><h3 id="1-2-不关注同一个事务里语句顺序"><a href="#1-2-不关注同一个事务里语句顺序" class="headerlink" title="1.2 不关注同一个事务里语句顺序"></a>1.2 不关注同一个事务里语句顺序</h3><p>比如 A 在超市购买 100 元的商品，付款操作可以简化为：</p><div class="table-container"><table><thead><tr><th>序号</th><th>操作</th></tr></thead><tbody><tr><td>1</td><td>A 的账户中扣除 100</td></tr><tr><td>2</td><td>超市的账户增加 100</td></tr><tr><td>3</td><td>在超市系统中记录一条日志</td></tr></tbody></table></div><p>很多时候我们会按上面的 SQL 步骤放入一个事务里执行，不关注里面语句的顺序。实际可以优化的。</p><p>根据两阶段锁，整个事务里面涉及的锁，需要等到事务提交时才会释放。因此我们在同一个事务中，可以把没锁或者锁范围小的语句放在事务前面执行，而锁定范围大的语句放在后面执行。</p><blockquote><p>这里来回顾一下第 16 节中提到的两阶段锁：锁操作分为两个阶段，加锁阶段和解锁阶段，并且保证加锁阶段和解锁阶段不相交。在执行语句的时候加上锁，但并不是语句执行完就立刻释放锁，而是要等到事务结束时才释放。</p></blockquote><p>因此上面 A 购买商品的例子中，可能很多人同时在超市付款，那么存在锁竞争的最可能是超市账户增加 100 元的操作。</p><p>那么付款操作可以这么优化：</p><div class="table-container"><table><thead><tr><th>序号</th><th>操作</th></tr></thead><tbody><tr><td>1</td><td>在超市系统中记录一条日志</td></tr><tr><td>2</td><td>A 的账户中扣除 100</td></tr><tr><td>3</td><td>超市的账户增加 100</td></tr></tbody></table></div><p>把可能存在锁竞争的操作放在最后执行，从而优化整个事务。</p><p>因此在写程序时，应该去关注事务里的语句顺序。</p><h3 id="1-3-不关注不同事务访问资源的顺序"><a href="#1-3-不关注不同事务访问资源的顺序" class="headerlink" title="1.3 不关注不同事务访问资源的顺序"></a>1.3 不关注不同事务访问资源的顺序</h3><p>各位是否还记得，在第 18 节中，讲到了几种产生死锁的原因，其中有两条就跟不同事务访问资源顺序有关，我们来回顾一下：</p><ul><li>不同线程并发访问同一张表的多行数据，未按顺序访问导致死锁。</li><li>不同线程并发访问多个表时，未按顺序访问导致死锁。</li></ul><p>如果不关注并发访问的不同事务中访问资源的顺序，就会增大出现死锁的概率。</p><p>因此，为了降低死锁，我们需要去关注不同事务访问资源的顺序。</p><h4 id="1-4-不关注事务隔离级别"><a href="#1-4-不关注事务隔离级别" class="headerlink" title="1.4 不关注事务隔离级别"></a>1.4 不关注事务隔离级别</h4><p>在上一节中，我们详细聊到了事务隔离级别，因此也知道，不同事务隔离级别加锁的情况也是不同的。</p><p>如果完全不关注自己业务使用的 MySQL 是什么隔离级别，可能会降低程序的并发能力或者导致死锁。</p><p>比如业务场景完全能接受幻读，如果要求更高的 QPS，使用 RR 隔离级别显然不是最好的选择，因此可以改为 RC 隔离级别。</p><p>而如果业务使用的是 RR 隔离级别，可能由于间隙锁导致死锁（可参考第 18 节 2.3 中的例子），因此也应该在程序编写时关注 RR 隔离级别下是否会有间隙锁。</p><p>因此，为了更高的并发和降低死锁概率，在创建事务前，也应该去关注自己业务的数据库是什么事务隔离级别。</p><h4 id="1-5-在事务中混合使用存储引擎"><a href="#1-5-在事务中混合使用存储引擎" class="headerlink" title="1.5 在事务中混合使用存储引擎"></a>1.5 在事务中混合使用存储引擎</h4><p>在事务中混合使用事务型（比如 InnoDB）和非事务型（比如 MyISAM）表，如果是正常提交，到没什么问题。</p><p>但是，如果该事务回滚了，事务型的表可以正常回滚，而非事务型的表的变更就无法回滚了。这种情况就会导致数据不正常，并且事务最终的结果也难以确定。</p><p>因此，在事务中混合使用存储引擎也是一个不好的事务习惯。</p><blockquote><p>值得一提的是：如果开启 GTID，那么当同一个事务中使用不同存储引擎的表时，会出现如下报错：<br>ERROR 1785 (HY000): Statement violates GTID consistency: Updates to non-transactional tables can only be done in either autocommitted statements or single-statement transactions, and never in the same statement as updates to transactional tables.<br>因此，开启 GTID 的情况，可以避免同一个事务中混合使用存储引擎的情况。</p></blockquote><h3 id="2-总结一下好的事务习惯"><a href="#2-总结一下好的事务习惯" class="headerlink" title="2 总结一下好的事务习惯"></a>2 总结一下好的事务习惯</h3><p>在本节中，我们列举了几种不好的事务习惯，这里总结一下好的事务习惯：</p><ul><li>循环写入的情况，如果循环次数不是太多，建议在循环前开启一个事务，循环结束后统一提交。</li><li>优化事务里的语句顺序，减少锁时间。</li><li>关注不同事务访问资源的顺序。</li><li>创建事务之前，关注事务隔离级别。</li><li>不在事务中混合使用存储引擎。</li></ul><h2 id="23-细聊分布式事务"><a href="#23-细聊分布式事务" class="headerlink" title="23 细聊分布式事务"></a>23 细聊分布式事务</h2><p>比如你在网上买了一本书，可以简化为在订单库增加订单，在库存库减掉这本书的 1 个库存。这里订单库和库存库是在不同的机器上，如果这两步放在两个事务里，增加订单这一步成功了，但是减库存这里失败了。那岂不是就乱了。</p><p>这里就要引出分布式事务了。什么是分布式事务？</p><h3 id="1-认识分布式事务"><a href="#1-认识分布式事务" class="headerlink" title="1 认识分布式事务"></a>1 认识分布式事务</h3><p>分布式事务是指一个大的事务由很多小操作组成，小操作分布在不同的服务器上或者不同的应用程序上。分布式事务需要保证这些小操作要么全部成功，要么全部失败。MySQL 从 5.0.3 开始支持分布式事务。</p><p>分布式事务使用两阶段提交协议：</p><ul><li>第一阶段：所有分支事务都开始准备，告诉事务管理器自己已经准备好了；</li><li>第二阶段：确定是 rollback 还是 commit，如果有一个节点不能提交，则所有节点都要回滚。</li></ul><p>与本地事务不同点在于：分布式事务需要多一次 prepare 操作，等收到所有节点的确定信息后，再进行 commit 或者 rollback。</p><p>MySQL 中分布式事务按实现方式可以分为两种：MySQL 自带的分布式事务和结合中间件实现分布式事务。下面来详细介绍一下这两种分布式事务。</p><h3 id="2-MySQL-自带的分布式事务"><a href="#2-MySQL-自带的分布式事务" class="headerlink" title="2 MySQL 自带的分布式事务"></a>2 MySQL 自带的分布式事务</h3><p>MySQL 有自带的分布式事务实现方法，具体语法如下：</p><p>启动分支事务：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">xa <span class="token keyword">start</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'a_1'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>‘a’,’a_1’ 表示 xid，<br>a 表示 gtrid，为分布式事务标识符，相同的分布式事务使用相同的 gtrid。<br>a_1 表示 bqual，为分支限定符，分布式事务中的每一个分支事务的 bqual 必须不同。</p></blockquote><p>结束分支事务：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">xa <span class="token keyword">end</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'a_1'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进入准备状态：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">xa <span class="token keyword">prepare</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'a_1'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>提交分支事务：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">xa <span class="token keyword">commit</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'a_1'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>回滚分支事务：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">xa <span class="token keyword">rollback</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'a_1'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回当前数据库中处于prepare状态的分支事务的详细信息：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">xa recover<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们来看一个例子：</p><div class="table-container"><table><thead><tr><th>session1</th><th>session2</th></tr></thead><tbody><tr><td>use muke1;</td><td>use muke2;</td></tr><tr><td>create table t23_1(id int);</td><td>create table t23_2(id int);</td></tr><tr><td>xa start ‘test’,’muke1’;</td><td>xa start ‘test’,’muke2’;</td></tr><tr><td>insert into t23_1 select 1;</td><td>insert into t23_2 select 1;</td></tr><tr><td>xa end ‘test’,’muke1’;</td><td>xa end ‘test’,’muke2’;</td></tr><tr><td>xa prepare ‘test’,’muke1’;</td><td>xa prepare ‘test’,’muke2’;</td></tr><tr><td>xa recover \G</td><td>xa recover \G</td></tr><tr><td>xa commit ‘test’,’muke1’;</td><td>xa commit ‘test’,’muke2’;</td></tr></tbody></table></div><p>上面的例子就演示了一个分布式事务，事务在 muke1 库中的 t23_1 表中插入一条记录，同时在 muke2 库中的 t23_2 表中插入一条记录，两个操作作为同一个事务提交。在进入准备状态之前，如果 session2 中某一步没执行成功而回滚了，则 session1 和 session2 整个分布式事务的操作都会回滚。</p><p>但是 MySQL 5.7 之前的版本，自带的分布式事务存在以下问题：</p><p>比如某个分支事务到达 prepare 状态时，此时数据库断电，重启后，可以继续对分支事务进行提交或者回滚，但是提交的事务不会写 binlog，如果有从库，会导致主从数据不一致的情况。</p><p>如果分支事务的客户端连接异常中止，那么数据库会自动回滚当前分支未完成的事务，如果此时分支事务已经到 prepare 状态，那么这个分布式事务的其他分支可能已经成功提交，如果这个分支回滚，可能导致分布式事务的不完整，丢失部分分支事务的内容。</p><p>还有一种情况，如果分支事务在执行到 prepare 状态时，数据库出现故障，并且无法启动，需要使用全备和 binlog 来恢复数据，那么这些在 prepare 状态的分支事务因为没有记录到 binlog，所以也不能通过binlog 进行恢复，在数据库恢复后，将丢失这部分数据。</p><p>所以，MySQL 5.7 之前的版本自带的分布式事务还存在比较严重的缺陷，在有些场景下，会导致数据丢失。如果业务对数据完整性要求不改，可以考虑使用，如果对数据完整性要求比较高，需要考虑先升级到 5.7 版本。</p><h3 id="3-结合中间件实现分布式"><a href="#3-结合中间件实现分布式" class="headerlink" title="3 结合中间件实现分布式"></a>3 结合中间件实现分布式</h3><p>上面说了 MySQL 自带的分布式事务，这里再介绍一下借助中间件实现分布式的情况。</p><p>具体实现方式可以拿上面网上购书的例子来说：</p><p>订单业务程序处理完增加订单的操作后，将减库存操作发送到消息队列中间件中（比如：Rocketmq），订单业务程序完成提交。然后库存业务程序检查到消息队列有减对应商品库存的信息，就开始执行减库存操作。库存业务执行完减库存操作，再发送一条消息给消息队列中间件：内容是已经减掉库存。具体步骤如下：</p><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/MQ实现增加订单和减库存操作.png" alt="MQ实现增加订单和减库存操作"></p><p>当然，为了确定最终已经完成减库存操作，还可以加一步对数据库中该商品库存的判断。</p><hr><p>第5章 MySQL的一些其他经验</p><h2 id="27-使用读写分离需要注意哪些？"><a href="#27-使用读写分离需要注意哪些？" class="headerlink" title="27 使用读写分离需要注意哪些？"></a>27 使用读写分离需要注意哪些？</h2><p>对于高访问量的业务场景，MySQL 读写分离显得格外重要。</p><p>通常我们说的 MySQL 读写分离是指：对于修改操作在主库上执行，而对于查询操作，在从库上执行。主要目的是分担主库的压力。</p><p>但是读写分离有时也会存在问题，比如：主从延迟时，读取的从库数据不是最新的，对应的业务场景比如：</p><p>你网购的一个商品，付完款之后，因为主从延迟，第一时间还查询不到订单（查询的从库），即使等一段时间能看到订单，但是相信这种情况很多用户是不能接受的。</p><p>本节就一起来讨论一下：读写分离需要注意哪些问题。</p><p>通常情况下，读写分离都是依赖主从复制，因此，我们先来看看主从复制的原理，也能方便我们理解为什么会出现主从延迟的现象。</p><h3 id="1-主从复制的原理"><a href="#1-主从复制的原理" class="headerlink" title="1 主从复制的原理"></a>1 主从复制的原理</h3><h4 id="1-1-MySQL-异步复制"><a href="#1-1-MySQL-异步复制" class="headerlink" title="1.1 MySQL 异步复制"></a>1.1 MySQL 异步复制</h4><p>传统的 MySQL 主从复制是异步的，因此也称为异步复制，MySQL 异步复制的原理如下：</p><ul><li>在主库开启 binlog 的情况下</li><li>如果主库有增删改的语句，会记录到 binlog 中</li><li>主库通过 IO 线程把 binlog 里面的内容传给从库的中继日志（relay log）中</li><li>主库给客户端返回 commit 成功（这里不会管从库是否已经收到了事务的 binlog）</li><li>从库的 SQL 线程负责读取它的 relay log 里的信息并应用到从库数据库中</li></ul><p>实现原理如下图：</p><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/MySQL异步复制.png" alt="MySQL异步复制"></p><p>在上图中，有一个地方不能忽视：</p><p>在主库上并行运行的更新 SQL，由于从库只有单个 SQL 线程去消化 relay log，因此更新的 SQL 在从库只能串行执行。这也是很多情况下，会出现主从延迟的原因。</p><p>当然，从 5.6 开始，MySQL 支持了每个库可以配置单独的 SQL 线程来消化 relay log，在 5.7 又增加了基于组提交的并行复制，大大改善了主从延迟的问题。</p><h4 id="1-2-MySQL-半同步复制"><a href="#1-2-MySQL-半同步复制" class="headerlink" title="1.2 MySQL 半同步复制"></a>1.2 MySQL 半同步复制</h4><p>在 MySQL 异步复制的基础上，又出现了一种改进的复制方式，称为：半同步复制。其原理如下：</p><ul><li>在主库开启 binlog 的情况下</li><li>如果主库有增删改的语句，会记录到 binlog 中</li><li>主库通过 IO 线程把 binlog 里面的内容传给从库的中继日志（relay log）中</li><li>从库收到 binlog 后，发送给主库一个 ACK，表示收到了</li><li>主库收到这个 ACK 以后，才能给客户端返回 commit 成功</li><li>从库的 SQL 线程负责读取它的 relay log 里的信息并应用到从库数据库中</li></ul><p>实现原理如下图：</p><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/MySQL半同步复制.png" alt="MySQL半同步复制"></p><p>跟传统的异步复制相比，半同步复制保证了所有给客户端发送过确认提交的事务，从库都已经收到这个日志了。</p><h3 id="2-常见的读写分离方式"><a href="#2-常见的读写分离方式" class="headerlink" title="2 常见的读写分离方式"></a>2 常见的读写分离方式</h3><h4 id="2-1、通过程序"><a href="#2-1、通过程序" class="headerlink" title="2.1、通过程序"></a>2.1、通过程序</h4><p>开发通过配置程序来决定修改操作走主库，查询操作走从库。这种方式直连数据库，优点是性能会好点，缺点是配置麻烦。</p><p>但是需要注意的是：从库需要设置为 read_only，防止配置错误在从库写入了数据。</p><blockquote><p>这里提醒一点：<br>程序连接的用户建议不要给 super 权限，因为 super 权限的用户，即使整个库设置了 read_only ，也能写入数据。</p></blockquote><h4 id="2-2、通过中间件"><a href="#2-2、通过中间件" class="headerlink" title="2.2、通过中间件"></a>2.2、通过中间件</h4><p>通过中间件实现读写分离，目前算是一种主流的方式。拿 MyCAT 举例：</p><p>在 schema.xml 文件中，dataHost 标签 balance 属性的值，决定了是否启用读写分离。</p><p>balance 各个值及对应的读写方法如下：</p><ul><li>0：不开启读写分离，读操作发送到 writehost</li><li>1：全部的 readhost 与 stand by writehost 参与 select 语句的负载均衡</li><li>2：所有读操作都随机在 writehost、readhost上分发</li><li>3：所有读请求随机分发到 writerhost 对应的 readhost 执行，writehost 不负担读压力</li></ul><p>因此可以根据实际情况选择上面合适的读写分离策略。</p><h3 id="3-什么情况下会出现主从延迟"><a href="#3-什么情况下会出现主从延迟" class="headerlink" title="3 什么情况下会出现主从延迟"></a>3 什么情况下会出现主从延迟</h3><p>在本节的开始，我们说到，对于读写分离场景，最大的问题就是：主从延迟。那么在哪些情况下会出现主从延迟呢？这里大致总结一下可能导致主从延迟的场景：</p><ul><li>大表 DDL</li><li>大事务</li><li>主库 DML 并发大</li><li>从库配置差</li><li>表上无主键</li><li>等等</li></ul><p>因此，如果存在读写分离的情况，应尽量避免上诉情况在业务高峰出现。</p><p>当然，我们不能完全杜绝主从延迟。因此再介绍几种读写分离场景下应对延迟的方法。</p><h3 id="4-读写分离怎样应对主从延迟"><a href="#4-读写分离怎样应对主从延迟" class="headerlink" title="4 读写分离怎样应对主从延迟"></a>4 读写分离怎样应对主从延迟</h3><p>读写分离场景应该怎样应对主从延迟呢？这里来讨论一下几种常见的应对主从延迟的方法：</p><h4 id="4-1-判断主从是否延迟"><a href="#4-1-判断主从是否延迟" class="headerlink" title="4.1 判断主从是否延迟"></a>4.1 判断主从是否延迟</h4><p>有些业务场景，如果所有请求都落在主库，主库压力会很大，但是在读写分离的情况，又不希望主从存在延迟的时候去读取从库。这种情况，就可以考虑查询时，先判断主从是否存在延迟，如果存在延迟，则查询落在主库，如果没延迟，则查询语句落在从库。</p><p>这里介绍几种判断主从延迟的方法：</p><p>第一种方法：判断 Seconds_Behind_Master 是否等于 0。</p><p>如果 Seconds_Behind_Master =0，则查询从库，如果大于 0，则查询主库。</p><blockquote><p>这里补充一下 Seconds_Behind_Master。<br>Seconds_Behind_Master 是在从库上执行 show slave status 时返回的其中一项，表示从库延迟的秒数。<br>其计算方法是：<br>从库服务器当前的时间戳与二进制日志中的事件的时间戳（在主库上的写入时间）相对比得到的。</p></blockquote><p>但是某些情况下，Seconds_Behind_Master 并不一定准确。比如网络中断时，Seconds_Behind_Master = 0 ，并不能代表主从无延迟。因此，有比这个更准确的一种方法：对比位点或 GTID。</p><p>第二种方法：对比位点或 GTID</p><p>如果 Master_Log_File 跟 Relay_Master_Log_File 相等，</p><p>并且 Read_Master_Log_Pos 跟 Exec_Master_Log_Pos 相等，</p><p>则可以把读请求放到从库，否则读请求放到主库。</p><blockquote><p>补充一下上面几个参数的意义：<br>几个参数均是通过 show slave status 返回的参数，用来查询主从复制的状态。<br>Master_Log_File：IO 线程正在读取的主库 binlog 文件名<br>Relay_Master_Log_File：SQL 线程最近执行的事务对应的主库 binlog 文件名<br>Read_Master_Log_Pos ：IO 线程正在读取的主库 binlog 文件中的位点<br>Exec_Master_Log_Pos ：SQL 线程最近读取和执行的事务对应的主库 binlog 文件中的位点</p></blockquote><p>如果开启了 GTID 复制，则可以对比 Retrieved_Gtid_Set 和 Executed_Gtid_Set 是否相等，相等则把读请求放到从库，有差异则读请求放到主库。</p><blockquote><p>同样补充下两个参数的意义：<br>前提是需要开启 GTID 两个参数才会有值，解释如下：<br>Retrieved_Gtid_Set：从库收到的所有日志的 GTID 集合<br>Executed_Gtid_Set：从库已经执行完的 GTID 集合</p></blockquote><h4 id="4-2-采用半同步复制"><a href="#4-2-采用半同步复制" class="headerlink" title="4.2 采用半同步复制"></a>4.2 采用半同步复制</h4><p>在本节的前面，我们讲解了半同步复制的原理，跟传统的异步复制相比，半同步复制保证了所有给客户端发送过确认提交的事务，从库都已经收到这个日志了。因此出现延迟的概率会小很多，当然实际生产应用时，建议结合上面讲的位点或 GTID 判断。</p><h4 id="4-3-等待同步完成"><a href="#4-3-等待同步完成" class="headerlink" title="4.3 等待同步完成"></a>4.3 等待同步完成</h4><p>依然采用 4.1 中介绍的几种判断是否有延迟的方法，只是应对方式不一样，比如存在延迟，则将情况反馈给程序，在前端页面提醒用户数据未完全同步，如果没有延迟，则查询从库。</p><p>有人可能会觉得：这种方式谁会用啊？实际可以应用在内部人员看的报表业务上。因为报表可能涉及的 SQL 都比较复杂，存在延迟就考虑去查询主库，可能会对其它线上业务有影响，因此可以等待从库同步完成，再查询从库。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 职业规划 </tag>
            
            <tag> 慕课专栏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《MySQL必知必会》读书笔记</title>
      <link href="mysql-bi-zhi-bi-hui-du-shu-bi-ji/"/>
      <url>mysql-bi-zhi-bi-hui-du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="第1章-了解SQL"><a href="#第1章-了解SQL" class="headerlink" title="第1章 了解SQL"></a>第1章 了解SQL</h2><ol><li><p><strong>数据库（database）</strong> 保存有组织的数据的容器（通常是一个文件或一组文件）。</p></li><li><p><strong>表（table）</strong> 某种特定类型数据的结构化清单。</p></li><li><p><strong>模式（schema）</strong> 关于数据库和表的布局及特性的信息。</p></li><li><p><strong>列（column）</strong> 表中的一个字段。所有表都是由一个或多个列组成的。</p></li><li><p><strong>数据类型（datatype）</strong> 所容许的数据的类型。每个表列都有相应的数据类型，它限制（或容许）该列中存储的数据。</p></li><li><p><strong>行（row）</strong> 表中的一个记录。</p></li><li><p><strong>主键（primary key）</strong> 一列（或一组列），其值能够唯一区分表中每个行。</p><p> 表中的任何列都可以作为主键，只要它满足以下条件：</p><blockquote><ol><li>任意两行都不具有相同的主键值；</li><li>每个行都必须具有一个主键值（主键列不允许NULL值）。</li></ol></blockquote><p> 主键的最好习惯：</p><blockquote><ol><li>不更新主键列中的值；</li><li>不重用主键列的值；</li><li>不在主键列中使用可能会更改的值。</li></ol></blockquote></li></ol><h2 id="第2章-MySQL简介"><a href="#第2章-MySQL简介" class="headerlink" title="第2章 MySQL简介"></a>第2章 MySQL简介</h2><ol><li>DBMS（数据库管理系统）分两类：<ol><li>基于共享文件系统的DBMS，如Microsoft Access和FileMaker；</li><li>基于客户机—服务器的DBMS，如MySQL、Oracle以及Microsoft SQL Server。</li></ol></li></ol><h2 id="第3章-使用MySQL"><a href="#第3章-使用MySQL" class="headerlink" title="第3章 使用MySQL"></a>第3章 使用MySQL</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SHOW</span> <span class="token keyword">DATABASES</span><span class="token punctuation">;</span> <span class="token comment">/* 显示所有数据库 */</span><span class="token keyword">USE</span> mysql<span class="token punctuation">;</span> <span class="token comment">/* 选择数据库mysql */</span><span class="token keyword">SHOW</span> <span class="token keyword">TABLES</span><span class="token punctuation">;</span> <span class="token comment">/* 显示所有表 */</span><span class="token keyword">SHOW</span> <span class="token keyword">COLUMNS</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span> <span class="token comment">/* 显示user表中的列信息 */</span><span class="token keyword">DESCRIBE</span> <span class="token keyword">user</span><span class="token punctuation">;</span> <span class="token comment">/* 同上 */</span><span class="token keyword">SHOW</span> <span class="token keyword">STATUS</span><span class="token punctuation">;</span> <span class="token comment">/* 显示服务器状态信息 */</span><span class="token keyword">SHOW</span> <span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> mysql<span class="token punctuation">;</span> <span class="token comment">/* 显示创建数据库mysql的SQL语句 */</span><span class="token keyword">SHOW</span> <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span><span class="token punctuation">;</span> <span class="token comment">/* 显示创建表user的SQL语句 */</span><span class="token keyword">show</span> grants<span class="token punctuation">;</span> <span class="token comment">/* 显示用户的授权信息 */</span><span class="token keyword">SHOW</span> <span class="token keyword">ERRORS</span><span class="token punctuation">;</span> <span class="token comment">/* 显示服务器中的错误信息 */</span><span class="token keyword">SHOW</span> <span class="token keyword">WARNINGS</span><span class="token punctuation">;</span> <span class="token comment">/* 显示服务器中的警告信息 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>可以使用<code>help show</code> 来查看帮助信息。</p></blockquote><h2 id="第4章-检索数据"><a href="#第4章-检索数据" class="headerlink" title="第4章 检索数据"></a>第4章 检索数据</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token keyword">user</span><span class="token punctuation">.</span><span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span> <span class="token comment">/* 同上 */</span><span class="token keyword">SELECT</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> mysql<span class="token punctuation">.</span><span class="token keyword">user</span><span class="token punctuation">;</span> <span class="token comment">/* 同上 */</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span><span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span> <span class="token comment">/* 去除重复 */</span><span class="token keyword">SELECT</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">LIMIT</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">/* 只显示查询结果的前3条记录 */</span><span class="token keyword">SELECT</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">LIMIT</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">/* 只显示查询结果的第2条开始（下标从0开始）后面的3条记录 */</span><span class="token keyword">SELECT</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">LIMIT</span> <span class="token number">3</span> <span class="token keyword">OFFSET</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">/* 同上 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>SQL不区分大小写，也忽略空格。</p><p>DISTINCT关键字应用于所有列而不仅是前置它的列。</p></blockquote><h2 id="第5章-排序检索数据"><a href="#第5章-排序检索数据" class="headerlink" title="第5章 排序检索数据"></a>第5章 排序检索数据</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token keyword">User</span><span class="token punctuation">;</span> <span class="token comment">/* 升序排序 */</span><span class="token keyword">SELECT</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token keyword">User</span> <span class="token keyword">ASC</span><span class="token punctuation">;</span> <span class="token comment">/* 同上 */</span><span class="token keyword">SELECT</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token keyword">User</span> <span class="token keyword">DESC</span><span class="token punctuation">;</span> <span class="token comment">/* 降序排序 */</span><span class="token keyword">SELECT</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token keyword">User</span><span class="token punctuation">,</span> Host<span class="token punctuation">;</span> <span class="token comment">/* 先按User升序排序，再按Host升序排序 */</span><span class="token keyword">SELECT</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token keyword">User</span> <span class="token keyword">DESC</span><span class="token punctuation">,</span> Host<span class="token punctuation">;</span> <span class="token comment">/* 先按User降序排序，再按Host升序排序 */</span><span class="token keyword">SELECT</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token keyword">User</span> <span class="token keyword">DESC</span><span class="token punctuation">,</span> Host <span class="token keyword">ASC</span><span class="token punctuation">;</span> <span class="token comment">/* 同上 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>DESC关键字只应用到直接位于其前面的列名。</p></blockquote><h2 id="第6章-过滤数据"><a href="#第6章-过滤数据" class="headerlink" title="第6章 过滤数据"></a>第6章 过滤数据</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> <span class="token keyword">User</span><span class="token operator">=</span><span class="token string">'root'</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span><span class="token punctuation">,</span> max_connections <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> max_connections <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span><span class="token punctuation">,</span> max_connections <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> max_connections <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span><span class="token punctuation">,</span> max_connections <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> max_connections <span class="token operator">&lt;&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">/* 同上 */</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span><span class="token punctuation">,</span> max_connections <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> max_connections <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span><span class="token punctuation">,</span> max_connections <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> max_connections <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span><span class="token punctuation">,</span> max_connections <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> max_connections <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span><span class="token punctuation">,</span> max_connections <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> max_connections <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span><span class="token punctuation">,</span> max_connections <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> max_connections <span class="token operator">BETWEEN</span> <span class="token number">0</span> <span class="token operator">AND</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span><span class="token punctuation">,</span> max_connections <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> ssl_cipher <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span> <span class="token comment">/* ssl_cipher字段为NULL */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第7章-数据过滤"><a href="#第7章-数据过滤" class="headerlink" title="第7章 数据过滤"></a>第7章 数据过滤</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> Host<span class="token operator">=</span><span class="token string">'localhost'</span> <span class="token operator">AND</span> <span class="token keyword">User</span><span class="token operator">=</span><span class="token string">'root'</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> Host<span class="token operator">=</span><span class="token string">'localhost'</span> <span class="token operator">OR</span> <span class="token keyword">User</span><span class="token operator">=</span><span class="token string">'root'</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> <span class="token punctuation">(</span>Host<span class="token operator">=</span><span class="token string">'localhost'</span> <span class="token operator">OR</span> <span class="token keyword">User</span><span class="token operator">=</span><span class="token string">'root'</span><span class="token punctuation">)</span> <span class="token operator">AND</span> max_connections <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> Host <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token string">'%'</span><span class="token punctuation">,</span> <span class="token string">'localhost'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> Host <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token string">'%'</span><span class="token punctuation">,</span> <span class="token string">'localhost'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>AND的优先级比OR高。</p><p>IN操作符完成与OR相同的功能，但是更快。</p></blockquote><h2 id="第8章-用通配符进行过滤"><a href="#第8章-用通配符进行过滤" class="headerlink" title="第8章 用通配符进行过滤"></a>第8章 用通配符进行过滤</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> Host <span class="token operator">LIKE</span> <span class="token string">'local%'</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> <span class="token keyword">User</span> <span class="token operator">LIKE</span> <span class="token string">'r__t'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>百分号（%）表示任何字符出现任意次数。%不能匹配NULL值。</p><p>下划线（_）只匹配单个字符。</p></blockquote><h2 id="第9章-用正则表达式进行搜索"><a href="#第9章-用正则表达式进行搜索" class="headerlink" title="第9章 用正则表达式进行搜索"></a>第9章 用正则表达式进行搜索</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> <span class="token keyword">User</span> <span class="token operator">REGEXP</span> <span class="token string">'r..t'</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> Host <span class="token operator">REGEXP</span> <span class="token string">'%|localhost'</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> <span class="token keyword">User</span> <span class="token operator">REGEXP</span> <span class="token string">'r[a-z]{2}t'</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> <span class="token keyword">User</span> <span class="token operator">REGEXP</span> <span class="token string">'mysql\\.sys'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>可以使用类似<code>SELECT 'hello' REGEXP '[0-9]'</code>这样的SQL来测试正常表达式，匹配成功返回1，否则返回0。</p></blockquote><h2 id="第10章-创建计算字段"><a href="#第10章-创建计算字段" class="headerlink" title="第10章 创建计算字段"></a>第10章 创建计算字段</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> CONCAT<span class="token punctuation">(</span><span class="token keyword">User</span><span class="token punctuation">,</span> <span class="token string">'('</span><span class="token punctuation">,</span> Host<span class="token punctuation">,</span> <span class="token string">')'</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> CONCAT<span class="token punctuation">(</span><span class="token keyword">User</span><span class="token punctuation">,</span> <span class="token string">'('</span><span class="token punctuation">,</span> Host<span class="token punctuation">,</span> <span class="token string">')'</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> UserHost <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="第11章-使用数据处理函数"><a href="#第11章-使用数据处理函数" class="headerlink" title="第11章 使用数据处理函数"></a>第11章 使用数据处理函数</h2><div class="table-container"><table><thead><tr><th><strong>函数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Left()</td><td>返回串左边的字符</td></tr><tr><td>Length()</td><td>返回串的长度</td></tr><tr><td>Locate()</td><td>找出串的一个子串</td></tr><tr><td>Lower()</td><td>将串转换为小写</td></tr><tr><td>LTrim()</td><td>去掉串左边的空格返</td></tr><tr><td>Right()</td><td>返回串右边的字符</td></tr><tr><td>RTrim()</td><td>去掉串右边的空格</td></tr><tr><td>Soundex()</td><td>返回串的SOUNDEX值</td></tr><tr><td>SubString()</td><td>返回子串的字符</td></tr><tr><td>Upper()</td><td>将串转换为大写</td></tr><tr><td>AddDate()</td><td>增加一个日期（天、周等）</td></tr><tr><td>AddTime()</td><td>增加一个时间（时、分等）</td></tr><tr><td>CurDate()</td><td>返回当前日期</td></tr><tr><td>CurTime()</td><td>返回当前时间</td></tr><tr><td>Date()</td><td>返回日期时间的日期部分</td></tr><tr><td>DateDiff()</td><td>计算两个日期之差</td></tr><tr><td>Date_Add()</td><td>高度灵活的日期运算函数</td></tr><tr><td>Date_Format()</td><td>返回一个格式化的日期或时间串</td></tr><tr><td>Day()</td><td>返回一个日期的天数部分</td></tr><tr><td>DayOfWeek()</td><td>对于一个日期，返回对应的星期几</td></tr><tr><td>Hour()</td><td>返回一个时间的小时部分</td></tr><tr><td>Minute()</td><td>返回一个时间的分钟部分</td></tr><tr><td>Month()</td><td>返回一个日期的月份部分</td></tr><tr><td>Now()</td><td>返回当前日期和时间</td></tr><tr><td>Second()</td><td>返回一个时间的秒部分</td></tr><tr><td>Time()</td><td>返回一个日期时间的时间部分</td></tr><tr><td>Year()</td><td>返回一个日期的年份部分</td></tr><tr><td>Abs()</td><td>返回一个数的绝对值</td></tr><tr><td>Cos()</td><td>返回一个角度的余弦</td></tr><tr><td>Exp()</td><td>返回一个数的指数值</td></tr><tr><td>Mod()</td><td>返回除操作的余数</td></tr><tr><td>Pi()</td><td>返回圆周率</td></tr><tr><td>Rand()</td><td>返回一个随机数</td></tr><tr><td>Sin()</td><td>返回一个角度的正弦</td></tr><tr><td>Sqrt()</td><td>返回一个数的平方根</td></tr><tr><td>Tan()</td><td>返回一个角度的正切</td></tr></tbody></table></div><blockquote><p>不管是插入或更新表值还是用WHERE子句进行过滤，日期必须为格式yyyy-mm-dd。并且总是应该使用4位数字的年份。</p></blockquote><h2 id="第12章-汇总数据"><a href="#第12章-汇总数据" class="headerlink" title="第12章 汇总数据"></a>第12章 汇总数据</h2><ol><li><p><strong>聚集函数（aggregate function）</strong> 运行在行组上，计算和返回单个值的函数。</p></li><li><p><strong>AVG()函数</strong> 计算单列的平均值。</p><blockquote><p>AVG()函数忽略列值为NULL的行。</p></blockquote></li><li><p><strong>COUNT()函数</strong> 进行计数。</p><blockquote><p>使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值（NULL）还是非空值。</p><p>使用COUNT(column)对特定列中具有值的行进行计数，忽略NULL值。</p></blockquote></li><li><p><strong>MAX()函数</strong> 返回指定列中的最大值。</p><blockquote><p>MAX()函数忽略列值为NULL的行。</p></blockquote></li><li><p><strong>MAX()函数</strong> 返回指定列中的最小值。</p><blockquote><p>MIN()函数忽略列值为NULL的行。</p></blockquote></li><li><p><strong>SUM()函数</strong> 用来返回指定列值的和（总计）。</p><blockquote><p>SUM()函数忽略列值为NULL的行。</p></blockquote></li><li><p>以上5个聚集函数都可以如下使用：</p><ol><li>对所有的行执行计算，指定ALL参数或不给参数（因为ALL是默认行为）；</li><li><p>只包含不同的值，指定DISTINCT参数。</p><blockquote><p>如果指定列名，则DISTINCT只能用于COUNT()。DISTINCT不能用于COUNT(*)，因此不允许使用COUNT（DISTINCT），否则会产生错误。类似地，DISTINCT必须使用列名，不能用于计算或表达式。</p><p><strong>将DISTINCT用于MIN()和MAX()</strong> 。虽然DISTINCT从技术上可用于MIN()和MAX()，但这样做实际上没有价值。一个列中的最小值和最大值不管是否包含不同值都是相同的。</p></blockquote></li></ol></li></ol><h2 id="第13章-分组数据"><a href="#第13章-分组数据" class="headerlink" title="第13章 分组数据"></a>第13章 分组数据</h2><ol><li><p>使用GROUP BY创建分组时需要注意：</p><ol><li>GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套，为数据分组提供更细致的控制。</li><li>如果在GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。</li><li>GROUP BY子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。</li><li>除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出。</li><li>如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。</li><li><p>GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。</p><blockquote><p>使用WITH ROLLUP关键字，可以得到每个分组以及每个分组汇总级别（针对每个分组）的值。</p></blockquote></li></ol></li><li><p>分组过滤操作HAVING支持所有WHERE操作符。</p><blockquote><p>WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤。</p></blockquote></li><li><p>一般在使用GROUP BY子句时，应该也给出ORDER BY子句。这是保证数据正确排序的唯一方法。</p></li><li><p>SELECT子句顺序</p></li></ol><div class="table-container"><table><thead><tr><th><strong>子句</strong></th><th><strong>说明</strong></th><th><strong>是否必须使用</strong></th></tr></thead><tbody><tr><td>SELECT</td><td>要返回的列或表达式</td><td>是</td></tr><tr><td>FROM</td><td>从中检索数据的表</td><td>仅在从表选择数据时使用</td></tr><tr><td>WHERE</td><td>行级过滤</td><td>否</td></tr><tr><td>GROUP BY</td><td>分组说明</td><td>仅在按组计算聚集时使用</td></tr><tr><td>HAVING</td><td>组级过滤</td><td>否</td></tr><tr><td>ORDER BY</td><td>输出排序顺序</td><td>否</td></tr><tr><td>LIMIT</td><td>要检索的行数</td><td>否</td></tr></tbody></table></div><h2 id="第14章-使用子查询"><a href="#第14章-使用子查询" class="headerlink" title="第14章 使用子查询"></a>第14章 使用子查询</h2><ol><li><p>子查询就是可以把一条SELECT语句返回的结果用于另一条SELECT语句的WHERE子句。</p></li><li><p>在WHERE子句中使用子查询，应该保证SELECT语句具有与WHERE子句中相同数目的列。通常，子查询将返回单个列并且与单个列匹配，但如果需要也可以使用多个列。</p></li></ol><h2 id="第15章-连结表"><a href="#第15章-连结表" class="headerlink" title="第15章 连结表"></a>第15章 连结表</h2><ol><li><p><strong>外键（foreign key）</strong> 为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。</p></li><li><p>由没有联结条件的表关系返回的结果为 <strong>笛卡儿积（cartesian product）</strong> 。如下：</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> vend_name<span class="token punctuation">,</span> prod_name<span class="token punctuation">,</span> prod_price<span class="token keyword">FROM</span> vendors<span class="token punctuation">,</span> products<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> vend_name<span class="token punctuation">,</span> prod_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>有时我们会听到返回称为 <strong>叉联结（cross join）</strong> 的笛卡儿积的联结类型。</p></blockquote></li><li><p><strong>等值联结（equijoin）</strong> 基于两个表之间的相等测试。这种联结也称为 <strong>内部联结</strong> 。下面的SQL都是等值联结：</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> vend_name<span class="token punctuation">,</span> prod_name<span class="token punctuation">,</span> prod_price<span class="token keyword">FROM</span> vendors<span class="token punctuation">,</span> products<span class="token keyword">WHERE</span> vendors<span class="token punctuation">.</span>vend_id <span class="token operator">=</span> products<span class="token punctuation">.</span>vend_id<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> vend_name<span class="token punctuation">,</span> prod_name<span class="token punctuation">;</span><span class="token keyword">SELECT</span> vend_name<span class="token punctuation">,</span> prod_name<span class="token punctuation">,</span> prod_price<span class="token keyword">FROM</span> vendors<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> products<span class="token keyword">ON</span> vendors<span class="token punctuation">.</span>vend_id <span class="token operator">=</span> products<span class="token punctuation">.</span>vend_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="第16章-创建高级联结"><a href="#第16章-创建高级联结" class="headerlink" title="第16章 创建高级联结"></a>第16章 创建高级联结</h2><ol><li><p>表别名只在查询执行中使用。</p></li><li><p>自联结</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> p1<span class="token punctuation">.</span>prod_id<span class="token punctuation">,</span> p1<span class="token punctuation">.</span>prod_name<span class="token keyword">FROM</span> products <span class="token keyword">AS</span> p1<span class="token punctuation">,</span> products <span class="token keyword">AS</span> p2<span class="token keyword">WHERE</span> p1<span class="token punctuation">.</span>vend_id <span class="token operator">=</span> p2<span class="token punctuation">.</span>vend_id  <span class="token operator">AND</span> p2<span class="token punctuation">.</span>prod_id <span class="token operator">=</span> <span class="token string">'DTNTR'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>自联结远比处理子查询快得多。</p></blockquote></li><li><p>无论何时对表进行联结，应该至少有一个列出现在不止一个表中（被联结的列）。标准的联结（前一章中介绍的内部联结）返回所有数据，甚至相同的列多次出现。 <strong>自然联结</strong> 排除多次出现，使每个列只返回一次。这一般是通过对表使用通配符（SELECT*），对所有其他表的列使用明确的子集来完成的。</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> c<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">,</span> o<span class="token punctuation">.</span>order_num<span class="token punctuation">,</span> o<span class="token punctuation">.</span>order_data<span class="token punctuation">,</span> io<span class="token punctuation">.</span>prod_id<span class="token punctuation">,</span> io<span class="token punctuation">.</span>quantity<span class="token punctuation">,</span> io<span class="token punctuation">.</span>item_price<span class="token keyword">FROM</span> customers <span class="token keyword">AS</span> c<span class="token punctuation">,</span> orders <span class="token keyword">AS</span> o<span class="token punctuation">,</span> orderitems <span class="token keyword">AS</span> io<span class="token keyword">WHERE</span> c<span class="token punctuation">.</span>cust_id <span class="token operator">=</span> o<span class="token punctuation">.</span>cust_id  <span class="token operator">AND</span> io<span class="token punctuation">.</span>order_num <span class="token operator">=</span> o<span class="token punctuation">.</span>order_num  <span class="token operator">AND</span> prod_id <span class="token operator">=</span> <span class="token string">'FB'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>外部联结在结果中包含了那些在另一个表中没有关联行的行。</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> customers<span class="token punctuation">.</span>cust_id<span class="token punctuation">,</span> orders<span class="token punctuation">.</span>order_num<span class="token keyword">FROM</span> customers<span class="token keyword">LEFT</span> <span class="token keyword">OUTER</span> <span class="token keyword">JOIN</span> orders<span class="token keyword">ON</span> customers<span class="token punctuation">.</span>cust_id <span class="token operator">=</span> orders<span class="token punctuation">.</span>cust_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表）。上面的例子使用LEFT OUTER JOIN从FROM子句的左边表（customers表）中选择所有行。为了从右边的表中选择所有行，应该使用RIGHT OUTER JOIN。</li></ol><h2 id="第17章-组合查询"><a href="#第17章-组合查询" class="headerlink" title="第17章 组合查询"></a>第17章 组合查询</h2><ol><li><p>MySQL允许执行多个查询（多条SELECT语句），并将结果作为单个查询结果集返回。这些组合查询通常称为 <strong>并（union）</strong> 或 <strong>复合查询（compound query）</strong> 。</p></li><li><p>使用UNION规则时需要遵循的规则：</p><ol><li>UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔（因此，如果组合4条SELECT语句，将要使用3个UNION关键字）。</li><li>UNION中的每个查询必须包含相同的列、表达式或聚集函数（不过各个列不需要以相同的次序列出）。</li><li>列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型（例如，不同的数值类型或不同的日期类型）。</li></ol></li><li><p>UNION从查询结果集中自动去除了重复的行（换句话说，它的行为与单条SELECT语句中使用多个WHERE子句条件一样）。这是UNION的默认行为，如果想返回所有匹配行，可使用UNION ALL而不是UNION。</p></li><li><p>在用UNION组合查询时，只能使用一条ORDER BY子句，它必须出现在最后一条SELECT语句之后。</p></li></ol><h2 id="第18章-全文本搜索"><a href="#第18章-全文本搜索" class="headerlink" title="第18章 全文本搜索"></a>第18章 全文本搜索</h2><ol><li><p>MyISAM支持全文本搜索，InnoDB不支持。</p></li><li><p>为了进行全文本搜索，必须索引被搜索的列。一般在创建表时使用FULLTEXT启用全文本搜索。</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> productnotes<span class="token punctuation">(</span>    note_id     <span class="token keyword">INT</span>         <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    prod_id     <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>    <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    note_date   <span class="token keyword">DATETIME</span>    <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    note_text   <span class="token keyword">TEXT</span>        <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>note_id<span class="token punctuation">)</span><span class="token punctuation">,</span>    FULLTEXT<span class="token punctuation">(</span>note_text<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span>MyISAM<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>不要在导入数据时使用FULLTEXT。应该首先导入所有数据，然后再修改表，定义FULLTEXT。</p></blockquote></li><li><p>使用两个函数Match()和Against()执行全文本搜索，其中Match()指定被搜索的列，Against()指定要使用的搜索表达式。</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> note_text<span class="token keyword">FROM</span> productnotes<span class="token keyword">WHERE</span> <span class="token keyword">MATCH</span><span class="token punctuation">(</span>note_text<span class="token punctuation">)</span> AGAINST<span class="token punctuation">(</span><span class="token string">'rabbit'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>传递给Match()的值必须与FULLTEXT()定义中的相同。如果指定多个列，则必须列出它们（而且次序正确）。</p><p>搜索不区分大小写，除非使用BINARY方式，否则全文本搜索不区分大小写。</p></blockquote></li><li><p>也是使用LIKE子句进行搜索。</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> note_text<span class="token keyword">FROM</span> productnotes<span class="token keyword">WHERE</span> note_text <span class="token operator">LIKE</span> <span class="token string">'%rabbit%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>使用LIKE子句进行搜索时，不会对结果进行排序。而使用函数Match()和Against()执行全文本搜索时，会对结果进行排序，具有较高等级的行先返回。等级可以通过下面的方式获取：</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> note_text<span class="token punctuation">,</span> <span class="token keyword">MATCH</span><span class="token punctuation">(</span>note_text<span class="token punctuation">)</span> AGAINST<span class="token punctuation">(</span><span class="token string">'rabbit'</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token string">'rank'</span><span class="token keyword">FROM</span> productnotes<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>在使用 <strong>查询扩展</strong> 时，MySQL对数据和索引进行两遍扫描来完成搜索：</p><ol><li>进行一个基本的全文本搜索，找出与搜索条件匹配的所有行；</li><li>MySQL检查这些匹配行并选择所有有用的词；</li><li><p>MySQL再次进行全文本搜索，这次不仅使用原来的条件，而且还使用所有有用的词。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> note_text<span class="token keyword">FROM</span> productnotes<span class="token keyword">WHERE</span> <span class="token keyword">MATCH</span><span class="token punctuation">(</span>note_text<span class="token punctuation">)</span> AGAINST<span class="token punctuation">(</span><span class="token string">'anvils'</span> <span class="token keyword">WITH</span> QUERY EXPANSION<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol></li><li><p>即使没有FULLTEXT索引也可以使用 <strong>布尔文本搜索</strong> ，但这是一种非常缓慢的操作。</p><blockquote><p><strong>排列而不排序</strong> 在布尔方式中，不按等级值降序排序返回的</p></blockquote></li><li><p>全文本搜索的使用说明</p><ol><li>在索引全文本数据时，短词被忽略且从索引中排除。短词定义为那些具有3个或3个以下字符的词（如果需要，这个数目可以更改）。</li><li>MySQL带有一个内建的非用词（stopword）列表，这些词在索引全文本数据时总是被忽略。如果需要，可以覆盖这个列表。</li><li>许多词出现的频率很高，搜索它们没有用处（返回太多的结果）。因此，MySQL规定了一条50%规则，如果一个词出现在50%以上的行中，则将它作为一个非用词忽略。50%规则不用于IN BOOLEANMODE。</li><li>如果表中的行数少于3行，则全文本搜索不返回结果（因为每个词或者不出现，或者至少出现在50%的行中）。</li><li>忽略词中的单引号。例如，don’t索引为dont。</li><li>不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文本搜索结果。</li><li><p>如前所述，仅在MyISAM数据库引擎中支持全文本搜索。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'ft%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol></li><li><p>一些例子</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> note_text<span class="token keyword">FROM</span> productnotes<span class="token keyword">WHERE</span> <span class="token keyword">MATCH</span><span class="token punctuation">(</span>note_text<span class="token punctuation">)</span> AGAINST<span class="token punctuation">(</span><span class="token string">'+rabbit +bait'</span> <span class="token operator">IN</span> <span class="token keyword">BOOLEAN</span> <span class="token keyword">MODE</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 匹配词rabbit和bait */</span><span class="token keyword">SELECT</span> note_text<span class="token keyword">FROM</span> productnotes<span class="token keyword">WHERE</span> <span class="token keyword">MATCH</span><span class="token punctuation">(</span>note_text<span class="token punctuation">)</span> AGAINST<span class="token punctuation">(</span><span class="token string">'rabbit bait'</span> <span class="token operator">IN</span> <span class="token keyword">BOOLEAN</span> <span class="token keyword">MODE</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 匹配词rabbit或bait */</span><span class="token keyword">SELECT</span> note_text<span class="token keyword">FROM</span> productnotes<span class="token keyword">WHERE</span> <span class="token keyword">MATCH</span><span class="token punctuation">(</span>note_text<span class="token punctuation">)</span> AGAINST<span class="token punctuation">(</span><span class="token string">'"rabbit bait"'</span> <span class="token operator">IN</span> <span class="token keyword">BOOLEAN</span> <span class="token keyword">MODE</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 匹配短语"rabbit bait" */</span><span class="token keyword">SELECT</span> note_text<span class="token keyword">FROM</span> productnotes<span class="token keyword">WHERE</span> <span class="token keyword">MATCH</span><span class="token punctuation">(</span>note_text<span class="token punctuation">)</span> AGAINST<span class="token punctuation">(</span><span class="token string">'&gt;rabbit &lt;bait'</span> <span class="token operator">IN</span> <span class="token keyword">BOOLEAN</span> <span class="token keyword">MODE</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 匹配词rabbit和bait，增加前者的等级，降低后者的等级 */</span><span class="token keyword">SELECT</span> note_text<span class="token keyword">FROM</span> productnotes<span class="token keyword">WHERE</span> <span class="token keyword">MATCH</span><span class="token punctuation">(</span>note_text<span class="token punctuation">)</span> AGAINST<span class="token punctuation">(</span><span class="token string">'+rabbit +(&lt;bait)'</span> <span class="token operator">IN</span> <span class="token keyword">BOOLEAN</span> <span class="token keyword">MODE</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 匹配词rabbit和bait，降低后者的等级 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>全文本布尔操作符</li></ol><div class="table-container"><table><thead><tr><th><strong>布尔操作符</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>+</td><td>包含，词必须存在</td></tr><tr><td>-</td><td>排除，词必须不出现</td></tr><tr><td>&gt;</td><td>包含，而且增加等级值</td></tr><tr><td>&lt;</td><td>包含，且减少等级值</td></tr><tr><td>()</td><td>把词组成子表达式（允许这些子表达式作为一个组被包含、排除、排列等）</td></tr><tr><td>~</td><td>取消一个词的排序值</td></tr><tr><td>*</td><td>词尾的通配符</td></tr><tr><td>“”</td><td>定义一个短语（与单个词的列表不一样，它匹配整个短语以便包含或排除这个短语）</td></tr></tbody></table></div><h2 id="第19章-插入数据"><a href="#第19章-插入数据" class="headerlink" title="第19章 插入数据"></a>第19章 插入数据</h2><ol><li><p>如果表的定义允许，则可以在INSERT操作中省略某些列：</p><ol><li>该列定义为允许NULL值（无值或空值）。</li><li>在表定义中给出默认值。这表示如果不给出值，将使用默认值。</li></ol></li><li><p>可以通过在INSERT和INTO之间添加关键字LOW_PRIORITY，指示MySQL降低INSERT语句的优先级：</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> LOW_PRIORITY <span class="token keyword">INTO</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>同样适用于UPDATE和DELETE。</p></blockquote></li><li><p>一些例子：</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">/* 一次插入一条记录 */</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> customers <span class="token punctuation">(</span>cust_name<span class="token punctuation">,</span> cust_address<span class="token punctuation">)</span><span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 一次插入多条记录 */</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> customers <span class="token punctuation">(</span>cust_name<span class="token punctuation">,</span> cust_address<span class="token punctuation">)</span><span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">)</span><span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 插入检索出的数据 */</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> customers <span class="token punctuation">(</span>cust_name<span class="token punctuation">,</span> cust_address<span class="token punctuation">)</span><span class="token keyword">SELECT</span> cust_name<span class="token punctuation">,</span> cust_address<span class="token keyword">FROM</span> customers_new<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>INSERT SELECT中不要求列名匹配。MySQL使用的是列的位置，因此SELECT中的第一列（不管其列名）将用来填充表列中指定的第一个列，第二列将用来填充表列中指定的第二个列，如此等等。</p></blockquote></li></ol><h2 id="第20章-更新和删除数据"><a href="#第20章-更新和删除数据" class="headerlink" title="第20章 更新和删除数据"></a>第20章 更新和删除数据</h2><ol><li><p>如果用UPDATE语句更新多行，并且在更新这些行中的一行或多行时出一个现错误，则整个UPDATE操作被取消（错误发生前更新的所有行被恢复到它们原来的值）。为即使是发生错误，也继续进行更新，可使用IGNORE关键字，如下所示：</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> <span class="token keyword">IGNORE</span> customers<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>如果想从表中删除所有行，不要使用DELETE。可使用TRUNCATE TABLE语句，它完成相同的工作，但速度更快（TRUNCATE实际是删除原来的表并重新创建一个表，而不是逐行删除表中的数据）。</li></ol><h2 id="第21章-创建和操纵表"><a href="#第21章-创建和操纵表" class="headerlink" title="第21章 创建和操纵表"></a>第21章 创建和操纵表</h2><ol><li><p>主键值必须唯一。即，表中的每个行必须具有唯一的主键值。如果主键使用单个列，则它的值必须唯一。如果使用多个列，则这些列的组合值必须唯一。</p></li><li><p><strong>函数last_insert_id()</strong> 返回最后一个AUTO_INCREMENT值。</p></li><li><p>外键不能跨引擎。</p></li><li><p>一些例子：</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> productnotes<span class="token punctuation">(</span>    note_id     <span class="token keyword">INT</span>         <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    prod_id     <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>    <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    note_date   <span class="token keyword">DATETIME</span>    <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    note_text   <span class="token keyword">TEXT</span>        <span class="token boolean">NULL</span><span class="token punctuation">,</span>    update_cnt  <span class="token keyword">INT</span>         <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>note_id<span class="token punctuation">,</span> prod_id<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span>MyISAM<span class="token punctuation">;</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> Vendors<span class="token keyword">DROP</span> <span class="token keyword">COLUMN</span> vend_phone<span class="token punctuation">;</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> orderitems<span class="token keyword">ADD</span> <span class="token keyword">CONSTRAINT</span> fk_orderitems_orders<span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>order_num<span class="token punctuation">)</span><span class="token keyword">REFERENCES</span> orders <span class="token punctuation">(</span>order_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> customers2<span class="token punctuation">;</span><span class="token keyword">RENAME</span> <span class="token keyword">TABLE</span> customers2 <span class="token keyword">TO</span> customers<span class="token punctuation">;</span><span class="token keyword">RENAME</span> <span class="token keyword">TABLE</span> customers <span class="token keyword">TO</span> customers_backup<span class="token punctuation">,</span> vendors <span class="token keyword">TO</span> vendors_backup<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="第22章-使用视图"><a href="#第22章-使用视图" class="headerlink" title="第22章 使用视图"></a>第22章 使用视图</h2><ol><li><p>视图仅仅是用来查看存储在别处的数据的一种设施。视图本身不包含数据，因此它们返回的数据是从其他表中检索出来的。</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> customeremaillist <span class="token keyword">AS</span><span class="token keyword">SELECT</span> cust_id<span class="token punctuation">,</span> cust_name<span class="token punctuation">,</span> cust_email<span class="token keyword">FROM</span> customers<span class="token keyword">WHERE</span> cust_email <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>视图的规则和限制</p><ol><li>与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字）。</li><li>对于可以创建的视图数目没有限制。</li><li>为了创建视图，必须具有足够的访问权限。</li><li>视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图。</li><li>ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖。</li><li>视图不能索引，也不能有关联的触发器或默认值。</li><li>视图可以和表一起使用。</li></ol></li><li><p>使用视图</p><ol><li>视图用CREATE VIEW语句来创建。</li><li>使用SHOW CREATE VIEW viewname；来查看创建视图的语句。</li><li>用DROP删除视图，其语法为DROP VIEW viewname。</li><li>更新视图时，可以先用DROP再用CREATE，也可以直接用CREATE OR REPLACE VIEW。如果要更新的视图不存在，则第2条更新语句会创建一个视图；如果要更新的视图存在，则第2条更新语句会替换原有视图。</li></ol></li><li><p>视图是可更新的（即，可以对它们使用INSERT、UPDATE和DELETE）。更新一个视图将更新其基表（可以回忆一下，视图本身没有数据）。如果你对视图增加或删除行，实际上是对其基表增加或删除行。</p></li><li><p>并非所有视图都是可更新的。基本上可以说，如果MySQL不能正确地确定被更新的基数据，则不允许更新（包括插入和删除）。这实际上意味着，如果视图定义中有以下操作，则不能进行视图的更新：</p><ol><li>分组（使用GROUP BY和HAVING）；</li><li>联结；</li><li>子查询；</li><li>并；</li><li>聚集函数（Min()、Count()、Sum()等）；</li><li>DISTINCT；</li><li>导出（计算）列。</li></ol></li></ol><h2 id="第23章-使用存储过程"><a href="#第23章-使用存储过程" class="headerlink" title="第23章 使用存储过程"></a>第23章 使用存储过程</h2><ol><li><p>执行存储过程</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CALL</span> productpricing<span class="token punctuation">(</span><span class="token variable">@pricelow</span><span class="token punctuation">,</span> <span class="token variable">@pricehigh</span><span class="token punctuation">,</span> <span class="token variable">@priceaverage</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>创建存储过程</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- Name: ordertotal</span><span class="token comment">-- Parameters: onumber = order number</span><span class="token comment">--             taxable = 0 if not taxable, 1 if taxable</span><span class="token comment">--             ototal  = order total variable</span><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> ordertotal<span class="token punctuation">(</span>    <span class="token operator">IN</span>  onumber <span class="token keyword">INT</span><span class="token punctuation">,</span>    <span class="token operator">IN</span>  taxable <span class="token keyword">BOOLEAN</span><span class="token punctuation">,</span>    <span class="token keyword">OUT</span> ototal <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">COMMENT</span> <span class="token string">'Obtain order total, optionally adding tax'</span><span class="token keyword">BEGIN</span>    <span class="token comment">--Declare variable for total</span>    <span class="token keyword">DECLARE</span> total <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">--Declare tax percentage</span>    <span class="token keyword">DECLARE</span> taxrate <span class="token keyword">INT</span> <span class="token keyword">DEFAULT</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token comment">--GET the order total</span>    <span class="token keyword">SELECT</span> <span class="token function">Sum</span><span class="token punctuation">(</span>item_price<span class="token operator">*</span>quantity<span class="token punctuation">)</span>    <span class="token keyword">FROM</span> orderitems    <span class="token keyword">WHERE</span> order_num <span class="token operator">=</span> onumber    <span class="token keyword">INTO</span> total<span class="token punctuation">;</span>    <span class="token comment">--Is this taxable</span>    <span class="token keyword">IF</span> taxable <span class="token keyword">THEN</span>        <span class="token keyword">SELECT</span> total<span class="token operator">+</span><span class="token punctuation">(</span>total<span class="token operator">/</span><span class="token number">100</span><span class="token operator">*</span>taxrate<span class="token punctuation">)</span> <span class="token keyword">INTO</span> total<span class="token punctuation">;</span>    <span class="token keyword">END</span> <span class="token keyword">IF</span><span class="token punctuation">;</span>    <span class="token keyword">SELECT</span> total <span class="token keyword">INTO</span> ototal<span class="token punctuation">;</span><span class="token keyword">END</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>COMMENT的值会在<code>SHOW PROCEDURE STATUS</code>时显示出来。</p></blockquote></li><li><p>删除存储过程</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">PROCEDURE</span> ordertotal<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>检查存储过程</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SHOW</span> <span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> ordertotal<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>为了获得包括何时、由谁创建等详细信息的存储过程列表，使用<code>SHOW PROCEDURE STATUS</code> 或<code>SHOW PROCEDURE STATUS LIKE 'ordertotal'</code>。</p></blockquote></li><li><p>使用mysql命令行实用程序时需要注意：</p><p> 默认的MySQL语句分隔符为<code>;</code> mysql命令行实用程序也使用<code>;</code>作为语句分隔符。如果命令行实用程序要解释存储过程自身内的;字符，则它们最终不会成为存储过程的成分，这会使存储过程中的SQL出现句法错误。<br> 解决办法是临时更改命令行实用程序的语句分隔符，如下所示：</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DELIMITER</span> <span class="token comment">//</span><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> productpricing<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">BEGIN</span>    <span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>prod_price<span class="token punctuation">)</span> <span class="token keyword">AS</span> priceaverage    <span class="token keyword">FROM</span> products<span class="token punctuation">;</span><span class="token keyword">END</span> <span class="token comment">//</span><span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>除<code>\</code>符号外，任何字符都可以用作语句分隔符。</p></blockquote></li></ol><h2 id="第24章-使用游标"><a href="#第24章-使用游标" class="headerlink" title="第24章 使用游标"></a>第24章 使用游标</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> processorders <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">BEGIN</span>    <span class="token comment">-- Declare local variables</span>    <span class="token keyword">DECLARE</span> done <span class="token keyword">TINYINT</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">DECLARE</span> o <span class="token keyword">INT</span><span class="token punctuation">;</span>    <span class="token keyword">DECLARE</span> t <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">-- Declare the cursor</span>    <span class="token keyword">DECLARE</span> ordernumbers <span class="token keyword">CURSOR</span> <span class="token keyword">FOR</span>    <span class="token keyword">SELECT</span> order_num <span class="token keyword">FROM</span> orders<span class="token punctuation">;</span>    <span class="token comment">-- Declare continue handler</span>    <span class="token keyword">DECLARE</span> <span class="token keyword">CONTINUE</span> <span class="token keyword">HANDLER</span> <span class="token keyword">FOR</span> SQLSTATE <span class="token string">'02000'</span> <span class="token keyword">SET</span> done<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">-- Create a table to store the results</span>    <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> ordertotals<span class="token punctuation">(</span>        order_num <span class="token keyword">INT</span><span class="token punctuation">,</span>        total <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">-- Open the cursor</span>    <span class="token keyword">OPEN</span> ordernumbers<span class="token punctuation">;</span>    <span class="token comment">-- Loop through all rows</span>    <span class="token keyword">REPEAT</span>        <span class="token comment">-- Get order number</span>        <span class="token keyword">FETCH</span> ordernumbers <span class="token keyword">INTO</span> o<span class="token punctuation">;</span>        <span class="token comment">-- Get the total for this order</span>        <span class="token keyword">CALL</span> ordertotalmye<span class="token punctuation">(</span>o<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">-- Insert order and total into ordertotals</span>        <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> ordertotals<span class="token punctuation">(</span>order_num<span class="token punctuation">,</span>total<span class="token punctuation">)</span>        <span class="token keyword">VALUES</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">-- End of loop</span>    UNTIL done <span class="token keyword">END</span> <span class="token keyword">REPEAT</span><span class="token punctuation">;</span>    <span class="token comment">-- Close the cursor</span>    <span class="token keyword">CLOSE</span> ordernumbers<span class="token punctuation">;</span><span class="token keyword">END</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第25章-使用触发器"><a href="#第25章-使用触发器" class="headerlink" title="第25章 使用触发器"></a>第25章 使用触发器</h2><ol><li><p>触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（或位于 BEGIN 和 END 语句之间的一组语 句）：</p><ol><li>DELETE；</li><li>INSERT；</li><li>UPDATE。</li></ol></li><li><p>在创建触发器时，需要给出4条信息：</p><ol><li>唯一的触发器名；</li><li>触发器关联的表；</li><li>触发器应该响应的活动（DELETE、INSERT或UPDATE）；</li><li><p>触发器何时执行（处理之前或之后）。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> newproduct<span class="token keyword">AFTER</span> <span class="token keyword">INSERT</span> <span class="token keyword">ON</span> products<span class="token keyword">FOR EACH ROW</span> <span class="token keyword">SELECT</span> <span class="token string">'Product added'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>只有表才支持触发器，视图不支持（临时表也不支持）。</p></blockquote></li></ol></li><li><p>触发器按每个表每个事件每次地定义，每个表每个事件每次只允许一个触发器。因此，每个表最多支持6个触发器（每条INSERT、UPDATE 和DELETE的之前和之后）。</p><blockquote><p>如果BEFORE触发器失败，则MySQL将不执行请求的操作。此外，如果BEFORE触发器或语句本身失败，MySQL 将不执行AFTER触发器（如果有的话）。</p></blockquote></li><li><p>删除触发器</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TRIGGER</span> newproduct<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>触发器不能更新或覆盖。为了修改一个触发器，必须先删除它， 然后再重新创建。</p></blockquote></li><li><p>INSERT触发器在INSERT语句执行之前或之后执行。需要知道以下几点：</p><ol><li>在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被插入的行；</li><li>在BEFORE INSERT触发器中，NEW中的值也可以被更新（允许更改被插入的值）；</li><li><p>对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT执行之后包含新的自动生成值。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> neworder<span class="token keyword">AFTER</span> <span class="token keyword">INSERT</span> <span class="token keyword">ON</span> orders<span class="token keyword">FOR EACH ROW</span> <span class="token keyword">SELECT</span> NEW<span class="token punctuation">.</span>order_new<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol></li><li><p>DELETE触发器在DELETE语句执行之前或之后执行。需要知道以下两点：</p><ol><li>在DELETE触发器代码内，你可以引用一个名为OLD的虚拟表，访问被删除的行；</li><li><p>OLD中的值全都是只读的，不能更新。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> deleteorderBEFORE <span class="token keyword">DELETE</span> <span class="token keyword">ON</span> orders<span class="token keyword">FOR EACH ROW</span><span class="token keyword">BEGIN</span>    <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> archive_orders<span class="token punctuation">(</span>order_num<span class="token punctuation">,</span> order_date<span class="token punctuation">,</span> cust_id<span class="token punctuation">)</span>    <span class="token keyword">VALUE</span><span class="token punctuation">(</span>OLD<span class="token punctuation">.</span>order_num<span class="token punctuation">,</span> OLD<span class="token punctuation">.</span>order_date<span class="token punctuation">,</span> OLD<span class="token punctuation">.</span>cust_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">END</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol></li><li><p>UPDATE触发器在UPDATE语句执行之前或之后执行。需要知道以下几点：</p><ol><li>在UPDATE触发器代码中，你可以引用一个名为OLD的虚拟表访问以前（UPDATE语句前）的值，引用一个名为NEW的虚拟表访问新更新的值；</li><li>在BEFORE UPDATE触发器中，NEW中的值可能也被更新（允许更改将要用于UPDATE语句中的值）；</li><li><p>OLD中的值全都是只读的，不能更新。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> updatevendorBEFORE <span class="token keyword">UPDATE</span> <span class="token keyword">ON</span> vendors<span class="token keyword">FOR EACH ROW</span> <span class="token keyword">SET</span> NEW<span class="token punctuation">.</span>vend_state <span class="token operator">=</span> UPPER<span class="token punctuation">(</span>NEW<span class="token punctuation">.</span>vend_state<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol></li><li>MySQL触发器中不支持CALL语句。这表示不能从触发器内调用存储过程。</li></ol><h2 id="第26章-管理事务处理"><a href="#第26章-管理事务处理" class="headerlink" title="第26章 管理事务处理"></a>第26章 管理事务处理</h2><ol><li><p>事务处理（transaction processing）可以用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行。</p><blockquote><p> MyISAM和InnoDB是两种最常使用的引擎。前者不支持明确的事务处理管理，而后者支持。</p></blockquote></li><li><p>相关术语：</p><ol><li><strong>事务（transaction）</strong> 指一组SQL语句；</li><li><strong>回退（rollback）</strong> 指撤销指定SQL语句的过程；</li><li><strong>提交（commit）</strong> 指将未存储的SQL语句结果写入数据库表；</li><li><strong>保留点（ savepoint ）</strong> 指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。</li></ol></li><li><p>开始事务</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>回退事务</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> ordertotals<span class="token punctuation">;</span><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> ordertotals<span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> ordertotals<span class="token punctuation">;</span><span class="token keyword">ROLLBACK</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> ordertotals<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>事务处理用来管理INSERT、UPDATE和DELETE语句。你不能回退SELECT语句，也 <strong>不能回退CREATE或DROP操作</strong> 。事务处理块中可以使用这两条语句，但如果你执行回退，它们不会被撤销。</p></blockquote></li><li><p>提交事务</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> orderitems <span class="token keyword">WHERE</span> order_num <span class="token operator">=</span> <span class="token number">20010</span><span class="token punctuation">;</span><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> orders <span class="token keyword">WHERE</span> order_num <span class="token operator">=</span> <span class="token number">20010</span><span class="token punctuation">;</span><span class="token keyword">COMMIT</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>当COMMIT或ROLLBACK语句执行后，事务会自动关闭（将来的更改会隐含提交）。</p></blockquote></li><li><p>为了支持回退部分事务处理，必须能在事务处理块中合适的位置放 置保留点。这样，如果需要回退，可以回退到某个保留点。</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SAVEPOINT</span> delete1<span class="token punctuation">;</span> <span class="token comment">/* 创建保留点 */</span><span class="token keyword">ROLLBACK</span> <span class="token keyword">TO</span> delete1<span class="token punctuation">;</span> <span class="token comment">/* 回退到保留点 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>保留点越多，就越能按自己的意愿灵活地进行回退，所以保留点越多越好。</p><p>保留点在事务处理完成（执行一条ROLLBACK或 COMMIT）后自动释放。也可以用RELEASE SAVEPOINT明确地释放保留点。</p></blockquote></li><li><p>默认的MySQL行为是自动提交所有更改。可以关闭：</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SET</span> AUTOCOMMIT<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>autocommit标志决定是否自动提交更改，不管有没有COMMIT 语句。设置autocommit为0（假）指示MySQL不自动提交更改 （直到autocommit被设置为真为止）。</p><p>autocommit标志是针对每个连接而不是服务器的。</p></blockquote></li></ol><h2 id="第27章-全球化和本地化"><a href="#第27章-全球化和本地化" class="headerlink" title="第27章 全球化和本地化"></a>第27章 全球化和本地化</h2><ol><li><p>重要术语：</p><ol><li><strong>字符集</strong> 为字母和符号的集合；</li><li><strong>编码</strong> 为某个字符集成员的内部表示；</li><li><strong>校对</strong> 为规定字符如何比较的指令。</li></ol></li><li><p>查看所支持的字符集完整列表</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SHOW</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查看所支持校对的完整列表</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SHOW</span> COLLATION<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>许多校对出现两次，一次区分大小写（由_cs表一次不区分大小写（由_ci表示）。</p></blockquote></li><li><p>通常系统管理在安装时定义一个默认的字符集和校对。</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'character%'</span><span class="token punctuation">;</span><span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'collation%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>可以在创建数据库时，指定默认的字符集和校对。</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> mytable<span class="token punctuation">(</span>    c1 <span class="token keyword">INT</span><span class="token punctuation">,</span>    c2 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> hebrew  <span class="token keyword">COLLATE</span> hebrew_general_ci<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>一般，MySQL如下确定使用什么样的字符集和校对：</p><ol><li>如果指定CHARACTER SET和COLLATE两者，则使用这些值。</li><li>如果只指定CHARACTER SET，则使用此字符集及其默认的校对（如SHOW CHARACTER SET的结果中所示）。</li><li>如果既不指定CHARACTER SET，也不指定COLLATE，则使用数据库默认。</li></ol></li><li><p>MySQL还允许对每个列设置：</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> mytable<span class="token punctuation">(</span>    c1 <span class="token keyword">INT</span><span class="token punctuation">,</span>    c2 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> latin1 <span class="token keyword">COLLATE</span> latin1_general_ci<span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> hebrew  <span class="token keyword">COLLATE</span> hebrew_general_ci<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>校对在对用ORDER BY子句检索出来的数据排序时起重要的作用。如果你需要用与创建表时不同的校对顺序排序特定的SELECT语句，可以在SELECT语句自身中进行：</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> customers<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> lastname<span class="token punctuation">,</span> firstname <span class="token keyword">COLLATE</span> latin1_general_cs<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>除了ORDER BY子句，COLLATE还可以用于GROUP BY、HAVING、聚集函数、别名等。</p></blockquote></li><li><p>如果绝对需要，串可以在字符集之间进行转换。为此，使用Cast()或Convert()函数。</p></li></ol><h2 id="第28章-安全管理"><a href="#第28章-安全管理" class="headerlink" title="第28章 安全管理"></a>第28章 安全管理</h2><ol><li><p>创建用户账号</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">USER</span> ben IDENTIFIED <span class="token keyword">BY</span> <span class="token string">'123'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>重命名用户账号</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">RENAME</span> <span class="token keyword">USER</span> ben <span class="token keyword">TO</span> kom<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>删除用户账号</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">USER</span> kom<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>在创建用户账号后，必须接着分配访问权限。新创建的用户账号没有访问权限。它们能登录MySQL，但不能看到数据，不能执行任何数据库操作。查看用户账号权限：</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SHOW</span> GRANTS <span class="token keyword">FOR</span> kom<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><strong>用户定义为user@host。</strong> MySQL的权限用用户名和主机名结合定义。如果不指定主机名，则使用默认的主机名%（授予用户访问权限而不管主机名）。</p></blockquote></li><li><p>为设置权限，使用GRANT语句。GRANT要求你至少给出以下信息：</p><ol><li>要授予的权限；</li><li>被授予访问权限的数据库或表；</li><li><p>用户名。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">GRANT</span> <span class="token keyword">SELECT</span> <span class="token keyword">ON</span> crashcourse<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">TO</span> kom<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol></li><li><p>撤销特定的权限使用REVOKE：</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">REVOKE</span> <span class="token keyword">SELECT</span> <span class="token keyword">ON</span> crashcourse<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">FROM</span> kom<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>GRANT和REVOKE可在几个层次上控制访问权限：</p><ol><li>整个服务器，使用GRANT ALL和REVOKE ALL；</li><li>整个数据库，使用ON database.*；</li><li>特定的表，使用ON database.table；</li><li>特定的列；</li><li>特定的存储过程。</li></ol></li><li><p>更改密码</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SET</span> PASSWORD <span class="token keyword">FOR</span> kom <span class="token operator">=</span> PASSWORD<span class="token punctuation">(</span><span class="token string">'456'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>不指定用户名时，SET PASSWORD更新当前登录用户的口令。<code>SET PASSWORD = PASSWORD('789')</code></p></blockquote></li><li><p>在使用GRANT和REVOKE时，用户账号必须存在，但对所涉及的对象没有这个要求。这允许管理员在创建数据库和表之前设计和实现安全措施。这样做的副作用是，当某个数据库或表被删除时（用DROP语句），相关的访问权限仍然存在。而且，如果将来重新创建该数据库或表，这些权限仍然起作用。</p></li><li><p>可通过列出各权限并用逗号分隔， 将多条GRANT语句串在一起。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">GRANT SELECT, INSERT ON crashcourse.* TO kom<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>权限列表</li></ol><div class="table-container"><table><thead><tr><th><strong>权限</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>ALL</td><td>除GRANT OPTION外的所有权限</td></tr><tr><td>ALTER</td><td>使用ALTER TABLE</td></tr><tr><td>ALTER ROUTINE</td><td>使用ALTER PROCEDURE和DROP PROCEDURE</td></tr><tr><td>CREATE</td><td>使用CREATE TABLE</td></tr><tr><td>CREATE ROUTINE</td><td>使用CREATE PROCEDURE</td></tr><tr><td>CREATE TEMPORARY TABLES</td><td>使用CREATE TEMPORARY TABLE</td></tr><tr><td>CREATE USER</td><td>使用CREATE USER、DROP USER、RENAME USER和REVOKE ALL PRIVILEGES</td></tr><tr><td>CREATE VIEW</td><td>使用CREATE VIEW</td></tr><tr><td>DELETE</td><td>使用DELETE</td></tr><tr><td>DROP</td><td>使用DROP TABLE</td></tr><tr><td>EXECUTE</td><td>使用CALL和存储过程</td></tr><tr><td>FILE</td><td>使用SELECT INTO OUTFILE和LOAD DATA INFILE</td></tr><tr><td>GRANT OPTION</td><td>使用GRANT和REVOKE</td></tr><tr><td>INDEX</td><td>使用CREATE INDEX和DROP INDEX</td></tr><tr><td>INSERT</td><td>使用INSERT</td></tr><tr><td>LOCK TABLES</td><td>使用LOCK TABLES</td></tr><tr><td>PROCESS</td><td>使用SHOW FULL PROCESSLIST</td></tr><tr><td>RELOAD</td><td>使用FLUSH</td></tr><tr><td>REPLICATION CLIENT</td><td>服务器位置的访问</td></tr><tr><td>REPLICATION SLAVE</td><td>由复制从属使用</td></tr><tr><td>SELECT</td><td>使用SELECT</td></tr><tr><td>SHOW DATABASES</td><td>使用SHOW DATABASES</td></tr><tr><td>SHOW VIEW</td><td>使用SHOW CREATE VIEW</td></tr><tr><td>SHUTDOWN</td><td>使用mysqladmin shutdown（用来关闭MySQL）</td></tr><tr><td>SUPER</td><td>使用CHANGE MASTER、KILL、LOGS、PURGE、MASTER 和SET GLOBAL。还允许mysqladmin调试登录</td></tr><tr><td>UPDATE</td><td>使用UPDATE</td></tr><tr><td>USAGE</td><td>无访问权限</td></tr></tbody></table></div><h2 id="第29章-数据库维护"><a href="#第29章-数据库维护" class="headerlink" title="第29章 数据库维护"></a>第29章 数据库维护</h2><ol><li><p>备份数据</p><ol><li>使用命令行实用程序mysqldump转储所有数据库内容到某个外部文件。在进行常规备份前这个实用程序应该正常运行，以便能正确地备份转储文件。</li><li>可用命令行实用程序 mysqlhotcopy 从一个数据库复制所有数据 （并非所有数据库引擎都支持这个实用程序）。</li><li><p>可以使用MySQL的BACKUP TABLE或SELECT INTO OUTFILE转储所有数据到某个外部文件。这两条语句都接受将要创建的系统文件名，此系统文件必须不存在，否则会出错。数据可以用RESTORE TABLE来复原。</p><blockquote><p>为了保证所有数据被写到磁盘（包括索引数据）可能需要在进行备份前使用FLUSH TABLES语句。</p></blockquote></li></ol></li><li><p>进行数据库维护</p><ol><li><p>检查表键是否正确</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ANALYZE</span> <span class="token keyword">TABLE</span> orders<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>CHECK TABLE用来针对许多问题对表进行检查。在MyISAM表上还对索引进行检查。CHECK TABLE支持一系列的用于MyISAM表的方式。 CHANGED检查自最后一次检查以来改动过的表。EXTENDED执行最彻底的检查，FAST只检查未正常关闭的表，MEDIUM检查所有被删除的链接并进行键检验，QUICK只进行快速扫描。</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CHECK</span> <span class="token keyword">TABLE</span> orders<span class="token punctuation">,</span> orderitems FAST <span class="token keyword">QUICK</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>如果 MyISAM 表访问产生不正确和不一致的结果，可能需要用REPAIR TABLE来修复相应的表。这条语句不应该经常使用，如果需要经常使用，可能会有更大的问题要解决。</p><p>如果从一个表中删除大量数据，应该使用OPTIMIZE TABLE来收回所用的空间，从而优化表的性能。</p></blockquote></li></ol></li></ol><h2 id="第30章-改善性能"><a href="#第30章-改善性能" class="headerlink" title="第30章 改善性能"></a>第30章 改善性能</h2><ol><li>可使用<code>SHOW PROCESSLIST</code> 显示所有活动进程（以及它们的线程ID和执行时间）。可以用KILL命令终结某个特定的进程（使用这个命令需要作为管理员登录）。</li><li>使用EXPLAIN语句让MySQL解释它将如何执行一条SELECT语句。</li><li>一般来说，存储过程执行得比一条一条地执行其中的各条MySQL 语句快。</li><li>有的操作（包括INSERT）支持一个可选的DELAYED关键字，如果使用它，将把控制立即返回给调用程序，并且一旦有可能就实际执行该操作。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习中的策略梯度与baseline</title>
      <link href="qiang-hua-xue-xi-zhong-de-ce-lue-ti-du-yu-baseline/"/>
      <url>qiang-hua-xue-xi-zhong-de-ce-lue-ti-du-yu-baseline/</url>
      
        <content type="html"><![CDATA[<h2 id="一、策略梯度中的-baseline"><a href="#一、策略梯度中的-baseline" class="headerlink" title="一、策略梯度中的 baseline"></a>一、策略梯度中的 baseline</h2><blockquote><p>本小结的主要内容是做数学推导得到带 baseline 的策略梯度的公式。</p></blockquote><p>策略梯度方法常用 baseline 来降低方差，可以让收敛更快。</p><h3 id="1-1-baseline-的性质"><a href="#1-1-baseline-的性质" class="headerlink" title="1.1 baseline 的性质"></a>1.1 baseline 的性质</h3><p>baseline 指的是一个函数 b ，它不依赖于动作 $A$ ，可以得到公式：</p><script type="math/tex; mode=display">\mathbb{E}_{A \sim \pi} \left[ b \cdot \frac{\partial \log \pi(A|s; \theta)}{\partial \theta} \right] = 0 \tag{1.1}</script><p>证明过程如下：</p><script type="math/tex; mode=display">\begin{aligned}\mathbb{E}_{A \sim \pi} \left[ b \cdot \frac{\partial \log \pi(A|s; \theta)}{\partial \theta} \right] \\& （b 不依赖与动作 A） \\& = b \cdot \mathbb{E}_{A \sim \pi} \left[ \frac{\partial \log \pi(A|s; \theta)}{\partial \theta} \right] \\& （假设动作是离散的，展开期望） \\& = b \cdot \sum_{a \in A}\pi(a|s; \theta) \frac{\partial \log \pi(a|s; \theta)}{\partial \theta} \\& （求导的链式法则） \\& = b \cdot \sum_{a \in A}\pi(a|s; \theta) \left[ \frac{1}{\pi(a|s; \theta)} \cdot \frac{\partial \pi(a|s; \theta)}{\partial \theta} \right] \\& = b \cdot \sum_{a \in A} \frac{\partial \pi(a|s; \theta)}{\partial \theta} \\& （连加与求导的对象不同） \\& = b \cdot \frac{\partial \sum_{a \in A} \pi(a|s; \theta)}{\partial \theta} \\& （所有动作的概率和为1） \\& = b \cdot \frac{\partial 1}{\partial \theta} \\& （常数的导数为0） \\& = 0 \\\end{aligned}</script><h3 id="1-2-带-baseline-的策略梯度公式"><a href="#1-2-带-baseline-的策略梯度公式" class="headerlink" title="1.2 带 baseline 的策略梯度公式"></a>1.2 带 baseline 的策略梯度公式</h3><p>在<a href="https://kibazen.cn/ji-yu-ce-lue-de-qiang-hua-xue-xi/">基于策略的强化学习</a>中推导了策略梯度的公式：</p><script type="math/tex; mode=display">\frac{\partial V(s; \theta)}{\partial \theta} = \mathbb{E}_{A \sim \pi(\cdot | s; \theta)} \left[ \frac{\partial \log \pi(A | s; \theta)}{\partial \theta} \cdot Q_{\pi}(s, A) \right]</script><p>结合上面推导得到公式1和策略梯度公式，可以得到 <strong>带 baseline 的策略梯度公式</strong> ：</p><script type="math/tex; mode=display">\begin{aligned}\frac{\partial V_{\pi}(s)}{\partial \theta}& = \mathbb{E}_{A \sim \pi} \left[ \frac{\partial \log \pi(A | s; \theta)}{\partial \theta} \cdot Q_{\pi}(s, A) \right] \\& = \mathbb{E}_{A \sim \pi} \left[ \frac{\partial \log \pi(A | s; \theta)}{\partial \theta} \cdot Q_{\pi}(s, A) \right] - 0 \\& = \mathbb{E}_{A \sim \pi} \left[ \frac{\partial \log \pi(A | s; \theta)}{\partial \theta} \cdot Q_{\pi}(s, A) \right] - \mathbb{E}_{A \sim \pi} \left[ b \cdot \frac{\partial \log \pi(A|s; \theta)}{\partial \theta} \right] \\& = \mathbb{E}_{A \sim \pi} \left[ \frac{\partial \log \pi(A | s; \theta)}{\partial \theta} \cdot \left( Q_{\pi}(s, A) - b \right) \right]\end{aligned}</script><p>即，如果 baseline 函数 b 不依赖于动作 $A_t$，下面公式成立：</p><script type="math/tex; mode=display">\frac{\partial V_{\pi}(s_t)}{\partial \theta} = \mathbb{E}_{A_t \sim \pi} \left[ \frac{\partial \log \pi(A_t | s_t; \theta)}{\partial \theta} \cdot \left( Q_{\pi}(s_t, A_t) - b \right) \right] \tag{1.2}</script><p>从公式中我们可以看出：baseline 不会影响策略梯度的正确性，不管函数 b 是什么，得到的期望都是一样的。</p><h3 id="1-3-蒙特卡洛近似"><a href="#1-3-蒙特卡洛近似" class="headerlink" title="1.3 蒙特卡洛近似"></a>1.3 蒙特卡洛近似</h3><p>将 <strong>带 baseline 的策略梯度公式</strong> 中求期望的部分记作 $g(A_t)$，即：</p><script type="math/tex; mode=display">g(A_t) = \frac{\partial \log \pi(A_t | s_t; \theta)}{\partial \theta} \cdot \left( Q_{\pi}(s_t, A_t) - b \right)</script><ol><li>从策略 $\pi(\cdot | s; \theta)$ 中抽样出动作 $a_t$，然后计算 $g(a_t)$ 。计算得到的 $g(a_t)$ 就是 $\mathbb{E}_{A_t \sim \pi} \left[ g(A_t) \right]$ 的蒙特卡洛近似。</li><li>$g(a_t)$ 是策略梯度的一个无偏估计，这是因为 $g(A_t)$ 关于 $A_t$ 的期望等于策略梯度。$g(a_t)$ 其实是一个随机梯度，它是对策略梯度的蒙特卡洛近似。实际训练策略网络的时候，用的都是随机梯度 $g(a_t)$ ，而不是用真正的策略梯度。<script type="math/tex; mode=display">\mathbb{E}_{A_t \sim \pi} \left[ g(A_t) \right] = \frac{\partial V_{\pi}(s_t)}{\partial \theta}</script></li><li>使用随机梯度上升更新策略网络的参数 $\theta$<script type="math/tex; mode=display">\theta \leftarrow \theta + \beta \cdot g(a_t)</script></li></ol><p>从 <strong>带 baseline 的策略梯度公式</strong> 看到，虽然使用不同的 baseline 函数 b 不会改变期望 $\mathbb{E}_{A_t \sim \pi} \left[ g(A_t) \right]$ 的值，但是会影响 $g(a_t)$ 的值。如果选择的baseline 函数 b 很好，接近 $Q_{\pi}(s_t, A_t)$，随机策略梯度 $g(a_t)$ 的方差就会变小，就能让算法收敛更快。这也是为什么要使用 baseline 函数 b 的原因。</p><h3 id="1-4-baseline-的选择"><a href="#1-4-baseline-的选择" class="headerlink" title="1.4 baseline 的选择"></a>1.4 baseline 的选择</h3><ol><li><p>b=0</p><p> 相当于不适用 baseline，得到的是标准的策略梯度。</p><script type="math/tex; mode=display">\frac{\partial V_{\pi}(s_t)}{\partial \theta} = \mathbb{E}_{A_t \sim \pi} \left[ \frac{\partial \log \pi(A_t | s_t; \theta)}{\partial \theta} \cdot Q_{\pi}(s_t, A_t) \right]</script></li><li><p>$b=V_{\pi}(s_t)$<br> 因为 $V_{\pi}(s_t)$ 只依赖于当前状态的 $s_t$，状态 $s_t$ 是先于 $A_t$ 被观测到的，所以 $s_t$ 不依赖于 $A_t$，可以作为 baseline 。</p><p> 而选择使用 $V_{\pi}(s_t)$ 作为 baseline 的原因在于，$V_{\pi}(s_t)$ 的值接近 $Q_{\pi}(s_t, A_t)$，能够有效的降低方差。</p><script type="math/tex; mode=display">V_{\pi}(s_t) = \mathbb{E}_{A_t}[Q_{\pi}(s_t, A_t)]</script></li></ol><h2 id="二、REINFORCE-with-Baseline"><a href="#二、REINFORCE-with-Baseline" class="headerlink" title="二、REINFORCE with Baseline"></a>二、REINFORCE with Baseline</h2><h3 id="2-1-近似带-baseline-的策略梯度"><a href="#2-1-近似带-baseline-的策略梯度" class="headerlink" title="2.1 近似带 baseline 的策略梯度"></a>2.1 近似带 baseline 的策略梯度</h3><p>在<a href="#14-baseline-的选择">1.4 baseline 的选择</a>中，证明了可以使用 $V_{\pi}(s_t)$ 来作为 Baseline：</p><script type="math/tex; mode=display">\frac{\partial V_{\pi}(s_t)}{\partial \theta} = \mathbb{E}_{A_t \sim \pi} \left[ \frac{\partial \log \pi(A_t | s_t; \theta)}{\partial \theta} \cdot \left( Q_{\pi}(s_t, A_t) - V_{\pi}(s_t) \right) \right]</script><p>在使用这个公式训练时，需要做总共3步近似：</p><ol><li><p>使用随机策略梯度来近似真正的策略梯度的期望（蒙特卡洛近似）<br> 记 $g(A_t)$ 为：</p><script type="math/tex; mode=display">g(A_t) = \frac{\partial \log \pi(A_t | s_t; \theta)}{\partial \theta} \cdot \left( Q_{\pi}(s_t, A_t) - V_{\pi}(s_t) \right)</script><p> 从策略 $\pi(\cdot | s; \theta)$ 中抽样出动作 $a_t$，然后使用随机策略梯度 $g(a_t)$ 的值来代替真正的策略梯度的期望 $\mathbb{E}_{A_t \sim \pi} \left[ g(A_t) \right]$ 的值。</p></li><li><p>使用折扣回报来近似 $Q_{\pi}(s_t, a_t)$ 的值（再一次蒙特卡洛近似）<br> 经过了上一步的近似后，我们得到：</p><script type="math/tex; mode=display">g(a_t) = \frac{\partial \log \pi(a_t | s_t; \theta)}{\partial \theta} \cdot \left( Q_{\pi}(s_t, a_t) - V_{\pi}(s_t) \right)</script><p> 得到的等式中，$Q_{\pi}(s_t, a_t)$ 和 $V_{\pi}(s_t)$ 依然是未知的。</p><p> 使用策略 $\pi(\cdot | s; \theta)$ 控制智能体玩一局游戏到结束，得到轨迹：</p><script type="math/tex; mode=display">s_t, a_t, r_t, s_{t+1}, a_{t+1}, r_{t+1}, \cdots, s_n, a_n, r_n</script><p> 计算折扣回报：</p><script type="math/tex; mode=display">u_t = \sum_{i=t}^n \gamma^{i-t} r_i</script><p> 折扣回报 $u_t$ 就是 $Q_{\pi}(s_t, a_t)$ 的无偏估计。REINFORCE 算法就是使用折扣回报 $u_t$ 来近似 $Q_{\pi}(s_t, a_t)$ 的值。</p></li><li><p>使用神经网络来近似 $V_{\pi}(s_t)$（函数近似）</p><p> 使用神经网络 $v(s; \mathbf{w})$ 来近似 $V_{\pi}(s_t)$ 的值。</p></li></ol><p>经过3步近似后，可以得到 <strong>近似后的带 baseline 的策略梯度</strong> ：</p><script type="math/tex; mode=display">\frac{\partial V_{\pi}(s_t)}{\partial \theta} \approx g(a_t) \approx \frac{\partial \log \pi(a_t | s_t; \theta)}{\partial \theta} \cdot \left( u_t - v(s_t; \mathbf{w}) \right)</script><h3 id="2-2-算法训练流程"><a href="#2-2-算法训练流程" class="headerlink" title="2.2 算法训练流程"></a>2.2 算法训练流程</h3><ol><li><p>使用策略 $\pi(\cdot | s; \theta)$ 控制智能体玩一局游戏到结束，得到轨迹：</p><script type="math/tex; mode=display">s_t, a_t, r_t, s_{t+1}, a_{t+1}, r_{t+1}, \cdots, s_n, a_n, r_n</script></li><li><p>计算折扣回报 $u_t$ 和误差 $\delta_t$</p><script type="math/tex; mode=display">u_t = \sum_{i=t}^n \gamma^{i-t} r_i</script><script type="math/tex; mode=display">\delta_t = v(s_t; \mathbf{w}) - u_t（注意这里是v-q而不是q-v）</script></li><li><p>更新策略网络的参数 $\theta$</p><script type="math/tex; mode=display">\theta \leftarrow \theta - \beta \cdot \delta_t \cdot \frac{\partial \log \pi(a_t | s_t; \theta)}{\partial \theta}</script></li><li><p>更新价值网络的参数 $\mathbf{w}$</p><script type="math/tex; mode=display">\mathbf{w} \leftarrow \mathbf{w} - \alpha \cdot \delta_t \cdot \frac{\partial v(s_t; \mathbf{w})}{\partial \mathbf{w}}</script><blockquote><p>其中 $\delta_t \cdot \frac{\partial v(s_t; \mathbf{w})}{\partial \mathbf{w}}$ 是误差 $\delta_t$ 的均方差关于参数 $\mathbf{w}$ 的导数</p><script type="math/tex; mode=display">\frac{\partial \delta_t ^2 / 2}{\partial \mathbf{w}} = \delta_t \cdot \frac{\partial v(s_t; \mathbf{w})}{\partial \mathbf{w}}</script></blockquote></li><li><p>对于第1步中的每个时刻，重复第2-4步。</p></li></ol><h2 id="三、Advantage-Actor-Critic（A2C）算法"><a href="#三、Advantage-Actor-Critic（A2C）算法" class="headerlink" title="三、Advantage Actor-Critic（A2C）算法"></a>三、Advantage Actor-Critic（A2C）算法</h2><blockquote><p>把 baseline 用到 Actor-Critic Method 上得到的算法就是A2C算法。</p></blockquote><h3 id="3-1-神经网络"><a href="#3-1-神经网络" class="headerlink" title="3.1 神经网络"></a>3.1 神经网络</h3><ol><li><p>策略网络（Actor）<br> 与原始的 Actor-Critic Method 中的策略网络（Actor）相同，依然是使用神经网络 $\pi(a|s; \theta)$ 来近似策略函数 $\pi({a|s})$，其中 $\theta$ 是神经网络的参数。</p></li><li><p>价值网络（Critic）<br> <strong>价值网络使用的是状态价值网络 $V_{\pi}(s)$ 而不是动作价值网络 $Q_{\pi}(s, a)$</strong>。使用神经网络 $v(s; \mathbf{w})$ 来近似策略函数 $V_{\pi}(s)$，其中 $\mathbf{w}$ 是神经网络的参数。</p><blockquote><p>动作价值网络 $Q_{\pi}(s, a)$ 依赖于状态 $s$ 和 动作 $a$ ，而状态价值网络 $V_{\pi}(s)$ 仅依赖于状态 $s$，不依赖于动作 $a$，所以状态价值网络 $V_{\pi}(s)$ 比动作价值网络 $Q_{\pi}(s, a)$ 更好训练。</p></blockquote></li></ol><h3 id="3-2-训练过程"><a href="#3-2-训练过程" class="headerlink" title="3.2 训练过程"></a>3.2 训练过程</h3><ol><li>获取到一组 transition $(s_t, a_t, r_t, s_{t+1})$</li><li>计算 <strong>TD target</strong><script type="math/tex; mode=display">y_t = r_t + \gamma \cdot v(s_{t+1}; \mathbf{w})</script></li><li>计算 <strong>TD error</strong><script type="math/tex; mode=display">\delta_t = v(s_t; \mathbf{w}) - y_t</script></li><li>更新策略网络的参数 $\theta$<script type="math/tex; mode=display">\theta \leftarrow \theta - \beta \cdot \delta_t \cdot \frac{\partial \log \pi(a_t | s_t; \theta)}{\partial \theta}</script></li><li>更新价值网络的参数 $\mathbf{w}$<script type="math/tex; mode=display">\mathbf{w} \leftarrow \mathbf{w} - \alpha \cdot \delta_t \cdot \frac{\partial v(s_t; \mathbf{w})}{\partial \mathbf{w}}</script></li></ol><h3 id="3-3-算法推导"><a href="#3-3-算法推导" class="headerlink" title="3.3 算法推导"></a>3.3 算法推导</h3><h4 id="3-3-1-价值函数性质的推导"><a href="#3-3-1-价值函数性质的推导" class="headerlink" title="3.3.1 价值函数性质的推导"></a>3.3.1 价值函数性质的推导</h4><p>在<a href="https://kibazen.cn/qiang-hua-xue-xi-zhong-shi-xu-chai-fen-xue-xi/">强化学习中时序差分学习</a>推导出了公式：</p><script type="math/tex; mode=display">Q_{\pi}(s_t, a_t) = \mathbb{E}[R_t + \gamma \cdot Q_{\pi}(S_{t+1}, A_{t+1})], \text{ for all }\pi</script><p>所以：</p><script type="math/tex; mode=display">\begin{aligned}Q_{\pi}(s_t, a_t)& = \mathbb{E}[R_t + \gamma \cdot Q_{\pi}(S_{t+1}, A_{t+1})] \\& = \mathbb{E}_{S_{t+1}, A_{t+1}}[R_t + \gamma \cdot Q_{\pi}(S_{t+1}, A_{t+1})] \\& （R_t 与 A_{t+1} 无关） \\& = \mathbb{E}_{S_{t+1}} \left[ R_t + \gamma \cdot \mathbb{E}_{A_{t+1}}[Q_{\pi}(S_{t+1}, A_{t+1})] \right] \\& （状态价值函数的定义） \\& = \mathbb{E}_{S_{t+1}}[R_t + \gamma \cdot V_{\pi}(S_{t+1})] \\\end{aligned}</script><p>即：</p><script type="math/tex; mode=display">Q_{\pi}(s_t, a_t) = \mathbb{E}_{S_{t+1}}[R_t + \gamma \cdot V_{\pi}(S_{t+1})] \tag{3.3.1a}</script><p>另，根据状态价值函数的定义：</p><script type="math/tex; mode=display">\begin{aligned}V_{\pi}(s_t)& = \mathbb{E}_{A_t}[Q_{\pi}(s_t, A_t)] \\& （使用公式3.3.1a） \\& = \mathbb{E}_{A_t} \left[ \mathbb{E}_{S_{t+1}}[R_t + \gamma \cdot V_{\pi}(S_{t+1})] \right] \\& = \mathbb{E}_{A_t,S_{t+1}}[R_t + \gamma \cdot V_{\pi}(S_{t+1})] \\\end{aligned}</script><p>即：</p><script type="math/tex; mode=display">V_{\pi}(s_t) = \mathbb{E}_{A_t,S_{t+1}}[R_t + \gamma \cdot V_{\pi}(S_{t+1})] \tag{3.3.1b}</script><h4 id="3-3-2-价值函数性质的蒙特卡洛近似"><a href="#3-3-2-价值函数性质的蒙特卡洛近似" class="headerlink" title="3.3.2 价值函数性质的蒙特卡洛近似"></a>3.3.2 价值函数性质的蒙特卡洛近似</h4><p>假设我们获取到一组 transition $(s_t, a_t, r_t, s_{t+1})$</p><ol><li><p><strong>公式3.3.1a</strong> 可以近似为</p><script type="math/tex; mode=display">Q_{\pi}(s_t, a_t) \approx r_t + \gamma \cdot V_{\pi}(s_{t+1}) \tag{3.3.2a}</script><p> 后面会使用这个公式来近似策略梯度，A2C算法的关键也在于这个公式。</p></li><li><p><strong>公式3.3.1b</strong> 可以近似为</p><script type="math/tex; mode=display">V_{\pi}(s_t) \approx r_t + \gamma \cdot V_{\pi}(s_{t+1}) \tag{3.3.2b}</script><p> 使用TD算法训练价值网络 $V_{\pi}(s_t)$ 时，<strong>TD target</strong> 就是由这个公式来的。</p></li></ol><h4 id="3-3-3-训练策略网络"><a href="#3-3-3-训练策略网络" class="headerlink" title="3.3.3 训练策略网络"></a>3.3.3 训练策略网络</h4><p>本文前面定义了随机梯度 $g(a_t)$</p><script type="math/tex; mode=display">g(a_t) = \frac{\partial \log \pi(a_t | s_t; \theta)}{\partial \theta} \cdot \left( Q_{\pi}(s_t, a_t) - V_{\pi}(s_t) \right)</script><blockquote><p>$g(a_t)$ 中包含了 $Q_{\pi}(s_t, a_t) - V_{\pi}(s_t)$，而 $Q_{\pi}(s_t, a_t) - V_{\pi}(s_t)$ 正好是优势函数（Advantage function）的定义，所以算法名中包含了 Advantage 。</p></blockquote><p>结合 $g(a_t)$ 的定义和 <strong>公式3.3.2a</strong>，有：</p><script type="math/tex; mode=display">g(a_t) \approx \frac{\partial \log \pi(a_t | s_t; \theta)}{\partial \theta} \cdot \left( r_t + \gamma \cdot V_{\pi}(s_{t+1}) - V_{\pi}(s_t) \right)</script><p>使用神经网络 $v(s;\mathbf{w})$ 近似状态价值函数 $V_{\pi}(s)$，得到：</p><script type="math/tex; mode=display">g(a_t) \approx \frac{\partial \log \pi(a_t | s_t; \theta)}{\partial \theta} \cdot \left( r_t + \gamma \cdot v(s_{t+1};\mathbf{w}) - v(s_t;\mathbf{w}) \right)</script><p>将公式中的 $r_t + \gamma \cdot v(s_{t+1};\mathbf{w})$ 记作 $y_t$。</p><blockquote><p>$y_t$ 其实就是 <strong>TD target</strong>，后面更新价值网络时也会用到。</p></blockquote><p>既然计算出了近似的策略梯度，就可以使用梯度上升来训练策略网络了：</p><script type="math/tex; mode=display">\theta \leftarrow \theta + \beta \cdot \frac{\partial \log \pi(a_t | s_t; \theta)}{\partial \theta} \cdot (y_t - v(s_t; \mathbf{w}))</script><h4 id="3-3-4-训练价值网络"><a href="#3-3-4-训练价值网络" class="headerlink" title="3.3.4 训练价值网络"></a>3.3.4 训练价值网络</h4><p>将 <strong>公式3.3.2b</strong> 中的 $V_{\pi}(S)$ 使用神经网络 $v(S; \mathbf{w})$ 近似，得到：</p><script type="math/tex; mode=display">v(s_t; \mathbf{w}) \approx r_t + \gamma \cdot v(s_{t+1}; \mathbf{w})</script><p>将 $r_t + \gamma \cdot v(s_{t+1}; \mathbf{w})$ 记作 $y_t$。使用TD算法训练时， $y_t$ 其实就是 <strong>TD target</strong> 。</p><p>所以 <strong>TD error</strong> 就是：</p><script type="math/tex; mode=display">\delta_t = v(s_t; \mathbf{w}) - y_t</script><p>梯度：</p><script type="math/tex; mode=display">\frac{\partial \delta_t ^2 / 2}{\partial \mathbf{w}} = \delta_t \cdot \frac{\partial v(s_t; \mathbf{w})}{\partial \mathbf{w}}</script><p>最后使用梯度下降方法来更新网络参数 $\mathbf{w}$：</p><script type="math/tex; mode=display">\mathbf{w} \leftarrow \mathbf{w} - \alpha \cdot \delta_t \cdot \frac{\partial v(s_t; \mathbf{w})}{\partial \mathbf{w}}</script><h4 id="3-3-5-对算法的直观理解"><a href="#3-3-5-对算法的直观理解" class="headerlink" title="3.3.5 对算法的直观理解"></a>3.3.5 对算法的直观理解</h4><p>回顾对策略梯度的近似：</p><script type="math/tex; mode=display">g(a_t) \approx \frac{\partial \log \pi(a_t | s_t; \theta)}{\partial \theta} \cdot \left( r_t + \gamma \cdot v(s_{t+1};\mathbf{w}) - v(s_t;\mathbf{w}) \right)</script><p>这个公式用来更新策略网络 $\pi(a|s; \theta)$。</p><p>公式中的 $r_t + \gamma \cdot v(s_{t+1};\mathbf{w}) - v(s_t;\mathbf{w})$ 是状态价值网络 $v(s;\mathbf{w})$ 做出的评价。它评价了动作 $a_t$ 的好坏，可以指导策略网络 $\pi(a|s; \theta)$ 做改进，所以状态价值网络 $v(s;\mathbf{w})$ 被称为 Critic 。</p><p>但是 $r_t + \gamma \cdot v(s_{t+1};\mathbf{w}) - v(s_t;\mathbf{w})$ 中并未包含动作 $a_t$，又是如何评价动作 $a_t$ 的好坏呢？</p><ol><li><p>$v(s_t;\mathbf{w})$ 是状态价值网络在 $t$ 时刻基于状态 $s_t$ 对状态 $s_t$ 的折扣回报 $\mathbb{E}[U_t | s_t]$ 的 <strong>预测值</strong>。预测值可以评价状态 $s_t$ 的好坏，状态 $s_t$ 越好，这个值就越大。</p></li><li><p>$r_t + \gamma \cdot v(s_{t+1};\mathbf{w})$ 是状态价值网络在 $t+1$ 时刻基于状态 $s_t$ 和状态 $s_{t+1}$ 对状态 $s_t$ 的折扣回报 $\mathbb{E}[U_t | s_t, s_{t+1}]$ 的 <strong>预测值</strong>。</p></li><li><p>$v(s_t;\mathbf{w})$ 和 $r_t + \gamma \cdot v(s_{t+1};\mathbf{w})$ 的 <strong>相同点</strong>：</p><ul><li>都是状态价值网络对状态 $s_t$ 的折扣回报的预估值。</li><li>都能够评价状态 $s_t$ 的好坏。</li></ul></li><li><p>$v(s_t;\mathbf{w})$ 和 $r_t + \gamma \cdot v(s_{t+1};\mathbf{w})$ 的 <strong>区别</strong>：</p><ul><li>$v(s_t;\mathbf{w})$ 是在 $t$ 时刻做出的预测，这个预测是在执行动作 $a_t$ 之前做出的，所以这个预测与动作 $a_t$ 无关。</li><li>$r_t + \gamma \cdot v(s_{t+1};\mathbf{w})$ 是在 $t+1$ 时刻做出的预测，这个预测受动作 $a_t$ 的影响，动作 $a_t$ 越好，新的状态 $s_{t+1}$ 就越好，$r_t + \gamma \cdot v(s_{t+1};\mathbf{w})$ 的值也就越大。</li><li>如果动作 $a_t$ 越好，$r_t + \gamma \cdot v(s_{t+1};\mathbf{w})$ 的值就比 $v(s_t;\mathbf{w})$ 更大，它们的差值就是正数，反之亦然。所以两者的差可以反映动作 $a_t$ 带来的优势，两者的差就叫做 Advantage 。</li></ul></li></ol><hr><blockquote><p>参考：<a href="https://www.youtube.com/playlist?list=PLvOO0btloRnujjKTwoC5fOJxC7nmiQ4c4">策略梯度与baseline</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 策略梯度 </tag>
            
            <tag> baseline </tag>
            
            <tag> 蒙特卡洛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于策略的强化学习</title>
      <link href="ji-yu-ce-lue-de-qiang-hua-xue-xi/"/>
      <url>ji-yu-ce-lue-de-qiang-hua-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、策略函数"><a href="#一、策略函数" class="headerlink" title="一、策略函数"></a>一、策略函数</h2><p>策略函数 $\pi(a|s)$ 的本质是一个概率密度函数（Probability Density Function， PDF）。它将从环境观察到的状态 $s$ 作为输入，输出所有动作中每个动作的概率。在需要执行动作时，就从这些动作概率中随机抽取一个动作来执行。</p><h2 id="二、策略网络"><a href="#二、策略网络" class="headerlink" title="二、策略网络"></a>二、策略网络</h2><p>因为从环境观察到的状态 $s$ 常常有无数多种，所以可以使用神经网络 $\pi(a|s; \theta)$ 来近似策略函数 $\pi({a|s})$，其中 $\theta$ 是神经网络的参数。神经网络 $\pi(a|s; \theta)$ 就是策略网络。</p><p>因为策略网络输出的是各个动作的概率，而各个动作概率的总和应该是1，所以策略网络最后的激活函数通常是 softmax 以保证策略网络输出值的总和为1。</p><h2 id="三、如何训练策略网络"><a href="#三、如何训练策略网络" class="headerlink" title="三、如何训练策略网络"></a>三、如何训练策略网络</h2><p>根据状态价值函数的定义有（为便于推导，假定动作是离散的）：</p><script type="math/tex; mode=display">V_{\pi}(s_t) = \mathbb{E}_A[Q_{\pi}(s_t, A)] = \sum_a \pi(a | s_t) \cdot Q_{\pi}(s_t, a)</script><p>使用神经网络 $\pi(a|s; \theta)$ 来近似策略函数 $\pi({a|s})$ 得到：</p><script type="math/tex; mode=display">V(s; \theta) = \sum_a \pi(a | s; \theta) \cdot Q_{\pi}(s, a)</script><p>我们知道，<a href="https://kibazen.cn/ma-er-ke-fu-he-bei-er-man-gong-shi-yi-ji-sheng-cheng-mo-shi/">当找到最优价值函数时，就解决了马尔科夫决策问题</a>。即当我们找到一个策略网络的参数值 $\hat{\theta}$ 使得 $V(s; \hat{\theta})$ 的值最大，我们就找到了一个最优的策略网络。</p><p>所以，令：</p><script type="math/tex; mode=display">J(\theta) = \mathbb{E}_s[V(s; \theta)]</script><p>可以使用 <strong>梯度上升</strong> 方法来更新策略网络的参数值 $\theta$ ：</p><ol><li>从环境观察到的状态 $s$ 。</li><li>更新策略网络（ $\beta$ 是学习率）<script type="math/tex; mode=display">\theta \leftarrow \theta + \beta \cdot \frac{\partial V(s; \theta)}{\partial \theta}</script></li></ol><h2 id="四、策略梯度"><a href="#四、策略梯度" class="headerlink" title="四、策略梯度"></a>四、策略梯度</h2><p>策略梯度就是使用神经网络 $\pi(a|s; \theta)$ 来近似策略函数 $\pi({a|s})$ 后得到的状态价值函数对神经网络参数 $\theta$ 的导数，即 $\frac{\partial V(s; \theta)}{\partial \theta}$ 。</p><script type="math/tex; mode=display">\begin{aligned}\frac{\partial V(s; \theta)}{\partial \theta}& = \frac{\partial \sum_a \pi(a | s; \theta) \cdot Q_{\pi}(s, a)}{\partial \theta} \\& = \sum_a \frac{\partial \pi(a | s; \theta) \cdot Q_{\pi}(s, a)}{\partial \theta} \\&（虽然不准确，但是为了简化推导，假设 Q_{\pi}(s, a) 不依赖于 \theta ） \\& = \sum_a \frac{\partial \pi(a | s; \theta)}{\partial \theta} \cdot Q_{\pi}(s, a) \\& （链式求导法则） \\& = \sum_a \pi(a | s; \theta) \cdot \frac{\partial \log \pi(a | s; \theta)}{\partial \theta} \cdot Q_{\pi}(s, a) \\& = \mathbb{E}_{A \sim \pi(\cdot | s; \theta)} \left[ \frac{\partial \log \pi(A | s; \theta)}{\partial \theta} \cdot Q_{\pi}(s, A) \right] \\\end{aligned}</script><blockquote><ol><li>上面的计算过程中，假设了 $Q_{\pi}(s, a)$ 不依赖于 $\theta$ ，这是为了简化推导，便于理解。实际上即使将 $Q_{\pi}(s, a)$ 对于 $\theta$ 的导数也考虑进去，得到的结果也是一样的。</li><li>链式求导法则<script type="math/tex; mode=display">\frac{\partial \log [\pi (\theta)]}{\partial \theta} = \frac{1}{\pi (\theta)} \cdot \frac{\partial \pi (\theta)}{\partial \theta}</script></li></ol></blockquote><p>即：</p><script type="math/tex; mode=display">\frac{\partial V(s; \theta)}{\partial \theta} = \sum_a \frac{\partial \pi(a | s; \theta)}{\partial \theta} \cdot Q_{\pi}(s, a) \tag{4.1}</script><script type="math/tex; mode=display">\frac{\partial V(s; \theta)}{\partial \theta} = \mathbb{E}_{A \sim \pi(\cdot | s; \theta)} \left[ \frac{\partial \log \pi(A | s; \theta)}{\partial \theta} \cdot Q_{\pi}(s, A) \right] \tag{4.2}</script><h2 id="五、计算策略梯度"><a href="#五、计算策略梯度" class="headerlink" title="五、计算策略梯度"></a>五、计算策略梯度</h2><h3 id="5-1-离散动作"><a href="#5-1-离散动作" class="headerlink" title="5.1 离散动作"></a>5.1 离散动作</h3><p>如果动作是离散的，比如动作空间是 $\mathcal{A} \in \{ \text{“left”}, \text{“right”}, \text{“fire”} \}$。可以使用 <strong>公式4.1</strong> ：</p><script type="math/tex; mode=display">\frac{\partial V(s; \theta)}{\partial \theta} = \sum_a \frac{\partial \pi(a | s; \theta)}{\partial \theta} \cdot Q_{\pi}(s, a) \tag{4.1}</script><ol><li><p>对每个动作 $a \in \mathcal{A}$ ，计算</p><script type="math/tex; mode=display">\mathbf{f}(a, \theta) = \frac{\partial \pi(a | s; \theta)}{\partial \theta} \cdot Q_{\pi}(s, a)</script></li><li><p>计算策略梯度</p><script type="math/tex; mode=display">\frac{\partial V(s; \theta)}{\partial \theta} = \mathbf{f}(\text{"left"}, \theta) + \mathbf{f}(\text{"right"}, \theta) + \mathbf{f}(\text{"fire"}, \theta)</script></li></ol><h3 id="5-2-连续动作"><a href="#5-2-连续动作" class="headerlink" title="5.2 连续动作"></a>5.2 连续动作</h3><p>如果动作是连续的，比如动作空间是 $\mathcal{A} = [0,1]$。可以使用 <strong>公式4.2</strong> ：</p><script type="math/tex; mode=display">\frac{\partial V(s; \theta)}{\partial \theta} = \mathbb{E}_{A \sim \pi(\cdot | s; \theta)} \left[ \frac{\partial \log \pi(A | s; \theta)}{\partial \theta} \cdot Q_{\pi}(s, A) \right] \tag{4.2}</script><p>因为直接求期望很难，所以可以对期望做蒙特卡洛（Monte Carlo）近似，步骤如下：</p><ol><li>从概率密度函数 $\pi(\cdot | s; \theta)$ 中随机抽样得到一个动作 $\hat{a}$ 。</li><li><p>计算</p><script type="math/tex; mode=display">\mathbf{g}(\hat{a}, \theta) = \frac{\partial \log \pi(\hat{a} | s; \theta)}{\partial \theta} \cdot Q_{\pi}(s, \hat{a})</script><blockquote><ol><li>显然有 $\mathbb{E}_A \left[ \mathbf{g}(A, \theta) \right]= \frac{\partial V(s; \theta)}{\partial \theta}$ 。</li><li>因为 $\hat{a}$ 是从 $\pi(\cdot | s; \theta)$ 中随机抽样得到的，所以 $\mathbf{g}(\hat{a}, \theta)$ 是 $\frac{\partial V(s; \theta)}{\partial \theta}$ 的一个无偏估计。</li></ol></blockquote></li><li><p>使用 $\mathbf{g}(\hat{a}, \theta)$ 来近似 $\frac{\partial V(s; \theta)}{\partial \theta}$ （蒙特卡洛近似）。</p></li></ol><p>上面的这种方法对离散的动作也是有效的。</p><h2 id="六、使用策略梯度来更新策略网络"><a href="#六、使用策略梯度来更新策略网络" class="headerlink" title="六、使用策略梯度来更新策略网络"></a>六、使用策略梯度来更新策略网络</h2><p>完整的步骤如下：</p><ol><li>从环境观察到的状态 $s_t$ 。</li><li>从概率密度函数 $\pi(\cdot | s_t; \theta_t)$ 中随机抽样得到一个动作 $a_t$ 。</li><li>计算动作价值 $q_t \approx Q_{\pi}(s_t, a_t)$ 。</li><li>计算策略梯度 $\mathbf{d}_{\theta, t} = \frac{\partial \log \pi(a_t | s_t; \theta)}{\partial \theta} \mid_{\theta = {\theta}_t}$ 。</li><li>计算策略梯度的近似值 $\mathbf{g}(a_t, {\theta}_t) = q_t \cdot \mathbf{d}_{\theta, t}$ 。</li><li>更新策略网络 $\theta_{t+1} = \theta_t + \beta \cdot \mathbf{g}(a_t, \theta_t)$ 。</li></ol><p>在上面的步骤3中，计算 $q_t$ 的方式有两种。</p><h3 id="6-1-REINFORCE"><a href="#6-1-REINFORCE" class="headerlink" title="6.1 REINFORCE"></a>6.1 REINFORCE</h3><p>使用观测到的 $g_t$ 来代替 $Q_{\pi}(s_t, a_t)$ 。</p><ul><li>用策略网络 $\pi(\cdot | s_t; \theta_t)$ 控制 agent 从游戏开始到游戏结束玩一局完整的游戏，得到游戏轨迹 $s_1, a_1, r_1, s_2, a_2, r_2, \cdots , s_T, a_T, r_T$ 。</li><li>计算所有时刻的折扣回报 $g_t = \sum_{k=t}^T \gamma^{k-t} r_k$ 。</li><li>因为 $Q_\pi (s_t, a_t) = \mathbb{E}[G_t]$ ，所以可以使用折扣回报 $g_t$ 来近似 $Q_\pi (s_t, a_t)$ ，即 $q_t = g_t$ 。</li></ul><h3 id="6-2-Actor-Critic-Method"><a href="#6-2-Actor-Critic-Method" class="headerlink" title="6.2 Actor-Critic Method"></a>6.2 Actor-Critic Method</h3><p>使用神经网络来近似 $Q_{\pi}(s_t, a_t)$。</p><p>我们已经使用神经网络 $\pi(a|s; \theta)$ 来近似策略函数 $\pi({a|s})$，其中 $\theta$ 是神经网络的参数。同时，我们再使用神经网络 $q(s,a;\mathbf{w})$ 来近似价值函数 $Q_{\pi}(s, a)$，其中 $\mathbf{w}$ 是神经网络的参数。</p><script type="math/tex; mode=display">V(s; \theta, \mathbf{w}) = \sum_a \pi(a | s; \theta) \cdot q_{\pi}(s, a; \mathbf{w})</script><p>训练时，策略网络 $\pi(a|s; \theta)$ 相当于运动员（Actor），而价值网络 $q(s,a;\mathbf{w})$ 相当于裁判（Critic）：</p><ul><li>训练 Actor 的目的是让 Critic 的打分尽可能的高，即更新策略网络 $\pi(a|s; \theta)$ 使状态价值 $V(s; \theta, \mathbf{w})$ 的值增加。 Actor 依靠 Critic 的打分来改进自己。</li><li>而训练 Critic 的目的则是让它对 Actor 的打分更准确，即更新价值网络 $q_{\pi}(s, a; \mathbf{w})$ 以能够更好的估计未来奖励的总和。 Critic 依靠环境给与的奖励来改进自己。</li><li>当 Critic 的打分比较准确且 Actor 的得分都比较高时，就能得到一个比较好的策略网络了。</li></ul><p>在推理时，只需要使用 Actor 来控制 agent 动作就可以了，推理时的不需要 Critic 。</p><p>算法完整的训练流程如下：</p><ol><li><p>从环境获得状态 $s_t$ 输入策略网络 $\pi(a|s; \theta)$ ，并从得到的动作概率 $\pi(a|s_t; \theta)$ 中抽样得到动作 $a_t$ 。</p></li><li><p>在环境中执行动作 $a_t$ 并获取到新的环境状态 $s_{t+1}$ 和奖励 $r_t$ 。</p></li><li><p>将新的环境状态 $s_{t+1}$ 输入策略网络中 $\pi(a|s; \theta)$ 并随机抽样得到一个临时的动作 $\hat{a}_{t+1}$ （<strong>这个动作不会在环境中执行，仅用于更新价值网络</strong>）。</p><blockquote><p>随机抽样保证样本的无偏性，这样才能用来做蒙特卡洛近似，详见<a href="#52-连续动作">5.2 连续动作</a>。</p></blockquote></li><li><p>计算动作 $a_t$ 和 $\hat{a}_{t+1}$ 的动作价值</p><script type="math/tex; mode=display">q_t = q(s_t, a_t; \mathbf{w}_t)</script><script type="math/tex; mode=display">q_{t+1} = q(s_{t+1}, \hat{a}_{t+1}; \mathbf{w}_t)</script></li><li><p>计算 <strong>TD error</strong></p><script type="math/tex; mode=display">{\delta}_t = q_t - (r_t + \gamma \cdot q_{t+1})</script></li><li><p>对价值网络 $q(s,a;\mathbf{w})$ 求导</p><script type="math/tex; mode=display">\mathbf{d}_{\mathbf{w}, t} = \frac{\partial q(s_t, a_t; \mathbf{w})}{\partial \mathbf{w}} \mid_{\mathbf{w} = \mathbf{w}_t}</script></li><li><p>使用<a href="https://kibazen.cn/qiang-hua-xue-xi-zhong-shi-xu-chai-fen-xue-xi/">时序差分学习</a>来更新价值网络（ $\alpha$ 是学习率）</p><script type="math/tex; mode=display">\mathbf{w}_{t+1} = \mathbf{w}_t - \alpha \cdot {\delta}_t \cdot \mathbf{d}_{\mathbf{w}, t}</script><blockquote><p>其中 ${\delta}_t \cdot \mathbf{d}_{\mathbf{w}, t}$ 是 <strong>TD error</strong> $\delta_t$ 的均方差关于参数 $\mathbf{w}$ 的导数</p><script type="math/tex; mode=display">\frac{\partial \delta_t ^2 / 2}{\partial \mathbf{w}} = \delta_t \cdot \mathbf{d}_{\mathbf{w}, t}</script></blockquote></li><li><p>对策略网络 $\pi(a|s; \theta)$ 求导</p><script type="math/tex; mode=display">\mathbf{d}_{\theta, t} = \frac{\partial \log \pi(a_t | s_t; \theta)}{\partial \theta} \mid_{\theta = {\theta}_t}</script></li><li><p>使用梯度上升方法来更新策略网络（ $\beta$ 是学习率）</p><script type="math/tex; mode=display">\theta_{t+1} = \theta_t + \beta \cdot q_t \cdot \mathbf{d}_{\theta, t}</script><blockquote><p>注意：实现中大多都使用第 5 步计算出来的 ${\delta}_t$ 来替代上面公式中的 $q_t$ 得到</p><script type="math/tex; mode=display">\theta_{t+1} = \theta_t + \beta \cdot {\delta}_t \cdot \mathbf{d}_{\theta, t}</script><p>这两种方式都是对的，使用 $q_t$ 是标准算法，而使用 ${\delta}_t$ 则是 <strong>Policy Gradient with Baseline</strong> 。 使用了 Baseline 的方法不影响期望，但是降低了方差，能让算法收敛更快，所以效果更好。</p></blockquote></li></ol><hr><blockquote><p>参考：<a href="https://www.youtube.com/watch?v=qI0vyfR2_Rc&amp;list=PLvOO0btloRnsiqM72G4Uid0UWljikENlU&amp;index=3&amp;ab_channel=ShusenWang">策略学习 Policy-Based Reinforcement Learning</a><br>Policy Gradient 论文：<a href="https://papers.nips.cc/paper/1713-policy-gradient-methods-for-reinforcement-learning-with-function-approximation.pdf">Policy Gradient Methods for Reinforcement Learning with Function Approximation</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 策略函数 </tag>
            
            <tag> 策略网络 </tag>
            
            <tag> 策略梯度 </tag>
            
            <tag> 策略学习 </tag>
            
            <tag> Actor-Critic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DQN中的高估问题及解决方案</title>
      <link href="dqn-zhong-de-gao-gu-wen-ti-ji-jie-jue-fang-an/"/>
      <url>dqn-zhong-de-gao-gu-wen-ti-ji-jie-jue-fang-an/</url>
      
        <content type="html"><![CDATA[<h2 id="一、DQN-中的-Bootstrapping"><a href="#一、DQN-中的-Bootstrapping" class="headerlink" title="一、DQN 中的 Bootstrapping"></a>一、DQN 中的 Bootstrapping</h2><p>Bootstrapping，自举，字面意思是：拔自己的鞋带，把自己举起来。而 Bootstrapping 在强化学习中的意思是：<strong>用一个估算去更新同类的估算</strong>。</p><p>在 DQN 算法中，我们让 DQN 在 $t$ 时刻的估计值 $Q(s_t)$ 尽量接近 <strong>TD target</strong>：</p><script type="math/tex; mode=display">y_t = r_t + \gamma \cdot \underset{a}{\operatorname{max}} Q_*(s_{t+1}, a)</script><p><strong>TD target</strong> 中使用到了 DQN 在 $t+1$ 时刻的估计值 $Q(s_{t+1})$ ，即：我们 <strong>用</strong> Q 网络在 $t+1$ 时刻的 <strong>估计值</strong> 去更新 $t$ 时刻的 <strong>估计值</strong> 。</p><h2 id="二、DQN-中的高估问题"><a href="#二、DQN-中的高估问题" class="headerlink" title="二、DQN 中的高估问题"></a>二、DQN 中的高估问题</h2><h3 id="2-1-最大化操作导致高估"><a href="#2-1-最大化操作导致高估" class="headerlink" title="2.1 最大化操作导致高估"></a>2.1 最大化操作导致高估</h3><p><strong>最大化操作本身会导致值被高估。</strong></p><p>举个例子，假如我们有一个数组 $A$：</p><script type="math/tex; mode=display">A = [-1,  5, -6,  8,  3,  2, -4, -7,  9]</script><p>数组 $A$ 的最大值是9，平均值是1。</p><p>数组 $A$ 加上一个均值为0数组 $B$：</p><script type="math/tex; mode=display">B = [-1,  1, -1,  0,  1,  1, -1, -1,  1]</script><p>后得到的数组 $C$：</p><script type="math/tex; mode=display">C = A+B = [-2,  6, -7,  8,  4,  3, -5, -8, 10]</script><p>数组 $C$ 的平均值依然是1，但是最大值却变成了10。</p><p>在 DQN 中，数组 $A$ 相当于各个动作真实的 Q 值，因为我们并不知道这个真实值，所以用 DQN 来估算它们。而估算总会有误差，相当于引入了上面的数组 $B$ 。假设 DQN 对真实动作价值的估算是无偏的（无偏估计），即 DQN 对动作估算的 Q 值和真实的 Q 值的均值相同，这和上面的例子一样。最后 DQN 估算出各个动作的 Q 值的结果相当于上面例子的 $A+B$ ，均值依然保持不变，但是最大值却变大了，所以 DQN 中最大化操作可能得到的结果也是比真实 Q 值更大的值，即最大化的操作导致了 DQN 高估了 Q 值。</p><h3 id="2-2-Bootstrapping-传播高估"><a href="#2-2-Bootstrapping-传播高估" class="headerlink" title="2.2 Bootstrapping 传播高估"></a>2.2 Bootstrapping 传播高估</h3><p>在上面分析到， <strong>TD target</strong> 中使用了 Q 网络在 $t+1$ 时刻的预估值，因为预估本身可能会导致高估真实的 Q 值，而让 DQN 在 $t$ 时刻的估计值 $Q(s_t)$ 尽量接近 <strong>TD target</strong> 则会将高估传播回 DQN，从而形成了一种正反馈。所以，一旦 DQN 中出现了高估，这种正反馈会让高估越来越严重。</p><h2 id="四、高估导致的问题"><a href="#四、高估导致的问题" class="headerlink" title="四、高估导致的问题"></a>四、高估导致的问题</h2><p>对不同动作不同程度的高估会导致原本最优的动作变成不是最优的，原本最差的动作可能会变成最优的动作。</p><p>假设某个状态下，两个动作真实的 Q 值分别是110和150，但是经过 DQN 高估后得到 Q 值分别是200和180。显然，经过高估后的各个动作的优劣完全变了样：原本最优的动作变成了最差的，最差的动作却成了最优的了。</p><p>因为各个状态下各个动作出现的概率总是不均匀的，越频繁出现的动作 DQN 对该动作的估算更新得也更频繁，估算中出现的高估则进一步加剧了这种情况。最后导致了 DQN 对各个状态下各个动作的高估程度不同。</p><h2 id="五、解决方案"><a href="#五、解决方案" class="headerlink" title="五、解决方案"></a>五、解决方案</h2><h3 id="5-1-使用-target-network-避免-Bootstrapping"><a href="#5-1-使用-target-network-避免-Bootstrapping" class="headerlink" title="5.1 使用 target network 避免 Bootstrapping"></a>5.1 使用 target network 避免 Bootstrapping</h3><p>在 DQN 中新加一个名为 <strong>target network</strong> 的网络 $Q(s,a; \mathbf{w}^-)$ ，其结构和原始的 Q 网络 $Q(s,a; \mathbf{w})$ 相同，但是使用不同的网络参数 $\mathbf{w}^-$ 。</p><p>两个网络的用处不同，原来的 Q 网络 $Q(s,a; \mathbf{w})$ 用来控制智能体和收集学习用的经验，而 <strong>target network</strong> 则用来计算 <strong>TD target</strong> 。</p><p>使用了 <strong>target network</strong> 的 DQN 算法的完整流程如下：</p><ol><li><p>计算 <strong>TD target</strong> ：</p><script type="math/tex; mode=display">y_t = r_t + \gamma \cdot \underset{a}{\operatorname{max}} Q(s_{t+1}, a; \mathbf{w}^-)</script></li><li><p>计算 <strong>TD error</strong> ：</p><script type="math/tex; mode=display">\delta^t = Q(s_t,a_t; \mathbf{w}) - y_t</script></li><li><p>使用梯度下降算法来更新 Q 网络 $Q(s_t,a_t; \mathbf{w})$ 的参数：</p><script type="math/tex; mode=display">\mathbf{w} \leftarrow \mathbf{w} - \alpha \cdot \delta^t \cdot \frac{\partial Q(s_t,a_t;\mathbf{w})}{\partial \mathbf{w}}</script></li></ol><p>因为使用了 <strong>target network</strong> 的预估值来更新原来的 Q 网络的预估值，这就避免了 Bootstrapping ，缓解了高估的问题。但是因为需要周期性的用 Q 网络的参数值来更新 <strong>target network</strong>，所以并不能完全解决高估问题，只能缓解。</p><p><strong>target network</strong> 参数的更新方式是周期性的同步自原来的Q网络。同步的方式有两种：</p><ol><li><p>直接使用原来的 Q 网络参数替换 <strong>target network</strong> 的参数：</p><script type="math/tex; mode=display">\mathbf{w}^- \leftarrow \mathbf{w}</script></li><li><p>将原来的 Q 网络参数和 <strong>target network</strong> 的参数做加权平均：</p><script type="math/tex; mode=display">\mathbf{w}^- \leftarrow \tau \cdot \mathbf{w} + (1 - \tau) \cdot \mathbf{w}^-</script></li></ol><h3 id="5-2-使用-Double-DQN-避免最大化导致的高估"><a href="#5-2-使用-Double-DQN-避免最大化导致的高估" class="headerlink" title="5.2 使用 Double DQN 避免最大化导致的高估"></a>5.2 使用 Double DQN 避免最大化导致的高估</h3><h4 id="5-2-1-原始的-DQN"><a href="#5-2-1-原始的-DQN" class="headerlink" title="5.2.1 原始的 DQN"></a>5.2.1 原始的 DQN</h4><p>其实 DQN 在计算 <strong>TD target</strong> 时，其中的 $\underset{a}{\operatorname{max}} Q(s_{t+1}, a; \mathbf{w})$ 可以分解成两步操作：</p><ol><li>使用 <strong>原来的 Q 网络</strong> 选择最优动作<script type="math/tex; mode=display">a_* = \underset{a}{\operatorname{argmax}} Q(s_{t+1},a; \mathbf{w})</script></li><li><strong>同时</strong> 使用 <strong>原来的 Q 网络</strong> 预估动作的价值<script type="math/tex; mode=display">y_t = r_t + \gamma \cdot Q(s_{t+1}, a_*; \mathbf{w})</script></li></ol><p>这两步用的都是 <strong>原来的 Q 网络</strong> 来进行计算，这种方式的表现最差，训练出的网络会严重高估真实的动作价值。</p><h4 id="5-2-2-使用了-target-network-的-DQN"><a href="#5-2-2-使用了-target-network-的-DQN" class="headerlink" title="5.2.2 使用了 target network 的 DQN"></a>5.2.2 使用了 <strong>target network</strong> 的 DQN</h4><p>使用了 <strong>target network</strong> 的 DQN 计算 <strong>TD target</strong> 时：</p><ol><li>使用 <strong>target network</strong> 选择最优动作<script type="math/tex; mode=display">a_* = \underset{a}{\operatorname{argmax}} Q(s_{t+1},a; \mathbf{w}^-)</script></li><li><strong>同时</strong> 使用 <strong>target network</strong> 预估动作的价值<script type="math/tex; mode=display">y_t = r_t + \gamma \cdot Q(s_{t+1}, a_*; \mathbf{w}^-)</script></li></ol><p>这两步用的都是 <strong>target network</strong> 来进行计算，这种方式因避免了 Bootstrapping，所以表现会比原始的 DQN 好一些，但是训练出的网络依然会高估真实的动作价值。</p><h4 id="5-2-3-Double-DQN"><a href="#5-2-3-Double-DQN" class="headerlink" title="5.2.3 Double DQN"></a>5.2.3 Double DQN</h4><p>而 Double DQN 则是对原始的 DQN 和使用了 <strong>target network</strong> 的 DQN 的一种改进：</p><ol><li>使用 <strong>原来的 Q 网络</strong> 选择最优动作<script type="math/tex; mode=display">a_* = \underset{a}{\operatorname{argmax}} Q(s_{t+1},a; \mathbf{w})</script></li><li>使用 <strong>target network</strong> 预估动作的价值<script type="math/tex; mode=display">y_t = r_t + \gamma \cdot Q(s_{t+1}, a_*; \mathbf{w}^-)</script></li></ol><p>Double DQN 中使用 <strong>原来的 Q 网络</strong> 选择最优动作，另外使用了 <strong>target network</strong> 预估动作的价值。两步使用了不同了网络，虽然改动很少，但是却能进一步的缓解高估的问题（依然没有根除高估的问题）。</p><p>对 <strong>target network</strong> 来说可以证明如下的等式是成立的：</p><script type="math/tex; mode=display">Q(s_{t+1}, a_*; \mathbf{w}^-) \le \underset{a}{\operatorname{max}} Q(s_{t+1}, a; \mathbf{w}^-)</script><p>等式左边是 Double DQN 算出的，等式右边是 <strong>target network</strong> 算出的。上面的等式表面了 Double DQN 估算出的 Q 值总是不高于使用 <strong>target network</strong> 计算出 Q 值，所以缓解了高估的问题。</p><h3 id="5-3-使用-Dueling-Network-改进网络结构"><a href="#5-3-使用-Dueling-Network-改进网络结构" class="headerlink" title="5.3 使用 Dueling Network 改进网络结构"></a>5.3 使用 Dueling Network 改进网络结构</h3><p>Dueling Network 中使用到了优势函数的概念，这里先介绍一下优势函数。</p><blockquote><p>后面的推导，特别是关于优势函数的推导与原论文中的推导不同。</p></blockquote><h4 id="5-3-1-优势函数（Advantage-Function）"><a href="#5-3-1-优势函数（Advantage-Function）" class="headerlink" title="5.3.1 优势函数（Advantage Function）"></a>5.3.1 优势函数（Advantage Function）</h4><ol><li><p>定义</p><p> 定义优势函数为：</p><script type="math/tex; mode=display">A_*(s,a) = Q_*(s,a) - V_*(s)</script><p> 其意义是：将 <script type="math/tex">V_*(s)</script> 作为基准，在状态 $s$ 的情况下，执行动作 $a$ 的好坏。即动作 $a$ 相对 <script type="math/tex">V_*(s)</script> 的优势。</p></li><li><p>性质</p><p> 对优势函数等式的两边同时做基于动作 $a$ 的 $max$ 操作得到：</p><script type="math/tex; mode=display">\underset{a}{max}A_*(s,a) = \underset{a}{max}Q_*(s,a) - V_*(s)</script><p> 根据贝尔曼最优方程（Bellman Optimality Equation）：</p><script type="math/tex; mode=display">V_*(s) = \max_a Q_*(s,a)</script><p> 于是：</p><script type="math/tex; mode=display"> \begin{aligned} \underset{a}{max}A_*(s,a) & = \underset{a}{max}Q_*(s,a) - V_*(s) \\ & = \underset{a}{max}Q_*(s,a) - \underset{a}{max}Q_*(s,a) \\ & = 0 \end{aligned}</script><p> 即：</p><script type="math/tex; mode=display">\underset{a}{max}A_*(s,a) = 0</script></li><li><p>推导</p><p> 变换一下优势函数定义的等式，可以得到下面的等式：</p><script type="math/tex; mode=display">Q_*(s,a) = V_*(s) + A_*(s,a)</script><p> 同时根据优势函数的性质，可以在上面等式右边减去一个 $0$，得到等式：</p><script type="math/tex; mode=display">Q_*(s,a) = V_*(s) + A_*(s,a) - \underset{a}{max}A_*(s,a) \tag{5.3.1}</script><p> 但是为什么要在等式的右边减去一个0呢？对比一下减去0前后的两个等式：</p><script type="math/tex; mode=display"> \begin{aligned} Q_*(s,a) & = V_*(s) + A_*(s,a) \\ Q_*(s,a) & = V_*(s) + A_*(s,a) - \underset{a}{max}A_*(s,a) \\ \end{aligned}</script><p> 发现，上面的公式有一个下面公式没有的 <strong>唯一解问题</strong> ：如果 <script type="math/tex">V_*(s)</script> 的值整体加 $x$，而 <script type="math/tex">A_*(s,a)</script> 的值整体减 $x$。上面的等式最后的值 <script type="math/tex">Q_*(s,a)</script> 没变，但是下面等式最后的值增加了 $x$。 而没有唯一解在强化学习中就意味着难以训练出模型，所以下面一个等式才能应用到强化学习中。</p></li></ol><h4 id="5-3-2-优势函数的应用-Dueling-Network"><a href="#5-3-2-优势函数的应用-Dueling-Network" class="headerlink" title="5.3.2 优势函数的应用 Dueling Network"></a>5.3.2 优势函数的应用 Dueling Network</h4><p>根据上面利用优势函数推导出的等式：</p><script type="math/tex; mode=display">Q_*(s,a) = V_*(s) + A_*(s,a) - \underset{a}{max}A_*(s,a)</script><p>使用两个神经网络来分别近似 <script type="math/tex">V_*(s)</script> 函数和 <script type="math/tex">A_*(s,a)</script> 函数，进而就可以得到 <script type="math/tex">Q_*(s,a)</script> 函数，这就是 Dueling Network。</p><p><strong>在实际使用时，根据数学公式推导出的 Dueling Network 中对优势函数求最大化的操作，换成均值操作得到的效果更好更稳定，这种替换操作没有理论依据，但是实际效果更好。</strong></p><script type="math/tex; mode=display">Q_*(s,a) = V_*(s) + A_*(s,a) - \underset{a}{mean}A_*(s,a)</script><p>最后，因为 Dueling Network 只是改进了 DQN 中原始 Q 网络的结构，所以使用了 Dueling Network 的 DQN 的训练方法与使用了原始的 Q 网络的 DQN 训练方法相同，DQN 改进的技巧（比如Double DQN）也依然都是可以使用的。</p><hr><blockquote><p>参考：<a href="https://www.youtube.com/watch?v=X2-56QN79zc&amp;list=PLvOO0btloRntS5U8rQWT9mHFcUdYOUmIC&amp;index=2&amp;ab_channel=ShusenWang">高估问题、Target Network、Double DQN</a><br>DQN 论文：<a href="https://arxiv.org/abs/1312.5602">Playing Atari with Deep Reinforcement Learning</a><br>Target Network 论文：<a href="https://web.stanford.edu/class/psych209/Readings/MnihEtAlHassibis15NatureControlDeepRL.pdf">Human-level control through deep reinforcement learning</a><br>Double DQN 论文：<a href="https://arxiv.org/abs/1509.06461">Deep Reinforcement Learning with Double Q-learning</a><br>Dueling Network 论文：<a href="https://arxiv.org/abs/1511.06581">Dueling Network Architectures for Deep Reinforcement Learning</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高估问题 </tag>
            
            <tag> Target Network </tag>
            
            <tag> Double DQN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习中的经验回放</title>
      <link href="qiang-hua-xue-xi-zhong-de-jing-yan-hui-fang/"/>
      <url>qiang-hua-xue-xi-zhong-de-jing-yan-hui-fang/</url>
      
        <content type="html"><![CDATA[<h2 id="一、时序差分学习（Temporal-Difference-Learning）"><a href="#一、时序差分学习（Temporal-Difference-Learning）" class="headerlink" title="一、时序差分学习（Temporal Difference Learning）"></a>一、时序差分学习（Temporal Difference Learning）</h2><p>强化学习中常用时序差分学习来更新模型，<a href="https://kibazen.cn/qiang-hua-xue-xi-zhong-shi-xu-chai-fen-xue-xi/">时序差分学习</a>的一般流程是：</p><ol><li>模型根据获取到的状态 $s_t$ 决定采取动作 $a_t$ 。</li><li>环境在执行动作 $a_t$ 后会给出对应的奖励 $r_t$ 和新的状态 $s_{t+1}$ 。</li><li>根据 <strong>TD target</strong> 计算出 <strong>TD error</strong> ， 然后使用 <a href="https://en.wikipedia.org/wiki/Gradient_descent">梯度下降</a> 等方法更新模型来降低 <strong>TD error</strong> 的值。</li><li>回到1重复。</li></ol><h2 id="二、经验回放（Experience-Replay）"><a href="#二、经验回放（Experience-Replay）" class="headerlink" title="二、经验回放（Experience Replay）"></a>二、经验回放（Experience Replay）</h2><p>原始的时序差分学习在实际的应用中有两个缺点：</p><ol><li>经验浪费<br> 从上面的流程可以看出，经验 $(s_r, a_t, r_t, s_{t+1})$ 在使用一次后就会被丢掉。但是事实上，这些经验可以重复利用的。这也是需要做经验回放的主要原因。</li><li>经验相关性太强<br> 前后相邻的经验的相关性太强了。比如对游戏来说，上一帧的画面和下一帧的画面变化很小。实验证明这种相关性是有害的，不利于模型的训练。</li></ol><p>经验回放则可以有效的解决上面的两个缺点。</p><p>经验回放的原理就是只保留最近的 $n$ 条经验，每次训练时 <strong>随机均匀的</strong> 从这些经验中 <strong>不重复的</strong> 选取一条或多条经验来训练。</p><blockquote><p>$n$ 的大小通常在十万到百万之间，视情况而定。这个值对训练影响较大。<br>经验回放现在是深度强化学习的标准技巧之一。</p></blockquote><h2 id="三、优先经验回放（Prioritized-Experience-Replay）"><a href="#三、优先经验回放（Prioritized-Experience-Replay）" class="headerlink" title="三、优先经验回放（Prioritized Experience Replay）"></a>三、优先经验回放（Prioritized Experience Replay）</h2><p>对经验回放改进有很多，其中一个常见的是优先经验回放。</p><p>优先经验回放的原理是 <strong>用非均匀抽样代替均匀抽样</strong> 来抽取经验。</p><h3 id="3-1-经验的重要性不同"><a href="#3-1-经验的重要性不同" class="headerlink" title="3.1 经验的重要性不同"></a>3.1 经验的重要性不同</h3><p>模型在和环境交互时，获得的经验的重要性是不同的。</p><p>比如：在一个打怪升级的游戏中，大多数经验都是和小兵战斗，只有很少的经验是和BOSS战斗。这样就容易导致训练出来的模型容易战胜小兵，但是很难打赢BOSS。所以和BOSS战斗的经验比和小兵战斗的经验更为重要。</p><h3 id="3-2-经验的抽样概率"><a href="#3-2-经验的抽样概率" class="headerlink" title="3.2 经验的抽样概率"></a>3.2 经验的抽样概率</h3><p>对于越不熟悉的状态，模型预测出的 <strong>TD error</strong> 的绝对值就会越大，所以可以根据 <strong>TD error</strong> 的绝对值的大小来判断一条经验的重要性。即 <strong>TD error</strong> 的绝对值越大越重要。</p><p>将 <strong>TD error</strong> 对应到抽样概率的方式有两种：</p><ol><li><p>经验抽样的概率 $p_t$ 正比于 <strong>TD error</strong> $\delta_t$ 的绝对值加上一个很小的数 $\epsilon$ （避免概率为0）。</p><script type="math/tex; mode=display">p_t \propto \vert \delta_t \vert + \epsilon</script></li><li><p>将所有经验的 <strong>TD error</strong> 的绝对值进行排序，大的靠前，小的靠后。 经验抽样的概率反比于排序后经验所处的位置。</p><script type="math/tex; mode=display">p_t \propto \frac{1}{rank(t)}</script></li></ol><h3 id="3-3-调整学习率"><a href="#3-3-调整学习率" class="headerlink" title="3.3 调整学习率"></a>3.3 调整学习率</h3><p>因为抽样时是非均匀的，所以需要调整学习率来抵消不同抽样概率造成的偏差。</p><p>如果一条经验的抽样概率很大，那么它就会经常的被抽到用于更新模型，所以需要调小这条经验的学习率。反之亦然。</p><p>每条经验的学习率都需要乘以系数 $(n \cdot p_t)^{-\beta}$，其中 $n$ 是经验回放池中经验的总条数， $p_t$ 是每条经验的抽验概率， $\beta$ 是一个超参数，值在0到1之间， $\beta \in (0, 1)$。</p><p>对于均匀抽样来说，每条经验概率相同，$p_1 = \cdots = p_n = \frac{1}{n}$ ，学习率系数 $(n \cdot p_t)^{-\beta}$ 值的和为1。</p><p>对于非均匀抽样来说，抽样概率 $p_t$ 越大，学习率系数 $(n \cdot p_t)^{-\beta}$ 的值越小。论文中推荐开始时 $\beta$ 值很小，后面逐步增长到1。</p><h3 id="3-4-实现细节"><a href="#3-4-实现细节" class="headerlink" title="3.4 实现细节"></a>3.4 实现细节</h3><p>需要将所有的经验 $(s_r, a_t, r_t, s_{t+1})$ 都计算出对应的 <strong>TD error</strong>。</p><p>对于刚刚收集到的经验，可以将其 <strong>TD error</strong> 的值设置为最大值。</p><p>每次使用经验后都需要更新对应的 <strong>TD error</strong> 。</p><hr><blockquote><p>参考：<a href="https://www.youtube.com/watch?v=rhslMPmj7SY&amp;list=PLvOO0btloRntS5U8rQWT9mHFcUdYOUmIC&amp;ab_channel=ShusenWang">Experience Replay</a><br>经验回放论文：<a href="http://isl.anthropomatik.kit.edu/pdf/Lin1993.pdf">Reinforcement Learning for Robots Using Neural Networks</a><br>优先经验回放论文：<a href="https://arxiv.org/abs/1511.05952">Prioritized Experience Replay</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时序差分学习 </tag>
            
            <tag> 经验回放 </tag>
            
            <tag> 优先经验回放 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习中时序差分学习</title>
      <link href="qiang-hua-xue-xi-zhong-shi-xu-chai-fen-xue-xi/"/>
      <url>qiang-hua-xue-xi-zhong-shi-xu-chai-fen-xue-xi/</url>
      
        <content type="html"><![CDATA[<p>在<a href="https://kibazen.cn/li-jie-meng-te-qia-luo-fang-fa-he-shi-xu-chai-fen-xue-xi/">理解蒙特卡洛方法和时序差分学习</a>一文中已经对时序差分学习进行了直观上的解释，本文中将具体的描述时序差分学习的数学推导过程及在强化学习中的应用。</p><h2 id="一、时序差分学习的数学推导"><a href="#一、时序差分学习的数学推导" class="headerlink" title="一、时序差分学习的数学推导"></a>一、时序差分学习的数学推导</h2><p>根据折扣回报（Discounted Return）的定义，有：</p><script type="math/tex; mode=display">\begin{aligned}G_t& = R_t + \gamma \cdot R_{t+1} + \gamma^2 \cdot R_{t+2} + \gamma^3 \cdot R_{t+3} + \cdots \\& = R_t + \gamma \cdot (R_{t+1} + \gamma \cdot R_{t+2} + \gamma^2 \cdot R_{t+3} + \cdots) \\& = R_t + \gamma \cdot G_{t+1}\end{aligned}</script><p>根据动作价值函数（Action-value function）的定义，有：</p><script type="math/tex; mode=display">\begin{aligned}Q_{\pi}(s_t, a_t)& = \mathbb{E}[G_t | s_t, a_t] \\& = \mathbb{E}[R_t + \gamma \cdot G_{t+1} | s_t, a_t] \\& = \mathbb{E}[R_t | s_t, a_t] + \gamma \cdot \mathbb{E}[G_{t+1} | s_t, a_t] \\& = \mathbb{E}[R_t | s_t, a_t] + \gamma \cdot \mathbb{E}[Q_{\pi}(S_{t+1}, A_{t+1}) | s_t, a_t] \\& = \mathbb{E}[R_t + \gamma \cdot Q_{\pi}(S_{t+1}, A_{t+1})] \\\end{aligned}</script><p>即，对所有的策略 $\pi$ 都有如下的等式：</p><script type="math/tex; mode=display">Q_{\pi}(s_t, a_t) = \mathbb{E}[R_t + \gamma \cdot Q_{\pi}(S_{t+1}, A_{t+1})], \text{ for all }\pi</script><p>直接求 $R_t + \gamma \cdot Q_{\pi}(S_{t+1}, A_{t+1})$ 的期望很困难，可以对期望做蒙特卡洛（Monte Carlo）近似，即：</p><ul><li>使用真实的奖励值 $r_t$ 来近似 $R_t$。</li><li>使用真实的Q值 $Q_{\pi}(s_{t+1}, a_{t+1})$ 来近似 $Q_{\pi}(S_{t+1}, A_{t+1})$ 。</li></ul><p>所以：</p><script type="math/tex; mode=display">\begin{aligned}Q_{\pi}(s_t, a_t)& = \mathbb{E}[R_t + \gamma \cdot Q_{\pi}(S_{t+1}, A_{t+1})] \\& \approx r_t + \gamma \cdot Q_{\pi}(s_{t+1}, a_{t+1}) \\\end{aligned}</script><p>结论：</p><ol><li>常将 $r_t + \gamma \cdot Q_{\pi}(s_{t+1}, a_{t+1})$ 的值记作 $y_t$ 。</li><li>因为 $y_t$ 中包含了真实的奖励值 $r_t$ ，所以认为 $y_t$ 比 $Q_{\pi}(s_t, a_t)$ 更准确。</li><li>将 $y_t$ 命名为 <strong>TD target</strong>，而将 $y_t - Q_{\pi}(s_t, a_t)$ 的值命名为 <strong>TD error</strong>。</li><li><strong>TD error</strong> 的绝对值越小，就表明模型预测误差越小，预测的结果越准确。所以，在确定好 <strong>TD error</strong> 的计算方式后，可以通过 <strong>梯度下降</strong> 方法来更新模型的参数，降低 <strong>TD error</strong> 。</li><li>时序差分学习的目的是让模型预测出的 $Q_{\pi}(s_t, a_t)$ 值不断的接近<strong>TD target</strong> 。</li></ol><h2 id="二、Sarsa算法"><a href="#二、Sarsa算法" class="headerlink" title="二、Sarsa算法"></a>二、Sarsa算法</h2><blockquote><p>Sarsa是State–action–reward–state–action这几个单词的缩写。</p></blockquote><p><a href="#一时序差分学习的数学推导">时序差分学习</a>的一个应用就是Sarsa算法，Sarsa算法的目的就是使用神经网络 $Q(s,a)$ 去逼近 <strong>动作价值函数（action-value function）$Q_{\pi}(s,a)$</strong> 。</p><p>Sarsa算法的<strong>TD target</strong>为 $y_t = r_t + \gamma \cdot Q(s_{t+1}, a_{t+1})$ 。</p><h2 id="三、Q-Learning算法的数学推导"><a href="#三、Q-Learning算法的数学推导" class="headerlink" title="三、Q-Learning算法的数学推导"></a>三、Q-Learning算法的数学推导</h2><p>在<a href="#一时序差分学习的数学推导">时序差分学习的数学推导</a>中得到了，对所有的策略 $\pi$ 都有如下的等式：</p><script type="math/tex; mode=display">Q_{\pi}(s_t, a_t) = \mathbb{E}[R_t + \gamma \cdot Q_{\pi}(S_{t+1}, A_{t+1})], \text{ for all }\pi</script><p>对最优策略 ${\pi}_*$ 也成立，所以：</p><script type="math/tex; mode=display">Q_*(s_t, a_t) = \mathbb{E}[R_t + \gamma \cdot Q_*(S_{t+1}, A_{t+1})]</script><blockquote><p><script type="math/tex">Q_{\pi_*}(s_t, a_t)</script> 可以简写为 <script type="math/tex">Q_*(s_t, a_t)</script> ，都可以表示最优动作价值函数。</p></blockquote><p>因为最优动作价值函数总是采用最优的动作：</p><script type="math/tex; mode=display">A_{t+1} = \underset{a}{\operatorname{argmax}}Q_*(S_{t+1}, a)</script><p>所以：</p><script type="math/tex; mode=display">Q_*(S_{t+1}, A_{t+1}) = \max_a Q_* (S_{t+1}, a)</script><p>即：</p><script type="math/tex; mode=display">\begin{aligned}Q_*(s_t, a_t)& = \mathbb{E}[R_t + \gamma \cdot Q_*(S_{t+1}, A_{t+1})] \\& = \mathbb{E}[R_t + \gamma \cdot \underset{a}{\operatorname{max}} Q_* (S_{t+1}, a)] \\\end{aligned}</script><p>直接求 $R_t + \gamma \cdot \underset{a}{\operatorname{max}} Q_* (S_{t+1}, a)$ 的期望很困难，可以对期望做蒙特卡洛（Monte Carlo）近似，即：</p><ul><li>使用真实的奖励值 $r_t$ 来近似 $R_t$。</li><li>使用真实的Q值 <script type="math/tex">\underset{a}{ \operatorname{max} } Q_*(s_{t+1}, a)</script> 来近似 <script type="math/tex">\underset{a}{ \operatorname{max} } Q_*(S_{t+1}, a)</script> 。</li></ul><p>所以：</p><script type="math/tex; mode=display">\begin{aligned}Q_*(s_t, a_t)& = \mathbb{E}[R_t + \gamma \cdot \underset{a}{\operatorname{max}} Q_* (S_{t+1}, a)] \\& \approx r_t + \gamma \cdot \underset{a}{\operatorname{max}} Q_*(s_{t+1}, a) \\\end{aligned}</script><h2 id="四、Q-Learning算法"><a href="#四、Q-Learning算法" class="headerlink" title="四、Q-Learning算法"></a>四、Q-Learning算法</h2><p><a href="#三q-learning算法的数学推导">时序差分学习</a>的另一个应用就是Q-Learning算法，Q-Learning算法的目的就是使用神经网络 $Q(s,a)$ 去逼近 <strong>最优动作价值函数（optimal action-value function）<script type="math/tex">Q_*(s,a)</script></strong> 。</p><p>Q-Learning算法的<strong>TD target</strong>为 <script type="math/tex">y_t = r_t + \gamma \cdot \underset{a}{\operatorname{max}} Q_*(s_{t+1}, a)</script> 。</p><hr><blockquote><p>参考：<a href="https://www.youtube.com/watch?v=-cYWdUubB6Q&amp;list=PLvOO0btloRnvWZCkAUrBbVB5ZjDI2hUAM&amp;ab_channel=ShusenWang">TD Learning</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时序差分学习 </tag>
            
            <tag> Sarsa算法 </tag>
            
            <tag> Q-Learning算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解蒙特卡洛方法和时序差分学习</title>
      <link href="li-jie-meng-te-qia-luo-fang-fa-he-shi-xu-chai-fen-xue-xi/"/>
      <url>li-jie-meng-te-qia-luo-fang-fa-he-shi-xu-chai-fen-xue-xi/</url>
      
        <content type="html"><![CDATA[<p>学习机器学习时常常会用到蒙特卡洛方法和时序差分学习，所以对它们有一个直观的理解还是很重要的。本文通过举一个实际的例子来帮助理解。</p><p>假如要训练一个预估开车从成都到北京需要耗时多久的模型（Model），那么如何训练呢？</p><div id="flowchart-0" class="flow-chart"></div><h2 id="1-蒙特卡洛方法（Monte-Carlo-method）"><a href="#1-蒙特卡洛方法（Monte-Carlo-method）" class="headerlink" title="1. 蒙特卡洛方法（Monte Carlo method）"></a>1. 蒙特卡洛方法（Monte Carlo method）</h2><p>最直观的方法，既然要预估开车从成都到北京需要耗时多久，那么可以直接记录开车从成都到北京所需要的时间。然后重复很多次，比如100次，把每次的耗时都给模型学习（至于模型具体怎么学习，又需要另外的算法了，比如：<a href="https://en.wikipedia.org/wiki/Gradient_descent">梯度下降</a>），这样模型就能预估出一个比较准确的时间了。</p><p>上面这种方法其实就是<a href="https://en.wikipedia.org/wiki/Monte_Carlo_method">蒙特卡洛方法</a>。这种算法的特点如下：</p><p>优点：</p><ul><li><strong>简单直接</strong>：要预估开车从成都到北京需要耗时多久，那直接做很多次，并记录经验，然后就能比较准确的训练了。</li></ul><p>缺点：</p><ul><li><strong>收集数据麻烦</strong>：直接尝试还是很麻烦的，代价太高。如果要训练一个预测手术成功率的模型，总不能拿人去试吧。</li><li><strong>需要等到完整的一次过程后才能开始训练</strong>：开车到一半时是不能训练模型的，必须要到了目的地才能训练。如果路上车出了故障，那么之前开的路都白费了，代价也太高了。</li></ul><p>第一个缺点不好解决，但是第二个缺点还是有办法改善的，那就是使用<a href="#2-时序差分学习temporal-difference-learning">时序差分学习</a>。</p><h2 id="2-时序差分学习（Temporal-Difference-Learning）"><a href="#2-时序差分学习（Temporal-Difference-Learning）" class="headerlink" title="2. 时序差分学习（Temporal Difference Learning）"></a>2. 时序差分学习（Temporal Difference Learning）</h2><p>时序差分学习的概念不是那么容易解释，但是可以通过更实际的例子来理解：</p><p>开始时模型预估开车从成都到北京需要花100个小时。</p><div id="flowchart-1" class="flow-chart"></div><p>实际开车从成都出发，实际花费了30个小时到西安，此时模型预估到北京还是60个小时。</p><div id="flowchart-2" class="flow-chart"></div><p>所以模型在开始时更准确的预估应该是：</p><p>30小时（成都到西安的<strong>实际时间</strong>）+ 60小时（新的<strong>预估时间</strong>）= 90小时</p><p>在时序差分学习中，这个更准确的估计就叫做 <strong>TD target</strong> 。有了这个更准确预估后，就知道开始时的预估时间是多了还是少了，从而就能更新模型的参数让模型的预估越来越准确。这样就能够做到不做完整件事就开始训练模型了。</p><p>而最初的预估时间和 <strong>TD target</strong> 的差值就是 <strong>TD error</strong>：</p><p><strong>TD error</strong> = 100小时(开始时的预估耗时） - 90小时（<strong>TD error</strong>） = 10小时</p><p>时序差分学习的目标就是让 <strong>TD error</strong> 的值接近0。</p><hr><blockquote><p>参考：<a href="https://www.youtube.com/watch?v=jflq6vNcZyA&amp;t=1344s&amp;ab_channel=ShusenWang">Value-Based Reinforcement Learning</a></p><p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">cd=&gt;start: 成都bj=&gt;end: 北京cd-&gt;bj</textarea><textarea id="flowchart-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><textarea id="flowchart-1-code" style="display: none">cd=&gt;start: 成都bj=&gt;end: 北京（模型预估需100小时）cd-&gt;bj</textarea><textarea id="flowchart-1-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-1", options);</script><textarea id="flowchart-2-code" style="display: none">cd=&gt;start: 成都xa=&gt;end: 西安（实际开车花费30小时）bj=&gt;end: 北京（模型预估还需60小时）cd-&gt;xa-&gt;bj</textarea><textarea id="flowchart-2-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-2-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-2-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-2", options);</script></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时序差分学习 </tag>
            
            <tag> 蒙特卡洛方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解强化学习中的基本概念</title>
      <link href="li-jie-qiang-hua-xue-xi-zhong-de-ji-ben-gai-nian/"/>
      <url>li-jie-qiang-hua-xue-xi-zhong-de-ji-ben-gai-nian/</url>
      
        <content type="html"><![CDATA[<h2 id="一、随机变量"><a href="#一、随机变量" class="headerlink" title="一、随机变量"></a>一、随机变量</h2><p>变量的值无法预先确定仅以一定的可能性（概率）取值的量。</p><p>强化学习中一般用大写的字母表示随机变量，用小写的字母表示随机变量的观测值（确定的值）。</p><blockquote><p>比如：掷骰子中，用大写的变量 $X$ 表示可能掷出来骰子的值。假如掷一次骰子，得到它的值是2点，可以用小写的变量 $x$ 来表示，即 $x = 2$ 。</p></blockquote><p>随机变量分两种基本的类型：离散型随机变量和连续型随机变量。</p><blockquote><p>强化学习中训练不同类型的变量一般需要使用不同类型的算法，只有少部分算法同时支持两种类型的变量训练。<br>训练离散型随机变量使用的损失函数一般是交叉熵（Cross Entropy），而训练连续型随机变量使用的损失函数一般是均方误差（MSE, Mean Squared Error）。</p></blockquote><h2 id="二、概率密度函数（Probability-Density-Function，PDF）"><a href="#二、概率密度函数（Probability-Density-Function，PDF）" class="headerlink" title="二、概率密度函数（Probability Density Function，PDF）"></a>二、概率密度函数（Probability Density Function，PDF）</h2><p>描述随机变量的输出值，物理意义为随机变量在某个确定的取值点附近的可能性。</p><blockquote><p>比如：掷骰子的概率密度函数 $p(X) = \frac{1}{6}$ 。<br>强化学习中的策略 $\pi$ 就是一个概率密度函数。因为它输出的其实是各个动作的概率。</p></blockquote><p>因为概率的总和总是1，所以：</p><ol><li>对于离散型随机变量 $X$ 及其可能值的集合 $\mathcal{X}$ 有：<script type="math/tex; mode=display">\sum_{x \in \mathcal{X}} p(x) = 1</script></li><li>对于连续型随机变量 $X$ 及其可能值的域 $\mathcal{X}$ 有：<script type="math/tex; mode=display">\int_{\mathcal{X}} p(x) \mathrm{d}x = 1</script></li></ol><h2 id="三、期望"><a href="#三、期望" class="headerlink" title="三、期望"></a>三、期望</h2><p>随机变量值产生的概率乘以随机变量值的总和。期望反应了随机变量平均取值的大小。</p><ol><li>对于离散型随机变量 $X$ 及其可能值的集合 $\mathcal{X}$ ，其期望公式为：<script type="math/tex; mode=display">\mathbb{E}[f(X)] = \sum_{x \in \mathcal{X}} p(x) \cdot f(x)</script></li><li>对于连续型随机变量 $X$ 及其可能值的域 $\mathcal{X}$ ，其期望公式为：<script type="math/tex; mode=display">\mathbb{E}[f(X)] = \int_{x \in \mathcal{X}} p(x) \cdot f(x) \mathrm{d}x</script></li></ol><h2 id="四、强化学习模型"><a href="#四、强化学习模型" class="headerlink" title="四、强化学习模型"></a>四、强化学习模型</h2><p><img src="/images/理解强化学习中的基本概念/强化学习模型.jpg" alt="强化学习模型"></p><p>模型的构成：</p><ol><li><p>智能体（Agent）<br> 从环境中观测到状态（state）并执行某个动作（action）的对象。</p><blockquote><p>比如在马里奥游戏中，我们控制的马里奥角色就是智能体；在赛车游戏中，我们控制的赛车就是智能体。</p></blockquote><p> 与智能体紧密相关的概念是策略 $\pi$ 。 策略 $\pi$ 用来控制智能体，它的输入就是智能体观测到的状态，然后输出各个动作的概率。智能体执行的动作就是从这些动作概率中抽取出来的。策略 $\pi$ 其实就是一个概率密度函数，其数学定义为：</p><script type="math/tex; mode=display">\pi(a|s) = \mathbb{P}(A = a | S = s)</script></li><li><p>动作（Actios）<br> 与环境交互时可以采取的动作的集合。</p><blockquote><p>比如在马里奥游戏中，可以采取的动作有：向左走、向右走、向上跳。</p></blockquote></li><li><p>环境（Environment）<br> 智能体所处的环境。</p><blockquote><p>比如在马里奥游戏中，就是指马里奥当前所处在的游戏环境。</p></blockquote></li><li><p>状态（State）<br> 智能体对环境的观测。</p><blockquote><p>比如在马里奥游戏中，游戏当前的画面就可以认为是环境当前的状态。</p></blockquote><p> 当智能体执行动作后，环境会进入到一个新的状态，这个就是状态转移的概念。状态转移的过程是随机的。这个随机性来自于两个方面：</p><ul><li>智能体执行的动作是随机的。智能体由策略 $\pi$ 控制的，策略 $\pi$ 输出的是各个动作的概率。执行的动作是从这些动作概率中抽取出来的，所以说执行的动作是随机的。</li><li><p>环境本身的变化也是随机的。即使每次智能体执行的都是相同的动作，环境也会随机的变化。</p><blockquote><p>比如在马里奥游戏中，即使每次都让马里奥向前走，但是游戏里的怪物总是会随机的移动，所以最后环境的状态也是随机的。</p></blockquote><p>状态转移的随机性用数学表示为：</p><script type="math/tex; mode=display">p(s\prime | s,a) = \mathbb{P}(S\prime = s\prime | S = s, A = a)</script></li></ul></li><li><p>奖励（Reward）<br> 智能体在环境中执行动作后获得的奖励或惩罚。</p><blockquote><p>比如在马里奥游戏中，吃到一个金币，就有金币奖励。</p></blockquote></li></ol><blockquote><p>关于智能体对环境的观测的表述。用 state 时表示智能体能观察到环境的所有内部状态，用 observation 时表示智能体不能观察到环境的所有内部状态。比如玩围棋时用 state ，玩扑克牌时用 observation （因为你看不到别人手中的牌）。</p></blockquote><p>交互的流程：</p><ol><li>智能体从环境观测到状态 $s_t$ 。</li><li>智能体根据获取到的状态 $s_t$ 决定下一步采取动作 $a_t$ 。</li><li>环境执行动作 $a_t$ 后转移到新的状态 $s_{t+1}$ ，并给出智能体执行动作获得的奖励 $r_t$ 。</li><li>回到第1步。</li></ol><blockquote><p>第3步中获得的奖励 $r_t$ ，一些资料中也记为 $r_{t+1}$ 。比如：<a href="https://www.youtube.com/watch?v=lfHX2hHRMVQ&amp;list=PLqYmG7hTraZDM-OYHWgPebj2MfCFzFObQ&amp;index=2&amp;ab_channel=DeepMind">RL Course by David Silver - Lecture 2: Markov Decision Process</a> 。</p></blockquote><h2 id="五、回报（Return）"><a href="#五、回报（Return）" class="headerlink" title="五、回报（Return）"></a>五、回报（Return）</h2><p>强化学习的目的是让智能体与环境交互时获得的奖励尽可能的多。</p><p>智能体从 $t$ 时刻开始到游戏结束获得的所有奖励 <strong>回报（Return，Cumulative Future Reward）</strong> 为：</p><script type="math/tex; mode=display">G_t = R_t + R_{t+1} + R_{t+2} + R_{t+3} + \cdots</script><p>考虑到未来的奖励不如现在的奖励有价值，我们给未来的奖励加一个折扣系数 $\gamma$ ，且 $\gamma \in [0, 1]$ 。</p><p>所以智能体从 $t$ 时刻开始到游戏结束获得的所有奖励 <strong>折扣回报（Discounted Return，Cumulative Discounted Future Reward）</strong> 为：</p><script type="math/tex; mode=display">G_t = R_t + \gamma \cdot R_{t+1} + \gamma^2 \cdot R_{t+2} + \gamma^3 \cdot R_{t+3} + \cdots</script><p>根据<a href="https://kibazen.cn/ma-er-ke-fu-he-bei-er-man-gong-shi-yi-ji-sheng-cheng-mo-shi/">马尔科夫回报过程</a>我们可以知道，折扣回报也是一个随机变量，原因如下：</p><ol><li>智能体采取的动作是一个随机变量：<script type="math/tex; mode=display">\mathbb{P}[A=a | S=s] = \pi(a|s)</script></li><li>环境状态的转移也是随机的：<script type="math/tex; mode=display">\mathbb{P}[S\prime = s\prime | S = s, A=a] = p(s\prime | s, a)</script></li></ol><p>而对于未来的任意时刻 $i \ge t$ ，奖励 $R_i$ 都依赖 $S_i$ 和 $A_i$ 。</p><blockquote><p>比如在马里奥游戏中，如果马里奥头上有一个金币，这个时候向上跳就能获得金币奖励，但是如果这时不向上跳或者向上跳时头上没有金币都不能获得金币奖励。</p></blockquote><p>所以，对某一个时刻 $t$ 的状态 $s_t$ 来说，折扣奖励 $G_t$ 依赖于未来所有的随机动作 $A_t, A_{t+1}, A_{t+2}, \cdots$ 和随机状态 $S_{t+1}, S_{t+2}, \cdots$ 。</p><p>折扣奖励 $G_t$ 定义了未来获取奖励的总和，机器学习的目的就是控制 agent 让 $G_t$ 的值越大越好。</p><h2 id="六、动作价值函数（Action-Value-Function）"><a href="#六、动作价值函数（Action-Value-Function）" class="headerlink" title="六、动作价值函数（Action-Value Function）"></a>六、动作价值函数（Action-Value Function）</h2><p>由于 $G_t$ 是随机变量，在 $t$ 时刻并不能计算出 $G_t$ 的值。但是为了便于评估 $t$ 时刻的形势，消除 $G_t$ 中的随机性，可以对 $G_t$ 求期望，将随机性都用积分积掉，可以得到一个实数。即：</p><script type="math/tex; mode=display">Q_{\pi}(s_t,a_t) = \mathbb{E}[G_t | S_t=s_t, A_t=a_t]</script><p>求期望得到的函数 $Q_{\pi}(s_t,a_t)$ 被称为动作价值函数。</p><p>把 $G_t$ 当做未来所有动作 $A$ 和所有状态 $S$ 的函数，除了 $a_t$ 和 $s_t$ ，其余的都用积分积掉。被积分积掉的变量包括 $A_{t+1}, A_{t+2}, \cdots$ 和 $S_{t+1}, S_{t+2}, \cdots$。</p><ol><li>动作的概率密度函数为：<script type="math/tex; mode=display">\mathbb{P}[A=a | S=s] = \pi(a|s)</script></li><li>状态转移的概率密度函数为：<script type="math/tex; mode=display">\mathbb{P}[S\prime = s\prime | S = s, A=a] = p(s\prime | s, a)</script></li></ol><p>函数 $Q_{\pi}(s_t,a_t)$ 和当前的状态 $s_t$ 和动作 $a_t$ 有关。 $a_t$ 和 $s_t$ 当作被观测到的值来处理，而不是随机变量。函数 $Q_{\pi}(s_t,a_t)$ 还有策略 $\pi$ 有关，因为积分时会用到策略 $\pi$ 。</p><p>动作价值函数的意义在于可以评估策略 $\pi$ 在状态 $s_t$ 时采取动作 $a_t$ 的期望回报。即，策略 $\pi$ 处在状态 $s_t$ 时，动作价值函数 $Q_{\pi}(s_t,a_t)$ 可以给动作 $a_t$ 打分，用来判断执行动作 $a$ 是否明智。</p><blockquote><p>就相当于你在打牌时有一个先知可以告诉你这次（仅一次）出每种牌后你赢钱的期望。</p></blockquote><h2 id="七、最优动作价值函数（Optimal-Action-Value-Function）"><a href="#七、最优动作价值函数（Optimal-Action-Value-Function）" class="headerlink" title="七、最优动作价值函数（Optimal Action-Value Function）"></a>七、最优动作价值函数（Optimal Action-Value Function）</h2><p>对函数 $Q_{\pi}(s_t,a_t)$ 做关于策略 $\pi$ 的最大化操作，就可以得到最优动作价值函数：</p><script type="math/tex; mode=display">Q_*(s_t,a_t) = \max_{\pi} Q_{\pi}(s_t,a_t)</script><blockquote><p><script type="math/tex">Q_*(s_t,a_t)</script> 是 <script type="math/tex">Q_{\pi_*}(s_t,a_t)</script> 的简写。</p></blockquote><p>最大化操作就是选取无数种策略中，让 $Q_{\pi}(s_t,a_t)$ 的值最大的那个策略 $\pi_*$ 。最优动作价值函数与策略 $\pi$ 无关，因为 $\pi$ 已经被最大化操作消除了。</p><p>最优动作价值函数的意义在于可以评估在状态 $s_t$ 时采取动作 $a_t$ 后最大能获得的期望回报。</p><blockquote><p>就相当于在打牌时有一把牌让世界上牌技最好的人来玩时出每种牌后赢钱的期望。</p></blockquote><h2 id="八、状态价值函数（State-Value-Function）"><a href="#八、状态价值函数（State-Value-Function）" class="headerlink" title="八、状态价值函数（State-Value Function）"></a>八、状态价值函数（State-Value Function）</h2><p>状态价值函数是动作价值函数关于动作的期望。</p><p>将动作 $A$ 视为随机变量，然后对动作价值函数 $Q_{\pi}(s_t,A)$ 关于动作 $A$ 求期望就可以得到状态价值函数：</p><script type="math/tex; mode=display">V_{\pi}(s_t) = \mathbb{E}_{A \sim \pi(\cdot | s_t)} [Q_{\pi}(s_t,A)]</script><p>状态价值函数 $V_{\pi}(s_t)$ 只与策略 $\pi$ 和状态 $s_t$ 有关。</p><p>状态价值函数可以反映策略 $\pi$ 处于状态 $s_t$ 时的优劣势。</p><blockquote><p>比如下围棋时，状态价值函数可以反映出当前的局面是快赢了还是快输了等。</p></blockquote><ol><li>如果动作是离散型随机变量，则：<script type="math/tex; mode=display">V_{\pi}(s_t) = \mathbb{E}_A[Q_{\pi}(s_t, A)] = \sum_a \pi(a | s_t) \cdot Q_{\pi}(s_t, a)</script></li><li>如果动作是连续型随机变量，则：<script type="math/tex; mode=display">V_{\pi}(s_t) = \mathbb{E}_A[Q_{\pi}(s_t, A)] = \int \pi(a | s_t) \cdot Q_{\pi}(s_t, a) \mathrm{d}x</script></li></ol><p>状态价值函数的意义在于可以评估策略 $\pi$ 处在状态 $s_t$ 时的期望回报。</p><blockquote><p>就相当于你在打牌时，你拿了一把牌，有一个先知可以告诉你你玩这把牌赢钱的期望。</p></blockquote><h2 id="九、最优状态价值函数（Optimal-State-Value-Function）"><a href="#九、最优状态价值函数（Optimal-State-Value-Function）" class="headerlink" title="九、最优状态价值函数（Optimal State-Value Function）"></a>九、最优状态价值函数（Optimal State-Value Function）</h2><p>对状态价值函数 $V_{\pi}(s_t)$ 做关于策略 $\pi$ 的最大化操作，就可以得到最优状态价值函数：</p><script type="math/tex; mode=display">V_*(s_t) = \max_{\pi} V_{\pi}(s_t)</script><blockquote><p><script type="math/tex">V_*(s_t)</script> 是 <script type="math/tex">V_{\pi_*}(s_t)</script> 的简写。</p></blockquote><p>最大化操作就是选取无数种策略中，让 $V_{\pi}(s_t)$ 的值最大的那个策略 $\pi_*$ 。最优状态价值函数与策略 $\pi$ 无关，因为 $\pi$ 已经被最大化操作消除了。</p><p>最优状态价值函数的意义在于可以评估在状态 $s_t$ 时最大能获得的期望回报。</p><blockquote><p>就相当于在打牌时有一把牌让世界上牌技最好的人来玩时赢钱的期望。</p></blockquote><h2 id="十、用强化学习玩游戏"><a href="#十、用强化学习玩游戏" class="headerlink" title="十、用强化学习玩游戏"></a>十、用强化学习玩游戏</h2><p>强化学习的目的就是学会如何控制智能体 ，让智能体基于当前的状态 $s$ 来做出相应的动作 $a$ ，争取能在未来获取尽量多的奖励。</p><p>强化学习通常要学习的是策略 $\pi(a|s)$ 或者最优动作价值函数 $Q_*(s, a)$，当有了这两个中的一个，就可以控制智能体自动的玩游戏了。</p><h3 id="1-假如有一个好的策略"><a href="#1-假如有一个好的策略" class="headerlink" title="1. 假如有一个好的策略"></a>1. 假如有一个好的策略</h3><ol><li>输入观测到的状态 $s_t$ 给策略 $\pi(a|s)$ ，它会返回不同动作的概率。</li><li>根据策略 $\pi(a|s)$ 返回的这些概率采样得到一个动作 $a_t$。</li><li>让环境执行动作 $a_t$ ，得到新的状态 $s_{t+1}$和奖励 $r_t$。</li><li>回到第1步。</li></ol><blockquote><p>好的策略相当于一个牌技好的人，牌技好的人赢钱的期望总是高。</p></blockquote><p>所以我们直接训练出一个好的策略就可以了。</p><p>这种直接训练策略的方式就是强化学习中的 <strong>基于策略的学习（Policy Based Learning）</strong> 。</p><h3 id="2-假如有最优动作价值函数"><a href="#2-假如有最优动作价值函数" class="headerlink" title="2. 假如有最优动作价值函数"></a>2. 假如有最优动作价值函数</h3><ol><li>根据观测到的状态 $s_t$ 和最优动作价值函数 $Q_*(s_t,a_t)$ 计算出能够获得最大期望奖励的动作<script type="math/tex; mode=display">a_t = \underset{a \in A}{\operatorname{argmax}} \; Q_*(s_t,a)</script></li><li>让环境执行动作 $a_t$ ，得到新的状态 $s_{t+1}$ 和奖励 $r_t$。</li><li>回到第1步。</li></ol><blockquote><p>最优动作价值函数 $Q_*(s_t,a_t)$ 相当于一个先知，可以告诉我们出每种牌赢钱的期望，只要我们每次都出赢钱期望最大的牌，那么最后赢钱的期望就会最高。</p></blockquote><p>所以我们也可以训练出一个先知，即最优动作价值函数。</p><p>这种训练最优动作价值函数的方式就是强化学习中的 <strong>基于价值的学习（Value Based Learning）</strong> 。</p><h2 id="十一、熵"><a href="#十一、熵" class="headerlink" title="十一、熵"></a>十一、熵</h2><ol><li><p>信息熵<br> 表达随机变量所需的平均信息量。即 <strong>从不了解到了解一件事所需要的最小信息量。</strong></p></li><li><p>交叉熵<br> 一种分布描述另一种分布所需要的信息量。</p></li><li><p>KL 散度</p><script type="math/tex; mode=display">KL 散度 = 交叉熵 - 信息熵</script></li></ol><hr><blockquote><p>参考：<a href="https://www.youtube.com/watch?v=vmkRMvhCW5c&amp;list=PLvOO0btloRnsiqM72G4Uid0UWljikENlU&amp;ab_channel=ShusenWang">Deep Reinforcement Learning</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随机变量 </tag>
            
            <tag> 概率密度函数 </tag>
            
            <tag> 强化学习模型 </tag>
            
            <tag> 动作价值函数 </tag>
            
            <tag> 状态价值函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>马尔可夫和贝尔曼公式以及生成模式</title>
      <link href="ma-er-ke-fu-he-bei-er-man-gong-shi-yi-ji-sheng-cheng-mo-shi/"/>
      <url>ma-er-ke-fu-he-bei-er-man-gong-shi-yi-ji-sheng-cheng-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、马尔可夫"><a href="#一、马尔可夫" class="headerlink" title="一、马尔可夫"></a>一、马尔可夫</h2><p>环境的状态必须是全部能够获取的（fully observable），即环境的 <strong>observation</strong> 就是 <strong>state</strong>。</p><h3 id="1-马尔可夫性（Markov-Property）"><a href="#1-马尔可夫性（Markov-Property）" class="headerlink" title="1. 马尔可夫性（Markov Property）"></a>1. 马尔可夫性（Markov Property）</h3><p>环境的下一个状态只由当前的的状态决定，与过去无关。</p><script type="math/tex; mode=display">\mathbb{P}[S_{t+1}|S_t] = \mathbb{P}[S_{t+1} | S_1, \ldots, S_t]</script><p>比如下棋，只用关心当前的局面，不用管过去操作。</p><h3 id="2-状态转移矩阵（State-Transition-matrix）"><a href="#2-状态转移矩阵（State-Transition-matrix）" class="headerlink" title="2. 状态转移矩阵（State Transition matrix）"></a>2. 状态转移矩阵（State Transition matrix）</h3><p>环境从一个状态转化成另一个状态的概率组成的矩阵。</p><script type="math/tex; mode=display">P_{ss\prime} = \mathbb{P}[S_{t+1}=s\prime | S_t=s] \tag{2}</script><p><strong>公式2</strong> 表示马尔可夫状态 $s$ 转移到其后继状态 $s\prime$ 的概率为 $P_{ss\prime}$，而状态转移矩阵则表示对于所有状态转移到其所有后继状态的概率，如下：</p><script type="math/tex; mode=display">P =\left[\begin{matrix}P_{11} & \cdots & P_{1n} \\\vdots & \ddots & \vdots \\P_{n1} & \cdots & P_{nn} \\\end{matrix}\right]</script><blockquote><p>$P$ 中任意行的值的和为1。</p></blockquote><h3 id="3-马尔可夫过程（Markov-Process-MP）"><a href="#3-马尔可夫过程（Markov-Process-MP）" class="headerlink" title="3. 马尔可夫过程（Markov Process, MP）"></a>3. 马尔可夫过程（Markov Process, MP）</h3><p>若环境状态变化的过程满足马尔可夫性，则称为马尔可夫过程。马尔可夫过程（或者马尔可夫链）由一个二元组 $\lt S, P \gt$ 定义。其中：</p><ul><li>$S$ 表示环境所有可能状态的有限集合</li><li>$P$ 表示这些状态之间转移概率的矩阵 <script type="math/tex">P_{ss\prime} = \mathbb{P}[S_{t+1}=s\prime | S_t=s]</script></li></ul><h3 id="4-马尔可夫链（Markov-Chain）"><a href="#4-马尔可夫链（Markov-Chain）" class="headerlink" title="4. 马尔可夫链（Markov Chain）"></a>4. 马尔可夫链（Markov Chain）</h3><p>马尔可夫过程下产生的有限状态的集合。</p><h3 id="5-马尔科夫回报过程（Markov-Reward-Process-MRP）"><a href="#5-马尔科夫回报过程（Markov-Reward-Process-MRP）" class="headerlink" title="5. 马尔科夫回报过程（Markov Reward Process, MRP）"></a>5. 马尔科夫回报过程（Markov Reward Process, MRP）</h3><p>包含 <strong>价值（values）</strong> 的马尔可夫链就是马尔科夫回报过程，由一个四元组 $\lt S, P, R, \gamma \gt$ 定义。其中：</p><ul><li>$S$ 表示环境所有可能状态的有限集合</li><li>$P$ 表示这些状态之间转移概率的矩阵 <script type="math/tex">P_{ss\prime} = \mathbb{P}[S_{t+1}=s\prime | S_t=s]</script></li><li><strong>$R$ 表示回报计算函数 <script type="math/tex">R_s = \mathbb{E}[R_{t+1} | S_t=s]</script></strong></li><li><strong>$\gamma$ 衰减系数（Discount factor），$\gamma \in [0, 1]$</strong></li></ul><h4 id="5-1-回报（Return）"><a href="#5-1-回报（Return）" class="headerlink" title="5.1 回报（Return）"></a>5.1 回报（Return）</h4><p>从时刻 $t$ 开始所有的折扣回报之和</p><script type="math/tex; mode=display">G_t = R_{t+1} + \gamma R_{t+2} + \cdots = \sum_{k=0} ^{\infty} \gamma^k R_{t+k+1}</script><h4 id="5-2-衰减系数（Discount-factor）"><a href="#5-2-衰减系数（Discount-factor）" class="headerlink" title="5.2 衰减系数（Discount factor）"></a>5.2 衰减系数（Discount factor）</h4><p>存在的原因：</p><ul><li>数学表达更方便</li><li>避免陷入循环</li><li>长远的利益具有不确定性</li></ul><p>意义：</p><ul><li>值越接近0表示越看重当前的利益</li><li>值越接近1表示越看重长远的利益</li></ul><h3 id="5-3-状态价值函数（Value-Function）"><a href="#5-3-状态价值函数（Value-Function）" class="headerlink" title="5.3 状态价值函数（Value Function）"></a>5.3 状态价值函数（Value Function）</h3><p>状态价值函数用于计算从状态 $s$ 开始的期望回报</p><script type="math/tex; mode=display">v(s) = \mathbb{E}[G_t | S_t=s]</script><h3 id="5-4-贝尔曼方程（Bellman-Equation）"><a href="#5-4-贝尔曼方程（Bellman-Equation）" class="headerlink" title="5.4 贝尔曼方程（Bellman Equation）"></a>5.4 贝尔曼方程（Bellman Equation）</h3><script type="math/tex; mode=display">\begin{aligned}v(s)& = \mathbb{E}[G_t | S_t = s] \\& = \mathbb{E}[R_{t+1} + \gamma R_{t+2} + {\gamma}^2 R_{t+3} + \cdots | S_t = s] \\& = \mathbb{E}[R_{t+1} + \gamma(R_{t+2} + \gamma R_{t+3} + \cdots) | S_t = s] \\& = \mathbb{E}[R_{t+1} + \gamma G_{t+1} | S_t = s] \\& (注意 v(S_{t+1}) 是大写的 S_{t+1} 是因为 S_t = s 的下一个状态是随机的) \\& = \mathbb{E}[R_{t+1} + \gamma v(S_{t+1}) | S_t = s] \\& (分别对 R_{t+1} 和 v(S_{t+1}) 求期望，和的期望等于期望的和) \\& = \mathbb{E}[R_{t+1} | S_t = s] + \gamma \mathbb{E}[v(S_{t+1}) | S_t = s] \\& (如果已知状态转移矩阵 P ，则可以将上式展开) \\& = R_s + \gamma \sum_{s\prime \in S} P_{ss\prime} v(s\prime) \\\end{aligned}</script><p>即：</p><script type="math/tex; mode=display">v(s) = R_s + \gamma \sum_{s\prime \in S} P_{ss\prime} v(s\prime)</script><p>对应的矩阵形式的方程为：</p><script type="math/tex; mode=display">v = R + \gamma Pv</script><script type="math/tex; mode=display">\left[\begin{matrix}v(1) \\\vdots \\v(n) \\\end{matrix}\right] = \left[\begin{matrix}R_{1} \\\vdots \\R_{n} \\\end{matrix}\right] + \gamma \left[\begin{matrix}P_{11} & \cdots & P_{1n} \\\vdots & \ddots & \vdots \\P_{n1} & \cdots & P_{nn} \\\end{matrix}\right] \left[\begin{matrix}v(1) \\\vdots \\v(n) \\\end{matrix}\right]</script><blockquote><p>其中 $R_{t+1}$ 是立即回报， $\gamma v(S_{t+1})$ 是后续状态的折扣值函数</p></blockquote><h3 id="5-5-贝尔曼方程的求解方法"><a href="#5-5-贝尔曼方程的求解方法" class="headerlink" title="5.5 贝尔曼方程的求解方法"></a>5.5 贝尔曼方程的求解方法</h3><ol><li><p>直接求解</p><script type="math/tex; mode=display"> \begin{aligned} v &= R + \gamma Pv \\ (I - \gamma P)v &= R \\ v &= (I - \gamma P)^{-1} R \\ \end{aligned}</script><p> 问题：复杂度太高 $O(n^3)$，n为状态的数量</p></li><li><p>迭代求解</p><ul><li>动态规划（Dynamic programming）</li><li>蒙地卡罗评估（Monte-Carlo evaluation）</li><li>时序差分学习（Temporal-Difference learning）</li></ul></li></ol><h3 id="6-马尔科夫决策过程（Markov-Decision-Process-MDP）"><a href="#6-马尔科夫决策过程（Markov-Decision-Process-MDP）" class="headerlink" title="6. 马尔科夫决策过程（Markov Decision Process, MDP）"></a>6. 马尔科夫决策过程（Markov Decision Process, MDP）</h3><p>包含 <strong>决策（decisions）</strong> 的马尔科夫回报过程就是马尔科夫决策过程，由一个五元组 $\lt S, A, P, R, \gamma \gt$ 定义。其中：</p><ul><li>$S$ 表示环境所有可能状态的有限集合</li><li><strong>$A$ 表示有限的动作集合</strong></li><li><strong>$P$ 表示这些状态之间转移概率的矩阵 <script type="math/tex">P_{ss\prime}^a = \mathbb{P}[S_{t+1}=s\prime | S_t=s, A_t=a]</script></strong></li><li><strong>$R$ 表示回报计算函数 <script type="math/tex">R_s^a = \mathbb{E}[R_{t+1} | S_t=s, A_t=a]</script></strong></li><li>$\gamma$ 衰减系数（Discount factor），$\gamma \in [0, 1]$</li></ul><h4 id="6-1-策略（Policy）"><a href="#6-1-策略（Policy）" class="headerlink" title="6.1 策略（Policy）"></a>6.1 策略（Policy）</h4><p>策略 $\pi$ 是状态 $s$ 时可能执行的动作 $a$ 的概率分布</p><script type="math/tex; mode=display">\pi (a|s) = \mathbb{P}[A_t=a | S_t=s]</script><p>当给定马尔科夫决策过程 $\lt S,A,P,R,\gamma \gt$ 和策略 $\pi$ 时：</p><ul><li>状态序列 $S_1, S_2, \ldots$ 就是一个马尔可夫过程 $\lt S,P^{\pi} \gt$</li><li>状态回报序列 $S_1, R_2, S_2, \ldots$ 就是一个马尔科夫回报过程 $\lt S, P^{\pi}, R^{\pi}, \gamma \gt$</li></ul><p>其中：</p><script type="math/tex; mode=display">P_{s,s\prime}^{\pi} = \sum_{a \in A}\pi(a|s) P_{s,s\prime}^a</script><script type="math/tex; mode=display">R_s^{\pi} = \sum_{a \in A}\pi(a|s) R_s^a</script><h4 id="6-2-基于策略的状态价值函数"><a href="#6-2-基于策略的状态价值函数" class="headerlink" title="6.2 基于策略的状态价值函数"></a>6.2 基于策略的状态价值函数</h4><p>马尔科夫决策过程中，基于策略 $\pi$ 的 <strong>状态</strong> 价值函数用于计算从状态 $s$ 开始，遵循策略 $\pi$ 时的期望回报</p><script type="math/tex; mode=display">v_{\pi}(s) = \mathbb{E}[G_t | S_t=s]</script><h4 id="6-3-基于策略的动作价值函数"><a href="#6-3-基于策略的动作价值函数" class="headerlink" title="6.3 基于策略的动作价值函数"></a>6.3 基于策略的动作价值函数</h4><p>马尔科夫决策过程中，基于策略 $\pi$ 的 <strong>动作</strong> 价值函数用于计算从状态 $s$ 开始，先采取动作 $a$，再遵循策略 $\pi$ 时的期望回报</p><script type="math/tex; mode=display">q_{\pi}(s,a) = \mathbb{E}_{\pi}[G_t | S_t=s, A_t=a]</script><h4 id="6-4-贝尔曼期望方程（Bellman-Expectation-Equation）"><a href="#6-4-贝尔曼期望方程（Bellman-Expectation-Equation）" class="headerlink" title="6.4 贝尔曼期望方程（Bellman Expectation Equation）"></a>6.4 贝尔曼期望方程（Bellman Expectation Equation）</h4><ol><li><p>基于策略的 <strong>状态</strong> 价值函数的贝尔曼方程可以分解为 <strong>立即回报</strong> 与 <strong>后续状态的折扣回报</strong> 的和</p><script type="math/tex; mode=display">v_{\pi}(s) = \mathbb{E}[R_{t+1} + \gamma v_{\pi}(S_{t+1}) | S_t=s]</script><p> 对应的矩阵形式的方程为：</p><script type="math/tex; mode=display">v_{\pi} = R^{\pi} + \gamma P^{\pi} v_{\pi}</script><script type="math/tex; mode=display">v_{\pi} = (I - \gamma P^{\pi})^{-1} R^{\pi}</script><p> 同时，状态 $s$ 的价值也可以通过计算在遵循策略 $\pi$ 时采取所有可能 <strong>动作的价值</strong> 与对应 <strong>动作发生的概率</strong> 乘积的和来获得，即：</p><script type="math/tex; mode=display">v_{\pi}(s) = \sum_{a \in A}\pi(a|s) q_{\pi}(s,a) \tag{6.4.1}</script></li><li><p>基于策略的 <strong>动作</strong> 价值函数的贝尔曼方程也是类似的</p><script type="math/tex; mode=display">q_{\pi}(s,a) = \mathbb{E}[R_{t+1} + \gamma q_{\pi}(S_{t+1},A_{t+1}) | S_t=s, A_t=a]</script><p> 类似的，状态 $s$ 下执行动作 $a$ 的价值也可以分解为 <strong>离开状态 $s$ 的立即回报</strong> 与 <strong>所有可能会进入状态的价值与对应进入概率</strong> 的乘积的和，即：</p><script type="math/tex; mode=display">q_{\pi}(s,a) = R_s^a + \gamma \sum_{s\prime \in S} P_{ss\prime}^a v_{\pi}(s\prime) \tag{6.4.2}</script></li><li><p>组合上面的 <strong>方程6.4.1</strong> 和 <strong>方程6.4.2</strong> ，可以得到</p><script type="math/tex; mode=display">v_{\pi}(s) = \sum_{a \in A}\pi(a|s) \left( R_s^a + \gamma \sum_{s\prime \in S} P_{ss\prime}^a v_{\pi}(s\prime) \right)</script><script type="math/tex; mode=display">q_{\pi}(s,a) = R_s^a + \gamma \sum_{s\prime \in S} P_{ss\prime}^a \sum_{a\prime \in A}\pi(a\prime|s\prime) q_{\pi}(s\prime,a\prime)</script></li></ol><h4 id="6-5-最优价值函数（Optimal-Value-Function）"><a href="#6-5-最优价值函数（Optimal-Value-Function）" class="headerlink" title="6.5 最优价值函数（Optimal Value Function）"></a>6.5 最优价值函数（Optimal Value Function）</h4><ol><li><p><strong>最优状态价值函数（Optimal State-Value Function）</strong> 就是从所有可能的策略中，<strong>选取</strong> 产生最大状态价值函数值的 <strong>策略的函数</strong></p><script type="math/tex; mode=display">v_*(s) = \max_{\pi} v_{\pi}(s) \tag{6.5.1}</script><blockquote><p><script type="math/tex">v_*(s)</script> 是 <script type="math/tex">v_{\pi_*}(s)</script> 的简写，都可以表示最优状态价值函数。</p></blockquote></li><li><p><strong>最优动作价值函数（Optimal Action-Value Function）</strong> 就是从所有可能的策略中，<strong>选取</strong> 产生最大动作状态价值函数值的 <strong>策略的函数</strong></p><script type="math/tex; mode=display">q_*(s,a) = \max_{\pi} q_{\pi}(s,a) \tag{6.5.2}</script><blockquote><p><script type="math/tex">q_*(s,a)</script> 是 <script type="math/tex">q_{\pi_*}(s,a)</script> 的简写，都可以表示最优动作价值函数。</p></blockquote></li><li><p>最优价值函数能够在马尔科夫决策过程中找到最好的策略。所以，如果我们找到了最优价值函数，那么我们就可以解决马尔科夫决策问题</p></li></ol><h4 id="6-6-最优策略（Optimal-Policy）"><a href="#6-6-最优策略（Optimal-Policy）" class="headerlink" title="6.6 最优策略（Optimal Policy）"></a>6.6 最优策略（Optimal Policy）</h4><ol><li><p>对于任意可能的状态，如果遵循一个策略的价值总是不差于遵循另一个策略，那么前一个策略就要优于后一个策略</p><script type="math/tex; mode=display">\pi \ge \pi\prime \quad if \; v_{\pi}(s) \ge v_{\pi\prime}(s), \forall{s}</script></li><li><p>定理：对任意马尔科夫决策过程，有：</p></li></ol><ul><li><p>存在一个最优策略 ${\pi}_*$ 不差于其他任何策略</p><script type="math/tex; mode=display">{\pi}_* \ge \pi, \forall{\pi}</script></li><li><p>所有的最优策略有相同的最优状态价值函数</p><script type="math/tex; mode=display">v_{\pi_*}(s) = v_*(s) \tag{6.6.2a}</script></li><li><p>所有的最优策略具有相同的最优动作价值函数</p><script type="math/tex; mode=display">q_{\pi_*}(s,a) = q_*(s,a) \tag{6.6.2b}</script></li></ul><h4 id="6-7-寻找最优策略"><a href="#6-7-寻找最优策略" class="headerlink" title="6.7 寻找最优策略"></a>6.7 寻找最优策略</h4><p>可以通过最大化最优动作价值函数 $q_*(s,a)$ 来找到最优策略</p><script type="math/tex; mode=display">\pi_*(a|s) =\begin{cases}    1 & if \; a = \underset{a \in A}{\operatorname{argmax}} \; q_*(s,a) \\    0 & otherwise \\\end{cases}\tag{6.7}</script><ul><li>对任意马尔科夫决策过程，总存在一个确定性的最优策略</li><li>如果我们知道最优动作价值函数 $q_*(s,a)$ ，则表明我们找到了最优策略</li></ul><h4 id="6-8-贝尔曼最优方程（Bellman-Optimality-Equation）"><a href="#6-8-贝尔曼最优方程（Bellman-Optimality-Equation）" class="headerlink" title="6.8 贝尔曼最优方程（Bellman Optimality Equation）"></a>6.8 贝尔曼最优方程（Bellman Optimality Equation）</h4><ol><li><p>一个状态的最优价值等于从该状态出发采取的所有动作产生的动作价值中最大的那个动作价值</p><script type="math/tex; mode=display"> \begin{aligned} v_*(s) & = v_{\pi_*}(s) & \text{公式6.6.2a} \\ & = \sum_{a \in A}\pi_*(a|s) q_{\pi_*}(s,a) & \text{公式6.4.1} \\ & = \max_a q_{\pi_*}(s,a) & \text{公式6.7} \\ & = \max_a q_*(s,a) & \text{公式6.6.2b} \\ \end{aligned}</script><p> 即</p><script type="math/tex; mode=display">v_*(s) = \max_a q_*(s,a) \tag{6.8.1}</script></li><li><p>与 <strong>方程6.4.2</strong> 类似，状态 $s$ 下执行动作 $a$ 的最优价值也可以分解为 <strong>离开状态 $s$ 的立即回报</strong> 与 <strong>所有可能会进入状态的最优状态价值与对应进入概率</strong> 的乘积的和，即：</p><script type="math/tex; mode=display">q_*(s,a) = R_s^a + \gamma \sum_{s\prime \in S} P_{ss\prime}^a v_*(s\prime) \tag{6.8.2}</script></li><li><p>组合上面的 <strong>方程6.8.1</strong> 和 <strong>方程6.8.2</strong> ，可以得到</p><script type="math/tex; mode=display">q_*(s,a) = R_s^a + \gamma \sum_{s\prime \in S} P_{ss\prime}^a  \max_{a\prime} q_*(s\prime,a\prime)</script><script type="math/tex; mode=display">v_*(s) = \max_a \left(R_s^a + \gamma \sum_{s\prime \in S} P_{ss\prime}^a v_*(s\prime)\right)</script></li></ol><h4 id="6-9-贝尔曼最优方程的求解方法"><a href="#6-9-贝尔曼最优方程的求解方法" class="headerlink" title="6.9 贝尔曼最优方程的求解方法"></a>6.9 贝尔曼最优方程的求解方法</h4><ol><li>贝尔曼最优方程是非线性的</li><li>贝尔曼最优方程通常没有固定的解决方案</li><li>可以通过一些迭代的方法来解决：<ul><li>价值迭代（Value Iteration）</li><li>策略迭代（Policy Iteration）</li><li>Q-learning</li><li>Sarsa</li></ul></li></ol><h3 id="6-10-贝尔曼期望方程和贝尔曼最优方程的关系"><a href="#6-10-贝尔曼期望方程和贝尔曼最优方程的关系" class="headerlink" title="6.10 贝尔曼期望方程和贝尔曼最优方程的关系"></a>6.10 贝尔曼期望方程和贝尔曼最优方程的关系</h3><ol><li>贝尔曼期望方程中，策略是已知的，求解贝尔曼期望方程就是在评价策略的优劣</li><li>贝尔曼最优方程中，策略是未知的，求解贝尔曼最优方程就是在找最优的策略</li></ol><hr><h2 id="二、生成模式（Generating-Patterns）"><a href="#二、生成模式（Generating-Patterns）" class="headerlink" title="二、生成模式（Generating Patterns）"></a>二、生成模式（Generating Patterns）</h2><h3 id="1-确定性模式（Deterministic-Patterns）"><a href="#1-确定性模式（Deterministic-Patterns）" class="headerlink" title="1. 确定性模式（Deterministic Patterns）"></a>1. 确定性模式（Deterministic Patterns）</h3><p>环境的下一个状态可以根据上一个状态计算出来。</p><p>比如：过完生日你就长了一岁。</p><h3 id="2-非确定性模式（Non-deterministic-patterns）"><a href="#2-非确定性模式（Non-deterministic-patterns）" class="headerlink" title="2. 非确定性模式（Non-deterministic patterns）"></a>2. 非确定性模式（Non-deterministic patterns）</h3><p>环境的下一个状态不能根据上一个状态计算出来。</p><p>比如：掷骰子。</p><p>马尔可夫假设：环境当前的状态仅仅依赖于之前的几个状态。<br>$n$ 阶马尔可夫模型：环境的下一个状态只由过去的 $n$ 个状态决定，与其他状态无关。</p><h3 id="3-隐藏模式（Hidden-Patterns）"><a href="#3-隐藏模式（Hidden-Patterns）" class="headerlink" title="3. 隐藏模式（Hidden Patterns）"></a>3. 隐藏模式（Hidden Patterns）</h3><p>隐马尔可夫模型（Hidden Markov Model, HMM）</p><hr><blockquote><p>参考：<a href="https://www.youtube.com/watch?v=lfHX2hHRMVQ&amp;list=PLqYmG7hTraZDM-OYHWgPebj2MfCFzFObQ&amp;index=2&amp;ab_channel=DeepMind">RL Course by David Silver - Lecture 2: Markov Decision Process</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 马尔可夫 </tag>
            
            <tag> 贝尔曼公式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决Ubuntu播放声音卡顿和爆音</title>
      <link href="jie-jue-ubuntu-bo-fang-sheng-yin-qia-dun-he-bao-yin/"/>
      <url>jie-jue-ubuntu-bo-fang-sheng-yin-qia-dun-he-bao-yin/</url>
      
        <content type="html"><![CDATA[<h2 id="播放声音卡顿"><a href="#播放声音卡顿" class="headerlink" title="播放声音卡顿"></a>播放声音卡顿</h2><p>安装完Ubuntu18.04后，用网易云音乐听歌时，声音总是每隔几秒卡顿一下，特此记录一下解决方法。</p><p>用命令<code>sudo lspci -v | grep -A7 Audio</code>查看系统的使用的声卡设备是<strong>Intel Corporation 200 Series PCH HD Audio</strong>，使用的驱动时<strong>snd_hda_intel</strong>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">~ <span class="token function">sudo</span> lspci -v <span class="token operator">|</span> <span class="token function">grep</span> -A7 Audio00:1f.3 Audio device: Intel Corporation <span class="token number">200</span> Series PCH HD Audio    Subsystem: Gigabyte Technology Co., Ltd <span class="token number">200</span> Series PCH HD Audio    Flags: bus master, fast devsel, latency <span class="token number">32</span>, IRQ <span class="token number">125</span>    Memory at f7140000 <span class="token punctuation">(</span><span class="token number">64</span>-bit, non-prefetchable<span class="token punctuation">)</span> <span class="token punctuation">[</span>size<span class="token operator">=</span>16K<span class="token punctuation">]</span>    Memory at f7120000 <span class="token punctuation">(</span><span class="token number">64</span>-bit, non-prefetchable<span class="token punctuation">)</span> <span class="token punctuation">[</span>size<span class="token operator">=</span>64K<span class="token punctuation">]</span>    Capabilities: <span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span> Power Management version <span class="token number">3</span>    Capabilities: <span class="token punctuation">[</span><span class="token number">60</span><span class="token punctuation">]</span> MSI: Enable+ <span class="token assign-left variable">Count</span><span class="token operator">=</span><span class="token number">1</span>/1 Maskable- 64bit+    Kernel driver <span class="token keyword">in</span> use: snd_hda_intel    Kernel modules: snd_hda_intel--01:00.1 Audio device: NVIDIA Corporation GP107GL High Definition Audio Controller <span class="token punctuation">(</span>rev a1<span class="token punctuation">)</span>    Subsystem: NVIDIA Corporation GP107GL High Definition Audio Controller    Flags: bus master, fast devsel, latency <span class="token number">0</span>, IRQ <span class="token number">17</span>    Memory at f7080000 <span class="token punctuation">(</span><span class="token number">32</span>-bit, non-prefetchable<span class="token punctuation">)</span> <span class="token punctuation">[</span>size<span class="token operator">=</span>16K<span class="token punctuation">]</span>    Capabilities: <span class="token punctuation">[</span><span class="token number">60</span><span class="token punctuation">]</span> Power Management version <span class="token number">3</span>    Capabilities: <span class="token punctuation">[</span><span class="token number">68</span><span class="token punctuation">]</span> MSI: Enable- <span class="token assign-left variable">Count</span><span class="token operator">=</span><span class="token number">1</span>/1 Maskable- 64bit+    Capabilities: <span class="token punctuation">[</span><span class="token number">78</span><span class="token punctuation">]</span> Express Endpoint, MSI 00    Capabilities: <span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span> Advanced Error Reporting    Kernel driver <span class="token keyword">in</span> use: snd_hda_intel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="播放声音爆音"><a href="#播放声音爆音" class="headerlink" title="播放声音爆音"></a>播放声音爆音</h2><p>有时电脑重启后，声音就一直每隔几秒爆音一下，重启也没用。可以执行一下命令，重启一下<strong>pulseaudio</strong>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pulseaudio --kill <span class="token punctuation">\</span>  <span class="token operator">&amp;&amp;</span> <span class="token function">rm</span> -r ~/.config/pulse/* <span class="token punctuation">\</span>  <span class="token operator">&amp;&amp;</span> pulseaudio --start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Effective Modern C++》读书笔记</title>
      <link href="effective-modern-c-du-shu-bi-ji/"/>
      <url>effective-modern-c-du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="一、型别推导"><a href="#一、型别推导" class="headerlink" title="一、型别推导"></a>一、型别推导</h2><h3 id="1-理解模板型别推导"><a href="#1-理解模板型别推导" class="headerlink" title="1. 理解模板型别推导"></a>1. 理解模板型别推导</h3><ol><li>在模板型别推导过程中，具有引用型别的实参会被当成非引用型别来处理。换言之，其引用性会被忽略。</li><li>对万能引用(Universal Reference)形参进行推导时，左值实参会进行特殊处理。</li><li>对按值传递的形参进行推导时，若实参型别中带有const或volatile饰词，则它们还是会被当作不带const或volatile饰词的型别来处理。</li><li>在模板型别推导过程中，数组或函数型别的实参会退化成对应的指针，除非它们被用来初始化引用。</li></ol><h3 id="2-理解auto型别推导"><a href="#2-理解auto型别推导" class="headerlink" title="2. 理解auto型别推导"></a>2. 理解auto型别推导</h3><ol><li>在一般情况下，auto型别推导和模板型别推导是一摸一样的，但是auto型别推导会假定用大括号括起的初始化表达式代表一个std::initializer_list，但模板型别推导却不会。</li><li>在函数返回值或lambda式的形参中使用auto，意思是使用模板型别推导而非auto型别推导。</li></ol><h3 id="3-理解decltype"><a href="#3-理解decltype" class="headerlink" title="3. 理解decltype"></a>3. 理解decltype</h3><ol><li>绝大多数情况下，decltype会得出变量或表达式的型别而不作任何修改。</li><li><p>对于型别为T的左值表达式，除非该表达式仅有一个名字，decltype总是得出型别T&amp;。</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>     <span class="token comment">// -&gt; int</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">// -&gt; int&amp;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span>    <span class="token comment">// -&gt; int&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>C++14支持decltype(auto)，和auto一样，它会从其初始化表达式出发来推导型别，但是它的型别推导使用的是decltype的规则。</li></ol><h3 id="4-掌握查看型别推导结果的方法"><a href="#4-掌握查看型别推导结果的方法" class="headerlink" title="4. 掌握查看型别推导结果的方法"></a>4. 掌握查看型别推导结果的方法</h3><ol><li>利用IDE编辑器、编译器错误消息和Boost.TypeIndex库常常能够查看到推导而得的型别。</li><li>有些工具产生的结果可能会无用，或者不准确。所以，理解C++型别推导规则是必要的。</li></ol><h2 id="二、auto"><a href="#二、auto" class="headerlink" title="二、auto"></a>二、auto</h2><h3 id="5-优先选用auto，而非显示型别声明"><a href="#5-优先选用auto，而非显示型别声明" class="headerlink" title="5. 优先选用auto，而非显示型别声明"></a>5. 优先选用auto，而非显示型别声明</h3><ol><li>auto变量必须初始化，基本上对会导致兼容性和效率问题的型别不匹配现象免疫，还可以简化重构流程，通常也比显示指定型别要少打一些字。</li><li>auto型别的变量都有着<a href="#2-理解auto型别推导">条款2</a>和<a href="#6-当auto推导的型别不符合要求时，使用带显示型别的初始化物习惯用法">条款6</a>中所描述的毛病。</li></ol><h3 id="6-当auto推导的型别不符合要求时，使用带显示型别的初始化物习惯用法"><a href="#6-当auto推导的型别不符合要求时，使用带显示型别的初始化物习惯用法" class="headerlink" title="6. 当auto推导的型别不符合要求时，使用带显示型别的初始化物习惯用法"></a>6. 当auto推导的型别不符合要求时，使用带显示型别的初始化物习惯用法</h3><ol><li>“隐形”的代理型别可以导致auto根据初始化表达式推导出“错误的”型别。</li><li>带显示型别的初始化物习惯用法强制auto推导出你想要的型别。</li></ol><h2 id="三、转向现代C"><a href="#三、转向现代C" class="headerlink" title="三、转向现代C++"></a>三、转向现代C++</h2><h3 id="7-在创建对象时注意区分-和"><a href="#7-在创建对象时注意区分-和" class="headerlink" title="7. 在创建对象时注意区分()和{}"></a>7. 在创建对象时注意区分()和{}</h3><ol><li>大括号初始化可以应用的语境最为宽泛，可以阻止隐式窄化型别转换，还对最令人苦恼之解析语法免疫。</li><li>在构造函数重载决议期间，只要有任何可能，大括号初始化物就会与带有std::initializer_list型别的形参相匹配，即使其他重载版本有着貌似更加匹配的形参表。</li><li>使用小括号还是大括号，会造成结果大相径庭的一个例子是：使用两个实参创建一个std::vector&lt;数值型别&gt;对象。</li><li>在模板内容进行对象创建时，到底应该使用小括号还是大括号会成为一个棘手问题。</li></ol><h4 id="几个容易混淆的例子"><a href="#几个容易混淆的例子" class="headerlink" title="几个容易混淆的例子"></a>几个容易混淆的例子</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Widget w1<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">// 调用默认构造函数</span>Widget <span class="token function">w2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 声明了一个名为w2的函数</span>Widget <span class="token function">w3</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 调用带有std::initializer_list型别形参的构造函数</span>Widget w4<span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// 同上</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-优先选用nullptr，而非0或NULL"><a href="#8-优先选用nullptr，而非0或NULL" class="headerlink" title="8. 优先选用nullptr，而非0或NULL"></a>8. 优先选用nullptr，而非0或NULL</h3><ol><li>相对于0或NULL，优先选用nullptr。</li><li>避免在整型和指针型别之间重载。</li></ol><h3 id="9-优先选用别名声明，而非typedef"><a href="#9-优先选用别名声明，而非typedef" class="headerlink" title="9. 优先选用别名声明，而非typedef"></a>9. 优先选用别名声明，而非typedef</h3><ol><li>typedef不支持模板化，但别名声明支持。</li><li>别名模板可以让人免写“::type”后缀，并且在模板内，对于内嵌typedef的引用经常要求加上typename前缀。</li></ol><h3 id="10-优先选用限定作用域的枚举型别，而非不限作用域的枚举型别"><a href="#10-优先选用限定作用域的枚举型别，而非不限作用域的枚举型别" class="headerlink" title="10. 优先选用限定作用域的枚举型别，而非不限作用域的枚举型别"></a>10. 优先选用限定作用域的枚举型别，而非不限作用域的枚举型别</h3><ol><li>C++98风格的枚举型别，现在称为不限范围的枚举型别。</li><li>限定作用域的枚举型别仅在枚举型别内可见。它们只能通过强制型别转换以转换至其他型别。</li><li>限制作用域的枚举型别和不限范围的枚举型别都支持底层型别指定。限制作用域的枚举型别的默认底层型别是int，而不限范围的枚举型别没有默认底层型别。</li><li>限制作用域的枚举型别总是可以进行前置声明，而不限范围的枚举型别却只有在指定了默认底层型别的前提下才可以进行前置声明。</li></ol><h3 id="11-优先选用删除函数，而非private未定义函数"><a href="#11-优先选用删除函数，而非private未定义函数" class="headerlink" title="11. 优先选用删除函数，而非private未定义函数"></a>11. 优先选用删除函数，而非private未定义函数</h3><ol><li>优先选用删除函数，而非private未定义函数。</li><li>任何函数都可以删除，包括非成员函数和模板具现。</li></ol><h3 id="12-为意在改写的函数添加override声明"><a href="#12-为意在改写的函数添加override声明" class="headerlink" title="12. 为意在改写的函数添加override声明"></a>12. 为意在改写的函数添加override声明</h3><ol><li>为意在改写的函数添加override声明。</li><li>成员函数引用饰词使得对于左值和右值对象（*this）的处理能够区分开来。</li></ol><h3 id="13-优先选用const-iterator，而非iterator"><a href="#13-优先选用const-iterator，而非iterator" class="headerlink" title="13. 优先选用const_iterator，而非iterator"></a>13. 优先选用const_iterator，而非iterator</h3><ol><li>优先选用const_iterator，而非iterator。</li><li>在最通用的代码中，优先选用非成员函数版本的begin、end和rbegin等，而非其成员函数版本。</li></ol><h3 id="14-只要函数不会发射异常，就为其加上noexcept声明"><a href="#14-只要函数不会发射异常，就为其加上noexcept声明" class="headerlink" title="14. 只要函数不会发射异常，就为其加上noexcept声明"></a>14. 只要函数不会发射异常，就为其加上noexcept声明</h3><ol><li>noexcept声明是函数接口的组成部分，这意味着调用方可能会对它有依赖。</li><li>相对于不带noexcept声明的函数，带有noexcept声明的函数有更对机会得到优化。</li><li>noexcept性质对于移动操作、swap、函数释放函数和析构函数最有价值。</li><li>大多数函数都是异常中立的，不具备noexcept性质。</li></ol><h4 id="关于条款14的补充说明"><a href="#关于条款14的补充说明" class="headerlink" title="关于条款14的补充说明"></a>关于条款14的补充说明</h4><ul><li><p>在带有noexcept声明的函数中，优化器不需要在异常传出函数的前提下，将执行期栈保持在可开解状态；也不需要在异常溢出函数的前提下，保证所有其中的对象以其被构造顺序的逆序完成析构。而那些以“throw()”异常规格声明的函数就享受不到这样的优化灵活性，和没有加异常规格声明的函数一样。</p></li><li><p>在C++98中，允许内存释放函数（即operator delete或operator delete[]）和析构函数发射异常，被认为是一种差劲的编程风格。而在C++11中，这种风格规则被升级成了一条语言规则。<strong>默认地，内存释放函数和所有的析构函数（无论是用户定义的，还是编译器自动生成的）都隐式地具备noexcept性质。</strong></p></li></ul><h3 id="15-只要有可能使用constexpr，就使用它"><a href="#15-只要有可能使用constexpr，就使用它" class="headerlink" title="15. 只要有可能使用constexpr，就使用它"></a>15. 只要有可能使用constexpr，就使用它</h3><ol><li>constexpr对象都具备const属性，并由编译期已知的值完成初始化。</li><li>constexpr函数在调用时若传入的实参值是编译期已知的，则会产生出编译期结果。</li><li>比起非constexpr对象或constexpr函数而言，constexpr对象或是constexpr函数可以用在一个作用域更广的语境中。</li></ol><h4 id="关于constexpr函数的说明"><a href="#关于constexpr函数的说明" class="headerlink" title="关于constexpr函数的说明"></a>关于constexpr函数的说明</h4><ul><li>constexpr函数可以用在要求编译期常量的语境中。在这样的语境中，若你传给一个constexpr函数的实参值是在编译期已知的，则结果也会在编译期间计算出来。如果任何一个实参值在编译期未知，则你的代码将无法通过编译。</li><li>在调用constexpr函数时，若传入的值有一个或多个在编译期未知，则它的运作方式和普通函数无异，亦即它也是在运行期执行结果的计算。这意味着，如果函数执行的是同样的操作，仅仅应用的语境一个是要求编译期常量的，一个是用于所有其他值的话，那就不必写两个函数。constexpr函数就可以同时满足所有需求。</li></ul><h4 id="关于constexpr在C-11和C-14中的不同"><a href="#关于constexpr在C-11和C-14中的不同" class="headerlink" title="关于constexpr在C++11和C++14中的不同"></a>关于constexpr在C++11和C++14中的不同</h4><p>constexpr函数仅限于传入和返回字面型别（literal type），意思就是这样的型别能够持有编译期可以决议的值。在C++11中，所有的内建型别，除了void，都符合这个条件。但是用户自定义型别同样可能也是字面型别，因为它的构造函数和其他成员函数可能也是constexpr函数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">constexpr</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">double</span> xVal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">double</span> yVal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>xVal<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>yVal<span class="token punctuation">)</span>    <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">constexpr</span> <span class="token keyword">double</span> <span class="token function">xValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">constexpr</span> <span class="token keyword">double</span> <span class="token function">yValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">setX</span><span class="token punctuation">(</span><span class="token keyword">double</span> newX<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> x <span class="token operator">=</span> newX<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">setY</span><span class="token punctuation">(</span><span class="token keyword">double</span> newY<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> y <span class="token operator">=</span> newY<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">double</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在C++11中，有两个限制使得Point的成员函数setX和setY无法声明为constexpr。</p><ol><li>首先，它们修改了操作对象。在C++11中，constexpr函数都隐式地被声明为const的了。<em>这里说的并非函数返回值的const属性，而是指成员函数的const饰词，这意味着该成员函数不能修改其操作对象（严格地说是不能修改其非mutable数据成员）。</em></li><li>其次，它们的返回型别是void。而在C++11中，void并不是个字面型别。</li></ol><p>不过这两个限制在C++14中都被解除了，所以在C++14中，就连设置器也可以声明为constexpr。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">constexpr</span> <span class="token keyword">void</span> <span class="token function">setX</span><span class="token punctuation">(</span><span class="token keyword">double</span> newX<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> x <span class="token operator">=</span> newX<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// C++14</span>    <span class="token keyword">constexpr</span> <span class="token keyword">void</span> <span class="token function">setY</span><span class="token punctuation">(</span><span class="token keyword">double</span> newY<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> y <span class="token operator">=</span> newY<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// C++14</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="关于条款15的补充说明"><a href="#关于条款15的补充说明" class="headerlink" title="关于条款15的补充说明"></a>关于条款15的补充说明</h4><ul><li><p>所有constexpr对象都是const对象，而并非所有的const对象都是constexpr对象。如果你想让编译器提供保证，让变量拥有一个值，用于要求编译期常量的语境，那么能达到这个目的的工具是constexpr，而非const。</p></li><li><p>在C++11中，constexpr函数不得包含多于一个可执行语句，即一个return语句。在C++14中，限制条件大大地放宽了。</p></li></ul><h3 id="16-保证const成员函数的线程安全性"><a href="#16-保证const成员函数的线程安全性" class="headerlink" title="16. 保证const成员函数的线程安全性"></a>16. 保证const成员函数的线程安全性</h3><ol><li>保证const成员函数的线程安全性，除非可以确信它们不会用在并发语境中。</li><li>运用std::atomic型别的变量会比运用互斥量提供更好的性能，但前者仅适用对单个变量或内存区域的操作。</li></ol><h3 id="17-理解特种成员函数的生成机制"><a href="#17-理解特种成员函数的生成机制" class="headerlink" title="17. 理解特种成员函数的生成机制"></a>17. 理解特种成员函数的生成机制</h3><ol><li>特种成员函数是指那些C++会自行生成的成员函数：默认构造函数、析构函数、复制操作，以及移动操作。</li><li>移动操作仅当类中未包含用户显式声明的复制操作、移动操作和析构函数时才生成。</li><li>复制构造函数仅当类中不包含用户显示声明的复制构造函数时才生成，如果该类声明了移动操作则复制构造函数将被删除。复制赋值运算符仅当类中不包含用户显示声明的复制赋值运算符才生成，如果该类声明了移动操作则复制赋值运算符将被删除。在已经存在显式声明的析构函数的条件下，生成复制操作已经成为了被废弃的行为。</li><li>成员函数模板在任何情况下都不会抑制特种成员函数的生成。</li></ol><h4 id="大三律"><a href="#大三律" class="headerlink" title="大三律"></a>大三律</h4><p>如果你声明了复制构造函数、复制赋值运算符，或析构函数中的任何一个，你就得同时声明所有这三个。</p><p>它植根于这样的思想：如果有改写复制操作的需求，往往意味着该类需要执行某种资源管理，而这就意味着：</p><ol><li>在一种复制操作中进行的任何资源管理，也极有可能在另一种复制操作中也需要进行；</li><li>该类的析构函数也会参与到该资源的管理中（通常是释放之）。</li></ol><h4 id="移动操作的生成条件（如果需要生成）仅当一下三者同时成立"><a href="#移动操作的生成条件（如果需要生成）仅当一下三者同时成立" class="headerlink" title="移动操作的生成条件（如果需要生成）仅当一下三者同时成立"></a>移动操作的生成条件（如果需要生成）仅当一下三者同时成立</h4><ol><li><p>该类未声明任何复制操作</p><p> 声明复制操作（无论是复制构造还是复制赋值）的行为表明了对象的常规复制途径（按成员复制）对于该类并不适用。编译器从而判定，既然按成员复制不适用于复制操作，则按成员移动极有可能也不适用于移动操作。</p></li><li><p>该类未声明任何移动操作</p><p> 假设你声明了一个移动构造函数，你实际上表明移动操作的实现方式将会与编译器生成的默认按成员移动的移动构造函数多少有些不同。而若是按成员进行的移动构造操作有不合用之处的话，那么按成员进行的移动赋值运算符极有可能也会有不合用之处。</p></li><li><p>该类未声明任何析构函数</p><ul><li><a href="#大三律">大三律</a>的一个推论是，如果存在用户声明的析构函数，则平凡的（trivial）按成员复制的也不适用于该类。根据这个推论，又能得出进一步的结论，如果声明了析构函数，则复制操作就不该被自动生成，因为它们的行为不可能正确。不过在C++98标准被接受的时代，这样的论证过程没有得到充分的重视，所以在C++98中，用户声明的析构函数即使存在，也不会影响编译器生成复制操作的意愿。这种情况在C++11仍然得到了保持，但原因仅仅在于，如果要对复制操作的生成条件施加更严格的限制，就会破坏太多的遗留代码了。</li><li>由于<a href="#大三律">大三律</a>背后的理由仍然成立，再结合声明了复制操作就会阻止隐式生成移动操作的事实，就推动了C++11中的这样一个规定：只要用户声明了析构函数，就不会生成移动操作。</li></ul></li></ol><h4 id="关于条款17的补充说明"><a href="#关于条款17的补充说明" class="headerlink" title="关于条款17的补充说明"></a>关于条款17的补充说明</h4><ul><li>当移动操作在某个数据成员或基类部分上执行移动构造或移动赋值的时候，并不能保证移动操作真的会发生。“按成员移动”实际上更像是按成员的移动请求，因为那些不可移动的型别（即那些并未为移动操作提供特殊支持的型别，这包括了大多数C++98的遗留型别）将通过其复制操作实现“移动”。每个按成员进行的“移动”操作，其核心在于把std::move应用于每一个移动源对象，其返回值被用于函数重载决议，最终决定是执行一个移动还是复制操作，这个流程将在<a href="#23-理解std::move和std::forward">条款23</a>中详述。在本条款中，只需记住，按成员移动是由两部分组成，一部分是在支持移动操作的成员上执行移动操作，另一部分实在不支持移动操作的成员上执行复制操作。</li></ul><h2 id="四、智能指针"><a href="#四、智能指针" class="headerlink" title="四、智能指针"></a>四、智能指针</h2><h3 id="18-使用std-unique-ptr管理具备专属所有权的资源"><a href="#18-使用std-unique-ptr管理具备专属所有权的资源" class="headerlink" title="18. 使用std::unique_ptr管理具备专属所有权的资源"></a>18. 使用std::unique_ptr管理具备专属所有权的资源</h3><ol><li>std::unique_ptr是小巧、高速的、具备只移型别的智能指针，对托管资源实施专属所有权语义。</li><li>默认地，资源析构采用delete运算符来实现，但可以指定自定义删除器。有状态的删除器和采用函数指针实现的删除器会增加std::unique_ptr型别的对象尺寸。</li><li>将std::unique_ptr转换成std::shared_ptr是容易实现的。</li></ol><h3 id="19-使用std-shared-ptr管理具备共享所有权的资源"><a href="#19-使用std-shared-ptr管理具备共享所有权的资源" class="headerlink" title="19. 使用std::shared_ptr管理具备共享所有权的资源"></a>19. 使用std::shared_ptr管理具备共享所有权的资源</h3><ol><li>std::shared_ptr提供方便的手段，实现了任意资源在共享所有权语义下进行生命周期管理的垃圾回收。</li><li>与std::unique_ptr相比，std::shared_ptr的尺寸通常是裸指针尺寸的两倍，它还会带来控制块的开销，并要求原子化的引用技术操作。</li><li>默认的资源析构通过delete运算符进行，但同时也支持定制删除器。删除器的型别对std::shared_ptr的型别没有影响。</li><li>避免使用裸指针型别的变量来创建std::shared_ptr指针。</li></ol><h3 id="20-对于类似std-shared-ptr但有可能空悬的指针使用std-weak-ptr"><a href="#20-对于类似std-shared-ptr但有可能空悬的指针使用std-weak-ptr" class="headerlink" title="20. 对于类似std::shared_ptr但有可能空悬的指针使用std::weak_ptr"></a>20. 对于类似std::shared_ptr但有可能空悬的指针使用std::weak_ptr</h3><ol><li>使用std::weak_ptr来代替可能空悬的std::shared_ptr。</li><li>std::weak_ptr可能的用武之地包括缓存，观察者列表，以及避免std::shared_ptr指针环路。</li></ol><h3 id="21-优先选用std-make-unique和std-make-shared，而非直接使用new"><a href="#21-优先选用std-make-unique和std-make-shared，而非直接使用new" class="headerlink" title="21. 优先选用std::make_unique和std::make_shared，而非直接使用new"></a>21. 优先选用std::make_unique和std::make_shared，而非直接使用new</h3><ol><li>相比于直接使用new表达式，make系列函数消除了重复代码、改进了异常安全性，并且对于std::make_shared和std::allocated_shared而言，生成的目标代码会尺寸更小、速度更快。</li><li>不适于使用make系列函数的场景包括需要定制删除器，以及期望直接传递大括号初始化物。</li><li>对于std::shared_ptr，不建议使用make系列函数的额外场景包括：（1）自定义内存管理的类；（2）内存紧张的系统、非常大的对象、以及存在比指涉到相同对象的std::shared_ptr生存期更久的std::weak_ptr。</li></ol><h3 id="22-使用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中"><a href="#22-使用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中" class="headerlink" title="22. 使用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中"></a>22. 使用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中</h3><ol><li>Pimpl惯用法通过降低类的客户和类实现者之间的依赖性，减少了构建遍数。</li><li>对于采用std::unique_ptr来实现的pImpl指针，须在类的头文件中声明特种成员函数，但在实现文件中实现它们。即使默认函数实现有着正确行为，也必须这样做。</li><li>上述建议仅适用于std::unique_ptr，但并不使用std::shared_ptr。</li></ol><h2 id="五、右值引用、移动语义和完美转发"><a href="#五、右值引用、移动语义和完美转发" class="headerlink" title="五、右值引用、移动语义和完美转发"></a>五、右值引用、移动语义和完美转发</h2><p>在阅读本章中的条款时，一定要把这一点铭记在心：<strong>形参总是左值，即使其型别是右值引用。</strong>即，给定函数形如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>形参w是个左值。即使它的型别是个指涉到Widget型别对象的右值引用（如果你对此感觉意外，请参阅本书第一章就写着的关于左值和右值的概述）。</p><h3 id="23-理解std-move和std-forward"><a href="#23-理解std-move和std-forward" class="headerlink" title="23. 理解std::move和std::forward"></a>23. 理解std::move和std::forward</h3><ol><li>std::move实施的是无条件的向右值型别的强制型别转换。就其本身而言，它不会执行移动操作。</li><li>仅当传入的实参被绑定到右值时，std::forward才针对该实参实施向右值型别的强制型别转换。</li><li>在运行期，std::move和std::forward都不会做任何操作。</li></ol><h3 id="24-区分万能引用和右值引用"><a href="#24-区分万能引用和右值引用" class="headerlink" title="24. 区分万能引用和右值引用"></a>24. 区分万能引用和右值引用</h3><ol><li>如果函数模板形参具备T&amp;&amp;型别，并且T的型别系推导而来，或如果对象使用auto&amp;&amp;声明其型别，则该形参或对象就是个万能引用。</li><li>如果型别声明并不精确地具备type&amp;&amp;的形式，或者型别推导并未发生，则type&amp;&amp;就代表右值引用。</li><li>若采用右值来初始化万能引用，就会得到一个右值引用。若采用左值来初始化万能引用，就会得到一个左值引用。</li></ol><h3 id="25-针对右值引用实施std-move，针对万能引用实施std-forward"><a href="#25-针对右值引用实施std-move，针对万能引用实施std-forward" class="headerlink" title="25. 针对右值引用实施std::move，针对万能引用实施std::forward"></a>25. 针对右值引用实施std::move，针对万能引用实施std::forward</h3><ol><li>针对右值引用的最后一次使用实施std::move，针对万能引用的最后一次使用实施std::forward。</li><li>作为按值返回的函数的右值引用和万能引用，依上一条所述采取相同行为。</li><li>若局部对象可能适用于返回值优化，则请勿针对其实施std::move或std::forward。</li></ol><h4 id="RVO的条件"><a href="#RVO的条件" class="headerlink" title="RVO的条件"></a>RVO的条件</h4><ul><li><p>局部对象型别和函数返回值型别相同。</p>  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Widget <span class="token function">makeWidget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Widget w<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  <code>std::move(w)</code>返回的不是局部对象w，而是w的引用，std::move(w)的结果。返回一个局部对象的引用并不满足实施RVO的前提条件，因此编译器必须把w移入函数的返回值存储位置。</p></li><li><p>返回的就是局部对象本身。</p></li></ul><p>即使实施RVO的前提条件满足，但编译器选择不执行复制省略的时候，返回对象必须作为右值处理。这么一来，就等于标准要求：<strong>当RVO的前提条件允许时，要么发生复制省略，要么std::move隐式地被实施于返回的局部对象上。</strong></p><h3 id="26-避免依万能引用型型别进行重载"><a href="#26-避免依万能引用型型别进行重载" class="headerlink" title="26. 避免依万能引用型型别进行重载"></a>26. 避免依万能引用型型别进行重载</h3><ol><li>把万能引用作为重载候选型别，几乎总会让该重载版本在始料未及的情况下被调用到。</li><li>完美转发构造函数的问题尤其严重，因为对于非常量的左值型别而言，它们一般都会形成相对于复制构造函数的更佳匹配，并且它们还会劫持派生类中对基类的复制和移动构造函数的调用。</li></ol><h3 id="27-熟悉依万能引用型别进行重载的替代方案"><a href="#27-熟悉依万能引用型别进行重载的替代方案" class="headerlink" title="27. 熟悉依万能引用型别进行重载的替代方案"></a>27. 熟悉依万能引用型别进行重载的替代方案</h3><ol><li>如果不使用万能引用和重载的组合，则替代方案包括使用彼此不同的函数名字、传递const T&amp;型别的形参、传值和标签分派。</li><li>经由std::enable_if对模板施加限制，就可以将万能引用和重载一起使用，不过这种技术控制了编译器可以调用到接受万能引用的重载版本的条件。</li><li>万能引用形参通常在性能方面具备优势，但在易用性方面一般会有劣势。</li></ol><h3 id="28-理解引用折叠"><a href="#28-理解引用折叠" class="headerlink" title="28. 理解引用折叠"></a>28. 理解引用折叠</h3><ol><li>引用折叠会在四种语境中发生：模板实例化，auto型别生成、创建和运用typedef和别名声明，以及decltype。</li><li>当编译器在引用折叠的语境下生成引用的引用时，结果会变成单个引用。如果原始的引用中有任一引用为左值引用，则结果为左值引用。否则，结果为右值引用。</li><li>万能引用就是在型别推导的过程中会区别左值和右值，以及会发生引用折叠的语境中的右值引用。</li></ol><h3 id="29-假定移动操作不存在、成本高、未使用"><a href="#29-假定移动操作不存在、成本高、未使用" class="headerlink" title="29. 假定移动操作不存在、成本高、未使用"></a>29. 假定移动操作不存在、成本高、未使用</h3><ol><li>假定移动操作不存在、成本高、未使用。</li><li>对于那些型别或对于移动语义的支持情况已知的代码，则无需作以上假定。</li></ol><h3 id="30-熟悉完美转发的失败情形"><a href="#30-熟悉完美转发的失败情形" class="headerlink" title="30. 熟悉完美转发的失败情形"></a>30. 熟悉完美转发的失败情形</h3><ol><li>完美转发的失败情形，是源于模板型别推导失败，或推导结果是错误的型别。</li><li>会导致完美转发失败的实参种类有大括号初始化物、以值0或NULL表达的空指针、仅有声明的整型static const成员变量、模板或重载的函数名字，以及位域。</li></ol><h2 id="六、lambda表达式"><a href="#六、lambda表达式" class="headerlink" title="六、lambda表达式"></a>六、lambda表达式</h2><h3 id="31-避免默认捕获模式"><a href="#31-避免默认捕获模式" class="headerlink" title="31. 避免默认捕获模式"></a>31. 避免默认捕获模式</h3><ol><li>按引用的默认捕获会导致空悬指针问题。</li><li>按值的默认捕获极易受空悬指针影响（尤其是this），并会误导人们认为lambda式是自洽的。</li></ol><h3 id="32-使用初始化捕获将对象移入闭包"><a href="#32-使用初始化捕获将对象移入闭包" class="headerlink" title="32. 使用初始化捕获将对象移入闭包"></a>32. 使用初始化捕获将对象移入闭包</h3><ol><li>使用C++14的初始化捕获将对象移入闭包。</li><li>在C++11中，经由手工实现的类或std::bind去模拟初始化捕获。</li></ol><h3 id="33-对auto-amp-amp-型别的形参使用decltype，以std-forward之"><a href="#33-对auto-amp-amp-型别的形参使用decltype，以std-forward之" class="headerlink" title="33. 对auto&amp;&amp;型别的形参使用decltype，以std::forward之"></a>33. 对auto&amp;&amp;型别的形参使用decltype，以std::forward之</h3><ol><li><p>对auto&amp;&amp;型别的形参使用decltype，以std::forward之。</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token function">normalize</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="34-优先选用lambda式，而非std-bind"><a href="#34-优先选用lambda式，而非std-bind" class="headerlink" title="34. 优先选用lambda式，而非std::bind"></a>34. 优先选用lambda式，而非std::bind</h3><ol><li>lambda式比起使用std::bind而言，可读性更好、表达力更强，可能运行效率也更高。</li><li>仅在C++11中，std::bind在实现移动捕获，或是绑定到具备模板化的函数调用运算符的对象的场合中，可能尚有余热可以发挥。</li></ol><h2 id="七、并发API"><a href="#七、并发API" class="headerlink" title="七、并发API"></a>七、并发API</h2><h3 id="35-优先选用基于任务而非基于线程的程序设计"><a href="#35-优先选用基于任务而非基于线程的程序设计" class="headerlink" title="35. 优先选用基于任务而非基于线程的程序设计"></a>35. 优先选用基于任务而非基于线程的程序设计</h3><ol><li>std::thread的API未提供直接获取异步运行函数返回值的途径，而且如果那些函数抛出异常，程序就会终止。</li><li>基于线程的程序设计要求手动管理线程耗尽、超订、负载均衡，以及新平台适配。</li><li>经由应用了默认启动策略的std::async进行基于任务的程序设计，大部分这类问题都能找到解决知道。</li></ol><h3 id="36-如果异步是必要的，则指定std-launch-async"><a href="#36-如果异步是必要的，则指定std-launch-async" class="headerlink" title="36. 如果异步是必要的，则指定std::launch::async"></a>36. 如果异步是必要的，则指定std::launch::async</h3><ol><li>std::async的默认启动策略既允许任务异步方式执行，也允许任务以同步方式执行。</li><li>如此的弹性会导致使用thread_local变量时的不确定性，隐含着任务可能永远不会执行，还会影响运用了基于超时的wait调用的程序逻辑。</li><li>如果异步是必要的，则指定std::launch::async。</li></ol><h3 id="37-使std-thread型别对象在所有路径皆不可联结（unjoinable）"><a href="#37-使std-thread型别对象在所有路径皆不可联结（unjoinable）" class="headerlink" title="37. 使std::thread型别对象在所有路径皆不可联结（unjoinable）"></a>37. 使std::thread型别对象在所有路径皆不可联结（unjoinable）</h3><ol><li>使std::thread型别对象在所有路径皆不可联结。</li><li>在析构时调用join可能导致难以调试的性能异常。</li><li>在析构时调用detach可能导致难以调试的未定义行为。</li><li>在成员列表的最后声明std::thread型别对象。</li></ol><h4 id="不可联结的std-thread型别对象"><a href="#不可联结的std-thread型别对象" class="headerlink" title="不可联结的std::thread型别对象"></a>不可联结的std::thread型别对象</h4><ol><li><strong>默认构造的std::thread。</strong> 此类std::thread没有可以执行的函数，因此也没有对应的底层执行线程。</li><li><strong>已移动的std::thread。</strong> 移动操作的结果是，一个std::thread所对应的底层执行线程（若有）被对应到另一个std::thread。</li><li><strong>已联结的std::thread。</strong> 联结后，std::thread型别对象不在对应至已结束运行的底层执行线程。</li><li><strong>已分离的std::thread。</strong> 分离操作会把std::thread型别对象和它对应的底层执行线程之间的连接断开。</li></ol><h4 id="关于条款37的补充说明"><a href="#关于条款37的补充说明" class="headerlink" title="关于条款37的补充说明"></a>关于条款37的补充说明</h4><ul><li>如果可联结线程对象的析构函数被调用，则程序的执行就终止了。</li></ul><h3 id="38-对变化多端的线程句柄析构函数行为保持关注"><a href="#38-对变化多端的线程句柄析构函数行为保持关注" class="headerlink" title="38. 对变化多端的线程句柄析构函数行为保持关注"></a>38. 对变化多端的线程句柄析构函数行为保持关注</h3><ol><li>期值（std::future/std::shared_future）的析构函数在常规情况下，仅会析构期值的成员变量。</li><li>指涉到经由std::async启动的未推迟任务的共享状态的最后一个期值会保持阻塞，直至该任务结束。</li></ol><h3 id="39-考虑针对一次性事件通信使用以void为模板型别实参的期值"><a href="#39-考虑针对一次性事件通信使用以void为模板型别实参的期值" class="headerlink" title="39. 考虑针对一次性事件通信使用以void为模板型别实参的期值"></a>39. 考虑针对一次性事件通信使用以void为模板型别实参的期值</h3><ol><li>如果仅为了实现平凡事件通信，基于条件变量的设计会要求多余的互斥量，这会给相互关联的检测和反应任务带来约束，并要求反应任务校验事件确已发生。</li><li>使用标志位的设计可以避免上述问题，但这一设计基于轮训而非阻塞。</li><li>条件变量和标志位可以一起使用，但这样的通信机制设计结果不甚自然。</li><li>使用std::promise型别对象和期值就可以回避这些问题，但是一来这个途径为了共享状态需要使用堆内存，而且仅限于一次性通信。</li></ol><h3 id="40-对并发使用std-atomic，对特种内存使用volatile"><a href="#40-对并发使用std-atomic，对特种内存使用volatile" class="headerlink" title="40. 对并发使用std::atomic，对特种内存使用volatile"></a>40. 对并发使用std::atomic，对特种内存使用volatile</h3><ol><li>std::atomic用于多线程访问的数据，且不用互斥量。它是撰写并发软件的工具。</li><li><p>volatile用于读写操作不可以被优化掉的内存。它是在面对特种内存时使用的工具。</p><p> 给y加上volatile可以避免编译器将代码：</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">y</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>y<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 优化成：</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">register</span> <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token keyword">register</span><span class="token punctuation">)</span><span class="token punctuation">;</span>y<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token keyword">register</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="八、微调"><a href="#八、微调" class="headerlink" title="八、微调"></a>八、微调</h2><h3 id="41-针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递"><a href="#41-针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递" class="headerlink" title="41. 针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递"></a>41. 针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递</h3><ol><li>对于可复制的、在移动成本低廉的并且一定会被复制的形参而言，按值传递可能会和按引用传递的具备相近的效率，并且可能生成更少量的目标代码。</li><li>经由构造复制形参的成本可能比经由赋值复制形参高出很多。</li><li>按值传递肯定会导致切片问题，所以基类型别特别不适用于按值传递。</li></ol><h3 id="42-考虑置入而非插入"><a href="#42-考虑置入而非插入" class="headerlink" title="42. 考虑置入而非插入"></a>42. 考虑置入而非插入</h3><ol><li>从原理上说，置入函数（如：emplace_back）应该有时比对应的插入函数（如：push_back）高效，而且不应该有更低效的可能。</li><li>从实践上说，置入函数在以下几个前提成立时，极有可能会运行得更快：（1）待添加的值是以构造而非赋值方式加入容器；（2）传递的实参型别与容器持有之物的型别不同；（3）容器不会由于存在重复值而拒绝待添加的值。</li><li><p>置入函数可能会执行在插入函数中会被拒绝的型别转换。</p><p> 复制初始化是不允许调用带有explicit声明饰词的构造函数的，但直接初始化就允许。</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token operator">::</span>regex r1 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    <span class="token comment">// 错误！无法通过编译 （复制初始化）</span>std<span class="token operator">::</span>regex <span class="token function">r2</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 能编译 （直接初始化）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP模型协议状态机速览</title>
      <link href="tcp-mo-xing-xie-yi-zhuang-tai-ji-su-lan/"/>
      <url>tcp-mo-xing-xie-yi-zhuang-tai-ji-su-lan/</url>
      
        <content type="html"><![CDATA[<h2 id="一、OSI-模型"><a href="#一、OSI-模型" class="headerlink" title="一、OSI 模型"></a>一、OSI 模型</h2><p><img src="/images/TCP模型协议状态机速览/计算机网络体系结构.png" alt="计算机网络体系结构"></p><div class="table-container"><table><thead><tr><th>名字</th><th>说明</th><th>数据包名</th><th>常用格式协议</th></tr></thead><tbody><tr><td>应用层</td><td>允许访问OSI环境的手段</td><td>应用协议数据单元 APDU</td><td>HTTP、FTP、TELNET、DNS、BT、NTP、DHCP、SNMP</td></tr><tr><td>表示层</td><td>对数据进行翻译、加密和压缩</td><td>表示协议数据单元 PPDU</td><td>JPEG、MPEG、ASCll</td></tr><tr><td>会话层</td><td>建立、管理和终止会话</td><td>会话协议数据单元 SPDU</td><td>SSL、TLS、NFS、SQL、NETBIOS、RPC</td></tr><tr><td>传输层</td><td>提供端到端的可靠报文传递和错误恢复</td><td>段 Segment</td><td>TCP、UDP、SPX</td></tr><tr><td>网络层</td><td>负责数据包从源到宿的传递和网际互连</td><td>包 Packet</td><td>IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器）</td></tr><tr><td>数据链路层</td><td>将比特组装成帧和点到点的传递</td><td>帧 Frame</td><td>PPP、FR、HDLC、VLAN、MAC（网桥，交换机）</td></tr><tr><td>物理层</td><td>通过媒介传输比特，确定机械及电气规范</td><td>比特 Bit</td><td>RJ45、CLOCK、IEEE802.3（中继器，集线器）</td></tr></tbody></table></div><blockquote><p>参考：<a href="http://www.colasoft.com.cn/download/protocols_map.php">网络通讯协议图</a></p></blockquote><h2 id="二、常用协议"><a href="#二、常用协议" class="headerlink" title="二、常用协议"></a>二、常用协议</h2><h3 id="2-1-以太网协议头格式"><a href="#2-1-以太网协议头格式" class="headerlink" title="2.1 以太网协议头格式"></a>2.1 以太网协议头格式</h3><p><img src="/images/TCP模型协议状态机速览/以太网协议头格式.png" alt="以太网协议头格式"></p><h3 id="2-2-ICMP-协议头格式"><a href="#2-2-ICMP-协议头格式" class="headerlink" title="2.2 ICMP 协议头格式"></a>2.2 ICMP 协议头格式</h3><p><img src="/images/TCP模型协议状态机速览/ICMP协议头格式.png" alt="ICMP协议头格式"></p><h3 id="2-3-IPv4-协议头格式"><a href="#2-3-IPv4-协议头格式" class="headerlink" title="2.3 IPv4 协议头格式"></a>2.3 IPv4 协议头格式</h3><p><img src="/images/TCP模型协议状态机速览/IPv4协议头格式.png" alt="IPv4协议头格式"></p><h3 id="2-4-TCP-协议头格式"><a href="#2-4-TCP-协议头格式" class="headerlink" title="2.4 TCP 协议头格式"></a>2.4 TCP 协议头格式</h3><p><img src="/images/TCP模型协议状态机速览/TCP协议头格式.png" alt="TCP协议头格式"></p><h3 id="2-5-UDP-协议头格式"><a href="#2-5-UDP-协议头格式" class="headerlink" title="2.5 UDP 协议头格式"></a>2.5 UDP 协议头格式</h3><p><img src="/images/TCP模型协议状态机速览/UDP协议头格式.png" alt="UDP协议头格式"></p><blockquote><p>图片来源：<a href="https://nmap.org/book/tcpip-ref.html">TCP/IP Reference</a></p></blockquote><h2 id="三、TCP状态机"><a href="#三、TCP状态机" class="headerlink" title="三、TCP状态机"></a>三、TCP状态机</h2><h3 id="3-1-完整-TCP-连接和断开状态图"><a href="#3-1-完整-TCP-连接和断开状态图" class="headerlink" title="3.1 完整 TCP 连接和断开状态图"></a>3.1 完整 TCP 连接和断开状态图</h3><p><img src="/images/TCP模型协议状态机速览/完整TCP连接和断开状态图.png" alt="完整TCP连接和断开状态图"></p><blockquote><p>图片来源：<a href="http://www.tcpipguide.com/free/t_TCPOperationalOverviewandtheTCPFiniteStateMachineF-2.htm">TCP Operational Overview and the TCP Finite State Machine (FSM) 2</a></p></blockquote><h3 id="3-2-TCP-断开状态图"><a href="#3-2-TCP-断开状态图" class="headerlink" title="3.2 TCP 断开状态图"></a>3.2 TCP 断开状态图</h3><p><img src="/images/TCP模型协议状态机速览/TCP断开状态图.png" alt="TCP断开状态图"></p><blockquote><p>图片来源：<a href="http://www.tcpipguide.com/free/t_TCPConnectionTermination-2.htm">TCP Connection Termination 2</a></p></blockquote><h3 id="3-3-TCP-双方同时断开状态图"><a href="#3-3-TCP-双方同时断开状态图" class="headerlink" title="3.3 TCP 双方同时断开状态图"></a>3.3 TCP 双方同时断开状态图</h3><p><img src="/images/TCP模型协议状态机速览/TCP双方同时断开状态图.png" alt="TCP双方同时断开状态图"></p><blockquote><p>图片来源：<a href="http://www.tcpipguide.com/free/t_TCPConnectionTermination-4.htm">TCP Connection Termination 4</a></p></blockquote><h3 id="3-4-实际操作和截图"><a href="#3-4-实际操作和截图" class="headerlink" title="3.4 实际操作和截图"></a>3.4 实际操作和截图</h3><h4 id="3-4-1-TCP-连接发送数据断开的-Wireshark-截图"><a href="#3-4-1-TCP-连接发送数据断开的-Wireshark-截图" class="headerlink" title="3.4.1 TCP 连接发送数据断开的 Wireshark 截图"></a>3.4.1 TCP 连接发送数据断开的 Wireshark 截图</h4><p><img src="/images/TCP模型协议状态机速览/TCP连接发送数据断开的Wireshark截图.png" alt="TCP连接发送数据断开的Wireshark截图"></p><ul><li><p>让 Wireshark 显示绝对的 sequence numbers</p><p>  在菜单栏依次点击 <code>编辑</code> -&gt; <code>首选项</code> -&gt; <code>Protocols</code> -&gt; <code>TCP</code> 中，取消选项 <code>Relative sequence numbers</code> 前的复选框。</p></li><li><p>如何显示截图的界面</p><p>  在菜单栏依次点击 <code>统计</code> -&gt; <code>流量图</code>，然后点击右键，在弹出的选项中选择<code>放大</code>/<code>缩小</code>调整图形。</p></li></ul><h4 id="3-4-2-环境及操作"><a href="#3-4-2-环境及操作" class="headerlink" title="3.4.2 环境及操作"></a>3.4.2 环境及操作</h4><p>两台机器分别是：</p><ul><li>A: 192.168.81.88（Windows 10）</li><li>B: 192.168.20.122（CentOS 7.7）</li></ul><p>操作步骤：</p><ol><li>B 在 9999 端口监听 TCP 连接；</li><li>A 连接 B的9999 端口；</li><li>A 向 B 发送 4 个字节的数据；</li><li>B 向 A 发送 4 个字节的数据；</li><li>B 主动断开连接。</li></ol><h3 id="3-5-常见问题"><a href="#3-5-常见问题" class="headerlink" title="3.5 常见问题"></a>3.5 常见问题</h3><h4 id="3-5-1-TIME-WAIT-会在什么情况下出现"><a href="#3-5-1-TIME-WAIT-会在什么情况下出现" class="headerlink" title="3.5.1 TIME_WAIT 会在什么情况下出现"></a>3.5.1 TIME_WAIT 会在什么情况下出现</h4><p>如果处于 TIMEWAIT 状态，说明双方建立成功过连接，而且已经发送了最后的 ACK 之后，才会处于这个状态，而且是主动发起关闭的一方处于这个状态。</p><p>其次，当断开TCP的主动方收到了被动方发来的FIN包并回复对应的ACK包给被动方后，主动方就进入了TIME_WAIT状态。然后等待<code>2 * MSL</code>时间（此时间段内如果再次收到被动方发来的FIN消息，说明之前回复的ACK包丢失，需要重新发送给被动方，并重新开始计时）后，再进入CLOSED状态，此时才能完成的释放相关的资源。</p><p>如果存在大量的 TIMEWAIT，往往是因为短连接太多，不断的创建连接，然后释放连接，从而导致很多连接在这个状态，可能会导致无法发起新的连接。解决的方式往往是：</p><ul><li>打开 tcp_tw_recycle 和 tcp_timestamps 选项；</li><li>打开 tcp_tw_reuse 和 tcp_timestamps 选项；</li><li>程序中使用 SO_LINGER，应用强制使用 rst 关闭。</li></ul><p>当客户端收到 Connection Reset，往往是收到了 TCP 的 RST 消息，RST 消息一般在下面的情况下发送：</p><ul><li>试图连接一个未被监听的服务端；</li><li>对方处于 TIMEWAIT 状态，或者连接已经关闭处于 CLOSED 状态，或者重新监听 seq num 不匹配；</li><li>发起连接时超时，重传超时，keepalive 超时；</li><li>在程序中使用 SO_LINGER，关闭连接时，放弃缓存中的数据，给对方发送 RST。</li></ul><h4 id="3-5-2-什么是-MSL"><a href="#3-5-2-什么是-MSL" class="headerlink" title="3.5.2 什么是 MSL"></a>3.5.2 什么是 MSL</h4><p><a href="https://en.wikipedia.org/wiki/Maximum_segment_lifetime">MSL, Maximum Segment Lifetime</a>，TCP Segment 在网络上的最长存活时间。</p><p><a href="www.rfc-editor.org/rfc/rfc793.txt">RFC793</a> 将 MSL 定义为 2 分钟。Linux 下 MSL 默认是 30 秒，Windows 下 MSL 默认是 240 秒。Linux 下可以通过下面的命令查看实际的 MSL 值。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sysctl net.ipv4.tcp_fin_timeout<span class="token function">cat</span> /proc/sys/net/ipv4/tcp_fin_timeout<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="3-5-3-为什么不直接进入-CLOSED-状态，还需要等待-2-MSL-时间"><a href="#3-5-3-为什么不直接进入-CLOSED-状态，还需要等待-2-MSL-时间" class="headerlink" title="3.5.3 为什么不直接进入 CLOSED 状态，还需要等待 2 * MSL 时间"></a>3.5.3 为什么不直接进入 CLOSED 状态，还需要等待 <code>2 * MSL</code> 时间</h4><p>主要原因有两个：</p><ol><li><p>进入TIME_WAIT状态并等待 <code>2 * MSL</code>，保证了如果被动方没有收到主动方回复的 ACK，被动方至少有时间能重发一次之前 FIN 包。一回一重发，正好 <code>2 * MSL</code>。</p><blockquote><p>如果主动方回的 ACK 包丢失，被动方重发的 FIN 包也丢失，那么就不管了。</p></blockquote></li><li><p>避免断开的 TCP 连接不影响后面新建立的 TCP 连接。</p><blockquote><p>如果主动方不等待 <code>2*MSL</code> 直接进入 CLOSED 状态，然后再重新建立 TCP 连接，如果此时收到了之前关闭的被动方重发 FIN 消息，那么重新建立的 TCP 连接就会被断开。</p></blockquote></li></ol><h2 id="四、TCP-滑动窗口"><a href="#四、TCP-滑动窗口" class="headerlink" title="四、TCP 滑动窗口"></a>四、TCP 滑动窗口</h2><h3 id="4-1-什么是滑动窗口"><a href="#4-1-什么是滑动窗口" class="headerlink" title="4.1 什么是滑动窗口"></a>4.1 什么是滑动窗口</h3><p>滑动窗口（Sliding Window），也叫发送窗口（Send Window），滑动窗口表明接收方有多少空间来接收数据。在 TCP 连接建立的过程中协商滑动窗口的大小，当连接成功建立后，双方的滑动窗口的大小都协商好了。在通信的过程中也可以动态的修改滑动窗口的大小。</p><p>滑动窗口主要用来做流控（Flow Control），它主要受 TCP 连接双方内存大小的影响，并不直接关心网速等问题。所以完整的 TCP 控制除了流控（Flow Control）外，还有需要拥塞处理（Congestion Handling）来处理网络相关的问题。</p><p><img src="/images/TCP模型协议状态机速览/什么是滑动窗口.png" alt="什么是滑动窗口"></p><ol><li>已经收到 ACK 确认的数据。字节 1-31；</li><li>在滑动窗口中，已经发送出去了，但是还没收到 ACK 确认的数据。字节 32-45；</li><li>在滑动窗口中，还没发送出去的数据（接收方还有空间接收）。字节 46-51；</li><li>待发送的数据（接收方没有空间接收）。字节 52 及以上。</li></ol><blockquote><p>图片来源：<a href="http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo-6.htm">TCP Sliding Window Acknowledgment System For Data Transport, Reliability and Flow Control 6</a></p></blockquote><h3 id="4-2-滑动窗口怎么工作"><a href="#4-2-滑动窗口怎么工作" class="headerlink" title="4.2 滑动窗口怎么工作"></a>4.2 滑动窗口怎么工作</h3><ol><li><p>当上图中所有滑动窗口内的数据都发送出后，滑动窗口内的状态变成了下图的状态：</p><p> <img src="/images/TCP模型协议状态机速览/滑动窗口内的数据都已被发送但未被确认.png" alt="滑动窗口内的数据都已被发送但未被确认"></p><blockquote><p>图片来源：<a href="http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo-7.htm">TCP Sliding Window Acknowledgment System For Data Transport, Reliability and Flow Control 7</a></p></blockquote><ol><li>已经收到 ACK 确认的数据。字节 1-31；</li><li>在滑动窗口中，已经发送出去了，但是还没收到 ACK 确认的数据。字节 32-51；</li><li>在滑动窗口中，还没发送出去的数据（接收方还有空间接收）。无；</li><li>待发送的数据（接收方没有空间接收）。字节 52 及以上；</li></ol></li><li><p>如果一段时间后，收到了 32-36 字节的 ACK 确认消息，那么滑动窗口就会向后面滑动，并可以发送字节 52-56。如下图：</p><p> <img src="/images/TCP模型协议状态机速览/滑动窗口收到确认后向后滑动.png" alt="滑动窗口收到确认后向后滑动"></p><blockquote><p>图片来源：<a href="http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo-8.htm">TCP Sliding Window Acknowledgment System For Data Transport, Reliability and Flow Control 8</a></p></blockquote><ol><li>已经收到 ACK 确认的数据。字节 1-36；</li><li>在滑动窗口中，已经发送出去了，但是还没收到 ACK 确认的数据。字节 37-51；</li><li>在滑动窗口中，还没发送出去的数据（接收方还有空间接收）。字节 52-56；</li><li>待发送的数据（接收方没有空间接收）。字节 57 及以上。</li></ol></li><li><p>循环上面的步骤就能够一直发送数据了。如下图（下图中滑动窗口没有向后滑动，所以最后滑动窗口的大小会变成 0）：</p><p> <img src="/images/TCP模型协议状态机速览/滑动窗口完整工作流程.png" alt="滑动窗口完整工作流程"></p><blockquote><p>图片来源：<a href="http://www.tcpipguide.com/free/t_TCPWindowSizeAdjustmentandFlowControl-2.htm">TCP Window Size Adjustment and Flow Control 2</a></p></blockquote></li></ol><h3 id="4-3-常见问题"><a href="#4-3-常见问题" class="headerlink" title="4.3 常见问题"></a>4.3 常见问题</h3><h4 id="4-3-1-如果滑动窗口变成了-0-会发生什么"><a href="#4-3-1-如果滑动窗口变成了-0-会发生什么" class="headerlink" title="4.3.1 如果滑动窗口变成了 0 会发生什么"></a>4.3.1 如果滑动窗口变成了 0 会发生什么</h4><p>当滑动窗口减少到 0 后，就不能再发送数据给对方了。此时可以发送 <code>Zero Window Probe</code> 包给对方，这样在对方回复此包的 ACK 的同时，可以更新滑动窗口的大小。</p><h4 id="4-3-2-什么是“糊涂窗口综合症”"><a href="#4-3-2-什么是“糊涂窗口综合症”" class="headerlink" title="4.3.2 什么是“糊涂窗口综合症”"></a>4.3.2 什么是“糊涂窗口综合症”</h4><p>如果发送方每次都发送很少的字节，或者接受方每次都处理很少的字节时，或者双方都有的情况下，就叫 <code>糊涂窗口综合症（Silly Window Syndrome）</code>。因为每次发送出去的字节数很少，比如几个字节，明显小于了 TCP/IP 的协议头的大小（TCP+IP 头有 40 个字节），此时网络传输的效率就很低。</p><p>一个解决办法就是使用<a href="https://en.wikipedia.org/wiki/Nagle%27s_algorithm">纳格算法，Nagle’s algorithm</a>，这个算法默认是启用的。该算法的伪代码如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">if there is new data to send then    if the window size ≥ MSS and available data is ≥ MSS then        send complete MSS segment now    else        if there is unconfirmed data still in the pipe then            enqueue data in the buffer until an acknowledge is received        else            send data immediately        end if    end ifend if<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、TCP拥塞处理"><a href="#五、TCP拥塞处理" class="headerlink" title="五、TCP拥塞处理"></a>五、TCP拥塞处理</h2><h3 id="5-1-为什么需要拥塞处理"><a href="#5-1-为什么需要拥塞处理" class="headerlink" title="5.1 为什么需要拥塞处理"></a>5.1 为什么需要拥塞处理</h3><p>如果网络延时突然增大丢包严重，TCP 发送出去的数据包，很久都没收到对应包的 ACK，那么 TCP 就只能选择重传该数据包。但是不能无限制不间断的重发数据包，因为这会增加网络的负担，导致更大的网络延迟和更多的网络丢包，所以需要拥塞处理（Congestion Handling）来控制数据包的重发。</p><h2 id="六、其他常见问题"><a href="#六、其他常见问题" class="headerlink" title="六、其他常见问题"></a>六、其他常见问题</h2><h3 id="6-1-MTU-1500-的具体含义是什么"><a href="#6-1-MTU-1500-的具体含义是什么" class="headerlink" title="6.1 MTU 1500 的具体含义是什么"></a>6.1 MTU 1500 的具体含义是什么</h3><p>MTU（Maximum Transmission Unit，最大传输单元）是二层的一个定义。以以太网为例，MTU 为 1500 个 Byte，前面有 6 个 Byte 的目标 MAC 地址，6 个 Byte 的源 MAC 地址，2 个 Byte 的类型，后面有 4 个 Byte 的 CRC 校验，共 1518 个 Byte。</p><p>在 IP 层，一个 IP 数据报在以太网中传输，如果它的长度大于该 MTU 值，就要进行分片传输。如果不允许分片 DF，就会发送 ICMP 包，</p><p>在 TCP 层有个 MSS（Maximum Segment Size，最大分段大小），它等于 MTU 减去 IP 头，再减去 TCP 头。即在不分片的情况下，TCP 里面放的最大内容。</p><h3 id="6-2-HTTPS-的双向认证流程"><a href="#6-2-HTTPS-的双向认证流程" class="headerlink" title="6.2 HTTPS 的双向认证流程"></a>6.2 HTTPS 的双向认证流程</h3><p><img src="/images/TCP模型协议状态机速览/HTTPS的双向认证流程.jpg" alt="HTTPS的双向认证流程"></p><p>其中，随机数和 premaster 的含义是：</p><p><img src="/images/TCP模型协议状态机速览/HTTPS中的随机数和premaster.jpg" alt="HTTPS中的随机数和premaster"></p><h3 id="6-3-RTMP-连接建立的过程"><a href="#6-3-RTMP-连接建立的过程" class="headerlink" title="6.3 RTMP 连接建立的过程"></a>6.3 RTMP 连接建立的过程</h3><ol><li>首先，客户端发送 C0 表明自己的版本号，不必等对方的回复，然后发送 C1 表明自己的时间戳。</li><li>服务器只有在收到 C0 的时候，才能返回 S0，表明自己的版本号。如果版本不匹配，可以断开连接。</li><li>服务器发送完 S0 后，也不用等什么，就直接发送自己的时间戳 S1。客户端收到 S1 的时候，发一个知道了对方时间戳的 ACK C2。同理服务器收到 C1 的时候，发一个知道了对方时间戳的 ACK S2。</li><li>握手完成。</li></ol><p><img src="/images/TCP模型协议状态机速览/RTMP连接建立的过程.jpg" alt="RTMP连接建立的过程"></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP状态机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深度探索C++对象模型》读书笔记</title>
      <link href="shen-du-tan-suo-c-dui-xiang-mo-xing-du-shu-bi-ji/"/>
      <url>shen-du-tan-suo-c-dui-xiang-mo-xing-du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="一、关于对象"><a href="#一、关于对象" class="headerlink" title="一、关于对象"></a>一、关于对象</h2><p>关于菱形继承对象的内存分布，可以查看<a href="https://kibazen.cn/c-ling-xing-ji-cheng-nei-cun-bu-ju-fen-xi/">C++菱形继承内存布局分析</a>了解。</p><h2 id="二、构造函数语义学"><a href="#二、构造函数语义学" class="headerlink" title="二、构造函数语义学"></a>二、构造函数语义学</h2><ol><li><p>四种情况下，编译器会为未声明 contructor 的 class 合成一个 default constructor。</p><ul><li><p>带有 Default Constructor 的 Member Class Object</p><blockquote><p>如果一个 class 没有任何的 constructor， 但是它含有一个拥有 default constructor 的 member object，那么这个 class 的 <strong>implicit default constructor</strong> 就是 nontrivial，编译器需要为此 class 合成一个 default constructor。此 class 的 default constructor 会调用每个 member object 的 default constructor。</p></blockquote></li><li><p>带有 Default Constructor 的 Base Class</p><blockquote><p>类似的道理，一个没有任何 constructor 的 class 派生自一个带有 default constructor 的 base class，这个 derived class 的 default constructor 会被视为 nontrivial，并需要被合成出来。它将调用上一层 base class 的 default constructor （根据它们的声明次序）。对这个 derived class 来说，合成出来的 constructor 和一个明确提供的 default constructor 一样。</p></blockquote></li><li><p>带有一个Virtual Function 的 Class</p><blockquote><p>另外两种情况，也需要合成出 default constructor：</p><ol><li>class 声明（或继承）一个 virtual function。</li><li>class 派生自一个继承串链，其中有一个或更多的 virtual base classes。</li></ol></blockquote></li><li><p>带有一个 Virtual Base Class 的 Class</p><p>这些合成的 constructor 叫 <strong>implicit nontrivial default constructor</strong>。不满足上面四种情况且没有声明任何 constructor 的 class， 他们的 constructor 叫 <strong>implicit trivial default constructor</strong>，编译不会为这些 class 合成 constructor。</p><p>在合成的 default constructor 中，只有 <strong>base class subojects</strong> 和 <strong>member class objects</strong> 会被初始化。所有其他的 nonstatic data member，如整数、整数指针、整数数组等都不会被初始化。</p></li></ul></li><li><p>和 default constructor 一样，如果 class 没有声明一个 copy constructor，编译器就会隐式的声明（implicitly declared）或隐式的定义（implicitly defined）一个。copy constructor 也分为 trivial 和 nontrivial 两种。只有 nontrivial 的实体才会被合成于程序中。决定一个 copy constructor 是否为 trivial 的标准在于 class 是否展现出所谓的“bitwise copy semantic”。</p></li><li><p>四种情况下，class 不展现出“bitwise copy semantic”。</p><ul><li><p>当 class 内含一个 member object 而后者的 class 声明中有一个 copy constructor。</p></li><li><p>当 class 继承自一个 base class 而后者存在有一个 copy constructor 时（不能是被明确声明或是被合成而得）。</p></li><li><p>当 class 声明一个或多个 virtual functions 时。</p></li><li><p>当 class 派生自一个继承串链，其中有一个或多个 virtual base classes 时。</p></li></ul></li></ol><h2 id="三、Data-语意学"><a href="#三、Data-语意学" class="headerlink" title="三、Data 语意学"></a>三、Data 语意学</h2><ol><li><p>上古时期，下面代码中，类A的成员函数返回的是全局x，而不是成员变量x。这个问题已经修复了，现在总数返回成员变量x。</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">A</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>下面的代码中，val_t的类型是使用全局的val_t的定义，即x，而不是类中声明的val_t，所以需注意。</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> val_t <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">A</span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">FuncA</span><span class="token punctuation">(</span>val_t v<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(val_t) = %d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// = sizeof(int) = 4</span>    <span class="token punctuation">}</span>    <span class="token keyword">using</span> val_t <span class="token operator">=</span> <span class="token keyword">char</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">FuncB</span><span class="token punctuation">(</span>val_t v<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(val_t) = %d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// = sizeof(char) = 1</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span><span class="token punctuation">{</span>    A a<span class="token punctuation">;</span>    a<span class="token punctuation">.</span><span class="token function">FuncA</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span><span class="token function">FuncB</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 运行结果</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">sizeof(val_t) = 4sizeof(val_t) = 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h2 id="四、Function-语意学"><a href="#四、Function-语意学" class="headerlink" title="四、Function 语意学"></a>四、Function 语意学</h2><h2 id="五、构造、解构、拷贝语意学"><a href="#五、构造、解构、拷贝语意学" class="headerlink" title="五、构造、解构、拷贝语意学"></a>五、构造、解构、拷贝语意学</h2><h2 id="六、执行期语意学"><a href="#六、执行期语意学" class="headerlink" title="六、执行期语意学"></a>六、执行期语意学</h2><h2 id="七、站在对象模型的尖端"><a href="#七、站在对象模型的尖端" class="headerlink" title="七、站在对象模型的尖端"></a>七、站在对象模型的尖端</h2>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++菱形继承内存布局分析</title>
      <link href="c-ling-xing-ji-cheng-nei-cun-bu-ju-fen-xi/"/>
      <url>c-ling-xing-ji-cheng-nei-cun-bu-ju-fen-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、编译环境"><a href="#一、编译环境" class="headerlink" title="一、编译环境"></a>一、编译环境</h2><ul><li>Visual Studio 2017</li><li>G++ (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0</li><li>Clang++ 6.0.0-1ubuntu2</li></ul><hr><h2 id="二、非虚继承"><a href="#二、非虚继承" class="headerlink" title="二、非虚继承"></a>二、非虚继承</h2><h3 id="2-1-测试代码"><a href="#2-1-测试代码" class="headerlink" title="2.1 测试代码"></a>2.1 测试代码</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// filename: nonvirtual.cpp</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio&gt;</span></span><span class="token keyword">struct</span> <span class="token class-name">A</span><span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">FA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> a <span class="token operator">=</span> <span class="token number">0x1111111111111111LL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">A</span></span><span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">FB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> b <span class="token operator">=</span> <span class="token number">0x2222222222222222LL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">C</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">A</span></span><span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">FC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> c <span class="token operator">=</span> <span class="token number">0x3333333333333333LL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">D</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">B</span><span class="token punctuation">,</span> <span class="token class-name">C</span></span><span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">FD</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> d <span class="token operator">=</span> <span class="token number">0x4444444444444444LL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span><span class="token punctuation">{</span>    A a<span class="token punctuation">;</span>    B b<span class="token punctuation">;</span>    C c<span class="token punctuation">;</span>    D d<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(void*) = %zu\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(a) = %zu, &amp;a = %p\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(b) = %zu, &amp;b = %p\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(c) = %zu, &amp;c = %p\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(d) = %zu, &amp;d = %p\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-编译方式"><a href="#2-2-编译方式" class="headerlink" title="2.2 编译方式"></a>2.2 编译方式</h3><h4 id="2-2-1-VS20177"><a href="#2-2-1-VS20177" class="headerlink" title="2.2.1 VS20177"></a>2.2.1 VS20177</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">Debug x64<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-2-2-G"><a href="#2-2-2-G" class="headerlink" title="2.2.2 G++"></a>2.2.2 G++</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">g++ -std<span class="token operator">=</span>c++11 -ggdb -o gcc-nv.out nonvirtual.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-2-3-Clang"><a href="#2-2-3-Clang" class="headerlink" title="2.2.3 Clang++"></a>2.2.3 Clang++</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">clang++ -std<span class="token operator">=</span>c++11 -ggdb -o clang-nv.out nonvirtual.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-3-执行结果"><a href="#2-3-执行结果" class="headerlink" title="2.3 执行结果"></a>2.3 执行结果</h3><h4 id="2-3-1-VS2017"><a href="#2-3-1-VS2017" class="headerlink" title="2.3.1 VS2017"></a>2.3.1 VS2017</h4><ol><li><p>执行结果</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">sizeof(void*) = 8sizeof(a) = 16, &amp;a = 000000204193F818sizeof(b) = 24, &amp;b = 000000204193F848sizeof(c) = 24, &amp;c = 000000204193F878sizeof(d) = 56, &amp;d = 000000204193F8A8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>类D的内存布局</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">+----------------+|                || +------------+ || |            | |      +---------+| | +--------+ | |      |         || | | A.vptr+----------&gt;+ A::FA() || | | A::a   | | |      | B::FB() || | +--------+ | |      | D::FD() || |   B::b     | |      |         || +------------+ |      +---------+|                || +------------+ || |            | |      +---------+| | +--------+ | |      |         || | | A.vptr+----------&gt;+ A::FA() || | | A::a   | | |      | C::FC() || | +--------+ | |      |         || |   C::c     | |      +---------+| +------------+ ||                ||     D::d       ||                |+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>类D的内存DUMP</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">0x000000204193F8A8  00007ff7c032b1e8 1111111111111111 2222222222222222 00007ff7c032ae18 1111111111111111 33333333333333330x000000204193F8D8  44444444444444440x00007FF7C032B1E8  00007ff7c0321302 00007ff7c03211b8 00007ff7c032105a0x00007FF7C032AE18  00007ff7c0321302 00007ff7c03212e4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="2-3-2-G"><a href="#2-3-2-G" class="headerlink" title="2.3.2 G++"></a>2.3.2 G++</h4><ol><li><p>执行结果</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">sizeof(void*) = 8sizeof(a) = 16, &amp;a = 0x7fffffffe350sizeof(b) = 24, &amp;b = 0x7fffffffe360sizeof(c) = 24, &amp;c = 0x7fffffffe380sizeof(d) = 56, &amp;d = 0x7fffffffe3a0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>类D的内存布局</p><p> 和VS2017的结果类似。</p></li><li><p>类D的内存DUMP</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">(gdb) x /7a &amp;d0x7fffffffe3a0: 0x555555755ca8 &lt;_ZTV1D+16&gt;      0x11111111111111110x7fffffffe3b0: 0x2222222222222222      0x555555755cd0 &lt;_ZTV1D+56&gt;0x7fffffffe3c0: 0x1111111111111111      0x33333333333333330x7fffffffe3d0: 0x4444444444444444(gdb) x /3a 0x555555755ca80x555555755ca8 &lt;_ZTV1D+16&gt;:     0x555555554b96 &lt;A::FA()&gt;        0x555555554ba2 &lt;B::FB()&gt;0x555555755cb8 &lt;_ZTV1D+32&gt;:     0x555555554bba &lt;D::FD()&gt;(gdb) x /2a 0x555555755cd00x555555755cd0 &lt;_ZTV1D+56&gt;:     0x555555554b96 &lt;A::FA()&gt;        0x555555554bae &lt;C::FC()&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="2-3-3-Clang"><a href="#2-3-3-Clang" class="headerlink" title="2.3.3 Clang++"></a>2.3.3 Clang++</h4><ol><li><p>执行结果</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">sizeof(void*) = 8sizeof(a) = 16, &amp;a = 0x7fffffffe3c0sizeof(b) = 24, &amp;b = 0x7fffffffe3a8sizeof(c) = 24, &amp;c = 0x7fffffffe390sizeof(d) = 56, &amp;d = 0x7fffffffe358<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>类D的内存布局</p><p> 和VS2017的结果类似。</p></li><li><p>类D的内存DUMP</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">(gdb) x /7a &amp;d0x7fffffffe358: 0x400a88 &lt;_ZTV1D+16&gt;    0x11111111111111110x7fffffffe368: 0x2222222222222222      0x400ab0 &lt;_ZTV1D+56&gt;0x7fffffffe378: 0x1111111111111111      0x33333333333333330x7fffffffe388: 0x4444444444444444(gdb) x /3a 0x400a880x400a88 &lt;_ZTV1D+16&gt;:   0x400880 &lt;A::FA()&gt;      0x400890 &lt;B::FB()&gt;0x400a98 &lt;_ZTV1D+32&gt;:   0x4008b0 &lt;D::FD()&gt;(gdb) x /2a 0x400ab00x400ab0 &lt;_ZTV1D+56&gt;:   0x400880 &lt;A::FA()&gt;      0x4008a0 &lt;C::FC()&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><hr><h2 id="三、虚继承"><a href="#三、虚继承" class="headerlink" title="三、虚继承"></a>三、虚继承</h2><h3 id="3-1-测试代码"><a href="#3-1-测试代码" class="headerlink" title="3.1 测试代码"></a>3.1 测试代码</h3><p>与<a href="#二非虚继承">非虚拟继承</a>的测试代码类似，只是将非虚拟继承改成了虚拟继承。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// filename: virtual.cpp</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio&gt;</span></span><span class="token keyword">struct</span> <span class="token class-name">A</span><span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">FA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> a <span class="token operator">=</span> <span class="token number">0x1111111111111111LL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">A</span></span><span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">FB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> b <span class="token operator">=</span> <span class="token number">0x2222222222222222LL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">C</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">A</span></span><span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">FC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> c <span class="token operator">=</span> <span class="token number">0x3333333333333333LL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">D</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">B</span><span class="token punctuation">,</span> <span class="token class-name">C</span></span><span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">FD</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> d <span class="token operator">=</span> <span class="token number">0x4444444444444444LL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span><span class="token punctuation">{</span>    A a<span class="token punctuation">;</span>    B b<span class="token punctuation">;</span>    C c<span class="token punctuation">;</span>    D d<span class="token punctuation">;</span>    <span class="token keyword">auto</span> pba <span class="token operator">=</span> <span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span>A<span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> pda <span class="token operator">=</span> <span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span>A<span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> pdb <span class="token operator">=</span> <span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span>B<span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(void*) = %zu\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(a) = %zu, &amp;a = %p\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(b) = %zu, &amp;b = %p\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(c) = %zu, &amp;c = %p\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(d) = %zu, &amp;d = %p\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-编译方式"><a href="#3-2-编译方式" class="headerlink" title="3.2 编译方式"></a>3.2 编译方式</h3><h4 id="3-2-1-vs2017"><a href="#3-2-1-vs2017" class="headerlink" title="3.2.1 vs2017"></a>3.2.1 vs2017</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">Debug x64<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-2-2-G"><a href="#3-2-2-G" class="headerlink" title="3.2.2 G++"></a>3.2.2 G++</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">g++ -std<span class="token operator">=</span>c++11 -ggdb -o gcc-v.out virtual.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-2-3-Clang"><a href="#3-2-3-Clang" class="headerlink" title="3.2.3 Clang++"></a>3.2.3 Clang++</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">clang++ -std<span class="token operator">=</span>c++11 -ggdb -o clang-v.out virtual.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-3-执行结果"><a href="#3-3-执行结果" class="headerlink" title="3.3 执行结果"></a>3.3 执行结果</h3><p>VS2017的执行结果与G++和Clang++不同。</p><h4 id="3-3-1-VS2017"><a href="#3-3-1-VS2017" class="headerlink" title="3.3.1 VS2017"></a>3.3.1 VS2017</h4><ol><li><p>执行结果</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">sizeof(void*) = 8sizeof(a) = 16, &amp;a = 00000002F65FF658sizeof(b) = 40, &amp;b = 00000002F65FF688sizeof(c) = 40, &amp;c = 00000002F65FF6C8sizeof(d) = 72, &amp;d = 00000002F65FF710<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>对类B的分析</p><ul><li><p>类B的内存分布</p>  <pre class="line-numbers language-text" data-language="text"><code class="language-text">                +--------------+                |              |+---------+     | +----------+ || B::FB() +&lt;--------+B.vptr   | |      +--------------------++---------+     | | B.offset+--------&gt;+ offset2ptr    = -8 |                | | B::b     | |      | offset2A.vptr = 16 |                | +----------+ |      +--------------------+                |              |+---------+     | +----------+ || A::FA() +&lt;-------+A.vptr   | |+---------+     | | A::a     | |                | +----------+ |                |              |                +--------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>类B的内存DUMP</p>  <pre class="line-numbers language-text" data-language="text"><code class="language-text">0x00000002F65FF688  00007ff6cd4eadb0 00007ff6cd4eb1e0 2222222222222222 00007ff6cd4eadc8 11111111111111110x00007FF6CD4EADB0  00007ff6cd4e11b8 &lt;B::FB()&gt;0x00007FF6CD4EB1E0  fffffff8 000000100x00007FF6CD4EADC8  00007ff6cd4e1302 &lt;A::FA()&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>对类D的分析</p><ul><li><p>类D的内存布局</p><p>  offset中，offset2ptr的数据是没使用的。</p>  <pre class="line-numbers language-text" data-language="text"><code class="language-text">                +--------------+                |              |+---------+     | +----------+ || B::FB() +&lt;-------+B.vptr   | |      +--------------------+| D::FD() |     | | B.offset+--------&gt;+ offset2ptr    = -8 |+---------+     | | B::b     | |      | offset2A.vptr = 48 |                | +----------+ |      | offset2vptr   = -8 |                |              |      | offset2C.vptr = 24 |+---------+     | +----------+ |      +--------------------+| C::FC() +&lt;-------+C.vptr   | |      +--------------------++---------+     | | C.offset+--------&gt;+ offset2vptr   = -8 |                | | C::c     | |      | offset2A.vptr = 24 |                | +----------+ |      +--------------------+                |              |                |   D::d       |                |              |+---------+     | +----------+ || A::FA() +&lt;-------+A.vptr   | |+---------+     | | A::a     | |                | +----------+ |                |              |                +--------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>类D的内存DUMP</p>  <pre class="line-numbers language-text" data-language="text"><code class="language-text">0x00000002F65FF710  00007ff6cd4eb098 00007ff6cd4eac10 2222222222222222 00007ff6cd4eae70 00007ff6cd4eac18 33333333333333330x00000002F65FF740  4444444444444444 00007ff6cd4eae90 11111111111111110x00007FF6CD4EB098  00007ff6cd4e11b8 &lt;B::FB()&gt; 00007ff6cd4e105a &lt;D::FD()&gt;0x00007FF6CD4EAC10  fffffff8 00000030 fffffff8 000000180x00007FF6CD4EAE70  00007ff6cd4e12e4 &lt;C::FC()&gt;0x00007FF6CD4EAC18  fffffff8 000000180x00007FF6CD4EAE90  00007ff6cd4e1302 &lt;A::FA()&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ol><h4 id="3-3-2-G"><a href="#3-3-2-G" class="headerlink" title="3.3.2 G++"></a>3.3.2 G++</h4><ol><li><p>执行结果</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">sizeof(void*) = 8sizeof(a) = 16, &amp;a = 0x7fffffffe360sizeof(b) = 32, &amp;b = 0x7fffffffe370sizeof(c) = 32, &amp;c = 0x7fffffffe390sizeof(d) = 56, &amp;d = 0x7fffffffe3b0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>对类B的分析</p><ul><li><p>类B的内存DUMP</p></li><li><p>类B的内存布局</p>  <pre class="line-numbers language-text" data-language="text"><code class="language-text">+------------+|            || +--------+ |     +---------+| | B.vptr+-------&gt;+ B::FB() || | B::b   | |     +---------+| +--------+ || +--------| |     +---------+| | A.vptr+-------&gt;+ A::FA() || | A::a   | |     +---------+| +--------+ ||            |+------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>  <pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt;&gt;&gt; x /4a &amp;b0x7fffffffe370: 0x555555755cc8 &lt;_ZTV1B+24&gt;      0x22222222222222220x7fffffffe380: 0x555555755ce8 &lt;_ZTV1B+56&gt;      0x1111111111111111&gt;&gt;&gt; x /1a 0x555555755cc80x555555755cc8 &lt;_ZTV1B+24&gt;:     0x555555554dc4 &lt;B::FB()&gt;&gt;&gt;&gt; x /1a 0x555555755ce80x555555755ce8 &lt;_ZTV1B+56&gt;:     0x555555554db8 &lt;A::FA()&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>对类D的分析</p><ul><li><p>类D的内存布局</p>  <pre class="line-numbers language-text" data-language="text"><code class="language-text">+----------------+|                || +------------+ || |            | || | +--------+ | |      +---------+| | | B.vptr+----------&gt;+ B::FB() || | | B::b   | | |      | D::FD() || | +--------+ | |      +---------+| | +--------| | |      +---------+| | | C.vptr+----------&gt;+ C::FC() || | | C::c   | | |      +---------+| | +--------+ | || |            | || +------------+ ||                ||     D::d       ||                ||   +--------+   |      +---------+|   | A.vptr+----------&gt;+ A::FA() ||   | A::a   |   |      +---------+|   +--------+   ||                |+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>类D的内存DUMP</p>  <pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt;&gt;&gt; x /7a &amp;d0x7fffffffe3b0: 0x555555755b58 &lt;_ZTV1D+24&gt;      0x22222222222222220x7fffffffe3c0: 0x555555755b80 &lt;_ZTV1D+64&gt;      0x33333333333333330x7fffffffe3d0: 0x4444444444444444      0x555555755ba0 &lt;_ZTV1D+96&gt;0x7fffffffe3e0: 0x1111111111111111&gt;&gt;&gt; x /2a 0x555555755b580x555555755b58 &lt;_ZTV1D+24&gt;:     0x555555554dc4 &lt;B::FB()&gt;        0x555555554ddc &lt;D::FD()&gt;&gt;&gt;&gt; x /1a 0x555555755b800x555555755b80 &lt;_ZTV1D+64&gt;:     0x555555554dd0 &lt;C::FC()&gt;&gt;&gt;&gt; x /1a 0x555555755ba00x555555755ba0 &lt;_ZTV1D+96&gt;:     0x555555554db8 &lt;A::FA()&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ol><h4 id="3-3-3-Clang"><a href="#3-3-3-Clang" class="headerlink" title="3.3.3 Clang++"></a>3.3.3 Clang++</h4><p>Clang++的结果和G++的一样。</p><ol><li><p>执行结果</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">sizeof(void*) = 8sizeof(a) = 16, &amp;a = 0x7fffffffe3c0sizeof(b) = 32, &amp;b = 0x7fffffffe3a0sizeof(c) = 32, &amp;c = 0x7fffffffe380sizeof(d) = 56, &amp;d = 0x7fffffffe348<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>对类B的分析</p><ul><li><p>类B的内存布局</p>  <pre class="line-numbers language-text" data-language="text"><code class="language-text">+------------+|            || +--------+ |     +---------+| | B.vptr+-------&gt;+ B::FB() || | B::b   | |     +---------+| +--------+ || +--------| |     +---------+| | A.vptr+-------&gt;+ A::FA() || | A::a   | |     +---------+| +--------+ ||            |+------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>类B的内存DUMP</p>  <pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt;&gt;&gt; x /4a &amp;b0x7fffffffe3a0: 0x400b60 &lt;_ZTV1B+24&gt;    0x22222222222222220x7fffffffe3b0: 0x400b80 &lt;_ZTV1B+56&gt;    0x1111111111111111&gt;&gt;&gt; x /1a 0x400b600x400b60 &lt;_ZTV1B+24&gt;:   0x400960 &lt;B::FB()&gt;&gt;&gt;&gt; x /1a 0x400b800x400b80 &lt;_ZTV1B+56&gt;:   0x400950 &lt;A::FA()&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>对类D的分析</p><ul><li><p>类D的内存布局</p>  <pre class="line-numbers language-text" data-language="text"><code class="language-text">+----------------+|                || +------------+ || |            | || | +--------+ | |      +---------+| | | B.vptr+----------&gt;+ B::FB() || | | B::b   | | |      | D::FD() || | +--------+ | |      +---------+| | +--------| | |      +---------+| | | C.vptr+----------&gt;+ C::FC() || | | C::c   | | |      +---------+| | +--------+ | || |            | || +------------+ ||                ||     D::d       ||                ||   +--------+   |      +---------+|   | A.vptr+----------&gt;+ A::FA() ||   | A::a   |   |      +---------+|   +--------+   ||                |+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>类D的内存DUMP</p>  <pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt;&gt;&gt; x /7a &amp;d0x7fffffffe348: 0x400c60 &lt;_ZTV1D+24&gt;    0x22222222222222220x7fffffffe358: 0x400c88 &lt;_ZTV1D+64&gt;    0x33333333333333330x7fffffffe368: 0x4444444444444444      0x400ca8 &lt;_ZTV1D+96&gt;0x7fffffffe378: 0x1111111111111111&gt;&gt;&gt; x /2a 0x400c600x400c60 &lt;_ZTV1D+24&gt;:   0x400960 &lt;B::FB()&gt;      0x400a00 &lt;D::FD()&gt;&gt;&gt;&gt; x /1a 0x400c880x400c88 &lt;_ZTV1D+64&gt;:   0x400970 &lt;C::FC()&gt;&gt;&gt;&gt; x /1a 0x400ca80x400ca8 &lt;_ZTV1D+96&gt;:   0x400950 &lt;A::FA()&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ol><hr><h2 id="四、分析结论"><a href="#四、分析结论" class="headerlink" title="四、分析结论"></a>四、分析结论</h2><h3 id="4-1-结论1"><a href="#4-1-结论1" class="headerlink" title="4.1 结论1"></a>4.1 结论1</h3><p>菱形非虚继承时 VS2017 、 G++ 7.5 和 Clang++ 6 编译生成的类的内存布局相同。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----------------+|                || +------------+ || |            | |      +---------+| | +--------+ | |      |         || | | A.vptr+----------&gt;+ A::FA() || | | A::a   | | |      | B::FB() || | +--------+ | |      | D::FD() || |   B::b     | |      |         || +------------+ |      +---------+|                || +------------+ || |            | |      +---------+| | +--------+ | |      |         || | | A.vptr+----------&gt;+ A::FA() || | | A::a   | | |      | C::FC() || | +--------+ | |      |         || |   C::c     | |      +---------+| +------------+ ||                ||     D::d       ||                |+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-结论2"><a href="#4-2-结论2" class="headerlink" title="4.2 结论2"></a>4.2 结论2</h3><p>菱形虚拟继承时 VS2017 编译生成类的内存布局与 G++ 7.5 和 Clang++ 6 的结果不同。</p><ul><li><p>VS2017生成的类的内存布局：</p>  <pre class="line-numbers language-text" data-language="text"><code class="language-text">                +--------------+                |              |+---------+     | +----------+ || B::FB() +&lt;--------+B.vptr   | |      +--------------------+| D::FD() |     | | B.offset+--------&gt;+ offset2ptr    = -8 |+---------+     | | B::b     | |      | offset2A.vptr = 48 |                | +----------+ |      | offset2vptr   = -8 |                |              |      | offset2C.vptr = 24 |+---------+     | +----------+ |      +--------------------+| C::FC() +&lt;-------+C.vptr   | |      +--------------------++---------+     | | C.offset+--------&gt;+ offset2vptr   = -8 |                | | C::c     | |      | offset2A.vptr = 24 |                | +----------+ |      +--------------------+                |              |                |   D::d       |                |              |+---------+     | +----------+ || A::FA() +&lt;-------+A.vptr   | |+---------+     | | A::a     | |                | +----------+ |                |              |                +--------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>G++ 7.5 和 Clang++ 6 生成的类的内存布局相同：</p>  <pre class="line-numbers language-text" data-language="text"><code class="language-text">+----------------+|                || +------------+ || |            | || | +--------+ | |      +---------+| | | B.vptr+----------&gt;+ B::FB() || | | B::b   | | |      | D::FD() || | +--------+ | |      +---------+| | +--------| | |      +---------+| | | C.vptr+----------&gt;+ C::FC() || | | C::c   | | |      +---------+| | +--------+ | || |            | || +------------+ ||                ||     D::d       ||                ||   +--------+   |      +---------+|   | A.vptr+----------&gt;+ A::FA() ||   | A::a   |   |      +---------+|   +--------+   ||                |+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> 逆向工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《左耳听风》学习笔记</title>
      <link href="zuo-er-ting-feng-xue-xi-bi-ji/"/>
      <url>zuo-er-ting-feng-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="一、程序员如何用技术变现"><a href="#一、程序员如何用技术变现" class="headerlink" title="一、程序员如何用技术变现"></a>一、程序员如何用技术变现</h2><h3 id="（一）一些学习经验"><a href="#（一）一些学习经验" class="headerlink" title="（一）一些学习经验"></a>（一）一些学习经验</h3><ol><li>要去经历大多数人经历不到的，要把学习时间花在那些比较难的地方。</li><li>要写文章就要写没有人写过的，或是别人写过，但我能写得更好的。</li><li>更重要的是，技术和知识完全是可以变现的。</li></ol><h3 id="（二）如何保持竞争力"><a href="#（二）如何保持竞争力" class="headerlink" title="（二）如何保持竞争力"></a>（二）如何保持竞争力</h3><p>一个是技术和技能的领先，二是对技术本质和趋势的敏感度。</p><h3 id="（三）如何让自己的技能变现"><a href="#（三）如何让自己的技能变现" class="headerlink" title="（三）如何让自己的技能变现"></a>（三）如何让自己的技能变现</h3><h4 id="1-千里之行，积于跬步"><a href="#1-千里之行，积于跬步" class="headerlink" title="1.千里之行，积于跬步"></a>1.千里之行，积于跬步</h4><p>掌握大多数人不能掌握的技能或技术，需要你更多地学习，并要有更多的别人没有的经验和经历。</p><h4 id="2-关注有价值的东西"><a href="#2-关注有价值的东西" class="headerlink" title="2.关注有价值的东西"></a>2.关注有价值的东西</h4><ul><li>关于市场需求。你要看清市场，就需要看看各个公司都在做什么，他们的难题是什么。</li><li>关于技术趋势。要看一个新的技术是否顺应技术发展趋势，你需要将一些老技术的本质吃得很透。</li></ul><p>因此，在学习技术的过程一定要多问自己两个问题：</p><ul><li>一，这个技术解决什么问题？为什么别的同类技术做不到？</li><li>二，为什么是这样解决的？有没有更好的方式？</li></ul><p>另外，还有一个简单的判断方法，如果一个新的技术顺应技术发展趋势，那么在这个新的技术出现时，后面一定会有大型的商业公司支持，这类公司支持得越多，就说明你越需要关注。</p><h4 id="3-找到能体现价值的地方"><a href="#3-找到能体现价值的地方" class="headerlink" title="3.找到能体现价值的地方"></a>3.找到能体现价值的地方</h4><ul><li>在一家高速发展的公司中，技术人员的价值可以达到最大化。</li><li>在一家大公司中，技术架构和业务已经定型，基本上没有什么太多的事可以做的。而且对于已经发展起来的大公司来说，往往稳定的重要性超过了创新。</li><li>而刚起步的公司，业务还没有跑顺，公司的主要精力会放在业务拓展上，这个时候也不太需要高精尖的技术，所以，技术人员的价值也体现不出来。</li><li>比较好的成长路径是，先进入大公司学习大公司的技术和成功的经验方法，然后再找到高速成长的公司，这样你就可以实现自己更多的价值。</li></ul><h4 id="4-动手能力很重要"><a href="#4-动手能力很重要" class="headerlink" title="4.动手能力很重要"></a>4.动手能力很重要</h4><ul><li>在解决任何一个具体问题的时候，有没有动手能力就成为了关键。</li><li>代码里全是细节，细节是魔鬼，只有了解了细节，你才能提出更好或是更靠谱、可以落地的解决方案。而不是一些笼统和模糊的东西。</li></ul><h4 id="5-关注技术付费点"><a href="#5-关注技术付费点" class="headerlink" title="5.关注技术付费点"></a>5.关注技术付费点</h4><p>技术付费点基本体现在两个地方:</p><ul><li>能帮别人“挣钱”的地方；</li><li>能帮别人“省钱”的地方。</li></ul><h4 id="6-提升自己的能力和经历"><a href="#6-提升自己的能力和经历" class="headerlink" title="6.提升自己的能力和经历"></a>6.提升自己的能力和经历</h4><ul><li>参与知名的开源项目。</li><li>成为公司核心项目的开发人员。</li></ul><h4 id="7-找到有价值的信息源"><a href="#7-找到有价值的信息源" class="headerlink" title="7.找到有价值的信息源"></a>7.找到有价值的信息源</h4><ul><li>如果你的信息来自朋友圈、微博、知乎、百度或是今日头条，那么我觉得你完蛋了。这些渠道有价值的信息不多。</li><li>用好 Google，比如你在 Google 搜索引擎里输入 “XXX Best Practice”，或是 “Best programming resource”……你就会找到很多。</li></ul><h4 id="8-输出观点和价值观"><a href="#8-输出观点和价值观" class="headerlink" title="8.输出观点和价值观"></a>8.输出观点和价值观</h4><h4 id="9-朋友圈很重要"><a href="#9-朋友圈很重要" class="headerlink" title="9.朋友圈很重要"></a>9.朋友圈很重要</h4><p>优质的朋友圈基本上都有这样的特性：</p><ul><li>这些人都比较有想法、有观点，经验也比较丰富；</li><li>这些人涉猎的面比较广；</li><li>这些人都有或多或少的成功；</li><li>这些人都是喜欢折腾喜欢搞事的人；</li><li>这些人都对现状有些不满，并想做一些改变；</li><li>这些人都有一定的影响力。</li></ul><p>最后有个关键的问题是，物以类聚，人以群分。如果你不做到这些，你怎么能进入到这样的朋友圈呢？</p><p>总之，就一句话，<strong>会挣钱的人一定是会投资的人。我一直认为，最宝贵的财富并不是钱，而是你的时间，时间比钱更宝贵，因为钱你不用还在那里，而时间你不用就浪费掉了。你把你的时间投资在哪些地方，就意味着你未来会走什么样的路。所以，利用好你的时间，投到一些有意义的地方吧。</strong></p><h3 id="（四）如何技术变现套路总结-来自评论"><a href="#（四）如何技术变现套路总结-来自评论" class="headerlink" title="（四）如何技术变现套路总结(来自评论)"></a>（四）如何技术变现套路总结(来自评论)</h3><ol><li>程序员用手艺、技术养活自己，不依靠公司；</li><li>提高工作效率，去研究那些难的，公司内外的核心技术；</li><li>注重输出，输出技术、价值观，帮助更多的人，提高影响力。</li></ol><hr><h2 id="二、何为技术领导力"><a href="#二、何为技术领导力" class="headerlink" title="二、何为技术领导力"></a>二、何为技术领导力</h2><h3 id="（一）人类社会的发展阶段"><a href="#（一）人类社会的发展阶段" class="headerlink" title="（一）人类社会的发展阶段"></a>（一）人类社会的发展阶段</h3><ol><li>野蛮开采。这个阶段的主要特点是资源过多，只需要开采就好了。</li><li>资源整合。在这个阶段，资源已经被不同的人给占有了，但是需要对资源整合优化，提高利用率。这时通过管理手段就能实现。</li><li>精耕细作。这个阶段基本上是对第二阶段的精细化运作，并且通过科学的手段来达到。</li><li>发明创造。在这个阶段，人们利用已有不足的资源来创造更好的资源，并替代已有的马上要枯竭的资源。这就需要采用高科技来达到了。</li></ol><p>这也是为什么像亚马逊、Facebook 这样的公司，最终都会去发展自己的核心技术，提高自己的技术领导力，从早期的业务型公司转变成为技术型公司的原因。那些本来技术很好的公司，比如雅虎、百度，在发展到一定程度时，将自己定位成了一个广告公司，然后开始变味、走下坡路。</p><h3 id="（二）几次工业革命改变本质"><a href="#（二）几次工业革命改变本质" class="headerlink" title="（二）几次工业革命改变本质"></a>（二）几次工业革命改变本质</h3><ol><li>关键技术。蒸汽机、电、化工、原子能、炼钢、计算机，如果只看这些东西的话，似乎没什么用。但这些核心技术的突破，可以让我们建造很多更牛的工具，而这些工具能让人类干出以前干不出来的事。</li><li>自动化。这其中最重要的事就是自动化。三次革命中最重要的事就是用机器来自动化。通信、交通、军事、教育、金融等各个领域都是在拼命地自动化，以提高效率——用更低的成本来完成更多的事。</li><li>解放生产力。把人从劳动密集型的工作中解放出来，去做更高层次的知识密集型的工作。说得难听一点，就是取代人类，让人失业。值得注意的是，今天的 AI 在开始取代人类的知识密集型的工作……</li></ol><h3 id="（三）技术领导力"><a href="#（三）技术领导力" class="headerlink" title="（三）技术领导力"></a>（三）技术领导力</h3><p>回顾几次工业革命改变本质，我们可以看到的技术领导力是：</p><ul><li>尊重技术，追求核心基础技术。</li><li>追逐自动化的高效率的工具和技术，同时避免无效率的组织架构和管理。</li><li>解放生产力，追逐人效的提高。开发抽象和高质量的可以重用的技术组件。</li><li>坚持高于社会主流的技术标准和要求。</li></ul><h3 id="（四）如何拥有技术领导力"><a href="#（四）如何拥有技术领导力" class="headerlink" title="（四）如何拥有技术领导力"></a>（四）如何拥有技术领导力</h3><p>作为一个软件工程师怎样才算是拥有“技术领导力”：</p><ul><li>能够发现问题。能够发现现有方案的问题。</li><li>能够提供解决问题的思路和方案，并能比较这些方案的优缺点。</li><li>能够做出正确的技术决定。用什么样的技术、什么解决方案、怎样实现来完成一个项目。</li><li>能够用更优雅，更简单，更容易的方式来解决问题。</li><li>能够提高代码或软件的扩展性、重用性和可维护性。</li><li>能够用正确的方式管理团队。所谓正确的方式，一方面是，让正确的人做正确的事，并发挥每个人的潜力；另一方面是，可以提高团队的生产力和人效，找到最有价值的需求，用最少的成本实现之。并且，可以不断地提高自身和团队的标准。</li><li>创新能力。能够使用新的方法新的方式解决问题，追逐新的工具和技术。</li></ul><p>总结一下，就是：</p><ul><li>扎实的基础技术；</li><li>非同一般的学习能力；</li><li>坚持做正确的事；</li><li>不断提高对自己的要求标准；</li></ul><hr><h2 id="三、如何才能拥有技术领导力"><a href="#三、如何才能拥有技术领导力" class="headerlink" title="三、如何才能拥有技术领导力"></a>三、如何才能拥有技术领导力</h2><h3 id="（一）、吃透基础技术"><a href="#（一）、吃透基础技术" class="headerlink" title="（一）、吃透基础技术"></a>（一）、吃透基础技术</h3><p>基础技术是各种上层技术共同的基础。吃透基础技术是为了更好地理解程序的运行原理，并基于这些基础技术进化出更优化的产品。</p><p>基础技术主要分成两个部分：编程和系统。</p><p>编程部分</p><ul><li>C语言</li><li>编程范式</li><li>算法和数据结构</li></ul><p>系统部分</p><ul><li>计算机系统原理</li><li>操作系统原理和基础</li><li>网络基础</li><li>数据库原理</li><li>分布式技术架构</li></ul><h3 id="（二）、提高学习能力"><a href="#（二）、提高学习能力" class="headerlink" title="（二）、提高学习能力"></a>（二）、提高学习能力</h3><p>所谓学习能力，就是能够很快地学习新技术，又能在关键技术上深入的能力。只有在掌握了上述的基础原理之上，你才能拥有好的学习能力。如何提高呢？</p><ul><li>学习的信息源。信息源很重要，有好的信息源就可以更快速地获取有价值的信息，并提升学习效率。常见的信息源有 Google 等搜索引擎，Stack Overflow、Quora 等社区，图书，API 文档，论文和博客等。</li><li>与高手交流。程序员可以通过技术社区以及参加技术会议与高手交流，也可以通过参加开源项目来和高手切磋。</li><li>举一反三的思考。比如，了解了操作系统的缓存和网页缓存以后，你要思考其相同点和不同点。</li><li>不怕困难的态度。</li><li>开放的心态。实现一个目的通常有多种办法。带有开放的心态，不拘泥于一个平台、一种语言，往往能带来更多思考，也能得到更好的结果。而且，能在不同的方法和方案间做比较，比较它们的优缺点，那么你会知道在什么样的场景下用什么样的方案，你就会比一般人能够有更全面和更完整的思路。</li></ul><h3 id="（三）、坚持做正确的事"><a href="#（三）、坚持做正确的事" class="headerlink" title="（三）、坚持做正确的事"></a>（三）、坚持做正确的事</h3><p>做正确的事，比用正确的方式做事更重要，因为这样才始终会向目的地靠拢。哪些是正确的事呢？</p><ul><li>提高效率的事。你要学习和掌握良好的时间管理方式，管理好自己的时间，能显著提高自己的效率。</li><li>自动化的事。程序员要充分利用自己的职业特质，当看见有可以自动化的步骤时，编写程序来自动化操作，可以显著提高效率。</li><li>掌握前沿技术的事。掌握前沿的技术，有利于拓展自己的眼界，也有利于找到更好的工作。需要注意的是，有些技术虽然当下很火，但未必前沿，而是因为它比较易学易用，或者性价比高。由于学习一门技术需要花费不少时间，你应该选择自己最感兴趣的，有的放矢地去学习。</li><li>知识密集型的事。知识密集型是相对于劳动密集型来说的。基本上，劳动密集型的事都能通过程序和机器来完成，而知识密集型的事却仍需要人来完成，所以人的价值此时就显现出来了。</li><li>技术驱动的事。不仅是指用程序驱动的事，而且还包括一切技术改变生活的事。比如自动驾驶、火星登陆等。就算自己一时用不着，你也要了解这些，以便将来这些技术来临时能适应它们。</li></ul><h4 id="（四）、高标准要求自己"><a href="#（四）、高标准要求自己" class="headerlink" title="（四）、高标准要求自己"></a>（四）、高标准要求自己</h4><p>只有不断地提高标准，你才可能越走越高，所以，要以高标准要求自己，不断地反思、总结和审视自己，才能够提升自己。</p><ul><li>Google 的自我评分卡。</li><li>敏锐的技术嗅觉。这是一个相对综合的能力，你需要充分利用信息源，GET 到新的技术动态，并通过参与技术社区的讨论，丰富自己了解技术的角度。</li><li>强调实践，学以致用。学习知识，一定要实际用一用，可以是工作中的项目，也可以是自己的项目，不仅有利于吸收理解，更有利于深入到技术的本质。并可以与现有技术对比一下，同样的问题，用新技术解决有什么不同，带来了哪些优势，还有哪些有待改进的地方。</li><li>Lead by Example。永远在编程。不写代码，你就对技术细节不敏感，你无法做出可以实践的技术决策和方案。</li></ul><hr><h2 id="四、如何成为一个大家愿意追随的-Leader"><a href="#四、如何成为一个大家愿意追随的-Leader" class="headerlink" title="四、如何成为一个大家愿意追随的 Leader"></a>四、如何成为一个大家愿意追随的 Leader</h2><h3 id="（一）、Leader-和-Boss-的不同"><a href="#（一）、Leader-和-Boss-的不同" class="headerlink" title="（一）、Leader 和 Boss 的不同"></a>（一）、Leader 和 Boss 的不同</h3><p>再或者用通俗的话说，Leader 是大家跟我一起上，而 Boss 则是大家给我上，一个在团队的前面，一个在团队的后面。</p><p>具体来说，这两者的不同点如下：</p><ul><li><p>Boss 是驱动员工，Leader 是指导员工。</p><p>  在面对项目的时候，Boss 制定时间计划，并且推动（push）和鞭策员工完成工作，而 Leader 则是和员工一起讨论工作细节，指导员工关注工作的重点，和员工一起规划出（work out）工作的方向和计划，并且在工作中和员工一起解决细节难题，帮助员工完成工作。</p></li><li><p>Boss制造畏惧，Leader制造热情。</p><p>  Boss 在工作中是用工作职位级别压人，用你的绩效考核来制造威慑，让员工畏惧他，从而推行工作。而 Leader 是通过描绘远景，制造激动人心的目标来鼓舞和触发团队的热情和斗志。</p></li><li><p>Boss面对错误喜欢使用人事惩罚的手段，而Leader面对错误喜欢寻找解决问题的技术或管理方法。</p><p>  惩罚员工和解决问题完全是两码事，Boss因为并不懂技术也并不懂问题的细节，所以他们只能使用惩罚这样的手段，而Leader通常是喜欢解决问题的技术型人才，所以，他们会深入技术细节，从技术上找到既治标又治本的技术方案或管理方式。</p></li><li><p>Boss 只是知道怎么做，而 Leader 则是展示怎么做。</p><p>  一个好 Leader 的最大特点就是 Lead by Example，以身作则，用身教而不是言传。而 Boss 只是在说教，总是在大道理上说的一套又一套，但从来不管技术细节。</p></li><li><p>Boss 是用人，而 Leader 是发展人。</p><p>  Boss 不关心人的发展，把人当成劳动力。而 Leader 则会看到人的潜力和特长，通过授权、指导和给员工制定成长计划让员工成长，从而发展员工。所以，我们通常可以看到 Boss 总是说自己的员工有这个问题有那个问题，而 Leader 总是说，如何让员工成长以解决员工个人的各种问题。</p></li><li><p>Boss 从团队收割成绩，而 Leader 则是给予团队成绩。</p><p>  Boss 通常都会把团队的成绩占为己有，虽然 Boss 会说这是团队的功劳，但基本上是一句带过。而 Leader 则是让团队成功，让团队的成员站在台前，自己甘当绿叶和铺路石。Leader 知道只有团队的每个人成功了，团队才会成功，所以，Leader 会帮助团队中的每个人更好更流畅地走向成功。</p></li><li><p>Boss 喜欢命令和控制（ Command + Control ），而 Leader 喜欢沟通和协作（ Communication + Cooperation ）。</p><p>  Boss 喜欢通过命令来控制员工的行为，从而实现团队的有效运转，而 Leader 喜欢通过沟通和协作来增加员工的参与感，从而让员工觉得这是自己的事，愿意为之付出。</p></li><li><p>Boss 喜欢说“给我上”，而 Leader 喜欢说“跟我上”。</p><p>  Boss 总是躲在团队后面，让团队冲锋陷阵，而 Leader 总是冲在前面用自己的行动领着团队浴血奋战。</p></li></ul><h3 id="（二）、如何成为众人愿意追随的-Leader"><a href="#（二）、如何成为众人愿意追随的-Leader" class="headerlink" title="（二）、如何成为众人愿意追随的 Leader"></a>（二）、如何成为众人愿意追随的 Leader</h3><ul><li><p>帮人解决问题。</p><p>  团队或身边大多数人都在问：“这个问题怎么办？”，而你总是能站出来告诉大家该怎么办。</p></li><li><p>被人依赖。</p><p>  团队或身边大多数人在做比较关键的决定时，都会来找你咨询意见和想法。</p></li></ul><p>要有能够做到上面的要求，你需要有技术领导力。有没有技术领导力（Leadership），是成为一个 Leader 非常关键的因素。因为人们想要跟随的人通常都是比自己强比自己出色的人，或是能够跟他学到东西，能够跟他成长的人。</p><p>但是，有了技术领导力可能并不够，下面是我罗列的一些比较关键的除了技术领导力之外的一个 Leader 需要的素质：</p><ul><li><p>赢得他人的信任。</p><p>  对于信任来说，并不完全是别人相信你能做到某个事，还有别人愿意向你打开心扉，和你说他心里面最柔软的东西。而后者才是真正的信任。</p></li><li><p>开放的心态 + 倾向性的价值观。</p><ol><li><p>对于新生事物要有开放的心态，对于每个人的观点都有开放的心态，但并不是要认同所有的观点和事情，成为一个油腔滑调的人。</p></li><li><p>就价值观来说，还是需要有倾向性的，比如，我就倾向于不加班的文化，倾向于全栈，倾向于按职责分工而不是按技能分工，倾向于做一个 Leader 而不是 Boss，倾向于技术是第一生产力，倾向于 OKR 而不是 KPI……</p></li></ol></li></ul><p>我的这些倾向性可以让别人更清楚地知道我是一个什么样的人，而不会对我琢磨不透，一会东一会西只会让人觉得你太油了，反而会产生距离感和厌恶感。我认为，倾向性的价值观是别人是否可以跟随你的一个基础。</p><ul><li><p>Lead by Example。</p><ol><li>用自己的行为来向大家展示你的 Leadership。这就是说，你需要给大家做示范。很多时候，道理人人都知道，但未必人人都会做，知易行难，以身示范，一个示例会比讲一万遍道理都管用。</li><li>所以我认为，对于软件开发来说，不写代码的架构师是根本不靠谱的。要做一个有人愿意跟随的技术 Leader，你需要终身写代码，也就是所谓的 ABC – Always Be Coding。这样，你会得到更多的实际经验，能够非常明白一个技术方案的优缺点，实现复杂度，知道什么是 Best Practice，你的方案才会更具执行力和实践性。当有了执行力，你就会获得更多的成就，而这些成就反过来会让更多的人来跟随你。</li></ol></li><li><p>能够抓住重点，看透事物的本质。</p><p>  作为一个 Leader，能够抓住主要矛盾，看清事物的本质，给出清楚的观点或方向，简化复杂的事情，传道解惑、开启民智，让人豁然开朗、醍醐灌顶，才会让人追随之。</p></li><li><p>描绘令人激动的方向，提供令人向住的环境。</p><p>  一个好的 Leader 一定会把每个人心中最真善美的东西呼唤出来，并且还能让人相信这是有机会有可能做到的。</p></li><li><p>甘当铺路石，为他人创造机会。</p><p>  别人愿意跟随你，愿意和你共事，有一部分原因是你能够给别人带来更多的可能性和机会，别人觉得和你在一起能够成长，能够进步，你能够带着大家到达更远的地方。帮助别人其实就是帮助自己，成就他人其实也是在成就自己，这就像一个好的足球队一样，球队中的人都互相给队友创造机会，整个团队成功了，球队的每个人也就成功了。作为一个好的 Leader，你一定要在团队中创造好这样的文化和风气。</p></li></ul><hr><h2 id="五、时间管理：同扭曲时间的事儿抗争"><a href="#五、时间管理：同扭曲时间的事儿抗争" class="headerlink" title="五、时间管理：同扭曲时间的事儿抗争"></a>五、时间管理：同扭曲时间的事儿抗争</h2><h3 id="（一）、主动管理"><a href="#（一）、主动管理" class="headerlink" title="（一）、主动管理"></a>（一）、主动管理</h3><p>无论什么事情，如果你发现你持续处于被动的状态下，那么你一定要停下来想一想如何把被动变为主动。因为在被动的方式下工作，你是不可能做好工作的，无论什么事。</p><p><strong>你要主动管理的不是你的时间，而是管理你的同事，管理你的信息。</strong></p><h3 id="（二）、学会说“不”"><a href="#（二）、学会说“不”" class="headerlink" title="（二）、学会说“不”"></a>（二）、学会说“不”</h3><ul><li><p>当你面对做不到的需求时，你不要说这个需求做不到，尤其是，你不要马上说做不到。</p><p>  你要先想一下，这样让别人觉得你是想做的，但是，在认真思考过后，你觉得做不到，并且给出一个你觉得能做到的方案。这里的诀窍是——<strong>给出另一个你可以做到的方案，而不是把对方的方案直接回绝掉。</strong></p></li><li><p>当你面对过于复杂的需求时，你不要说不。</p><p>  你要反问一下，为什么要这样做？这样做的目的是什么？当了解完目的以后，你可以给出一个自己的方案，或是和对方讨论一个性价比更好的方案。你可以回复说，这个需求好复杂，我们能不能先干这个，再做那个，这样会更经济一些。这里的诀窍是——<strong>我不说我不能完全满足你，但我说我可以部分满足你。</strong></p></li><li><p>当你面对时间完全不够的需求时，你也不要说不。</p><p>  既然对方把压力给你，你要想办法把这个压力还回去，或是让对方来和你一同分担这个压力。</p></li></ul><p>惯用的方式是给回三个选择：</p><ul><li>我可以加班加点完成，但是我不保证好的质量，有 bug 你得认，而且事后你要给我 1 个月的时间还债。</li><li>我可以加班加点，还能保证质量，但我没办法完成这么多需求，能不能减少一些？</li><li>我可以保质保量地完成所有的需求，但是，能不能多给我 2 周时间？</li></ul><h3 id="（三）、加班和开会"><a href="#（三）、加班和开会" class="headerlink" title="（三）、加班和开会"></a>（三）、加班和开会</h3><p><strong>如果怎么做都要受伤害，那么两害相权取其轻</strong>。你要学会比较是项目延期的伤害大，还是线上故障的伤害大，是先苦后甜好，还是积压问题好，聪明的你应该能做出正确的判断。</p><p><strong>开会，不是讨论问题，而是讨论方案，开会不是要有议题，而是要有议案。</strong></p><hr><h2 id="六、时间管理：如何利用好自己的时间"><a href="#六、时间管理：如何利用好自己的时间" class="headerlink" title="六、时间管理：如何利用好自己的时间"></a>六、时间管理：如何利用好自己的时间</h2><h3 id="（一）、投资自己的时间"><a href="#（一）、投资自己的时间" class="headerlink" title="（一）、投资自己的时间"></a>（一）、投资自己的时间</h3><ul><li><p>花时间学习基础知识，花时间读文档。</p><p>  系统地学习一门技术是非常关键的，所以这个时间是值得投资的。</p></li><li><p>花时间在解放自己生产力的事上。</p><p>  在自动化、可配置、可重用、可扩展上要多花时间。花时间在解放自己的事上是最有意义的了。</p></li><li><p>花时间在让自己成长的事上。</p><p>  注意，晋升并不代表成长，成长不应该只看在一个公司内，而是要看在行业内，在行业内的成长才是真正的成长。所以，把时间花在能让自己成长，能让自己有更强的竞争力，能让自己有更大的视野，能让自己有更多可能性的事情上。</p></li><li><p>花时间在建立高效的环境上。</p><p>  不仅仅是工具上，花些时间在影响你身边的人上，比如你的同事，你的产品经理，你的老板，去影响他们，让他们理解你，让他们配合你来建立更好的流程和管理方法。在这个方向上花时间也是很值得的。</p></li></ul><h3 id="（二）、规划自己的时间"><a href="#（二）、规划自己的时间" class="headerlink" title="（二）、规划自己的时间"></a>（二）、规划自己的时间</h3><ul><li><p>定义好优先级。</p><p>  无论你写不写出来，你一定都会有一个自己的 to-do list。知道什么事是重要的，什么事是紧急的，什么事重要但不紧急，什么事又重要又紧急。这有利于你划分优先级。</p></li><li><p>最短作业优先。</p><p>  对于相同优先级的事，我个人喜欢的是“最短作业优先”的调度算法。</p></li><li><p>想清楚再做。</p><p>  对于一些没想清楚的事，或是自己不太有信心的事，还是先看看有没有已有的成熟解决方案，或是找更牛的人来给你把把关，帮你出出主意，看看有没有更好、更简单的方式。</p></li><li><p>关注长期利益规划。</p><p>  要多关注长远可以节省多少时间，而不是当前会花费多少时间。长期成本会比短期成本大得多。所以，宁可在短期延期，也不要透支未来。这里的逻辑是，工作上的事你永远也做不完的，长痛不如短痛。</p></li></ul><p><strong>你要学会规划自己的行动计划，不是短期的，而是一个中长期的。我个人建议是按季度来规划，这个季度做什么，达到什么目标，一年往前走四步，而不是只考虑眼下。</strong></p><h3 id="（三）、用好自己的时间"><a href="#（三）、用好自己的时间" class="headerlink" title="（三）、用好自己的时间"></a>（三）、用好自己的时间</h3><ul><li><p><strong>将军赶路不追小兔</strong>。</p><p>  能专注地把时间投入到一个有价值的事上是非常重要的。确定自己的目标，专注达到这个目标，而不是分心。将军的目标是要攻城，而不是追兔子。所以，你要学会过滤掉与自己目标无关的事，不要让那些无关的事控制自己。</p></li><li><p>形成习惯。</p><p>  在讲述完如何争取时间，及如何使用时间之后，我想分享一下如何将这些时间管理方法形成习惯，因为我坚信：<strong>“做”比“做好”更重要</strong>。养成一个好习惯通常需要 30 天左右的时间，尤其在最初的几天就更为重要了。这时，不妨将文章中提到的方法和几个要点，写在某本书或者笔记本的扉页上，方便查看，时刻提醒自己。</p></li><li><p>形成正反馈。</p><p>  要有正反馈，也就是成就感，有助于完成一些看似难以完成的事儿。比如，我们说过，学习是逆人性的事儿，但如果在学习过程中不断地有正反馈，就更利于我们坚持下去。要让自己有正反馈，那就需要把时间花在有价值的地方，比如，解决自己和他人的痛点，这样你会收获别人的赞扬和鼓励。</p></li><li><p>反思和举一反三。</p><p>  可以尝试每周末花上点时间思考一下，本周做了哪些事儿？时间安排是否合理？还有哪些可以优化提高的地方？有点儿类似于我们常说的“复盘”。然后思考一下，下周的主要任务是什么？并根据优先级规划一下完成这些任务的顺序，也就是做一些下周的工作规划。</p></li></ul><hr><h2 id="七、程序员面试攻略：面试前的准备"><a href="#七、程序员面试攻略：面试前的准备" class="headerlink" title="七、程序员面试攻略：面试前的准备"></a>七、程序员面试攻略：面试前的准备</h2><h3 id="（一）、怎样写简历"><a href="#（一）、怎样写简历" class="headerlink" title="（一）、怎样写简历"></a>（一）、怎样写简历</h3><p><strong>我们知道真正的好简历是要用自己的经历去写的。</strong></p><p>写简历的最佳实践——用自己的经历聊，而不是用文字写。</p><p>基本上来说，简历上的信息不要写太多，信息太多相当于没有信息，不要单纯地罗列，要突出自己的长处和技能。一般来说，简历需要包括以下几项内容：</p><ul><li><p>自我简介。</p><p>  用最简单的话来说明自己的情况，不超过 200 字。比如：10+ 年的软件开发经验（说明你的主业），4+ 年的团队 leader 经验（说明你的领导力），擅长高可用高性能的分布式架构（说明你的专业和专攻），多年互联网和金融行业背景（说明你的行业背景），任职于 XXX 公司的 XX 职位（说明你的职业），负责 XXX 平台或系统（说明你的业务场景）……</p></li><li><p>个人信息。</p><ol><li>基本信息。电子邮箱建议用 Gmail，千万不要用 QQ 邮箱，要让人感觉职业化一些。</li><li>个人网站。如果你有个人主页、博客、GitHub 或是 Stack Overflow，请一定附上，这是加分项。如果个人主页或博客有独立域名，那更好，这会给人一种你爱动手做事的感觉。页面也要干净有美感，这样会让人感觉你有品味。</li><li>网站内容。一般来说这些项都会被面试官点看浏览，所以，里面的内容你需要小心组织和呈现，千万不要造假。另外，除了技术上的一些知识总结（不要太初级，要有深度的、原理型的、刨根问底型的文章），你也可以秀一秀自己的技术价值观（比如，对代码整洁的追求，对一些技术热点事件的看法），这会让你更容易获得面试官的好感。面试官的好感很重要。</li><li>作品展。如果你有一些作品展现，会更好。当然，对于前端程序员来说，这是比较容易的。而对于后端程序员来说，这会比较难一些，只能展示一下自己的 GitHub 了。如果你有一些比较不错的证书或奖项（如微软的认证、Oracle 的认证），也可以展示一下。</li></ol></li></ul><p><strong>对应于你的简历，如果能和应聘职位的需求看齐有相类似的描述，这样可以快速地让人觉得你和要应聘的职位很匹配。</strong></p><ul><li><p>工作经历和教育经历。</p><ol><li>列一下你的工作经历。每份工作完成的主要项目（不要列一大堆项目，挑重要的），主要突出项目的难度、规模、挑战、职责，以及获得的认可和荣誉。</li><li>工作经历和教育经历，主要是对上述的个人技能的印证。不要东拉西扯，要紧紧地围绕着你的技能、特长和亮点来展开。</li></ol></li></ul><p>一般来说，你简历中的内容最好控制在两页 A4 纸以内，最好有中英文版，简历不要是 Word 版的，最好是 PDF 版，然后简历的格式和风格请参考 LinkedIn 上的（在 微软的 Office 模板网站 上也能找到一些不错的简历模板）。简历的内容不要太多，内容太多，重点就不明显了。写简历的目的是呈现自己的特长、亮点和特点。只要你能呈现出 2-3 个亮点和特长，就可以吸引到人了。</p><p>如果简历上的经历和技术亮点不足的话，那么你可以在简历的版式和形式的制作上花些心思，以及在简历的自我描述中加上一些“虚”的东西。</p><p>比如“工作态度积极，不分份内和份外的事，只要对公司和个人有利，都会努力做好；勤奋踏实，热爱学习，喜欢做一个全栈工程师；善于发现问题，并解决问题……”表示我虽然现在的经历和技能不足以打动你，但是我的态度端正，潜力巨大，你不能错过……</p><h3 id="（二）、技术知识准备"><a href="#（二）、技术知识准备" class="headerlink" title="（二）、技术知识准备"></a>（二）、技术知识准备</h3><p>一般来说，你的简历上写什么，面试官就会问什么，所以，不要打自己的脸，精通就是精通，熟悉就是熟悉，了解就是了解。然后对于你列出来的这些技术，你一定要把其最基本的技术细节给掌握了。你不见得要记住所有的知识点，但是 80% 以上的关键知识点，你多少得知道吧。面试官一般也会逐步加大问题的难度和深度，看看你到底在哪个层次上。所以，你还是需要系统地看看书，才能应对面试官的问题。比如：</p><ul><li>你写上了 Java，那么 Java 的基本语法都要了解，并发编程、NIO、JVM 等，你多少要有点儿了解，Spring、Netty 这些框架也要了解。</li><li>你写上了 Go，那么至少得把官网上的 Effective Go 给看了。</li><li>你写上了 Redis，那么除了 Redis 的数据结构，Redis 的性能优化、高可用配置、分布式锁什么的，你多少也要把官网上的那几篇文章读一读。</li><li>你写上了面向对象，那么怎么着也得把《设计模式》中的 23 个模式了解一下。</li><li>你写上了分布式架构，那么 CAP 理论、微服务架构、弹力设计、Spring Cloud、Cloud Native 这些架构就要做到心里有数。</li><li>你写上网络编程，那么 TCP/IP 的三次握手，四次挥手，两端的状态变化你得知道吧，Socket 编程的那几个系统调用，还有 select、poll、epoll 这些异步 IO 多路复用的东西，你得知道。</li></ul><h3 id="（三）、算法题准备"><a href="#（三）、算法题准备" class="headerlink" title="（三）、算法题准备"></a>（三）、算法题准备</h3><p>面试前去LeetCode练练。<a href="https://www.geeksforgeeks.org/top-20-dynamic-programming-interview-questions/">Top 20 的动态规划题的列表</a>。</p><h3 id="（四）、工作项目准备"><a href="#（四）、工作项目准备" class="headerlink" title="（四）、工作项目准备"></a>（四）、工作项目准备</h3><p><strong>无论什么公司的面试，都会让你说一个你做过的项目，或是你过去解决过的一个难题。</strong> 一般来说，会有下面这样的几个经典的面试问题：</p><ol><li>说一个你做过的最自豪的项目，或是最近做过的一个项目。</li><li>说一个你解决过的最难的技术问题，或是最有技术含量的问题。</li><li>说一个你最痛苦的项目，或最艰难的项目。</li><li>说一个犯过的最大的技术错误，或是引发的技术故障。</li></ol><p>对于上面这四个问题：第一个问题，主要是想看看你过去工作中做过的最高级的事是什么，还有你的兴趣点和兴奋点是什么；第二和第三个问题，主要是想看看你解决难题的能力，以及面对压力和困难时的心态；第四个问题，主要是想了解一下你面对错误时的态度，还要了解你是否会对错误有所总结和改进。</p><p>怎样准备这样的题，我这里有几个提示：</p><ul><li><p>要有框架。</p><p>  讲故事要学会使用 STAR 。Situation - 在什么样的环境和背景下，Task - 你要干什么样的事，Action - 你采取了什么样的行动和努力，Result - 最终得到了什么样的效果。这是整个语言组织的框架，不要冗长啰嗦。</p></li><li><p>要有细节。</p><p>  没有细节的故事听起来就很假，所以，其中要有很多细节。因为是技术方面的，所以，一定要有很多技术细节。</p></li><li><p>要有感情。</p><p>  讲这些故事一定要带感情。要让面试官感受到你的热情、骄傲、坚韧和顽强。一定要是真实的，只有真实的事才会有真实的感情。</p></li><li><p>要有思考。</p><p>  只有细节和故事还不够，还要有自己的思考和得失总结，以及后续的改进。</p></li></ul><p>对此，如果你想有一个比较好的面试回答效果，<strong>这不是你能临时准备出来的，工夫都是花在平时的。而训练这方面能力的最好方式就是在工作中写文档 ，在工作之余写博客。</strong> 只有写得多了，写得好了，你这样的能力才能训练出来。</p><hr><h2 id="八、程序员面试攻略：面试中的技巧"><a href="#八、程序员面试攻略：面试中的技巧" class="headerlink" title="八、程序员面试攻略：面试中的技巧"></a>八、程序员面试攻略：面试中的技巧</h2><h3 id="（一）、形象和谈吐"><a href="#（一）、形象和谈吐" class="headerlink" title="（一）、形象和谈吐"></a>（一）、形象和谈吐</h3><ul><li>着装让人感到干净、整洁。</li><li>保持微笑，表现得热情、开朗和幽默。</li><li>说话的时候，要看着对方，一方面这是对对方的尊重和礼貌，另一方面，这也是一种自信。</li><li>面试官问的问题，你要给出充足的细节，千万不要让面试官不断地追问，那样就被动了。</li></ul><h3 id="（二）、答不出来"><a href="#（二）、答不出来" class="headerlink" title="（二）、答不出来"></a>（二）、答不出来</h3><p>面试中有一些问题很难，但是不要放弃，要不断尝试。很多时候，面试官并不期待你能在很短的时候内解出一道难题，他只是想看一下你遇到难题时的态度和思维方式。如果你能证明给面试官看，你解决问题的方向和方法是正确的，就算是没有找到答案，也是很不错的。因为只要方向走对了，剩下的就是时间问题了。</p><p>如果实在解不出来，或是被问了不懂的知识性问题，那么就直接说不懂就好了。记下来，回去多看多练，下次记住了就好。</p><p>另外，对于没有答上来的问题，有的人会在面试后请教一下面试官。但是我觉得更好的方式是，问面试官要个他的邮箱或微信，回去后，努力搞懂，举一反三，然后写个东西再发回去。这样做是有可能让你起死回生的。多少可以暗示对方：“你看，我有不懂的，但是我能下工夫很快就搞懂了，你看我的学习能力还不错哦。你就不再考虑一下了吗？”</p><h3 id="（三）、尖锐问题"><a href="#（三）、尖锐问题" class="headerlink" title="（三）、尖锐问题"></a>（三）、尖锐问题</h3><ul><li><p>你为什么要离开现在的公司？</p><p>  一般来说，永远不要说之前公司的坏话。说客观原因。</p></li><li><p>说一下你的缺点？</p><ol><li>真实的回答。</li><li>最后还要补一句，我知道我的缺点，我也在努力改正，我正在通过什么样的方式改正。这非常关键，因为这基本上是面试官最喜欢看到的答案了，就是你不仅能正视自己的缺点，而且还能不断地改正。</li></ol></li><li><p>说一下你的优点？</p><ol><li>真实的回答。优点是需要用证据来说明的。</li><li>比如，我通常的回答是，我的优点就是学习能力强，因为我掌握的技术面很广，而且，我什么样的技术都学，比如最新的 Cloud Native 技术。作为后端人员我还学前端方面的技术如 React.js 和 Vue.js，这一切都来源于我扎实的基础知识……</li><li>回答这个问题的时候，一般都会反衬出你的价值观，HR 就是想了解你的价值观。比如，我比较踏实，我想把技术一直做到老。再比如，我有韧性，我受过哪些挫折、失败、不公、无奈和无助，我没有当逃兵……</li></ol></li><li><p>你为什么换工作换得这么勤？</p><ol><li>给出合理的解释，以消除用人方的疑惑。</li><li>一方面，你还是需要诚恳一点儿，另一方面，你在解释时需要承认频繁换工作也不是自己想的，自己何尝不想在一份工作上干得时间长一点儿。无奈，要么是公司有变化，要么就是自己没选好。一方面表达自己也厌倦了频繁换工作这种事，另一方面，你要把这个话题引到另外一个方向上——什么样的工作自己可以干很久？自己所期望的工作内容和工作环境是什么样的？这样就转而去谈你所向往的工作内容和环境了，并再表达一下在这样的工作环境下，是可以很长时间做下去的，并愿意和公司一起发展。</li><li>但是，先不要说得太理想了，不然，用人方也会觉得自己是做不到的。正确的说法是，自己并不担心公司有各种各样的问题，只要有一起扛事的队友一起拼搏，这才是最关键的。</li></ol></li><li><p>你在一家公司呆了接近 10 年为什么没有做到管理层？你又是怎么保持竞争力的？</p><ol><li>一般来说，不想做管理的程序员也挺多的，在技术的方向上勤勤恳恳深耕细作，会是一个非常难得的优秀工程师。专注于技术，不分心，不断地在技术上的深度和广度上钻研，这就是保持竞争力最好的方式。</li></ol></li><li><p>你工作满 5 年了，为什么还不是一个高级程序员？</p><ol><li>对于国外的顶尖公司来说，如果你有 5 年的工作经验，但还不能胜任高级程序员（Amazon 的 SDE2）的职位，那么你这个人就基本会被 pass 掉了，包括在职的员工也是一样的。</li><li>国内的公司可能会问你这个问题，对此，我个人认为比较好的回答是要分几方面来谈。一方面，过去因为什么原因耽误了些时间（环境因素、客观条件因素），另一方面，要表示同样也有主观因素，不然显得有点找借口的感觉，不诚恳。</li><li>接下来，要表明自己心里面也比较慌（表明自己不用别人提醒可以自己意识到自己的问题），所以，近一年来一直在学习，罗列一下学过哪些东西，最好还有学习目标和学习计划（表明自己除了有意识外，还有行动）。当然，厉害的面试官会不断地追问你一些细节，以此来确定你没有说假话，对此，你要有充足的准备。</li></ol></li><li><p>你为什么换了一个方向？你觉得你有什么优势？</p><ol><li>这个问题其实并不难回答，实话实说就好了。但是不要让招聘方感受到你浮燥的内心，或是朝三暮四的性格，更不要让人感觉到你像“小猫钓鱼”那样一边不行又来搞另一边。</li><li>我觉得回答这个问题有两种方式：一种是非常自信的回答——“我从来没有改变我的方向，因为种种原因，我没能得到我想要的方向，虽然现在很残酷，但是我一直都没有放弃我的方向，我一直都在努力学习……”如果你要这么回答了，你就要真的是这样的，在新的方向有所研究和建树，不然会被识破的。</li><li>另一种回答则常规一点，首先说明一下，自己的兴趣爱好，为什么这个方向要比之前的那个方向更适合自己。可以用几个例子来说明，但其中要有一些细节，比如，自己试过这个新方向 ，发现干得比原来那边更好，更容易出成绩，自己的兴奋点更大，所以觉得新方向更适合自己。然后，承认换一个方向短期内并没有优势。但是，因为自己的某某特质，比如，学习能力强、勤奋、聪明等特质，未来一定是可以胜任的。</li><li>但是，你要用证据证明你的学习能力强，你比一般人勤奋，比一般人聪明。不然如果对方追问下去，会让你破绽百出的。总之，回答这样的问题，需要一定的证据作为补充，而且还要伴随着以降职降薪为代价。所以，一般来说，选定方向最好不要再变了，如果一定要变的话，你也要有必胜的信心和先下后上的心态，而且这些信心和心态要让招聘方看到。</li></ol></li><li><p>对于技术的热情或初心体现在你生活和工作中的哪里？</p><ol><li>你要小心回答，而且是要带感情的，但一定要是真实的。</li><li>总结一下，对技术的热情或初心，需要表现在这么几个特质上：执着、坚持、坚韧、不服输、担当、不妥协、不浮燥……我说一句，我相信每个人或多或少都会有这些特质，这是你的亮点，要小心呵护。不然，你跟一条咸鱼就没什么两样了。</li></ol></li></ul><h3 id="（四）、结尾问题"><a href="#（四）、结尾问题" class="headerlink" title="（四）、结尾问题"></a>（四）、结尾问题</h3><ul><li><p>如果你面得比较好</p><ol><li>这个时候可以问几个尖锐的问题，这样有利于后面谈 offer 和岗位（抓住机会反转被动为主动）。比如：</li><li>你们公司有多少一线开发经理还在写代码？你们的一线经理都没有时间来写代码了，不知道细节怎么做好管理？另外是不是说明你们公司有大量的内耗？</li><li>任何公司都有好的有不好的，你能不能分享一下你最喜欢这个公司的地方和最不喜欢的地方？</li></ol></li><li><p>如果你面得一般</p><ol><li>这个时候你也可以问些加分的问题。</li><li>比如：目前贵公司或是贵团队最需要解决什么样的问题？我能帮贵公司做些什么？能不能给我一些资料我先了解一下，这样我后面如果能进来，就能上手更快一些了。因为你面得一般的话，面试官会比较犹豫和纠结，此时你需要让面试官不要犹豫，所以，你可以表现得更加热情和主动一点。你看，竟然一副通过面试明天就要上班的“无耻嘴脸”也会为你加点分的……（哈哈哈）</li></ol></li><li><p>如果你面得很不行，基本挂掉了</p><p>  这个时候，也要问问题。但最好问一下面试官对你的评价，并且让他指出你的不足和需要改进的地方。面试本来就是一次经历和一次学习，你也可以把其当作是一种受教育的过程。所以，不要放过自己可以成长的机会。通过面试官给你的评价，你日后就知道自己需要努力的地方和方向了。这是多好的一件事儿啊。</p></li></ul><hr><h2 id="九、高效学习：端正学习态度"><a href="#九、高效学习：端正学习态度" class="headerlink" title="九、高效学习：端正学习态度"></a>九、高效学习：端正学习态度</h2><h3 id="（一）、主动学习和被动学习"><a href="#（一）、主动学习和被动学习" class="headerlink" title="（一）、主动学习和被动学习"></a>（一）、主动学习和被动学习</h3><p>人的学习分为「被动学习」和「主动学习」两个层次。</p><ul><li>被动学习：如听讲、阅读、视听、演示，学习内容的平均留存率为 5%、10%、20% 和 30%。</li><li>主动学习：如通过讨论、实践、教授给他人，会将原来被动学习的内容留存率从 5% 提升到 50%、75% 和 90%。</li></ul><p><strong>学习不是努力读更多的书，盲目追求阅读的速度和数量，这会让人产生低层次的勤奋和成长的感觉，这只是在使蛮力。要思辨，要践行，要总结和归纳，否则，你只是在机械地重复某件事，而不会有质的成长的。</strong></p><h3 id="（二）、浅度学习和深度学习"><a href="#（二）、浅度学习和深度学习" class="headerlink" title="（二）、浅度学习和深度学习"></a>（二）、浅度学习和深度学习</h3><p>老实说，对于当前这个社会：</p><ul><li>大多数人的信息渠道都被微信朋友圈、微博、知乎、今日头条、抖音占据着。这些信息渠道中有营养的信息少之又少。</li><li>大多数公司都是实行类似于 996 这样的加班文化，在透支和消耗着下一代年轻人，让他们成长不起来。</li><li>因为国内互联网访问不通畅，加上英文水平受限，所以，大多数人根本没法获取到国外的第一手信息。</li><li>快餐文化盛行，绝大多数人都急于速成，心态比较浮燥，对事物不求甚解。</li></ul><p>只要你注意观察，就会发现，少数的精英人士，他们在训练自己获取知识的能力，他们到源头查看第一手的资料，然后，深度钻研，并通过自己的思考后，生产更好的内容。而绝大部分受众享受轻度学习，消费内容。</p><p>你有没有发现，在知识的领域也有阶层之分，那些长期在底层知识阶层的人，需要等着高层的人来喂养，他们长期陷于各种谣言和不准确的信息环境中，于是就导致错误或幼稚的认知，并习惯于那些不费劲儿的轻度学习方式，从而一点点地丧失了深度学习的独立思考能力，从而再也没有能力打破知识阶层的限制，被困在认知底层翻不了身。</p><p>可见深度学习十分重要，但应该怎样进行深度学习呢？下面几点是关键。</p><ul><li>高质量的信息源和第一手的知识。</li><li>把知识连成地图，将自己的理解反述出来。</li><li>不断地反思和思辨，与不同年龄段的人讨论。</li><li>举一反三，并践行之，把知识转换成技能。</li></ul><p>换言之，学习有三个步骤。</p><ul><li>知识采集。信息源是非常重要的，<strong>获取信息源头、破解表面信息的内在本质、多方数据印证</strong>，是这个步骤的关键。</li><li>知识缝合。所谓缝合就是把信息组织起来，成为结构体的知识。这里，<strong>连接记忆，逻辑推理，知识梳理</strong>是很重要的三部分。</li><li>技能转换。通过<strong>举一反三、实践和练习，以及传授教导</strong>，把知识转化成自己的技能。这种技能可以让你进入更高的阶层。</li></ul><h3 id="（三）、学习是为了找到方法"><a href="#（三）、学习是为了找到方法" class="headerlink" title="（三）、学习是为了找到方法"></a>（三）、学习是为了找到方法</h3><p><strong>学习不仅仅是为了找到答案，而更是为了找到方法。</strong></p><p>只有掌握解题的思路和方法，你才算得上拥有解决问题的能力。所有的练习，所有的答案，其实都是在引导你去寻找一种“以不变应万变”的方法或能力。</p><p><strong>学习是为了找到通往答案的路径和方法，是为了拥有无师自通的能力。</strong></p><h3 id="（四）、学习是为了找到原理"><a href="#（四）、学习是为了找到原理" class="headerlink" title="（四）、学习是为了找到原理"></a>（四）、学习是为了找到原理</h3><p><strong>学习不仅仅是为了知道，而更是为了思考和理解。</strong> 在学习的过程中，我们不是为了知道某个事的表面是什么，而是要通过表象去探索其内在的本质和原理。</p><p>问题会驱使你像一个侦探一样去探索背后的事实和真相，并在不断的思考中一点一点地理解整个事情的内在本质、逻辑和原理。 <strong>一旦理解和掌握了这些本质的东西，你就会发现，整个复杂多变的世界在变得越来越简单。你就好像找到了所有问题的最终答案似的，一通百通了。</strong></p><h3 id="（五）、学习是为了了解自己"><a href="#（五）、学习是为了了解自己" class="headerlink" title="（五）、学习是为了了解自己"></a>（五）、学习是为了了解自己</h3><p><strong>学习不仅仅是为了开拓眼界，而更是为了找到自己的未知，为了了解自己。</strong> 英文中有句话叫：You do not know what you do not know，可以翻译为：你不知道你不知道的东西。也就是说，你永远不会去学习你不知道其存在的东西。就好像你永远 Google 不出来你不知道的事，因为对于你不知道的事，你不知道用什么样的关键词，你不知道关键词，你就找不到你想要的知识。</p><p><strong>开拓眼界的目的就是发现自己的不足和上升空间，从而才能让自己成长。</strong></p><h3 id="（六）、学习是为了改变自己"><a href="#（六）、学习是为了改变自己" class="headerlink" title="（六）、学习是为了改变自己"></a>（六）、学习是为了改变自己</h3><p><strong>学习不仅仅是为了成长，而更是为了改变自己。</strong> 很多时候，我们觉得学习是为了自己的成长，但是其实，学习是为了改变自己，然后才能获得成长。为什么这么说呢？我们知道，人都是有直觉的，但如果人的直觉真的靠谱，那么我们就不需要学习了。而学习就是为了告诉我们，我们的很多直觉或是思维方式是不对的，不好的，不科学的。</p><p><strong>学习是为了改变自己的思考方式，改变自己的思维方式，改变自己与生俱来的那些垃圾和低效的算法。总之，学习让我们改变自己，行动和践行，反思和改善，从而获得成长。</strong></p><hr><h2 id="十、高效学习：源头、原理和知识地图"><a href="#十、高效学习：源头、原理和知识地图" class="headerlink" title="十、高效学习：源头、原理和知识地图"></a>十、高效学习：源头、原理和知识地图</h2><h3 id="（一）、挑选知识和信息源"><a href="#（一）、挑选知识和信息源" class="headerlink" title="（一）、挑选知识和信息源"></a>（一）、挑选知识和信息源</h3><p>信息源要有下面几个特质：</p><ul><li>应该是第一手资料，不是被别人理解过、消化过的二手资料。尤其对于知识性的东西来说，更是这样。应该是原汁原味的，不应该是被添油加醋的。</li><li>应该是有佐证、有数据、有引用的，或是有权威人士或大公司生产系统背书的资料。应该是被时间和实践检验过的，或是小心求证过的，不是拍脑袋野路子或是道听途说出来的资料。</li><li>应该是加入了一些自己的经验和思考，可以引发人深思的，是所谓信息的密集很大的文章。</li></ul><h3 id="（二）、注重基础和原理"><a href="#（二）、注重基础和原理" class="headerlink" title="（二）、注重基础和原理"></a>（二）、注重基础和原理</h3><p><strong>基础知识和原理性的东西和技术，都是经历过长时间的考验的，所以，这些基础技术也有很多人类历史上的智慧结晶，会给你很多启示和帮助。</strong> 比如：TCP 协议的状态机，可以让你明白，如果你要设计一个异步通信协议，状态机是一件多么重要的事，还有 TCP 拥塞控制中的方式，让你知道，设计一个以响应时间来限流的中件间是什么样的。</p><h3 id="（三）、使用知识图"><a href="#（三）、使用知识图" class="headerlink" title="（三）、使用知识图"></a>（三）、使用知识图</h3><p>联想记忆法。比如，在学习 C++ 的时候，面对《C++ Primer》这种厚得不行的书，我就使用联想记忆法。</p><p>我把 C++ 分成三部分：</p><ul><li>第一部分是 C++ 是用来解决 C 语言的问题的，那么 C 语言有什么问题呢？指针、宏、错误处理、数据拷贝…… C++ 用什么技术来解决这些问题呢？</li><li>第二部分是 C++ 的面向对象特性：封装、继承、多态。封装，让我想到了构造函数、析构函数等。构造函数让我想到了初始化列表，想到了默认构造函数，想到了拷贝构造函数，想到了 new……多态，让我想到了虚函数，想到了 RTTI，RTTI 让我想到了 dynamic_cast 和 typeid 等。</li><li>第三部分是 C++ 的泛型编程。我想到了 template，想到了操作符重载，想到了函数对象，想到 STL，想到数据容器，想到了 iterator，想到了通用算法，等等。</li></ul><p>于是，我通过“顺藤摸瓜”的方式，从知识树的主干开始做广度或是深度遍历，于是我就得到了一整棵的知识树。这种“顺藤摸瓜”的记忆方式让我记住了很多知识。<strong>最重要的是，当出现一些我不知道的知识点时，我就会往这棵知识树上挂，而这样一来，也使得我的学习更为系统和全面。</strong></p><p>这种画知识图的方式可以让你从一个技术最重要最主干的地方出发开始遍历所有的技术细节，也就是画地图的方式。如果你不想在知识的海洋中迷路，你需要有一份地图，所以，<strong>学习并不是为了要记忆那些知识点，而是为了要找到一个知识的地图，你在这个地图上能通过关键路径找到你想要的答案。</strong></p><hr><h2 id="十一、高效学习：深度，归纳和坚持实践"><a href="#十一、高效学习：深度，归纳和坚持实践" class="headerlink" title="十一、高效学习：深度，归纳和坚持实践"></a>十一、高效学习：深度，归纳和坚持实践</h2><h3 id="（一）、系统地学习"><a href="#（一）、系统地学习" class="headerlink" title="（一）、系统地学习"></a>（一）、系统地学习</h3><p>当然学习一门技术时，Go 语言也好，Docker 也好，我都有一个学习模板。只有把这个学习模板中的内容都填实了，我才罢休。这个模板如下：</p><ol><li><p>这个技术出现的背景、初衷和要达到什么样的目标或是要解决什么样的问题。</p><p> 这个问题非常关键，也就是说，你在学习一个技术的时候，需要知道这个技术的成因和目标，也就是这个技术的灵魂。如果不知道这些的话，那么你会看不懂这个技术的一些设计理念。</p></li><li><p>这个技术的优势和劣势分别是什么，或者说，这个技术的 trade-off 是什么。</p><p> 任何技术都有其好坏，在解决一个问题的时候，也会带来新的问题。另外，一般来说，任何设计都有 trade-off（要什么和不要什么），所以，你要清楚这个技术的优势和劣势，以及带来的挑战。</p></li><li><p>这个技术适用的场景。</p><p> 任何技术都有其适用的场景，离开了这个场景，这个技术可能会有很多槽点，所以学习技术不但要知道这个技术是什么，还要知道其适用的场景。没有任何一个技术是普适的。注意，所谓场景一般分别两个，一个是业务场景，一个是技术场景。</p></li><li><p>技术的组成部分和关键点。</p><p> 这是技术的核心思想和核心组件了，也是这个技术的灵魂所在了。学习技术的核心部分是快速掌握的关键。</p></li><li><p>技术的底层原理和关键实现。</p><p> 任何一个技术都有其底层的关键基础技术，这些关键技术很有可能也是其它技术的关键基础技术。所以，学习这些关键的基础底层技术，可以让你未来很快地掌握其它技术。可以参看我在 CoolShell 上写的 Docker 底层技术那一系列文章。</p></li><li><p>已有的实现和它之间的对比。</p><p> 一般来说，任何一个技术都会有不同的实现，不同的实现都会有不同的侧重。学习不同的实现，可以让你得到不同的想法和思路，对于开阔思维，深入细节是非常重要的。</p></li></ol><h3 id="（二）、举一反三"><a href="#（二）、举一反三" class="headerlink" title="（二）、举一反三"></a>（二）、举一反三</h3><p>我觉得一个人的举一反三能力，可以分解成如下三种基本能力：</p><ol><li><p>联想能力。</p><p> 这种能力的锻炼需要你平时就在不停地思考同一个事物的不同的用法，或是联想与之有关的其他事物。对于软件开发和技术学习也一样。</p></li><li><p>抽象能力。</p><p> 抽象能力是举一反三的基本技能。平时你解决问题的时候，如果你能对这个问题进行抽象，你就可以获得更多的表现形式。抽象能力需要找到解决问题的通用模型，比如数学就是对现实世界的一种抽象。只要我们能把现实世界的各种问题建立成数据模型（如，建立各种维度的向量），我们就可以用数学来求解，这也是机器学习的本质。</p></li><li><p>自省能力。</p><p> 所谓自省能力就是自己找自己的难看。当你得到一个解的时候，要站在自己的对立面来找这个解的漏洞。有点像左右手互博。这种自己和自己辩论的能力又叫思辨能力。将自己分裂成正反方，左右方，甚至多方，站在不同的立场上来和自己辩论，从而做到不漏过一个 case，从而获得完整全面的问题分析能力。</p></li></ol><p>在这方面，我对自己的训练如下：</p><ul><li>对于一个场景，制造出各种不同的问题或难题。</li><li>对于一个问题，努力寻找尽可能多的解，并比较这些解的优劣。</li><li>对于一个解，努力寻找各种不同的测试案例，以图让其健壮。</li></ul><h3 id="（三）、总结和归纳"><a href="#（三）、总结和归纳" class="headerlink" title="（三）、总结和归纳"></a>（三）、总结和归纳</h3><p>对自己的知识进行总结和归纳是提高学习能力的一个非常重要的手段。这是把一个复杂问题用简单的语言来描述的能力。也就是说，我们把学到的东西用自己的语言和理解重新组织并表达出来，本质上是对信息进行消化和再加工的过程，这个过程可能会有信息损失，但也可能会有新信息加入，本质上是信息重构的过程。</p><p>不过，我们需要注意的是，如果只学了部分知识或者还没有学透，就开始对知识进行总结归纳，那么总结归纳出来的知识结构也只能是混乱和幼稚的。因此， <strong>学习的开始阶段，可以不急于总结归纳，不急于下判断，做结论，而应该保留部分知识的不确定性，保持对知识的开放状态。</strong> 当对整个知识的理解更深入，自己站的位置更高以后，总结和归纳才会更有条理。总结归纳更多是在复习中对知识的回顾和重组，而不是一边学习一边就总结归纳。</p><p>我们来总结一下做总结归纳的方法：<strong>把你看到和学习到的信息，归整好，排列好，关联好，总之把信息碎片给结构化掉，然后在结构化的信息中，找到规律，找到相通之处，找到共同之处，进行简化、归纳和总结，最终形成一种套路，一种模式，一种通用方法。</strong></p><p>要训练自己这方面的能力，你需要多看一些经典的方法论图书，看看别人是怎样总结和归纳知识的。你可以在一开始模仿并把自己的理解的知识给写出来，写博客会是一种很好的方式。另外一种更好的方式是讲一遍给别人听。总之，你需要把你总结归纳的知识公开出来，给别人看，接受别人的批评和反馈，这样你才能成长得更快。其实，我也在锻炼这样的能力。</p><h3 id="（四）、实践出真知"><a href="#（四）、实践出真知" class="headerlink" title="（四）、实践出真知"></a>（四）、实践出真知</h3><p>所谓实践出真知，也就是学以致用，不然只是纸上谈兵，误国误民。只有实践过，你才能对学到的东西有更深的体会。</p><p>多写多用。</p><h3 id="（五）、坚持不懈"><a href="#（五）、坚持不懈" class="headerlink" title="（五）、坚持不懈"></a>（五）、坚持不懈</h3><p>一方面你要把你的坚持形成成果晒出来，让别人来给你点赞，另一方面，你还要把坚持变成一种习惯，就像吃饭喝水一样，你感觉不到太多的成本付出。只有做到这两点，你才能够真正坚持。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 职业规划 </tag>
            
            <tag> 极客时间 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《C语言程序设计：现代方法(第2版)》读书笔记</title>
      <link href="c-yu-yan-cheng-xu-she-ji-xian-dai-fang-fa-di-2-ban-du-shu-bi-ji/"/>
      <url>c-yu-yan-cheng-xu-she-ji-xian-dai-fang-fa-di-2-ban-du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>主要是备忘C99标准中的一些变化。</p><h2 id="允许代码段与声明混合"><a href="#允许代码段与声明混合" class="headerlink" title="允许代码段与声明混合"></a>允许代码段与声明混合</h2><p>允许在程序块中任何地方声明变量，只要在第一次调用该变量之前声明就可以。</p><h2 id="支持-风格注释"><a href="#支持-风格注释" class="headerlink" title="支持//风格注释"></a>支持//风格注释</h2><h2 id="变量不再隐式声明为int类型"><a href="#变量不再隐式声明为int类型" class="headerlink" title="变量不再隐式声明为int类型"></a>变量不再隐式声明为int类型</h2><h2 id="不支持隐式声明函数"><a href="#不支持隐式声明函数" class="headerlink" title="不支持隐式声明函数"></a>不支持隐式声明函数</h2><h2 id="更准确的整型除法"><a href="#更准确的整型除法" class="headerlink" title="更准确的整型除法"></a>更准确的整型除法</h2><p>C89中i/j的两个整数操作数中有负数时，除法的结果既可以向上取整，也可以向下取整，在C99中总是向0取整。C89中如果i或j为负数，i%j结果与实现有关，在c99中结果符号总与i的符号相同。</p><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><p>新的布尔类型<code>_Bool</code>，本质是无符号的整型。<code>_Bool</code>类型的变量只能存储0或1，所以，将非0的值赋值给<code>_Bool</code>类型的变量都会导致变量的值变为1。同时还提供了新的头文件<stdbool.h>，内容如下：</stdbool.h></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">__bool_true_false_are_defined   <span class="token number">1</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">bool    <span class="token keyword">_Bool</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">false   <span class="token number">0</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">true    <span class="token number">1</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="for语句的变化"><a href="#for语句的变化" class="headerlink" title="for语句的变化"></a>for语句的变化</h2><p>在C99中，for语言的第一个表达式可以替换为一个声明，下面的代码也是合法的了：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="64位整数和扩展整数类型的支持"><a href="#64位整数和扩展整数类型的支持" class="headerlink" title="64位整数和扩展整数类型的支持"></a>64位整数和扩展整数类型的支持</h2><p>C99提供了两个额外的标准整数类型：<code>long long int</code>和<code>unsigned long long int</code>，大小至少64位宽。同时，以<code>LL</code>或<code>ll</code>（所有字母的大小写要一致）结尾的整数常量是<code>long long int</code>类型的，以<code>ULL</code>或<code>ull</code>（所有字母的大小写要一致）结尾的整数常量是<code>unsigned long long int</code>类型的。</p><p>除了标准的整数类型外，C99标准还允许在具体实现时定义<code>扩展的数类整数</code>（包括有符号的和无符号的）。比如：128位的整数类型。</p><h2 id="隐式转换的变化"><a href="#隐式转换的变化" class="headerlink" title="隐式转换的变化"></a>隐式转换的变化</h2><p>因为C99中增加了一些类型（_Bool、long long类型、扩展的整数类型和复数类型）。新的隐式转换规则略有变化（这里忽略了扩展整数类型和枚举类型）：</p><ol><li>long long int、unsigned long long int</li><li>long int、unsigned long int</li><li>int、unsigned int</li><li>short int、unsigned short int</li><li>char、signed char、unsigned char（这里要注意char类型和signed char类型是不同的类型）</li><li>_Bool</li></ol><p>C99用整数提升（integer promotion）取代了C89中的整值提升（integral promotion），可以将任何等级低于int和unsigned int的类型转换为int（只要该类型的所有值都可以用int类型表示）或unsigned int。</p><p>和C89一样类似，C99中执行常用的算术转换的规则可以划分为两种情况：</p><ul><li><p><code>任一操作数的类型是浮点数类型的情况。</code>只要两个操作数都不是复数型，规则如下(下面的内容摘录自<a href="https://book.douban.com/subject/1139336/">C程序设计语言(第2版_新版)</a>)：</p><ol><li>如果任何一个操作数为long double类型，将另一个操作数转换为long double类型，过程结束。</li><li>如果任何一个操作数为double类型，将另一个操作数转换为double类型，过程结束。</li><li>如果任何一个操作数为float类型，将另一个操作数转换为float类型，过程结束。</li></ol></li><li><p><code>两个操作数的类型都不是浮点类型的情况。</code>首先对两个操作数进行整数提升。如果这时两个操作数的类型相同，过程结束。否则，依次尝试下面的规则，一旦遇到可应用的规则就不再考虑别的规则：</p><ol><li>如果两个操作数都是有符号型或都是无符号型，将整数转换等级低的操作数转换为等级较高的操作数的类型。</li><li>如果无符号操作数的等级<code>高于或等于</code>有符号操作数的等级，将有符号操作数转换为无符号操作数的类型。</li><li>如果有符号操作数类型可以表示无符号操作数类型的所有值，将无符号操作数转换为有符号操作数的类型。</li><li>否则，将两个操作数都转换为与有符号操作数的类型相对应的无符号类型。</li></ol></li></ul><p>另外，所有算术类型都可以转换为_Bool类型。如果原始值为0则转换结果为0，否则结果为1。</p><h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2><blockquote><p>这条C99中没有变化，只是C和C++略有不同。</p></blockquote><p>如果数组的初始化式比数组短，那么数组中剩余的元素赋值为0：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">/* initial value of a is {1, 2, 0} */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>但是在C中初始化式完全为空是非法的，如果想要把数组全部初始化为0，必须要在大括号中放一个0。这点要求在C++中是没有的。</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// initial value of a to {0, 0, 0}</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// invalid in c but valid in c++</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="数组指定初始化式"><a href="#数组指定初始化式" class="headerlink" title="数组指定初始化式"></a>数组指定初始化式</h2><p>C99中，提供了指定下标的方式来初始化数组中指定位置的值。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">/* a is {0, 1, 0, 3, 0} */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同时，初始化式中老方法（逐个元素初始化）和新方法（指定初始化式）可以同时使用。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">/* b is {1, 0, 2} */</span><span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">/* b us {0, 0, 2, 1}*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="变长数组"><a href="#变长数组" class="headerlink" title="变长数组"></a>变长数组</h2><p>下面的代码在C99标准下是合法的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> a<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* C99 only*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>变长数组的长度是在程序执行时计算的，而不是在编译时计算的。变长数组的主要限制是它们没有静态存储时限（因为它是放在栈上面的），另一个限制是变长数组没有初始化式。</p><h2 id="变长数组形式参数"><a href="#变长数组形式参数" class="headerlink" title="变长数组形式参数"></a>变长数组形式参数</h2><p>下面的代码在C99标准下是合法的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sum_2d_array</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> arr<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：参数的顺序很重要。<code>int m</code>和<code>int n</code>必须要在<code>int arr[m][n]</code>的左边。</p></blockquote><p>在声明包含有变长数组形式的函数时，可以使用<code>*</code>，比如上面的函数可以声明为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sum_2d_array</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> arr<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">sum_2d_array</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">sum_2d_array</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">sum_2d_array</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>变长数组参数对编译器来说，只是提示性的，编译器并不进行额外的错误检测，只是方便编译优化等。所以实际上变长数组的大小和变长数组的参数可能是无关的。</code></p><h2 id="在数组参数声明中使用static"><a href="#在数组参数声明中使用static" class="headerlink" title="在数组参数声明中使用static"></a>在数组参数声明中使用static</h2><p>C99允许在数组参数声明中使用关键字static。在下面的代码中，将static放在数字3之前表示数组a的长度至少可以保证为3：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sum_array</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token keyword">static</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样使用static对程序的行为不会有任何影响。static的存在只是提示编译器，方便编译器根据此提示优化指令。</p><p>最后，如果数组参数是多维的，static仅可用于第一维（比如，指定二维数组的行数）。</p><h2 id="数组复合字面量"><a href="#数组复合字面量" class="headerlink" title="数组复合字面量"></a>数组复合字面量</h2><p>代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>total <span class="token operator">=</span> <span class="token function">sum_array</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在C99中，可以简化为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">total <span class="token operator">=</span> <span class="token function">sum_array</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，<code>(int []){3, 0, 3, 4, 1}</code>就是<code>复合字面量</code>。</p><p>复合字面量是通过指定其包含的元素而创建的没有名字的数组。其格式为：先在一对圆括号内给定类型名，随后在一对花括号内设定所包括元素的值。</p><p>复合字面量类似于应用于数组初始化式的强制转换。事实上，复合字面量和数组初始化式遵守同样的规则。复合字面量可以包含指示符，就像指定初始化式一样；可以不提供数组完全的初始化（未初始化的元素默认被初始化为0）。例如：复合字面量<code>(int[10]){8,6}</code>有10个元素，前面两个元素的值为8和6，剩下的元素值为0。</p><p>函数内部创建的复合字面量可以包含任意表达式，不限于常量。例如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">total <span class="token operator">=</span> <span class="token function">sum_array</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">2</span><span class="token operator">*</span>i<span class="token punctuation">,</span> i<span class="token operator">+</span>j<span class="token punctuation">,</span> j<span class="token operator">*</span>k<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中i、j、k都是变量。</p><p>复合字面量为左值，所以其元素的值可以改变。如果要求其值为“只读”，可以在类型前面加上<code>const</code>，如<code>(const int[]){5,4}</code>。</p><h2 id="指向常量数组复合字面量的指针"><a href="#指向常量数组复合字面量的指针" class="headerlink" title="指向常量数组复合字面量的指针"></a>指向常量数组复合字面量的指针</h2><p>指针指向复合字面量创建的数组中的某个元素是合法的。下面两段代码都是合法的，并且意义相同。</p><p>代码一：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>代码二：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="C99中的指针和变长数组"><a href="#C99中的指针和变长数组" class="headerlink" title="C99中的指针和变长数组"></a>C99中的指针和变长数组</h2><p>指针可以指向变长数组中的元素。如果变长数组是多维的，指针的类型取决于除第一维外每一维的长度。下面是二维的情况：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> a<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为p的类型依赖于n，而n不是常量，所以说p具有可改变类型。需要注意的是，编译器并非总能确定<code>p = a</code>这样的赋值语句的合法性，例如，下面的代码可以通过编译，但只有当<code>m = n</code>是才正确：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>p <span class="token operator">=</span> a<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果<code>m != n</code>，后续对p的使用都将导致未定义的行为。</p><p>与变长数组一样，可改变类型也具有特定的限制，其中最重要的限制是，可改变类型的声明必须出现在函数体内部或者在函数原型中。</p><h2 id="C99中新增的预定义宏"><a href="#C99中新增的预定义宏" class="headerlink" title="C99中新增的预定义宏"></a>C99中新增的预定义宏</h2><div class="table-container"><table><thead><tr><th style="text-align:center">名字</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>__STDC_HOSTED__</code></td><td style="text-align:center">如果是托管式实现，值为1；如果是独立式实现，值为0</td></tr><tr><td style="text-align:center"><code>__STDC_VERSION__</code></td><td style="text-align:center">支持的C标准版本</td></tr><tr><td style="text-align:center"><code>__STDC_IEC_559__</code></td><td style="text-align:center">如果支持IEC 60559浮点算术运算，则定义该宏，且值为1</td></tr><tr><td style="text-align:center"><code>__STDC_IEC_559_COMPLEX</code></td><td style="text-align:center">如果支持IEC 60559复数算术运算，则定义该宏，且值为1</td></tr><tr><td style="text-align:center"><code>__STDC_ISO_10646__</code></td><td style="text-align:center">如果wchar_t类型的值由ISO/IEC 10646标准中的码值表示，则定义该宏，且值的格式是yyyymmL（表示修订的年月）</td></tr></tbody></table></div><h2 id="空的宏参数"><a href="#空的宏参数" class="headerlink" title="空的宏参数"></a>空的宏参数</h2><p>C99允许宏调用中的任意或所有参数为空。但是这样的调用需要有和一般调用一样多的逗号（方便看出哪些参数被省略了）。</p><p>在大多数情况下，实际参数为空的效果是显而易见的。例如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">ADD</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span> <span class="token punctuation">(</span>x<span class="token operator">+</span>y<span class="token punctuation">)</span></span></span>i <span class="token operator">=</span> <span class="token function">ADD</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>i <span class="token operator">=</span> <span class="token function">ADD</span><span class="token punctuation">(</span><span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>经过预处理后变成：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">i <span class="token operator">=</span> <span class="token punctuation">(</span>j<span class="token operator">+</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>i <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">+</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当空参数是#或##运算符的操作数时，用法有特殊规定。例如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">MK_STR</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> #x</span></span><span class="token keyword">char</span> empty_string<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">MK_STR</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">JOIN</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">)</span> x</span><span class="token punctuation">##</span><span class="token expression">y</span><span class="token punctuation">##</span><span class="token expression">z</span></span><span class="token keyword">int</span> <span class="token function">JOIN</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">JOIN</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">JOIN</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">JOIN</span><span class="token punctuation">(</span><span class="token punctuation">,</span><span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>经过预处理后变成：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> empty_string<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token keyword">int</span> abc<span class="token punctuation">,</span> ab<span class="token punctuation">,</span> ac<span class="token punctuation">,</span> c<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="参数个数可变的宏"><a href="#参数个数可变的宏" class="headerlink" title="参数个数可变的宏"></a>参数个数可变的宏</h2><p>在C89中，如果宏有参数，那么参数的个数是固定的。在C99中，这个条件被适当放宽了，允许宏具有可变长度的参数列表。</p><p>宏具有可变参数个数的主要原因是：它可以将参数传递给具有可变参数个数的函数。比如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">TEST</span><span class="token punctuation">(</span>cond<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cond<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">printf</span><span class="token punctuation">(</span></span><span class="token string">"pass test: %s\n"</span><span class="token expression"><span class="token punctuation">,</span> #cond<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">printf</span><span class="token punctuation">(</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>...</code>记号（省略号）出现在宏参数列表的最后，前面是普通参数。<code>__VA_ARGS__</code>是一个专用的标识符，只能出现在具有可变参数个数的宏的替换列表中，代表所有与省略号相对应的参数。（至少有一个与省略号相对应的参数，但该参数可以为空。）</p><h2 id="func标识符"><a href="#func标识符" class="headerlink" title="func标识符"></a><strong>func</strong>标识符</h2><p>每个函数都可以访问<code>__func__</code>标识符，它的行为很像一个存储当前正在执行的函数的名字的字符串变量。作用相当于在函数体的一开始包含了如下声明：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token constant">__func__</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"function-name"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>__func__</code>的另一个用法：作为参数传递给函数，让函数知道调用它的函数的名字。</p><h2 id="Pragma运算符"><a href="#Pragma运算符" class="headerlink" title="_Pragma运算符"></a>_Pragma运算符</h2><p>C99引入了与#pragma指令一起使用的_Pragma运算符。其具有如下形式：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">_Pragma</span> <span class="token punctuation">(</span>字符串字面量<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>遇到该表达式时，预处理器通过移除字符串两端的双引号并分别用字符<code>"</code>和<code>\</code>代替转义序列<code>\"</code>和<code>\\</code>来实现对字符串字面量的“去字符串化”。下面的两行代码意义相同：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">_Pragma</span><span class="token punctuation">(</span><span class="token string">"data(heap_size =&gt; 1000, stack_size =&gt; 2000)"</span><span class="token punctuation">)</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">data</span><span class="token punctuation">(</span>heap_size <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">1000</span><span class="token punctuation">,</span> stack_size <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">2000</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="结构指定初始化式"><a href="#结构指定初始化式" class="headerlink" title="结构指定初始化式"></a>结构指定初始化式</h2><p>与数组指定初始化式类似，结构也可以使用指定初始化式。下面两行初始化代码意义相同：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">KibaZen</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">int</span> b<span class="token punctuation">;</span>    <span class="token keyword">int</span> c<span class="token punctuation">;</span>    <span class="token keyword">int</span> d<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">kibaZen</span> k <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">KibaZen</span> z <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="结构复合字面量"><a href="#结构复合字面量" class="headerlink" title="结构复合字面量"></a>结构复合字面量</h2><p>和数组复合字面量类似，结构也有复合字面量。下面的代码是合法的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">KibaZen</span> kz <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kibaZen</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="受限指针"><a href="#受限指针" class="headerlink" title="受限指针"></a>受限指针</h2><p>在C99中，用restrict声明的指针叫做受限指针（restricted pointer）。它向编译器保证，在这个指针的生命周期内，任何通过该指针访问的内存，都只能被这个指针改变。目的是为了是给编译器提供额外的信息帮助编译器进行代码优化。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> restrict dst<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> restrict src<span class="token punctuation">,</span> size_t n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">memmove</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> dst<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> src<span class="token punctuation">,</span> size_t n<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>C99标准下，<code>memcpy</code>中的dst和src都使用了restrict，说明复制源和目的地不应互相重叠（但不能确保不重叠）。而<code>memmove</code>中的dst和src没有使用restrict，说明即使在重叠时也能正常复制。</p><h2 id="灵活数组成员"><a href="#灵活数组成员" class="headerlink" title="灵活数组成员"></a>灵活数组成员</h2><p>在存储字符串时我们可能会定义下面的结构：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">vstring</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> len<span class="token punctuation">;</span>    <span class="token keyword">char</span> chars<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">vstring</span><span class="token operator">*</span> str <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">vstring</span><span class="token punctuation">)</span> <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>str<span class="token operator">-&gt;</span>nlen <span class="token operator">=</span> n<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里使用了一种“欺骗”的方法，分配比该结构声明时应具有的内存更多的内存，然后使用这些内存来存储chars数组额外的元素。这种方法称为“struct hack”。C89标准并不能保证struct hack技术工作，也不允许数组长度为0(GCC允许)。</p><p>C99提供了灵活数组成员（flexible array member）来达到同样的目的。当结构的最后一个成员是数组时，其长度可以省略：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">vstring</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> len<span class="token punctuation">;</span>    <span class="token keyword">char</span> chars<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">/* flexible array member - c99 only */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">vstring</span><span class="token operator">*</span> str <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">vstring</span><span class="token punctuation">)</span> <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>str<span class="token operator">-&gt;</span>len <span class="token operator">=</span> n<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具有灵活数组成员的结构是不完整类型（incomplete type）。不完整类型缺少用于确定所需内存大小的信息。</p><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>C99标准下，可以使用关键字inline创建内联函数。</p><h2 id="新的头文件-lt-stdbool-h-gt"><a href="#新的头文件-lt-stdbool-h-gt" class="headerlink" title="新的头文件<stdbool.h>"></a>新的头文件<code>&lt;stdbool.h&gt;</code></h2><h2 id="C99对…printf转换说明的修改"><a href="#C99对…printf转换说明的修改" class="headerlink" title="C99对…printf转换说明的修改"></a>C99对…printf转换说明的修改</h2><p>C99对printf函数和fprintf函数的转换说明做了不少修改。</p><ul><li>增加了长度修饰符：hh、ll、j、z和t。</li><li>增加了转换说明符：F、a和A。</li><li>允许输出无穷数和NaN。</li><li>支持宽字符输出：<code>%lc</code>和<code>%ls</code>。</li><li>C89未定义的转换说明C99允许了。%le、%lE、%lf、%lg和%lG在C99是合法的（l长度修饰符被忽略）。</li></ul><h2 id="C99对…scanf转换说明的改变"><a href="#C99对…scanf转换说明的改变" class="headerlink" title="C99对…scanf转换说明的改变"></a>C99对…scanf转换说明的改变</h2><p>C99对scanf函数和fscanf函数的转换说明也做了一些修改。</p><ul><li>增加了长度修饰符：hh、ll、j、z和t。</li><li>增加了转换说明符：F、a和A。</li><li>具有读无穷数和NaN的能力。</li><li>支持宽字符。<code>%lc</code>转换说明用于读出单个的多字节字符或者一系列多字节字符；<code>%ls</code>用于读取由多字节字符组成的字符串（在结尾添加空字符）。<code>%l[集合]</code>和<code>%l[^集合]</code>转换说明也可以读取多字节字符串。</li></ul><p>scanf示例：</p><div class="table-container"><table><thead><tr><th style="text-align:center">代码</th><th style="text-align:center">输入</th><th style="text-align:center">变量</th></tr></thead><tbody><tr><td style="text-align:center"><code>n = scanf("%i%i%i", &amp;i, &amp;j, &amp;k);</code></td><td style="text-align:center"><code>12 012 0x12</code></td><td style="text-align:center">n=3; i=12; j=10; k=18;</td></tr><tr><td style="text-align:center"><code>n = scanf("%[0123456789]", str);</code></td><td style="text-align:center"><code>123abc</code></td><td style="text-align:center">n=1; str=”123”;</td></tr><tr><td style="text-align:center"><code>n = scanf("%[0123456789]", str);</code></td><td style="text-align:center"><code>abc123</code></td><td style="text-align:center">n=0; str的值不变;</td></tr><tr><td style="text-align:center"><code>n = scanf("%[^0123456789]", str);</code></td><td style="text-align:center"><code>abc123</code></td><td style="text-align:center">n=1; str=”abc”;</td></tr><tr><td style="text-align:center"><code>n = scanf("%*d%d%n", &amp;i, &amp;j);</code></td><td style="text-align:center"><code>10 20 30</code></td><td style="text-align:center">n=1; i=20; j=5;</td></tr></tbody></table></div><h2 id="在-lt-math-h-gt-中增加许多类型、宏和函数"><a href="#在-lt-math-h-gt-中增加许多类型、宏和函数" class="headerlink" title="在<math.h>中增加许多类型、宏和函数"></a>在<code>&lt;math.h&gt;</code>中增加许多类型、宏和函数</h2><h2 id="通用字符名"><a href="#通用字符名" class="headerlink" title="通用字符名"></a>通用字符名</h2><p>可以用两种方式书写通用字符名（\udddd和\Udddddddd），每个d都是一个十六进制的数字。</p><p>UCS的码值可以在<a href="www.unicode.org/charts/">www.unicode.org/charts/</a>找到。</p><h2 id="支持宽字符的-lt-wchar-h-gt-和-lt-wctype-h-gt-函数库"><a href="#支持宽字符的-lt-wchar-h-gt-和-lt-wctype-h-gt-函数库" class="headerlink" title="支持宽字符的<wchar.h>和<wctype.h>函数库"></a>支持宽字符的<code>&lt;wchar.h&gt;</code>和<code>&lt;wctype.h&gt;</code>函数库</h2><h2 id="在-lt-stdio-h-gt-和-lt-wchar-h-gt-中支持vscanf族函数"><a href="#在-lt-stdio-h-gt-和-lt-wchar-h-gt-中支持vscanf族函数" class="headerlink" title="在<stdio.h>和<wchar.h>中支持vscanf族函数"></a>在<code>&lt;stdio.h&gt;</code>和<code>&lt;wchar.h&gt;</code>中支持vscanf族函数</h2><h2 id="新增-lt-stdint-h-gt-整数类型"><a href="#新增-lt-stdint-h-gt-整数类型" class="headerlink" title="新增<stdint.h>整数类型"></a>新增<code>&lt;stdint.h&gt;</code>整数类型</h2><h2 id="新增-lt-inttypes-h-gt-整数类型的格式"><a href="#新增-lt-inttypes-h-gt-整数类型的格式" class="headerlink" title="新增<inttypes.h>整数类型的格式"></a>新增<code>&lt;inttypes.h&gt;</code>整数类型的格式</h2><h2 id="新增-lt-complex-h-gt-复数算术运算"><a href="#新增-lt-complex-h-gt-复数算术运算" class="headerlink" title="新增<complex.h>复数算术运算"></a>新增<code>&lt;complex.h&gt;</code>复数算术运算</h2><h2 id="新增-lt-tgmath-h-gt-泛型数学"><a href="#新增-lt-tgmath-h-gt-泛型数学" class="headerlink" title="新增<tgmath.h>泛型数学"></a>新增<code>&lt;tgmath.h&gt;</code>泛型数学</h2><p><tgmath.h>提供了带参数的宏，宏的名字与<math.h>和<complex.h>中的函数名相匹配。这些泛型宏（type-generic macro）可以检测参数的类型，然后调用<math.h>或<complex.h>中相对应的函数。</complex.h></math.h></complex.h></math.h></tgmath.h></p><p>比如：sqrt函数不仅有3种复数版本（csqrt、csqrtf和csqrtl），还有double（sqrt）、float（sqrtf）以及long double版本（sqrtl）。使用<tgmath.h>后，程序员可以直接使用sqrt，而不用担心需要的到底是哪个版本：根据参数x类型的不同，函数调用sqrt(x)有可能是6个版本sqrt中的任何一个。</tgmath.h></p><p>顺便提一下，<tgmath.h>中包含了<math.h>和<complex.h>。</complex.h></math.h></tgmath.h></p><h2 id="新增-lt-fenv-h-gt-浮点环境"><a href="#新增-lt-fenv-h-gt-浮点环境" class="headerlink" title="新增<fenv.h>浮点环境"></a>新增<code>&lt;fenv.h&gt;</code>浮点环境</h2><p>IEEE标准754在表示浮点数时使用最广泛。（C99标准把IEEE 754成为IEC 60559）。<fenv.h>的目的是使程序可以访问IEEE标准指定的浮点状态标志和控制模式。</fenv.h></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法=逻辑+控制</title>
      <link href="suan-fa-luo-ji-kong-zhi/"/>
      <url>suan-fa-luo-ji-kong-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="观点"><a href="#观点" class="headerlink" title="观点"></a>观点</h2><p><a href="https://en.wikipedia.org/wiki/Robert_Kowalski">Robert Kowalski</a>在其论文<a href="https://www.doc.ic.ac.uk/~rak/papers/algorithm%20=%20logic%20+%20control.pdf">Algorithm = Logic + Control</a>中指出：</p><blockquote><p>An algorithm can be regarded as consisting of a logic component, which specifies the knowledge to be used in solving problems, and a control component, which determines the problem-solving strategies by means of which that knowledge is used. The logic component determines the meaning of the algorithm whereas the control component only affects its efficiency. The efficiency of an algorithm can often be improved by improving the control component without changing the logic of the algorithm. We argue that computer programs would be more often correct and more easily improved and modified if their logic and control aspects were identified and separated in the program text.</p><p>算法可以视为由逻辑部分和控制部分组成。其中，逻辑部分指明了解决问题时需要用到的知识。而控制部分则（根据逻辑部分用到的知识来）决定解决问题时需要用到的策略。逻辑部分确定算法的含义，而控制部分只影响其效率。在不改变算法逻辑部分的条件下，通常可以通过改进算法控制部分来提升算法的效率。我们认为，如果软件代码中的逻辑部分和控制部分能够有效的识别和区分开，那么软件将会变得更加容易改进和维护。</p><p>We have argued that conventional algorithms can usefully be regarded as consisting of two components:<br>(1) a logic component which specifies what is to be done and<br>(2) a control component which determines how it is to be done.</p><p>我们认为传统的算法可以被视为由两个部分组成：<br>(1) 一个表明算法<code>做什么</code>的逻辑部分<br>(2) 和一个决定了算法<code>如何做</code>的控制部分。</p></blockquote><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>那么如何来理解<code>算法 = 逻辑 + 控制</code>以及如何区分算法中的<code>逻辑</code>和<code>控制</code>呢？作者举例几个例子来阐述，其中一个简单易懂的例子就是阶乘。</p><p>首先，阶乘的定义是：</p><ol><li><code>0</code>的阶乘是<code>1</code>。</li><li>如果<code>x</code>的阶乘是<code>v</code>，那么<code>x+1</code>的阶乘就是<code>v*(x+1)</code>。</li></ol><p>我们一般有两种方式计算一个数n的阶乘：</p><ol><li>自底向上。首先计算<code>0</code>的阶乘，然后是<code>1</code>，然后是<code>2</code>…一直到<code>n</code>。本质就是从<code>0</code>循环计算直到<code>n</code>。</li><li>自顶向下。要计算<code>n</code>的阶乘，首先就要计算<code>n-1</code>的阶乘。要计算<code>n-1</code>的阶乘，首先就要计算<code>n-2</code>的阶乘。这样一直到需要计算0的阶乘，而我们知道<code>0</code>的阶乘是<code>1</code>。本质就是递归的求解。</li></ol><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>结合<a href="#观点">Robert Kowalski的观点</a>和上面的<a href="#举例">阶乘的例子</a>来理解。</p><p>阶乘算法可以视为由两个部分组成：</p><ol><li>逻辑部分，是阶乘的定义。<br>为什么呢？逻辑部分的定义就是<code>做什么</code>，而阶乘算法的<code>做什么</code>就是计算一个数的阶乘。其中”<em>逻辑部分指明了解决问题时需要用到的知识</em>“的知识，指的就是阶乘算法的定义。换而言之，算法的逻辑部分，指定是算法的业务逻辑。</li><li>控制部分，是阶乘的计算方法。<br>为什么呢？控制部分的定义就是<code>如何做</code>，上面例子中如何计算的阶乘的方法有两种：自底向上和自顶向下。”<em>在不改变算法逻辑部分的条件下，通常可以通过改进算法控制部分来提升算法的效率。</em>“ 我们也确实可以通过优化阶乘计算过程中的细节来提高计算的效率，比如在自底向上的方法中，缓存计算过的值，避免重复计算来提高效率。但是我们很难通过调整阶乘定义的描述方式来优化整个阶乘算法的效率。</li></ol><p>另外一个容易理解的例子是排序算法。不同的排序算法都可以实现排序的功能，而不用的排序算法的效率是不同的，比如冒泡排序，归并排序等。所以对排序算法来说，排序功能是<code>逻辑部分</code>，冒泡、归并等具体的做法则是排序算法的<code>控制部分</code>。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><a href="#观点">Robert Kowalski的观点</a>帮助我们能够更好的分解程序中的算法，将<code>做什么</code>和<code>怎么做</code>的代码分开，其实也是应用<a href="https://kibazen.cn/she-ji-mo-shi-du-shu-bi-ji/">设计模式</a>中<code>策略模式</code>的过程。</p><p>我们都知道，程序是由算法和数据结构组成的（最开始由<a href="https://en.wikipedia.org/wiki/Niklaus_Wirth">Niklaus Wirth</a>在其书<a href="http://www.ethoberon.ethz.ch/WirthPubl/AD.pdf">Algorithms + Data Structures = Programs</a>提出），即<code>算法 + 数据结构 = 程序</code>，而<a href="#观点">Robert Kowalski的观点</a>则是将这个公式进一步的细化，从而让我们能够得出：<code>算法逻辑 + 算法控制 + 数据结构 = 程序</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通俗易懂的介绍CAP定理</title>
      <link href="tong-su-yi-dong-de-jie-shao-cap-ding-li/"/>
      <url>tong-su-yi-dong-de-jie-shao-cap-ding-li/</url>
      
        <content type="html"><![CDATA[<p>本文<code>意译</code>自<a href="http://ksat.me/">Kaushik Sathupadi</a>博客中的一篇博文，该博文通俗易懂的介绍了CAP定理。<br>原文：<a href="http://ksat.me/a-plain-english-introduction-to-cap-theorem">A plain english introduction to CAP Theorem</a><br>翻译：<a href="https://kibazen.cn">kibazen</a></p><hr><p>你经常会听说CAP定理，该定理指明了在设计分布式系统时的一些上限限制。与我大多数其他的教程一样，让我们通过真实世界中的例子来理解CAP定理。</p><blockquote><p>译注：CAP指：一致性（Consistency）、可用性（Availability）、分区容忍性（Partition tolerance）。</p></blockquote><h2 id="一、新的事业“记忆公司”"><a href="#一、新的事业“记忆公司”" class="headerlink" title="一、新的事业“记忆公司”"></a>一、新的事业“记忆公司”</h2><p>昨晚，当你的妻子感谢你记得她的生日，并给她买了礼物时，你的脑海中突然冒出一个奇怪的想法。大家都不擅长记忆，但是你却擅长记忆。所以，为什么不用自己的记忆天赋来创业呢？心动不如行动，于是你z在报纸上打了一个广告：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">记忆公司 —— 即使你不记得，都不会忘记是否还在为忘记很多事而烦恼？不用担心，只需一个电话就可以解决！当你需要记住某事时，拨打电话555-55-REMEN告诉我们你想记住的事。比如：打电话告诉我们你上司的电话号码，然后就可以忘记它了。当拨打同样的电话号码555-55-REMEN，我们就会告诉你上司的电话号码。收费：每次服务仅需0.1元哦！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后，你与客户典型的一次对话内容就会像下面这样：</p><ul><li>客户：你好，麻烦帮我记一下我邻居的生日？</li><li>你：好的，请问是多少？</li><li>客户：1月2日</li><li>你：（记在笔记本上）已经记录好了。当你需要时请再联系我们！</li><li>客户：谢谢！</li><li>你：没关系！本次服务收费0.1元！</li></ul><h2 id="二、业务增长"><a href="#二、业务增长" class="headerlink" title="二、业务增长"></a>二、业务增长</h2><p>因为你的想法很简单，只需要笔记本和电话就能高效的完成业务，公司发展的很顺利，也收到了YCombinator的投资。公司的业务越来越多，每天都会接到上千个电话。</p><p>但是问题也开始出现了，客户需要等待越来越久电话才会接通。一些客户甚至听烦了服务电话的铃声，直接在等待接通的过程中就挂断了电话。同时，当你生病无法工作时，就会白白的丢失了一天业务。这对当天需要服务的客户来说，体验也很不好。所以，是时候扩大公司的规模了，让你的妻子也来帮忙。</p><blockquote><p>译注：随着业务的增长，单点的服务已经不能满足业务的需求。</p></blockquote><p>一个简单的计划：</p><ol><li>你和你的妻子同时接听客户的电话。</li><li>对客户来说，还是只需要记住<code>555-55-REMEN</code>这个电话。</li><li>客户的服务电话会平均且高效的分配给你们。</li></ol><h2 id="三、服务第一次出现问题"><a href="#三、服务第一次出现问题" class="headerlink" title="三、服务第一次出现问题"></a>三、服务第一次出现问题</h2><p>实施新计划的两天后，你接到了老客户John的电话。下面是当时的通话记录：</p><ul><li>John：你好！</li><li>你：欢迎拨打记忆公司热线，有什么可以帮到你？</li><li>John：请告诉我到新泽西的飞机是几点的？</li><li>你：好的，请稍等……（翻了一下自己的笔记本，没找到相关的内容）</li><li>你：你好，你好像并没有告诉我你飞机的信息，我这里找不到相关的信息。</li><li>John：什么？我昨天不是告诉你们了吗？（电话就被挂断了）</li></ul><p>怎么回事呢？John说谎了吗？你思考了一会，然后发现了问题的所在：是不是昨天是你的妻子接到的电话？然后你看妻子的笔记本上面确实有相关信息，这时你和你的妻子才认识到出问题了。</p><p>这个电话分配计划设计的有问题啊！分配系统没有保证<code>一致性</code>！客户每次打来的电话都不一定是同一个人接到，那么客户得到的回答就可能是不对的。</p><blockquote><p>译注：一致性：同样的请求，每次处理的结果应当一致。</p></blockquote><h2 id="四、解决一致性问题"><a href="#四、解决一致性问题" class="headerlink" title="四、解决一致性问题"></a>四、解决一致性问题</h2><p>你的竞争对手可能会忽略这个问题，但是你不会。于是你思考整夜，终于在早上想出了一个不错的计划：</p><ol><li>当接到客户要求我们记录事情的电话时，在挂电话之前，都要先通知另外的人新记录事情的内容。</li><li>所有人同时将新纪录事情的内容<code>更新</code>到各自的笔记本上。</li><li>因为所有人的本子上都有最新的所有已记录的事情，所以，当客户再来问之前记录的内容时，就不用问其他人，因为自己的笔记本上就可以查到了。</li></ol><p>但是这个计划有一个问题，第2步”<code>更新</code>“会影响所有人，这样大家就不能同时工作了。比如：你接到一个记录事情的电话，然后马上告诉我也需要记录这个事，这时我就没办法接听其他客户的电话了。但是这可以接受的，因为大多数客户打来电话都是查询之前的内容（记一次，问多次）。同时，这种方法也解决了之前记了事情但是查不到的问题。</p><p>“这个系统还有一个问题你没考虑到。”你的妻子说。如果我们中有一人某天没有工作时就会出问题，我们不能再记录任何新的事情，因为无法更新那个没工作的人的笔记本。这样就会出现<code>可用性</code>的问题。比如：如果你今天没工作，而此时我又接到一个更新电话，那我就没法完成更新的工作，因为我不能更新你的笔记本。</p><blockquote><p>译注：可用性：即使系统内部某些子系统出现问题，整个系统依然能正常的对外提供服务。</p></blockquote><h2 id="五、更好的解决方法"><a href="#五、更好的解决方法" class="headerlink" title="五、更好的解决方法"></a>五、更好的解决方法</h2><p>你终于意识到了为什么分布式系统并没一开始想的那么简单了。难道就找不到一个既能保证<code>一致性</code>，同时也能保证<code>可用性</code>的解决方法了吗？于是你经过彻夜的思考，在早上又想出了一个和之前的类似，但是更好的计划：</p><ol><li>当接到客户要求我们记录事情的电话时，在挂电话之前，都要先通知另外的人新记录事情的内容。</li><li>如果其他人在正常的工作的话，那么就同时将新纪录事情的内容<code>更新</code>到各自的笔记本上。如果有人没有正常工作的话，就需要给他发邮件提醒他更新。等到他们开始正常工作时，首先需要根据所有收到的更新邮件来更新笔记本，更新完成后，才能开始接电话，为客户提供服务。</li><li>因为所有人的本子上都有最新的所有已记录的事情，所以，当客户再来问之前记录的内容时，就不用问其他人，因为自己的笔记本上就可以查到了。</li></ol><p>太好了！这下“记忆公司”提供的服务就能同时保证<code>一致性</code>和<code>可用性</code>了。</p><h2 id="六、妻子怒了"><a href="#六、妻子怒了" class="headerlink" title="六、妻子怒了"></a>六、妻子怒了</h2><p>有了上面的计划，现在公司的事情进展的很顺利。但是如果你和你的妻子都在上班，而其中一个人接收到更新电话时并没有通知其他人更新呢？比如：你惹你妻子不高兴了，她决定今天一天都不理你了，也不通知你更新笔记本了。那么今天你妻子的笔记本的所有更新你笔记本上都没有。所以，上面的计划只是保证<code>一致性</code>和<code>可用性</code>，并没有保证<code>分区容忍性</code>。<br>你也可以选择在哄好妻子之前，不接任何客户的电话来避免这个问题。但是在你哄好妻子前的这段时间，系统又是不可用的，这样又没法保证<code>可用性</code>了。</p><blockquote><p>分区容忍性：即使各个系统暂时无法正常的通信，整个系统依然能正常的对外提供服务。</p></blockquote><h2 id="七、结论"><a href="#七、结论" class="headerlink" title="七、结论"></a>七、结论</h2><p>好了，让我们来看看CAP定理到底在说什么。CAP定理说的是：当你设计分布式系统时，无法同时让系统满足<code>一致性</code>、<code>可用性</code>和<code>分区容忍性</code>。顶多只能满足其中的两个：</p><ol><li><code>一致性</code>：对你的客户来说，一旦他们更新要记住的事。无论何时，他们总是能获取到最新的记录内容。</li><li><code>可用性</code>：只要你和你的妻子中有人在上班，公司就能正常且正确运行。</li><li><code>分区容忍性</code>：即使你和你的妻子有一段时间不沟通了，公司依然能正常且正确的运行。</li></ol><h2 id="额外奖励：-请一个可以来回跑的秘书来保证最终结果的一致性"><a href="#额外奖励：-请一个可以来回跑的秘书来保证最终结果的一致性" class="headerlink" title="额外奖励： 请一个可以来回跑的秘书来保证最终结果的一致性"></a>额外奖励： 请一个可以来回跑的秘书来保证最终结果的一致性</h2><p>这里还有一个其他的解决方法。可以请一个秘书，当你或你的妻子笔记本更新时，她可以帮你们自动的更新其他人的笔记本上。这么做的最大好处就是：在有记录更新时，就不用等待其他人的笔记本更新完了才能接下一个电话了。这也是很多NoSQL系统的工作原理：数据库节点本地更新自己，然后一个后台进程再将这些修改同步到其他的数据库节点。这种方法的唯一问题就在于会在短时间内丢失一致性。比如：你的妻子接到了客户的更新电话，在秘书把你妻子笔记本上的这个变化同步到你的笔记本上之前，这个客户又打电话来问，但是是你接到了这个电话，这时他就会得到一个错误的回答。话虽如此，这种情况还是比较少的。比如：假如你的客户不会在5分钟内就来打电话问呢。</p><p>这个就是CAP和最终一致性，本文到此结束。</p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机中浮点数的表示方法</title>
      <link href="ji-suan-ji-zhong-fu-dian-shu-de-biao-shi-fang-fa/"/>
      <url>ji-suan-ji-zhong-fu-dian-shu-de-biao-shi-fang-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="IEEE-754标准"><a href="#IEEE-754标准" class="headerlink" title="IEEE 754标准"></a>IEEE 754标准</h2><p>在C/C++等编程语言中，浮点数在计算机中的表示采用的是IEEE 754标准。该标准一共的规定了四种表示浮点数值的方式，其中常见的表示方式有两种：单精确度（32位）和双精确度（64位）。这两种表示方式在C/C++语言中分别可以用<code>float</code>和<code>double</code>关键字来定义。</p><h2 id="单精度浮点数的表示方法"><a href="#单精度浮点数的表示方法" class="headerlink" title="单精度浮点数的表示方法"></a>单精度浮点数的表示方法</h2><p>单精度浮点数的表示方法其实就是把一个32位分成了三个部分：</p><ol><li>第一个部分，占1位，表示浮点数的符号，英文Sign，简称为S。</li><li>第二个部分，占8位，表示浮点数的指数，英文Exponent，简称为E。</li><li>第三个部分，占23位，表示浮点数的尾数，英文Mantissa，简称为M。</li></ol><p>如下图所示：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text"> 31         22                    0+----------------------------------+|S|EEEEEEEE|MMMMMMMMMMMMMMMMMMMMMMM|+----------------------------------+   30     23<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应浮点数表示的值为：</p><script type="math/tex; mode=display">(-1)^S \cdot (1 + \frac{M}{2^{23}}) \cdot 2^{(E-127)}</script><p>结合上面的公式，来理解各个部分的意义就更容易了：</p><ol><li><p>符号部分，$(-1)^S$</p><p> 当S为0时，$(-1)^0 = 1$，表示浮点数的值大于0；同理，当S为1时，$(-1)^1 = -1$，表示浮点数的值小于0。</p></li><li><p>指数部分，$2^{(E-127)}$</p><p> 首先要明白：对于任何一个正实数x，都可以找到一个整数n，使得$2^n &lt;= x &lt; 2^{n+1}$。举个例子，比如5，可以找到n=2，使得$2^2 &lt;= 5 &lt; 2^3$，即$4 &lt;= 5 &lt; 8$。浮点数中的指数部分就是这里的n。</p><p> 那么为什么还要减去127呢？因为当浮点数值的绝对值小于1时，指数部分其实是小于0的。举个例子，比如0.45，只有$n=-2$时，使得$2^{-2} &lt;= 0.45 &lt; 2^{-1}$，即$0.25 &lt;= 0.45 &lt; 0.5$。而浮点数中指数部分占8位，可以表示范围[0-$2^8$)，即[0-256)，为了在指数部分能够表示负数，<code>IEEE 754规定</code>减去127，即$n = E - 127$。所以，如果浮点数的$n=-2$，那么实际的E应该是125。</p></li><li><p>尾数部分，$(1 + \frac{M}{2^{23}})$</p><p> 尾数部分占23位，可以表示范围[0-$2^{23}$)，即[0-8388608)。</p><p> 可以这样理解尾数部分：把一条线分成8388608个段，也就是把$2^n$到$2^{n+1}$分成8388608个线段。尾数部分的值M，表示从$2^n$到浮点数值的绝对值x所要经过的线段数量，也就是$2^n$到x的长度占$2^n$到$2^{n+1}$长度的比例是多少。这个比例的值就是尾数部分公式中$\frac{M}{2^{23}}$的来由，而加1则表示线段的起点$2^n$的值。</p></li></ol><h2 id="单精度浮点数举例"><a href="#单精度浮点数举例" class="headerlink" title="单精度浮点数举例"></a>单精度浮点数举例</h2><p>有了上面的说明，再结合例子来理解一下，比如浮点数3.14：</p><ol><li><p>符号部分</p><p> 因为3.14大于0，所以$S = 0$。</p></li><li><p>指数部分</p><p> $2^1 &lt;= 3.14 &lt; 2^2$，所以$n=1$，那么$E = n + 127 = 128$。</p></li><li><p>尾数部分</p><p> $2^1$到3.14的长度占$2^1$到$2^2$长度的比例是$\frac{(3.14 - 2^1)}{(2^2 - 2^1)} = 0.57$</p></li></ol><p>总线段数量为$2^{23}$，那么，从$2^1$到3.14所要经过的线段数量$M = 0.57 * 2^{23} = 4781506.56$，四舍五入，转换成整数结果为$M = 4781507$。<code>因为有四舍五入，所以浮点数保存的数据和实际数据是有误差的。</code></p><p>把S、E、M转换成二进制，就可以得到3.14的二进制表示<code>0x4048f5c3</code>：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text"> S     E             M+----------------------------------+|0|10000000|10010001111010111000011|+----------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>最后代入浮点数公式计算：</p><script type="math/tex; mode=display">(-1)^0 \cdot (1 + \frac{4781507}{2^{23}}) \cdot 2^{(128-127)} = 3.1400001049041748046875</script><p>也可以使用<a href="https://www.h-schmidt.net/FloatConverter/IEEE754.html">IEEE-754浮点数转换工具</a>来分析浮点数的表示方法。</p><h2 id="双精度浮点数的表示方法"><a href="#双精度浮点数的表示方法" class="headerlink" title="双精度浮点数的表示方法"></a>双精度浮点数的表示方法</h2><p>双精度浮点数和单精度浮点数的原理是一样的，只是各个部分长度不同而已。</p><p>双精度浮点数的表示方法其实就是把一个64位分成了三个部分：</p><ol><li>第一个部分，占1位，表示浮点数的符号，英文Sign，简称为S。</li><li>第二个部分，占11位，表示浮点数的指数，英文Exponent，简称为E。</li><li>第三个部分，占52位，表示浮点数的尾数，英文Mantissa，简称为M。</li></ol><p>对应浮点数表示的值为：</p><script type="math/tex; mode=display">(-1)^S \cdot (1 + \frac{M}{2^{52}}) \cdot 2^{(E-1023)}</script>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浮点数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《重构：改善既有代码的设计(第2版)》读书笔记</title>
      <link href="chong-gou-gai-shan-ji-you-dai-ma-de-she-ji-di-2-ban-du-shu-bi-ji/"/>
      <url>chong-gou-gai-shan-ji-you-dai-ma-de-she-ji-di-2-ban-du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>重构(refactoring)：在不改变代码外在行为的前提下，对代码做出修改，以改进程序的内部结构。重构的本质就是在代码写好之后改进它的设计。</li></ol><h2 id="第1章-重构，第一个示例"><a href="#第1章-重构，第一个示例" class="headerlink" title="第1章 重构，第一个示例"></a>第1章 重构，第一个示例</h2><ol><li>如果你要给程序添加一个特性，但发现代码因缺乏良好的结构而不易于进行更改，那就先重构那个程序，使其比较容易添加该特性，然后再添加该特性。</li><li>需求的变化使重构变得必要。如果一段代码能正常工作，并且不会再被修改，那么完全可以不去重构它。</li><li>重构的第一步：确保即将被修改的代码拥有一组可靠的测试。这些测试必须有自我检验能力。</li><li>无论每次重构多么简单，养成重构后即运行测试的习惯非常重要。</li><li>对于重构过程的性能问题的处理：大多数情况下可以忽略它。如果重构引入了性能损耗，先完成重构，再做性能优化。</li><li>编程时，需要遵循营地法则：保证你离开时的代码库一定比来时更健康。</li><li>好代码的检验标准就是人们是否能轻而易举地修改它。</li></ol><h2 id="第2章-重构的原则"><a href="#第2章-重构的原则" class="headerlink" title="第2章 重构的原则"></a>第2章 重构的原则</h2><ol><li>重构(名词)：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。</li><li>重构(动词)：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。</li><li>如果有人说他们的代码在重构过程中有一两天时间不可用，基本上可以确定，他们在做的事不是重构。</li><li>“结构调整”(restructuring)泛指对代码库进行的各种形式的重新组织或清理，重构则是特定的一类结构调整。</li><li>使用重构技术开发软件时，添加新功能和重构，同一时间，二者只能做其一。</li><li>为何重构：重构改进软件的设计；重构使软件更容易理解；重构帮助找到bug；重构提高编程速度。</li><li>何时重构：预备性重构(添加新功能之前重构)；帮助理解的重构(提升代码阅读性)；捡垃圾式重构(消除代码冗余等)；有计划的重构(固定周期对之前写过的代码重构)和见机行事的重构(写新代码过程中发现其他代码需要重构)；长期重构(更新三方库等)；代码复审时重构。</li><li>不必将重构与添加新功能在版本控制的提交中分开。原因：重构常因新功能所致，单独提交脱离重构的上下文，体现不出为何需要重构；重构的代码和新功能代码高耦合。</li><li>如果经理不能接受代码重构需要花时间，那就不要给经理说。</li><li>何时不应该重构：凌乱且不需要修改的代码；重写比重构更容易的代码。</li><li>重构的挑战：延缓新功能开发；代码所有权(代码是其他部门写的)；分支(多分支开发，最后合并代码)；测试(代码测试不完善，无法保证重构后不引入新BUG)；遗留代码；数据库(改字段值)。</li><li>重构的唯一目的就是让我们开发更快，用更少的工作量创造更大的价值。</li><li>“写代码之前就完成软件的设计和架构”这个思想是不正确的。因为需求会变，且一开始的考虑而不是完全的周全。</li><li>三大实践：自测试代码、持续集成、重构。</li><li>用性能测试工具去定位性能问题，而不是根据对代码的了解来猜测。</li><li>一些语言(Java、C#等)可以借助工具进行自动化的重构。</li></ol><h2 id="第3章-代码的坏味道"><a href="#第3章-代码的坏味道" class="headerlink" title="第3章 代码的坏味道"></a>第3章 代码的坏味道</h2><ol><li>当你”闻到”代码中有坏味道时，就表明代码需要进行重构了。</li><li>当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余。</li><li>神秘命名。</li><li>重复代码。</li><li>过长函数。</li><li>过长参数列表。</li><li>全局数据。(PS：慎用单例模式)</li><li>可变数据(如在js中使用Immutable.js)。</li><li>发散式变化(违背了单一职责原则)。</li><li>霰弹式修改(需求变化是，需要在很多个地方做修改。封装性不够好)。</li><li>依恋情结(违背了依赖倒置原则)。</li><li>数据泥团(很多类中的变量名相同，考虑抽象出基类)。</li><li>基本类型偏执(针对问题域定义新的类型而不是用基本类型，比如定义坐标类，而不是用std::pair)。</li><li>重复的switch。</li><li>循环语句。</li><li>冗赘的元素(有些类结构是不必要的)。</li><li>夸夸其谈通用性。</li><li>临时字段(类内部某个字段仅为某种特定情况而设)。</li><li>过长的消息链。</li><li>中间人(过度使用委托)。</li><li>内幕交易(用委托替代继承等)。</li><li>过大的类。</li><li>异曲同工的类。</li><li>纯数据类(使用面向对象编程而不是面向过程)。</li><li>被拒绝的遗赠(子类复用了超类的实现，却又不愿意支持超类的接口，那就不要用继承)。</li><li>注释(过长的注释)。</li></ol><h2 id="第4章-构筑测试体系"><a href="#第4章-构筑测试体系" class="headerlink" title="第4章 构筑测试体系"></a>第4章 构筑测试体系</h2><ol><li>稳固的测试集合是正确地进行重构的前提条件之一。</li><li>确保所有测试都完全自动化，让它们检查自己的测试结果。</li><li>一套测试就是一个强大的bug侦测器，能够大大缩减查找bug所需的时间。</li><li>测试驱动开发的编程方式依赖于下面这个短循环：先编写一个（失败的）测试，编写代码使测试通过，然后进行重构以保证代码整洁。</li><li>总是确保测试不该通过时真的会失败。</li><li>频繁地运行测试。对于你正在处理的代码，与其对应的测试至少每隔几分钟就要运行一次，每天至少运行一次所有的测试。</li><li>编写未臻完善的测试并经常运行，好过对完美测试的无尽等待。</li><li>考虑可能出错的边界条件，把测试火力集中在那儿。</li><li>如果错误会导致脏数据在应用中到处传递，或是产生一些很难调试的失败，考虑引入断言手法，使代码不满足预设条件时快速失败。不用为这样的失败断言添加测试，它们本身就是一种测试的形式。</li><li>不要因为测试无法捕捉所有的bug就不写测试，因为测试的确可以捕捉到大多数bug。</li><li>每当你收到bug报告，请先写一个单元测试来暴露这个bug。</li></ol><h2 id="第5章-介绍重构名录"><a href="#第5章-介绍重构名录" class="headerlink" title="第5章 介绍重构名录"></a>第5章 介绍重构名录</h2><ol><li>书的剩余部分是重构方法的索引，作为参看书来使用。</li></ol><h2 id="第6章-第一组重构"><a href="#第6章-第一组重构" class="headerlink" title="第6章 第一组重构"></a>第6章 第一组重构</h2><ol><li>提炼函数 vs 内联函数。</li><li>提炼变量 vs 内联变量。</li><li>改变函数声明。</li><li>封装变量。</li><li>变量改名。</li><li>引入参数对象。</li><li>函数组合成类v</li><li>函数组合成变换。</li><li>拆分阶段。</li></ol><h2 id="第7章-封装"><a href="#第7章-封装" class="headerlink" title="第7章 封装"></a>第7章 封装</h2><ol><li>封装记录。</li><li>封装集合。</li><li>以对象取代基本类型。</li><li>以查询取代临时变量。</li><li>提炼类 vs 内联类。</li><li>隐藏委托关系 vs 移除中间人。</li><li>替换算法。</li></ol><h2 id="第8章-搬移特性"><a href="#第8章-搬移特性" class="headerlink" title="第8章 搬移特性"></a>第8章 搬移特性</h2><ol><li>搬移函数。</li><li>搬移字段。</li><li>搬移语句到函数 vs 搬移语句到调用者。</li><li>移动语句。</li><li>拆分循环。</li><li>以管道取代循环。</li><li>移除死代码。</li></ol><h2 id="第9章-重新组织数据"><a href="#第9章-重新组织数据" class="headerlink" title="第9章 重新组织数据"></a>第9章 重新组织数据</h2><ol><li>拆分变量。</li><li>字段改名。</li><li>以查询取代派生变量。</li><li>将引用对象改为值对象 vs 将值对象改为引用对象。</li></ol><h2 id="第10章-简化条件逻辑"><a href="#第10章-简化条件逻辑" class="headerlink" title="第10章 简化条件逻辑"></a>第10章 简化条件逻辑</h2><ol><li>分解条件表达式 vs 合并条件表达式。</li><li>以卫语句取代嵌套条件表达式(Replace Nested Conditional with Guard Clauses)。</li><li>以多态取代条件表达式。</li><li>引入特例。</li><li>引入断言。</li></ol><h2 id="第11章-重构API"><a href="#第11章-重构API" class="headerlink" title="第11章 重构API"></a>第11章 重构API</h2><ol><li>将查询函数和修改函数分离。</li><li>函数参数化。</li><li>移除标记参数。</li><li>保持对象完整。</li><li>以查询取代参数 vs 以参数取代查询。</li><li>移除设值函数。</li><li>以工厂函数取代构造函数。</li><li>以命令取代函数 vs 以函数取代命令。</li></ol><h2 id="第12章-处理继承关系"><a href="#第12章-处理继承关系" class="headerlink" title="第12章 处理继承关系"></a>第12章 处理继承关系</h2><ol><li>函数上移 vs 函数下移。</li><li>字段上移 vs 字段下移。</li><li>构造函数本体上移。</li><li>以子类取代类型码 vs 移除子类。</li><li>提炼超类。</li><li>折叠继承体系。</li><li>以委托取代子类。</li><li>以委托取代超类。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重构 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《设计模式》读书笔记</title>
      <link href="she-ji-mo-shi-du-shu-bi-ji/"/>
      <url>she-ji-mo-shi-du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><h3 id="1-1-设计模式的编目"><a href="#1-1-设计模式的编目" class="headerlink" title="1.1 设计模式的编目"></a>1.1 设计模式的编目</h3><ol><li><strong>Abstract Factory</strong>: 提供了一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</li><li><strong>Adapter</strong>: 将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</li><li><strong>Bridge</strong>: 将抽象部分与它的实现部分分离，使它们都可以独立地变化。</li><li><strong>Builder</strong>: 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</li><li><strong>Chain of Responsibility</strong>: 为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。</li><li><strong>Command</strong>: 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。</li><li><strong>Composite</strong>: 将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得客户对单个对象和复合对象的使用具有一致性。</li><li><strong>Decorator</strong>: 动态地给一个对象添加一些额外的职责。就扩展功能而言，Decorator模式比生成子类方式更为灵活。</li><li><strong>Facade</strong>: 为子系统中的一组接口提供一个一致，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</li><li><strong>Factory Method</strong>: 定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method是一个类的实例化延迟到其子类。</li><li><strong>Flyweight</strong>: 运用共享技术有效地支持大量细粒度的对象。</li><li><strong>Interpreter</strong>: 给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。</li><li><strong>Iterator</strong>: 提供了一个方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。</li><li><strong>Mediator</strong>: 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</li><li><strong>Memento</strong>: 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</li><li><strong>Observer</strong>: 定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。</li><li><strong>Prototype</strong>: 用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。</li><li><strong>Proxy</strong>: 为其他对象提供一个代理以控制对这个对象的访问。</li><li><strong>Singleton</strong>: 保证一个类仅有一个实例，并提供一个访问它的全局访问点。</li><li><strong>State</strong>: 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。</li><li><strong>Strategy</strong>: 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。</li><li><strong>Template Method</strong>: 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</li><li><strong>Visitor</strong>: 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</li></ol><h3 id="1-2-组织编目"><a href="#1-2-组织编目" class="headerlink" title="1.2 组织编目"></a>1.2 组织编目</h3><p><img src="/images/《设计模式》读书笔记/设计模式空间.png" alt="设计模式空间"></p><h3 id="1-3-怎样选择设计模式"><a href="#1-3-怎样选择设计模式" class="headerlink" title="1.3 怎样选择设计模式"></a>1.3 怎样选择设计模式</h3><p><img src="/images/《设计模式》读书笔记/设计模式所支持的设计的可变方面.png" alt="设计模式所支持的设计的可变方面"></p><hr><h2 id="二、创建型模式"><a href="#二、创建型模式" class="headerlink" title="二、创建型模式"></a>二、创建型模式</h2><h3 id="2-1-Abstract-Factory-抽象工厂"><a href="#2-1-Abstract-Factory-抽象工厂" class="headerlink" title="2.1 Abstract Factory(抽象工厂)"></a>2.1 Abstract Factory(抽象工厂)</h3><h4 id="2-1-1-类图"><a href="#2-1-1-类图" class="headerlink" title="2.1.1 类图"></a>2.1.1 类图</h4><p><img src="/images/《设计模式》读书笔记/抽象工厂类图.png" alt="抽象工厂类图"></p><h4 id="2-1-2-参与者"><a href="#2-1-2-参与者" class="headerlink" title="2.1.2 参与者"></a>2.1.2 参与者</h4><p>AbstractFactory</p><ol><li>声明一个创建抽象产品对象的操作接口。</li></ol><p>ConcreteFactory</p><ol><li>实现创建具体产品对象的操作。</li></ol><p>AbstractProduct</p><ol><li>为一类产品声明一个接口。</li></ol><p>ConcreteProduct</p><ol><li>定义一个将被相应的具体工厂创建的产品对象。</li><li>实现AbstractProduct接口。</li></ol><p>Client</p><ol><li>仅使用由AbstractFactory和AbstractProduct类声明的接口。</li></ol><h4 id="2-1-3-协作"><a href="#2-1-3-协作" class="headerlink" title="2.1.3 协作"></a>2.1.3 协作</h4><ol><li>通常在运行时刻创建一个ConcreteFactory类的实例。这一具体的工厂创建具有特定实现的产品对象。为创建不同的产品对象，客户应使用不同的具体工程。</li><li>AbstractFactory将产品对象的创建延迟到它的ConcreteFactory子类。</li></ol><h3 id="2-2-Builder-生成器"><a href="#2-2-Builder-生成器" class="headerlink" title="2.2 Builder(生成器)"></a>2.2 Builder(生成器)</h3><h4 id="2-2-1-类图"><a href="#2-2-1-类图" class="headerlink" title="2.2.1 类图"></a>2.2.1 类图</h4><p><img src="/images/《设计模式》读书笔记/生成器类图.png" alt="生成器类图"></p><h4 id="2-2-2-参与者"><a href="#2-2-2-参与者" class="headerlink" title="2.2.2 参与者"></a>2.2.2 参与者</h4><p>Builder</p><ol><li>为创建一个Product对象的各个部件指定抽象接口。</li></ol><p>ConcreteBuilder</p><ol><li>实现Builder的接口以构造和装配该产品的各个部件。</li><li>定义并明确它所创建的表示。</li><li>提供一个检索产品的接口。</li></ol><p>Director</p><ol><li>构造一个使用Builder接口的对象。</li></ol><p>Product</p><ol><li>表示被构造的复杂对象。ConcreteBuilder创建该产品的内部表示并定义它的装配过程。</li><li>包含定义组成部件的类，包括将这些部件装配成最终产品的接口。</li></ol><h4 id="2-2-3-协作"><a href="#2-2-3-协作" class="headerlink" title="2.2.3 协作"></a>2.2.3 协作</h4><ol><li>客户创建Director对象，并用它所想要的Builder对象进行配置。</li><li>一旦产品部件被生成，导向器就会通知生成器。</li><li>生成器处理导向器的请求，并将部件添加到该产品中。</li><li>客户从生成器中检索产品。</li></ol><p>交互图</p><p><img src="/images/《设计模式》读书笔记/生成器协作类图.png" alt="生成器协作类图"></p><h3 id="2-3-Factory-Method-工厂方法"><a href="#2-3-Factory-Method-工厂方法" class="headerlink" title="2.3 Factory Method(工厂方法)"></a>2.3 Factory Method(工厂方法)</h3><h4 id="2-3-1-类图"><a href="#2-3-1-类图" class="headerlink" title="2.3.1 类图"></a>2.3.1 类图</h4><p><img src="/images/《设计模式》读书笔记/工厂方法类图.png" alt="工厂方法类图"></p><h4 id="2-3-2-参与者"><a href="#2-3-2-参与者" class="headerlink" title="2.3.2 参与者"></a>2.3.2 参与者</h4><p>Product</p><ol><li>定义工厂方法所创建的对象的接口。</li></ol><p>ConcreteProduct</p><ol><li>实现Product接口。</li></ol><p>Creator</p><ol><li>声明工厂方法，该方法返回一个Product类型的对象。Creator也可以定义一个工厂方法的缺省实现，它返回一个缺省的ConcreteProduct对象。</li><li>也可以调用工厂方法以创建一个Product对象。</li></ol><p>ConcreteCreator</p><ol><li>重定义工厂方法以返回一个ConcreteProduct实例。</li></ol><h4 id="2-3-3-协作"><a href="#2-3-3-协作" class="headerlink" title="2.3.3 协作"></a>2.3.3 协作</h4><ol><li>Creator依赖于它的子类来定义工厂方法，所以它返回一个适当的ConcreteProduct实例。</li></ol><h3 id="2-4-Prototype-原型"><a href="#2-4-Prototype-原型" class="headerlink" title="2.4 Prototype(原型)"></a>2.4 Prototype(原型)</h3><h4 id="2-4-1-类图"><a href="#2-4-1-类图" class="headerlink" title="2.4.1 类图"></a>2.4.1 类图</h4><p><img src="/images/《设计模式》读书笔记/原型类图.png" alt="原型类图"></p><h4 id="2-4-2-参与者"><a href="#2-4-2-参与者" class="headerlink" title="2.4.2 参与者"></a>2.4.2 参与者</h4><p>Prototype</p><ol><li>声明一个克隆自身的接口。</li></ol><p>ConcretePrototype</p><ol><li>实现一个克隆自身的操作。</li></ol><p>Client</p><ol><li>让一个原型克隆自身从而创建一个新的对象。</li></ol><h4 id="2-4-3-协作"><a href="#2-4-3-协作" class="headerlink" title="2.4.3 协作"></a>2.4.3 协作</h4><ol><li>客户请求一个原型克隆自身。</li></ol><h3 id="2-5-Singleton-单件"><a href="#2-5-Singleton-单件" class="headerlink" title="2.5 Singleton(单件)"></a>2.5 Singleton(单件)</h3><h4 id="2-5-1-类图"><a href="#2-5-1-类图" class="headerlink" title="2.5.1 类图"></a>2.5.1 类图</h4><p><img src="/images/《设计模式》读书笔记/单件类图.png" alt="单件类图"></p><h4 id="2-5-2-参与者"><a href="#2-5-2-参与者" class="headerlink" title="2.5.2 参与者"></a>2.5.2 参与者</h4><p>Singleton</p><ol><li>定义一个Instance操作，允许客户访问它的唯一实例。Instance是一个类操作（C++中的一个静态成员函数）。</li><li>可能负责创建它自己的唯一实例。</li></ol><h4 id="2-5-3-协作"><a href="#2-5-3-协作" class="headerlink" title="2.5.3 协作"></a>2.5.3 协作</h4><ol><li>客户只能通过Singleton的Instance操作访问一个Singleton的实例。</li></ol><hr><h2 id="三、结构型模式"><a href="#三、结构型模式" class="headerlink" title="三、结构型模式"></a>三、结构型模式</h2><h3 id="3-1-Adapter-适配器"><a href="#3-1-Adapter-适配器" class="headerlink" title="3.1 Adapter(适配器)"></a>3.1 Adapter(适配器)</h3><h4 id="3-1-1-类图"><a href="#3-1-1-类图" class="headerlink" title="3.1.1 类图"></a>3.1.1 类图</h4><p>类版本</p><p><img src="/images/《设计模式》读书笔记/适配器类版本类图.png" alt="适配器类版本类图"></p><p>对象版本</p><p><img src="/images/《设计模式》读书笔记/适配器对象版本类图.png" alt="适配器对象版本类图"></p><h4 id="3-1-2-参与者"><a href="#3-1-2-参与者" class="headerlink" title="3.1.2 参与者"></a>3.1.2 参与者</h4><p>Target</p><ol><li>定义Client使用的与特定领域相关的接口。</li></ol><p>Client</p><ol><li>与符合Target接口的对象协同。</li></ol><p>Adaptee</p><ol><li>定义一个已经存在的接口，这个接口需要适配。</li></ol><p>Adapter</p><ol><li>对Adaptee的接口与Target接口进行适配。</li></ol><h4 id="3-1-3-协作"><a href="#3-1-3-协作" class="headerlink" title="3.1.3 协作"></a>3.1.3 协作</h4><ol><li>Client在Adapter实例上调用一些操作。接着适配器调用Adaptee的操作实现这个请求。</li></ol><h3 id="3-2-Bridge-桥接"><a href="#3-2-Bridge-桥接" class="headerlink" title="3.2 Bridge(桥接)"></a>3.2 Bridge(桥接)</h3><h4 id="3-2-1-类图"><a href="#3-2-1-类图" class="headerlink" title="3.2.1 类图"></a>3.2.1 类图</h4><p><img src="/images/《设计模式》读书笔记/桥接类图.png" alt="桥接类图"></p><h4 id="3-2-2-参与者"><a href="#3-2-2-参与者" class="headerlink" title="3.2.2 参与者"></a>3.2.2 参与者</h4><p>Abstraction</p><ol><li>定义抽象类的接口。</li><li>维护一个指向Implementor类型对象的指针。</li></ol><p>RefinedAbstraction</p><ol><li>扩充由Abstraction定义的接口。</li></ol><p>Implementor</p><ol><li>定义实现类的接口，该接口不一定要与Abstraction的接口完全一致；事实上这两个接口可以完全不同。一般来讲，Implementor接口仅提供基本操作，而Abstraction则定义了基于这些基本操作的较高层次的操作。</li></ol><p>ConcreteImplementor</p><ol><li>实现Implementor接口并定义它的具体实现。</li></ol><h4 id="3-2-3-协作"><a href="#3-2-3-协作" class="headerlink" title="3.2.3 协作"></a>3.2.3 协作</h4><ol><li>Abstraction将client的请求转发给它的Implementor对象。</li></ol><h3 id="3-3-Composite-组合"><a href="#3-3-Composite-组合" class="headerlink" title="3.3 Composite(组合)"></a>3.3 Composite(组合)</h3><h4 id="3-3-1-类图"><a href="#3-3-1-类图" class="headerlink" title="3.3.1 类图"></a>3.3.1 类图</h4><p><img src="/images/《设计模式》读书笔记/组合类图.png" alt="组合类图"></p><h4 id="3-3-2-参与者"><a href="#3-3-2-参与者" class="headerlink" title="3.3.2 参与者"></a>3.3.2 参与者</h4><p>Component</p><ol><li>为组合中的对象声明接口。</li><li>在适当的情况下，实现所有类共有接口的缺省行为。</li><li>声明一个接口用于访问和管理Component的子组件。</li><li>(可选)在递归结构中定义一个接口，用于访问一个父组件，并在合适的情况下实现它。</li></ol><p>Leaf</p><ol><li>在组合中表示叶节点对象，叶节点没有子节点。</li><li>在组合中定义图元对象的行为。</li></ol><p>Composite</p><ol><li>定义有子部件的那些部件的行为。</li><li>存储子部件。</li><li>在Component接口中实现与子部件有关的操作。</li></ol><p>Client</p><ol><li>通过Component接口操纵组合部件的对象。</li></ol><h4 id="3-3-3-协作"><a href="#3-3-3-协作" class="headerlink" title="3.3.3 协作"></a>3.3.3 协作</h4><ol><li>用户使用Component类接口与组合结构中的对象进行交互。如果接收者是一个叶节点，则直接处理请求。如果接收者是Composite，它通常将请求发送给它的子部件，在转发请求之前与/或之后可能执行一些辅助操作。</li></ol><h3 id="3-4-Decorator-装饰"><a href="#3-4-Decorator-装饰" class="headerlink" title="3.4 Decorator(装饰)"></a>3.4 Decorator(装饰)</h3><h4 id="3-4-1-类图"><a href="#3-4-1-类图" class="headerlink" title="3.4.1 类图"></a>3.4.1 类图</h4><p><img src="/images/《设计模式》读书笔记/装饰类图.png" alt="装饰类图"></p><h4 id="3-4-2-对象结构示例图"><a href="#3-4-2-对象结构示例图" class="headerlink" title="3.4.2 对象结构示例图"></a>3.4.2 对象结构示例图</h4><p><img src="/images/《设计模式》读书笔记/装饰对象结构示例图.png" alt="装饰对象结构示例图"></p><h4 id="3-4-3-参与者"><a href="#3-4-3-参与者" class="headerlink" title="3.4.3 参与者"></a>3.4.3 参与者</h4><p>Component</p><ol><li>定义一个对象接口，可以给这些对象动态地添加职责。</li></ol><p>ConcreteComponent</p><ol><li>定义一个对象，可以给这个对象添加一些职责。</li></ol><p>Decorator</p><ol><li>维持一个指向Component对象的指针，并定义一个与Component接口一致的接口。</li></ol><p>ConcreteDecorator</p><ol><li>向组件添加职责。</li></ol><h4 id="3-4-4-协作"><a href="#3-4-4-协作" class="headerlink" title="3.4.4 协作"></a>3.4.4 协作</h4><ol><li>Decorator将请求转发给它的Component对象，并有可能在转发请求前后执行一些附加的动作。</li></ol><h3 id="3-5-Facade-外观"><a href="#3-5-Facade-外观" class="headerlink" title="3.5 Facade(外观)"></a>3.5 Facade(外观)</h3><h4 id="3-5-1-类图"><a href="#3-5-1-类图" class="headerlink" title="3.5.1 类图"></a>3.5.1 类图</h4><p><img src="/images/《设计模式》读书笔记/外观类图.png" alt="外观类图"></p><h4 id="3-5-2-参与者"><a href="#3-5-2-参与者" class="headerlink" title="3.5.2 参与者"></a>3.5.2 参与者</h4><p>Facade</p><ol><li>知道哪些子系统类负责处理请求。</li><li>将客户的请求代理给适当的子系统对象。</li></ol><p>Subsystem classes</p><ol><li>实现子系统的功能。</li><li>处理由Facade对象指派的任务。</li><li>没有facade的任何相关信息；即没有指向facade的指针。</li></ol><h4 id="3-5-3-协作"><a href="#3-5-3-协作" class="headerlink" title="3.5.3 协作"></a>3.5.3 协作</h4><ol><li>客户程序通过发送请求给Facade的方式与子系统通信，Facade将这些消息转发给适当的子系统对象。尽管是子系统中的有关对象在做实际工作，但Facade模式本身也必须将它的接口转换成子系统的接口。</li><li>使用Facade的客户程序不需要直接访问子系统对象。</li></ol><h3 id="3-6-Flyweight-享元"><a href="#3-6-Flyweight-享元" class="headerlink" title="3.6 Flyweight(享元)"></a>3.6 Flyweight(享元)</h3><h4 id="3-6-1-类图"><a href="#3-6-1-类图" class="headerlink" title="3.6.1 类图"></a>3.6.1 类图</h4><p><img src="/images/《设计模式》读书笔记/享元类图.png" alt="享元类图"></p><h4 id="3-6-2-对象结构示例图"><a href="#3-6-2-对象结构示例图" class="headerlink" title="3.6.2 对象结构示例图"></a>3.6.2 对象结构示例图</h4><p><img src="/images/《设计模式》读书笔记/享元对象结构示例图.png" alt="享元对象结构示例图"></p><h4 id="3-6-3-参与者"><a href="#3-6-3-参与者" class="headerlink" title="3.6.3 参与者"></a>3.6.3 参与者</h4><p>Flyweight</p><ol><li>描述一个接口，通过这个接口flyweight可以接受并作用于外部状态。</li></ol><p>ConcreteFlyweight</p><ol><li>实现Flyweight接口，并为内部状态（如果有的话）增加存储空间。ConcreteFlyweight对象必须是可共享的。它所存储的状态必须是内部的；即，它必须独立于ConcreteFlyweight对象的场景。</li></ol><p>UnsharedConcreteFlyweight</p><ol><li>并非所有的Flyweight子类都需要被共享。Flyweight接口使共享成为可能，但它并不强制共享。在Flyweight对象结构的某些层次，UnsharedConcreteFlyweight对象通常将ConcreteFlyweight对象作为子节点。</li></ol><p>FlyweightFactory</p><ol><li>创建并管理flyweight对象。</li><li>确保合理地共享flyweight。当用户请求一个flyweight时，FlyweightFactory对象提供一个已创建的实例或者创建一个（如果不存在的话）。</li></ol><p>Client</p><ol><li>维持一个对flyweight的引用。</li><li>计算或存储一个（多个）flyweight的外部状态。</li></ol><h4 id="3-6-4-协作"><a href="#3-6-4-协作" class="headerlink" title="3.6.4 协作"></a>3.6.4 协作</h4><ol><li>flyweight执行时所需的状态必定时内部的或外部的。内部状态存储于ConcreteFlyweight对象之中；而外部对象则由Client对象存储或计算。当用户调用flyweight对象的操作时，将该状态传递给它。</li><li>用户不应直接对ConcreteFlyweight类进行实例化，而只能从FlyeightFactory对象得到ConcreteFlyweight对象，这可以保证对它们适当地进行共享。</li></ol><h3 id="3-7-Proxy-代理"><a href="#3-7-Proxy-代理" class="headerlink" title="3.7 Proxy(代理)"></a>3.7 Proxy(代理)</h3><h4 id="3-7-1-类图"><a href="#3-7-1-类图" class="headerlink" title="3.7.1 类图"></a>3.7.1 类图</h4><p><img src="/images/《设计模式》读书笔记/代理类图.png" alt="代理类图"></p><h4 id="3-7-2-对象结构示例图"><a href="#3-7-2-对象结构示例图" class="headerlink" title="3.7.2 对象结构示例图"></a>3.7.2 对象结构示例图</h4><p><img src="/images/《设计模式》读书笔记/代理对象结构示例图.png" alt="代理对象结构示例图"></p><h4 id="3-7-3-参与者"><a href="#3-7-3-参与者" class="headerlink" title="3.7.3 参与者"></a>3.7.3 参与者</h4><p>Proxy</p><ol><li>保持一个引用使得代理可以访问实体。若RealSubject和Subject的接口相同，Proxy会引用Subject。</li><li>提供一个与Subject的接口相同的接口，这样代理就可以用来替代实体。</li><li>控制对实体的存取，并可能负责创建和删除它。</li><li><p>其他功能依赖于代理的类型：</p><ol><li>Remote Proxy负责对请求及其参数进行编码，并向不同地址空间中的实体发送已编码的请求。</li><li>Virtual Proxy可以缓存实体的附加信息，以便延迟对它的访问。</li><li>Protection Proxy检查调用者是否具有实现一个请求所必须的访问权限。</li></ol></li></ol><p>Subject</p><ol><li>定义RealSubject和Proxy的共用接口，这样就在任何使用RealSubject的地方都可以使用Proxy。</li></ol><p>RealSubject</p><ol><li>定义Proxy所代表的实体。</li></ol><h4 id="3-7-4-协作"><a href="#3-7-4-协作" class="headerlink" title="3.7.4 协作"></a>3.7.4 协作</h4><ol><li>代理根据其种类，在适当的时候向RealSubject转发请求。</li></ol><hr><h2 id="四、行为模式"><a href="#四、行为模式" class="headerlink" title="四、行为模式"></a>四、行为模式</h2><h3 id="4-1-Chain-of-Responsibility-职责链"><a href="#4-1-Chain-of-Responsibility-职责链" class="headerlink" title="4.1 Chain of Responsibility(职责链)"></a>4.1 Chain of Responsibility(职责链)</h3><h4 id="4-1-1-类图"><a href="#4-1-1-类图" class="headerlink" title="4.1.1 类图"></a>4.1.1 类图</h4><p><img src="/images/《设计模式》读书笔记/职责链类图.png" alt="职责链类图"></p><h4 id="4-1-2-对象结构示例图"><a href="#4-1-2-对象结构示例图" class="headerlink" title="4.1.2 对象结构示例图"></a>4.1.2 对象结构示例图</h4><p><img src="/images/《设计模式》读书笔记/职责链对象结构示例图.png" alt="职责链对象结构示例图"></p><h4 id="4-1-3-参与者"><a href="#4-1-3-参与者" class="headerlink" title="4.1.3 参与者"></a>4.1.3 参与者</h4><p>Handler</p><ol><li>定义一个处理请求的接口。</li><li>（可选）实现后继链。</li></ol><p>ConcreteHandler</p><ol><li>处理它所负责的请求。</li><li>可访问它的后继者。</li><li>如果可处理该请求，就处理；否则将该请求转发给它的后继者。</li></ol><p>Client</p><ol><li>向链上的具体处理者(ConcreteHandler)对象提交请求。</li></ol><h4 id="4-1-4-协作"><a href="#4-1-4-协作" class="headerlink" title="4.1.4 协作"></a>4.1.4 协作</h4><ol><li>当客户提交一个请求时，请求沿链传递直至有一个ConcreteHandler对象负责处理它。</li></ol><h3 id="4-2-Command-命令"><a href="#4-2-Command-命令" class="headerlink" title="4.2 Command(命令)"></a>4.2 Command(命令)</h3><h4 id="4-2-1-类图"><a href="#4-2-1-类图" class="headerlink" title="4.2.1 类图"></a>4.2.1 类图</h4><p><img src="/images/《设计模式》读书笔记/命令类图.png" alt="命令类图"></p><h4 id="4-2-2-参与者"><a href="#4-2-2-参与者" class="headerlink" title="4.2.2 参与者"></a>4.2.2 参与者</h4><p>Command</p><ol><li>声明执行操作的接口。</li></ol><p>ConcreteCommand</p><ol><li>将一个接收者对象绑定于一个动作。</li><li>调用接收者相应的操作，以实现Execute。</li></ol><p>Client</p><ol><li>创建一个具体命令对象并设定它的接收者。</li></ol><p>Invoker</p><ol><li>要求该命令执行这个请求。</li></ol><p>Receiver</p><ol><li>知道如何实施与执行一个请求相关的操作。任何类都可能作为一个接收者。</li></ol><h4 id="4-2-3-协作"><a href="#4-2-3-协作" class="headerlink" title="4.2.3 协作"></a>4.2.3 协作</h4><ol><li>Client创建一个ConcreteCommand对象并指定它的Receiver对象。</li><li>某Invoker对象存储该ConcreteCommand对象。</li><li>该Invoker通过调用Command对象的Execute操作来提交一个请求。若该命令是可撤销的，ConcreteCommand就在执行Execute操作之前存储当前状态已用于取消该命令。</li><li>ConcreteCommand对象对调用它的Recevier的进行操作以执行该请求。</li></ol><h4 id="4-2-4-时序图"><a href="#4-2-4-时序图" class="headerlink" title="4.2.4 时序图"></a>4.2.4 时序图</h4><p><img src="/images/《设计模式》读书笔记/命令时序图.png" alt="命令时序图"></p><h3 id="4-3-Interpreter-解释器"><a href="#4-3-Interpreter-解释器" class="headerlink" title="4.3 Interpreter(解释器)"></a>4.3 Interpreter(解释器)</h3><h4 id="4-3-1-类图"><a href="#4-3-1-类图" class="headerlink" title="4.3.1 类图"></a>4.3.1 类图</h4><p><img src="/images/《设计模式》读书笔记/解释器类图.png" alt="解释器类图"></p><h4 id="4-3-2-参与者"><a href="#4-3-2-参与者" class="headerlink" title="4.3.2 参与者"></a>4.3.2 参与者</h4><p>AbstractExpression(抽象表达式)</p><ol><li>声明一个抽象的解释操作，这个接口为抽象语法树中所有的节点所共享。</li></ol><p>TerminalExpression(终结符表达式)</p><ol><li>实现与文法中的终结符相关联的解释操作。</li><li>一个句子中的每个终结符需要该类的一个实例。</li></ol><p>NonterminalExpression(非终结符表达式)</p><ol><li>对文法中的每一条规则<code>R ::=R&lt;sub&gt;1&lt;/sub&gt;R&lt;sub&gt;2&lt;/sub&gt;...R&lt;sub&gt;n&lt;/sub&gt;</code>都需要一个NonterminalExpression类。</li><li>为从<code>R&lt;sub&gt;1&lt;/sub&gt;</code>到<code>R&lt;sub&gt;n&lt;/sub&gt;</code>的每个符号都维护一个AbstractExpression类型的实例变量。</li><li>为文法中的非终结符实现解释(Interpret)操作。解释(Interpret)一般要递归地调用表示<code>R&lt;sub&gt;1&lt;/sub&gt;</code>到<code>R&lt;sub&gt;n&lt;/sub&gt;</code>的那些对象的解释操作。</li></ol><p>Context</p><ol><li>包含解释器之外的一些全局信息。</li></ol><p>Client</p><ol><li>构建（或被给定）表示该文法定义的语言中一个特定的句子的抽象语法树。该抽象语法树由NonterminalExpression和TerminalExpression的实例装配而成。</li><li>调用解释操作。</li></ol><h4 id="4-3-3-协作"><a href="#4-3-3-协作" class="headerlink" title="4.3.3 协作"></a>4.3.3 协作</h4><ol><li>Client构建（或被给定）一个句子，它是NonterminalExpression和TerminalExpression的实例的一个抽象语法树，然后初始化上下文并调用解释操作。</li><li>每一个非终结符表达式节点定义相应子表达式的解释操作。而各终结符表达式的解释操作构成了递归的基础。</li><li>每一节点的解释操作用上下文来存储和访问解释器的状态。</li></ol><h3 id="4-4-Iterator-迭代器"><a href="#4-4-Iterator-迭代器" class="headerlink" title="4.4 Iterator(迭代器)"></a>4.4 Iterator(迭代器)</h3><h4 id="4-4-1-类图"><a href="#4-4-1-类图" class="headerlink" title="4.4.1 类图"></a>4.4.1 类图</h4><p><img src="/images/《设计模式》读书笔记/迭代器类图.png" alt="迭代器类图"></p><h4 id="4-4-2-参与者"><a href="#4-4-2-参与者" class="headerlink" title="4.4.2 参与者"></a>4.4.2 参与者</h4><p>Iterator</p><ol><li>迭代器定义访问和遍历元素的接口。</li></ol><p>ConcreteIterator</p><ol><li>具体迭代器实现迭代器接口。</li><li>对该聚合遍历时跟踪当前位置。</li></ol><p>Aggregate</p><ol><li>聚合定义创建相应迭代器对象的接口。</li></ol><p>ConcreteAggregate</p><ol><li>具体聚合实现创建相应迭代器的接口，该操作返回ConcreteIterator的一个适当的实例。</li></ol><h4 id="4-4-3-协作"><a href="#4-4-3-协作" class="headerlink" title="4.4.3 协作"></a>4.4.3 协作</h4><ol><li>ConcreteIterator跟踪聚合中的当前对象，并能够计算出待遍历的后继对象。</li></ol><h3 id="4-5-Mediator-中介者"><a href="#4-5-Mediator-中介者" class="headerlink" title="4.5 Mediator(中介者)"></a>4.5 Mediator(中介者)</h3><h4 id="4-5-1-类图"><a href="#4-5-1-类图" class="headerlink" title="4.5.1 类图"></a>4.5.1 类图</h4><p><img src="/images/《设计模式》读书笔记/中介者类图.png" alt="中介者类图"></p><h4 id="4-5-2-对象结构示例图"><a href="#4-5-2-对象结构示例图" class="headerlink" title="4.5.2 对象结构示例图"></a>4.5.2 对象结构示例图</h4><p><img src="/images/《设计模式》读书笔记/中介者对象结构示例图.png" alt="中介者对象结构示例图"></p><h4 id="4-5-3-参与者"><a href="#4-5-3-参与者" class="headerlink" title="4.5.3 参与者"></a>4.5.3 参与者</h4><p>Mediator</p><ol><li>中介者定义一个接口用于与各同事(Colleague)对象通信。</li></ol><p>ConcreteMediator</p><ol><li>具体中介者通过协调各同事对象实现协作行为。</li><li>了解并维护它的各个同事。</li></ol><p>Colleague class</p><ol><li>每一个同事类都知道它的中介对象。</li><li>每一个同事对象在需与其他的同事通信的时候，与它的中介者通信。</li></ol><h4 id="4-5-4-协作"><a href="#4-5-4-协作" class="headerlink" title="4.5.4 协作"></a>4.5.4 协作</h4><ol><li>同事向一个中介者对象发送和接受请求。中介着在各同事间适当地转发请求以实现协作行为。</li></ol><h3 id="4-6-Memento-备忘录"><a href="#4-6-Memento-备忘录" class="headerlink" title="4.6 Memento(备忘录)"></a>4.6 Memento(备忘录)</h3><h4 id="4-6-1-类图"><a href="#4-6-1-类图" class="headerlink" title="4.6.1 类图"></a>4.6.1 类图</h4><p><img src="/images/《设计模式》读书笔记/备忘录类图.png" alt="备忘录类图"></p><h4 id="4-6-2-参与者"><a href="#4-6-2-参与者" class="headerlink" title="4.6.2 参与者"></a>4.6.2 参与者</h4><p>Memento</p><ol><li>备忘录存储原发器对象的内部状态。原发器根据需要决定备忘录存储原发器的哪些内部状态。</li><li>防止原发器以外的其他对象访问备忘录。备忘录实际上有两个接口，管理者(caretaker)只能看到备忘录的窄接口——它只能将备忘录传递给其他对象。相反，原发器能够看到一个宽接口，允许它访问返回到先前状态所需的所有数据。理想的情况是只允许生成本备忘录的那个原发器访问本备忘录的内部状态。</li></ol><p>Originator</p><ol><li>原发器创建一个备忘录，用以记录当前时刻它的内部状态。</li><li>使用备忘录恢复内部状态。</li></ol><p>CareTaker</p><ol><li>负责保存好备忘录。</li><li>不能对备忘录的内容进行操作或检查。</li></ol><h4 id="4-6-3-协作"><a href="#4-6-3-协作" class="headerlink" title="4.6.3 协作"></a>4.6.3 协作</h4><ol><li>管理器向原发器请求一个备忘录，保留一段时间后，将其送回给原发器。</li></ol><h4 id="4-6-4-时序图"><a href="#4-6-4-时序图" class="headerlink" title="4.6.4 时序图"></a>4.6.4 时序图</h4><p><img src="/images/《设计模式》读书笔记/备忘录时序图.png" alt="备忘录时序图"></p><h3 id="4-7-Observer-观察者"><a href="#4-7-Observer-观察者" class="headerlink" title="4.7 Observer(观察者)"></a>4.7 Observer(观察者)</h3><h4 id="4-7-1-类图"><a href="#4-7-1-类图" class="headerlink" title="4.7.1 类图"></a>4.7.1 类图</h4><p><img src="/images/《设计模式》读书笔记/观察者类图.png" alt="观察者类图"></p><h4 id="4-7-2-参与者"><a href="#4-7-2-参与者" class="headerlink" title="4.7.2 参与者"></a>4.7.2 参与者</h4><p>Subject</p><ol><li>目标知道它的观察者。可以有任意多个观察者观察同一目标。</li><li>提供注册和删除观察者对象的接口。</li></ol><p>Observer</p><ol><li>为那些在目标发生改变时需获得通知的对象定义一个更新接口。</li></ol><p>ConcreteSubject</p><ol><li>将有关状态存入各ConcreteObserver对象。</li><li>当它的状态发生改变时，向它的各个观察者发出通知。</li></ol><p>ConcreteObserver</p><ol><li>维护一个指向ConcreteSubject对象的引用。</li><li>存储有关状态，这些状态应与目标的状态保持一致。<br>实现Observer的更新接口以使自身状态与目标的状态保持一致。</li></ol><h4 id="4-7-3-协作"><a href="#4-7-3-协作" class="headerlink" title="4.7.3 协作"></a>4.7.3 协作</h4><ol><li>当ConcreteSubject发生任何可能导致其观察者与本身状态不一致的改变时，它将通知它的各个观察者。</li><li>在得到一个具体目标的改变通知后，ConcreteObserver对象可向目标对象查询信息。ConcreteObserver使用这些信息以使它的状态与目标对象的状态一致。</li></ol><h4 id="4-7-4-时序图"><a href="#4-7-4-时序图" class="headerlink" title="4.7.4 时序图"></a>4.7.4 时序图</h4><p><img src="/images/《设计模式》读书笔记/观察者时序图.png" alt="观察者时序图"></p><h3 id="4-8-State-状态"><a href="#4-8-State-状态" class="headerlink" title="4.8 State(状态)"></a>4.8 State(状态)</h3><h4 id="4-8-1-类图"><a href="#4-8-1-类图" class="headerlink" title="4.8.1 类图"></a>4.8.1 类图</h4><p><img src="/images/《设计模式》读书笔记/状态类图.png" alt="状态类图"></p><h4 id="4-8-2-参与者"><a href="#4-8-2-参与者" class="headerlink" title="4.8.2 参与者"></a>4.8.2 参与者</h4><p>Context</p><ol><li>定义客户感兴趣的接口。</li><li>维护一个ConcreteState子类的实例，这个实例定义当前状态。</li></ol><p>State</p><ol><li>定义一个接口以封装与Context的一个特定状态相关的行为。</li></ol><p>ConcreteState subclasses</p><ol><li>每一子类实现一个与Context的一个状态相关的行为。</li></ol><h4 id="4-8-3-协作"><a href="#4-8-3-协作" class="headerlink" title="4.8.3 协作"></a>4.8.3 协作</h4><ol><li>Context将与状态相关的请求委托给当前的ConcreteState对象处理。</li><li>Context可将自身作为一个参数传递给处理该请求的状态对象。这使得状态对象在必要时可访问Context。</li><li>Context是客户使用的主要接口。客户可用状态对象来配置一个Context，一旦一个Context配置完毕，它的客户不再需要直接与状态对象打交道。</li><li>Context或ConcreteState子类都可决定哪个状态是另外哪一个的后继者，以及是在何种条件下进行状态转换。</li></ol><h3 id="4-9-Strategy-策略"><a href="#4-9-Strategy-策略" class="headerlink" title="4.9 Strategy(策略)"></a>4.9 Strategy(策略)</h3><h4 id="4-9-1-类图"><a href="#4-9-1-类图" class="headerlink" title="4.9.1 类图"></a>4.9.1 类图</h4><p><img src="/images/《设计模式》读书笔记/策略类图.png" alt="策略类图"></p><h4 id="4-9-2-参与者"><a href="#4-9-2-参与者" class="headerlink" title="4.9.2 参与者"></a>4.9.2 参与者</h4><p>Strategy</p><ol><li>定义所有支持的算法的公共接口。Context使用这个接口来调用某ConcreteStrategy定义的算法。</li></ol><p>ConcreteStrategy</p><ol><li>以Strategy接口实现某具体算法。</li></ol><p>Context</p><ol><li>用一个ConcreteStrategy对象来配置。</li><li>维护一个对Strategy对象的引用。</li><li>可定义一个接口来让Strategy访问它的数据。</li></ol><h4 id="4-9-3-协作"><a href="#4-9-3-协作" class="headerlink" title="4.9.3 协作"></a>4.9.3 协作</h4><ol><li>Strategy和Context相互作用以实现选定的算法。当算法被调用时，Context可以将该算法所需要的所有数据都传递给该Strategy。或者，Context可以将自身作为一个参数传递给Strategy操作。这就让Strategy在需要时可以回调Context。</li><li>Context将它的客户的请求转发给它的Strategy。客户通常创建并传递一个ConcreteStrategy对象给该Context；这样，客户仅与Context交互。通常有一系列的ConcreteStrategy类可供客户从中选择。</li></ol><h3 id="4-10-Template-Method-模板方法"><a href="#4-10-Template-Method-模板方法" class="headerlink" title="4.10 Template Method(模板方法)"></a>4.10 Template Method(模板方法)</h3><h4 id="4-10-1-类图"><a href="#4-10-1-类图" class="headerlink" title="4.10.1 类图"></a>4.10.1 类图</h4><p><img src="/images/《设计模式》读书笔记/模板方法类图.png" alt="模板方法类图"></p><h4 id="4-10-2-参与者"><a href="#4-10-2-参与者" class="headerlink" title="4.10.2 参与者"></a>4.10.2 参与者</h4><p>AbstractClass</p><ol><li>定义抽象的原语操作(primitive operation)，具体的子类将重定义它们以实现一个算法的各个步骤。</li><li>实现一个模板方法，定义一个算法骨架。该模板方法不仅调用原语操作，也调用定义在AbstractClass或其他对象中的操作。</li></ol><p>ConcreteClass</p><ol><li>实现原语操作以完成算法中与特定子类相关的步骤。</li></ol><h4 id="4-10-3-协作"><a href="#4-10-3-协作" class="headerlink" title="4.10.3 协作"></a>4.10.3 协作</h4><ol><li>ConcreteClass靠AbstractClass来实现算法中不变的步骤。</li></ol><h3 id="4-11-Visitor-访问者"><a href="#4-11-Visitor-访问者" class="headerlink" title="4.11 Visitor(访问者)"></a>4.11 Visitor(访问者)</h3><h4 id="4-11-1-类图"><a href="#4-11-1-类图" class="headerlink" title="4.11.1 类图"></a>4.11.1 类图</h4><p><img src="/images/《设计模式》读书笔记/访问者类图.png" alt="访问者类图"></p><h4 id="4-11-2-参与者"><a href="#4-11-2-参与者" class="headerlink" title="4.11.2 参与者"></a>4.11.2 参与者</h4><p>Visitor</p><ol><li>为该对象结构中ConcreteElement的每一个类声明一个Visit操作。该操作的名字和特征标识了发送Visit请求给该访问者的那个类。这使得访问者可以确定正被访问元素的具体的类。这样访问者就可以通过该元素的特定接口直接访问它。</li></ol><p>ConcreteVisitor</p><ol><li>实现每个由Visitor声明的操作。每个操作实现本算法的一部分，而该算法片段乃是对应于结构中对象的类。ConcreteVisitor为该算法提供了上下文并存储它的局部状态。这一状态常常在遍历该结构的过程中累计结果。</li></ol><p>Element</p><ol><li>定义一个Accept操作，它以一个访问者为参数。</li></ol><p>ConcreteElement</p><ol><li>实现Accept操作，该操作以一个访问者为参数。</li></ol><p>ObjectStructure</p><ol><li>能枚举它的元素。</li><li>可以提供一个高层的接口以允许该访问者访问它的元素。</li><li>可以是一个复合或是一个集合，如一个列表或一个无序集合。</li></ol><h4 id="4-11-3-协作"><a href="#4-11-3-协作" class="headerlink" title="4.11.3 协作"></a>4.11.3 协作</h4><ol><li>一个使用Visitor模式的客户必须创建一个ConcreteVisitor对象，然后遍历该对象结构，并用该访问者访问每一个元素。</li><li>当一个元素被访问是，它调用对应于它的类的Visitor操作。如果必要，该元素将自身作为这个操作的一个参数以便访问者访问它的状态。</li></ol><h4 id="4-11-4-时序图"><a href="#4-11-4-时序图" class="headerlink" title="4.11.4 时序图"></a>4.11.4 时序图</h4><p><img src="/images/《设计模式》读书笔记/访问者时序图.png" alt="访问者时序图"></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下打包程序生成自解压自运行文件</title>
      <link href="linux-xia-da-bao-cheng-xu-sheng-cheng-zi-jie-ya-zi-yun-xing-wen-jian/"/>
      <url>linux-xia-da-bao-cheng-xu-sheng-cheng-zi-jie-ya-zi-yun-xing-wen-jian/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/usr/bin/env bash</span><span class="token comment"># Program:</span><span class="token comment">#   打包程序生成自解压自运行文件</span><span class="token comment"># History:</span><span class="token comment">#   2020/03/25  [KibaAmor](https://kibazen.cn)    Create this file</span><span class="token comment"># 遇到错误时退出</span><span class="token builtin class-name">set</span> -e<span class="token comment"># 配置</span><span class="token comment">#################################################################</span><span class="token comment"># 打包后可执行文件的名字</span><span class="token assign-left variable">PACKAGE_NAME</span><span class="token operator">=</span><span class="token string">"server.run"</span><span class="token comment"># 需要被打包程序的目录名(不要包含路径)</span><span class="token assign-left variable">TARGET_DIR</span><span class="token operator">=</span>server<span class="token comment"># 被打包程序的可执行程序</span><span class="token assign-left variable">EXEC_NAME</span><span class="token operator">=</span><span class="token string">"run.sh"</span><span class="token comment"># 开始生成自解压的可执行程序</span><span class="token comment">#################################################################</span><span class="token comment"># 创建自解压脚本</span><span class="token function">cat</span> <span class="token operator">&gt;</span> <span class="token variable">${PACKAGE_NAME}</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'END'#!/usr/bin/env bash# Program:#   打包目录'TARGET_DIR'生成自解压自运行的可执行文件# History:#   CURRENT_DATETIME  [KibaAmor](https://kibazen.cn)    Create this file# 遇到错误时退出set -e# 解压目录必须不存在test -e TARGET_DIR &amp;&amp; echo "'TARGET_DIR' already exist. Remove?" &amp;&amp;  rm -Ir TARGET_DIRtest -e TARGET_DIR &amp;&amp; echo "'TARGET_DIR' is still exist. please remove manual" &amp;&amp; exit -1# 生成一个空的，用于解压文件的目录mkdir TARGET_DIR# 定位程序压缩后二进制数据在脚本中的位置BIN_LINE_NUM=$(awk '/^__LAST_LINE__/ { print NR+1; exit 0; }' $0)# 解压被打包的程序tail -n +${BIN_LINE_NUM} $0 | tar -xz -C TARGET_DIR --strip-components=1# 进入目录cd TARGET_DIR# 赋予可执行权限chmod +x ./EXEC_NAME# 开始执行被打包的程序./EXEC_NAME $*# 正常退出exit 0__LAST_LINE__END</span><span class="token assign-left variable">CURRENT_DATETIME</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">date</span> +<span class="token string">'%Y/%m/%d %H:%M:%S'</span><span class="token variable">)</span></span><span class="token comment"># 替换自解压脚本中的变量</span><span class="token function">sed</span> -i <span class="token string">"s/TARGET_DIR/<span class="token variable">${TARGET_DIR}</span>/g"</span> <span class="token variable">${PACKAGE_NAME}</span><span class="token function">sed</span> -i <span class="token string">"s/EXEC_NAME/<span class="token variable">${EXEC_NAME}</span>/g"</span> <span class="token variable">${PACKAGE_NAME}</span><span class="token function">sed</span> -i <span class="token string">"s@CURRENT_DATETIME@<span class="token variable"><span class="token variable">$(</span><span class="token function">date</span> +<span class="token string">'%Y/%m/%d %H:%M:%S'</span><span class="token variable">)</span></span>@g"</span> <span class="token variable">${PACKAGE_NAME}</span><span class="token comment"># 将打包的程序压缩，并将压缩后的二进制数据附加到自解压脚本后面</span><span class="token function">tar</span> c <span class="token variable">${TARGET_DIR}</span> <span class="token operator">|</span> <span class="token function">gzip</span> -f <span class="token operator">&gt;&gt;</span> <span class="token variable">${PACKAGE_NAME}</span><span class="token comment"># 给自解压脚本执行权限</span><span class="token function">chmod</span> +x <span class="token variable">${PACKAGE_NAME}</span><span class="token comment"># 输出信息</span><span class="token builtin class-name">echo</span> <span class="token string">"打包成功. 打包后的文件为：<span class="token variable">${PACKAGE_NAME}</span>"</span><span class="token comment"># 正常退出</span><span class="token builtin class-name">exit</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何正确的学习设计模式</title>
      <link href="ru-he-zheng-que-de-xue-xi-she-ji-mo-shi/"/>
      <url>ru-he-zheng-que-de-xue-xi-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、编程初期遇到的问题"><a href="#一、编程初期遇到的问题" class="headerlink" title="一、编程初期遇到的问题"></a>一、编程初期遇到的问题</h2><p>初学编程时，写的代码基本上都编程作业，ACM之类的，代码量一般都不多，几百行，少有上千行。所以，初读设计模式相关书籍时，只是觉得很厉害，并没有切实的体会到使用设计模式带来的好处。随着写的程序代码量逐渐增多，发现代码的逻辑越来越混乱，实现的功能BUG也越来越多。</p><p>在编程的过程中，也接触到了很多优秀的代码库，比如：<a href="https://www.ogre3d.org/">OGRE(Open-source Graphics Rendering Engines)</a>，一个优秀同时也是开源的3D图形图像渲染引擎。在学习使用的过程中，发现其代码逻辑清晰，便于阅读。对比自己写的代码和<a href="https://www.ogre3d.org/">OGRE</a>的代码，发现OGRE的代码中使用了很多的设计模式。所有就简单的认为：</p><blockquote><p>使用设计模式就能让代码组织更加简单，让代码的逻辑也更加清晰明了，同时大大的提高了代码的可读性，降低了程序出BUG的几率。</p></blockquote><h2 id="二、对设计模式错误的认识"><a href="#二、对设计模式错误的认识" class="headerlink" title="二、对设计模式错误的认识"></a>二、对设计模式错误的认识</h2><p>有了上面的结论，认为只要学会了所有的设计模式，就能够提高编程的能力。但是在背完所有的设计模式后发现：</p><ul><li><code>不知道什么时候该用设计模式。</code> 设计模式确实很好，但是还是也不知道什么时候该用设计模式，因为平时的编程中不用设计模式，功能也能实现出来。</li><li><code>套用了设计模式后代码质量也没提升。</code> 即使在编程的过程中，刻意的使用了一些设计模式，也没体会到设计模式带来的好处，更没有体会到想象中代码质量会立竿见影的提高。</li></ul><p>伴随着对设计模式使用的疑问，阅读了更多的书籍。当读到《重构：改善既有代码的设计》这本书时，按照书中的指导，重构了已有的代码，发现修改后的代码，阅读起来更加的容易，代码逻辑也比修改之前更加清晰。再对比修改前后的代码，发现：</p><ul><li><code>如果有多个地方都需要完成相同的功能，应该把代码封装成一个单独的函数，而不是复制粘贴。</code> 因为复制粘贴后，代码多了，改起来容易漏，也就容易出问题了，同时代码也变得难读。</li><li><code>如果一个函数或者一个类的代码有很多，通常更容易出BUG。</code> 如果一个函数或者一个类里面的代码有很多的话，读起来逻辑复杂，做的事情也多，就老是容易出问题。</li></ul><p>其他的细节还有很多。比如，如果注释都说不清楚一段代码在干什么，那么这段代码常常更容易出问题。</p><p>再次读<a href="https://www.ogre3d.org/">OGRE</a>的源代码时就发现，整个源代码在这些细节上都做的很好。比如：一个函数只做一件事，而且从函数的名字里就能知道具体做的什么。而源代码中使用的设计模式更是巧妙的让一个复杂的功能变得简单好理解。</p><h2 id="三、认识软件工程"><a href="#三、认识软件工程" class="headerlink" title="三、认识软件工程"></a>三、认识软件工程</h2><p>阅读书籍过程中也多次接触到了<code>软件工程</code>这个术语，但是一直不是很明白<code>软件工程</code>具体是做什么的，直到读到了《敏捷软件开发》这本书。<code>软件工程是一门研究用工程化方法构建和维护有效的、实用的和高质量的软件的学科。</code>而《敏捷软件开发》这本书正是讲述如何实践软件工程的经典巨著。理解一下，<code>软件工程</code>就是一门学习研究写出高质量软件(代码)的学科。而《敏捷软件开发》则是介绍具体用某种方法来实现写出高质量软件目的的书。</p><p>《敏捷软件开发》这本书中提出了<code>敏捷设计</code>这一方法，并将其定义为：</p><blockquote><p>敏捷设计是一个持续的应用原则、模式以及实现来改进软件的结构和可读性的过程。它是一个过程，不是一个事件。</p></blockquote><p>它认为，只要在编写代码实现软件时，遵守一些软件开发原则和模式，那么就能够提高代码的质量。</p><h2 id="四、了解敏捷开发的原则"><a href="#四、了解敏捷开发的原则" class="headerlink" title="四、了解敏捷开发的原则"></a>四、了解敏捷开发的原则</h2><p>《敏捷软件开发》着重介绍并解释了5种软件开发原则。分别是：</p><ol><li><code>单一职责原则(SRP)</code>：就一个类而言，应该仅有一个引起它变化的原因。</li><li><code>开放-封闭原则(OCP)</code>：软件实体（类、模块、函数等等）应该是可以扩展的，但是不可修改的。</li><li><code>里氏替换原则(LSP)</code>：子类型(subtype)必须能够替换掉它们的基类型(base type)。</li><li><code>依赖倒置原则(DIP)</code>：高层模块不应该依赖于低层模块。二者都应该依赖于抽象。抽象不应该依赖于细节。细节应该依赖于抽象。</li><li><code>接口隔离原则(ISP)</code>：不应该强迫客户依赖于它们不用的方法。</li></ol><p>与其说是<code>原则</code>，不如说是<code>标准</code>。因为它们告诉了我们一个标准：应该把代码设计成一个什么样子，满足什么条件，有什么特征，但是并没有说应该如何编写代码。</p><p>此时，再回过头阅读<a href="https://www.ogre3d.org/">OGRE</a>等优秀的代码库时才明白，这些代码库优秀的原因之一是它们遵循了良好的软件开发原则，而使用设计模式则是让代码遵循这些软件开发原则的方法。这也是初学设计模式时，生搬硬套设计模式并没有改善代码质量的根本原因。因为根本就不知道应该把代码改成什么样，需要满足什么要求。结果就是把劣质的代码换一种方式写出来而已。</p><p>所以，我们能够得出一个结论，那就是：</p><blockquote><p>优秀的软件由高质量的代码编写而成，而遵从软件开发原则是代码成为高质量代码的条件之一，设计模式只是让代码遵从开发原则的方法。</p></blockquote><h2 id="五、正确的学习设计模式"><a href="#五、正确的学习设计模式" class="headerlink" title="五、正确的学习设计模式"></a>五、正确的学习设计模式</h2><p>最后，如何正确的学习设计模式呢？</p><ol><li>发现自己写的代码越来越复杂，BUG越来越多。</li><li>寻求提高代码质量的方法。</li><li>学习软件工程。<code>认识到别人代码质量高的原因之一是因为别人遵循了良好软件开发原则。</code></li><li>开始真正的学习并运用设计模式。</li><li>最后，明白了什么时候应该怎么用设计模式，更清楚了软件工程的重要性。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全局唯一ID生成方法总结</title>
      <link href="quan-ju-wei-yi-id-sheng-cheng-fang-fa-zong-jie/"/>
      <url>quan-ju-wei-yi-id-sheng-cheng-fang-fa-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么情况下需要全局唯一ID"><a href="#一、什么情况下需要全局唯一ID" class="headerlink" title="一、什么情况下需要全局唯一ID"></a>一、什么情况下需要全局唯一ID</h2><p>在一个由多个服务器组成的业务系统中，有很多对象都需要一个ID来标识该对象，以示区分。这个ID应该是系统(全局)范围内唯一的，这种ID就是<code>全局唯一ID(GUID，Globally Unique Identifier)</code>。比如：购物商城中的用户ID和订单ID就应该是<code>全局唯一ID</code>。</p><h2 id="二、生成全局唯一ID要求"><a href="#二、生成全局唯一ID要求" class="headerlink" title="二、生成全局唯一ID要求"></a>二、生成全局唯一ID要求</h2><p>既然要使用<code>全局唯一ID</code>，那么就需要先生成<code>全局唯一ID</code>。生成时主要考虑以下面几点：</p><ol><li><code>全系统范围内唯一。</code> 显而易见，全局唯一ID肯定应该是全系统唯一不重复的。</li><li><code>ID易于存储和比较。</code> <code>全局唯一ID</code>的占用空间应该尽量的小且便于比较。比如：类型为64位整形(int64)的<code>全局唯一ID</code>就明显比类型为字符串(string)的<code>全局唯一ID</code>更易于存储和比较，使用起来也更好用。</li><li><code>生成结果是有序递增(递减)的。</code> 一般会将生成后的<code>全局唯一ID</code>作为数据库的主键来存储该对象的信息。有序的主键在插入数据库时性能一般会更好。</li><li><code>生成结果不可预测。</code> 生成的结果应当是不能预测的。如果能够预测出下一个生成结果，基本上就能猜测出所有的生成结果，比如在一个订单系统中，就能获取到所有的订单信息，这在安全性上是难以接受的。</li><li><code>生成快速且稳定。</code> 在一个系统中，很有可能需要频繁的生成<code>全局唯一ID</code>，一旦生成的速度过慢甚至生成时卡顿，将导致整个系统的卡顿或者崩溃。所以，<code>全局唯一ID</code>的生成应当是快速且稳定的。</li></ol><h2 id="三、目前成熟的生成方法"><a href="#三、目前成熟的生成方法" class="headerlink" title="三、目前成熟的生成方法"></a>三、目前成熟的生成方法</h2><h3 id="1-数据库自增ID"><a href="#1-数据库自增ID" class="headerlink" title="1. 数据库自增ID"></a>1. 数据库自增ID</h3><p>很多数据库提供生成自增ID的功能，如MySQL提供了变量<code>auto_increment_offset</code>来设置自增的初始值，变量<code>auto_increment_increment</code>设置每次自增的步长。借助数据库提供的这个功能，我们就能简单的实现生成<code>全局唯一ID</code>的功能了。</p><p>这种方式的优点很明显，那就是简单。不需要开发一个单独的系统，也不需要专人去维护。<br>但是缺点也是很明显的：</p><ol><li><code>生成性能不够好。</code> 每次生成<code>全局唯一ID</code>都需要通过网络访问数据库一次，生成时间可能达到几十上百毫秒。而且在数据库内部生成自增ID时，常常还会加锁，多个地方同时生成<code>全局唯一ID</code>时，还需要竞争抢锁。并发性能也就不好。</li><li><code>稳定性不够好。</code> 使用数据库来生成<code>全局唯一ID</code>方法的特点就是所有需要生成<code>全局唯一ID</code>的业务都需要连接相同的数据库，压力集中于一点。一旦数据库崩溃，将不能生成<code>全局唯一ID</code>，这会严重影响使用<code>全局唯一ID</code>的业务系统。即使数据库采用了主从结构，也难以保证在主从数据库切换时，生成的<code>全局唯一ID</code>不重复。</li><li><code>生成结果可以预测。</code> 一旦确定了自增初始值和自增步长后，基本上不会再动态修改这两个值，那么根据这两个值生成出来的ID也就是可预测的了。</li></ol><p>虽然使用数据库来生成<code>全局唯一ID</code>有上面的种种缺点，但是可以通过一些方法来改善这些问题：</p><h4 id="A-Flickr的分布式唯一主键生成算法"><a href="#A-Flickr的分布式唯一主键生成算法" class="headerlink" title="A. Flickr的分布式唯一主键生成算法"></a>A. Flickr的<a href="https://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/">分布式唯一主键生成算法</a></h4><p>针对使用数据库生成<code>全局唯一ID</code>性能不好的问题，Flickr提供了这样的解决方案：</p><blockquote><p>部署多台数据库，每台数据库设置不同的自增初始值，相同的自增步长值。同时自增步长值必须大于等于数据库的数量。这样就能保证每台数据都能生成<code>全局唯一ID</code>，且所有生成的<code>全局唯一ID</code>都不重复。</p></blockquote><p>举例，比如部署了两台数据库，其自增初始值，自增步长值及结果分别如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">数据库</th><th style="text-align:center">自增初始值</th><th style="text-align:center">自增步长值</th><th style="text-align:center">生成结果</th></tr></thead><tbody><tr><td style="text-align:center">数据库A</td><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">0,2,4,6,8…</td></tr><tr><td style="text-align:center">数据库B</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1,3,5,7,9…</td></tr></tbody></table></div><p>实际使用此方案时生成的<code>全局唯一ID</code>可能不是上面这种连续的结果，MySQL的下个自增ID的实际计算公式是<code>INT(current_value / increment) x increment + offset</code>，具体的可以参考<a href="https://stackoverflow.com/questions/35766521/mysql-master-master-replication-causing-missing-autoincrement-values/">MySql Master-Master Replication Causing Missing AutoIncrement Values</a>。</p><p>Flickr<a href="https://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/">分布式唯一主键生成算法</a>的核心思想是：</p><blockquote><p>分散单点数据库的压力到了多点数据库，从而在提升了生成的性能和稳定性。</p></blockquote><p>但是这种方法中有一个很大的弊端，那就是因为要提前的确定自增的步长，所以扩展性很差。</p><h4 id="B-美团的Leaf-segment算法"><a href="#B-美团的Leaf-segment算法" class="headerlink" title="B. 美团的Leaf-segment算法"></a>B. 美团的<a href="https://tech.meituan.com/2017/04/21/mt-leaf.html">Leaf-segment算法</a></h4><p>同样是针对使用数据库生成<code>全局唯一ID</code>性能不好的问题，美团提供的解决方案是：</p><blockquote><p>不同的业务使用不同的自增ID。同一个业务一次获取多个<code>全局唯一ID</code>，缓存起来慢慢使用。同时在要用完时前就再次异步获取新的<code>全局唯一ID</code>缓存起来备用，就能为业务提供持续不断的<code>全局唯一ID</code>生成功能。</p></blockquote><p>举例，系统中有用户和订单都需要使用<code>全局唯一ID</code>来标识。那么数据库中就分别为用户和订单使用不同的自增ID。每次获取10000个<code>全局唯一ID</code>。并规定当前消耗10%的<code>全局唯一ID</code>就马上异步的获取下一批并将结果缓存起来备用。</p><div class="table-container"><table><thead><tr><th style="text-align:center">自增ID</th><th style="text-align:center">自增初始值</th><th style="text-align:center">自增步长值</th><th style="text-align:center">生成结果</th></tr></thead><tbody><tr><td style="text-align:center">用户</td><td style="text-align:center">0</td><td style="text-align:center">10000</td><td style="text-align:center">0,10000,20000…</td></tr><tr><td style="text-align:center">订单</td><td style="text-align:center">0</td><td style="text-align:center">10000</td><td style="text-align:center">0,10000,20000…</td></tr></tbody></table></div><p>美团<a href="https://tech.meituan.com/2017/04/21/mt-leaf.html">Leaf-segment算法</a>的核心思想是：批量获取和提前缓存。</p><ul><li>批量获取的同时，也减少请求数据库的次数，也就降低了数据库的压力。</li><li>而提前缓存则是保证了即使在网络波动时和业务高峰时都能够持续不阻塞的生成<code>全局唯一ID</code>。</li></ul><h3 id="2-UUID算法"><a href="#2-UUID算法" class="headerlink" title="2. UUID算法"></a>2. UUID算法</h3><p>UUID的全称是Universally Unique Identifier，中文名为通用唯一识别码。</p><p>UUID包含32个16进制的数字，大小是16字节128为，一般以连字号分为五段，形式为8-4-4-4-12的36个字符，比如：12fae663-e3dd-4b9e-b1a9-b7e598d2f853。具体的细节可以参考UUID的IETF标准<a href="https://www.ietf.org/rfc/rfc4122.txt">A Universally Unique IDentifier (UUID) URN Namespace</a>。</p><p>UUID生成的算法主要有5种，都不需要联网，本地即可生成。所以，使用UUID算法生成<code>全局唯一ID</code>的优点是很明显的，那就是：<code>高性能且难于预测结果</code>。但是缺点也很明显：</p><ol><li><code>UUID不易存储和使用。</code> 目前的主流编程语言和数据库，最大支持64位的整数。128位的UUID难以原生的以整数方式存储和使用。</li><li><code>UUID不是有序递增(递减)的。</code> UUID算法生成出来的ID一般不是有序的，这对将UUID作为主键存入数据库的使用方式来说并不友好。</li></ol><p>基于上面的缺点，UUID很少作为<code>全局唯一ID</code>来使用。</p><h3 id="3-字节-位-分段算法"><a href="#3-字节-位-分段算法" class="headerlink" title="3. 字节(位)分段算法"></a>3. 字节(位)分段算法</h3><p>这种算法的思想其实来自Twitter的<a href="https://github.com/twitter-archive/snowflake">雪花算法</a>，其他的同类算法都是在此基础上的一些变种。算法核心是：</p><blockquote><p>将组成<code>全局唯一ID</code>的多个字节看做一个整体，并其划分成不同的段，分别控制不同段的值。</p></blockquote><p>该算法具有与UUID算法相同的好处，那就是都不需要联网，本地即可生成。除此之外，还支持多个服务器同时生成，且生成的结果总体的保持递增或递减。在控制字节大小的情况下，也能较好的存储和比较。</p><h4 id="A-Twitter的雪花算法"><a href="#A-Twitter的雪花算法" class="headerlink" title="A. Twitter的雪花算法"></a>A. Twitter的<a href="https://github.com/twitter-archive/snowflake">雪花算法</a></h4><p>该算法生成的<code>全局唯一ID</code>的大小为64字节，能够使用64位整型来存储。其格式为：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+------------------------------------------------------------------------------------+| UNUSED(1BIT) |     TIMESTAMP(41BIT)     |  MACHINE-ID(10BIT)  |   SERIAL-NO(12BIT) |+------------------------------------------------------------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中：</p><ul><li><code>1位不用。</code> 最高位不用，固定为0。因为二进制中最高位为1的表示是负数，而我们一般整数来表示ID，不希望有负数的ID，所以不用。</li><li><code>41位的时间戳。</code> 用41位的空间来表示单位为毫秒的时间戳，大约可以表示<code>(1L &lt;&lt; 41) /（1000 * 60 * 60 * 24 * 365）= 69</code>年的时间。</li><li><code>10位的机器位。</code> 用来区分不同服务器生成出来的ID。10位空间最多可以表示(1L &lt;&lt; 10) = 1024台服务器。</li><li><code>12位的序列化。</code> 用12位空间来存储在同一毫秒内，同一台服务器生成出来的ID数量。最多可以存储(1L &lt;&lt; 12) = 4096个。</li></ul><p>使用Twitter的<a href="https://github.com/twitter-archive/snowflake">雪花算法</a>只有一个明显的缺点，就是：</p><blockquote><p>算法高度依赖时间戳，如果各个生成ID的服务器时间不同步，将会导致生成出来的ID是乱序或者重复的。</p></blockquote><h4 id="B-百度的UidGenerator算法"><a href="#B-百度的UidGenerator算法" class="headerlink" title="B. 百度的UidGenerator算法"></a>B. 百度的<a href="https://github.com/baidu/uid-generator">UidGenerator算法</a></h4><p>百度<a href="https://github.com/baidu/uid-generator">UidGenerator算法</a>与Twitter<a href="https://github.com/twitter-archive/snowflake">雪花算法</a>的主要区别在于调整了各个分段的大小，改变了各个分度的意义，本质没变。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+-------------------------------------------------------------------------------------+| UNUSED(1BIT) |  DELTA SECONDS(28BIT)  |  WORKER-NODE-ID(22BIT)  |  SERIAL-NO(13BIT) |+-------------------------------------------------------------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>1位不用。</code> 最高位依旧不用，固定为0。</li><li><code>28位的时间差。</code> 表示当前时间相对与”2016-05-20”的差值，单位为秒。最多可支持约8.7年。</li><li><code>22位的机器位。</code> 表示机器ID。每次机器重启后都废弃重新从数据库申请，最多可支持约420w次机器启动。</li><li><code>13位的序列化。</code> 每秒下的并发序列，可支持每秒8192个并发。</li></ul><h4 id="C-美团的Leaf-snowflake算法"><a href="#C-美团的Leaf-snowflake算法" class="headerlink" title="C. 美团的Leaf-snowflake算法"></a>C. 美团的<a href="https://tech.meituan.com/2017/04/21/mt-leaf.html">Leaf-snowflake算法</a></h4><p>美团<a href="https://tech.meituan.com/2017/04/21/mt-leaf.html">Leaf-snowflake算法</a>沿用了Twitter<a href="https://github.com/twitter-archive/snowflake">雪花算法</a>各个字段的意义，但是扩展了算法的使用方式，提高了算法的易用性和在时钟乱序时的容错性。</p><h5 id="提升算法的易用性"><a href="#提升算法的易用性" class="headerlink" title="提升算法的易用性"></a>提升算法的易用性</h5><p>在生成<code>全局唯一ID</code>的服务器集群中加入了Zookeeper。每次服务器启动时都去ZooKeeper读取(不存在时则注册)自己的用于生成<code>全局唯一ID</code>时的服务器ID值。因为服务器ID一般不会变，所以可以将这个值缓存起来，即使以后遇到连接ZooKeeper时，也能正常的启动服务器，并提供生成ID的服务。</p><h5 id="提升时钟乱序时的容错性"><a href="#提升时钟乱序时的容错性" class="headerlink" title="提升时钟乱序时的容错性"></a>提升时钟乱序时的容错性</h5><p>服务器会在启动时判断时钟发生是否发生了回拨，具体细节如下：</p><ul><li>如果服务器启动时，Zookeeper无此服务器的时间记录，那么就判断当前服务器的时间和其他的运行<a href="https://tech.meituan.com/2017/04/21/mt-leaf.html">Leaf-snowflake算法</a>服务器的时间的平均值(通过RPC获取)之间的差值，如果差值大于某个阈值，认为本机系统时间发生大步长偏移，启动失败并报警。</li><li>如果服务器启动时，Zookeeper已经有此服务器的时间记录，且当前服务器的时间小于记录的时间，那么就认为服务器时间发生了大步长回拨，服务启动失败并报警。</li><li>服务器正常启动后，定时(如每隔3秒)的向Zookeeper记录本服务器当前时间。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>负载均衡简介</title>
      <link href="fu-zai-jun-heng-jian-jie/"/>
      <url>fu-zai-jun-heng-jian-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="一、为什么需要负载均衡"><a href="#一、为什么需要负载均衡" class="headerlink" title="一、为什么需要负载均衡"></a>一、为什么需要负载均衡</h2><p>随着业务的发展，业务的流量也越来越大，以前单台服务器提供的服务，无论如何优化，都不能满足现有业务的需求。这时，就需要将业务流量分摊到多个不同的服务器上来减少单个服务器的压力。而<code>负载均衡(Load Balance)</code>就是用来将业务流量分发到不用的服务器上面的。</p><h2 id="二、什么是负载均衡"><a href="#二、什么是负载均衡" class="headerlink" title="二、什么是负载均衡"></a>二、什么是负载均衡</h2><pre class="line-numbers language-text" data-language="text"><code class="language-text">+---------------------------------------------------------------------------+|                                                                           ||                                                             +----------+  ||                                                             |          |  ||                                              +------------&gt; |  Server  |  ||                                              |              |          |  ||                                              |              +----------+  ||                                              |                            ||  +----------+         +----------------+     |              +----------+  ||  |          |         |                |     |              |          |  ||  |  Client  | +-----&gt; |  Load Balance  | +----------------&gt; |  Server  |  ||  |          |         |                |     |              |          |  ||  +----------+         +----------------+     |              +----------+  ||                                              |                            ||                                              |              +----------+  ||                                              |              |          |  ||                                              +------------&gt; |  Server  |  ||                                                             |          |  ||                                                             +----------+  ||                                                                           |+---------------------------------------------------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>负载均衡(软件或硬件)会将所有的客户端流量，通过特定的调度算法分发到不同的后端服务器上，同时还会监控后端服务器的压力和监控状态，以便在某些后端服务器压力过大或故障时，减少对该服务器的流量分发，从而保证了整个业务的稳定。</p><h2 id="三、利用DNS实现负载均衡"><a href="#三、利用DNS实现负载均衡" class="headerlink" title="三、利用DNS实现负载均衡"></a>三、利用DNS实现负载均衡</h2><p>早期解决单个服务器压力过大的方法之一是利用DNS将域名解析到不同的IP的方式来实现的。如：客户端在不同的地区解析相同的域名时，DNS解析出离客户端最近的服务器IP。这样，不同的客户端就连接到提供了相同服务但是机器不同的服务器。从而分散了服务器压力，同时也缩短服务响应时间。这也是CDN原理。</p><p>利用DNS来实现负载均衡好处有成本低，实现简单等。但是弊端也是很明显的：</p><ol><li><code>流量分发的不够均匀。</code> DNS在解析IP时，能够根据客户端地理位置来分发流量，但是没法根据后端服务器的实际压力来分发流量。这样就可能会出现一台服务器压力满载，而其他的服务器无压力的情况。</li><li><code>支持的分发策略少。</code>DNS一般只支持轮询方式来解析。大大的限制了使用场景。</li><li><code>服务器故障时切换延迟大。</code> 由于DNS服务器是多层，且各层服务器中有缓存，导致了DNS修改后不能立即生效。这种情况下，如果一个后端服务器崩溃停止服务器，即使我们立即修改DNS，部分的客户端也无法立即恢复服务。这会严重影响用户体验。</li><li><code>DNS劫持和缓存污染导致的安全问题。</code> 由于DNS存在被劫持和缓存被污染可能，这会导致域名解析出来的IP可能不是我们服务器的IP，从而会导致客户端连接到了错误的服务器，造成安全问题。</li></ol><p>所以严格来说，使用DNS只能算是分发流量，而不能算作真正的负载均衡。</p><blockquote><p>Tips:</p><ol><li><code>DNS劫持:</code> DNS服务器被控制，查询DNS时，服务器直接返回给你它想让你看的信息。</li><li><code>DNS缓存污染:</code> 黑客通过技术手段使用户查询到虚假解析信息。</li></ol></blockquote><h2 id="四、基于OSI分层分类的负载均衡"><a href="#四、基于OSI分层分类的负载均衡" class="headerlink" title="四、基于OSI分层分类的负载均衡"></a>四、基于OSI分层分类的负载均衡</h2><div class="table-container"><table><thead><tr><th style="text-align:center">层级</th><th style="text-align:center">OSI参考模型</th><th style="text-align:center">各层解释</th></tr></thead><tbody><tr><td style="text-align:center">7</td><td style="text-align:center">应用层(Application)</td><td style="text-align:center">提供网络与用户应用软件之间的接口服务</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">表达层(Presentation)</td><td style="text-align:center">提供格式化的表示和转换数据服务，如加密和压缩</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">会话层(Session)</td><td style="text-align:center">提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">传输层(Transimission)</td><td style="text-align:center">提供建立、维护和取消传输连接功能，负责可靠地传输数据(PC)</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">网络层(Network)</td><td style="text-align:center">处理网络间路由，确保数据及时传送(路由器)</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">数据链路层(DataLink)</td><td style="text-align:center">负责无错传输数据，确认帧、发错重传等(交换机)</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">物理层(Physics)</td><td style="text-align:center">提供机械、电气、功能和过程特性(网卡、网线、双绞线、同轴电缆、中继器)</td></tr></tbody></table></div><p>参考OSI的七层模型，我们可以：</p><ol><li>在第二层(数据链路层)做基于MAC地址的<code>二层负载均衡</code>。通过一个虚拟MAC地址接收请求，然后再将数据转发到真实的MAC地址。</li><li>在第三层(网络层)做基于IP地址的<code>三层负载均衡</code>。通过一个虚拟IP地址接收请求，然后再将数据转发到真实的IP地址。</li><li>在第四层(传输层)做基于IP和端口的<code>四层负载均衡</code>。通过一个虚拟IP地址和端口接收请求，然后再将数据转发到真实的IP地址和端口。</li><li>在第七层(应用层)做基于应用层信息(如：URL)的<code>七层负载均衡</code>。通过一个虚拟的URL接收请求，然后再将数据转发到真实URL所在的服务器。</li></ol><p>常用的负载均衡有：<a href="#七层负载均衡">七层负载均衡</a>和<a href="#四层负载均衡">四层负载均衡</a>。</p><blockquote><p>Tips:</p><ol><li>DNS属于应用层的协议，所以<a href="#利用DNS实现负载均衡">利用DNS实现负载均衡</a>算是<a href="#七层负载均衡">七层负载均衡</a>。</li></ol></blockquote><h2 id="五、七层负载均衡"><a href="#五、七层负载均衡" class="headerlink" title="五、七层负载均衡"></a>五、七层负载均衡</h2><p><code>七层负载均衡</code>工作在OSI的第七层(传输层)，位于第四层(应用层)之上，所以需要完整的TCP/IP协议栈的实现，这也让负载均衡能够解析流量的内容。</p><p>客户端不能与直接与后端服务器建立传输层的连接(如TCP连接)，取而代之，客户端将直接与负载均衡建立连接，负载均衡解析完协议内容后，根据协议内容、流量分发策略和后端压力等信息选择一个后端服务器，并与服务器建立连接，然后将进行流量分发。所以，<code>七层负载均衡的主要工作就是代理。</code></p><p><code>七层负载均衡</code>的好处是显而易见的：</p><ol><li><code>可以查看修改流量内容。</code> 能够查看流量内容让负载均衡能够记录日志，方便进行大数据分析；也能够根据内容来做更加智能的流量分发；还能对明显非法的访问进行简单的过滤。能够修改流量让负载均衡能够添加额外的信息到流量中，为后端的业务处理提供更丰富的信息。</li><li><code>可以避免后端服务遭受传输层的流量攻击。</code> 因为客户端不再直接与后端服务器建立传输层的连接，后端服务器也就不会再受到可能的SYN Flood攻击。</li><li><code>无需特别的硬件就能实现。</code> 因为<code>七层负载均衡</code>工作在应用层，所以利用普通的软件即可实现。常用的软件有：Nginx、HAProxy等。</li></ol><p>同时也带来了一些不便：</p><ol><li><code>隐藏了客户端的连接信息。</code> 因为负载均衡取代了后端服务器与客户端建立连接。所以后端服务器<code>无法直接获取</code>真实的客户端IP信息等。但是可以通过修改流量的内容，将客户端的信息添加到流量中来避免此问题。</li><li><code>增加了排错的难度。</code> 增加七层负载的同时，也为将业务流程复杂化了，出错时也增加了排错的难度。</li></ol><p>所以，在使用<code>七层负载均衡</code>之前，需要综合考虑使用<code>七层负载均衡</code>能带来的好处以及不便。如果使用负载均衡的主要目的是分发流量，均衡后端压力，还可以考虑使用<a href="#四层负载均衡">四层负载均衡</a>。</p><h2 id="六、四层负载均衡"><a href="#六、四层负载均衡" class="headerlink" title="六、四层负载均衡"></a>六、四层负载均衡</h2><p><code>四层负载均衡</code>工作在OSI的第四层(传输层)，不需要完整的TCP/IP协议栈的实现，所以也不能解析流量的内容。在这一点来说，效率比<code>七层负载均衡</code>更高。</p><p>负载均衡仅能根据流量中目标地址和端口，加上指定的流量分发策略等信息进行流量分发。客户端能够直接与后端服务器建立传输层的连接(如TCP连接)，此时负载均衡的作用类似于路由器转发报文，只是更加智能可控。所以，<code>四层负载均衡的主要工作就是转发。</code></p><p>使用<code>四层负载均衡</code>最明显的好处是在保持分发策略最大化可控的同时性能的最大化。因为<code>四层负载均衡</code>并不需要解析传输层的协议内容，相比与<code>七层负载均衡</code>来说，少了很多工作。</p><p>但是，使用<code>四层负载均衡</code>的缺点也是很明显的：</p><ol><li><code>成本高昂。</code> <code>四层负载均衡</code>大多基于硬件来实现，虽然也有软件实现的。</li><li><code>暴露了后端的服务器。</code> 这与不用负载均衡前的情况相同，后端服务器直接暴露给客户端。服务器遭受攻击时会直接影响业务。</li></ol><hr><p>参考</p><ul><li><a href="https://tech.meituan.com/2017/01/05/mgw.html">MGW——美团点评高性能四层负载均衡</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下Bash配置文件的执行顺序</title>
      <link href="linux-xia-bash-pei-zhi-wen-jian-de-zhi-xing-shun-xu/"/>
      <url>linux-xia-bash-pei-zhi-wen-jian-de-zhi-xing-shun-xu/</url>
      
        <content type="html"><![CDATA[<blockquote><p><em>翻译自<a href="https://linux.101hacks.com/bash-scripting/execution-sequence-of-bash-files/">Linux 101 Hacks: 84</a></em></p></blockquote><h2 id="下列文件的执行顺序是什么"><a href="#下列文件的执行顺序是什么" class="headerlink" title="下列文件的执行顺序是什么"></a>下列文件的执行顺序是什么</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/etc/profile~/.bash_profile~/.bashrc~/.bash_login~/.profile~/.bash_logout<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="交互式登录shell的执行顺序"><a href="#交互式登录shell的执行顺序" class="headerlink" title="交互式登录shell的执行顺序"></a>交互式登录shell的执行顺序</h2><p>下面的伪代码将说明这些文件的执行顺序</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">execute /etc/profileIF ~/.bash_profile exists THEN    execute ~/.bash_profileELSE    IF ~/.bash_login exist THEN        execute ~/.bash_login    ELSE        IF ~/.profile exist THEN            execute ~/.profile        END IF    END IFEND IF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当你从交互式shell中注销，以下是执行顺序：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">IF ~/.bash_logout exists THEN    execute ~/.bash_logoutEND IF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>请注意/etc/bashrc是通过~/.bashrc执行，如下所示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># cat ~/.bashrc</span>IF <span class="token punctuation">[</span> -f /etc/bashrc <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span><span class="token builtin class-name">.</span> /etc/bashrcFI<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="非登录交互式shell的执行顺序"><a href="#非登录交互式shell的执行顺序" class="headerlink" title="非登录交互式shell的执行顺序"></a>非登录交互式shell的执行顺序</h2><p>当你启动一个非登录交互式shell,下面是执行顺序</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">IF ~/.bashrc exists THEN    execute ~/.bashrcEND IF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>注意</code>：当一个非交互式shell启动，它会寻找环境变量ENV，并执行包含在环境变量ENV中的文件。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Boost编译选项备忘</title>
      <link href="boost-bian-yi-xuan-xiang-bei-wang/"/>
      <url>boost-bian-yi-xuan-xiang-bei-wang/</url>
      
        <content type="html"><![CDATA[<h2 id="初始化Boost"><a href="#初始化Boost" class="headerlink" title="初始化Boost"></a>初始化Boost</h2><p>进入boost所在的目录，执行下面的命令初始化boost</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Windows</span>./bootstrap.bat<span class="token comment"># Linux</span>./bootstrap.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="编译使用C-静态CRT的64位Boost静态库"><a href="#编译使用C-静态CRT的64位Boost静态库" class="headerlink" title="编译使用C++静态CRT的64位Boost静态库"></a>编译使用C++静态CRT的64位Boost静态库</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./b2.exe --prefix<span class="token operator">=</span>./install64_staticlib_staticrt --stagedir<span class="token operator">=</span>./stage64_staticlib_staticrt --build-dir<span class="token operator">=</span>./build64_staticlib_staticrt --build-type<span class="token operator">=</span>complete --layout<span class="token operator">=</span>versioned --buildid<span class="token operator">=</span>amd64 --without-mpi --without-graph --without-graph_parallel --without-python address-model<span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">variant</span><span class="token operator">=</span>debug,release <span class="token assign-left variable">threading</span><span class="token operator">=</span>multi <span class="token assign-left variable">link</span><span class="token operator">=</span>static runtime-link<span class="token operator">=</span>static -a -q -j16 <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成的文件列表如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">libboost_atomic-vc140-mt-s-1_59-amd64.liblibboost_atomic-vc140-mt-sgd-1_59-amd64.liblibboost_chrono-vc140-mt-s-1_59-amd64.liblibboost_chrono-vc140-mt-sgd-1_59-amd64.liblibboost_container-vc140-mt-s-1_59-amd64.liblibboost_container-vc140-mt-sgd-1_59-amd64.liblibboost_context-vc140-mt-s-1_59-amd64.liblibboost_context-vc140-mt-sgd-1_59-amd64.liblibboost_coroutine-vc140-mt-s-1_59-amd64.liblibboost_coroutine-vc140-mt-sgd-1_59-amd64.liblibboost_date_time-vc140-mt-s-1_59-amd64.liblibboost_date_time-vc140-mt-sgd-1_59-amd64.liblibboost_exception-vc140-mt-s-1_59-amd64.liblibboost_exception-vc140-mt-sgd-1_59-amd64.liblibboost_filesystem-vc140-mt-s-1_59-amd64.liblibboost_filesystem-vc140-mt-sgd-1_59-amd64.liblibboost_iostreams-vc140-mt-s-1_59-amd64.liblibboost_iostreams-vc140-mt-sgd-1_59-amd64.liblibboost_locale-vc140-mt-s-1_59-amd64.liblibboost_locale-vc140-mt-sgd-1_59-amd64.liblibboost_log-vc140-mt-s-1_59-amd64.liblibboost_log-vc140-mt-sgd-1_59-amd64.liblibboost_log_setup-vc140-mt-s-1_59-amd64.liblibboost_log_setup-vc140-mt-sgd-1_59-amd64.liblibboost_math_c99-vc140-mt-s-1_59-amd64.liblibboost_math_c99-vc140-mt-sgd-1_59-amd64.liblibboost_math_c99f-vc140-mt-s-1_59-amd64.liblibboost_math_c99f-vc140-mt-sgd-1_59-amd64.liblibboost_math_c99l-vc140-mt-s-1_59-amd64.liblibboost_math_c99l-vc140-mt-sgd-1_59-amd64.liblibboost_math_tr1-vc140-mt-s-1_59-amd64.liblibboost_math_tr1-vc140-mt-sgd-1_59-amd64.liblibboost_math_tr1f-vc140-mt-s-1_59-amd64.liblibboost_math_tr1f-vc140-mt-sgd-1_59-amd64.liblibboost_math_tr1l-vc140-mt-s-1_59-amd64.liblibboost_math_tr1l-vc140-mt-sgd-1_59-amd64.liblibboost_prg_exec_monitor-vc140-mt-s-1_59-amd64.liblibboost_prg_exec_monitor-vc140-mt-sgd-1_59-amd64.liblibboost_program_options-vc140-mt-s-1_59-amd64.liblibboost_program_options-vc140-mt-sgd-1_59-amd64.liblibboost_random-vc140-mt-s-1_59-amd64.liblibboost_random-vc140-mt-sgd-1_59-amd64.liblibboost_regex-vc140-mt-s-1_59-amd64.liblibboost_regex-vc140-mt-sgd-1_59-amd64.liblibboost_serialization-vc140-mt-s-1_59-amd64.liblibboost_serialization-vc140-mt-sgd-1_59-amd64.liblibboost_signals-vc140-mt-s-1_59-amd64.liblibboost_signals-vc140-mt-sgd-1_59-amd64.liblibboost_system-vc140-mt-s-1_59-amd64.liblibboost_system-vc140-mt-sgd-1_59-amd64.liblibboost_test_exec_monitor-vc140-mt-s-1_59-amd64.liblibboost_test_exec_monitor-vc140-mt-sgd-1_59-amd64.liblibboost_thread-vc140-mt-s-1_59-amd64.liblibboost_thread-vc140-mt-sgd-1_59-amd64.liblibboost_timer-vc140-mt-s-1_59-amd64.liblibboost_timer-vc140-mt-sgd-1_59-amd64.liblibboost_unit_test_framework-vc140-mt-s-1_59-amd64.liblibboost_unit_test_framework-vc140-mt-sgd-1_59-amd64.liblibboost_wave-vc140-mt-s-1_59-amd64.liblibboost_wave-vc140-mt-sgd-1_59-amd64.liblibboost_wserialization-vc140-mt-s-1_59-amd64.liblibboost_wserialization-vc140-mt-sgd-1_59-amd64.lib<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./b2 --prefix<span class="token operator">=</span>./install64_staticlib_staticrt --stagedir<span class="token operator">=</span>./stage64_staticlib_staticrt --build-dir<span class="token operator">=</span>./build64_staticlib_staticrt --build-type<span class="token operator">=</span>complete --layout<span class="token operator">=</span>versioned --buildid<span class="token operator">=</span>amd64 --without-mpi --without-graph --without-graph_parallel --without-python <span class="token assign-left variable">cxxflags</span><span class="token operator">=</span>-fPIC <span class="token assign-left variable">cflags</span><span class="token operator">=</span>-fPIC address-model<span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">variant</span><span class="token operator">=</span>debug,release <span class="token assign-left variable">threading</span><span class="token operator">=</span>multi <span class="token assign-left variable">link</span><span class="token operator">=</span>static runtime-link<span class="token operator">=</span>static -a -q -j6 <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成的文件列表如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">libboost_atomic-gcc49-mt-s-1_59-amd64.alibboost_atomic-gcc49-mt-sd-1_59-amd64.alibboost_chrono-gcc49-mt-s-1_59-amd64.alibboost_chrono-gcc49-mt-sd-1_59-amd64.alibboost_container-gcc49-mt-s-1_59-amd64.alibboost_container-gcc49-mt-sd-1_59-amd64.alibboost_context-gcc49-mt-s-1_59-amd64.alibboost_context-gcc49-mt-sd-1_59-amd64.alibboost_coroutine-gcc49-mt-s-1_59-amd64.alibboost_coroutine-gcc49-mt-sd-1_59-amd64.alibboost_date_time-gcc49-mt-s-1_59-amd64.alibboost_date_time-gcc49-mt-sd-1_59-amd64.alibboost_exception-gcc49-mt-s-1_59-amd64.alibboost_exception-gcc49-mt-sd-1_59-amd64.alibboost_filesystem-gcc49-mt-s-1_59-amd64.alibboost_filesystem-gcc49-mt-sd-1_59-amd64.alibboost_iostreams-gcc49-mt-s-1_59-amd64.alibboost_iostreams-gcc49-mt-sd-1_59-amd64.alibboost_locale-gcc49-mt-s-1_59-amd64.alibboost_locale-gcc49-mt-sd-1_59-amd64.alibboost_log-gcc49-mt-s-1_59-amd64.alibboost_log-gcc49-mt-sd-1_59-amd64.alibboost_log_setup-gcc49-mt-s-1_59-amd64.alibboost_log_setup-gcc49-mt-sd-1_59-amd64.alibboost_math_c99f-gcc49-mt-s-1_59-amd64.alibboost_math_c99f-gcc49-mt-sd-1_59-amd64.alibboost_math_c99-gcc49-mt-s-1_59-amd64.alibboost_math_c99-gcc49-mt-sd-1_59-amd64.alibboost_math_c99l-gcc49-mt-s-1_59-amd64.alibboost_math_c99l-gcc49-mt-sd-1_59-amd64.alibboost_math_tr1f-gcc49-mt-s-1_59-amd64.alibboost_math_tr1f-gcc49-mt-sd-1_59-amd64.alibboost_math_tr1-gcc49-mt-s-1_59-amd64.alibboost_math_tr1-gcc49-mt-sd-1_59-amd64.alibboost_math_tr1l-gcc49-mt-s-1_59-amd64.alibboost_math_tr1l-gcc49-mt-sd-1_59-amd64.alibboost_prg_exec_monitor-gcc49-mt-s-1_59-amd64.alibboost_prg_exec_monitor-gcc49-mt-sd-1_59-amd64.alibboost_program_options-gcc49-mt-s-1_59-amd64.alibboost_program_options-gcc49-mt-sd-1_59-amd64.alibboost_random-gcc49-mt-s-1_59-amd64.alibboost_random-gcc49-mt-sd-1_59-amd64.alibboost_regex-gcc49-mt-s-1_59-amd64.alibboost_regex-gcc49-mt-sd-1_59-amd64.alibboost_serialization-gcc49-mt-s-1_59-amd64.alibboost_serialization-gcc49-mt-sd-1_59-amd64.alibboost_signals-gcc49-mt-s-1_59-amd64.alibboost_signals-gcc49-mt-sd-1_59-amd64.alibboost_system-gcc49-mt-s-1_59-amd64.alibboost_system-gcc49-mt-sd-1_59-amd64.alibboost_test_exec_monitor-gcc49-mt-s-1_59-amd64.alibboost_test_exec_monitor-gcc49-mt-sd-1_59-amd64.alibboost_thread-gcc49-mt-s-1_59-amd64.alibboost_thread-gcc49-mt-sd-1_59-amd64.alibboost_timer-gcc49-mt-s-1_59-amd64.alibboost_timer-gcc49-mt-sd-1_59-amd64.alibboost_unit_test_framework-gcc49-mt-s-1_59-amd64.alibboost_unit_test_framework-gcc49-mt-sd-1_59-amd64.alibboost_wave-gcc49-mt-s-1_59-amd64.alibboost_wave-gcc49-mt-sd-1_59-amd64.alibboost_wserialization-gcc49-mt-s-1_59-amd64.alibboost_wserialization-gcc49-mt-sd-1_59-amd64.a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="修改boost的头文件"><a href="#修改boost的头文件" class="headerlink" title="修改boost的头文件"></a>修改boost的头文件</h2><p>把下面的内容加到文件<code>install64_staticlib_staticrt/include/boost-1_59/boost/config</code>的最后：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">BOOST_LIB_BUILDID amd64</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arch安装备忘</title>
      <link href="arch-an-zhuang-bei-wang/"/>
      <url>arch-an-zhuang-bei-wang/</url>
      
        <content type="html"><![CDATA[<h2 id="获取ISO"><a href="#获取ISO" class="headerlink" title="获取ISO"></a>获取<a href="http://mirrors.163.com/archlinux/iso/latest/">ISO</a></h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> http://mirrors.163.com/archlinux/iso/latest/archlinux-2018.05.01-x86_64.iso<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="从ISO文件引导系统"><a href="#从ISO文件引导系统" class="headerlink" title="从ISO文件引导系统"></a>从ISO文件引导系统</h2><h2 id="更新系统时间"><a href="#更新系统时间" class="headerlink" title="更新系统时间"></a>更新系统时间</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">timedatectl set-ntp <span class="token boolean">true</span>timedatectl status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">parted</span> -a optimal /dev/sdamklabel gptunit mibmkpart primary <span class="token number">1</span> <span class="token number">3</span>name <span class="token number">1</span> grub<span class="token builtin class-name">set</span> <span class="token number">1</span> bios_grub onmkpart primary <span class="token number">3</span> <span class="token number">256</span>name <span class="token number">2</span> boot<span class="token builtin class-name">set</span> <span class="token number">2</span> boot onmkpart primary <span class="token number">256</span> <span class="token number">8448</span>name <span class="token number">3</span> swapmkpart primary <span class="token number">8448</span> -1name <span class="token number">4</span> rootfsprintquitmkfs.ext4 /dev/sda2mkfs.ext4 /dev/sda4<span class="token function">mkswap</span> /dev/sda3<span class="token function">swapon</span> /dev/sda3<span class="token function">mount</span> /dev/sda4 /mnt<span class="token function">mkdir</span> /mnt/boot<span class="token function">mount</span> /dev/sda2 /mnt/boot<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="安装Arch"><a href="#安装Arch" class="headerlink" title="安装Arch"></a>安装Arch</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mv</span> /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.bk<span class="token function">grep</span> <span class="token number">163</span>.com /etc/pacman.d/mirrorlist.bk <span class="token operator">&gt;</span> /etc/pacman.d/mirrorlistpacstrap /mnt base base-develgenfstab -U /mnt <span class="token operator">&gt;&gt;</span> /mnt/etc/fstab<span class="token function">cat</span> /mnt/etc/fstabarch-chroot /mnt<span class="token function">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtimehwclock --systohc<span class="token function">mv</span> /etc/locale.gen /etc/locale.gen.bk<span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">&gt;</span>/etc/locale.gen</span>en_US ISO-8859-1en_US.UTF-8 UTF-8zh_CN GB18030zh_CN.GBK GBKzh_CN.GB2312 GB2312zh_CN.UTF-8 UTF-8EOF</span>locale-genlocale -a<span class="token builtin class-name">echo</span> <span class="token string">"LANG=en_US.UTF-8"</span> <span class="token operator">&gt;</span> /etc/locale.conf<span class="token builtin class-name">echo</span> <span class="token string">"kiba"</span> <span class="token operator">&gt;</span> /etc/hostname<span class="token function">passwd</span>systemctl <span class="token builtin class-name">enable</span> dhcpcdpacman -S <span class="token function">vim</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="安装Grub"><a href="#安装Grub" class="headerlink" title="安装Grub"></a>安装Grub</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pacman -S grubgrub-install /dev/sda<span class="token function">grub-mkconfig</span> -o /boot/grub/grub.cfg<span class="token builtin class-name">exit</span><span class="token builtin class-name">cd</span><span class="token function">umount</span> -R /mnt<span class="token function">reboot</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="安装常用软件"><a href="#安装常用软件" class="headerlink" title="安装常用软件"></a>安装常用软件</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 可以使用命令`pacman -Fs binname`根据执行文件的名字搜索软件包的名字</span>pacman -S openssh<span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">&gt;&gt;</span>/etc/ssh/sshd_config</span>PermitRootLogin yesPasswordAuthentication yesEOF</span>systemctl <span class="token builtin class-name">enable</span> sshdsystemctl start sshd<span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">&gt;&gt;</span>/etc/pacman.conf</span>[archlinuxcn]SigLevel = Optional TrustAllServer = http://mirrors.163.com/archlinux-cn/<span class="token variable">$arch</span>EOF</span>pacman -Syy <span class="token operator">&amp;&amp;</span> pcman -Syu <span class="token operator">&amp;&amp;</span> pacman -S archlinuxcn-keyringpacman -S yaourtpacman -S <span class="token function">wget</span> <span class="token function">git</span><span class="token function">mkdir</span> /usr/share/pictures<span class="token function">wget</span> http://b.hiphotos.baidu.com/zhidao/pic/item/1ad5ad6eddc451da88f9f31ab3fd5266d0163237.jpg -O /usr/share/pictures/background.jpg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="安装GUI"><a href="#安装GUI" class="headerlink" title="安装GUI"></a>安装GUI</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pacman -S xorg xorg-xinit xf86-video-fbdevpacman -S i3-wm i3status i3lock dmenu rxvt-unicode rxvt-unicode-terminfo conky fehpacman -S ttf-font-awesome<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arch </tag>
            
            <tag> 系统安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gentoo安装备忘</title>
      <link href="gentoo-an-zhuang-bei-wang/"/>
      <url>gentoo-an-zhuang-bei-wang/</url>
      
        <content type="html"><![CDATA[<h2 id="获取ISO"><a href="#获取ISO" class="headerlink" title="获取ISO"></a>获取<a href="http://mirrors.163.com/gentoo/releases/amd64/autobuilds/">ISO</a></h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> http://mirrors.163.com/gentoo/releases/amd64/autobuilds/current-install-amd64-minimal/install-amd64-minimal-20180415T214502Z.iso<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="从ISO文件引导系统"><a href="#从ISO文件引导系统" class="headerlink" title="从ISO文件引导系统"></a>从ISO文件引导系统</h2><h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">parted</span> -a optimal /dev/sdamklabel gptunit mibmkpart primary <span class="token number">1</span> <span class="token number">3</span>name <span class="token number">1</span> grub<span class="token builtin class-name">set</span> <span class="token number">1</span> bios_grub onmkpart primary <span class="token number">3</span> <span class="token number">256</span>name <span class="token number">2</span> boot<span class="token builtin class-name">set</span> <span class="token number">2</span> boot onmkpart primary <span class="token number">256</span> <span class="token number">8448</span>name <span class="token number">3</span> swapmkpart primary <span class="token number">8448</span> -1name <span class="token number">4</span> rootfsprintquitmkfs.ext4 /dev/sda2mkfs.ext4 /dev/sda4<span class="token function">mkswap</span> /dev/sda3<span class="token function">swapon</span> /dev/sda3<span class="token function">mount</span> /dev/sda4 /mnt/gentoo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="安装Gentoo"><a href="#安装Gentoo" class="headerlink" title="安装Gentoo"></a>安装Gentoo</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /mnt/gentoo<span class="token function">wget</span> http://mirrors.163.com/gentoo/releases/amd64/autobuilds/current-install-amd64-minimal/stage3-amd64-20180415T214502Z.tar.xz<span class="token comment"># hardened</span><span class="token function">wget</span> http://mirrors.163.com/gentoo/releases/amd64/autobuilds/current-stage3-amd64-hardened/stage3-amd64-hardened-20180517T214504Z.tar.xz<span class="token comment"># systemd</span><span class="token function">wget</span> http://mirrors.163.com/gentoo/releases/amd64/autobuilds/current-stage3-amd64-systemd/stage3-amd64-systemd-20180518.tar.bz2<span class="token function">tar</span> xpf stage3-amd64-20180415T214502Z.tar.xz --xattrs-include<span class="token operator">=</span><span class="token string">'*.*'</span> --numeric-owner<span class="token function">cp</span> /mnt/gentoo/etc/portage/make.conf /mnt/gentoo/etc/portage/make.conf.bk<span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">&gt;</span> /mnt/gentoo/etc/portage/make.conf</span>CFLAGS="-march=native -O2 -pipe"CXXFLAGS="-march=native -O2 -pipe"CHOST="x86_64-pc-linux-gnu"MAKEOPTS="-j9 -l8"EMERGE_DEFAULT_OPTS="--jobs=8 --load-average=8 --ask --verbose --with-bdeps=y"PORTAGE_NICENESS=15# get by cpuid2cpuflags(emerge app-portage/cpuid2cpuflags)CPU_FLAGS_X86="aes avx avx2 f16c fma3 mmx mmxext pclmul popcnt sse sse2 sse3 sse4_1 sse4_2 ssse3"ACCEPT_KEYWORDS="amd64"#GENTOO_MIRRORS="https://mirrors.tuna.tsinghua.edu.cn/gentoo/"#GENTOO_MIRRORS="https://mirrors.163.com/gentoo/"GENTOO_MIRRORS="http://mirrors.ustc.edu.cn/gentoo/"L10N="en-US zh-CN"#LINGUAS="en_US zh_CN"LC_MESSAGES="C"PORTDIR="/usr/portage"DISTDIR="/usr/portage/distfiles"PKGDIR="/usr/portage/packages"#FEATURES="ccache"#CCACHE_SIZE="8G"#USE="dbus policykit udisks udev consolekit X"#VIDEO_CARDS="vmware"#INPUT_DEVICES="keyboard mouse"EOF</span><span class="token function">mkdir</span> --parents /mnt/gentoo/etc/portage/repos.conf<span class="token function">cp</span> /mnt/gentoo/usr/share/portage/config/repos.conf /mnt/gentoo/etc/portage/repos.conf/gentoo.conf.bk<span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">&gt;</span> /mnt/gentoo/etc/portage/repos.conf/gentoo.conf</span>[DEFAULT]main-repo = gentoo[gentoo]location = /usr/portagesync-type = rsync#sync-uri = rsync://rsync.gentoo.org/gentoo-portage#sync-uri = rsync://rsync.cn.gentoo.org/gentoo-portagesync-uri = rsync://rsync.mirrors.ustc.edu.cn/gentoo-portage/auto-sync = yessync-rsync-verify-jobs = 1sync-rsync-verify-metamanifest = nosync-rsync-verify-max-age = 24sync-openpgp-key-path = /usr/share/openpgp-keys/gentoo-release.ascsync-openpgp-key-refresh-retry-count = 40sync-openpgp-key-refresh-retry-overall-timeout = 1200sync-openpgp-key-refresh-retry-delay-exp-base = 2sync-openpgp-key-refresh-retry-delay-max = 60sync-openpgp-key-refresh-retry-delay-mult = 4# for daily squashfs snapshots#sync-type = squashdelta#sync-uri = mirror://gentoo/../snapshots/squashfsEOF</span><span class="token function">cp</span> --dereference /etc/resolv.conf /mnt/gentoo/etc/<span class="token function">mount</span> --types proc /proc /mnt/gentoo/proc<span class="token function">mount</span> --rbind /sys /mnt/gentoo/sys<span class="token function">mount</span> --make-rslave /mnt/gentoo/sys<span class="token function">mount</span> --rbind /dev /mnt/gentoo/dev<span class="token function">mount</span> --make-rslave /mnt/gentoo/dev<span class="token function">chroot</span> /mnt/gentoo /bin/bash<span class="token builtin class-name">source</span> /etc/profile<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PS1</span></span><span class="token operator">=</span><span class="token string">"(chroot) <span class="token variable">${<span class="token environment constant">PS1</span>}</span>"</span><span class="token function">mkdir</span> /boot<span class="token function">mount</span> /dev/sda2 /bootemerge-webrsyncemerge --synceselect profile listeselect profile <span class="token builtin class-name">set</span> default/linux/amd64/17.0/desktop/plasmaemerge --ask --update --deep --newuse @world<span class="token function">ls</span> /usr/share/zoneinfo<span class="token builtin class-name">echo</span> <span class="token string">"Asia/Shanghai"</span> <span class="token operator">&gt;</span> /etc/timezoneemerge --config sys-libs/timezone-data<span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">&gt;</span>/etc/locale.gen</span>en_US ISO-8859-1en_US.UTF-8 UTF-8zh_CN GB18030zh_CN.GBK GBKzh_CN.GB2312 GB2312zh_CN.UTF-8 UTF-8EOF</span>locale-genlocale -aeselect locale listeselect locale <span class="token builtin class-name">set</span> en_US.utf8env-update <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">source</span> /etc/profile <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PS1</span></span><span class="token operator">=</span><span class="token string">"(chroot) <span class="token environment constant">$PS1</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="配置内核"><a href="#配置内核" class="headerlink" title="配置内核"></a>配置内核</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">emerge sys-kernel/gentoo-sources<span class="token function">ls</span> -l /usr/src/linuxemerge sys-kernel/genkernel<span class="token function">nano</span> -w /etc/fstab<span class="token comment"># /dev/sda2 /boot ext2 defaults 0 2</span>genkernel all<span class="token comment"># or genkernel --lvm all</span><span class="token function">ls</span> /boot/kernel* /boot/initramfs*emerge sys-kernel/linux-firmware<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="配置系统"><a href="#配置系统" class="headerlink" title="配置系统"></a>配置系统</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">nano</span> -w /etc/fstab<span class="token comment">#/dev/sda2  /boot       ext4    defaults,noatime    0 2</span><span class="token comment">#/dev/sda3  none        swap    sw                  0 0</span><span class="token comment">#/dev/sda4  /           ext4    noatime             0 1</span><span class="token comment">#/dev/cdrom /mnt/cdrom  auto    noauto,user         0 0</span><span class="token function">cp</span> /etc/conf.d/hostname /etc/conf.d/hostname.bk<span class="token builtin class-name">echo</span> <span class="token string">"hostname=<span class="token entity" title="\&quot;">\"</span>gentoo<span class="token entity" title="\&quot;">\"</span>"</span> <span class="token operator">&gt;</span> /etc/conf.d/hostnameemerge --noreplace net-misc/netifrc<span class="token builtin class-name">echo</span> <span class="token string">"config_eno16777736=<span class="token entity" title="\&quot;">\"</span>dhcp<span class="token entity" title="\&quot;">\"</span>"</span> <span class="token operator">&gt;</span> /etc/conf.d/net<span class="token function">passwd</span><span class="token builtin class-name">cd</span> /etc/init.d<span class="token function">ln</span> -s net.lo net.eno16777736rc-update <span class="token function">add</span> net.eno16777736 default<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="安装系统工具"><a href="#安装系统工具" class="headerlink" title="安装系统工具"></a>安装系统工具</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">emerge app-admin/sysklogdrc-update <span class="token function">add</span> sysklogd defaultemerge sys-process/cronierc-update <span class="token function">add</span> cronie defaultemerge sys-apps/mlocaterc-update <span class="token function">add</span> sshd defaultemerge net-misc/dhcpcdrc-update <span class="token function">add</span> dhcpcd defaultrc-update <span class="token function">add</span> dbus defaultrc-update <span class="token function">add</span> udev sysinitrc-update <span class="token function">add</span> consolekit default<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="安装Grub"><a href="#安装Grub" class="headerlink" title="安装Grub"></a>安装Grub</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">emerge sys-boot/grub:2grub-install /dev/sda<span class="token function">grub-mkconfig</span> -o /boot/grub/grub.cfg<span class="token builtin class-name">exit</span><span class="token builtin class-name">cd</span><span class="token function">umount</span> -l /mnt/gentoo/dev<span class="token punctuation">{</span>/shm,/pts,<span class="token punctuation">}</span><span class="token function">umount</span> -R /mnt/gentoo<span class="token function">reboot</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="安装系统内核工具"><a href="#安装系统内核工具" class="headerlink" title="安装系统内核工具"></a>安装系统内核工具</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">emerge app-portage/eix app-portage/gentoolkit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="更新系统"><a href="#更新系统" class="headerlink" title="更新系统"></a>更新系统</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">eix-syncemerge -avuDN --tree worldemerge -av --depcleanrevdep-rebuild -v -- --askdispatch-confeclean-dist -deix-test-obsoleteglsa-check -t allglsa-check -f all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="安装Xorg"><a href="#安装Xorg" class="headerlink" title="安装Xorg"></a>安装Xorg</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">emerge --ask x11-base/xorg-drivers media-libs/mesa x11-base/xorg-x11 x11-wm/twm x11-terms/xtermstartx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="安装Kde"><a href="#安装Kde" class="headerlink" title="安装Kde"></a>安装Kde</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">emerge --ask kde-plasma/plasma-meta<span class="token builtin class-name">echo</span> <span class="token string">"DISPLAYMANAGER=<span class="token entity" title="\&quot;">\"</span>sddm<span class="token entity" title="\&quot;">\"</span>"</span> <span class="token operator">&gt;&gt;</span> /etc/conf.d/xdmrc-update <span class="token function">add</span> xdm default<span class="token function">useradd</span> -m k<span class="token function">passwd</span> k<span class="token comment">#su k</span><span class="token comment">#groups</span><span class="token comment">#usermod -a -G plugdev k</span>emerge app-portage/laymanlayman -Llayman -a gentoo-zhemerge app-i18n/fcitx app-i18n/fcitx-cloudpinyin app-i18n/kcm-fcitx<span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">&gt;&gt;</span>/home/k/.xprofile</span>eval "<span class="token variable"><span class="token variable">$(</span>dbus-launch --sh-syntax --exit-with-session<span class="token variable">)</span></span>"export XMODIFIERS="@im=fcitx"export QT_IM_MODULE=fcitxexport GTK_IM_MODULE=fcitxEOF</span><span class="token comment">#/etc/init.d/xdm restart</span><span class="token function">reboot</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">emerge --ask kde-apps/kde-apps-metaemerge --ask www-client/google-chromeemerge --ask app-portage/pfl<span class="token comment"># e-file = apt-file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="更新系统时间"><a href="#更新系统时间" class="headerlink" title="更新系统时间"></a>更新系统时间</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># ntp</span>emerge --ask net-misc/openntpd<span class="token function">mv</span> /etc/ntpd.conf /etc/ntpd.conf.bk<span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">&gt;</span>/etc/ntpd.conf</span>servers 0.cn.pool.ntp.orgservers 1.cn.pool.ntp.orgservers 2.cn.pool.ntp.orgservers 3.cn.pool.ntp.orgEOF</span>/etc/init.d/ntpd startrc-update <span class="token function">add</span> ntpd default<span class="token function">cp</span> /etc/conf.d/hwclock /etc/conf.d/hwclock.bk<span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">&gt;</span>/etc/conf.d/hwclock</span>clock="local"clock_args=""EOF</span>hwclock --systohc --utchwclock --hctosys --localtime<span class="token function">date</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统安装 </tag>
            
            <tag> Gentoo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断两个矩形是否相交</title>
      <link href="pan-duan-liang-ge-ju-xing-shi-fou-xiang-jiao/"/>
      <url>pan-duan-liang-ge-ju-xing-shi-fou-xiang-jiao/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给出两个矩形的一个顶点和宽度高度，判断两个矩形是否相交并计算出相交的区域。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>下面给了出几种算法的C代码并对其进行了测试，算法依次更简单快速：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">IsOverlap1</span><span class="token punctuation">(</span><span class="token keyword">double</span> ax1<span class="token punctuation">,</span> <span class="token keyword">double</span> ay1<span class="token punctuation">,</span> <span class="token keyword">double</span> aw<span class="token punctuation">,</span> <span class="token keyword">double</span> ah<span class="token punctuation">,</span>    <span class="token keyword">double</span> bx1<span class="token punctuation">,</span> <span class="token keyword">double</span> by1<span class="token punctuation">,</span> <span class="token keyword">double</span> bw<span class="token punctuation">,</span> <span class="token keyword">double</span> bh<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">double</span> ax2<span class="token punctuation">,</span> ay2<span class="token punctuation">,</span> bx2<span class="token punctuation">,</span> by2<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">&lt;</span> <span class="token number">0.0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> a <span class="token operator">+=</span> b<span class="token punctuation">;</span> b <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">-</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>ax1<span class="token punctuation">,</span> aw<span class="token punctuation">,</span> ax2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>ay1<span class="token punctuation">,</span> ah<span class="token punctuation">,</span> ay2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>bx1<span class="token punctuation">,</span> bw<span class="token punctuation">,</span> bx2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>by1<span class="token punctuation">,</span> bh<span class="token punctuation">,</span> by2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">undef</span> <span class="token expression">_PARAM_CHECK_</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token punctuation">(</span>a <span class="token operator">&lt;=</span> b <span class="token operator">&amp;&amp;</span> b <span class="token operator">&lt;=</span> c<span class="token punctuation">)</span></span></span>    <span class="token comment">/*    1.B有顶点在A中    -------A    |     |    |   ------B    |   | |  |    ----|--  |        |    |        ------    */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>ax1<span class="token punctuation">,</span> bx1<span class="token punctuation">,</span> ax2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>ay1<span class="token punctuation">,</span> by1<span class="token punctuation">,</span> ay2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>ax1<span class="token punctuation">,</span> bx1<span class="token punctuation">,</span> ax2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>ay1<span class="token punctuation">,</span> by2<span class="token punctuation">,</span> ay2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>ax1<span class="token punctuation">,</span> bx2<span class="token punctuation">,</span> ax2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>ay1<span class="token punctuation">,</span> by1<span class="token punctuation">,</span> ay2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>ax1<span class="token punctuation">,</span> bx2<span class="token punctuation">,</span> ax2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>ay1<span class="token punctuation">,</span> by2<span class="token punctuation">,</span> ay2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">/*    2.A有2或4个顶点在B中    -------B    | --- |    --|-|--      ---A    -------    | --- |    | |A| |    | --- |    -------B    */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>bx1<span class="token punctuation">,</span> ax1<span class="token punctuation">,</span> bx2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>by1<span class="token punctuation">,</span> ay1<span class="token punctuation">,</span> by2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>bx1<span class="token punctuation">,</span> ax2<span class="token punctuation">,</span> bx2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>by1<span class="token punctuation">,</span> ay2<span class="token punctuation">,</span> by2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">/*    3.A与B十字相交且A横B竖       ---B       | |    ---|-|---A    |  | |  |    ---|-|---       | |       ---    */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>ax1<span class="token punctuation">,</span> bx1<span class="token punctuation">,</span> ax2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>ax1<span class="token punctuation">,</span> bx2<span class="token punctuation">,</span> ax2<span class="token punctuation">)</span>        <span class="token operator">&amp;&amp;</span> <span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>by1<span class="token punctuation">,</span> ay1<span class="token punctuation">,</span> by2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>by1<span class="token punctuation">,</span> ay2<span class="token punctuation">,</span> by2<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">/*    3.A与B十字相交且A竖B横       ---A       | |    ---|-|---B    |  | |  |    ---|-|---       | |       ---    */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>bx1<span class="token punctuation">,</span> ax1<span class="token punctuation">,</span> bx2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>bx1<span class="token punctuation">,</span> ax2<span class="token punctuation">,</span> bx2<span class="token punctuation">)</span>        <span class="token operator">&amp;&amp;</span> <span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>ay1<span class="token punctuation">,</span> by1<span class="token punctuation">,</span> ay2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>ay1<span class="token punctuation">,</span> by2<span class="token punctuation">,</span> ay2<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">IsOverlap2</span><span class="token punctuation">(</span><span class="token keyword">double</span> ax1<span class="token punctuation">,</span> <span class="token keyword">double</span> ay1<span class="token punctuation">,</span> <span class="token keyword">double</span> aw<span class="token punctuation">,</span> <span class="token keyword">double</span> ah<span class="token punctuation">,</span>    <span class="token keyword">double</span> bx1<span class="token punctuation">,</span> <span class="token keyword">double</span> by1<span class="token punctuation">,</span> <span class="token keyword">double</span> bw<span class="token punctuation">,</span> <span class="token keyword">double</span> bh<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">/*    如果A与B中心在X和Y轴上的距离小于他们边长和的一半就相交    */</span>    <span class="token keyword">double</span> ax2<span class="token punctuation">,</span> ay2<span class="token punctuation">,</span> bx2<span class="token punctuation">,</span> by2<span class="token punctuation">;</span>    <span class="token keyword">double</span> dx<span class="token punctuation">,</span> dy<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">&lt;</span> <span class="token number">0.0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> a <span class="token operator">+=</span> b<span class="token punctuation">;</span> b <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">-</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>ax1<span class="token punctuation">,</span> aw<span class="token punctuation">,</span> ax2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>ay1<span class="token punctuation">,</span> ah<span class="token punctuation">,</span> ay2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>bx1<span class="token punctuation">,</span> bw<span class="token punctuation">,</span> bx2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>by1<span class="token punctuation">,</span> bh<span class="token punctuation">,</span> by2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">undef</span> <span class="token expression">_PARAM_CHECK_</span></span>    dx <span class="token operator">=</span> ax1 <span class="token operator">+</span> ax2 <span class="token operator">-</span> <span class="token punctuation">(</span>bx1 <span class="token operator">+</span> bx2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* A与B中心在X轴上距离的2倍 */</span>    dy <span class="token operator">=</span> ay1 <span class="token operator">+</span> ay2 <span class="token operator">-</span> <span class="token punctuation">(</span>by1 <span class="token operator">+</span> by2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* A与B中心在Y轴上距离的2倍 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dx <span class="token operator">&lt;</span> <span class="token number">0.0</span><span class="token punctuation">)</span> dx <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">-</span> dx<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dy <span class="token operator">&lt;</span> <span class="token number">0.0</span><span class="token punctuation">)</span> dy <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">-</span> dy<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dx <span class="token operator">&lt;=</span> aw <span class="token operator">+</span> bw <span class="token operator">&amp;&amp;</span> dy <span class="token operator">&lt;=</span> ah <span class="token operator">+</span> bh<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">IsOverlap3</span><span class="token punctuation">(</span><span class="token keyword">double</span> ax1<span class="token punctuation">,</span> <span class="token keyword">double</span> ay1<span class="token punctuation">,</span> <span class="token keyword">double</span> aw<span class="token punctuation">,</span> <span class="token keyword">double</span> ah<span class="token punctuation">,</span>    <span class="token keyword">double</span> bx1<span class="token punctuation">,</span> <span class="token keyword">double</span> by1<span class="token punctuation">,</span> <span class="token keyword">double</span> bw<span class="token punctuation">,</span> <span class="token keyword">double</span> bh<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">/*    找出不相交的情况，取反    */</span>    <span class="token keyword">double</span> ax2<span class="token punctuation">,</span> ay2<span class="token punctuation">,</span> bx2<span class="token punctuation">,</span> by2<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">&lt;</span> <span class="token number">0.0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> a <span class="token operator">+=</span> b<span class="token punctuation">;</span> b <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">-</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>ax1<span class="token punctuation">,</span> aw<span class="token punctuation">,</span> ax2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>ay1<span class="token punctuation">,</span> ah<span class="token punctuation">,</span> ay2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>bx1<span class="token punctuation">,</span> bw<span class="token punctuation">,</span> bx2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>by1<span class="token punctuation">,</span> bh<span class="token punctuation">,</span> by2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">undef</span> <span class="token expression">_PARAM_CHECK_</span></span>    <span class="token comment">/* A在B左边 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ax2 <span class="token operator">&lt;</span> bx1<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/* A在B右边 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bx2 <span class="token operator">&lt;</span> ax1<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/* A在B上边 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>by2 <span class="token operator">&lt;</span> ay1<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/* A在B下边 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ay2 <span class="token operator">&lt;</span> by1<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">IsOverlap4</span><span class="token punctuation">(</span><span class="token keyword">double</span> ax1<span class="token punctuation">,</span> <span class="token keyword">double</span> ay1<span class="token punctuation">,</span> <span class="token keyword">double</span> aw<span class="token punctuation">,</span> <span class="token keyword">double</span> ah<span class="token punctuation">,</span>    <span class="token keyword">double</span> bx1<span class="token punctuation">,</span> <span class="token keyword">double</span> by1<span class="token punctuation">,</span> <span class="token keyword">double</span> bw<span class="token punctuation">,</span> <span class="token keyword">double</span> bh<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">double</span> ax2<span class="token punctuation">,</span> ay2<span class="token punctuation">,</span> bx2<span class="token punctuation">,</span> by2<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">&lt;</span> <span class="token number">0.0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> a <span class="token operator">+=</span> b<span class="token punctuation">;</span> b <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">-</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>ax1<span class="token punctuation">,</span> aw<span class="token punctuation">,</span> ax2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>ay1<span class="token punctuation">,</span> ah<span class="token punctuation">,</span> ay2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>bx1<span class="token punctuation">,</span> bw<span class="token punctuation">,</span> bx2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>by1<span class="token punctuation">,</span> bh<span class="token punctuation">,</span> by2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">undef</span> <span class="token expression">_PARAM_CHECK_</span></span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>ax1 <span class="token operator">&lt;=</span> bx2 <span class="token operator">&amp;&amp;</span> bx1 <span class="token operator">&lt;=</span> ax2 <span class="token operator">&amp;&amp;</span> ay1 <span class="token operator">&lt;=</span> by2 <span class="token operator">&amp;&amp;</span> by1 <span class="token operator">&lt;=</span> ay2<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">GetOverlap</span><span class="token punctuation">(</span><span class="token keyword">double</span> ax1<span class="token punctuation">,</span> <span class="token keyword">double</span> ay1<span class="token punctuation">,</span> <span class="token keyword">double</span> aw<span class="token punctuation">,</span> <span class="token keyword">double</span> ah<span class="token punctuation">,</span>    <span class="token keyword">double</span> bx1<span class="token punctuation">,</span> <span class="token keyword">double</span> by1<span class="token punctuation">,</span> <span class="token keyword">double</span> bw<span class="token punctuation">,</span> <span class="token keyword">double</span> bh<span class="token punctuation">,</span>    <span class="token keyword">double</span><span class="token operator">*</span> cx1<span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">*</span> cy1<span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">*</span> cw<span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">*</span> ch<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">double</span> ax2<span class="token punctuation">,</span> ay2<span class="token punctuation">,</span> bx2<span class="token punctuation">,</span> by2<span class="token punctuation">;</span>    <span class="token keyword">double</span> x1<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> x2<span class="token punctuation">,</span> y2<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">&lt;</span> <span class="token number">0.0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> a <span class="token operator">+=</span> b<span class="token punctuation">;</span> b <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">-</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>ax1<span class="token punctuation">,</span> aw<span class="token punctuation">,</span> ax2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>ay1<span class="token punctuation">,</span> ah<span class="token punctuation">,</span> ay2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>bx1<span class="token punctuation">,</span> bw<span class="token punctuation">,</span> bx2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>by1<span class="token punctuation">,</span> bh<span class="token punctuation">,</span> by2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">undef</span> <span class="token expression">_PARAM_CHECK_</span></span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ax1 <span class="token operator">&lt;=</span> bx2 <span class="token operator">&amp;&amp;</span> bx1 <span class="token operator">&lt;=</span> ax2 <span class="token operator">&amp;&amp;</span> ay1 <span class="token operator">&lt;=</span> by2 <span class="token operator">&amp;&amp;</span> by1 <span class="token operator">&lt;=</span> ay2<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        x1 <span class="token operator">=</span> ax1 <span class="token operator">&gt;</span> bx1 <span class="token operator">?</span> ax1 <span class="token operator">:</span> bx1<span class="token punctuation">;</span>        y1 <span class="token operator">=</span> ay1 <span class="token operator">&gt;</span> by1 <span class="token operator">?</span> ay1 <span class="token operator">:</span> by1<span class="token punctuation">;</span>        x2 <span class="token operator">=</span> ax2 <span class="token operator">&lt;</span> bx2 <span class="token operator">?</span> ax2 <span class="token operator">:</span> bx2<span class="token punctuation">;</span>        y2 <span class="token operator">=</span> ay2 <span class="token operator">&lt;</span> by2 <span class="token operator">?</span> ay2 <span class="token operator">:</span> by2<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> cx1<span class="token punctuation">)</span> <span class="token operator">*</span>cx1 <span class="token operator">=</span> x1<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> cy1<span class="token punctuation">)</span> <span class="token operator">*</span>cy1 <span class="token operator">=</span> y1<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> cw<span class="token punctuation">)</span> <span class="token operator">*</span>cw <span class="token operator">=</span> x2 <span class="token operator">-</span> x1<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> ch<span class="token punctuation">)</span> <span class="token operator">*</span>ch <span class="token operator">=</span> y2 <span class="token operator">-</span> y1<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">,</span> <span class="token keyword">double</span> ax1<span class="token punctuation">,</span> <span class="token keyword">double</span> ay1<span class="token punctuation">,</span> <span class="token keyword">double</span> aw<span class="token punctuation">,</span> <span class="token keyword">double</span> ah<span class="token punctuation">,</span>    <span class="token keyword">double</span> bx1<span class="token punctuation">,</span> <span class="token keyword">double</span> by1<span class="token punctuation">,</span> <span class="token keyword">double</span> bw<span class="token punctuation">,</span> <span class="token keyword">double</span> bh<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">double</span> cx1 <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> cy1 <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> cw <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> ch <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> s<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"-----------------------------------------------\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Test:%s\n"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"A:%lf, %lf, %lf, %lf\n"</span><span class="token punctuation">,</span> ax1<span class="token punctuation">,</span> ay1<span class="token punctuation">,</span> aw<span class="token punctuation">,</span> ah<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"B:%lf, %lf, %lf, %lf\n"</span><span class="token punctuation">,</span> bx1<span class="token punctuation">,</span> by1<span class="token punctuation">,</span> bw<span class="token punctuation">,</span> bh<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Result1:%d\n"</span><span class="token punctuation">,</span> <span class="token function">IsOverlap1</span><span class="token punctuation">(</span>ax1<span class="token punctuation">,</span> ay1<span class="token punctuation">,</span> aw<span class="token punctuation">,</span> ah<span class="token punctuation">,</span> bx1<span class="token punctuation">,</span> by1<span class="token punctuation">,</span> bw<span class="token punctuation">,</span> bh<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Result2:%d\n"</span><span class="token punctuation">,</span> <span class="token function">IsOverlap2</span><span class="token punctuation">(</span>ax1<span class="token punctuation">,</span> ay1<span class="token punctuation">,</span> aw<span class="token punctuation">,</span> ah<span class="token punctuation">,</span> bx1<span class="token punctuation">,</span> by1<span class="token punctuation">,</span> bw<span class="token punctuation">,</span> bh<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Result3:%d\n"</span><span class="token punctuation">,</span> <span class="token function">IsOverlap3</span><span class="token punctuation">(</span>ax1<span class="token punctuation">,</span> ay1<span class="token punctuation">,</span> aw<span class="token punctuation">,</span> ah<span class="token punctuation">,</span> bx1<span class="token punctuation">,</span> by1<span class="token punctuation">,</span> bw<span class="token punctuation">,</span> bh<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Result4:%d\n"</span><span class="token punctuation">,</span> <span class="token function">IsOverlap4</span><span class="token punctuation">(</span>ax1<span class="token punctuation">,</span> ay1<span class="token punctuation">,</span> aw<span class="token punctuation">,</span> ah<span class="token punctuation">,</span> bx1<span class="token punctuation">,</span> by1<span class="token punctuation">,</span> bw<span class="token punctuation">,</span> bh<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">GetOverlap</span><span class="token punctuation">(</span>ax1<span class="token punctuation">,</span> ay1<span class="token punctuation">,</span> aw<span class="token punctuation">,</span> ah<span class="token punctuation">,</span> bx1<span class="token punctuation">,</span> by1<span class="token punctuation">,</span> bw<span class="token punctuation">,</span> bh<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cx1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cy1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cw<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Overlap:%lf, %lf, %lf, %lf\n"</span><span class="token punctuation">,</span> cx1<span class="token punctuation">,</span> cy1<span class="token punctuation">,</span> cw<span class="token punctuation">,</span> ch<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The left-up    of B in A"</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span>  <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The left-down  of B in A"</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span>  <span class="token number">2.0</span><span class="token punctuation">,</span>  <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The right-up   of B in A"</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The right-down of B in A"</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.0</span><span class="token punctuation">,</span>  <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The left-up    of A in B"</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span>  <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The left-down  of A in B"</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span>  <span class="token number">2.0</span><span class="token punctuation">,</span>  <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The right-up   of A in B"</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The right-down of A in B"</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.0</span><span class="token punctuation">,</span>  <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The up    of B in A"</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span>  <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">4.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The down  of B in A"</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span>  <span class="token number">0.5</span><span class="token punctuation">,</span>  <span class="token number">4.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The left  of B in A"</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">4.0</span><span class="token punctuation">,</span>  <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The right of B in A"</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span>  <span class="token number">4.0</span><span class="token punctuation">,</span>  <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The up    of A in B"</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span>  <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">4.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The down  of A in B"</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span>  <span class="token number">0.5</span><span class="token punctuation">,</span>  <span class="token number">4.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The left  of A in B"</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">4.0</span><span class="token punctuation">,</span>  <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The right of A in B"</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span>  <span class="token number">4.0</span><span class="token punctuation">,</span>  <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The B in A"</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The A in B"</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"horizontal A cross vertical B"</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"horizontal B cross vertical A"</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码测试结果"><a href="#代码测试结果" class="headerlink" title="代码测试结果"></a>代码测试结果</h2><pre class="line-numbers language-text" data-language="text"><code class="language-text">-----------------------------------------------Test:The left-up    of B in AA:1.000000, 1.000000, 2.000000, 2.000000B:2.000000, 2.000000, 2.000000, -2.000000Result1:1Result2:1Result3:1Result4:1Overlap:2.000000, 1.000000, 1.000000, 1.000000-----------------------------------------------Test:The left-down  of B in AA:1.000000, 1.000000, 2.000000, 2.000000B:2.000000, 2.000000, 2.000000, 2.000000Result1:1Result2:1Result3:1Result4:1Overlap:2.000000, 2.000000, 1.000000, 1.000000-----------------------------------------------Test:The right-up   of B in AA:1.000000, 1.000000, 2.000000, 2.000000B:2.000000, 2.000000, -2.000000, -2.000000Result1:1Result2:1Result3:1Result4:1Overlap:1.000000, 1.000000, 1.000000, 1.000000-----------------------------------------------Test:The right-down of B in AA:1.000000, 1.000000, 2.000000, 2.000000B:2.000000, 2.000000, -2.000000, 2.000000Result1:1Result2:1Result3:1Result4:1Overlap:1.000000, 2.000000, 1.000000, 1.000000-----------------------------------------------Test:The left-up    of A in BA:2.000000, 2.000000, 2.000000, -2.000000B:1.000000, 1.000000, 2.000000, 2.000000Result1:1Result2:1Result3:1Result4:1Overlap:2.000000, 1.000000, 1.000000, 1.000000-----------------------------------------------Test:The left-down  of A in BA:2.000000, 2.000000, 2.000000, 2.000000B:1.000000, 1.000000, 2.000000, 2.000000Result1:1Result2:1Result3:1Result4:1Overlap:2.000000, 2.000000, 1.000000, 1.000000-----------------------------------------------Test:The right-up   of A in BA:2.000000, 2.000000, -2.000000, -2.000000B:1.000000, 1.000000, 2.000000, 2.000000Result1:1Result2:1Result3:1Result4:1Overlap:1.000000, 1.000000, 1.000000, 1.000000-----------------------------------------------Test:The right-down of A in BA:2.000000, 2.000000, -2.000000, 2.000000B:1.000000, 1.000000, 2.000000, 2.000000Result1:1Result2:1Result3:1Result4:1Overlap:1.000000, 2.000000, 1.000000, 1.000000-----------------------------------------------Test:The up    of B in AA:1.000000, 1.000000, 2.000000, 2.000000B:2.000000, 2.000000, 0.500000, -4.000000Result1:1Result2:1Result3:1Result4:1Overlap:2.000000, 1.000000, 0.500000, 1.000000-----------------------------------------------Test:The down  of B in AA:1.000000, 1.000000, 2.000000, 2.000000B:2.000000, 2.000000, 0.500000, 4.000000Result1:1Result2:1Result3:1Result4:1Overlap:2.000000, 2.000000, 0.500000, 1.000000-----------------------------------------------Test:The left  of B in AA:1.000000, 1.000000, 2.000000, 2.000000B:2.000000, 2.000000, -4.000000, 0.500000Result1:1Result2:1Result3:1Result4:1Overlap:1.000000, 2.000000, 1.000000, 0.500000-----------------------------------------------Test:The right of B in AA:1.000000, 1.000000, 2.000000, 2.000000B:2.000000, 2.000000, 4.000000, 0.500000Result1:1Result2:1Result3:1Result4:1Overlap:2.000000, 2.000000, 1.000000, 0.500000-----------------------------------------------Test:The up    of A in BA:2.000000, 2.000000, 0.500000, -4.000000B:1.000000, 1.000000, 2.000000, 2.000000Result1:1Result2:1Result3:1Result4:1Overlap:2.000000, 1.000000, 0.500000, 1.000000-----------------------------------------------Test:The down  of A in BA:2.000000, 2.000000, 0.500000, 4.000000B:1.000000, 1.000000, 2.000000, 2.000000Result1:1Result2:1Result3:1Result4:1Overlap:2.000000, 2.000000, 0.500000, 1.000000-----------------------------------------------Test:The left  of A in BA:2.000000, 2.000000, -4.000000, 0.500000B:1.000000, 1.000000, 2.000000, 2.000000Result1:1Result2:1Result3:1Result4:1Overlap:1.000000, 2.000000, 1.000000, 0.500000-----------------------------------------------Test:The right of A in BA:2.000000, 2.000000, 4.000000, 0.500000B:1.000000, 1.000000, 2.000000, 2.000000Result1:1Result2:1Result3:1Result4:1Overlap:2.000000, 2.000000, 1.000000, 0.500000-----------------------------------------------Test:The B in AA:1.000000, 1.000000, 2.000000, 2.000000B:2.000000, 2.000000, 0.500000, 0.500000Result1:1Result2:1Result3:1Result4:1Overlap:2.000000, 2.000000, 0.500000, 0.500000-----------------------------------------------Test:The A in BA:2.000000, 2.000000, 0.500000, 0.500000B:1.000000, 1.000000, 2.000000, 2.000000Result1:1Result2:1Result3:1Result4:1Overlap:2.000000, 2.000000, 0.500000, 0.500000-----------------------------------------------Test:horizontal A cross vertical BA:0.000000, 1.000000, 2.000000, 1.000000B:1.000000, 0.000000, 1.000000, 2.000000Result1:1Result2:1Result3:1Result4:1Overlap:1.000000, 1.000000, 1.000000, 1.000000-----------------------------------------------Test:horizontal B cross vertical AA:1.000000, 0.000000, 1.000000, 2.000000B:0.000000, 1.000000, 2.000000, 1.000000Result1:1Result2:1Result3:1Result4:1Overlap:1.000000, 1.000000, 1.000000, 1.000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩形相交 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下Bash中case用法详解</title>
      <link href="linux-xia-bash-zhong-case-yong-fa-xiang-jie/"/>
      <url>linux-xia-bash-zhong-case-yong-fa-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>Linux下Bash中的case和C/C++中的switch类似，但是Bash中的case更强大和复杂。</p><ol><li>强大主要体现在：Bash中case中的关键字可以是字符串类型，而每一项中可以包含正则表达式。</li><li>复杂主要体现在：Bash中case的每一个项后有三个选择：break(常规的break)、unconditional follow up(无条件继续)和conditional follow up(有条件继续)。</li></ol><p>这篇文章的重点是上面的第2点。</p><blockquote><p><code>注意</code>: case的无条件继续和有条件继续是bash 4.1.x及之后的版本中才有的特性。</p></blockquote><p>执行如下命令可以查看你当前bash的版本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token environment constant">$BASH_VERSION</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>常规的break是在每一项后面加;;</li><li>无条件继续是在每一项后面加;&amp;</li><li>有条件继续实在每一项后面加;;&amp;</li></ul><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token builtin class-name">echo</span> <span class="token string">"Test No.1 ..."</span><span class="token keyword">case</span> <span class="token string">"1"</span> <span class="token keyword">in</span>    <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'1'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>    <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'2'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token number">3</span><span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'3'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span>    ?<span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'?'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span>    *<span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'*'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">esac</span><span class="token builtin class-name">echo</span> <span class="token string">"Test No.2 ..."</span><span class="token keyword">case</span> <span class="token string">"1"</span> <span class="token keyword">in</span>    <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'1'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'2'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>    <span class="token number">3</span><span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'3'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span>    ?<span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'?'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span>    *<span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'*'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">esac</span><span class="token builtin class-name">echo</span> <span class="token string">"Test No.3 ..."</span><span class="token keyword">case</span> <span class="token string">"1"</span> <span class="token keyword">in</span>    <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'1'</span>        <span class="token punctuation">;</span><span class="token operator">&amp;</span>    <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'2'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token number">3</span><span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'3'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span>    ?<span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'?'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span>    *<span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'*'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">esac</span><span class="token builtin class-name">echo</span> <span class="token string">"Test No.4 ..."</span><span class="token keyword">case</span> <span class="token string">"1"</span> <span class="token keyword">in</span>    <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'1'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'2'</span>        <span class="token punctuation">;</span><span class="token operator">&amp;</span>    <span class="token number">3</span><span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'3'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span>    ?<span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'?'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span>    *<span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'*'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">esac</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><pre class="line-numbers language-text" data-language="text"><code class="language-text">Test No.1 ...1?Test No.2 ...1Test No.3 ...12Test No.4 ...1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个带参数解析的Shell例子</title>
      <link href="yi-ge-dai-can-shu-jie-xi-de-shell-li-zi/"/>
      <url>yi-ge-dai-can-shu-jie-xi-de-shell-li-zi/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment"># Program:</span><span class="token comment">#   LZSH server log filter</span><span class="token comment"># History:</span><span class="token comment">#   2014/07/01  Kom     First release</span><span class="token comment">#   2014/07/03  Kom     Remote and multi-param support</span><span class="token comment">#   2014/07/18  Kom     Fix multi keyword bug</span><span class="token comment">#   2014/07/18  Kom     Continue exe even if some cmd failed</span><span class="token comment">#   2014/07/18  Kom     optimize</span><span class="token comment"># Set PATH</span><span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span>/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<span class="token builtin class-name">export</span> <span class="token environment constant">PATH</span><span class="token comment">#Disable filename globbing</span><span class="token builtin class-name">set</span> -f<span class="token comment"># Set script name variable</span><span class="token assign-left variable">SCRIPT</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">basename</span> $<span class="token punctuation">{</span><span class="token environment constant">BASH_SOURCE</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token variable">`</span></span><span class="token assign-left variable">SCRIPT_VER</span><span class="token operator">=</span><span class="token number">20140718</span>-1809<span class="token comment"># Initialize variables to default values</span><span class="token assign-left variable">IP</span><span class="token operator">=</span><span class="token assign-left variable"><span class="token environment constant">USER</span></span><span class="token operator">=</span><span class="token assign-left variable">TMPOUTPUT</span><span class="token operator">=</span><span class="token builtin class-name">declare</span> -a KEYS<span class="token builtin class-name">declare</span> -a INPUTS<span class="token assign-left variable">OUTPUT</span><span class="token operator">=</span><span class="token comment"># Set fonts for help</span><span class="token assign-left variable">NORM</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span>tput sgr0<span class="token variable">`</span></span><span class="token assign-left variable">BOLD</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span>tput bold<span class="token variable">`</span></span><span class="token assign-left variable">REV</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span>tput smso<span class="token variable">`</span></span><span class="token comment"># Help function</span><span class="token keyword">function</span> <span class="token function-name function">HELP</span><span class="token punctuation">{</span>    <span class="token builtin class-name">echo</span> -e <span class="token punctuation">\</span>n<span class="token string">"<span class="token variable">${BOLD}</span>龙之守护数据过滤脚本<span class="token variable">${SCRIPT}</span><span class="token variable">${NORM}</span>的帮助文档"</span>    <span class="token builtin class-name">echo</span> -e <span class="token string">"<span class="token variable">${BOLD}</span>版本：<span class="token variable">${SCRIPT_VER}</span><span class="token variable">${NORM}</span>"</span><span class="token punctuation">\</span>n    <span class="token builtin class-name">echo</span> -e <span class="token string">"<span class="token variable">${REV}</span>用法:<span class="token variable">${NORM}</span> <span class="token variable">${BOLD}</span><span class="token variable">$SCRIPT</span> 参数<span class="token variable">${NORM}</span>"</span><span class="token punctuation">\</span>n    <span class="token builtin class-name">echo</span> <span class="token string">"可选参数:"</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">${REV}</span>-a<span class="token variable">${NORM}</span>  --输入文件所在的IP，为空表示本地（默认为空）"</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">${REV}</span>-u<span class="token variable">${NORM}</span>  --访问输入文件所用的用户名，当文件在本地时不使用此参数"</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">${REV}</span>-k<span class="token variable">${NORM}</span>  --用于过滤的关键字，此参数可以多个联合使用(例如：-k物品创建 -k强化石)"</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">${REV}</span>-i<span class="token variable">${NORM}</span>  --输入文件的全路径，此参数可以多个联合使用(例如：-i/home/log/objscenesserver21.log.140701-* -i/home/log/objscenesserver40.log.140701-*)"</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">${REV}</span>-o<span class="token variable">${NORM}</span>  --本地输出文件的全路径(例如：-o/local/lzsh.log)"</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">${REV}</span>-t<span class="token variable">${NORM}</span>  --临时输出文件的全路径，当文件在本地时不使用此参数"</span>    <span class="token builtin class-name">echo</span> -e <span class="token string">"<span class="token variable">${REV}</span>-h<span class="token variable">${NORM}</span>  --显示此帮助并退出"</span><span class="token punctuation">\</span>n    <span class="token builtin class-name">echo</span> -e <span class="token string">"示例: "</span>    <span class="token builtin class-name">echo</span> -e <span class="token string">"<span class="token variable">${BOLD}</span><span class="token variable">$SCRIPT</span> -a127.0.0.1 -uUsername -k物品创建 -k强化石 -i/home/log/objscenesserver21.log.140701-* -o/local/lzsh.log -t/tmp/lzsh.log<span class="token variable">${NORM}</span>"</span><span class="token punctuation">\</span>n    <span class="token builtin class-name">exit</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token comment"># Check the number of argument. If none are passed, print help and exit.</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$#</span> -eq <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>    HELP<span class="token keyword">else</span>    <span class="token builtin class-name">echo</span> <span class="token string">"输入参数：<span class="token variable">${BOLD}</span><span class="token variable">$*</span><span class="token variable">${NORM}</span>"</span><span class="token keyword">fi</span><span class="token keyword">while</span> <span class="token builtin class-name">getopts</span> :a:u:t:i:o:k:h FLAG<span class="token punctuation">;</span> <span class="token keyword">do</span>    <span class="token keyword">case</span> <span class="token variable">$FLAG</span> <span class="token keyword">in</span>        a<span class="token punctuation">)</span>            <span class="token assign-left variable">IP</span><span class="token operator">=</span><span class="token variable">$OPTARG</span>            <span class="token punctuation">;</span><span class="token punctuation">;</span>        u<span class="token punctuation">)</span>            <span class="token assign-left variable"><span class="token environment constant">USER</span></span><span class="token operator">=</span><span class="token variable">$OPTARG</span>            <span class="token punctuation">;</span><span class="token punctuation">;</span>        t<span class="token punctuation">)</span>            <span class="token assign-left variable">TMPOUTPUT</span><span class="token operator">=</span><span class="token variable">$OPTARG</span>            <span class="token punctuation">;</span><span class="token punctuation">;</span>        i<span class="token punctuation">)</span>            <span class="token assign-left variable">INPUTS</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token variable">${INPUTS<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span> <span class="token variable">$OPTARG</span><span class="token punctuation">)</span>            <span class="token punctuation">;</span><span class="token punctuation">;</span>        o<span class="token punctuation">)</span>            <span class="token assign-left variable">OUTPUT</span><span class="token operator">=</span><span class="token variable">$OPTARG</span>            <span class="token punctuation">;</span><span class="token punctuation">;</span>        k<span class="token punctuation">)</span>            <span class="token assign-left variable">KEYS</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token variable">${KEYS<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span> <span class="token variable">$OPTARG</span><span class="token punctuation">)</span>            <span class="token punctuation">;</span><span class="token punctuation">;</span>        h<span class="token punctuation">)</span> <span class="token comment"># show help</span>            HELP            <span class="token punctuation">;</span><span class="token punctuation">;</span>        ?<span class="token punctuation">)</span> <span class="token comment"># unrecognized option - show help</span>            <span class="token builtin class-name">echo</span> -e <span class="token punctuation">\</span>n<span class="token string">"非法参数：-<span class="token variable">${BOLD}</span><span class="token variable">$OPTARG</span><span class="token variable">${NORM}</span>"</span>            HELP            <span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token keyword">esac</span><span class="token keyword">done</span><span class="token builtin class-name">shift</span> <span class="token variable"><span class="token variable">$((</span>OPTIND<span class="token operator">-</span><span class="token number">1</span><span class="token variable">))</span></span> <span class="token comment">#  This tells getopts to move on to the next argument</span><span class="token comment">#######################################################################</span><span class="token comment"># Parameters check</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">${<span class="token operator">#</span>KEYS}</span> -eq <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>    <span class="token builtin class-name">echo</span> <span class="token string">"你必须指定至少一个<span class="token variable">${BOLD}</span>关键字<span class="token variable">${NORM}</span>"</span>    <span class="token builtin class-name">exit</span> -1<span class="token keyword">else</span>    <span class="token builtin class-name">echo</span> <span class="token string">"关键字：<span class="token variable">${BOLD}</span><span class="token variable">${KEYS<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span><span class="token variable">${NORM}</span>"</span><span class="token keyword">fi</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">${<span class="token operator">#</span>INPUTS}</span> -eq <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>    <span class="token builtin class-name">echo</span> <span class="token string">"你必须指定至少一个<span class="token variable">${BOLD}</span>输入文件<span class="token variable">${NORM}</span>"</span>    <span class="token builtin class-name">exit</span> -1<span class="token keyword">else</span>    <span class="token builtin class-name">echo</span> <span class="token string">"输入文件：<span class="token variable">${BOLD}</span><span class="token variable">${INPUTS<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span><span class="token variable">${NORM}</span>"</span><span class="token keyword">fi</span><span class="token keyword">if</span> <span class="token punctuation">[</span> -z <span class="token variable">$OUTPUT</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>    <span class="token builtin class-name">echo</span> <span class="token string">"你必须指定<span class="token variable">${BOLD}</span>本地输出文件<span class="token variable">${NORM}</span>"</span>    <span class="token builtin class-name">exit</span> -1<span class="token keyword">fi</span><span class="token builtin class-name">echo</span> <span class="token string">"输出文件：<span class="token variable">${BOLD}</span><span class="token variable">${OUTPUT<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span><span class="token variable">${NORM}</span>"</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> -z <span class="token variable">$IP</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>    <span class="token keyword">if</span> <span class="token punctuation">[</span> -z <span class="token environment constant">$USER</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>        <span class="token builtin class-name">echo</span> <span class="token string">"必须指定用于访问<span class="token variable">${BOLD}</span><span class="token variable">${IP}</span><span class="token variable">${NORM}</span>的<span class="token variable">${BOLD}</span>用户名<span class="token variable">${NORM}</span>"</span>        <span class="token builtin class-name">exit</span> -1    <span class="token keyword">fi</span>    <span class="token keyword">if</span> <span class="token punctuation">[</span> -z <span class="token variable">$TMPOUTPUT</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>        <span class="token builtin class-name">echo</span> <span class="token string">"必须指定在<span class="token variable">${BOLD}</span><span class="token variable">${IP}</span><span class="token variable">${NORM}</span>上的<span class="token variable">${BOLD}</span>临时输出文件<span class="token variable">${NORM}</span>"</span>        <span class="token builtin class-name">exit</span> -1    <span class="token keyword">fi</span><span class="token keyword">fi</span><span class="token comment">#######################################################################</span><span class="token comment"># Work</span><span class="token assign-left variable">TARGETOUTPUT</span><span class="token operator">=</span><span class="token string">""</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> -z <span class="token variable">$IP</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>    <span class="token assign-left variable">TARGETOUTPUT</span><span class="token operator">=</span><span class="token variable">$TMPOUTPUT</span><span class="token keyword">else</span>    <span class="token assign-left variable">TARGETOUTPUT</span><span class="token operator">=</span><span class="token variable">$OUTPUT</span><span class="token keyword">fi</span><span class="token assign-left variable">CMD</span><span class="token operator">=</span><span class="token string">""</span><span class="token keyword">for</span> <span class="token for-or-select variable">k</span> <span class="token keyword">in</span> <span class="token variable">${KEYS<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span><span class="token keyword">do</span>    <span class="token assign-left variable">CMD</span><span class="token operator">=</span><span class="token variable">${CMD}</span><span class="token string">"grep <span class="token variable">$k</span> <span class="token variable">${INPUTS<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span> &gt;&gt; <span class="token variable">$TARGETOUTPUT</span>; "</span><span class="token keyword">done</span><span class="token assign-left variable">CMD</span><span class="token operator">=</span><span class="token string">"echo &gt; <span class="token variable">$TARGETOUTPUT</span>; <span class="token variable">$CMD</span>"</span><span class="token builtin class-name">echo</span> <span class="token variable">$CMD</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> -z <span class="token variable">$IP</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>    <span class="token builtin class-name">echo</span> -e <span class="token punctuation">\</span>n<span class="token string">"将要执行ssh命令："</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">${BOLD}</span>ssh <span class="token environment constant">$USER</span>@<span class="token variable">$IP</span> "</span><span class="token variable">$CMD</span><span class="token string">"<span class="token variable">${NORM}</span>"</span>    <span class="token function">sh</span> -c <span class="token string">"ssh <span class="token environment constant">$USER</span>@<span class="token variable">$IP</span> "</span><span class="token variable">$CMD</span><span class="token string">""</span>    <span class="token builtin class-name">echo</span> -e <span class="token punctuation">\</span>n<span class="token string">"将要执行scp命令："</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">${BOLD}</span>scp <span class="token environment constant">$USER</span>@<span class="token variable">$IP</span>:<span class="token variable">$TMPOUTPUT</span> <span class="token variable">$OUTPUT</span><span class="token variable">${NORM}</span>"</span>    <span class="token function">sh</span> -c <span class="token string">"scp <span class="token environment constant">$USER</span>@<span class="token variable">$IP</span>:<span class="token variable">$TMPOUTPUT</span> <span class="token variable">$OUTPUT</span>"</span><span class="token keyword">else</span>    <span class="token builtin class-name">echo</span> -e <span class="token punctuation">\</span>n<span class="token string">"将要执行命令："</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">${BOLD}</span><span class="token variable">$CMD</span><span class="token variable">${NORM}</span>"</span>    <span class="token function">sh</span> -c <span class="token string">"<span class="token variable">$CMD</span>"</span><span class="token keyword">fi</span><span class="token builtin class-name">exit</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win32程序发生异常时处理的流程</title>
      <link href="win32-cheng-xu-fa-sheng-yi-chang-shi-chu-li-de-liu-cheng/"/>
      <url>win32-cheng-xu-fa-sheng-yi-chang-shi-chu-li-de-liu-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="一、程序没有被调试"><a href="#一、程序没有被调试" class="headerlink" title="一、程序没有被调试"></a>一、程序没有被调试</h2><ol><li>线程建立时，系统安装一个系统线程异常处理例程。</li><li>异常发生时，Win2K/XP控制权转移给NTDLL.KiUserExceptionDispatcher。</li><li>如果你安装了线程相关的异常处理例程，系统就把异常发送给你的处理例程，交由其处理。</li><li>每个线程相关的异常处理例程可以处理或者不处理这个异常,如果他不处理并且安装了多个线程相关的异常处理例程，可交由链起来的其他例程处理。</li><li>如果这些例程均选择不处理异常，系统线程异常处理例程将起作用，调用ZwQueryInformationProcess判断是否被调试，没有调试并且你调用SetUnhandledExceptionFilter安装了最后异常处理例程的话，系统转向对它的调用。</li><li>如果你没有安装最后异常处理例程或者他没有处理这个异常，系统会调用默认的系统处理程序，通常显示一个对话框，你可以选择关闭或者最后将其附加到调试器上的调试按钮。如果没有调试器能被附加于其上或者调试器也处理不了，系统就调用ExitProcess终结程序。</li><li>不过在终结之前，系统仍然对发生异常的线程异常处理句柄来一次展开，这是线程异常处理例程最后清理的机会。一般只用来释放资源，不要试图修复什么。注意只对线程异常有展开。</li></ol><h2 id="二、程序被调试"><a href="#二、程序被调试" class="headerlink" title="二、程序被调试"></a>二、程序被调试</h2><ol><li>线程建立时，系统安装一个系统线程异常处理例程。</li><li>异常发生时，系统挂起程序并向调试器发送。EXCEPTION_DEBUG_EVENT消息。</li><li>调试器未能处理异常(比如我们在OD里按Shift+F7)，控制权转移给 NTDLL。KiUserExceptionDispatcher如果你安装了线程相关的异常处理例程，系统就把异常发送给你的程序seh处理例程，交由其处理。</li><li>每个线程相关的异常处理例程可以处理或者不处理这个异常，如果他不处理并且安装了多个线程相关的异常处理例程，可交由链起来的其他例程处理。</li><li>如果这些例程均选择不处理异常，系统线程异常处理例程将起作用，调用ZwQueryInformationProcess判断是否被调试。</li><li>由于被调试，操作系统仍会再次挂起程序通知debugger。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++重载内存分配时需要注意的地方</title>
      <link href="c-chong-zai-nei-cun-fen-pei-shi-xu-yao-zhu-yi-de-di-fang/"/>
      <url>c-chong-zai-nei-cun-fen-pei-shi-xu-yao-zhu-yi-de-di-fang/</url>
      
        <content type="html"><![CDATA[<h2 id="一、测试代码"><a href="#一、测试代码" class="headerlink" title="一、测试代码"></a>一、测试代码</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;new&gt;</span></span><span class="token comment">//#define VF</span><span class="token comment">//#define FLAG</span><span class="token keyword">class</span> <span class="token class-name">MemObj</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">VF</span></span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">MemObj</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">// VF</span></span>    <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t stSize<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"operator new(size_t) %d\n"</span><span class="token punctuation">,</span> stSize<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">malloc</span><span class="token punctuation">(</span>stSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">FLAG</span></span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> pMemory<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"operator delete(void*)\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>pMemory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> pMemory<span class="token punctuation">,</span> size_t stSize<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"operator delete(void*, size_t) %d\n"</span><span class="token punctuation">,</span> stSize<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>pMemory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">MemObj</span></span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> m_nValue<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span><span class="token punctuation">{</span>    MemObj<span class="token operator">*</span> pObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">MemObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> pObj<span class="token punctuation">;</span>    Test<span class="token operator">*</span> pTest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> pTest<span class="token punctuation">;</span>    pObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> pObj<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、测试"><a href="#二、测试" class="headerlink" title="二、测试"></a>二、测试</h2><p>通过控制宏VF和宏FLAG的定义与否来查看各个情况下代码运行的结果。</p><h3 id="测试1：不定义宏VF和FLAG"><a href="#测试1：不定义宏VF和FLAG" class="headerlink" title="测试1：不定义宏VF和FLAG"></a>测试1：不定义宏VF和FLAG</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">operator new(size_t) 1operator delete(void*, size_t) 1operator new(size_t) 4operator delete(void*, size_t) 1operator new(size_t) 4operator delete(void*, size_t) 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="测试2：定义宏FLAG但不定义宏VF"><a href="#测试2：定义宏FLAG但不定义宏VF" class="headerlink" title="测试2：定义宏FLAG但不定义宏VF"></a>测试2：定义宏FLAG但不定义宏VF</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">operator new(size_t) 1operator delete(void*)operator new(size_t) 4operator delete(void*)operator new(size_t) 4operator delete(void*)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="测试3：定义宏VF但不定义宏FLAG"><a href="#测试3：定义宏VF但不定义宏FLAG" class="headerlink" title="测试3：定义宏VF但不定义宏FLAG"></a>测试3：定义宏VF但不定义宏FLAG</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">operator new(size_t) 4operator delete(void*, size_t) 4operator new(size_t) 8operator delete(void*, size_t) 8operator new(size_t) 8operator delete(void*, size_t) 8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="测试4：同时定义宏VF和FLAG"><a href="#测试4：同时定义宏VF和FLAG" class="headerlink" title="测试4：同时定义宏VF和FLAG"></a>测试4：同时定义宏VF和FLAG</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">operator new(size_t) 4operator delete(void*)operator new(size_t) 8operator delete(void*)operator new(size_t) 8operator delete(void*)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、结果分析"><a href="#三、结果分析" class="headerlink" title="三、结果分析"></a>三、结果分析</h2><h3 id="1-对比测试1和测试2"><a href="#1-对比测试1和测试2" class="headerlink" title="1. 对比测试1和测试2"></a>1. 对比测试1和测试2</h3><p>重载了operator new(size_t stSize)后，在删除的时候：</p><ol><li>如果没有定义<code>void operator delete(void* pMemory)，那么会调用void operator delete(void* pMemory, size_t stSize)</code>；</li><li>如果定义了<code>void operator delete(void* pMemory)，不管是否定义void operator delete(void* pMemory, size_t stSize)都会调用void operator delete(void* pMemory)</code>。</li></ol><p>结论：<br>重载operator new(size_t)后，如果同时重载了operator delete(void<em>)，删除时候会调用operator delete(void</em>)，否则才会调用operator delete(void*, size_t)。</p><h3 id="2-对比测试1和测试3"><a href="#2-对比测试1和测试3" class="headerlink" title="2. 对比测试1和测试3"></a>2. 对比测试1和测试3</h3><p>如果不将基类的析构函数定义为虚析构函数，会有内存泄漏。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win32下FS寄存器、TEB和PEB详解</title>
      <link href="win32-xia-fs-ji-cun-qi-teb-he-peb-xiang-jie/"/>
      <url>win32-xia-fs-ji-cun-qi-teb-he-peb-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>在Win32下，FS段寄存器指向当前的TEB结构，在TEB编译0x30处是PEB指针，通过这个指针即可获得PED的地址。</p><p>实现方法：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">__asm<span class="token punctuation">{</span>    mov eax<span class="token punctuation">,</span> fs<span class="token operator">:</span><span class="token punctuation">[</span><span class="token number">0x30</span><span class="token punctuation">]</span>    mov PED<span class="token punctuation">,</span> eax<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TEB和PEB的结构如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">PEB_BASE</span> <span class="token punctuation">(</span><span class="token number">0x7ffdf000</span><span class="token punctuation">)</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_NT_TIB</span><span class="token punctuation">{</span>                                           <span class="token comment">// Size: 01C</span>    <span class="token keyword">struct</span> <span class="token class-name">_EXCEPTION_REGISTRATION_RECORD</span> <span class="token operator">*</span>ExceptionList<span class="token punctuation">;</span> <span class="token comment">// 000</span>    PVOID StackBase<span class="token punctuation">;</span>                        <span class="token comment">// 004</span>    PVOID StackLimit<span class="token punctuation">;</span>                       <span class="token comment">// 008</span>    PVOID SubSystemTib<span class="token punctuation">;</span>                     <span class="token comment">// 00C</span>    <span class="token keyword">union</span>                                   <span class="token comment">// 010</span>    <span class="token punctuation">{</span>        PVOID FiberData<span class="token punctuation">;</span>        ULONG Version<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    PVOID ArbitraryUserPointer<span class="token punctuation">;</span>             <span class="token comment">// 014</span>    <span class="token keyword">struct</span> <span class="token class-name">_NT_TIB</span> <span class="token operator">*</span>Self<span class="token punctuation">;</span>                   <span class="token comment">// 018</span><span class="token punctuation">}</span> NT_TIB<span class="token punctuation">,</span> <span class="token operator">*</span>PNT_TIB<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_TEB</span><span class="token punctuation">{</span>                                           <span class="token comment">// Size:  FBC</span>    NT_TIB Tib<span class="token punctuation">;</span>                             <span class="token comment">// 000</span>    PVOID EnvironmentPointer<span class="token punctuation">;</span>               <span class="token comment">// 01C</span>    CLIENT_ID Cid<span class="token punctuation">;</span>                          <span class="token comment">// 020</span>    PVOID ActiveRpcHandle<span class="token punctuation">;</span>                  <span class="token comment">// 028</span>    PVOID ThreadLocalStoragePointer<span class="token punctuation">;</span>        <span class="token comment">// 02C</span>    <span class="token keyword">struct</span> <span class="token class-name">_PEB</span> <span class="token operator">*</span>ProcessEnvironmentBlock<span class="token punctuation">;</span>   <span class="token comment">// 030</span>    ULONG LastErrorValue<span class="token punctuation">;</span>                   <span class="token comment">// 034</span>    ULONG CountOfOwnedCriticalSections<span class="token punctuation">;</span>     <span class="token comment">// 038</span>    PVOID CsrClientThread<span class="token punctuation">;</span>                  <span class="token comment">// 03C</span>    <span class="token keyword">struct</span> <span class="token class-name">_W32THREAD</span><span class="token operator">*</span> Win32ThreadInfo<span class="token punctuation">;</span>     <span class="token comment">// 040</span>    ULONG User32Reserved<span class="token punctuation">[</span><span class="token number">0x1A</span><span class="token punctuation">]</span><span class="token punctuation">;</span>             <span class="token comment">// 044</span>    ULONG UserReserved<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                  <span class="token comment">// 0AC</span>    PVOID WOW32Reserved<span class="token punctuation">;</span>                    <span class="token comment">// 0C0</span>    LCID CurrentLocale<span class="token punctuation">;</span>                     <span class="token comment">// 0C4</span>    ULONG FpSoftwareStatusRegister<span class="token punctuation">;</span>         <span class="token comment">// 0C8</span>    PVOID SystemReserved1<span class="token punctuation">[</span><span class="token number">0x36</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">// 0CC</span>    LONG ExceptionCode<span class="token punctuation">;</span>                     <span class="token comment">// 1A4</span>    <span class="token keyword">struct</span> <span class="token class-name">_ACTIVATION_CONTEXT_STACK</span> <span class="token operator">*</span>ActivationContextStackPointer<span class="token punctuation">;</span> <span class="token comment">// 1A8</span>    UCHAR SpareBytes1<span class="token punctuation">[</span><span class="token number">0x28</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment">// 1AC</span>    GDI_TEB_BATCH GdiTebBatch<span class="token punctuation">;</span>              <span class="token comment">// 1D4</span>    CLIENT_ID RealClientId<span class="token punctuation">;</span>                 <span class="token comment">// 6B4</span>    PVOID GdiCachedProcessHandle<span class="token punctuation">;</span>           <span class="token comment">// 6BC</span>    ULONG GdiClientPID<span class="token punctuation">;</span>                     <span class="token comment">// 6C0</span>    ULONG GdiClientTID<span class="token punctuation">;</span>                     <span class="token comment">// 6C4</span>    PVOID GdiThreadLocalInfo<span class="token punctuation">;</span>               <span class="token comment">// 6C8</span>    ULONG Win32ClientInfo<span class="token punctuation">[</span><span class="token number">62</span><span class="token punctuation">]</span><span class="token punctuation">;</span>              <span class="token comment">// 6CC</span>    PVOID glDispatchTable<span class="token punctuation">[</span><span class="token number">0xE9</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">// 7C4</span>    ULONG glReserved1<span class="token punctuation">[</span><span class="token number">0x1D</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment">// B68</span>    PVOID glReserved2<span class="token punctuation">;</span>                      <span class="token comment">// BDC</span>    PVOID glSectionInfo<span class="token punctuation">;</span>                    <span class="token comment">// BE0</span>    PVOID glSection<span class="token punctuation">;</span>                        <span class="token comment">// BE4</span>    PVOID glTable<span class="token punctuation">;</span>                          <span class="token comment">// BE8</span>    PVOID glCurrentRC<span class="token punctuation">;</span>                      <span class="token comment">// BEC</span>    PVOID glContext<span class="token punctuation">;</span>                        <span class="token comment">// BF0</span>    NTSTATUS LastStatusValue<span class="token punctuation">;</span>               <span class="token comment">// BF4</span>    UNICODE_STRING StaticUnicodeString<span class="token punctuation">;</span>     <span class="token comment">// BF8</span>    WCHAR StaticUnicodeBuffer<span class="token punctuation">[</span><span class="token number">0x105</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">// C00</span>    PVOID DeallocationStack<span class="token punctuation">;</span>                <span class="token comment">// E0C</span>    PVOID TlsSlots<span class="token punctuation">[</span><span class="token number">0x40</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                   <span class="token comment">// E10</span>    LIST_ENTRY TlsLinks<span class="token punctuation">;</span>                    <span class="token comment">// F10</span>    PVOID Vdm<span class="token punctuation">;</span>                              <span class="token comment">// F18</span>    PVOID ReservedForNtRpc<span class="token punctuation">;</span>                 <span class="token comment">// F1C</span>    PVOID DbgSsReserved<span class="token punctuation">[</span><span class="token number">0x2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>               <span class="token comment">// F20</span>    ULONG HardErrorDisabled<span class="token punctuation">;</span>                <span class="token comment">// F28</span>    PVOID Instrumentation<span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">;</span>              <span class="token comment">// F2C</span>    PVOID SubProcessTag<span class="token punctuation">;</span>                    <span class="token comment">// F64</span>    PVOID EtwTraceData<span class="token punctuation">;</span>                     <span class="token comment">// F68</span>    PVOID WinSockData<span class="token punctuation">;</span>                      <span class="token comment">// F6C</span>    ULONG GdiBatchCount<span class="token punctuation">;</span>                    <span class="token comment">// F70</span>    BOOLEAN InDbgPrint<span class="token punctuation">;</span>                     <span class="token comment">// F74</span>    BOOLEAN FreeStackOnTermination<span class="token punctuation">;</span>         <span class="token comment">// F75</span>    BOOLEAN HasFiberData<span class="token punctuation">;</span>                   <span class="token comment">// F76</span>    UCHAR IdealProcessor<span class="token punctuation">;</span>                   <span class="token comment">// F77</span>    ULONG GuaranteedStackBytes<span class="token punctuation">;</span>             <span class="token comment">// F78</span>    PVOID ReservedForPerf<span class="token punctuation">;</span>                  <span class="token comment">// F7C</span>    PVOID ReservedForOle<span class="token punctuation">;</span>                   <span class="token comment">// F80</span>    ULONG WaitingOnLoaderLock<span class="token punctuation">;</span>              <span class="token comment">// F84</span>    ULONG SparePointer1<span class="token punctuation">;</span>                    <span class="token comment">// F88</span>    ULONG SoftPatchPtr1<span class="token punctuation">;</span>                    <span class="token comment">// F8C</span>    ULONG SoftPatchPtr2<span class="token punctuation">;</span>                    <span class="token comment">// F90</span>    PVOID <span class="token operator">*</span>TlsExpansionSlots<span class="token punctuation">;</span>               <span class="token comment">// F94</span>    ULONG ImpersionationLocale<span class="token punctuation">;</span>             <span class="token comment">// F98</span>    ULONG IsImpersonating<span class="token punctuation">;</span>                  <span class="token comment">// F9C</span>    PVOID NlsCache<span class="token punctuation">;</span>                         <span class="token comment">// FA0</span>    PVOID pShimData<span class="token punctuation">;</span>                        <span class="token comment">// FA4</span>    ULONG HeapVirualAffinity<span class="token punctuation">;</span>               <span class="token comment">// FA8</span>    PVOID CurrentTransactionHandle<span class="token punctuation">;</span>         <span class="token comment">// FAC</span>    PTEB_ACTIVE_FRAME ActiveFrame<span class="token punctuation">;</span>          <span class="token comment">// FB0</span>    PVOID FlsData<span class="token punctuation">;</span>                          <span class="token comment">// FB4</span>    UCHAR SafeThunkCall<span class="token punctuation">;</span>                    <span class="token comment">// FB8</span>    UCHAR BooleanSpare<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                  <span class="token comment">// FB9</span><span class="token punctuation">}</span> TEB<span class="token punctuation">,</span> <span class="token operator">*</span>PTEB<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_LIST_ENTRY</span><span class="token punctuation">{</span>                                           <span class="token comment">// Size: 008</span>    <span class="token keyword">struct</span> <span class="token class-name">_LIST_ENTRY</span> <span class="token operator">*</span>Flink<span class="token punctuation">;</span>              <span class="token comment">// 000 从前到后</span>    <span class="token keyword">struct</span> <span class="token class-name">_LIST_ENTRY</span> <span class="token operator">*</span>Blink<span class="token punctuation">;</span>              <span class="token comment">// 004 从后到前</span><span class="token punctuation">}</span> LIST_ENTRY<span class="token punctuation">,</span> <span class="token operator">*</span>PLIST_ENTRY<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_PER_LDR_DATA</span><span class="token punctuation">{</span>                                           <span class="token comment">// Size: 0024</span>    ULONG Length<span class="token punctuation">;</span>                           <span class="token comment">// 000</span>    BOOLEAN Initialize<span class="token punctuation">;</span>                     <span class="token comment">// 004</span>    PVOID SsHandle<span class="token punctuation">;</span>                         <span class="token comment">// 008</span>    LIST_ENTRY InLoadOrderModuleList<span class="token punctuation">;</span>       <span class="token comment">// 00C</span>    LIST_ENTRY InMemoryOrderModuleList<span class="token punctuation">;</span>     <span class="token comment">// 014</span>    LIST_ENTRY InInitializationOrderModuleList<span class="token punctuation">;</span> <span class="token comment">// 01C</span><span class="token punctuation">}</span> PER_LDR_DATA<span class="token punctuation">,</span> <span class="token operator">*</span>PPER_LDR_DATA<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_UNICODE_STRING</span><span class="token punctuation">{</span>                                           <span class="token comment">// Size: 008</span>  USHORT  Length<span class="token punctuation">;</span>                           <span class="token comment">// 000 占用的内存字节数，个数*2；</span>  USHORT  MaximumLength<span class="token punctuation">;</span>                    <span class="token comment">// 002</span>  PWSTR  Buffer<span class="token punctuation">;</span>                            <span class="token comment">// 004</span><span class="token punctuation">}</span> UNICODE_STRING <span class="token punctuation">,</span><span class="token operator">*</span>PUNICODE_STRING<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_LDR_DATA_TABLE_ENTRY</span><span class="token punctuation">{</span>                                           <span class="token comment">// Size: 050</span>     LIST_ENTRY InLoadOrderLinks<span class="token punctuation">;</span>           <span class="token comment">// 000 LIST_ENTRY里的Flink和Blink其实是指向LDR_MODULE结构，即LDR_DATA_TABLE_ENTRY</span>     LIST_ENTRY InMemoryOrderLinks<span class="token punctuation">;</span>         <span class="token comment">// 008 同上</span>     LIST_ENTRY InInitializationOrderLinks<span class="token punctuation">;</span> <span class="token comment">// 010 同上</span>     PVOID DllBase<span class="token punctuation">;</span>                         <span class="token comment">// 018</span>     PVOID EntryPoint<span class="token punctuation">;</span>                      <span class="token comment">// 01C</span>     ULONG SizeOfImage<span class="token punctuation">;</span>                     <span class="token comment">// 020</span>     UNICODE_STRING FullDllName<span class="token punctuation">;</span>            <span class="token comment">// 024</span>     UNICODE_STRING BaseDllName<span class="token punctuation">;</span>            <span class="token comment">// 02C</span>     ULONG Flags<span class="token punctuation">;</span>                           <span class="token comment">// 034</span>     WORD LoadCount<span class="token punctuation">;</span>                        <span class="token comment">// 038</span>     WORD TlsIndex<span class="token punctuation">;</span>                         <span class="token comment">// 03A</span>     <span class="token keyword">union</span>                                  <span class="token comment">// 03C</span>     <span class="token punctuation">{</span>          LIST_ENTRY HashLinks<span class="token punctuation">;</span>             <span class="token comment">// 03C</span>          <span class="token keyword">struct</span>          <span class="token punctuation">{</span>               PVOID SectionPointer<span class="token punctuation">;</span>        <span class="token comment">// 03C</span>               ULONG CheckSum<span class="token punctuation">;</span>              <span class="token comment">// 040</span>          <span class="token punctuation">}</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">;</span>     <span class="token keyword">union</span>     <span class="token punctuation">{</span>          ULONG TimeDateStamp<span class="token punctuation">;</span>              <span class="token comment">// 044</span>          PVOID LoadedImports<span class="token punctuation">;</span>              <span class="token comment">// 044</span>     <span class="token punctuation">}</span><span class="token punctuation">;</span>     _ACTIVATION_CONTEXT <span class="token operator">*</span> EntryPointActivationContext<span class="token punctuation">;</span> <span class="token comment">// 048</span>     PVOID PatchInformation<span class="token punctuation">;</span>                <span class="token comment">// 04C</span><span class="token punctuation">}</span> LDR_DATA_TABLE_ENTRY<span class="token punctuation">,</span> <span class="token operator">*</span>PLDR_DATA_TABLE_ENTRY<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_PEB</span><span class="token punctuation">{</span>                                           <span class="token comment">// Size: 1D8</span>    UCHAR InheritedAddressSpace<span class="token punctuation">;</span>            <span class="token comment">// 000</span>    UCHAR ReadImageFileExecOptions<span class="token punctuation">;</span>         <span class="token comment">// 001</span>    UCHAR BeingDebugged<span class="token punctuation">;</span>                    <span class="token comment">// 002</span>    UCHAR SpareBool<span class="token punctuation">;</span>                        <span class="token comment">// 003 Allocation size</span>    HANDLE Mutant<span class="token punctuation">;</span>                          <span class="token comment">// 004</span>    HINSTANCE ImageBaseAddress<span class="token punctuation">;</span>             <span class="token comment">// 008</span>    <span class="token keyword">struct</span> <span class="token class-name">_PER_LDR_DATA</span> <span class="token operator">*</span>Ldr<span class="token punctuation">;</span>              <span class="token comment">// 00C</span>    strcut _RTL_USER_PPROCESS_PARAMETERS <span class="token operator">*</span>ProcessParameters<span class="token punctuation">;</span> <span class="token comment">// 010</span>    ULONG SubSystemData<span class="token punctuation">;</span>                    <span class="token comment">// 014</span>    HANDLE DefaultHeap<span class="token punctuation">;</span>                     <span class="token comment">// 018</span>    KSPIN_LOCK FastPebLock<span class="token punctuation">;</span>                 <span class="token comment">// 01C</span>    ULONG FastPebLockRoutine<span class="token punctuation">;</span>               <span class="token comment">// 020</span>    ULONG FastPebUnlockRoutine<span class="token punctuation">;</span>             <span class="token comment">// 024</span>    ULONG EnvironmentUpdateCount<span class="token punctuation">;</span>           <span class="token comment">// 028</span>    ULONG KernelCallbackTable<span class="token punctuation">;</span>              <span class="token comment">// 02C</span>    LARGE_INTEGER SystemReserved<span class="token punctuation">;</span>           <span class="token comment">// 030</span>    <span class="token keyword">struct</span> <span class="token class-name">_PER_FREE_BLOCK</span> <span class="token operator">*</span>FreeList<span class="token punctuation">;</span>       <span class="token comment">// 038</span>    ULONG TlsExpansionCounter<span class="token punctuation">;</span>              <span class="token comment">// 03C</span>    ULONG TlsBitmap<span class="token punctuation">;</span>                        <span class="token comment">// 040</span>    LARGE_INTEGER TlsBitmapBits<span class="token punctuation">;</span>            <span class="token comment">// 044</span>    ULONG ReadOnlySharedMemoryBase<span class="token punctuation">;</span>         <span class="token comment">// 04C</span>    ULONG ReadOnlySharedMemoryHeap<span class="token punctuation">;</span>         <span class="token comment">// 050</span>    ULONG ReadOnlyStaticServerData<span class="token punctuation">;</span>         <span class="token comment">// 054</span>    ULONG AnsiCodePageData<span class="token punctuation">;</span>                 <span class="token comment">// 058</span>    ULONG OemCodePageData<span class="token punctuation">;</span>                  <span class="token comment">// 05C</span>    ULONG UnicodeCaseTableData<span class="token punctuation">;</span>             <span class="token comment">// 060</span>    ULONG NumberOfProcessors<span class="token punctuation">;</span>               <span class="token comment">// 064</span>    LARGE_INTEGER NtGlobalFlag<span class="token punctuation">;</span>             <span class="token comment">// 068 Address of a local copy</span>    LARGE_INTEGER CriticalSectionTimeout<span class="token punctuation">;</span>   <span class="token comment">// 070</span>    ULONG HeapSegmentReserve<span class="token punctuation">;</span>               <span class="token comment">// 078</span>    ULONG HeapSegmentCommit<span class="token punctuation">;</span>                <span class="token comment">// 07C</span>    ULONG HeapDeCommitTotalFreeThreshold<span class="token punctuation">;</span>   <span class="token comment">// 080</span>    ULONG HeapDeCommitFreeBlockThreshold<span class="token punctuation">;</span>   <span class="token comment">// 084</span>    ULONG NumberOfHeaps<span class="token punctuation">;</span>                    <span class="token comment">// 088</span>    ULONG MaximumNumberOfHeaps<span class="token punctuation">;</span>             <span class="token comment">// 08C</span>    ULONG ProcessHeaps<span class="token punctuation">;</span>                     <span class="token comment">// 090</span>    ULONG GdiSharedHandleTable<span class="token punctuation">;</span>             <span class="token comment">// 094</span>    ULONG ProcessStarterHelper<span class="token punctuation">;</span>             <span class="token comment">// 098</span>    ULONG GdiDCAttributeList<span class="token punctuation">;</span>               <span class="token comment">// 09C</span>    KSPIN_LOCK LoaderLock<span class="token punctuation">;</span>                  <span class="token comment">// 0A0</span>    ULONG OSMajorVersion<span class="token punctuation">;</span>                   <span class="token comment">// 0A4</span>    ULONG OSMinorVersion<span class="token punctuation">;</span>                   <span class="token comment">// 0A8</span>    USHORT OSBuildNumber<span class="token punctuation">;</span>                   <span class="token comment">// 0AC</span>    USHORT OSCSDVersion<span class="token punctuation">;</span>                    <span class="token comment">// 0AE</span>    ULONG OSPlatformId<span class="token punctuation">;</span>                     <span class="token comment">// 0B0</span>    ULONG ImageSubsystem<span class="token punctuation">;</span>                   <span class="token comment">// 0B4</span>    ULONG ImageSubsystemMajorVersion<span class="token punctuation">;</span>       <span class="token comment">// 0B8</span>    ULONG ImageSubsystemMinorVersion<span class="token punctuation">;</span>       <span class="token comment">// 0BC</span>    ULONG ImageProcessAffinityMask<span class="token punctuation">;</span>         <span class="token comment">// 0C0</span>    ULONG GdiHandleBuffer<span class="token punctuation">[</span><span class="token number">0x22</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">// 0C4</span>    ULONG PostProcessInitRoutine<span class="token punctuation">;</span>           <span class="token comment">// 14C</span>    ULONG TlsExpansionBitmap<span class="token punctuation">;</span>               <span class="token comment">// 150</span>    UCHAR TlsExpansionBitmapBits<span class="token punctuation">[</span><span class="token number">0x80</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// 154</span>    ULONG SessionId<span class="token punctuation">;</span>                        <span class="token comment">// 1D4</span><span class="token punctuation">}</span> PEB<span class="token punctuation">,</span> <span class="token operator">*</span>PPEB<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> 逆向工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>elf文件查看工具</title>
      <link href="elf-wen-jian-cha-kan-gong-ju/"/>
      <url>elf-wen-jian-cha-kan-gong-ju/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* * Copyright (c) 2013 Kiba Amor &lt;KibaAmor@gmai.com&gt; * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * *  * Redistributions of source code must retain the above copyright *    notice, this list ofconditions and the following disclaimer. * *  * Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materialsprovided with the *    distribution. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;elf.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">_countof</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">_countof</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token operator">/</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>X<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">safe_free</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>  <span class="token expression"><span class="token keyword">if</span> <span class="token punctuation">(</span>X <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> </span><span class="token punctuation">\</span>  <span class="token expression"><span class="token punctuation">{</span> </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token function">free</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">;</span> </span><span class="token punctuation">\</span>    <span class="token expression">X <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> </span><span class="token punctuation">\</span>  <span class="token expression"><span class="token punctuation">}</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>__x86_64__<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">ARCH </span><span class="token string">"x86_64"</span></span><span class="token keyword">typedef</span> Elf64_Ehdr Elf_Ehdr<span class="token punctuation">;</span><span class="token keyword">typedef</span> Elf64_Phdr Elf_Phdr<span class="token punctuation">;</span><span class="token keyword">typedef</span> Elf64_Shdr Elf_Shdr<span class="token punctuation">;</span><span class="token keyword">typedef</span> Elf64_Sym  Elf_Sym<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">ELF_ST_TYPE</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token function">ELF64_ST_TYPE</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">ELF_ST_BIND</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token function">ELF64_ST_BIND</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">ELF_ST_VISIBILITY</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token function">ELF64_ST_VISIBILITY</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span></span></span><span class="token keyword">typedef</span> Elf64_Rel  Elf_Rel<span class="token punctuation">;</span><span class="token keyword">typedef</span> Elf64_Rela Elf_Rela<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">ELF_R_SYM</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span>  <span class="token function">ELF64_R_SYM</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">ELF_R_TYPE</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token function">ELF64_R_TYPE</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">ARCH </span><span class="token string">"x86"</span></span><span class="token keyword">typedef</span> Elf32_Ehdr Elf_Ehdr<span class="token punctuation">;</span><span class="token keyword">typedef</span> Elf32_Phdr Elf_Phdr<span class="token punctuation">;</span><span class="token keyword">typedef</span> Elf32_Shdr Elf_Shdr<span class="token punctuation">;</span><span class="token keyword">typedef</span> Elf32_Sym  Elf_Sym<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">ELF_ST_TYPE</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token function">ELF32_ST_TYPE</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">ELF_ST_BIND</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token function">ELF32_ST_BIND</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">ELF_ST_VISIBILITY</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token function">ELF32_ST_VISIBILITY</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span></span></span><span class="token keyword">typedef</span> Elf32_Rel  Elf_Rel<span class="token punctuation">;</span><span class="token keyword">typedef</span> Elf32_Rela Elf_Rela<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">ELF_R_SYM</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span>  <span class="token function">ELF32_R_SYM</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">ELF_R_TYPE</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token function">ELF32_R_TYPE</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">// __x86_64__</span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>  <span class="token keyword">int</span>         key<span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> value<span class="token punctuation">;</span><span class="token punctuation">}</span> pair_t<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> g_selfname <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> g_filename <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">int</span>         g_file <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>Elf_Ehdr<span class="token operator">*</span>   g_ehdr <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>Elf_Phdr<span class="token operator">*</span>   g_phdrs <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">int</span>         g_phdr_num <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>Elf_Shdr<span class="token operator">*</span>   g_shdrs <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">int</span>         g_shdr_num <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span>       g_shdr_str_tab <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">clean_up</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>g_file <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">close</span><span class="token punctuation">(</span>g_file<span class="token punctuation">)</span><span class="token punctuation">;</span>    g_file <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">safe_free</span><span class="token punctuation">(</span>g_ehdr<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">safe_free</span><span class="token punctuation">(</span>g_phdrs<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">safe_free</span><span class="token punctuation">(</span>g_shdrs<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">safe_free</span><span class="token punctuation">(</span>g_shdr_str_tab<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">get_file</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>g_file <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    g_file <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>g_filename<span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>g_file <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open input file failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> g_file<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">read_at</span><span class="token punctuation">(</span><span class="token keyword">int</span> file<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> buf<span class="token punctuation">,</span> <span class="token keyword">int</span> cnt<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">==</span> <span class="token function">lseek</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> <span class="token constant">SEEK_SET</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token function">read</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> cnt<span class="token punctuation">)</span> <span class="token operator">==</span> cnt <span class="token operator">?</span> cnt <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">is_elf_file</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span> ident<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ident      <span class="token operator">||</span> ident<span class="token punctuation">[</span>EI_MAG0<span class="token punctuation">]</span> <span class="token operator">!=</span> ELFMAG0      <span class="token operator">||</span> ident<span class="token punctuation">[</span>EI_MAG1<span class="token punctuation">]</span> <span class="token operator">!=</span> ELFMAG1      <span class="token operator">||</span> ident<span class="token punctuation">[</span>EI_MAG2<span class="token punctuation">]</span> <span class="token operator">!=</span> ELFMAG2      <span class="token operator">||</span> ident<span class="token punctuation">[</span>EI_MAG3<span class="token punctuation">]</span> <span class="token operator">!=</span> ELFMAG3<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> Elf_Ehdr<span class="token operator">*</span> <span class="token function">get_ehdr</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>g_ehdr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    g_ehdr <span class="token operator">=</span> <span class="token punctuation">(</span>Elf_Ehdr <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Elf_Ehdr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">read_at</span><span class="token punctuation">(</span><span class="token function">get_file</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> g_ehdr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Elf_Ehdr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"read elf header failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">is_elf_file</span><span class="token punctuation">(</span>g_ehdr<span class="token operator">-&gt;</span>e_ident<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"'%s' is not a elf file\n"</span><span class="token punctuation">,</span> g_filename<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Elf_Ehdr<span class="token punctuation">)</span> <span class="token operator">!=</span> g_ehdr<span class="token operator">-&gt;</span>e_ehsize<span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"elf header size mismatch\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> g_ehdr<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> Elf_Phdr<span class="token operator">*</span> <span class="token function">get_phdrs</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">const</span> Elf_Ehdr<span class="token operator">*</span> ehdr <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>g_phdrs <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    ehdr <span class="token operator">=</span> <span class="token function">get_ehdr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Elf_Phdr<span class="token punctuation">)</span> <span class="token operator">!=</span> ehdr<span class="token operator">-&gt;</span>e_phentsize<span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"program header size mismatch\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    g_phdr_num <span class="token operator">=</span> ehdr<span class="token operator">-&gt;</span>e_phnum<span class="token punctuation">;</span>    g_phdrs <span class="token operator">=</span> <span class="token punctuation">(</span>Elf_Phdr <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Elf_Phdr<span class="token punctuation">)</span> <span class="token operator">*</span> g_phdr_num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">read_at</span><span class="token punctuation">(</span><span class="token function">get_file</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ehdr<span class="token operator">-&gt;</span>e_phoff<span class="token punctuation">,</span> g_phdrs<span class="token punctuation">,</span>        <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Elf_Phdr<span class="token punctuation">)</span> <span class="token operator">*</span> g_phdr_num<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"read program header failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> g_phdrs<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> Elf_Shdr<span class="token operator">*</span> <span class="token function">get_shdrs</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">const</span> Elf_Ehdr<span class="token operator">*</span> ehdr <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>g_shdrs <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    ehdr <span class="token operator">=</span> <span class="token function">get_ehdr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Elf_Shdr<span class="token punctuation">)</span> <span class="token operator">!=</span> ehdr<span class="token operator">-&gt;</span>e_shentsize<span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"section header size mismatch\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    g_shdr_num <span class="token operator">=</span> ehdr<span class="token operator">-&gt;</span>e_shnum<span class="token punctuation">;</span>    g_shdrs <span class="token operator">=</span> <span class="token punctuation">(</span>Elf_Shdr <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Elf_Shdr<span class="token punctuation">)</span> <span class="token operator">*</span> g_shdr_num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">read_at</span><span class="token punctuation">(</span><span class="token function">get_file</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ehdr<span class="token operator">-&gt;</span>e_shoff<span class="token punctuation">,</span> g_shdrs<span class="token punctuation">,</span>          <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Elf_Shdr<span class="token punctuation">)</span> <span class="token operator">*</span> g_shdr_num<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"read section header failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> g_shdrs<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">get_sect_cont_by_idx</span><span class="token punctuation">(</span><span class="token keyword">int</span> sect_idx<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">const</span> Elf_Shdr<span class="token operator">*</span> shdrs <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token keyword">void</span><span class="token operator">*</span> sect_cont <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>sect_idx <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> sect_idx <span class="token operator">&gt;=</span> g_shdr_num<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  shdrs <span class="token operator">=</span> <span class="token function">get_shdrs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  sect_cont <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>shdrs<span class="token punctuation">[</span>sect_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_size<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">read_at</span><span class="token punctuation">(</span><span class="token function">get_file</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> shdrs<span class="token punctuation">[</span>sect_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_offset<span class="token punctuation">,</span>    sect_cont<span class="token punctuation">,</span> shdrs<span class="token punctuation">[</span>sect_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_size<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">safe_free</span><span class="token punctuation">(</span>sect_cont<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> sect_cont<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">get_shdr_str_tab</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>g_shdr_str_tab <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    g_shdr_str_tab <span class="token operator">=</span> <span class="token function">get_sect_cont_by_idx</span><span class="token punctuation">(</span><span class="token function">get_ehdr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>e_shstrndx<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> g_shdr_str_tab<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">get_sect_idx_by_name</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> sect_name<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">const</span> Elf_Shdr<span class="token operator">*</span> shdrs <span class="token operator">=</span> <span class="token function">get_shdrs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> shdr_str_tab <span class="token operator">=</span> <span class="token function">get_shdr_str_tab</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> g_shdr_num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>sect_name<span class="token punctuation">,</span> shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_name <span class="token operator">+</span> shdr_str_tab<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> i<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">print_pair</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">const</span> pair_t<span class="token operator">*</span> pairs<span class="token punctuation">,</span> <span class="token keyword">int</span> cnt<span class="token punctuation">,</span> <span class="token keyword">int</span> linefeed<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>cnt <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> pairs<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> pairs<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>linefeed<span class="token punctuation">)</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">print_ehdr_ident</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">const</span> pair_t classpairs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>  <span class="token punctuation">{</span>    <span class="token punctuation">{</span>ELFCLASSNONE<span class="token punctuation">,</span>  <span class="token string">"None"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ELFCLASS32<span class="token punctuation">,</span>    <span class="token string">"ELF32"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ELFCLASS64<span class="token punctuation">,</span>    <span class="token string">"ELF64"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> pair_t datapairs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>  <span class="token punctuation">{</span>    <span class="token punctuation">{</span>ELFDATANONE<span class="token punctuation">,</span> <span class="token string">"None"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ELFDATA2LSB<span class="token punctuation">,</span> <span class="token string">"2's complement, little endian"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ELFDATA2MSB<span class="token punctuation">,</span> <span class="token string">"2's complement, big endian"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> pair_t osabipairs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>  <span class="token punctuation">{</span>    <span class="token comment">//{ELFOSABI_NONE,     "UNIX System VB ABI"},</span>    <span class="token punctuation">{</span>ELFOSABI_SYSV<span class="token punctuation">,</span>       <span class="token string">"UNIX System VB ABI"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ELFOSABI_HPUX<span class="token punctuation">,</span>       <span class="token string">"HP-UX"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ELFOSABI_NETBSD<span class="token punctuation">,</span>     <span class="token string">"NetBSD"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment">//{ELFOSABI_GNU,      "Object uses GNU ELF extensions"},</span>    <span class="token punctuation">{</span>ELFOSABI_LINUX<span class="token punctuation">,</span>      <span class="token string">"Object uses GNU ELF extensions"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ELFOSABI_SOLARIS<span class="token punctuation">,</span>    <span class="token string">"Sun Solaris"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ELFOSABI_AIX<span class="token punctuation">,</span>        <span class="token string">"AIX"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ELFOSABI_IRIX<span class="token punctuation">,</span>       <span class="token string">"IBM Irix"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ELFOSABI_FREEBSD<span class="token punctuation">,</span>    <span class="token string">"FreeBSD"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ELFOSABI_TRU64<span class="token punctuation">,</span>      <span class="token string">"Compaq TRU64 UNIX"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ELFOSABI_MODESTO<span class="token punctuation">,</span>    <span class="token string">"Novell Modesto"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ELFOSABI_OPENBSD<span class="token punctuation">,</span>    <span class="token string">"OpenBSD"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ELFOSABI_ARM_AEABI<span class="token punctuation">,</span>  <span class="token string">"ARM EABI"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ELFOSABI_ARM<span class="token punctuation">,</span>        <span class="token string">"ARM"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ELFOSABI_STANDALONE<span class="token punctuation">,</span> <span class="token string">"Standlone (embedded) application"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> Elf_Ehdr<span class="token operator">*</span> ehdr <span class="token operator">=</span> <span class="token function">get_ehdr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span> ident <span class="token operator">=</span> ehdr<span class="token operator">-&gt;</span>e_ident<span class="token punctuation">;</span>  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ELF Header:\n  Magic:  "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> EI_NIDENT<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%02X "</span><span class="token punctuation">,</span> ident<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n  Class:                              "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">print_pair</span><span class="token punctuation">(</span>ident<span class="token punctuation">[</span>EI_CLASS<span class="token punctuation">]</span><span class="token punctuation">,</span> classpairs<span class="token punctuation">,</span> <span class="token function">_countof</span><span class="token punctuation">(</span>classpairs<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Data:                               "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">print_pair</span><span class="token punctuation">(</span>ident<span class="token punctuation">[</span>EI_DATA<span class="token punctuation">]</span><span class="token punctuation">,</span> datapairs<span class="token punctuation">,</span> <span class="token function">_countof</span><span class="token punctuation">(</span>datapairs<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Version:                            %d%s\n"</span><span class="token punctuation">,</span> ident<span class="token punctuation">[</span>EI_VERSION<span class="token punctuation">]</span><span class="token punctuation">,</span>      ident<span class="token punctuation">[</span>EI_VERSION<span class="token punctuation">]</span> <span class="token operator">==</span> EV_CURRENT <span class="token operator">?</span> <span class="token string">"(current)"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  OS/ABI:                             "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">print_pair</span><span class="token punctuation">(</span>ident<span class="token punctuation">[</span>EI_OSABI<span class="token punctuation">]</span><span class="token punctuation">,</span> osabipairs<span class="token punctuation">,</span> <span class="token function">_countof</span><span class="token punctuation">(</span>osabipairs<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">print_ehdr</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">const</span> pair_t objtypepairs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>  <span class="token punctuation">{</span>    <span class="token punctuation">{</span>ET_NONE<span class="token punctuation">,</span> <span class="token string">"None"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ET_REL<span class="token punctuation">,</span>  <span class="token string">"Relocatable file"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ET_EXEC<span class="token punctuation">,</span> <span class="token string">"Executable file"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ET_DYN<span class="token punctuation">,</span>  <span class="token string">"Shared object file"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ET_CORE<span class="token punctuation">,</span> <span class="token string">"Core file"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> pair_t machinepairs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>  <span class="token punctuation">{</span>    <span class="token punctuation">{</span>EM_NONE<span class="token punctuation">,</span>       <span class="token string">"None"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_M32<span class="token punctuation">,</span>        <span class="token string">"AT&amp;T WE 32100"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_SPARC<span class="token punctuation">,</span>      <span class="token string">"SUN SPARC"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_386<span class="token punctuation">,</span>        <span class="token string">"Intel 80386"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_68K<span class="token punctuation">,</span>        <span class="token string">"Motorola m68k family"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_88K<span class="token punctuation">,</span>        <span class="token string">"Motorola m88k family"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_860<span class="token punctuation">,</span>        <span class="token string">"Intel 80860"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_MIPS<span class="token punctuation">,</span>       <span class="token string">"MIPS R3000 big-endian"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_S370<span class="token punctuation">,</span>       <span class="token string">"IBM System/370"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_MIPS_RS3_LE<span class="token punctuation">,</span><span class="token string">"MIPS R3000 little-endian"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_PARISC<span class="token punctuation">,</span>     <span class="token string">"HPPA"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_VPP500<span class="token punctuation">,</span>     <span class="token string">"Fujitsu VPP500"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_SPARC32PLUS<span class="token punctuation">,</span><span class="token string">"Sun's \"v8plus\""</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_960<span class="token punctuation">,</span>        <span class="token string">"Intel 80960"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_PPC<span class="token punctuation">,</span>        <span class="token string">"PowerPC"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_PPC64<span class="token punctuation">,</span>      <span class="token string">"PowerPC 64-bit"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_S390<span class="token punctuation">,</span>       <span class="token string">"IBM S390"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_V800<span class="token punctuation">,</span>       <span class="token string">"NEC V800 series"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_FR20<span class="token punctuation">,</span>       <span class="token string">"Fujitsu FR20"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_RH32<span class="token punctuation">,</span>       <span class="token string">"TRW RH-32"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_RCE<span class="token punctuation">,</span>        <span class="token string">"Motorola RCE"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_ARM<span class="token punctuation">,</span>        <span class="token string">"ARM"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_FAKE_ALPHA<span class="token punctuation">,</span> <span class="token string">"Digital Alpha"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_SH<span class="token punctuation">,</span>         <span class="token string">"Hitachi SH"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_SPARCV9<span class="token punctuation">,</span>    <span class="token string">"SPARC v9 64-bit"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_TRICORE<span class="token punctuation">,</span>    <span class="token string">"Siemens Tricore"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_ARC<span class="token punctuation">,</span>        <span class="token string">"Argonaut RISC Core"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_H8_300<span class="token punctuation">,</span>     <span class="token string">"Hitachi H8/300"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_H8_300H<span class="token punctuation">,</span>    <span class="token string">"Hitachi H8/300H"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_H8S<span class="token punctuation">,</span>        <span class="token string">"Hitachi H8S"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_H8_500<span class="token punctuation">,</span>     <span class="token string">"Hitachi H8/500"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_IA_64<span class="token punctuation">,</span>      <span class="token string">"Intel Merced"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_MIPS_X<span class="token punctuation">,</span>     <span class="token string">"Stanford MIPS-X"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_COLDFIRE<span class="token punctuation">,</span>   <span class="token string">"Motorola Coldfire"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_68HC12<span class="token punctuation">,</span>     <span class="token string">"Motorola M68HC12"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_MMA<span class="token punctuation">,</span>        <span class="token string">"Fujitsu MMA Multimedia Accelerator"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_PCP<span class="token punctuation">,</span>        <span class="token string">"Siemens PCP"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_NCPU<span class="token punctuation">,</span>       <span class="token string">"Sony nCPU embeeded RISC"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_NDR1<span class="token punctuation">,</span>       <span class="token string">"Denso NDR1 microprocessor"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_STARCORE<span class="token punctuation">,</span>   <span class="token string">"Motorola Start*Core processor"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_ME16<span class="token punctuation">,</span>       <span class="token string">"Toyota ME16 processor"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_ST100<span class="token punctuation">,</span>      <span class="token string">"STMicroelectronic ST100 processor"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_TINYJ<span class="token punctuation">,</span>      <span class="token string">"Advanced Logic Corp. Tinyj emb.fam"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_X86_64<span class="token punctuation">,</span>     <span class="token string">"AMD x86-64 architecture"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_PDSP<span class="token punctuation">,</span>       <span class="token string">"Sony DSP Processor"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_FX66<span class="token punctuation">,</span>       <span class="token string">"Siemens FX66 microcontroller"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_ST9PLUS<span class="token punctuation">,</span>    <span class="token string">"STMicroelectronics ST9+ 8/16 mc"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_ST7<span class="token punctuation">,</span>        <span class="token string">"STmicroelectronics ST7 8 bit mc"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_68HC16<span class="token punctuation">,</span>     <span class="token string">"Motorola MC68HC16 microcontroller"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_68HC11<span class="token punctuation">,</span>     <span class="token string">"Motorola MC68HC11 microcontroller"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_68HC08<span class="token punctuation">,</span>     <span class="token string">"Motorola MC68HC08 microcontroller"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_68HC05<span class="token punctuation">,</span>     <span class="token string">"Motorola MC68HC05 microcontroller"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_SVX<span class="token punctuation">,</span>        <span class="token string">"Silicon Graphics SVx"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_ST19<span class="token punctuation">,</span>       <span class="token string">"STMicroelectronics ST19 8 bit mc"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_VAX<span class="token punctuation">,</span>        <span class="token string">"Digital VAX"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_CRIS<span class="token punctuation">,</span>       <span class="token string">"Axis Communications 32-bit embedded processor"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_JAVELIN<span class="token punctuation">,</span>    <span class="token string">"Infineon Technologies 32-bit embedded processor"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_FIREPATH<span class="token punctuation">,</span>   <span class="token string">"Element 14 64-bit DSP Processor"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_ZSP<span class="token punctuation">,</span>        <span class="token string">"LSI Logic 16-bit DSP Processor"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_MMIX<span class="token punctuation">,</span>       <span class="token string">"Donald Knuth's educational 64-bit processor"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_HUANY<span class="token punctuation">,</span>      <span class="token string">"Harvard University machine-independent object files"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_PRISM<span class="token punctuation">,</span>      <span class="token string">"SiTera Prism"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_AVR<span class="token punctuation">,</span>        <span class="token string">"Atmel AVR 8-bit microcontroller"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_FR30<span class="token punctuation">,</span>       <span class="token string">"Fujitsu FR30"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_D10V<span class="token punctuation">,</span>       <span class="token string">"Mitsubishi D10V"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_D30V<span class="token punctuation">,</span>       <span class="token string">"Mitsubishi D30V"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_V850<span class="token punctuation">,</span>       <span class="token string">"NEC v850"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_M32R<span class="token punctuation">,</span>       <span class="token string">"Mitsubishi M32R"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_MN10300<span class="token punctuation">,</span>    <span class="token string">"Matsushita MN10300"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_MN10200<span class="token punctuation">,</span>    <span class="token string">"Matsushita MN10200"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_PJ<span class="token punctuation">,</span>         <span class="token string">"picoJava"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_OPENRISC<span class="token punctuation">,</span>   <span class="token string">"OpenRISC 32-bit embedded processor"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_ARC_A5<span class="token punctuation">,</span>     <span class="token string">"ARC Cores Tangent-A5"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_XTENSA<span class="token punctuation">,</span>     <span class="token string">"Tensilica Xtensa Architecture"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> pair_t versionpairs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>  <span class="token punctuation">{</span>    <span class="token punctuation">{</span>EV_NONE<span class="token punctuation">,</span>     <span class="token string">"None"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EV_CURRENT<span class="token punctuation">,</span>  <span class="token string">"Current version"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> Elf_Ehdr<span class="token operator">*</span> ehdr <span class="token operator">=</span> <span class="token function">get_ehdr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">print_ehdr_ident</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Object file type:                   "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">print_pair</span><span class="token punctuation">(</span>ehdr<span class="token operator">-&gt;</span>e_type<span class="token punctuation">,</span> objtypepairs<span class="token punctuation">,</span> <span class="token function">_countof</span><span class="token punctuation">(</span>objtypepairs<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Machine:                            "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">print_pair</span><span class="token punctuation">(</span>ehdr<span class="token operator">-&gt;</span>e_machine<span class="token punctuation">,</span> machinepairs<span class="token punctuation">,</span> <span class="token function">_countof</span><span class="token punctuation">(</span>machinepairs<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Version:                            "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">print_pair</span><span class="token punctuation">(</span>ehdr<span class="token operator">-&gt;</span>e_version<span class="token punctuation">,</span> versionpairs<span class="token punctuation">,</span> <span class="token function">_countof</span><span class="token punctuation">(</span>versionpairs<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Entry point address:                0x%08x\n"</span><span class="token punctuation">,</span> ehdr<span class="token operator">-&gt;</span>e_entry<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Start of program headers:           0x%08x (bytes into file)\n"</span><span class="token punctuation">,</span> ehdr<span class="token operator">-&gt;</span>e_phoff<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Start of section headers:           0x%08x (bytes into file)\n"</span><span class="token punctuation">,</span> ehdr<span class="token operator">-&gt;</span>e_shoff<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Flags:                              0x%08x\n"</span><span class="token punctuation">,</span> ehdr<span class="token operator">-&gt;</span>e_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Size of this header:                %d (bytes)\n"</span><span class="token punctuation">,</span> ehdr<span class="token operator">-&gt;</span>e_ehsize<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Size of program headers:            %d (bytes)\n"</span><span class="token punctuation">,</span> ehdr<span class="token operator">-&gt;</span>e_phentsize<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Number of program headers:          %d\n"</span><span class="token punctuation">,</span> ehdr<span class="token operator">-&gt;</span>e_phnum<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Size of section headers:            %d (bytes)\n"</span><span class="token punctuation">,</span> ehdr<span class="token operator">-&gt;</span>e_shentsize<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Number of section headers:          %d\n"</span><span class="token punctuation">,</span> ehdr<span class="token operator">-&gt;</span>e_shnum<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Section header string table index:  %d\n\n"</span><span class="token punctuation">,</span> ehdr<span class="token operator">-&gt;</span>e_shstrndx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">print_phdrs</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">const</span> pair_t typepairs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>  <span class="token punctuation">{</span>    <span class="token punctuation">{</span>PT_NULL<span class="token punctuation">,</span>         <span class="token string">"NULL        "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>PT_LOAD<span class="token punctuation">,</span>         <span class="token string">"LOAD        "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>PT_DYNAMIC<span class="token punctuation">,</span>      <span class="token string">"DYNAMIC     "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>PT_INTERP<span class="token punctuation">,</span>       <span class="token string">"INTERP      "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>PT_NOTE<span class="token punctuation">,</span>         <span class="token string">"NOTE        "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>PT_SHLIB<span class="token punctuation">,</span>        <span class="token string">"SHLIB       "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>PT_PHDR<span class="token punctuation">,</span>         <span class="token string">"PHDR        "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>PT_TLS<span class="token punctuation">,</span>          <span class="token string">"TLS         "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>PT_GNU_EH_FRAME<span class="token punctuation">,</span> <span class="token string">"GNU_EH_FRAME"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>PT_GNU_STACK<span class="token punctuation">,</span>    <span class="token string">"GUN_STACK   "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>PT_GNU_RELRO<span class="token punctuation">,</span>    <span class="token string">"GNU_RELRO   "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> Elf_Phdr<span class="token operator">*</span> phdrs <span class="token operator">=</span> <span class="token function">get_phdrs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> i<span class="token punctuation">;</span>  <span class="token keyword">char</span> tmp_buf<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Program Headers:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Type         Offset     VirtAddr   PhysAddr   FileSize   MemSize    Flag Align\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> g_phdr_num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print_pair</span><span class="token punctuation">(</span>phdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p_type<span class="token punctuation">,</span> typepairs<span class="token punctuation">,</span> <span class="token function">_countof</span><span class="token punctuation">(</span>typepairs<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" 0x%08x"</span><span class="token punctuation">,</span> phdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p_offset<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" 0x%08x"</span><span class="token punctuation">,</span> phdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p_vaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" 0x%08x"</span><span class="token punctuation">,</span> phdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p_paddr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" 0x%08x"</span><span class="token punctuation">,</span> phdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p_filesz<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" 0x%08x"</span><span class="token punctuation">,</span> phdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p_memsz<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">snprintf</span><span class="token punctuation">(</span>tmp_buf<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token string">"%s%s%s"</span><span class="token punctuation">,</span>        phdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p_flags <span class="token operator">&amp;</span> PF_X <span class="token operator">?</span> <span class="token string">"X"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>        phdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p_flags <span class="token operator">&amp;</span> PF_W <span class="token operator">?</span> <span class="token string">"W"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>        phdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p_flags <span class="token operator">&amp;</span> PF_R <span class="token operator">?</span> <span class="token string">"R"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" %-4s"</span><span class="token punctuation">,</span> tmp_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" 0x%04x\n"</span><span class="token punctuation">,</span> phdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p_align<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">print_shdrs</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">const</span> pair_t typepairs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>  <span class="token punctuation">{</span>    <span class="token punctuation">{</span>SHT_NULL<span class="token punctuation">,</span>            <span class="token string">"NULL          "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_PROGBITS<span class="token punctuation">,</span>        <span class="token string">"PROGBITS      "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_SYMTAB<span class="token punctuation">,</span>          <span class="token string">"SYMTAB        "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_STRTAB<span class="token punctuation">,</span>          <span class="token string">"STRTAB        "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_RELA<span class="token punctuation">,</span>            <span class="token string">"RELA          "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_HASH<span class="token punctuation">,</span>            <span class="token string">"HASH          "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_DYNAMIC<span class="token punctuation">,</span>         <span class="token string">"DYNAMIC       "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_NOTE<span class="token punctuation">,</span>            <span class="token string">"NOTE          "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_NOBITS<span class="token punctuation">,</span>          <span class="token string">"NOBITS        "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_REL<span class="token punctuation">,</span>             <span class="token string">"REL           "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_SHLIB<span class="token punctuation">,</span>           <span class="token string">"SHLIB         "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_DYNSYM<span class="token punctuation">,</span>          <span class="token string">"DYNSYM        "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_INIT_ARRAY<span class="token punctuation">,</span>      <span class="token string">"INIT_ARRAY    "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_FINI_ARRAY<span class="token punctuation">,</span>      <span class="token string">"FINI_ARRAY    "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_PREINIT_ARRAY<span class="token punctuation">,</span>   <span class="token string">"PREINIT_ARRAY "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_GROUP<span class="token punctuation">,</span>           <span class="token string">"GROUP         "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_SYMTAB_SHNDX<span class="token punctuation">,</span>    <span class="token string">"SYMTAB_SHNDX  "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_GNU_ATTRIBUTES<span class="token punctuation">,</span>  <span class="token string">"GNU_ATTRIBUTES"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_GNU_HASH<span class="token punctuation">,</span>        <span class="token string">"GNU_HASH      "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_GNU_LIBLIST<span class="token punctuation">,</span>     <span class="token string">"GNU_LIBLIST   "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_GNU_verdef<span class="token punctuation">,</span>      <span class="token string">"GNU_verdef    "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_GNU_verneed<span class="token punctuation">,</span>     <span class="token string">"GNU_verneed   "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_GNU_versym<span class="token punctuation">,</span>      <span class="token string">"GNU_versym    "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> Elf_Shdr<span class="token operator">*</span> shdrs <span class="token operator">=</span> <span class="token function">get_shdrs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> shdr_str_tab <span class="token operator">=</span> <span class="token function">get_shdr_str_tab</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> i<span class="token punctuation">;</span>  <span class="token keyword">char</span> tmp_buf<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Section Headers:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Idx Name               Type           Flags VirtAddr   Offset     Size       Link Info Align  EntrySize\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> g_shdr_num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" %- 3d "</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" %-18s "</span><span class="token punctuation">,</span> shdr_str_tab <span class="token operator">+</span> shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print_pair</span><span class="token punctuation">(</span>shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_type<span class="token punctuation">,</span> typepairs<span class="token punctuation">,</span> <span class="token function">_countof</span><span class="token punctuation">(</span>typepairs<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">snprintf</span><span class="token punctuation">(</span>tmp_buf<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token string">" %s%s%s%s%s%s%s%s%s%s"</span><span class="token punctuation">,</span>        shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_flags <span class="token operator">&amp;</span> SHF_WRITE             <span class="token operator">?</span> <span class="token string">"W"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>        shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_flags <span class="token operator">&amp;</span> SHF_ALLOC             <span class="token operator">?</span> <span class="token string">"A"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>        shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_flags <span class="token operator">&amp;</span> SHF_EXECINSTR         <span class="token operator">?</span> <span class="token string">"E"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>        shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_flags <span class="token operator">&amp;</span> SHF_MERGE             <span class="token operator">?</span> <span class="token string">"M"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>        shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_flags <span class="token operator">&amp;</span> SHF_STRINGS           <span class="token operator">?</span> <span class="token string">"S"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>        shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_flags <span class="token operator">&amp;</span> SHF_INFO_LINK         <span class="token operator">?</span> <span class="token string">"I"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>        shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_flags <span class="token operator">&amp;</span> SHF_LINK_ORDER        <span class="token operator">?</span> <span class="token string">"L"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>        shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_flags <span class="token operator">&amp;</span> SHF_OS_NONCONFORMING  <span class="token operator">?</span> <span class="token string">"O"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>        shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_flags <span class="token operator">&amp;</span> SHF_GROUP             <span class="token operator">?</span> <span class="token string">"G"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>        shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_flags <span class="token operator">&amp;</span> SHF_TLS               <span class="token operator">?</span> <span class="token string">"T"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%-5s "</span><span class="token punctuation">,</span> tmp_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" 0x%08x"</span><span class="token punctuation">,</span> shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" 0x%08x"</span><span class="token punctuation">,</span> shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_offset<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" 0x%08x"</span><span class="token punctuation">,</span> shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%- 4d "</span><span class="token punctuation">,</span> shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_link<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%- 4d "</span><span class="token punctuation">,</span> shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_info<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" 0x%04x"</span><span class="token punctuation">,</span> shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_addralign<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" 0x%08x\n"</span><span class="token punctuation">,</span> shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_entsize<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Key to Flags:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  W (Writable), A (Alloc), E(Executable), M (Merge), S (Strings),\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  I (Info), L (Link Order), O (Os Nonconforming), G (Group), T (TLS)\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">print_symbol_info_by_sect_idx</span><span class="token punctuation">(</span><span class="token keyword">int</span> sect_idx<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">const</span> pair_t typepairs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>  <span class="token punctuation">{</span>    <span class="token punctuation">{</span>STT_NOTYPE<span class="token punctuation">,</span>    <span class="token string">"NOTYPE   "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>STT_OBJECT<span class="token punctuation">,</span>    <span class="token string">"OBJECT   "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>STT_FUNC<span class="token punctuation">,</span>      <span class="token string">"FUNC     "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>STT_SECTION<span class="token punctuation">,</span>   <span class="token string">"SECTION  "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>STT_FILE<span class="token punctuation">,</span>      <span class="token string">"FILE     "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>STT_COMMON<span class="token punctuation">,</span>    <span class="token string">"COMMON   "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>STT_TLS<span class="token punctuation">,</span>       <span class="token string">"TLS      "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>STT_GNU_IFUNC<span class="token punctuation">,</span> <span class="token string">"GUN_IFUNC"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> pair_t bindpairs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>  <span class="token punctuation">{</span>    <span class="token punctuation">{</span>STB_LOCAL<span class="token punctuation">,</span>       <span class="token string">"LOCAL     "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>STB_GLOBAL<span class="token punctuation">,</span>      <span class="token string">"GLOBAL    "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>STB_WEAK<span class="token punctuation">,</span>        <span class="token string">"WEAK      "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>STB_GNU_UNIQUE<span class="token punctuation">,</span>  <span class="token string">"GUN_UNIQUE"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> pair_t visiblepairs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>  <span class="token punctuation">{</span>    <span class="token punctuation">{</span>STV_DEFAULT<span class="token punctuation">,</span>   <span class="token string">"DEFAULT   "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>STV_INTERNAL<span class="token punctuation">,</span>  <span class="token string">"INTERNAL  "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>STV_HIDDEN<span class="token punctuation">,</span>    <span class="token string">"HIDDEN    "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>STV_PROTECTED<span class="token punctuation">,</span> <span class="token string">"PROTECTED "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> Elf_Shdr<span class="token operator">*</span> shdrs <span class="token operator">=</span> <span class="token function">get_shdrs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> shdr_str_tab <span class="token operator">=</span> <span class="token function">get_shdr_str_tab</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Elf_Sym<span class="token operator">*</span> symbol <span class="token operator">=</span> <span class="token punctuation">(</span>Elf_Sym <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">get_sect_cont_by_idx</span><span class="token punctuation">(</span>sect_idx<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> symbol_num <span class="token operator">=</span> shdrs<span class="token punctuation">[</span>sect_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_size <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Elf_Sym<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">char</span><span class="token operator">*</span> symbol_str_tab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">get_sect_cont_by_idx</span><span class="token punctuation">(</span>shdrs<span class="token punctuation">[</span>sect_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_link<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>symbol <span class="token operator">==</span> <span class="token constant">NULL</span>    <span class="token operator">||</span> symbol_str_tab <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">safe_free</span><span class="token punctuation">(</span>symbol<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">safe_free</span><span class="token punctuation">(</span>symbol_str_tab<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Symbol Info For '%s':\n"</span><span class="token punctuation">,</span> shdrs<span class="token punctuation">[</span>sect_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_name <span class="token operator">+</span> shdr_str_tab<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Idx Value      Size   Type      Bind       Visibility Shndx  Name\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> symbol_num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  %3d"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" 0x%08x"</span><span class="token punctuation">,</span> symbol<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>st_value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" 0x%04x "</span><span class="token punctuation">,</span> symbol<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>st_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print_pair</span><span class="token punctuation">(</span><span class="token function">ELF_ST_TYPE</span><span class="token punctuation">(</span>symbol<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>st_info<span class="token punctuation">)</span><span class="token punctuation">,</span> typepairs<span class="token punctuation">,</span> <span class="token function">_countof</span><span class="token punctuation">(</span>typepairs<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print_pair</span><span class="token punctuation">(</span><span class="token function">ELF_ST_BIND</span><span class="token punctuation">(</span>symbol<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>st_info<span class="token punctuation">)</span><span class="token punctuation">,</span> bindpairs<span class="token punctuation">,</span> <span class="token function">_countof</span><span class="token punctuation">(</span>bindpairs<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print_pair</span><span class="token punctuation">(</span><span class="token function">ELF_ST_VISIBILITY</span><span class="token punctuation">(</span>symbol<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>st_other<span class="token punctuation">)</span><span class="token punctuation">,</span> visiblepairs<span class="token punctuation">,</span> <span class="token function">_countof</span><span class="token punctuation">(</span>visiblepairs<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>symbol<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>st_shndx<span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token keyword">case</span> SHN_UNDEF<span class="token operator">:</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"UNDEF "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token keyword">case</span> SHN_ABS<span class="token operator">:</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ABS   "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token keyword">case</span> SHN_COMMON<span class="token operator">:</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"COMMON"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token keyword">default</span><span class="token operator">:</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%-6d"</span><span class="token punctuation">,</span> symbol<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>st_shndx<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" %s\n"</span><span class="token punctuation">,</span> symbol<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>st_name <span class="token operator">+</span> symbol_str_tab<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">safe_free</span><span class="token punctuation">(</span>symbol<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">safe_free</span><span class="token punctuation">(</span>symbol_str_tab<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">print_symbol_info</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">const</span> Elf_Shdr<span class="token operator">*</span> shdrs <span class="token operator">=</span> <span class="token function">get_shdrs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Symbol Info:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> g_shdr_num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_type <span class="token operator">==</span> SHT_SYMTAB      <span class="token operator">||</span> shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_type <span class="token operator">==</span> SHT_DYNSYM<span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token function">print_symbol_info_by_sect_idx</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">print_relocation_info</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">const</span> Elf_Shdr<span class="token operator">*</span> shdrs <span class="token operator">=</span> <span class="token function">get_shdrs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> shdr_str_tab <span class="token operator">=</span> <span class="token function">get_shdr_str_tab</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Elf_Rel<span class="token operator">*</span> rel <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> rel_num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  Elf_Sym<span class="token operator">*</span> sym <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token keyword">char</span><span class="token operator">*</span> sym_str_tab <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Relocation Info:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> g_shdr_num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_type <span class="token operator">==</span> SHT_REL<span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Relocation Info Without Addends For '%s':\n"</span><span class="token punctuation">,</span>          shdrs<span class="token punctuation">[</span>shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_info<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_name <span class="token operator">+</span> shdr_str_tab<span class="token punctuation">)</span><span class="token punctuation">;</span>      rel_num <span class="token operator">=</span> shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_size <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Elf_Rel<span class="token punctuation">)</span><span class="token punctuation">;</span>      rel <span class="token operator">=</span> <span class="token punctuation">(</span>Elf_Rel <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">get_sect_cont_by_idx</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>      sym <span class="token operator">=</span> <span class="token punctuation">(</span>Elf_Sym <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">get_sect_cont_by_idx</span><span class="token punctuation">(</span>shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_link<span class="token punctuation">)</span><span class="token punctuation">;</span>      sym_str_tab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">get_sect_cont_by_idx</span><span class="token punctuation">(</span>shdrs<span class="token punctuation">[</span>shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_link<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_link<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  OFFSET     TYPE       VALUE\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> rel_num<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>      <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  0x%08x"</span><span class="token punctuation">,</span> rel<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>r_offset<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" 0x%08x"</span><span class="token punctuation">,</span> <span class="token function">ELF_R_TYPE</span><span class="token punctuation">(</span>rel<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>r_info<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" %s\n"</span><span class="token punctuation">,</span> sym<span class="token punctuation">[</span><span class="token function">ELF_R_SYM</span><span class="token punctuation">(</span>rel<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>r_info<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>st_name <span class="token operator">+</span> sym_str_tab<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token function">safe_free</span><span class="token punctuation">(</span>rel<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">safe_free</span><span class="token punctuation">(</span>sym<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">safe_free</span><span class="token punctuation">(</span>sym_str_tab<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">print_all_str_tab</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">const</span> Elf_Shdr<span class="token operator">*</span> shdrs <span class="token operator">=</span> <span class="token function">get_shdrs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> shdr_str_tab <span class="token operator">=</span> <span class="token function">get_shdr_str_tab</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">char</span><span class="token operator">*</span> str_tab <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> str_tab_pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"All String Table:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> g_shdr_num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_type <span class="token operator">==</span> SHT_STRTAB<span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"String Table '%s':\n"</span><span class="token punctuation">,</span> shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_name <span class="token operator">+</span> shdr_str_tab<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Idx Value\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      str_tab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">get_sect_cont_by_idx</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> str_tab_pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> str_tab_pos <span class="token operator">&lt;</span> shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_size<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>      <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  %3d %s\n"</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> str_tab <span class="token operator">+</span> str_tab_pos<span class="token punctuation">)</span><span class="token punctuation">;</span>        str_tab_pos <span class="token operator">+=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str_tab <span class="token operator">+</span> str_tab_pos<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token function">safe_free</span><span class="token punctuation">(</span>str_tab<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">print_usage</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Usage: %s file\n"</span><span class="token punctuation">,</span> g_selfname<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">" -a  same as -h -p -s -S -r -d\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">" -h  dump ELF file header\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">" -p  dump ELF file program header\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">" -s  dump ELF file section header\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">" -S  dump Symbol Info\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">" -r  dump relocation info\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">" -d  dump all string table\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">" -v  print version info and exit\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">print_version</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Elf(Executable Linkable Format) file dump tool("</span>ARCH<span class="token string">")\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Copyright (c) 2013 Kiba Amor &lt;KibaAmor@gmai.com&gt;\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"All rights reserved.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Version 1.0\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> show_ehdr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> show_phdrs <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> show_shdrs <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> show_symbol_info <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> show_relocation_info <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> show_all_str_tab <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  g_selfname <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'-'</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>g_filename <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"multi input file detected\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> EXIT_FAILURE<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">else</span>      <span class="token punctuation">{</span>        g_filename <span class="token operator">=</span> argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">continue</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">strlen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token keyword">switch</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span>        <span class="token keyword">case</span> <span class="token string">'a'</span><span class="token operator">:</span>          show_ehdr <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          show_phdrs <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          show_shdrs <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          show_symbol_info <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          show_relocation_info <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          show_all_str_tab <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'h'</span><span class="token operator">:</span>          show_ehdr <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'p'</span><span class="token operator">:</span>          show_phdrs <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'s'</span><span class="token operator">:</span>          show_shdrs <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'S'</span><span class="token operator">:</span>          show_symbol_info <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'r'</span><span class="token operator">:</span>          show_relocation_info <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'d'</span><span class="token operator">:</span>          show_all_str_tab <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'v'</span><span class="token operator">:</span>          <span class="token function">print_version</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> EXIT_FAILURE<span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token operator">:</span>          <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"unkown option: '%c'\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> EXIT_FAILURE<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>g_filename <span class="token operator">==</span> <span class="token constant">NULL</span>      <span class="token operator">||</span> <span class="token punctuation">(</span>show_ehdr <span class="token operator">==</span> <span class="token number">0</span>      <span class="token operator">&amp;&amp;</span> show_phdrs <span class="token operator">==</span> <span class="token number">0</span>      <span class="token operator">&amp;&amp;</span> show_shdrs <span class="token operator">==</span> <span class="token number">0</span>      <span class="token operator">&amp;&amp;</span> show_symbol_info <span class="token operator">==</span> <span class="token number">0</span>      <span class="token operator">&amp;&amp;</span> show_relocation_info <span class="token operator">==</span> <span class="token number">0</span>      <span class="token operator">&amp;&amp;</span> show_all_str_tab <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">print_usage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> EXIT_FAILURE<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">atexit</span><span class="token punctuation">(</span>clean_up<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>show_ehdr<span class="token punctuation">)</span>    <span class="token function">print_ehdr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>show_phdrs<span class="token punctuation">)</span>    <span class="token function">print_phdrs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>show_shdrs<span class="token punctuation">)</span>    <span class="token function">print_shdrs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>show_symbol_info<span class="token punctuation">)</span>    <span class="token function">print_symbol_info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>show_relocation_info<span class="token punctuation">)</span>    <span class="token function">print_relocation_info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>show_all_str_tab<span class="token punctuation">)</span>    <span class="token function">print_all_str_tab</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> EXIT_SUCCESS<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> 逆向工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用socat来测试echo服务器和客户端</title>
      <link href="li-yong-socat-lai-ce-shi-echo-fu-wu-qi-he-ke-hu-duan/"/>
      <url>li-yong-socat-lai-ce-shi-echo-fu-wu-qi-he-ke-hu-duan/</url>
      
        <content type="html"><![CDATA[<h2 id="用socat开启echo服务器"><a href="#用socat开启echo服务器" class="headerlink" title="用socat开启echo服务器"></a>用socat开启echo服务器</h2><p>在本地9999端口开启一个echo服务器</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">socat tcp-listen:8888 <span class="token builtin class-name">echo</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="用socat测试echo服务器"><a href="#用socat测试echo服务器" class="headerlink" title="用socat测试echo服务器"></a>用socat测试echo服务器</h2><p>把文件in.dat中内容发送到本地的8888端口，并将接收到的数据存放在out中。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">socat tcp:127.0.0.1:8888 open:in.dat,rdonly<span class="token operator">!</span><span class="token operator">!</span>open:out.dat,create,wronly<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>可用于对echo服务器进行数据压力测试。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具使用 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
