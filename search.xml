<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《Linux性能优化实战》学习笔记</title>
      <link href="linux-xing-neng-you-hua-shi-zhan-xue-xi-bi-ji/"/>
      <url>linux-xing-neng-you-hua-shi-zhan-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="01-开篇词"><a href="#01-开篇词" class="headerlink" title="01-开篇词"></a><strong>01-开篇词</strong></h2><h3 id="01-如何学习Linux性能优化？"><a href="#01-如何学习Linux性能优化？" class="headerlink" title="01 | 如何学习Linux性能优化？"></a>01 | 如何学习Linux性能优化？</h3><h4 id="1-1-性能指标是什么？"><a href="#1-1-性能指标是什么？" class="headerlink" title="1.1 性能指标是什么？"></a>1.1 性能指标是什么？</h4><p>性能分析，其实就是找出应用或系统的瓶颈，并设法去避免或者缓解它们，从而更高效地利用系统资源处理更多的请求。这包含了一系列的步骤，比如下面这六个步骤：</p><ol><li>选择指标评估应用程序和系统的性能；</li><li>为应用程序和系统设置性能目标；</li><li>进行性能基准测试；</li><li>性能分析定位瓶颈；</li><li>优化系统和应用程序；</li><li>性能监控和告警。</li></ol><h4 id="1-2-学习的重点是什么？"><a href="#1-2-学习的重点是什么？" class="headerlink" title="1.2 学习的重点是什么？"></a>1.2 学习的重点是什么？</h4><p>想要学习好性能分析和优化，建立整体系统性能的全局观是最核心的话题。因而，</p><ul><li>理解最基本的几个系统知识原理；</li><li>掌握必要的性能工具；</li><li>通过实际的场景演练，贯穿不同的组件。</li></ul><p>千万不要把性能工具当成学习的全部。工具只是解决问题的手段，关键在于你的用法。只有真正理解了它们背后的原理，并且结合具体场景，融会贯通系统的不同组件，你才能真正掌握它们。</p><p><img src="/images/《Linux性能优化实战》学习笔记/Linux性能优化实战思维导图.png" alt="Linux性能优化实战思维导图"></p><h4 id="1-3-怎么学更高效？"><a href="#1-3-怎么学更高效？" class="headerlink" title="1.3 怎么学更高效？"></a>1.3 怎么学更高效？</h4><ul><li>虽然系统的原理很重要，但在刚开始一定不要试图抓住所有的实现细节。</li><li>边学边实践，通过大量的案例演习掌握 Linux 性能的分析和优化。</li><li>勤思考，多反思，善总结，多问为什么。</li></ul><h2 id="02-CPU-性能篇"><a href="#02-CPU-性能篇" class="headerlink" title="02-CPU 性能篇"></a><strong>02-CPU 性能篇</strong></h2><h3 id="02-基础篇：到底应该怎么理解“平均负载”？"><a href="#02-基础篇：到底应该怎么理解“平均负载”？" class="headerlink" title="02 | 基础篇：到底应该怎么理解“平均负载”？"></a>02 | 基础篇：到底应该怎么理解“平均负载”？</h3><h4 id="2-1-平均负载"><a href="#2-1-平均负载" class="headerlink" title="2.1 平均负载"></a>2.1 平均负载</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">uptime</span>02:34:03 up <span class="token number">2</span> days, <span class="token number">20</span>:14,  <span class="token number">1</span> user,  load average: <span class="token number">0.63</span>, <span class="token number">0.83</span>, <span class="token number">0.88</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输出结果分别是：系统当前时间、系统运行时间、登录用户数、系统过去 1 分钟、5 分钟、15 分钟的平均负载（Load Average）。</p><p>关于平均负载的解释可以查看 <code>man uptime</code>。</p><p>平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数。</p><ul><li>可运行状态的进程，是指正在使用 CPU 或者正在等待 CPU 的进程，也就是我们常用 ps 命令看到的，处于 R 状态（Running 或 Runnable）的进程。</li><li>不可中断状态的进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应，也就是我们在 ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程。<blockquote><p>比如，当一个进程向磁盘读写数据时，为了保证数据的一致性，在得到磁盘回复前，它是不能被其他进程或者中断打断的，这个时候的进程就处于不可中断状态。<br>不可中断状态实际上是系统对进程和硬件设备的一种保护机制。</p></blockquote></li></ul><p>可以简单理解为，平均负载其实就是平均活跃进程数。平均活跃进程数，直观上的理解就是单位时间内的活跃进程数，但它实际上是活跃进程数的指数衰减平均值。</p><h4 id="2-2-平均负载为多少时合理"><a href="#2-2-平均负载为多少时合理" class="headerlink" title="2.2 平均负载为多少时合理"></a>2.2 平均负载为多少时合理</h4><p>平均负载最理想的情况是等于 CPU 个数。</p><p>分析系统负载趋势：</p><ul><li>如果 1 分钟、5 分钟、15 分钟的三个值基本相同，或者相差不大，那就说明系统负载很平稳。</li><li>但如果 1 分钟的值远小于 15 分钟的值，就说明系统最近 1 分钟的负载在减少，而过去 15 分钟内却有很大的负载。</li><li>反过来，如果 1 分钟的值远大于 15 分钟的值，就说明最近 1 分钟的负载在增加，这种增加有可能只是临时性的，也有可能还会持续增加下去，所以就需要持续观察。一旦 1 分钟的平均负载接近或超过了 CPU 的个数，就意味着系统正在发生过载的问题，这时就得分析调查是哪里导致的问题，并要想办法优化了。</li></ul><p>在实际生产环境中，当平均负载高于 CPU 数量 70% 的时候，就应该分析排查负载高的问题了。</p><h4 id="2-3-平均负载与-CPU-使用率"><a href="#2-3-平均负载与-CPU-使用率" class="headerlink" title="2.3 平均负载与 CPU 使用率"></a>2.3 平均负载与 CPU 使用率</h4><p>平均负载是指单位时间内，处于可运行状态和不可中断状态的进程数。所以，它不仅包括了正在使用 CPU 的进程，还包括等待 CPU 和等待 I/O 的进程。</p><p>CPU 使用率，是单位时间内 CPU 繁忙情况的统计，跟平均负载并不一定完全对应。比如：</p><ul><li>CPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时这两者是一致的；</li><li>I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高；</li><li>大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高。</li></ul><h4 id="2-4-平均负载案例分析"><a href="#2-4-平均负载案例分析" class="headerlink" title="2.4 平均负载案例分析"></a>2.4 平均负载案例分析</h4><blockquote><p>机器配置：2 CPU，8GB 内存。</p><p>安装软件：<code>apt install stress sysstat</code>。</p></blockquote><p>观察测试前的平均负载</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">uptime</span><span class="token punctuation">..</span>.,  load average: <span class="token number">0.11</span>, <span class="token number">0.15</span>, <span class="token number">0.09</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li><p>场景一：CPU 密集型进程</p><ol><li><p>模拟高 CPU 使用率</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ stress --cpu <span class="token number">1</span> --timeout <span class="token number">600</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>在第二个终端运行 uptime 查看平均负载的变化情况</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -d 参数表示高亮显示变化的区域</span>$ <span class="token function">watch</span> -d <span class="token function">uptime</span><span class="token punctuation">..</span>.,  load average: <span class="token number">1.00</span>, <span class="token number">0.75</span>, <span class="token number">0.39</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>在第三个终端运行 mpstat 查看 CPU 使用率的变化情况</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -P ALL 表示监控所有 CPU，后面数字 5 表示间隔 5 秒后输出一组数据</span>$ mpstat -P ALL <span class="token number">5</span>Linux <span class="token number">4.15</span>.0 <span class="token punctuation">(</span>ubuntu<span class="token punctuation">)</span> 09/22/18 _x86_64_ <span class="token punctuation">(</span><span class="token number">2</span> CPU<span class="token punctuation">)</span><span class="token number">13</span>:30:06     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle<span class="token number">13</span>:30:11     all   <span class="token number">50.05</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">49.95</span><span class="token number">13</span>:30:11       <span class="token number">0</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>  <span class="token number">100.00</span><span class="token number">13</span>:30:11       <span class="token number">1</span>  <span class="token number">100.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 可以看到，1 分钟的平均负载会慢慢增加到 1.00，而从终端三中还可以看到，正好有一个 CPU 的使用率为 100%，但它的 iowait 只有 0。这说明，平均负载的升高正是由于 CPU 使用率为 100% 。</p></li><li><p>到底是哪个进程导致了 CPU 使用率为 100% 呢？你可以使用 pidstat 来查询</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 间隔 5 秒后输出一组数据</span>$ pidstat -u <span class="token number">5</span> <span class="token number">1</span><span class="token number">13</span>:37:07      <span class="token environment constant">UID</span>       PID    %usr %system  %guest   %wait    %CPU   CPU  Command<span class="token number">13</span>:37:12        <span class="token number">0</span>      <span class="token number">2962</span>  <span class="token number">100.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>  <span class="token number">100.00</span>     <span class="token number">1</span>  stress<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 可以明显看到，stress 进程的 CPU 使用率为 100%。</p></li></ol></li><li><p>场景二：I/O 密集型进程</p><ol><li><p>模拟 I/O 压力，即不停地执行 sync</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">stress -i <span class="token number">1</span> --timeout <span class="token number">600</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>在第二个终端运行 uptime 查看平均负载的变化情况</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">watch</span> -d <span class="token function">uptime</span><span class="token punctuation">..</span>.,  load average: <span class="token number">1.06</span>, <span class="token number">0.58</span>, <span class="token number">0.37</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>在第三个终端运行 mpstat 查看 CPU 使用率的变化情况</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 显示所有 CPU 的指标，并在间隔 5 秒输出一组数据</span>$ mpstat -P ALL <span class="token number">5</span> <span class="token number">1</span>Linux <span class="token number">4.15</span>.0 <span class="token punctuation">(</span>ubuntu<span class="token punctuation">)</span>     09/22/18     _x86_64_    <span class="token punctuation">(</span><span class="token number">2</span> CPU<span class="token punctuation">)</span><span class="token number">13</span>:41:28     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle<span class="token number">13</span>:41:33     all    <span class="token number">0.21</span>    <span class="token number">0.00</span>   <span class="token number">12.07</span>   <span class="token number">32.67</span>    <span class="token number">0.00</span>    <span class="token number">0.21</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">54.84</span><span class="token number">13</span>:41:33       <span class="token number">0</span>    <span class="token number">0.43</span>    <span class="token number">0.00</span>   <span class="token number">23.87</span>   <span class="token number">67.53</span>    <span class="token number">0.00</span>    <span class="token number">0.43</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">7.74</span><span class="token number">13</span>:41:33       <span class="token number">1</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.81</span>    <span class="token number">0.20</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">98.99</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 可以看到，1 分钟的平均负载会慢慢增加到 1.06，其中一个 CPU 的系统 CPU 使用率升高到了 23.87，而 iowait 高达 67.53%。这说明，平均负载的升高是由于 iowait 的升高。</p></li><li><p>那么到底是哪个进程，导致 iowait 这么高呢？用 pidstat 来查询</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 间隔 5 秒后输出一组数据，-u 表示 CPU 指标</span>$ pidstat -u <span class="token number">5</span> <span class="token number">1</span>Linux <span class="token number">4.15</span>.0 <span class="token punctuation">(</span>ubuntu<span class="token punctuation">)</span>     09/22/18     _x86_64_    <span class="token punctuation">(</span><span class="token number">2</span> CPU<span class="token punctuation">)</span><span class="token number">13</span>:42:08      <span class="token environment constant">UID</span>       PID    %usr %system  %guest   %wait    %CPU   CPU  Command<span class="token number">13</span>:42:13        <span class="token number">0</span>       <span class="token number">104</span>    <span class="token number">0.00</span>    <span class="token number">3.39</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">3.39</span>     <span class="token number">1</span>  kworker/1:1H<span class="token number">13</span>:42:13        <span class="token number">0</span>       <span class="token number">109</span>    <span class="token number">0.00</span>    <span class="token number">0.40</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.40</span>     <span class="token number">0</span>  kworker/0:1H<span class="token number">13</span>:42:13        <span class="token number">0</span>      <span class="token number">2997</span>    <span class="token number">2.00</span>   <span class="token number">35.53</span>    <span class="token number">0.00</span>    <span class="token number">3.99</span>   <span class="token number">37.52</span>     <span class="token number">1</span>  stress<span class="token number">13</span>:42:13        <span class="token number">0</span>      <span class="token number">3057</span>    <span class="token number">0.00</span>    <span class="token number">0.40</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.40</span>     <span class="token number">0</span>  pidstat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 可以发现，还是 stress 进程导致的。</p></li></ol></li><li><p>场景三：大量进程的场景</p><p> 当系统中运行进程超出 CPU 运行能力时，就会出现等待 CPU 的进程。</p><ol><li><p>使用 stress 模拟的是 8 个进程</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ stress -c <span class="token number">8</span> --timeout <span class="token number">600</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>由于系统只有 2 个 CPU，明显比 8 个进程要少得多，因而，系统的 CPU 处于严重过载状态，平均负载高达 7.97。</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">uptime</span><span class="token punctuation">..</span>.,  load average: <span class="token number">7.97</span>, <span class="token number">5.93</span>, <span class="token number">3.02</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>接着再运行 pidstat 来看一下进程的情况</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 间隔 5 秒后输出一组数据</span>$ pidstat -u <span class="token number">5</span> <span class="token number">1</span><span class="token number">14</span>:23:25      <span class="token environment constant">UID</span>       PID    %usr %system  %guest   %wait    %CPU   CPU  Command<span class="token number">14</span>:23:30        <span class="token number">0</span>      <span class="token number">3190</span>   <span class="token number">25.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">74.80</span>   <span class="token number">25.00</span>     <span class="token number">0</span>  stress<span class="token number">14</span>:23:30        <span class="token number">0</span>      <span class="token number">3191</span>   <span class="token number">25.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">75.20</span>   <span class="token number">25.00</span>     <span class="token number">0</span>  stress<span class="token number">14</span>:23:30        <span class="token number">0</span>      <span class="token number">3192</span>   <span class="token number">25.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">74.80</span>   <span class="token number">25.00</span>     <span class="token number">1</span>  stress<span class="token number">14</span>:23:30        <span class="token number">0</span>      <span class="token number">3193</span>   <span class="token number">25.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">75.00</span>   <span class="token number">25.00</span>     <span class="token number">1</span>  stress<span class="token number">14</span>:23:30        <span class="token number">0</span>      <span class="token number">3194</span>   <span class="token number">24.80</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">74.60</span>   <span class="token number">24.80</span>     <span class="token number">0</span>  stress<span class="token number">14</span>:23:30        <span class="token number">0</span>      <span class="token number">3195</span>   <span class="token number">24.80</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">75.00</span>   <span class="token number">24.80</span>     <span class="token number">0</span>  stress<span class="token number">14</span>:23:30        <span class="token number">0</span>      <span class="token number">3196</span>   <span class="token number">24.80</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">74.60</span>   <span class="token number">24.80</span>     <span class="token number">1</span>  stress<span class="token number">14</span>:23:30        <span class="token number">0</span>      <span class="token number">3197</span>   <span class="token number">24.80</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">74.80</span>   <span class="token number">24.80</span>     <span class="token number">1</span>  stress<span class="token number">14</span>:23:30        <span class="token number">0</span>      <span class="token number">3200</span>    <span class="token number">0.00</span>    <span class="token number">0.20</span>    <span class="token number">0.00</span>    <span class="token number">0.20</span>    <span class="token number">0.20</span>     <span class="token number">0</span>  pidstat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 可以看出，8 个进程在争抢 2 个 CPU，每个进程等待 CPU 的时间（也就是代码块中的 %wait 列）高达 75%。这些超出 CPU 计算能力的进程，最终导致 CPU 过载。</p></li></ol></li></ol><h4 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h4><p>平均负载提供了一个快速查看系统整体性能的手段，反映了整体的负载情况。但只看平均负载本身，我们并不能直接发现，到底是哪里出现了瓶颈。所以，在理解平均负载时，也要注意：</p><ul><li>平均负载高有可能是 CPU 密集型进程导致的；</li><li>平均负载高并不一定代表 CPU 使用率高，还有可能是 I/O 更繁忙了；</li><li>当发现负载高的时候，你可以使用 mpstat、pidstat 等工具，辅助分析负载的来源。</li></ul><h3 id="03-基础篇：经常说的-CPU-上下文切换是什么意思？（上）"><a href="#03-基础篇：经常说的-CPU-上下文切换是什么意思？（上）" class="headerlink" title="03 | 基础篇：经常说的 CPU 上下文切换是什么意思？（上）"></a>03 | 基础篇：经常说的 CPU 上下文切换是什么意思？（上）</h3><p>进程在竞争 CPU 的时候并没有真正运行，但是 CPU 上下文切换会导致系统的负载升高。</p><p>根据任务的不同，CPU 的上下文切换就可以分为几个不同的场景，也就是进程上下文切换、线程上下文切换以及中断上下文切换。</p><h4 id="3-1-进程上下文切换"><a href="#3-1-进程上下文切换" class="headerlink" title="3.1 进程上下文切换"></a>3.1 进程上下文切换</h4><ol><li><p>系统调用</p><p> 系统调用的过程会发生 CPU 上下文。</p><p> CPU 寄存器里原来用户态的指令位置，需要先保存起来。接着，为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务。</p><p> 而系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。所以，一次系统调用的过程，其实是发生了两次 CPU 上下文切换。</p><p> 需要注意的是，系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程。这跟我们通常所说的进程上下文切换是不一样的：</p><ul><li>进程上下文切换，是指从一个进程切换到另一个进程运行。</li><li><p>而系统调用过程中一直是同一个进程在运行。</p><p><strong>所以，系统调用过程通常称为特权模式切换，而不是上下文切换。</strong></p></li></ul></li><li><p>进程上下文切换跟系统调用又有什么区别呢？</p><p> 进程是由内核来管理和调度的，进程的切换只能发生在内核态。所以，进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。</p><p> 因此，进程的上下文切换就比系统调用时多了一步：在保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进程的虚拟内存、栈等保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。</p><p> <img src="/images/《Linux性能优化实战》学习笔记/进程上下文切换.png" alt="进程上下文切换"></p><p> 根据 <a href="https://blog.tsunanet.net/2010/11/how-long-does-it-take-to-make-context.html">How long does it take to make a context switch?</a> 的测试报告，每次上下文切换都需要几十纳秒到数微秒的 CPU 时间。</p><p> 另外， Linux 通过 TLB（Translation Lookaside Buffer）来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，TLB 也需要刷新，内存的访问也会随之变慢。特别是在多处理器系统上，缓存是被多个处理器共享的，刷新缓存不仅会影响当前处理器的进程，还会影响共享缓存的其他处理器的进程。</p></li><li><p>进程在什么时候才会被调度到 CPU 上运行呢？</p><ol><li>进程执行完终止了，它之前使用的 CPU 会释放出来，这个时候再从就绪队列里，拿一个新的进程过来运行。</li><li>当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行。</li><li>进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。</li><li>当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度。</li><li>当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。</li><li>发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。</li></ol></li></ol><h4 id="3-2-线程上下文切换"><a href="#3-2-线程上下文切换" class="headerlink" title="3.2 线程上下文切换"></a>3.2 线程上下文切换</h4><p>线程与进程最大的区别在于，<strong>线程是调度的基本单位，而进程则是资源拥有的基本单位</strong> 。内核中的任务调度，实际上的调度对象是线程；而进程只是给线程提供了虚拟内存、全局变量等资源。所以，对于线程和进程，可以这么理解：</p><ul><li>当进程只有一个线程时，可以认为进程就等于线程。</li><li>当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。</li><li>另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。</li></ul><p>这么一来，线程的上下文切换其实就可以分为两种情况：</p><ol><li>前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。</li><li>前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。</li></ol><p>虽然同为上下文切换，但同进程内的线程切换，要比多进程间的切换消耗更少的资源，而这，也正是多线程代替多进程的一个优势。</p><h4 id="3-3-中断上下文切换"><a href="#3-3-中断上下文切换" class="headerlink" title="3.3 中断上下文切换"></a>3.3 中断上下文切换</h4><p>为了快速响应硬件的事件，<strong>中断处理会打断进程的正常调度和执行</strong>，转而调用中断处理程序，响应设备事件。</p><p>跟进程上下文不同，中断上下文切换并不涉及到进程的用户态。所以，即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等。</p><p>对同一个 CPU 来说，中断处理比进程拥有更高的优先级，所以中断上下文切换并不会与进程上下文切换同时发生。</p><h3 id="04-基础篇：经常说的-CPU-上下文切换是什么意思？（下）"><a href="#04-基础篇：经常说的-CPU-上下文切换是什么意思？（下）" class="headerlink" title="04 | 基础篇：经常说的 CPU 上下文切换是什么意思？（下）"></a>04 | 基础篇：经常说的 CPU 上下文切换是什么意思？（下）</h3><h4 id="4-1-怎么查看系统的上下文切换情况"><a href="#4-1-怎么查看系统的上下文切换情况" class="headerlink" title="4.1 怎么查看系统的上下文切换情况"></a>4.1 怎么查看系统的上下文切换情况</h4><ol><li><p>查看系统总体的上下文切换情况</p><p> vmstat 是一个常用的系统性能分析工具，主要用来分析系统的内存使用情况，也常用来分析 CPU 上下文切换和中断的次数。</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 每隔 5 秒输出 1 组数据</span>$ <span class="token function">vmstat</span> <span class="token number">5</span>procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r  b   swpd   <span class="token function">free</span>   buff  cache   si   so    bi    bo   <span class="token keyword">in</span>   cs us sy <span class="token function">id</span> wa st <span class="token number">0</span>  <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">7005360</span>  <span class="token number">91564</span> <span class="token number">818900</span>    <span class="token number">0</span>    <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">0</span>   <span class="token number">25</span>   <span class="token number">33</span>  <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">100</span>  <span class="token number">0</span>  <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 特别关注下面几列信息：</p><ul><li>cs（context switch）是每秒上下文切换的次数。</li><li>in（interrupt）则是每秒中断的次数。</li><li>r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待 CPU 的进程数。</li><li>b（Blocked）则是处于不可中断睡眠状态的进程数。</li></ul></li><li><p>查看每个进程的上下文切换情况</p><p> vmstat 只给出了系统总体的上下文切换情况，要想查看每个进程的详细情况，就需要使用我们前面提到过的 pidstat 了。给它加上 -w 选项，你就可以查看每个进程上下文切换的情况了。</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 每隔 5 秒输出 1 组数据</span>$ pidstat -w <span class="token number">5</span>Linux <span class="token number">4.15</span>.0 <span class="token punctuation">(</span>ubuntu<span class="token punctuation">)</span>  09/23/18  _x86_64_  <span class="token punctuation">(</span><span class="token number">2</span> CPU<span class="token punctuation">)</span>08:18:26      <span class="token environment constant">UID</span>       PID   cswch/s nvcswch/s  Command08:18:31        <span class="token number">0</span>         <span class="token number">1</span>      <span class="token number">0.20</span>      <span class="token number">0.00</span>  systemd08:18:31        <span class="token number">0</span>         <span class="token number">8</span>      <span class="token number">5.40</span>      <span class="token number">0.00</span>  rcu_sched<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 特别关注下面几列信息：</p><ul><li>cswch ，表示每秒自愿上下文切换（voluntary context switches）的次数。</li><li><p>nvcswch ，表示每秒非自愿上下文切换（non voluntary context switches）的次数。</p><p>它们会反应出不同的性能问题：</p></li><li><p>自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换。</p></li><li>非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换。</li></ul></li></ol><h4 id="4-2-案例分析"><a href="#4-2-案例分析" class="headerlink" title="4.2 案例分析"></a>4.2 案例分析</h4><blockquote><p>机器配置： 2 CPU, 8 GB 内存。</p><p>安装软件：<code>apt install sysbench sysstat</code>。</p></blockquote><p>先用 vmstat 看一下空闲系统的上下文切换次数</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 间隔 1 秒后输出 1 组数据</span>$ <span class="token function">vmstat</span> <span class="token number">1</span> <span class="token number">1</span>procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r  b   swpd   <span class="token function">free</span>   buff  cache   si   so    bi    bo   <span class="token keyword">in</span>   cs us sy <span class="token function">id</span> wa st <span class="token number">0</span>  <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">6984064</span>  <span class="token number">92668</span> <span class="token number">830896</span>    <span class="token number">0</span>    <span class="token number">0</span>     <span class="token number">2</span>    <span class="token number">19</span>   <span class="token number">19</span>   <span class="token number">35</span>  <span class="token number">1</span>  <span class="token number">0</span> <span class="token number">99</span>  <span class="token number">0</span>  <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，现在的上下文切换次数 cs 是 35，而中断次数 in 是 19，r 和 b 都是 0。因为这会儿没有运行其他任务，所以它们就是空闲系统的上下文切换次数。</p><ol><li><p>在第一个终端里运行 sysbench ，模拟系统多线程调度的瓶颈</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 以 10 个线程运行 5 分钟的基准测试，模拟多线程切换的问题</span>$ sysbench --threads<span class="token operator">=</span><span class="token number">10</span> --max-time<span class="token operator">=</span><span class="token number">300</span> threads run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>在第二个终端运行 vmstat ，观察上下文切换情况</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 每隔 1 秒输出 1 组数据（需要 Ctrl+C 才结束）</span>$ <span class="token function">vmstat</span> <span class="token number">1</span>procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----r  b   swpd   <span class="token function">free</span>   buff  cache   si   so    bi    bo   <span class="token keyword">in</span>   cs us sy <span class="token function">id</span> wa st<span class="token number">6</span>  <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">6487428</span> <span class="token number">118240</span> <span class="token number">1292772</span>    <span class="token number">0</span>    <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">0</span> <span class="token number">9019</span> <span class="token number">1398830</span> <span class="token number">16</span> <span class="token number">84</span>  <span class="token number">0</span>  <span class="token number">0</span>  <span class="token number">0</span><span class="token number">8</span>  <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">6487428</span> <span class="token number">118240</span> <span class="token number">1292772</span>    <span class="token number">0</span>    <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">0</span> <span class="token number">10191</span> <span class="token number">1392312</span> <span class="token number">16</span> <span class="token number">84</span>  <span class="token number">0</span>  <span class="token number">0</span>  <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 可以发现，cs 列的上下文切换次数从之前的 35 骤然上升到了 139 万。同时，注意观察其他几个指标：</p><ul><li>r 列：就绪队列的长度已经到了 8，远远超过了系统 CPU 的个数 2，所以肯定会有大量的 CPU 竞争。</li><li>us（user）和 sy（system）列：这两列的 CPU 使用率加起来上升到了 100%，其中系统 CPU 使用率，也就是 sy 列高达 84%，说明 CPU 主要是被内核占用了。</li><li><p>in 列：中断次数也上升到了 1 万左右，说明中断处理也是个潜在的问题。</p><p>综合这几个指标，我们可以知道，系统的就绪队列过长，也就是正在运行和等待 CPU 的进程数过多，导致了大量的上下文切换，而上下文切换又导致了系统 CPU 的占用率升高。</p><p>那么到底是什么进程导致了这些问题呢？</p></li></ul></li><li><p>在第三个终端再用 pidstat 来看一下， CPU 和进程上下文切换的情况</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 每隔 1 秒输出 1 组数据（需要 Ctrl+C 才结束）</span><span class="token comment"># -w 参数表示输出进程切换指标，而 -u 参数则表示输出 CPU 使用指标</span>$ pidstat -w -u <span class="token number">1</span>08:06:33      <span class="token environment constant">UID</span>       PID    %usr %system  %guest   %wait    %CPU   CPU  Command08:06:34        <span class="token number">0</span>     <span class="token number">10488</span>   <span class="token number">30.00</span>  <span class="token number">100.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>  <span class="token number">100.00</span>     <span class="token number">0</span>  sysbench08:06:34        <span class="token number">0</span>     <span class="token number">26326</span>    <span class="token number">0.00</span>    <span class="token number">1.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">1.00</span>     <span class="token number">0</span>  kworker/u4:208:06:33      <span class="token environment constant">UID</span>       PID   cswch/s nvcswch/s  Command08:06:34        <span class="token number">0</span>         <span class="token number">8</span>     <span class="token number">11.00</span>      <span class="token number">0.00</span>  rcu_sched08:06:34        <span class="token number">0</span>        <span class="token number">16</span>      <span class="token number">1.00</span>      <span class="token number">0.00</span>  ksoftirqd/108:06:34        <span class="token number">0</span>       <span class="token number">471</span>      <span class="token number">1.00</span>      <span class="token number">0.00</span>  hv_balloon08:06:34        <span class="token number">0</span>      <span class="token number">1230</span>      <span class="token number">1.00</span>      <span class="token number">0.00</span>  iscsid08:06:34        <span class="token number">0</span>      <span class="token number">4089</span>      <span class="token number">1.00</span>      <span class="token number">0.00</span>  kworker/1:508:06:34        <span class="token number">0</span>      <span class="token number">4333</span>      <span class="token number">1.00</span>      <span class="token number">0.00</span>  kworker/0:308:06:34        <span class="token number">0</span>     <span class="token number">10499</span>      <span class="token number">1.00</span>    <span class="token number">224.00</span>  pidstat08:06:34        <span class="token number">0</span>     <span class="token number">26326</span>    <span class="token number">236.00</span>      <span class="token number">0.00</span>  kworker/u4:208:06:34     <span class="token number">1000</span>     <span class="token number">26784</span>    <span class="token number">223.00</span>      <span class="token number">0.00</span>  sshd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 从 pidstat 的输出你可以发现，CPU 使用率的升高果然是 sysbench 导致的，它的 CPU 使用率已经达到了 100%。但上下文切换则是来自其他进程，包括非自愿上下文切换频率最高的 pidstat ，以及自愿上下文切换频率最高的内核线程 kworker 和 sshd。</p><p> 不过，细心的你肯定也发现了一个怪异的事儿：pidstat 输出的上下文切换次数，加起来也就几百，比 vmstat 的 139 万明显小了太多。</p><p> 通过运行 man pidstat ，你会发现，pidstat 默认显示进程的指标数据，加上 -t 参数后，才会输出线程的指标。</p><p> 所以，在第三个终端里， Ctrl+C 停止刚才的 pidstat 命令，再加上 -t 参数，重试一下看看：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 每隔 1 秒输出一组数据（需要 Ctrl+C 才结束）</span><span class="token comment"># -wt 参数表示输出线程的上下文切换指标</span>$ pidstat -wt <span class="token number">1</span>08:14:05      <span class="token environment constant">UID</span>      TGID       TID   cswch/s nvcswch/s  Command<span class="token punctuation">..</span>.08:14:05        <span class="token number">0</span>     <span class="token number">10551</span>         -      <span class="token number">6.00</span>      <span class="token number">0.00</span>  sysbench08:14:05        <span class="token number">0</span>         -     <span class="token number">10551</span>      <span class="token number">6.00</span>      <span class="token number">0.00</span>  <span class="token operator">|</span>__sysbench08:14:05        <span class="token number">0</span>         -     <span class="token number">10552</span>  <span class="token number">18911.00</span> <span class="token number">103740.00</span>  <span class="token operator">|</span>__sysbench08:14:05        <span class="token number">0</span>         -     <span class="token number">10553</span>  <span class="token number">18915.00</span> <span class="token number">100955.00</span>  <span class="token operator">|</span>__sysbench08:14:05        <span class="token number">0</span>         -     <span class="token number">10554</span>  <span class="token number">18827.00</span> <span class="token number">103954.00</span>  <span class="token operator">|</span>__sysbench<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 现在你就能看到了，虽然 sysbench 进程（也就是主线程）的上下文切换次数看起来并不多，但它的子线程的上下文切换次数却有很多。看来，上下文切换罪魁祸首，还是过多的 sysbench 线程。</p><p> 在观察系统指标时，除了上下文切换频率骤然升高，还有一个指标也有很大的变化。是的，正是中断次数。中断次数也上升到了 1 万，但到底是什么类型的中断上升了？</p><p> 既然是中断，我们都知道，它只发生在内核态，而 pidstat 只是一个进程的性能分析工具，并不提供任何关于中断的详细信息，怎样才能知道中断发生的类型呢？</p><p> 没错，那就是从 /proc/interrupts 这个只读文件中读取。/proc 实际上是 Linux 的一个虚拟文件系统，用于内核空间与用户空间之间的通信。/proc/interrupts 就是这种通信机制的一部分，提供了一个只读的中断使用情况。</p><p> 在第三个终端里， Ctrl+C 停止刚才的 pidstat 命令，然后运行下面的命令，观察中断的变化情况：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -d 参数表示高亮显示变化的区域</span>$ <span class="token function">watch</span> -d <span class="token function">cat</span> /proc/interrupts        CPU0       CPU1<span class="token punctuation">..</span>.RES:    <span class="token number">2450431</span>    <span class="token number">5279697</span>   Rescheduling interrupts<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 观察一段时间，你可以发现，变化速度最快的是重调度中断（RES），这个中断类型表示，唤醒空闲状态的 CPU 来调度新的任务运行。这是多处理器系统（SMP）中，调度器用来分散任务到不同 CPU 的机制，通常也被称为处理器间中断（Inter-Processor Interrupts，IPI）。</p><p> 所以，这里的中断升高还是因为过多任务的调度问题，跟前面上下文切换次数的分析结果是一致的。</p><p> 通过这个案例，你应该也发现了多工具、多方面指标对比观测的好处。如果最开始时，我们只用了 pidstat 观测，这些很严重的上下文切换线程，压根儿就发现不了了。</p><p> 现在再回到最初的问题，每秒上下文切换多少次才算正常呢？</p><p> 这个数值其实取决于系统本身的 CPU 性能。在我看来，如果系统的上下文切换次数比较稳定，那么从数百到一万以内，都应该算是正常的。但当上下文切换次数超过一万次，或者切换次数出现数量级的增长时，就很可能已经出现了性能问题。</p><p> 这时，你还需要根据上下文切换的类型，再做具体分析。比方说：</p><ul><li>自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 I/O 等其他问题；</li><li>非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈；</li><li>中断次数变多了，说明 CPU 被中断处理程序占用，还需要通过查看 /proc/interrupts 文件来分析具体的中断类型。</li></ul></li></ol><h3 id="05-基础篇：某个应用的CPU使用率居然达到100-，我该怎么办？"><a href="#05-基础篇：某个应用的CPU使用率居然达到100-，我该怎么办？" class="headerlink" title="05 | 基础篇：某个应用的CPU使用率居然达到100%，我该怎么办？"></a>05 | 基础篇：某个应用的CPU使用率居然达到100%，我该怎么办？</h3><p>CPU 使用率是单位时间内 CPU 使用情况的统计，以百分比的方式展示。</p><h4 id="5-1-CPU-使用率"><a href="#5-1-CPU-使用率" class="headerlink" title="5.1 CPU 使用率"></a>5.1 CPU 使用率</h4><p>Linux 作为一个多任务操作系统，将每个 CPU 的时间划分为很短的时间片，再通过调度器轮流分配给各个任务使用，因此造成多任务同时运行的错觉。</p><p>为了维护 CPU 时间，Linux 通过事先定义的节拍率（内核中表示为 HZ），触发时间中断，并使用全局变量 Jiffies 记录了开机以来的节拍数。每发生一次时间中断，Jiffies 的值就加 1。</p><p>节拍率 HZ 是内核的可配选项，可以设置为 100、250、1000 等。不同的系统可能设置不同数值，你可以通过查询 /boot/config 内核选项来查看它的配置值。比如在我的系统中，节拍率设置成了 250，也就是每秒钟触发 250 次时间中断。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">grep</span> <span class="token string">'CONFIG_HZ='</span> /boot/config-<span class="token variable"><span class="token variable">$(</span><span class="token function">uname</span> -r<span class="token variable">)</span></span><span class="token assign-left variable">CONFIG_HZ</span><span class="token operator">=</span><span class="token number">250</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>同时，正因为节拍率 HZ 是内核选项，所以用户空间程序并不能直接访问。为了方便用户空间程序，内核还提供了一个用户空间节拍率 USER_HZ，它总是固定为 100，也就是 1/100 秒。这样，用户空间程序并不需要关心内核中 HZ 被设置成了多少，因为它看到的总是固定值 USER_HZ。</p><p>Linux 通过 /proc 虚拟文件系统，向用户空间提供了系统内部状态的信息，而 /proc/stat 提供的就是系统的 CPU 和任务统计信息。比方说，如果你只关注 CPU 的话，可以执行下面的命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 只保留各个 CPU 的数据</span>$ <span class="token function">cat</span> /proc/stat <span class="token operator">|</span> <span class="token function">grep</span> ^cpucpu  <span class="token number">280580</span> <span class="token number">7407</span> <span class="token number">286084</span> <span class="token number">172900810</span> <span class="token number">83602</span> <span class="token number">0</span> <span class="token number">583</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span>cpu0 <span class="token number">144745</span> <span class="token number">4181</span> <span class="token number">176701</span> <span class="token number">86423902</span> <span class="token number">52076</span> <span class="token number">0</span> <span class="token number">301</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span>cpu1 <span class="token number">135834</span> <span class="token number">3226</span> <span class="token number">109383</span> <span class="token number">86476907</span> <span class="token number">31525</span> <span class="token number">0</span> <span class="token number">282</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果是一个表格。其中，第一列表示的是 CPU 编号，如 cpu0、cpu1 ，而第一行没有编号的 cpu ，表示的是所有 CPU 的累加。其他列则表示不同场景下 CPU 的累加节拍数，它的单位是 USER_HZ，也就是 10 ms（1/100 秒），所以这其实就是不同场景下的 CPU 时间。</p><p>每个数字的意义可以通过 <code>man proc</code> 查询。要清楚 man proc 文档里每一列的涵义，它们都是 CPU 使用率相关的重要指标，你还会在很多其他的性能工具中看到它们。下面，我来依次解读一下。</p><ul><li>user（通常缩写为 us），代表用户态 CPU 时间。注意，它不包括下面的 nice 时间，但包括了 guest 时间。</li><li>nice（通常缩写为 ni），代表低优先级用户态 CPU 时间，也就是进程的 nice 值被调整为 1-19 之间时的 CPU 时间。这里注意，nice 可取值范围是 -20 到 19，数值越大，优先级反而越低。</li><li>system（通常缩写为 sys），代表内核态 CPU 时间。</li><li>idle（通常缩写为 id），代表空闲时间。注意，它不包括等待 I/O 的时间（iowait）。</li><li>iowait（通常缩写为 wa），代表等待 I/O 的 CPU 时间。</li><li>irq（通常缩写为 hi），代表处理硬中断的 CPU 时间。</li><li>softirq（通常缩写为 si），代表处理软中断的 CPU 时间。</li><li>steal（通常缩写为 st），代表当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间。</li><li>guest（通常缩写为 guest），代表通过虚拟化运行其他操作系统的时间，也就是运行虚拟机的 CPU 时间。</li><li>guest_nice（通常缩写为 gnice），代表以低优先级运行虚拟机的时间。</li></ul><p>CPU 使用率，就是除了空闲时间外的其他时间占总 CPU 时间的百分比，用公式来表示就是：</p><p><img src="/images/《Linux性能优化实战》学习笔记/CPU使用率公式.png" alt="CPU使用率公式"></p><p>根据这个公式，我们就可以从 /proc/stat 中的数据，很容易地计算出 CPU 使用率。当然，也可以用每一个场景的 CPU 时间，除以总的 CPU 时间，计算出每个场景的 CPU 使用率。</p><p>不过先不要着急计算，你能说出，直接用 /proc/stat 的数据，算的是什么时间段的 CPU 使用率吗？</p><p>看到这里，你应该想起来了，这是开机以来的节拍数累加值，所以直接算出来的，是开机以来的平均 CPU 使用率，一般没啥参考价值。</p><p>事实上，为了计算 CPU 使用率，性能工具一般都会取间隔一段时间（比如 3 秒）的两次值，作差后，再计算出这段时间内的平均 CPU 使用率，即</p><p><img src="/images/《Linux性能优化实战》学习笔记/平均CPU使用率公式.png" alt="平均CPU使用率公式"></p><p>这个公式，就是我们用各种性能工具所看到的 CPU 使用率的实际计算方法。</p><p>现在，我们知道了系统 CPU 使用率的计算方法，那进程的呢？跟系统的指标类似，Linux 也给每个进程提供了运行情况的统计信息，也就是 /proc/[pid]/stat。不过，这个文件包含的数据就比较丰富了，总共有 52 列的数据。</p><p><strong>性能分析工具给出的都是间隔一段时间的平均 CPU 使用率，所以要注意间隔时间的设置，特别是用多个工具对比分析时，你一定要保证它们用的是相同的间隔时间。</strong></p><p>比如，对比一下 top 和 ps 这两个工具报告的 CPU 使用率，默认的结果很可能不一样，因为 top 默认使用 3 秒时间间隔，而 ps 使用的却是进程的整个生命周期。</p><h4 id="5-2-怎么查看-CPU-使用率"><a href="#5-2-怎么查看-CPU-使用率" class="headerlink" title="5.2 怎么查看 CPU 使用率"></a>5.2 怎么查看 CPU 使用率</h4><p>top 和 ps 是最常用的性能分析工具：</p><ul><li>top 显示了系统总体的 CPU 和内存使用情况，以及各个进程的资源使用情况。</li><li>ps 则只显示了每个进程的资源使用情况。</li></ul><p>top 的输出格式为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 默认每 3 秒刷新一次</span>$ <span class="token function">top</span><span class="token function">top</span> - <span class="token number">11</span>:58:59 up <span class="token number">9</span> days, <span class="token number">22</span>:47,  <span class="token number">1</span> user,  load average: <span class="token number">0.03</span>, <span class="token number">0.02</span>, <span class="token number">0.00</span>Tasks: <span class="token number">123</span> total,   <span class="token number">1</span> running,  <span class="token number">72</span> sleeping,   <span class="token number">0</span> stopped,   <span class="token number">0</span> zombie%Cpu<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:  <span class="token number">0.3</span> us,  <span class="token number">0.3</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">99.3</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> stKiB Mem <span class="token builtin class-name">:</span>  <span class="token number">8169348</span> total,  <span class="token number">5606884</span> free,   <span class="token number">334640</span> used,  <span class="token number">2227824</span> buff/cacheKiB Swap:        <span class="token number">0</span> total,        <span class="token number">0</span> free,        <span class="token number">0</span> used.  <span class="token number">7497908</span> avail Mem  PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND    <span class="token number">1</span> root      <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">78088</span>   <span class="token number">9288</span>   <span class="token number">6696</span> S   <span class="token number">0.0</span>  <span class="token number">0.1</span>   <span class="token number">0</span>:16.83 systemd    <span class="token number">2</span> root      <span class="token number">20</span>   <span class="token number">0</span>       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> S   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.05 kthreadd    <span class="token number">4</span> root       <span class="token number">0</span> -20       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> I   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.00 kworker/0:0H<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果中，第三行 %Cpu 就是系统的 CPU 使用率，具体每一列的含义上一节都讲过，只是把 CPU 时间变换成了 CPU 使用率。不过需要注意，top 默认显示的是所有 CPU 的平均值，这个时候你只需要按下数字 1 ，就可以切换到每个 CPU 的使用率了。</p><p>继续往下看，空白行之后是进程的实时信息，每个进程都有一个 %CPU 列，表示进程的 CPU 使用率。它是用户态和内核态 CPU 使用率的总和，包括进程用户空间使用的 CPU、通过系统调用执行的内核空间 CPU 、以及在就绪队列等待运行的 CPU。在虚拟化环境中，它还包括了运行虚拟机占用的 CPU。</p><p>可以发现， top 并没有细分进程的用户态 CPU 和内核态 CPU。可以使用 pidstat 专门分析每个进程 CPU 使用情况的工具。</p><p>比如，下面的 pidstat 命令，就间隔 1 秒展示了进程的 5 组 CPU 使用率，包括：</p><ul><li>用户态 CPU 使用率 （%usr）；</li><li>内核态 CPU 使用率（%system）；</li><li>运行虚拟机 CPU 使用率（%guest）；</li><li>等待 CPU 使用率（%wait）；</li><li>以及总的 CPU 使用率（%CPU）。</li></ul><p>最后的 Average 部分，还计算了 5 组数据的平均值。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 每隔 1 秒输出一组数据，共输出 5 组</span>$ pidstat <span class="token number">1</span> <span class="token number">5</span><span class="token number">15</span>:56:02      <span class="token environment constant">UID</span>       PID    %usr %system  %guest   %wait    %CPU   CPU  Command<span class="token number">15</span>:56:03        <span class="token number">0</span>     <span class="token number">15006</span>    <span class="token number">0.00</span>    <span class="token number">0.99</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.99</span>     <span class="token number">1</span>  dockerd<span class="token punctuation">..</span>.Average:      <span class="token environment constant">UID</span>       PID    %usr %system  %guest   %wait    %CPU   CPU  CommandAverage:        <span class="token number">0</span>     <span class="token number">15006</span>    <span class="token number">0.00</span>    <span class="token number">0.99</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.99</span>     -  dockerd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-3-CPU-使用率过高怎么办？"><a href="#5-3-CPU-使用率过高怎么办？" class="headerlink" title="5.3 CPU 使用率过高怎么办？"></a>5.3 CPU 使用率过高怎么办？</h4><p>通过 top、ps、pidstat 等工具，你能够轻松找到 CPU 使用率较高（比如 100% ）的进程。接下来，你可能又想知道，占用 CPU 的到底是代码里的哪个函数呢？找到它，你才能更高效、更针对性地进行优化。</p><p>我猜你第一个想到的，应该是 GDB（The GNU Project Debugger）， 这个功能强大的程序调试利器。的确，GDB 在调试程序错误方面很强大。但是，我又要来“挑刺”了。请你记住，GDB 并不适合在性能分析的早期应用。</p><p>为什么呢？因为 GDB 调试程序的过程会中断程序运行，这在线上环境往往是不允许的。所以，GDB 只适合用在性能分析的后期，当你找到了出问题的大致函数后，线下再借助它来进一步调试函数内部的问题。</p><p>那么哪种工具适合在第一时间分析进程的 CPU 问题呢？我的推荐是 perf。perf 是 Linux 2.6.31 以后内置的性能分析工具。它以性能事件采样为基础，不仅可以分析系统的各种事件和内核性能，还可以用来分析指定应用程序的性能问题。</p><p>使用 perf 分析 CPU 性能问题，我来说两种最常见、也是我最喜欢的用法。</p><p>第一种常见用法是 perf top，类似于 top，它能够实时显示占用 CPU 时钟最多的函数或者指令，因此可以用来查找热点函数，使用界面如下所示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ perf <span class="token function">top</span>Samples: <span class="token number">833</span>  of event <span class="token string">'cpu-clock'</span>, Event count <span class="token punctuation">(</span>approx.<span class="token punctuation">)</span>: <span class="token number">97742399</span>Overhead  Shared Object       Symbol   <span class="token number">7.28</span>%  perf                <span class="token punctuation">[</span>.<span class="token punctuation">]</span> 0x00000000001f78a4   <span class="token number">4.72</span>%  <span class="token punctuation">[</span>kernel<span class="token punctuation">]</span>            <span class="token punctuation">[</span>k<span class="token punctuation">]</span> vsnprintf   <span class="token number">4.32</span>%  <span class="token punctuation">[</span>kernel<span class="token punctuation">]</span>            <span class="token punctuation">[</span>k<span class="token punctuation">]</span> module_get_kallsym   <span class="token number">3.65</span>%  <span class="token punctuation">[</span>kernel<span class="token punctuation">]</span>            <span class="token punctuation">[</span>k<span class="token punctuation">]</span> _raw_spin_unlock_irqrestore<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果中，第一行包含三个数据，分别是采样数（Samples）、事件类型（event）和事件总数量（Event count）。比如这个例子中，perf 总共采集了 833 个 CPU 时钟事件，而总事件数则为 97742399。</p><p>再往下看是一个表格式样的数据，每一行包含四列，分别是：</p><ul><li>第一列 Overhead ，是该符号的性能事件在所有采样中的比例，用百分比来表示。</li><li>第二列 Shared ，是该函数或指令所在的动态共享对象（Dynamic Shared Object），如内核、进程名、动态链接库名、内核模块名等。</li><li>第三列 Object ，是动态共享对象的类型。比如 [.] 表示用户空间的可执行程序、或者动态链接库，而 [k] 则表示内核空间。</li><li>最后一列 Symbol 是符号名，也就是函数名。当函数名未知时，用十六进制的地址来表示。</li></ul><p>以上面的输出为例，我们可以看到，占用 CPU 时钟最多的是 perf 工具自身，不过它的比例也只有 7.28%，说明系统并没有 CPU 性能问题。 perf top 的使用你应该很清楚了吧。</p><p>接着再来看第二种常见用法，也就是 perf record 和 perf report。 perf top 虽然实时展示了系统的性能信息，但它的缺点是并不保存数据，也就无法用于离线或者后续的分析。而 perf record 则提供了保存数据的功能，保存后的数据，需要你用 perf report 解析展示。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ perf record <span class="token comment"># 按 Ctrl+C 终止采样</span><span class="token punctuation">[</span> perf record: Woken up <span class="token number">1</span> <span class="token builtin class-name">times</span> to <span class="token function">write</span> data <span class="token punctuation">]</span><span class="token punctuation">[</span> perf record: Captured and wrote <span class="token number">0.452</span> MB perf.data <span class="token punctuation">(</span><span class="token number">6093</span> samples<span class="token punctuation">)</span> <span class="token punctuation">]</span>$ perf report <span class="token comment"># 展示类似于 perf top 的报告</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在实际使用中，我们还经常为 perf top 和 perf record 加上 -g 参数，开启调用关系的采样，方便我们根据调用链来分析性能问题。</p><h4 id="5-4-案例"><a href="#5-4-案例" class="headerlink" title="5.4 案例"></a>5.4 案例</h4><p>下面我们就以 Nginx + PHP 的 Web 服务为例，来看看当你发现 CPU 使用率过高的问题后，要怎么使用 top 等工具找出异常的进程，又要怎么利用 perf 找出引发性能问题的函数。</p><blockquote><p>机器配置：2 CPU，8GB 内存。</p><p>安装软件：<code>apt install docker.io sysstat linux-tools-common apache2-utils</code>。</p><blockquote><p>ab（apache bench）是一个常用的 HTTP 服务性能测试工具，这里用来模拟 Ngnix 的客户端。</p></blockquote></blockquote><ol><li><p>在第一个终端执行下面的命令来运行 Nginx 和 PHP 应用：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run --name nginx -p <span class="token number">10000</span>:80 -itd feisky/nginx$ docker run --name phpfpm -itd --network container:nginx feisky/php-fpm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>在第二个终端使用 curl 访问 <a href="http://[VM1">http://[VM1</a> 的 IP]:10000，确认 Nginx 已正常启动。你应该可以看到 It works! 的响应。</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 192.168.0.10 是第一台虚拟机的 IP 地址</span>$ <span class="token function">curl</span> http://192.168.0.10:10000/It works<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>接着，我们来测试一下这个 Nginx 服务的性能。在第二个终端运行下面的 ab 命令：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 并发 10 个请求测试 Nginx 性能，总共测试 100 个请求</span>$ ab -c <span class="token number">10</span> -n <span class="token number">100</span> http://192.168.0.10:10000/This is ApacheBench, Version <span class="token number">2.3</span> <span class="token operator">&lt;</span><span class="token variable">$Revision</span><span class="token builtin class-name">:</span> <span class="token number">1706008</span> $<span class="token operator">&gt;</span>Copyright <span class="token number">1996</span> Adam Twiss, Zeus Technology Ltd,<span class="token punctuation">..</span>.Requests per second:    <span class="token number">11.63</span> <span class="token punctuation">[</span><span class="token comment">#/sec] (mean)</span>Time per request:       <span class="token number">859.942</span> <span class="token punctuation">[</span>ms<span class="token punctuation">]</span> <span class="token punctuation">(</span>mean<span class="token punctuation">)</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 从 ab 的输出结果我们可以看到，Nginx 能承受的每秒平均请求数只有 11.63。太少了，那到底是哪里出了问题呢？我们用 top 和 pidstat 再来观察下。</p></li><li><p>我们在第二个终端，将测试的请求总数增加到 10000。这样当你在第一个终端使用性能分析工具时， Nginx 的压力还是继续。继续在第二个终端，运行 ab 命令：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ab -c <span class="token number">10</span> -n <span class="token number">10000</span> http://10.240.0.5:10000/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>回到第一个终端运行 top 命令，并按下数字 1 ，切换到每个 CPU 的使用率：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">top</span><span class="token punctuation">..</span>.%Cpu0  <span class="token builtin class-name">:</span> <span class="token number">98.7</span> us,  <span class="token number">1.3</span> sy,  <span class="token number">0.0</span> ni,  <span class="token number">0.0</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> st%Cpu1  <span class="token builtin class-name">:</span> <span class="token number">99.3</span> us,  <span class="token number">0.7</span> sy,  <span class="token number">0.0</span> ni,  <span class="token number">0.0</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> st<span class="token punctuation">..</span>.PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND<span class="token number">21514</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">16384</span>   <span class="token number">8712</span> R  <span class="token number">41.9</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:06.00 php-fpm<span class="token number">21513</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">13244</span>   <span class="token number">5572</span> R  <span class="token number">40.2</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:06.08 php-fpm<span class="token number">21515</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">16384</span>   <span class="token number">8712</span> R  <span class="token number">40.2</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:05.67 php-fpm<span class="token number">21512</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">13244</span>   <span class="token number">5572</span> R  <span class="token number">39.9</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:05.87 php-fpm<span class="token number">21516</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">16384</span>   <span class="token number">8712</span> R  <span class="token number">35.9</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:05.61 php-fpm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 这里可以看到，系统中有几个 php-fpm 进程的 CPU 使用率加起来接近 200%；而每个 CPU 的用户使用率（us）也已经超过了 98%，接近饱和。这样，我们就可以确认，正是用户空间的 php-fpm 进程，导致 CPU 使用率骤升。</p></li><li><p>那再往下走，怎么知道是 php-fpm 的哪个函数导致了 CPU 使用率升高呢？我们来用 perf 分析一下。在第一个终端运行下面的 perf 命令：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -g 开启调用关系分析，-p 指定 php-fpm 的进程号 21515</span>$ perf <span class="token function">top</span> -g -p <span class="token number">21515</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 按方向键切换到 php-fpm，再按下回车键展开 php-fpm 的调用关系，你会发现，调用关系最终到了 sqrt 和 add_function。看来，我们需要从这两个函数入手了。</p><p> <img src="/images/《Linux性能优化实战》学习笔记/CPU使用率过高案例分析perf截图.png" alt="CPU使用率过高案例分析perf截图"></p><p> 我们拷贝出 <a href="https://github.com/feiskyer/linux-perf-examples/blob/master/nginx-high-cpu/app/index.php">Nginx 应用的源码</a>，看看是不是调用了这两个函数：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 从容器 phpfpm 中将 PHP 源码拷贝出来</span>$ docker <span class="token function">cp</span> phpfpm:/app <span class="token builtin class-name">.</span><span class="token comment"># 使用 grep 查找函数调用</span>$ <span class="token function">grep</span> sqrt -r app/ <span class="token comment"># 找到了 sqrt 调用</span>app/index.php:  <span class="token variable">$x</span> <span class="token operator">+=</span> sqrt<span class="token punctuation">(</span><span class="token variable">$x</span><span class="token punctuation">)</span><span class="token punctuation">;</span>$ <span class="token function">grep</span> add_function -r app/ <span class="token comment"># 没找到 add_function 调用，这其实是 PHP 内置函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> OK，原来只有 sqrt 函数在 app/index.php 文件中调用了。那最后一步，我们就该看看这个文件的源码了：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> app/index.php<span class="token operator">&lt;</span>?php// <span class="token builtin class-name">test</span> only.<span class="token variable">$x</span> <span class="token operator">=</span> <span class="token number">0.0001</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">1000000</span><span class="token punctuation">;</span> <span class="token variable">$i</span>++<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token variable">$x</span> <span class="token operator">+=</span> sqrt<span class="token punctuation">(</span><span class="token variable">$x</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token builtin class-name">echo</span> <span class="token string">"It works!"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 呀，有没有发现问题在哪里呢？我想你要笑话我了，居然犯了一个这么傻的错误，测试代码没删就直接发布应用了。为了方便你验证优化后的效果，我把修复后的应用也打包成了一个 Docker 镜像，你可以在第一个终端中执行下面的命令来运行它：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 停止原来的应用</span>$ docker <span class="token function">rm</span> -f nginx phpfpm<span class="token comment"># 运行优化后的应用</span>$ docker run --name nginx -p <span class="token number">10000</span>:80 -itd feisky/nginx:cpu-fix$ docker run --name phpfpm -itd --network container:nginx feisky/php-fpm:cpu-fix<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>接着，到第二个终端来验证一下修复后的效果。首先 Ctrl+C 停止之前的 ab 命令后，再运行下面的命令：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ab -c <span class="token number">10</span> -n <span class="token number">10000</span> http://10.240.0.5:10000/<span class="token punctuation">..</span>.Complete requests:      <span class="token number">10000</span>Failed requests:        <span class="token number">0</span>Total transferred:      <span class="token number">1720000</span> bytesHTML transferred:       <span class="token number">90000</span> bytesRequests per second:    <span class="token number">2237.04</span> <span class="token punctuation">[</span><span class="token comment">#/sec] (mean)</span>Time per request:       <span class="token number">4.470</span> <span class="token punctuation">[</span>ms<span class="token punctuation">]</span> <span class="token punctuation">(</span>mean<span class="token punctuation">)</span>Time per request:       <span class="token number">0.447</span> <span class="token punctuation">[</span>ms<span class="token punctuation">]</span> <span class="token punctuation">(</span>mean, across all concurrent requests<span class="token punctuation">)</span>Transfer rate:          <span class="token number">375.75</span> <span class="token punctuation">[</span>Kbytes/sec<span class="token punctuation">]</span> received<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 从这里你可以发现，现在每秒的平均请求数，已经从原来的 11 变成了 2237。</p></li></ol><h4 id="5-5-小结"><a href="#5-5-小结" class="headerlink" title="5.5 小结"></a>5.5 小结</h4><p>CPU 使用率是最直观和最常用的系统性能指标，更是我们在排查性能问题时，通常会关注的第一个指标。所以我们更要熟悉它的含义，尤其要弄清楚用户（%user）、Nice（%nice）、系统（%system） 、等待 I/O（%iowait） 、中断（%irq）以及软中断（%softirq）这几种不同 CPU 的使用率。比如说：</p><ul><li>用户 CPU 和 Nice CPU 高，说明用户态进程占用了较多的 CPU，所以应该着重排查进程的性能问题。</li><li>系统 CPU 高，说明内核态占用了较多的 CPU，所以应该着重排查内核线程或者系统调用的性能问题。</li><li>I/O 等待 CPU 高，说明等待 I/O 的时间比较长，所以应该着重排查系统存储是不是出现了 I/O 问题。</li><li>软中断和硬中断高，说明软中断或硬中断的处理程序占用了较多的 CPU，所以应该着重排查内核中的中断服务程序。</li></ul><p>碰到 CPU 使用率升高的问题，你可以借助 top、pidstat 等工具，确认引发 CPU 性能问题的来源；再使用 perf 等工具，排查出引起性能问题的具体函数。</p><h3 id="06-案例篇：系统的-CPU-使用率很高，但为啥却找不到高-CPU-的应用？"><a href="#06-案例篇：系统的-CPU-使用率很高，但为啥却找不到高-CPU-的应用？" class="headerlink" title="06 | 案例篇：系统的 CPU 使用率很高，但为啥却找不到高 CPU 的应用？"></a>06 | 案例篇：系统的 CPU 使用率很高，但为啥却找不到高 CPU 的应用？</h3><p>系统的 CPU 使用率，不仅包括进程用户态和内核态的运行，还包括中断处理、等待 I/O 以及内核线程等。所以，当你发现系统的 CPU 使用率很高的时候，不一定能找到相对应的高 CPU 使用率的进程。</p><p>今天，我就用一个 Nginx + PHP 的 Web 服务的案例，带你来分析这种情况。</p><h4 id="6-1-案例分析"><a href="#6-1-案例分析" class="headerlink" title="6.1 案例分析"></a>6.1 案例分析</h4><blockquote><p>机器配置：2 CPU，8GB 内存。</p><p>安装软件：<code>apt install docker.io sysstat linux-tools-common apache2-utils</code>。</p></blockquote><ol><li><p>在第一个终端，执行下面的命令运行 Nginx 和 PHP 应用：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run --name nginx -p <span class="token number">10000</span>:80 -itd feisky/nginx:sp$ docker run --name phpfpm -itd --network container:nginx feisky/php-fpm:sp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>第二个终端，使用 curl 访问 <a href="http://[VM1">http://[VM1</a> 的 IP]:10000，确认 Nginx 已正常启动。你应该可以看到 It works! 的响应。</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 192.168.0.10 是第一台虚拟机的 IP 地址</span>$ <span class="token function">curl</span> http://192.168.0.10:10000/It works<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>来测试一下这个 Nginx 服务的性能。在第二个终端运行下面的 ab 命令。要注意，与上次操作不同的是，这次我们需要并发 100 个请求测试 Nginx 性能，总共测试 1000 个请求。</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 并发 100 个请求测试 Nginx 性能，总共测试 1000 个请求</span>$ ab -c <span class="token number">100</span> -n <span class="token number">1000</span> http://192.168.0.10:10000/This is ApacheBench, Version <span class="token number">2.3</span> <span class="token operator">&lt;</span><span class="token variable">$Revision</span><span class="token builtin class-name">:</span> <span class="token number">1706008</span> $<span class="token operator">&gt;</span>Copyright <span class="token number">1996</span> Adam Twiss, Zeus Technology Ltd,<span class="token punctuation">..</span>.Requests per second:    <span class="token number">87.86</span> <span class="token punctuation">[</span><span class="token comment">#/sec] (mean)</span>Time per request:       <span class="token number">1138.229</span> <span class="token punctuation">[</span>ms<span class="token punctuation">]</span> <span class="token punctuation">(</span>mean<span class="token punctuation">)</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 从 ab 的输出结果我们可以看到，Nginx 能承受的每秒平均请求数，只有 87 多一点，是不是感觉它的性能有点差呀。那么，到底是哪里出了问题呢？我们再用 top 和 pidstat 来观察一下。</p><p> 这次，我们在第二个终端，将测试的并发请求数改成 5，同时把请求时长设置为 10 分钟（-t 600）。这样，当你在第一个终端使用性能分析工具时， Nginx 的压力还是继续的。</p></li><li><p>继续在第二个终端运行 ab 命令：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ab -c <span class="token number">5</span> -t <span class="token number">600</span> http://192.168.0.10:10000/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>然后，我们在第一个终端运行 top 命令，观察系统的 CPU 使用情况：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">top</span><span class="token punctuation">..</span>.%Cpu<span class="token punctuation">(</span>s<span class="token punctuation">)</span>: <span class="token number">80.8</span> us, <span class="token number">15.1</span> sy,  <span class="token number">0.0</span> ni,  <span class="token number">2.8</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">1.3</span> si,  <span class="token number">0.0</span> st<span class="token punctuation">..</span>.PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND<span class="token number">6882</span> root      <span class="token number">20</span>   <span class="token number">0</span>    <span class="token number">8456</span>   <span class="token number">5052</span>   <span class="token number">3884</span> S   <span class="token number">2.7</span>  <span class="token number">0.1</span>   <span class="token number">0</span>:04.78 docker-containe<span class="token number">6947</span> systemd+  <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">33104</span>   <span class="token number">3716</span>   <span class="token number">2340</span> S   <span class="token number">2.7</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:04.92 nginx<span class="token number">7494</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">15012</span>   <span class="token number">7332</span> S   <span class="token number">2.0</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:03.55 php-fpm<span class="token number">7495</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">15160</span>   <span class="token number">7480</span> S   <span class="token number">2.0</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:03.55 php-fpm<span class="token number">10547</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">16200</span>   <span class="token number">8520</span> S   <span class="token number">2.0</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:03.13 php-fpm<span class="token number">10155</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">16200</span>   <span class="token number">8520</span> S   <span class="token number">1.7</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:03.12 php-fpm<span class="token number">10552</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">16200</span>   <span class="token number">8520</span> S   <span class="token number">1.7</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:03.12 php-fpm<span class="token number">15006</span> root      <span class="token number">20</span>   <span class="token number">0</span> <span class="token number">1168608</span>  <span class="token number">66264</span>  <span class="token number">37536</span> S   <span class="token number">1.0</span>  <span class="token number">0.8</span>   <span class="token number">9</span>:39.51 dockerd<span class="token number">4323</span> root      <span class="token number">20</span>   <span class="token number">0</span>       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> I   <span class="token number">0.3</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.87 kworker/u4:1<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 观察 top 输出的进程列表可以发现，CPU 使用率最高的进程也只不过才 2.7%，看起来并不高。</p><p> 然而，再看系统 CPU 使用率（ %Cpu ）这一行，你会发现，系统的整体 CPU 使用率是比较高的：用户 CPU 使用率（us）已经到了 80%，系统 CPU 为 15.1%，而空闲 CPU （id）则只有 2.8%。</p><p> 为什么用户 CPU 使用率这么高呢？我们再重新分析一下进程列表，看看有没有可疑进程：</p><ul><li>docker-containerd 进程是用来运行容器的，2.7% 的 CPU 使用率看起来正常；</li><li>Nginx 和 php-fpm 是运行 Web 服务的，它们会占用一些 CPU 也不意外，并且 2% 的 CPU 使用率也不算高；</li><li><p>再往下看，后面的进程呢，只有 0.3% 的 CPU 使用率，看起来不太像会导致用户 CPU 使用率达到 80%。</p><p>看来 top 是不管用了，那还有其他工具可以查看进程 CPU 使用情况吗？</p></li></ul></li><li><p>接下来，我们还是在第一个终端，运行 pidstat 命令：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 间隔 1 秒输出一组数据（按 Ctrl+C 结束）</span>$ pidstat <span class="token number">1</span><span class="token punctuation">..</span>.04:36:24      <span class="token environment constant">UID</span>       PID    %usr %system  %guest   %wait    %CPU   CPU  Command04:36:25        <span class="token number">0</span>      <span class="token number">6882</span>    <span class="token number">1.00</span>    <span class="token number">3.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">4.00</span>     <span class="token number">0</span>  docker-containe04:36:25      <span class="token number">101</span>      <span class="token number">6947</span>    <span class="token number">1.00</span>    <span class="token number">2.00</span>    <span class="token number">0.00</span>    <span class="token number">1.00</span>    <span class="token number">3.00</span>     <span class="token number">1</span>  nginx04:36:25        <span class="token number">1</span>     <span class="token number">14834</span>    <span class="token number">1.00</span>    <span class="token number">1.00</span>    <span class="token number">0.00</span>    <span class="token number">1.00</span>    <span class="token number">2.00</span>     <span class="token number">0</span>  php-fpm04:36:25        <span class="token number">1</span>     <span class="token number">14835</span>    <span class="token number">1.00</span>    <span class="token number">1.00</span>    <span class="token number">0.00</span>    <span class="token number">1.00</span>    <span class="token number">2.00</span>     <span class="token number">0</span>  php-fpm04:36:25        <span class="token number">1</span>     <span class="token number">14845</span>    <span class="token number">0.00</span>    <span class="token number">2.00</span>    <span class="token number">0.00</span>    <span class="token number">2.00</span>    <span class="token number">2.00</span>     <span class="token number">1</span>  php-fpm04:36:25        <span class="token number">1</span>     <span class="token number">14855</span>    <span class="token number">0.00</span>    <span class="token number">1.00</span>    <span class="token number">0.00</span>    <span class="token number">1.00</span>    <span class="token number">1.00</span>     <span class="token number">1</span>  php-fpm04:36:25        <span class="token number">1</span>     <span class="token number">14857</span>    <span class="token number">1.00</span>    <span class="token number">2.00</span>    <span class="token number">0.00</span>    <span class="token number">1.00</span>    <span class="token number">3.00</span>     <span class="token number">0</span>  php-fpm04:36:25        <span class="token number">0</span>     <span class="token number">15006</span>    <span class="token number">0.00</span>    <span class="token number">1.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">1.00</span>     <span class="token number">0</span>  dockerd04:36:25        <span class="token number">0</span>     <span class="token number">15801</span>    <span class="token number">0.00</span>    <span class="token number">1.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">1.00</span>     <span class="token number">1</span>  pidstat04:36:25        <span class="token number">1</span>     <span class="token number">17084</span>    <span class="token number">1.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">2.00</span>    <span class="token number">1.00</span>     <span class="token number">0</span>  stress04:36:25        <span class="token number">0</span>     <span class="token number">31116</span>    <span class="token number">0.00</span>    <span class="token number">1.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">1.00</span>     <span class="token number">0</span>  atopacctd<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 观察一会儿，你是不是发现，所有进程的 CPU 使用率也都不高啊，最高的 Docker 和 Nginx 也只有 4% 和 3%，即使所有进程的 CPU 使用率都加起来，也不过是 21%，离 80% 还差得远呢！</p><p> 后来我发现，会出现这种情况，很可能是因为前面的分析漏了一些关键信息。你可以先暂停一下，自己往上翻，重新操作检查一遍。或者，我们一起返回去分析 top 的输出，看看能不能有新发现。</p><p> 现在，我们回到第一个终端，重新运行 top 命令，并观察一会儿：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">top</span><span class="token function">top</span> - 04:58:24 up <span class="token number">14</span> days, <span class="token number">15</span>:47,  <span class="token number">1</span> user,  load average: <span class="token number">3.39</span>, <span class="token number">3.82</span>, <span class="token number">2.74</span>Tasks: <span class="token number">149</span> total,   <span class="token number">6</span> running,  <span class="token number">93</span> sleeping,   <span class="token number">0</span> stopped,   <span class="token number">0</span> zombie%Cpu<span class="token punctuation">(</span>s<span class="token punctuation">)</span>: <span class="token number">77.7</span> us, <span class="token number">19.3</span> sy,  <span class="token number">0.0</span> ni,  <span class="token number">2.0</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">1.0</span> si,  <span class="token number">0.0</span> stKiB Mem <span class="token builtin class-name">:</span>  <span class="token number">8169348</span> total,  <span class="token number">2543916</span> free,   <span class="token number">457976</span> used,  <span class="token number">5167456</span> buff/cacheKiB Swap:        <span class="token number">0</span> total,        <span class="token number">0</span> free,        <span class="token number">0</span> used.  <span class="token number">7363908</span> avail MemPID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND<span class="token number">6947</span> systemd+  <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">33104</span>   <span class="token number">3764</span>   <span class="token number">2340</span> S   <span class="token number">4.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:32.69 nginx<span class="token number">6882</span> root      <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">12108</span>   <span class="token number">8360</span>   <span class="token number">3884</span> S   <span class="token number">2.0</span>  <span class="token number">0.1</span>   <span class="token number">0</span>:31.40 docker-containe<span class="token number">15465</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">15256</span>   <span class="token number">7576</span> S   <span class="token number">2.0</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:00.62 php-fpm<span class="token number">15466</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">15196</span>   <span class="token number">7516</span> S   <span class="token number">2.0</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:00.62 php-fpm<span class="token number">15489</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">16200</span>   <span class="token number">8520</span> S   <span class="token number">2.0</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:00.62 php-fpm<span class="token number">6948</span> systemd+  <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">33104</span>   <span class="token number">3764</span>   <span class="token number">2340</span> S   <span class="token number">1.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.95 nginx<span class="token number">15006</span> root      <span class="token number">20</span>   <span class="token number">0</span> <span class="token number">1168608</span>  <span class="token number">65632</span>  <span class="token number">37536</span> S   <span class="token number">1.0</span>  <span class="token number">0.8</span>   <span class="token number">9</span>:51.09 dockerd<span class="token number">15476</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">16200</span>   <span class="token number">8520</span> S   <span class="token number">1.0</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:00.61 php-fpm<span class="token number">15477</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">16200</span>   <span class="token number">8520</span> S   <span class="token number">1.0</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:00.61 php-fpm<span class="token number">24340</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>    <span class="token number">8184</span>   <span class="token number">1616</span>    <span class="token number">536</span> R   <span class="token number">1.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.01 stress<span class="token number">24342</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>    <span class="token number">8196</span>   <span class="token number">1580</span>    <span class="token number">492</span> R   <span class="token number">1.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.01 stress<span class="token number">24344</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>    <span class="token number">8188</span>   <span class="token number">1056</span>    <span class="token number">492</span> R   <span class="token number">1.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.01 stress<span class="token number">24347</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>    <span class="token number">8184</span>   <span class="token number">1356</span>    <span class="token number">540</span> R   <span class="token number">1.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.01 stress<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 这次从头开始看 top 的每行输出，咦？Tasks 这一行看起来有点奇怪，就绪队列中居然有 6 个 Running 状态的进程（6 running），是不是有点多呢？</p><p> 回想一下 ab 测试的参数，并发请求数是 5。再看进程列表里， php-fpm 的数量也是 5，再加上 Nginx，好像同时有 6 个进程也并不奇怪。但真的是这样吗？</p><p> 再仔细看进程列表，这次主要看 Running（R） 状态的进程。你有没有发现， Nginx 和所有的 php-fpm 都处于 Sleep（S）状态，而真正处于 Running（R）状态的，却是几个 stress 进程。这几个 stress 进程就比较奇怪了，需要我们做进一步的分析。</p><p> 我们还是使用 pidstat 来分析这几个进程，并且使用 -p 选项指定进程的 PID。首先，从上面 top 的结果中，找到这几个进程的 PID。比如，先随便找一个 24344，然后用 pidstat 命令看一下它的 CPU 使用情况：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ pidstat -p <span class="token number">24344</span><span class="token number">16</span>:14:55      <span class="token environment constant">UID</span>       PID    %usr %system  %guest   %wait    %CPU   CPU  Command<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 奇怪，居然没有任何输出。难道是 pidstat 命令出问题了吗？之前我说过，<strong>在怀疑性能工具出问题前，最好还是先用其他工具交叉确认一下。</strong>那用什么工具呢？ ps 应该是最简单易用的。我们在终端里运行下面的命令，看看 24344 进程的状态：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 从所有进程中查找 PID 是 24344 的进程</span>$ <span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">grep</span> <span class="token number">24344</span>root      <span class="token number">9628</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>  <span class="token number">14856</span>  <span class="token number">1096</span> pts/0    S+   <span class="token number">16</span>:15   <span class="token number">0</span>:00 <span class="token function">grep</span> --color<span class="token operator">=</span>auto <span class="token number">24344</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 还是没有输出。现在终于发现问题，原来这个进程已经不存在了，所以 pidstat 就没有任何输出。既然进程都没了，那性能问题应该也跟着没了吧。我们再用 top 命令确认一下：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">top</span><span class="token punctuation">..</span>.%Cpu<span class="token punctuation">(</span>s<span class="token punctuation">)</span>: <span class="token number">80.9</span> us, <span class="token number">14.9</span> sy,  <span class="token number">0.0</span> ni,  <span class="token number">2.8</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">1.3</span> si,  <span class="token number">0.0</span> st<span class="token punctuation">..</span>.PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND<span class="token number">6882</span> root      <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">12108</span>   <span class="token number">8360</span>   <span class="token number">3884</span> S   <span class="token number">2.7</span>  <span class="token number">0.1</span>   <span class="token number">0</span>:45.63 docker-containe<span class="token number">6947</span> systemd+  <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">33104</span>   <span class="token number">3764</span>   <span class="token number">2340</span> R   <span class="token number">2.7</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:47.79 nginx<span class="token number">3865</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">15056</span>   <span class="token number">7376</span> S   <span class="token number">2.0</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:00.15 php-fpm<span class="token number">6779</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>    <span class="token number">8184</span>   <span class="token number">1112</span>    <span class="token number">556</span> R   <span class="token number">0.3</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.01 stress<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 好像又错了。结果还跟原来一样，用户 CPU 使用率还是高达 80.9%，系统 CPU 接近 15%，而空闲 CPU 只有 2.8%，Running 状态的进程有 Nginx、stress 等。</p><p> 可是，刚刚我们看到 stress 进程不存在了，怎么现在还在运行呢？再细看一下 top 的输出，原来，这次 stress 进程的 PID 跟前面不一样了，原来的 PID 24344 不见了，现在的是 6779。</p><p> 进程的 PID 在变，这说明什么呢？在我看来，要么是这些进程在不停地重启，要么就是全新的进程，这无非也就两个原因：</p><ul><li>第一个原因，进程在不停地崩溃重启，比如因为段错误、配置错误等等，这时，进程在退出后可能又被监控系统自动重启了。</li><li><p>第二个原因，这些进程都是短时进程，也就是在其他应用内部通过 exec 调用的外面命令。这些命令一般都只运行很短的时间就会结束，你很难用 top 这种间隔时间比较长的工具发现（上面的案例，我们碰巧发现了）。</p><p>至于 stress，我们前面提到过，它是一个常用的压力测试工具。它的 PID 在不断变化中，看起来像是被其他进程调用的短时进程。要想继续分析下去，还得找到它们的父进程。</p><p>要怎么查找一个进程的父进程呢？没错，用 pstree 就可以用树状形式显示所有进程之间的关系：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ pstree <span class="token operator">|</span> <span class="token function">grep</span> stress        <span class="token operator">|</span>-docker-containe-+-php-fpm-+-php-fpm---sh---stress        <span class="token operator">|</span>         <span class="token operator">|</span>-3*<span class="token punctuation">[</span>php-fpm---sh---stress---stress<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>从这里可以看到，stress 是被 php-fpm 调用的子进程，并且进程数量不止一个（这里是 3 个）。找到父进程后，我们能进入 app 的内部分析了。</p><p>首先，当然应该去看看它的源码。运行下面的命令，把案例应用的源码拷贝到 app 目录，然后再执行 grep 查找是不是有代码再调用 stress 命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 拷贝源码到本地</span>$ docker <span class="token function">cp</span> phpfpm:/app <span class="token builtin class-name">.</span><span class="token comment"># grep 查找看看是不是有代码在调用 stress 命令</span>$ <span class="token function">grep</span> stress -r appapp/index.php:// fake I/O with stress <span class="token punctuation">(</span>via write<span class="token punctuation">(</span><span class="token punctuation">)</span>/unlink<span class="token punctuation">(</span><span class="token punctuation">))</span>.app/index.php:<span class="token variable">$result</span> <span class="token operator">=</span> exec<span class="token punctuation">(</span><span class="token string">"/usr/local/bin/stress -t 1 -d 1 2&gt;&amp;1"</span>, <span class="token variable">$output</span>, <span class="token variable">$status</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>找到了，果然是 <a href="https://github.com/feiskyer/linux-perf-examples/blob/master/nginx-short-process/app/index.php">app/index.php</a> 文件中直接调用了 stress 命令。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> app/index.php<span class="token operator">&lt;</span>?php// fake I/O with stress <span class="token punctuation">(</span>via write<span class="token punctuation">(</span><span class="token punctuation">)</span>/unlink<span class="token punctuation">(</span><span class="token punctuation">))</span>.<span class="token variable">$result</span> <span class="token operator">=</span> exec<span class="token punctuation">(</span><span class="token string">"/usr/local/bin/stress -t 1 -d 1 2&gt;&amp;1"</span>, <span class="token variable">$output</span>, <span class="token variable">$status</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>isset<span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">"verbose"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">"verbose"</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$status</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token builtin class-name">echo</span> <span class="token string">"Server internal error: "</span><span class="token punctuation">;</span>print_r<span class="token punctuation">(</span><span class="token variable">$output</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token builtin class-name">echo</span> <span class="token string">"It works!"</span><span class="token punctuation">;</span><span class="token punctuation">}</span>?<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，源码里对每个请求都会调用一个 stress 命令，模拟 I/O 压力。从注释上看，stress 会通过 write() 和 unlink() 对 I/O 进程进行压测，看来，这应该就是系统 CPU 使用率升高的根源了。</p><p>不过，stress 模拟的是 I/O 压力，而之前在 top 的输出中看到的，却一直是用户 CPU 和系统 CPU 升高，并没见到 iowait 升高。这又是怎么回事呢？stress 到底是不是 CPU 使用率升高的原因呢？</p><p>我们还得继续往下走。从代码中可以看到，给请求加入 verbose=1 参数后，就可以查看 stress 的输出。你先试试看，在第二个终端运行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">curl</span> http://192.168.0.10:10000?verbose<span class="token operator">=</span><span class="token number">1</span>Server internal error: Array<span class="token punctuation">(</span>    <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">&gt;</span> stress: info: <span class="token punctuation">[</span><span class="token number">19607</span><span class="token punctuation">]</span> dispatching hogs: <span class="token number">0</span> cpu, <span class="token number">0</span> io, <span class="token number">0</span> vm, <span class="token number">1</span> hdd    <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">&gt;</span> stress: FAIL: <span class="token punctuation">[</span><span class="token number">19608</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">563</span><span class="token punctuation">)</span> mkstemp failed: Permission denied    <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">&gt;</span> stress: FAIL: <span class="token punctuation">[</span><span class="token number">19607</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">394</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span>-- worker <span class="token number">19608</span> returned error <span class="token number">1</span>    <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">&gt;</span> stress: WARN: <span class="token punctuation">[</span><span class="token number">19607</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">396</span><span class="token punctuation">)</span> now reaping child worker processes    <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">&gt;</span> stress: FAIL: <span class="token punctuation">[</span><span class="token number">19607</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">)</span> <span class="token function">kill</span> error: No such process    <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">&gt;</span> stress: FAIL: <span class="token punctuation">[</span><span class="token number">19607</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">451</span><span class="token punctuation">)</span> failed run completed <span class="token keyword">in</span> 0s<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看错误消息 <strong>mkstemp failed: Permission denied</strong> ，以及 <strong>failed run completed in 0s</strong>。原来 stress 命令并没有成功，它因为权限问题失败退出了。看来，我们发现了一个 PHP 调用外部 stress 命令的 bug：没有权限创建临时文件。</p><p>从这里我们可以猜测，正是由于权限错误，大量的 stress 进程在启动时初始化失败，进而导致用户 CPU 使用率的升高。</p><p>分析出问题来源，下一步是不是就要开始优化了呢？当然不是！既然只是猜测，那就需要再确认一下，这个猜测到底对不对，是不是真的有大量的 stress 进程。该用什么工具或指标呢？</p><p>我们前面已经用了 top、pidstat、pstree 等工具，没有发现大量的 stress 进程。那么，还有什么其他的工具可以用吗？</p><p>还记得上一期提到的 perf 吗？它可以用来分析 CPU 性能事件，用在这里就很合适。依旧在第一个终端中运行 perf record -g 命令 ，并等待一会儿（比如 15 秒）后按 Ctrl+C 退出。然后再运行 perf report 查看报告：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 记录性能事件，等待大约 15 秒后按 Ctrl+C 退出</span>$ perf record -g<span class="token comment"># 查看报告</span>$ perf report<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，你就可以看到下图这个性能报告：</p><p><img src="/images/《Linux性能优化实战》学习笔记/系统CPU很高但找不到应该案例分析perf截图.png" alt="系统CPU很高但找不到应该案例分析perf截图"></p><p>你看，stress 占了所有 CPU 时钟事件的 77%，而 stress 调用调用栈中比例最高的，是随机数生成函数 random()，看来它的确就是 CPU 使用率升高的元凶了。随后的优化就很简单了，只要修复权限问题，并减少或删除 stress 的调用，就可以减轻系统的 CPU 压力。</p></li></ul></li></ol><h4 id="6-2-execsnoop"><a href="#6-2-execsnoop" class="headerlink" title="6.2 execsnoop"></a>6.2 execsnoop</h4><pre><code>在这个案例中，我们使用了 top、pidstat、pstree 等工具分析了系统 CPU 使用率高的问题，并发现 CPU 升高是短时进程 stress 导致的，但是整个分析过程还是比较复杂的。对于这类问题，有没有更好的方法监控呢？[execsnoop](https://github.com/brendangregg/perf-tools/blob/master/execsnoop) 就是一个专为短时进程设计的工具。它通过 ftrace 实时监控进程的 exec() 行为，并输出短时进程的基本信息，包括进程 PID、父进程 PID、命令行参数以及执行的结果。比如，用 execsnoop 监控上述案例，就可以直接得到 stress 进程的父进程 PID 以及它的命令行参数，并可以发现大量的 stress 进程在不停启动：<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 按 Ctrl+C 结束</span>$ execsnoopPCOMM            PID    <span class="token environment constant">PPID</span>   RET ARGS<span class="token function">sh</span>               <span class="token number">30394</span>  <span class="token number">30393</span>    <span class="token number">0</span>stress           <span class="token number">30396</span>  <span class="token number">30394</span>    <span class="token number">0</span> /usr/local/bin/stress -t <span class="token number">1</span> -d <span class="token number">1</span><span class="token function">sh</span>               <span class="token number">30398</span>  <span class="token number">30393</span>    <span class="token number">0</span>stress           <span class="token number">30399</span>  <span class="token number">30398</span>    <span class="token number">0</span> /usr/local/bin/stress -t <span class="token number">1</span> -d <span class="token number">1</span><span class="token function">sh</span>               <span class="token number">30402</span>  <span class="token number">30400</span>    <span class="token number">0</span>stress           <span class="token number">30403</span>  <span class="token number">30402</span>    <span class="token number">0</span> /usr/local/bin/stress -t <span class="token number">1</span> -d <span class="token number">1</span><span class="token function">sh</span>               <span class="token number">30405</span>  <span class="token number">30393</span>    <span class="token number">0</span>stress           <span class="token number">30407</span>  <span class="token number">30405</span>    <span class="token number">0</span> /usr/local/bin/stress -t <span class="token number">1</span> -d <span class="token number">1</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>execsnoop 所用的 ftrace 是一种常用的动态追踪技术，一般用于分析 Linux 内核的运行时行为，后面课程我也会详细介绍并带你使用。</code></pre><h4 id="6-3-小结"><a href="#6-3-小结" class="headerlink" title="6.3 小结"></a>6.3 小结</h4><p>碰到常规问题无法解释的 CPU 使用率情况时，首先要想到有可能是短时应用导致的问题，比如有可能是下面这两种情况。</p><ul><li>第一，应用里直接调用了其他二进制程序，这些程序通常运行时间比较短，通过 top 等工具也不容易发现。</li><li>第二，应用本身在不停地崩溃重启，而启动过程的资源初始化，很可能会占用相当多的 CPU。</li></ul><p>对于这类进程，我们可以用 pstree 或者 execsnoop 找到它们的父进程，再从父进程所在的应用入手，排查问题的根源。</p><h3 id="07-案例篇：系统中出现大量不可中断进程和僵尸进程怎么办？（上）"><a href="#07-案例篇：系统中出现大量不可中断进程和僵尸进程怎么办？（上）" class="headerlink" title="07 | 案例篇：系统中出现大量不可中断进程和僵尸进程怎么办？（上）"></a>07 | 案例篇：系统中出现大量不可中断进程和僵尸进程怎么办？（上）</h3><h4 id="7-1-进程状态"><a href="#7-1-进程状态" class="headerlink" title="7.1 进程状态"></a>7.1 进程状态</h4><p>当 iowait 升高时，进程很可能因为得不到硬件的响应，而长时间处于不可中断状态。从 ps 或者 top 命令的输出中，你可以发现它们都处于 D 状态，也就是不可中断状态（Uninterruptible Sleep）。</p><p>top 和 ps 是最常用的查看进程状态的工具，我们就从 top 的输出开始。下面是一个 top 命令输出的示例，S 列（也就是 Status 列）表示进程的状态。从这个示例里，你可以看到 R、D、Z、S、I 等几个状态，它们分别是什么意思呢？</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">top</span>  PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND<span class="token number">28961</span> root      <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">43816</span>   <span class="token number">3148</span>   <span class="token number">4040</span> R   <span class="token number">3.2</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.01 <span class="token function">top</span>  <span class="token number">620</span> root      <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">37280</span>  <span class="token number">33676</span>    <span class="token number">908</span> D   <span class="token number">0.3</span>  <span class="token number">0.4</span>   <span class="token number">0</span>:00.01 app    <span class="token number">1</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">160072</span>   <span class="token number">9416</span>   <span class="token number">6752</span> S   <span class="token number">0.0</span>  <span class="token number">0.1</span>   <span class="token number">0</span>:37.64 systemd <span class="token number">1896</span> root      <span class="token number">20</span>   <span class="token number">0</span>       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> Z   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.00 devapp    <span class="token number">2</span> root      <span class="token number">20</span>   <span class="token number">0</span>       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> S   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.10 kthreadd    <span class="token number">4</span> root       <span class="token number">0</span> -20       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> I   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.00 kworker/0:0H    <span class="token number">6</span> root       <span class="token number">0</span> -20       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> I   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.00 mm_percpu_wq    <span class="token number">7</span> root      <span class="token number">20</span>   <span class="token number">0</span>       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> S   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:06.37 ksoftirqd/0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们挨个来看一下：</p><ul><li>R 是 Running 或 Runnable 的缩写，表示进程在 CPU 的就绪队列中，正在运行或者正在等待运行。</li><li>D 是 Disk Sleep 的缩写，也就是不可中断状态睡眠（Uninterruptible Sleep），一般表示进程正在跟硬件交互，并且交互过程不允许被其他进程或中断打断。</li><li>Z 是 Zombie 的缩写，如果你玩过“植物大战僵尸”这款游戏，应该知道它的意思。它表示僵尸进程，也就是进程实际上已经结束了，但是父进程还没有回收它的资源（比如进程的描述符、PID 等）。</li><li>S 是 Interruptible Sleep 的缩写，也就是可中断状态睡眠，表示进程因为等待某个事件而被系统挂起。当进程等待的事件发生时，它会被唤醒并进入 R 状态。</li><li>I 是 Idle 的缩写，也就是空闲状态，用在不可中断睡眠的内核线程上。前面说了，硬件交互导致的不可中断进程用 D 表示，但对某些内核线程来说，它们有可能实际上并没有任何负载，用 Idle 正是为了区分这种情况。要注意，D 状态的进程会导致平均负载升高， I 状态的进程却不会。</li></ul><p>当然了，上面的示例并没有包括进程的所有状态。除了以上 5 个状态，进程还包括下面这 2 个状态。</p><ul><li>第一个是 T 或者 t，也就是 Stopped 或 Traced 的缩写，表示进程处于暂停或者跟踪状态。<blockquote><p>向一个进程发送 SIGSTOP 信号，它就会因响应这个信号变成暂停状态（Stopped）；再向它发送 SIGCONT 信号，进程又会恢复运行（如果进程是终端里直接启动的，则需要你用 fg 命令，恢复到前台运行）。</p><p>而当你用调试器（如 gdb）调试一个进程时，在使用断点中断进程后，进程就会变成跟踪状态，这其实也是一种特殊的暂停状态，只不过你可以用调试器来跟踪并按需要控制进程的运行。</p></blockquote></li><li>另一个是 X，也就是 Dead 的缩写，表示进程已经消亡，所以你不会在 top 或者 ps 命令中看到它。</li></ul><ol><li><p>不可中断状态</p><p> 先看不可中断状态，这其实是为了保证进程数据与硬件状态一致，并且正常情况下，不可中断状态在很短时间内就会结束。所以，短时的不可中断状态进程，我们一般可以忽略。</p><p> 但如果系统或硬件发生了故障，进程可能会在不可中断状态保持很久，甚至导致系统中出现大量不可中断进程。这时，你就得注意下，系统是不是出现了 I/O 等性能问题。</p></li><li><p>僵尸进程</p><p> 再看僵尸进程，这是多进程应用很容易碰到的问题。正常情况下，当一个进程创建了子进程后，它应该通过系统调用 wait() 或者 waitpid() 等待子进程结束，回收子进程的资源；而子进程在结束时，会向它的父进程发送 SIGCHLD 信号，所以，父进程还可以注册 SIGCHLD 信号的处理函数，异步回收资源。</p><p> 如果父进程没这么做，或是子进程执行太快，父进程还没来得及处理子进程状态，子进程就已经提前退出，那这时的子进程就会变成僵尸进程。换句话说，父亲应该一直对儿子负责，善始善终，如果不作为或者跟不上，都会导致“问题少年”的出现。</p><p> 通常，僵尸进程持续的时间都比较短，在父进程回收它的资源后就会消亡；或者在父进程退出后，由 init 进程回收后也会消亡。</p><p> 一旦父进程没有处理子进程的终止，还一直保持运行状态，那么子进程就会一直处于僵尸状态。大量的僵尸进程会用尽 PID 进程号，导致新进程不能创建，所以这种情况一定要避免。</p></li></ol><h4 id="7-1-案例分析"><a href="#7-1-案例分析" class="headerlink" title="7.1 案例分析"></a>7.1 案例分析</h4><blockquote><p>机器配置： 2 CPU, 8 GB 内存。</p><p>安装软件：<code>apt install docker.io dstat sysstat</code>。</p><blockquote><p>dstat 是一个新的性能工具，它吸收了 vmstat、iostat、ifstat 等几种工具的优点，可以同时观察系统的 CPU、磁盘 I/O、网络以及内存使用情况。</p></blockquote></blockquote><ol><li><p>首先执行下面的命令运行案例应用：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run --privileged --name<span class="token operator">=</span>app -itd feisky/app:iowait<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>然后，输入 ps 命令，确认案例应用已正常启动。如果一切正常，你应该可以看到如下所示的输出：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">grep</span> /approot      <span class="token number">4009</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">4376</span>  <span class="token number">1008</span> pts/0    Ss+  05:51   <span class="token number">0</span>:00 /approot      <span class="token number">4287</span>  <span class="token number">0.6</span>  <span class="token number">0.4</span>  <span class="token number">37280</span> <span class="token number">33660</span> pts/0    D+   05:54   <span class="token number">0</span>:00 /approot      <span class="token number">4288</span>  <span class="token number">0.6</span>  <span class="token number">0.4</span>  <span class="token number">37280</span> <span class="token number">33668</span> pts/0    D+   05:54   <span class="token number">0</span>:00 /app<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 从这个界面，我们可以发现多个 app 进程已经启动，并且它们的状态分别是 Ss+ 和 D+。其中，S 表示可中断睡眠状态，D 表示不可中断睡眠状态，我们在前面刚学过，那后面的 s 和 + 是什么意思呢？不知道也没关系，查一下 <code>man ps</code> 就可以。现在记住，s 表示这个进程是一个会话的领导进程，而 + 表示前台进程组。</p><p> 这里又出现了两个新概念，进程组和会话。它们用来管理一组相互关联的进程，意思其实很好理解。</p><ul><li>进程组表示一组相互关联的进程，比如每个子进程都是父进程所在组的成员；</li><li><p>而会话是指共享同一个控制终端的一个或多个进程组。</p><p>比如，我们通过 SSH 登录服务器，就会打开一个控制终端（TTY），这个控制终端就对应一个会话。而我们在终端中运行的命令以及它们的子进程，就构成了一个个的进程组，其中，在后台运行的命令，构成后台进程组；在前台运行的命令，构成前台进程组。</p><p>明白了这些，我们再用 top 看一下系统的资源使用情况：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 按下数字 1 切换到所有 CPU 的使用情况，观察一会儿按 Ctrl+C 结束</span>$ <span class="token function">top</span><span class="token function">top</span> - 05:56:23 up <span class="token number">17</span> days, <span class="token number">16</span>:45,  <span class="token number">2</span> users,  load average: <span class="token number">2.00</span>, <span class="token number">1.68</span>, <span class="token number">1.39</span>Tasks: <span class="token number">247</span> total,   <span class="token number">1</span> running,  <span class="token number">79</span> sleeping,   <span class="token number">0</span> stopped, <span class="token number">115</span> zombie%Cpu0  <span class="token builtin class-name">:</span>  <span class="token number">0.0</span> us,  <span class="token number">0.7</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">38.9</span> id, <span class="token number">60.5</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> st%Cpu1  <span class="token builtin class-name">:</span>  <span class="token number">0.0</span> us,  <span class="token number">0.7</span> sy,  <span class="token number">0.0</span> ni,  <span class="token number">4.7</span> id, <span class="token number">94.6</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> st<span class="token punctuation">..</span>.PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND<span class="token number">4340</span> root      <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">44676</span>   <span class="token number">4048</span>   <span class="token number">3432</span> R   <span class="token number">0.3</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.05 <span class="token function">top</span><span class="token number">4345</span> root      <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">37280</span>  <span class="token number">33624</span>    <span class="token number">860</span> D   <span class="token number">0.3</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.01 app<span class="token number">4344</span> root      <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">37280</span>  <span class="token number">33624</span>    <span class="token number">860</span> D   <span class="token number">0.3</span>  <span class="token number">0.4</span>   <span class="token number">0</span>:00.01 app   <span class="token number">1</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">160072</span>   <span class="token number">9416</span>   <span class="token number">6752</span> S   <span class="token number">0.0</span>  <span class="token number">0.1</span>   <span class="token number">0</span>:38.59 systemd<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从这里你能看出什么问题吗？</p></li><li><p>先看第一行的平均负载（ Load Average），过去 1 分钟、5 分钟和 15 分钟内的平均负载在依次减小，说明平均负载正在升高；而 1 分钟内的平均负载已经达到系统的 CPU 个数，说明系统很可能已经有了性能瓶颈。</p></li><li>再看第二行的 Tasks，有 1 个正在运行的进程，但僵尸进程比较多，而且还在不停增加，说明有子进程在退出时没被清理。</li><li>接下来看两个 CPU 的使用率情况，用户 CPU 和系统 CPU 都不高，但 iowait 分别是 60.5% 和 94.6%，好像有点儿不正常。</li><li><p>最后再看每个进程的情况， CPU 使用率最高的进程只有 0.3%，看起来并不高；但有两个进程处于 D 状态，它们可能在等待 I/O，但光凭这里并不能确定是它们导致了 iowait 升高。</p><p>汇总一下：</p></li><li><p>第一点，iowait 太高了，导致系统的平均负载升高，甚至达到了系统 CPU 的个数。</p></li><li>第二点，僵尸进程在不断增多，说明有程序没能正确清理子进程的资源。</li></ul></li></ol><h4 id="7-2-小结"><a href="#7-2-小结" class="headerlink" title="7.2 小结"></a>7.2 小结</h4><p>进程的状态包括运行（R）、空闲（I）、不可中断睡眠（D）、可中断睡眠（S）、僵尸（Z）以及暂停（T）等。</p><p>其中，不可中断状态和僵尸状态，是我们今天学习的重点。</p><ul><li>不可中断状态，表示进程正在跟硬件交互，为了保护进程数据和硬件的一致性，系统不允许其他进程或中断打断这个进程。进程长时间处于不可中断状态，通常表示系统有 I/O 性能问题。</li><li>僵尸进程表示进程已经退出，但它的父进程还没有回收子进程占用的资源。短暂的僵尸状态我们通常不必理会，但进程长时间处于僵尸状态，就应该注意了，可能有应用程序没有正常处理子进程的退出。</li></ul><h3 id="08-案例篇：系统中出现大量不可中断进程和僵尸进程怎么办？（下）"><a href="#08-案例篇：系统中出现大量不可中断进程和僵尸进程怎么办？（下）" class="headerlink" title="08 | 案例篇：系统中出现大量不可中断进程和僵尸进程怎么办？（下）"></a>08 | 案例篇：系统中出现大量不可中断进程和僵尸进程怎么办？（下）</h3><p>打开一个终端，登录到上次的机器中。然后执行下面的命令，重新运行这个案例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 先删除上次启动的案例</span>$ docker <span class="token function">rm</span> -f app<span class="token comment"># 重新运行案例</span>$ docker run --privileged --name<span class="token operator">=</span>app -itd feisky/app:iowait<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="8-1-iowait-分析"><a href="#8-1-iowait-分析" class="headerlink" title="8.1 iowait 分析"></a>8.1 iowait 分析</h4><p>一提到 iowait 升高，你首先会想要查询系统的 I/O 情况。我一般也是这种思路，那么什么工具可以查询系统的 I/O 情况呢？</p><p>这里，我推荐的正是上节课要求安装的 dstat ，它的好处是，可以同时查看 CPU 和 I/O 这两种资源的使用情况，便于对比分析。</p><ol><li><p>在终端中运行 dstat 命令，观察 CPU 和 I/O 的使用情况：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 间隔 1 秒输出 10 组数据</span>$ dstat <span class="token number">1</span> <span class="token number">10</span>You did not <span class="token keyword">select</span> any stats, using -cdngy by default.--total-cpu-usage-- -dsk/total- -net/total- ---paging-- ---system--usr sys idl wai stl<span class="token operator">|</span> <span class="token builtin class-name">read</span>  writ<span class="token operator">|</span> recv  send<span class="token operator">|</span>  <span class="token keyword">in</span>   out <span class="token operator">|</span> int   csw  <span class="token number">0</span>   <span class="token number">0</span>  <span class="token number">96</span>   <span class="token number">4</span>   <span class="token number">0</span><span class="token operator">|</span>1219k  408k<span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span>  <span class="token number">42</span>   <span class="token number">885</span>  <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">2</span>  <span class="token number">98</span>   <span class="token number">0</span><span class="token operator">|</span>  34M    <span class="token number">0</span> <span class="token operator">|</span> 198B  790B<span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span>  <span class="token number">42</span>   <span class="token number">138</span>  <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span> <span class="token number">100</span>   <span class="token number">0</span><span class="token operator">|</span>  34M    <span class="token number">0</span> <span class="token operator">|</span>  66B  342B<span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span>  <span class="token number">42</span>   <span class="token number">135</span>  <span class="token number">0</span>   <span class="token number">0</span>  <span class="token number">84</span>  <span class="token number">16</span>   <span class="token number">0</span><span class="token operator">|</span>5633k    <span class="token number">0</span> <span class="token operator">|</span>  66B  342B<span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span>  <span class="token number">52</span>   <span class="token number">177</span>  <span class="token number">0</span>   <span class="token number">3</span>  <span class="token number">39</span>  <span class="token number">58</span>   <span class="token number">0</span><span class="token operator">|</span>  22M    <span class="token number">0</span> <span class="token operator">|</span>  66B  342B<span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span>  <span class="token number">43</span>   <span class="token number">144</span>  <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span> <span class="token number">100</span>   <span class="token number">0</span><span class="token operator">|</span>  34M    <span class="token number">0</span> <span class="token operator">|</span> 200B  450B<span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span>  <span class="token number">46</span>   <span class="token number">147</span>  <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">2</span>  <span class="token number">98</span>   <span class="token number">0</span><span class="token operator">|</span>  34M    <span class="token number">0</span> <span class="token operator">|</span>  66B  342B<span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span>  <span class="token number">45</span>   <span class="token number">134</span>  <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span> <span class="token number">100</span>   <span class="token number">0</span><span class="token operator">|</span>  34M    <span class="token number">0</span> <span class="token operator">|</span>  66B  342B<span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span>  <span class="token number">39</span>   <span class="token number">131</span>  <span class="token number">0</span>   <span class="token number">0</span>  <span class="token number">83</span>  <span class="token number">17</span>   <span class="token number">0</span><span class="token operator">|</span>5633k    <span class="token number">0</span> <span class="token operator">|</span>  66B  342B<span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span>  <span class="token number">46</span>   <span class="token number">168</span>  <span class="token number">0</span>   <span class="token number">3</span>  <span class="token number">39</span>  <span class="token number">59</span>   <span class="token number">0</span><span class="token operator">|</span>  22M    <span class="token number">0</span> <span class="token operator">|</span>  66B  342B<span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span>  <span class="token number">37</span>   <span class="token number">134</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 从 dstat 的输出，我们可以看到，每当 iowait 升高（wai）时，磁盘的读请求（read）都会很大。这说明 iowait 的升高跟磁盘的读请求有关，很可能就是磁盘读导致的。</p><p> 那到底是哪个进程在读磁盘呢？不知道你还记不记得，上节在 top 里看到的不可中断状态进程，我觉得它就很可疑，我们试着来分析下。</p></li><li><p>继续在刚才的终端中，运行 top 命令，观察 D 状态的进程：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 观察一会儿按 Ctrl+C 结束</span>$ <span class="token function">top</span><span class="token punctuation">..</span>. PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND<span class="token number">4340</span> root      <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">44676</span>   <span class="token number">4048</span>   <span class="token number">3432</span> R   <span class="token number">0.3</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.05 <span class="token function">top</span><span class="token number">4345</span> root      <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">37280</span>  <span class="token number">33624</span>    <span class="token number">860</span> D   <span class="token number">0.3</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.01 app<span class="token number">4344</span> root      <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">37280</span>  <span class="token number">33624</span>    <span class="token number">860</span> D   <span class="token number">0.3</span>  <span class="token number">0.4</span>   <span class="token number">0</span>:00.01 app<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 我们从 top 的输出找到 D 状态进程的 PID，你可以发现，这个界面里有两个 D 状态的进程，PID 分别是 4344 和 4345。</p><p> 一般要查看某一个进程的资源使用情况，都可以用我们的老朋友 pidstat，不过这次记得加上 -d 参数，以便输出 I/O 使用情况。</p></li><li><p>以 4344 为例，我们在终端里运行下面的 pidstat 命令，并用 -p 4344 参数指定进程号：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -d 展示 I/O 统计数据，-p 指定进程号，间隔 1 秒输出 3 组数据</span>$ pidstat -d -p <span class="token number">4344</span> <span class="token number">1</span> <span class="token number">3</span>06:38:50      <span class="token environment constant">UID</span>       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command06:38:51        <span class="token number">0</span>      <span class="token number">4344</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>       <span class="token number">0</span>  app06:38:52        <span class="token number">0</span>      <span class="token number">4344</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>       <span class="token number">0</span>  app06:38:53        <span class="token number">0</span>      <span class="token number">4344</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>       <span class="token number">0</span>  app<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 在这个输出中， kB_rd 表示每秒读的 KB 数， kB_wr 表示每秒写的 KB 数，iodelay 表示 I/O 的延迟（单位是时钟周期）。它们都是 0，那就表示此时没有任何的读写，说明问题不是 4344 进程导致的。</p><p> 可是，用同样的方法分析进程 4345，你会发现，它也没有任何磁盘读写。</p><p> 那要怎么知道，到底是哪个进程在进行磁盘读写呢？我们继续使用 pidstat，但这次去掉进程号，干脆就来观察所有进程的 I/O 使用情况。</p></li><li><p>在终端中运行下面的 pidstat 命令：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 间隔 1 秒输出多组数据 (这里是 20 组)</span>$ pidstat -d <span class="token number">1</span> <span class="token number">20</span><span class="token punctuation">..</span>.06:48:46      <span class="token environment constant">UID</span>       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command06:48:47        <span class="token number">0</span>      <span class="token number">4615</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>       <span class="token number">1</span>  kworker/u4:106:48:47        <span class="token number">0</span>      <span class="token number">6080</span>  <span class="token number">32768.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>     <span class="token number">170</span>  app06:48:47        <span class="token number">0</span>      <span class="token number">6081</span>  <span class="token number">32768.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>     <span class="token number">184</span>  app06:48:47      <span class="token environment constant">UID</span>       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command06:48:48        <span class="token number">0</span>      <span class="token number">6080</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>     <span class="token number">110</span>  app06:48:48      <span class="token environment constant">UID</span>       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command06:48:49        <span class="token number">0</span>      <span class="token number">6081</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>     <span class="token number">191</span>  app06:48:49      <span class="token environment constant">UID</span>       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command06:48:50      <span class="token environment constant">UID</span>       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command06:48:51        <span class="token number">0</span>      <span class="token number">6082</span>  <span class="token number">32768.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>       <span class="token number">0</span>  app06:48:51        <span class="token number">0</span>      <span class="token number">6083</span>  <span class="token number">32768.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>       <span class="token number">0</span>  app06:48:51      <span class="token environment constant">UID</span>       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command06:48:52        <span class="token number">0</span>      <span class="token number">6082</span>  <span class="token number">32768.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>     <span class="token number">184</span>  app06:48:52        <span class="token number">0</span>      <span class="token number">6083</span>  <span class="token number">32768.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>     <span class="token number">175</span>  app06:48:52      <span class="token environment constant">UID</span>       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command06:48:53        <span class="token number">0</span>      <span class="token number">6083</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>     <span class="token number">105</span>  app<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 观察一会儿可以发现，的确是 app 进程在进行磁盘读，并且每秒读的数据有 32 MB，看来就是 app 的问题。不过，app 进程到底在执行啥 I/O 操作呢？</p><p> 这里，我们需要回顾一下进程用户态和内核态的区别。进程想要访问磁盘，就必须使用系统调用，所以接下来，重点就是找出 app 进程的系统调用了。</p></li><li><p>strace 正是最常用的跟踪进程系统调用的工具。所以，我们从 pidstat 的输出中拿到进程的 PID 号，比如 6082，然后在终端中运行 strace 命令，并用 -p 参数指定 PID 号：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">strace</span> -p <span class="token number">6082</span>strace: attach: ptrace<span class="token punctuation">(</span>PTRACE_SEIZE, <span class="token number">6082</span><span class="token punctuation">)</span>: Operation not permitted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> <strong>一般遇到这种问题时，我会先检查一下进程的状态是否正常。</strong> 比如，继续在终端中运行 ps 命令，并使用 grep 找出刚才的 6082 号进程：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">grep</span> <span class="token number">6082</span>root      <span class="token number">6082</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> pts/0    Z+   <span class="token number">13</span>:43   <span class="token number">0</span>:00 <span class="token punctuation">[</span>app<span class="token punctuation">]</span> <span class="token operator">&lt;</span>defunct<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 果然，进程 6082 已经变成了 Z 状态，也就是僵尸进程。僵尸进程都是已经退出的进程，所以就没法儿继续分析它的系统调用。关于僵尸进程的处理方法，我们一会儿再说，现在还是继续分析 iowait 的问题。</p><p> 到这一步，你应该注意到了，系统 iowait 的问题还在继续，但是 top、pidstat 这类工具已经不能给出更多的信息了。这时，我们就应该求助那些基于事件记录的动态追踪工具了。</p></li><li><p>你可以用 perf top 看看有没有新发现。再或者，可以像我一样，在终端中运行 perf record，持续一会儿（例如 15 秒），然后按 Ctrl+C 退出，再运行 perf report 查看报告：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ perf record -g$ perf report<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 接着，找到我们关注的 app 进程，按回车键展开调用栈，你就会得到下面这张调用关系图：</p><p> <img src="/images/《Linux性能优化实战》学习笔记/大量不可中断进程和僵尸进程案例iowait分析perf截图.png" alt="大量不可中断进程和僵尸进程案例iowait分析perf截图"></p><p> 这个图里的 swapper 是内核中的调度进程，你可以先忽略掉。</p><p> 我们来看其他信息，你可以发现， app 的确在通过系统调用 sys_read() 读取数据。并且从 new_sync_read 和 blkdev_direct_IO 能看出，进程正在对磁盘进行<strong>直接读</strong>，也就是绕过了系统缓存，每个读请求都会从磁盘直接读，这就可以解释我们观察到的 iowait 升高了。</p><p> 看来，罪魁祸首是 app 内部进行了磁盘的直接 I/O 啊！</p><p> 查看源码文件 <a href="https://github.com/feiskyer/linux-perf-examples/blob/master/high-iowait-process/app.c">app.c</a>，你会发现它果然使用了 O_DIRECT 选项打开磁盘，于是绕过了系统缓存，直接对磁盘进行读写。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">open</span><span class="token punctuation">(</span>disk<span class="token punctuation">,</span> O_RDONLY<span class="token operator">|</span>O_DIRECT<span class="token operator">|</span>O_LARGEFILE<span class="token punctuation">,</span> <span class="token number">0755</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 直接读写磁盘，对 I/O 敏感型应用（比如数据库系统）是很友好的，因为你可以在应用中，直接控制磁盘的读写。但在大部分情况下，我们最好还是通过系统缓存来优化磁盘 I/O，换句话说，删除 O_DIRECT 这个选项就是了。</p><p> <a href="https://github.com/feiskyer/linux-perf-examples/blob/master/high-iowait-process/app-fix1.c">app-fix1.c</a> 就是修改后的文件，我也打包成了一个镜像文件，运行下面的命令，你就可以启动它了：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 首先删除原来的应用</span>$ docker <span class="token function">rm</span> -f app<span class="token comment"># 运行新的应用</span>$ docker run --privileged --name<span class="token operator">=</span>app -itd feisky/app:iowait-fix1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>最后，再用 top 检查一下：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">top</span><span class="token function">top</span> - <span class="token number">14</span>:59:32 up <span class="token number">19</span> min,  <span class="token number">1</span> user,  load average: <span class="token number">0.15</span>, <span class="token number">0.07</span>, <span class="token number">0.05</span>Tasks: <span class="token number">137</span> total,   <span class="token number">1</span> running,  <span class="token number">72</span> sleeping,   <span class="token number">0</span> stopped,  <span class="token number">12</span> zombie%Cpu0  <span class="token builtin class-name">:</span>  <span class="token number">0.0</span> us,  <span class="token number">1.7</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">98.0</span> id,  <span class="token number">0.3</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> st%Cpu1  <span class="token builtin class-name">:</span>  <span class="token number">0.0</span> us,  <span class="token number">1.3</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">98.7</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> st<span class="token punctuation">..</span>. PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND<span class="token number">3084</span> root      <span class="token number">20</span>   <span class="token number">0</span>       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> Z   <span class="token number">1.3</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.04 app<span class="token number">3085</span> root      <span class="token number">20</span>   <span class="token number">0</span>       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> Z   <span class="token number">1.3</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.04 app    <span class="token number">1</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">159848</span>   <span class="token number">9120</span>   <span class="token number">6724</span> S   <span class="token number">0.0</span>  <span class="token number">0.1</span>   <span class="token number">0</span>:09.03 systemd    <span class="token number">2</span> root      <span class="token number">20</span>   <span class="token number">0</span>       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> S   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.00 kthreadd    <span class="token number">3</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 你会发现， iowait 已经非常低了，只有 0.3%，说明刚才的改动已经成功修复了 iowait 高的问题。</p></li></ol><h4 id="8-2-僵尸进程"><a href="#8-2-僵尸进程" class="headerlink" title="8.2 僵尸进程"></a>8.2 僵尸进程</h4><p>既然僵尸进程是因为父进程没有回收子进程的资源而出现的，那么，要解决掉它们，就要找到它们的根儿，也就是找出父进程，然后在父进程里解决。</p><ol><li><p>父进程的找法我们前面讲过，最简单的就是运行 pstree 命令：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -a 表示输出命令行选项</span><span class="token comment"># p 表 PID</span><span class="token comment"># s 表示指定进程的父进程</span>$ pstree -aps <span class="token number">3084</span>systemd,1└─dockerd,15006 -H fd://    └─docker-containe,15024 --config /var/run/docker/containerd/containerd.toml        └─docker-containe,3991 -namespace moby -workdir<span class="token punctuation">..</span>.            └─app,4009                └─<span class="token punctuation">(</span>app,3084<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 运行完，你会发现 3084 号进程的父进程是 4009，也就是 app 应用。</p><p> 所以，我们接着查看 app 应用程序的代码，看看子进程结束的处理是否正确，比如有没有调用 wait() 或 waitpid() ，抑或是，有没有注册 SIGCHLD 信号的处理函数。</p></li><li><p>现在我们查看修复 iowait 后的源码文件 <a href="https://github.com/feiskyer/linux-perf-examples/blob/master/high-iowait-process/app-fix1.c">app-fix1.c</a> ，找到子进程的创建和清理的地方：</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">sub_process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>status<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 循环语句本来就容易出错，你能找到这里的问题吗？这段代码虽然看起来调用了 wait() 函数等待子进程结束，但却错误地把 wait() 放到了 for 死循环的外面，也就是说，wait() 函数实际上并没被调用到，我们把它挪到 for 循环的里面就可以了。</p></li><li><p>修改后的文件我放到了 <a href="https://github.com/feiskyer/linux-perf-examples/blob/master/high-iowait-process/app-fix2.c">app-fix2.c</a> 中，也打包成了一个 Docker 镜像，运行下面的命令，你就可以启动它：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 先停止产生僵尸进程的 app</span>$ docker <span class="token function">rm</span> -f app<span class="token comment"># 然后启动新的 app</span>$ docker run --privileged --name<span class="token operator">=</span>app -itd feisky/app:iowait-fix2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>启动后，再用 top 最后来检查一遍：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">top</span><span class="token function">top</span> - <span class="token number">15</span>:00:44 up <span class="token number">20</span> min,  <span class="token number">1</span> user,  load average: <span class="token number">0.05</span>, <span class="token number">0.05</span>, <span class="token number">0.04</span>Tasks: <span class="token number">125</span> total,   <span class="token number">1</span> running,  <span class="token number">72</span> sleeping,   <span class="token number">0</span> stopped,   <span class="token number">0</span> zombie%Cpu0  <span class="token builtin class-name">:</span>  <span class="token number">0.0</span> us,  <span class="token number">1.7</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">98.3</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> st%Cpu1  <span class="token builtin class-name">:</span>  <span class="token number">0.0</span> us,  <span class="token number">1.3</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">98.7</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> st<span class="token punctuation">..</span>.PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND<span class="token number">3198</span> root      <span class="token number">20</span>   <span class="token number">0</span>    <span class="token number">4376</span>    <span class="token number">840</span>    <span class="token number">780</span> S   <span class="token number">0.3</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.01 app    <span class="token number">2</span> root      <span class="token number">20</span>   <span class="token number">0</span>       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> S   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.00 kthreadd    <span class="token number">3</span> root      <span class="token number">20</span>   <span class="token number">0</span>       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> I   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.41 kworker/0:0<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 好了，僵尸进程（Z 状态）没有了， iowait 也是 0，问题终于全部解决了。</p></li></ol><h4 id="8-3-小结"><a href="#8-3-小结" class="headerlink" title="8.3 小结"></a>8.3 小结</h4><p>虽然这个案例是磁盘 I/O 导致了 iowait 升高，不过， <strong>iowait 高不一定代表 I/O 有性能瓶颈。当系统中只有 I/O 类型的进程在运行时，iowait 也会很高，但实际上，磁盘的读写远没有达到性能瓶颈的程度。</strong></p><p>因此，碰到 iowait 升高时，需要先用 dstat、pidstat 等工具，确认是不是磁盘 I/O 的问题，然后再找是哪些进程导致了 I/O。</p><p>等待 I/O 的进程一般是不可中断状态，所以用 ps 命令找到的 D 状态（即不可中断状态）的进程，多为可疑进程。但这个案例中，在 I/O 操作后，进程又变成了僵尸进程，所以不能用 strace 直接分析这个进程的系统调用。</p><p>这种情况下，我们用了 perf 工具，来分析系统的 CPU 时钟事件，最终发现是直接 I/O 导致的问题。这时，再检查源码中对应位置的问题，就很轻松了。</p><p>而僵尸进程的问题相对容易排查，使用 pstree 找出父进程后，去查看父进程的代码，检查 wait() / waitpid() 的调用，或是 SIGCHLD 信号处理函数的注册就行了。</p><h3 id="09-基础篇：怎么理解Linux软中断？"><a href="#09-基础篇：怎么理解Linux软中断？" class="headerlink" title="09 | 基础篇：怎么理解Linux软中断？"></a>09 | 基础篇：怎么理解Linux软中断？</h3><h4 id="9-1-从“取外卖”看中断"><a href="#9-1-从“取外卖”看中断" class="headerlink" title="9.1 从“取外卖”看中断"></a>9.1 从“取外卖”看中断</h4><p>中断是系统用来响应硬件设备请求的一种机制，它会打断进程的正常调度和执行，然后调用内核中的中断处理程序来响应设备的请求。</p><p>为什么要有中断呢？</p><p>比如说你订了一份外卖，但是不确定外卖什么时候送到，也没有别的方法了解外卖的进度，但是，配送员送外卖是不等人的，到了你这儿没人取的话，就直接走人了。所以你只能苦苦等着，时不时去门口看看外卖送到没，而不能干其他事情。</p><p>不过呢，如果在订外卖的时候，你就跟配送员约定好，让他送到后给你打个电话，那你就不用苦苦等待了，就可以去忙别的事情，直到电话一响，接电话、取外卖就可以了。</p><p>这里的“打电话”，其实就是一个中断。没接到电话的时候，你可以做其他的事情；只有接到了电话（也就是发生中断），你才要进行另一个动作：取外卖。</p><p>可以发现，<strong>中断其实是一种异步的事件处理机制，可以提高系统的并发处理能力。</strong></p><p>由于中断处理程序会打断其他进程的运行，所以，<strong>为了减少对正常进程运行调度的影响，中断处理程序就需要尽可能快地运行</strong>。如果中断本身要做的事情不多，那么处理起来也不会有太大问题；但如果中断要处理的事情很多，中断服务程序就有可能要运行很长时间。</p><p>特别是，中断处理程序在响应中断时，还会临时关闭中断。这就会导致上一次中断处理完成之前，其他中断都不能响应，也就是说中断有可能会丢失。</p><h4 id="9-2-软中断"><a href="#9-2-软中断" class="headerlink" title="9.2 软中断"></a>9.2 软中断</h4><p>为了解决中断处理程序执行过长和中断丢失的问题，Linux 将中断处理过程分成了两个阶段，也就是<strong>上半部和下半部</strong>：</p><ul><li>上半部用来快速处理中断，它在中断禁止模式下运行，主要处理跟硬件紧密相关的或时间敏感的工作。</li><li>下半部用来延迟处理上半部未完成的工作，通常以内核线程的方式运行。</li></ul><p>举个最常见的网卡接收数据包的例子。</p><p>网卡接收到数据包后，会通过<strong>硬件中断</strong>的方式，通知内核有新的数据到了。这时，内核就应该调用中断处理程序来响应它。</p><p>对上半部来说，既然是快速处理，其实就是要把网卡的数据读到内存中，然后更新一下硬件寄存器的状态（表示数据已经读好了），最后再发送一个<strong>软中断</strong>信号，通知下半部做进一步的处理。</p><p>而下半部被软中断信号唤醒后，需要从内存中找到网络数据，再按照网络协议栈，对数据进行逐层解析和处理，直到把它送给应用程序。</p><p>所以，这两个阶段你也可以这样理解：</p><ul><li>上半部直接处理硬件请求，也就是我们常说的硬中断，特点是快速执行；</li><li>而下半部则是由内核触发，也就是我们常说的软中断，特点是延迟执行。</li></ul><p>实际上，上半部会打断 CPU 正在执行的任务，然后立即执行中断处理程序。而下半部以内核线程的方式执行，并且每个 CPU 都对应一个软中断内核线程，名字为 “ksoftirqd/CPU 编号”，比如说， 0 号 CPU 对应的软中断内核线程的名字就是 ksoftirqd/0。</p><p>不过要注意的是，软中断不只包括了刚刚所讲的硬件设备中断处理程序的下半部，一些内核自定义的事件也属于软中断，比如内核调度和 RCU 锁（Read-Copy Update 的缩写，RCU 是 Linux 内核中最常用的锁之一）等。</p><h4 id="9-3-查看软中断和内核线程"><a href="#9-3-查看软中断和内核线程" class="headerlink" title="9.3 查看软中断和内核线程"></a>9.3 查看软中断和内核线程</h4><p>proc 文件系统可以用来查看内核的数据结构，或者用来动态修改内核的配置。其中：</p><ul><li>/proc/softirqs 提供了软中断的运行情况；</li><li>/proc/interrupts 提供了硬中断的运行情况。</li></ul><p>运行下面的命令，查看 /proc/softirqs 文件的内容，你就可以看到各种类型软中断在不同 CPU 上的累积运行次数：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> /proc/softirqs                    CPU0       CPU1          HI:          <span class="token number">0</span>          <span class="token number">0</span>       TIMER:     <span class="token number">811613</span>    <span class="token number">1972736</span>      NET_TX:         <span class="token number">49</span>          <span class="token number">7</span>      NET_RX:    <span class="token number">1136736</span>    <span class="token number">1506885</span>       BLOCK:          <span class="token number">0</span>          <span class="token number">0</span>    IRQ_POLL:          <span class="token number">0</span>          <span class="token number">0</span>     TASKLET:     <span class="token number">304787</span>       <span class="token number">3691</span>       SCHED:     <span class="token number">689718</span>    <span class="token number">1897539</span>     HRTIMER:          <span class="token number">0</span>          <span class="token number">0</span>         RCU:    <span class="token number">1330771</span>    <span class="token number">1354737</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在查看 /proc/softirqs 文件内容时，你要特别注意以下这两点。</p><ul><li>第一，要注意软中断的类型，也就是这个界面中第一列的内容。从第一列你可以看到，软中断包括了 10 个类别，分别对应不同的工作类型。比如 NET_RX 表示网络接收中断，而 NET_TX 表示网络发送中断。</li><li>第二，要注意同一种软中断在不同 CPU 上的分布情况，也就是同一行的内容。正常情况下，同一种中断在不同 CPU 上的累积次数应该差不多。比如这个界面中，NET_RX 在 CPU0 和 CPU1 上的中断次数基本是同一个数量级，相差不大。</li></ul><p>不过你可能发现，TASKLET 在不同 CPU 上的分布并不均匀。TASKLET 是最常用的软中断实现机制，每个 TASKLET 只运行一次就会结束 ，并且只在调用它的函数所在的 CPU 上运行。</p><p>因此，使用 TASKLET 特别简便，当然也会存在一些问题，比如说由于只在一个 CPU 上运行导致的调度不均衡，再比如因为不能在多个 CPU 上并行运行带来了性能限制。</p><p>另外，刚刚提到过，软中断实际上是以内核线程的方式运行的，每个 CPU 都对应一个软中断内核线程，这个软中断内核线程就叫做 ksoftirqd/CPU 编号。那要怎么查看这些线程的运行状况呢？</p><p>其实用 ps 命令就可以做到，比如执行下面的指令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">grep</span> softirqroot         <span class="token number">7</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        S    Oct10   <span class="token number">0</span>:01 <span class="token punctuation">[</span>ksoftirqd/0<span class="token punctuation">]</span>root        <span class="token number">16</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        S    Oct10   <span class="token number">0</span>:01 <span class="token punctuation">[</span>ksoftirqd/1<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意，这些线程的名字外面都有中括号，这说明 ps 无法获取它们的命令行参数（cmline）。一般来说，ps 的输出中，名字括在中括号里的，一般都是内核线程。</p><h3 id="10-案例篇：系统的软中断CPU使用率升高，我该怎么办？"><a href="#10-案例篇：系统的软中断CPU使用率升高，我该怎么办？" class="headerlink" title="10 | 案例篇：系统的软中断CPU使用率升高，我该怎么办？"></a>10 | 案例篇：系统的软中断CPU使用率升高，我该怎么办？</h3><h4 id="10-1-案例"><a href="#10-1-案例" class="headerlink" title="10.1 案例"></a>10.1 案例</h4><blockquote><p>机器配置： 2 CPU, 8 GB 内存。</p><p>安装软件：<code>apt-get install docker.io sysstat hping3 tcpdump</code>。</p><ul><li>sar 是一个系统活动报告工具，既可以实时查看系统的当前活动，又可以配置保存和报告历史统计数据。</li><li>hping3 是一个可以构造 TCP/IP 协议数据包的工具，可以对系统进行安全审计、防火墙测试等。</li><li>tcpdump 是一个常用的网络抓包工具，常用来分析各种网络问题。</li></ul></blockquote><ol><li><p>在第一个终端，执行下面的命令运行案例，也就是一个最基本的 Nginx 应用：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 运行 Nginx 服务并对外开放 80 端口</span>$ docker run -itd --name<span class="token operator">=</span>nginx -p <span class="token number">80</span>:80 nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>在第二个终端，使用 curl 访问 Nginx 监听的端口，确认 Nginx 正常启动。假设 192.168.0.30 是 Nginx 所在虚拟机的 IP 地址，运行 curl 命令后你应该会看到下面这个输出界面：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">curl</span> http://192.168.0.30/<span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">&gt;</span><span class="token operator">&lt;</span>html<span class="token operator">&gt;</span><span class="token operator">&lt;</span>head<span class="token operator">&gt;</span><span class="token operator">&lt;</span>title<span class="token operator">&gt;</span>Welcome to nginx<span class="token operator">!</span><span class="token operator">&lt;</span>/title<span class="token operator">&gt;</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>还是在第二个终端，我们运行 hping3 命令，来模拟 Nginx 的客户端请求：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -S 参数表示设置 TCP 协议的 SYN（同步序列号），-p 表示目的端口为 80</span><span class="token comment"># -i u100 表示每隔 100 微秒发送一个网络帧</span><span class="token comment"># 注：如果你在实践过程中现象不明显，可以尝试把 100 调小，比如调成 10 甚至 1</span>$ hping3 -S -p <span class="token number">80</span> -i u100 <span class="token number">192.168</span>.0.30<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 现在我们再回到第一个终端，你应该发现了异常。是不是感觉系统响应明显变慢了，即便只是在终端中敲几个回车，都得很久才能得到响应？这个时候应该怎么办呢？</p></li><li><p>先看看系统的整体资源使用情况应该是个不错的注意，比如执行下 top 看看是不是出现了 CPU 的瓶颈。我们在第一个终端运行 top 命令，看一下系统整体的资源使用情况。</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># top 运行后按数字 1 切换到显示所有 CPU</span>$ <span class="token function">top</span><span class="token function">top</span> - <span class="token number">10</span>:50:58 up <span class="token number">1</span> days, <span class="token number">22</span>:10,  <span class="token number">1</span> user,  load average: <span class="token number">0.00</span>, <span class="token number">0.00</span>, <span class="token number">0.00</span>Tasks: <span class="token number">122</span> total,   <span class="token number">1</span> running,  <span class="token number">71</span> sleeping,   <span class="token number">0</span> stopped,   <span class="token number">0</span> zombie%Cpu0  <span class="token builtin class-name">:</span>  <span class="token number">0.0</span> us,  <span class="token number">0.0</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">96.7</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">3.3</span> si,  <span class="token number">0.0</span> st%Cpu1  <span class="token builtin class-name">:</span>  <span class="token number">0.0</span> us,  <span class="token number">0.0</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">95.6</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">4.4</span> si,  <span class="token number">0.0</span> st<span class="token punctuation">..</span>.  PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND    <span class="token number">7</span> root      <span class="token number">20</span>   <span class="token number">0</span>       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> S   <span class="token number">0.3</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:01.64 ksoftirqd/0   <span class="token number">16</span> root      <span class="token number">20</span>   <span class="token number">0</span>       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> S   <span class="token number">0.3</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:01.97 ksoftirqd/1 <span class="token number">2663</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">923480</span>  <span class="token number">28292</span>  <span class="token number">13996</span> S   <span class="token number">0.3</span>  <span class="token number">0.3</span>   <span class="token number">4</span>:58.66 docker-containe <span class="token number">3699</span> root      <span class="token number">20</span>   <span class="token number">0</span>       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> I   <span class="token number">0.3</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.13 kworker/u4:0 <span class="token number">3708</span> root      <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">44572</span>   <span class="token number">4176</span>   <span class="token number">3512</span> R   <span class="token number">0.3</span>  <span class="token number">0.1</span>   <span class="token number">0</span>:00.07 <span class="token function">top</span>    <span class="token number">1</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">225384</span>   <span class="token number">9136</span>   <span class="token number">6724</span> S   <span class="token number">0.0</span>  <span class="token number">0.1</span>   <span class="token number">0</span>:23.25 systemd    <span class="token number">2</span> root      <span class="token number">20</span>   <span class="token number">0</span>       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> S   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.03 kthreadd<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 我们从第一行开始，逐个看一下：</p><ul><li>平均负载全是 0，就绪队列里面只有一个进程（1 running）。</li><li>每个 CPU 的使用率都挺低，最高的 CPU1 的使用率也只有 4.4%，并不算高。</li><li><p>再看进程列表，CPU 使用率最高的进程也只有 0.3%，还是不高呀。</p><p>仔细看 top 的输出，两个 CPU 的使用率虽然分别只有 3.3% 和 4.4%，但都用在了软中断上；而从进程列表上也可以看到，CPU 使用率最高的也是软中断进程 ksoftirqd。看起来，软中断有点可疑了。</p><p>根据上一期的内容，既然软中断可能有问题，那你先要知道，究竟是哪类软中断的问题。停下来想想，上一节我们用了什么方法，来判断软中断类型呢？没错，还是 proc 文件系统。观察 /proc/softirqs 文件的内容，你就能知道各种软中断类型的次数。</p><p>不过，这里的各类软中断次数，又是什么时间段里的次数呢？它是系统运行以来的累积中断次数。所以我们直接查看文件内容，得到的只是累积中断次数，对这里的问题并没有直接参考意义。因为，这些中断次数的变化速率才是我们需要关注的。</p><p>那什么工具可以观察命令输出的变化情况呢？我想你应该想起来了，在前面案例中用过的 watch 命令，就可以定期运行一个命令来查看输出；如果再加上 -d 参数，还可以高亮出变化的部分，从高亮部分我们就可以直观看出，哪些内容变化得更快。</p></li></ul></li><li><p>在第一个终端，我们运行下面的命令：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">watch</span> -d <span class="token function">cat</span> /proc/softirqs                    CPU0       CPU1          HI:          <span class="token number">0</span>          <span class="token number">0</span>       TIMER:    <span class="token number">1083906</span>    <span class="token number">2368646</span>      NET_TX:         <span class="token number">53</span>          <span class="token number">9</span>      NET_RX:    <span class="token number">1550643</span>    <span class="token number">1916776</span>       BLOCK:          <span class="token number">0</span>          <span class="token number">0</span>    IRQ_POLL:          <span class="token number">0</span>          <span class="token number">0</span>     TASKLET:     <span class="token number">333637</span>       <span class="token number">3930</span>       SCHED:     <span class="token number">963675</span>    <span class="token number">2293171</span>     HRTIMER:          <span class="token number">0</span>          <span class="token number">0</span>         RCU:    <span class="token number">1542111</span>    <span class="token number">1590625</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 通过 /proc/softirqs 文件内容的变化情况，你可以发现， TIMER（定时中断）、NET_RX（网络接收）、SCHED（内核调度）、RCU（RCU 锁）等这几个软中断都在不停变化。</p><p> 其中，NET_RX，也就是网络数据包接收软中断的变化速率最快。而其他几种类型的软中断，是保证 Linux 调度、时钟和临界区保护这些正常工作所必需的，所以它们有一定的变化倒是正常的。</p><p> 那么接下来，我们就从网络接收的软中断着手，继续分析。既然是网络接收的软中断，第一步应该就是观察系统的网络接收情况。这里你可能想起了很多网络工具，不过，我推荐今天的主人公工具 sar 。</p><p> sar 可以用来查看系统的网络收发情况，还有一个好处是，不仅可以观察网络收发的吞吐量（BPS，每秒收发的字节数），还可以观察网络收发的 PPS，即每秒收发的网络帧数。</p></li><li><p>在第一个终端中运行 sar 命令，并添加 -n DEV 参数显示网络收发的报告：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -n DEV 表示显示网络收发的报告，间隔 1 秒输出一组数据</span>$ sar -n DEV <span class="token number">1</span><span class="token number">15</span>:03:46        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil<span class="token number">15</span>:03:47         eth0  <span class="token number">12607.00</span>   <span class="token number">6304.00</span>    <span class="token number">664.86</span>    <span class="token number">358.11</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.01</span><span class="token number">15</span>:03:47      docker0   <span class="token number">6302.00</span>  <span class="token number">12604.00</span>    <span class="token number">270.79</span>    <span class="token number">664.66</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span><span class="token number">15</span>:03:47           lo      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span><span class="token number">15</span>:03:47  veth9f6bbcd   <span class="token number">6302.00</span>  <span class="token number">12604.00</span>    <span class="token number">356.95</span>    <span class="token number">664.66</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.05</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 对于 sar 的输出界面，我先来简单介绍一下，从左往右依次是：</p><ul><li>第一列：表示报告的时间。</li><li>第二列：IFACE 表示网卡。</li><li>第三、四列：rxpck/s 和 txpck/s 分别表示每秒接收、发送的网络帧数，也就是 PPS。</li><li><p>第五、六列：rxkB/s 和 txkB/s 分别表示每秒接收、发送的千字节数，也就是 BPS。</p><p>后面的其他参数基本接近 0，显然跟今天的问题没有直接关系，你可以先忽略掉。</p><p>我们具体来看输出的内容，你可以发现：</p></li><li><p>对网卡 eth0 来说，每秒接收的网络帧数比较大，达到了 12607，而发送的网络帧数则比较小，只有 6304；每秒接收的千字节数只有 664 KB，而发送的千字节数更小，只有 358 KB。</p></li><li><p>docker0 和 veth9f6bbcd 的数据跟 eth0 基本一致，只是发送和接收相反，发送的数据较大而接收的数据较小。这是 Linux 内部网桥转发导致的，你暂且不用深究，只要知道这是系统把 eth0 收到的包转发给 Nginx 服务即可。具体工作原理，我会在后面的网络部分详细介绍。</p><p>既然怀疑是网络接收中断的问题，我们还是重点来看 eth0 ：接收的 PPS 比较大，达到 12607，而接收的 BPS 却很小，只有 664 KB。直观来看网络帧应该都是比较小的，我们稍微计算一下，664*1024/12607 = 54 字节，说明平均每个网络帧只有 54 字节，这显然是很小的网络帧，也就是我们通常所说的小包问题。</p><p>那么，有没有办法知道这是一个什么样的网络帧，以及从哪里发过来的呢？</p><p>使用 tcpdump 抓取 eth0 上的包就可以了。我们事先已经知道， Nginx 监听在 80 端口，它所提供的 HTTP 服务是基于 TCP 协议的，所以我们可以指定 TCP 协议和 80 端口精确抓包。</p></li></ul></li><li><p>接下来，我们在第一个终端中运行 tcpdump 命令，通过 -i eth0 选项指定网卡 eth0，并通过 tcp port 80 选项指定 TCP 协议的 80 端口：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -i eth0 只抓取 eth0 网卡，-n 不解析协议名和主机名</span><span class="token comment"># tcp port 80 表示只抓取 tcp 协议并且端口号为 80 的网络帧</span>$ tcpdump -i eth0 -n tcp port <span class="token number">80</span><span class="token number">15</span>:11:32.678966 IP <span class="token number">192.168</span>.0.2.18238 <span class="token operator">&gt;</span> <span class="token number">192.168</span>.0.30.80: Flags <span class="token punctuation">[</span>S<span class="token punctuation">]</span>, <span class="token function">seq</span> <span class="token number">458303614</span>, win <span class="token number">512</span>, length <span class="token number">0</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 从 tcpdump 的输出中，你可以发现：</p><ul><li>192.168.0.2.18238 &gt; 192.168.0.30.80 ，表示网络帧从 192.168.0.2 的 18238 端口发送到 192.168.0.30 的 80 端口，也就是从运行 hping3 机器的 18238 端口发送网络帧，目的为 Nginx 所在机器的 80 端口。</li><li><p>Flags [S] 则表示这是一个 SYN 包。</p><p>再加上前面用 sar 发现的， PPS 超过 12000 的现象，现在我们可以确认，这就是从 192.168.0.2 这个地址发送过来的 SYN FLOOD 攻击。</p><p>SYN FLOOD 问题最简单的解决方法，就是从交换机或者硬件防火墙中封掉来源 IP，这样 SYN FLOOD 网络帧就不会发送到服务器中。</p></li></ul></li></ol><h4 id="10-2-终端卡顿的问题"><a href="#10-2-终端卡顿的问题" class="headerlink" title="10.2 终端卡顿的问题"></a>10.2 终端卡顿的问题</h4><p>这个是由于网络延迟增大（甚至是丢包）导致的。比如你可以再拿另外一台机器（也就是第三台）在 hping3 运行的前后 ping 一下案例机器，ping -c3 <ip></ip></p><p>hping3 运行前，你可能看到最长的也不超过 1 ms：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">3 packets transmitted, 3 received, 0% packet loss, time 2028msrtt min/avg/max/mdev = 0.815/0.914/0.989/0.081 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>而 hping3 运行时，不仅平均延迟增长到了 245 ms，而且还会有丢包的发生：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">3 packets transmitted, 2 received, 33% packet loss, time 2026msrtt min/avg/max/mdev = 240.637/245.758/250.880/5.145 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="11-套路篇：如何迅速分析出系统CPU的瓶颈在哪里？"><a href="#11-套路篇：如何迅速分析出系统CPU的瓶颈在哪里？" class="headerlink" title="11 | 套路篇：如何迅速分析出系统CPU的瓶颈在哪里？"></a>11 | 套路篇：如何迅速分析出系统CPU的瓶颈在哪里？</h3><h4 id="11-1-CPU-性能指标"><a href="#11-1-CPU-性能指标" class="headerlink" title="11.1 CPU 性能指标"></a>11.1 CPU 性能指标</h4><ol><li><p>最容易想到的应该是 CPU 使用率。</p><p> CPU 使用率描述了非空闲时间占总 CPU 时间的百分比，根据 CPU 上运行任务的不同，又被分为用户 CPU、系统 CPU、等待 I/O CPU、软中断和硬中断等。</p><ul><li>用户 CPU 使用率，包括用户态 CPU 使用率（user）和低优先级用户态 CPU 使用率（nice），表示 CPU 在用户态运行的时间百分比。用户 CPU 使用率高，通常说明有应用程序比较繁忙。</li><li>系统 CPU 使用率，表示 CPU 在内核态运行的时间百分比（不包括中断）。系统 CPU 使用率高，说明内核比较繁忙。</li><li>等待 I/O 的 CPU 使用率，通常也称为 iowait，表示等待 I/O 的时间百分比。iowait 高，通常说明系统与硬件设备的 I/O 交互时间比较长。</li><li>软中断和硬中断的 CPU 使用率，分别表示内核调用软中断处理程序、硬中断处理程序的时间百分比。它们的使用率高，通常说明系统发生了大量的中断。</li><li>除了上面这些，还有在虚拟化环境中会用到的窃取 CPU 使用率（steal）和客户 CPU 使用率（guest），分别表示被其他虚拟机占用的 CPU 时间百分比，和运行客户虚拟机的 CPU 时间百分比。</li></ul></li><li><p>第二个比较容易想到的，应该是平均负载（Load Average）。</p><p> 平均负载（Load Average），也就是系统的平均活跃进程数。它反应了系统的整体负载情况，主要包括三个数值，分别指过去 1 分钟、过去 5 分钟和过去 15 分钟的平均负载。</p><p> 理想情况下，平均负载等于逻辑 CPU 个数，这表示每个 CPU 都恰好被充分利用。如果平均负载大于逻辑 CPU 个数，就表示负载比较重了。</p></li><li><p>第三个，也是在专栏学习前你估计不太会注意到的，进程上下文切换。</p><p> 包括：</p><ul><li>无法获取资源而导致的自愿上下文切换；</li><li><p>被系统强制调度导致的非自愿上下文切换。</p><p>上下文切换，本身是保证 Linux 正常运行的一项核心功能。但过多的上下文切换，会将原本运行进程的 CPU 时间，消耗在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，缩短进程真正运行的时间，成为性能瓶颈。</p></li></ul></li><li><p>还有一个指标，CPU 缓存的命中率。</p><p> 由于 CPU 发展的速度远快于内存的发展，CPU 的处理速度就比内存的访问速度快得多。这样，CPU 在访问内存的时候，免不了要等待内存的响应。为了协调这两者巨大的性能差距，CPU 缓存（通常是多级缓存）就出现了。</p><p> <img src="/images/《Linux性能优化实战》学习笔记/CPU缓存架构.png" alt="CPU缓存架构"></p><p> 就像上面这张图显示的，CPU 缓存的速度介于 CPU 和内存之间，缓存的是热点的内存数据。根据不断增长的热点数据，这些缓存按照大小不同分为 L1、L2、L3 等三级缓存，其中 L1 和 L2 常用在单核中， L3 则用在多核中。</p><p> 从 L1 到 L3，三级缓存的大小依次增大，相应的，性能依次降低（当然比内存还是好得多）。而它们的命中率，衡量的是 CPU 缓存的复用情况，命中率越高，则表示性能越好。</p></li></ol><p><img src="/images/《Linux性能优化实战》学习笔记/CPU性能指标筛选清单.png" alt="CPU性能指标筛选清单"></p><h4 id="11-2-性能工具"><a href="#11-2-性能工具" class="headerlink" title="11.2 性能工具"></a>11.2 性能工具</h4><ol><li><p>平均负载的案例。</p><p> 我们先用 uptime， 查看了系统的平均负载；而在平均负载升高后，又用 mpstat 和 pidstat ，分别观察了每个 CPU 和每个进程 CPU 的使用情况，进而找出了导致平均负载升高的进程，也就是我们的压测工具 stress。</p></li><li><p>上下文切换的案例。</p><p> 我们先用 vmstat ，查看了系统的上下文切换次数和中断次数；然后通过 pidstat ，观察了进程的自愿上下文切换和非自愿上下文切换情况；最后通过 pidstat ，观察了线程的上下文切换情况，找出了上下文切换次数增多的根源，也就是我们的基准测试工具 sysbench。</p></li><li><p>进程 CPU 使用率升高的案例。</p><p> 我们先用 top ，查看了系统和进程的 CPU 使用情况，发现 CPU 使用率升高的进程是 php-fpm；再用 perf top ，观察 php-fpm 的调用链，最终找出 CPU 升高的根源，也就是库函数 sqrt() 。</p></li><li><p>系统的 CPU 使用率升高的案例。</p><p> 我们先用 top 观察到了系统 CPU 升高，但通过 top 和 pidstat ，却找不出高 CPU 使用率的进程。于是，我们重新审视 top 的输出，又从 CPU 使用率不高但处于 Running 状态的进程入手，找出了可疑之处，最终通过 perf record 和 perf report ，发现原来是短时进程在捣鬼。</p><p> 另外，对于短时进程，我还介绍了一个专门的工具 execsnoop，它可以实时监控进程调用的外部命令。</p></li><li><p>不可中断进程和僵尸进程的案例。</p><p> 我们先用 top 观察到了 iowait 升高的问题，并发现了大量的不可中断进程和僵尸进程；接着我们用 dstat 发现是这是由磁盘读导致的，于是又通过 pidstat 找出了相关的进程。但我们用 strace 查看进程系统调用却失败了，最终还是用 perf 分析进程调用链，才发现根源在于磁盘直接 I/O 。</p></li><li><p>软中断的案例。</p><p> 我们通过 top 观察到，系统的软中断 CPU 使用率升高；接着查看 /proc/softirqs， 找到了几种变化速率较快的软中断；然后通过 sar 命令，发现是网络小包的问题，最后再用 tcpdump ，找出网络帧的类型和来源，确定是一个 SYN FLOOD 攻击导致的。</p></li></ol><h4 id="11-3-活学活用，把性能指标和性能工具联系起来"><a href="#11-3-活学活用，把性能指标和性能工具联系起来" class="headerlink" title="11.3 活学活用，把性能指标和性能工具联系起来"></a>11.3 活学活用，把性能指标和性能工具联系起来</h4><ol><li><p>第一个维度，从 CPU 的性能指标出发。也就是说，当你要查看某个性能指标时，要清楚知道哪些工具可以做到。</p><p> 根据不同的性能指标，对提供指标的性能工具进行分类和理解。这样，在实际排查性能问题时，你就可以清楚知道，什么工具可以提供你想要的指标，而不是毫无根据地挨个尝试，撞运气。</p><p> 比如用 top 发现了软中断 CPU 使用率高后，下一步自然就想知道具体的软中断类型。那在哪里可以观察各类软中断的运行情况呢？当然是 proc 文件系统中的 /proc/softirqs 这个文件。</p><p> 紧接着，比如说，我们找到的软中断类型是网络接收，那就要继续往网络接收方向思考。系统的网络接收情况是什么样的？什么工具可以查到网络接收情况呢？在我们案例中，用的正是 dstat。</p><p> <img src="/images/《Linux性能优化实战》学习笔记/根据指标找工具（CPU性能）.png" alt="根据指标找工具（CPU性能）"></p></li><li><p>第二个维度，从工具出发。也就是当你已经安装了某个工具后，要知道这个工具能提供哪些指标。</p><p> <img src="/images/《Linux性能优化实战》学习笔记/根据工具查指标（CPU性能）.png" alt="根据工具查指标（CPU性能）"></p></li></ol><h4 id="11-4-如何迅速分析-CPU-的性能瓶颈"><a href="#11-4-如何迅速分析-CPU-的性能瓶颈" class="headerlink" title="11.4 如何迅速分析 CPU 的性能瓶颈"></a>11.4 如何迅速分析 CPU 的性能瓶颈</h4><p>虽然 CPU 的性能指标比较多，但要知道，既然都是描述系统的 CPU 性能，它们就不会是完全孤立的，很多指标间都有一定的关联。<strong>想弄清楚性能指标的关联性，就要通晓每种性能指标的工作原理</strong>。这也是为什么我在介绍每个性能指标时，都要穿插讲解相关的系统原理，希望你能记住这一点。</p><p>举个例子，用户 CPU 使用率高，我们应该去排查进程的用户态而不是内核态。因为用户 CPU 使用率反映的就是用户态的 CPU 使用情况，而内核态的 CPU 使用情况只会反映到系统 CPU 使用率上。</p><p>所以，<strong>为了缩小排查范围，我通常会先运行几个支持指标较多的工具，如 top、vmstat 和 pidstat</strong>。为什么是这三个工具呢？仔细看看下面这张图，你就清楚了。</p><p><img src="/images/《Linux性能优化实战》学习笔记/如何迅速分析CPU的性能瓶颈.png" alt="如何迅速分析CPU的性能瓶颈"></p><p>这张图里，我列出了 top、vmstat 和 pidstat 分别提供的重要的 CPU 指标，并用虚线表示关联关系，对应出了性能分析下一步的方向。</p><p>通过这张图你可以发现，这三个命令，几乎包含了所有重要的 CPU 性能指标，比如：</p><ul><li>从 top 的输出可以得到各种 CPU 使用率以及僵尸进程和平均负载等信息。</li><li>从 vmstat 的输出可以得到上下文切换次数、中断次数、运行状态和不可中断状态的进程数。</li><li>从 pidstat 的输出可以得到进程的用户 CPU 使用率、系统 CPU 使用率、以及自愿上下文切换和非自愿上下文切换情况。</li></ul><p>另外，这三个工具输出的很多指标是相互关联的，所以，我也用虚线表示了它们的关联关系，举几个例子你可能会更容易理解。</p><ol><li><p>第一个例子，pidstat 输出的进程用户 CPU 使用率升高，会导致 top 输出的用户 CPU 使用率升高。所以，当发现 top 输出的用户 CPU 使用率有问题时，可以跟 pidstat 的输出做对比，观察是否是某个进程导致的问题。</p><p> 而找出导致性能问题的进程后，就要用进程分析工具来分析进程的行为，比如使用 strace 分析系统调用情况，以及使用 perf 分析调用链中各级函数的执行情况。</p></li><li><p>第二个例子，top 输出的平均负载升高，可以跟 vmstat 输出的运行状态和不可中断状态的进程数做对比，观察是哪种进程导致的负载升高。</p><ul><li>如果是不可中断进程数增多了，那么就需要做 I/O 的分析，也就是用 dstat 或 sar 等工具，进一步分析 I/O 的情况。</li><li>如果是运行状态进程数增多了，那就需要回到 top 和 pidstat，找出这些处于运行状态的到底是什么进程，然后再用进程分析工具，做进一步分析。</li></ul></li><li><p>最后一个例子，当发现 top 输出的软中断 CPU 使用率升高时，可以查看 /proc/softirqs 文件中各种类型软中断的变化情况，确定到底是哪种软中断出的问题。比如，发现是网络接收中断导致的问题，那就可以继续用网络分析工具 sar 和 tcpdump 来分析。</p></li></ol><h3 id="12-套路篇：CPU-性能优化的几个思路"><a href="#12-套路篇：CPU-性能优化的几个思路" class="headerlink" title="12 | 套路篇：CPU 性能优化的几个思路"></a>12 | 套路篇：CPU 性能优化的几个思路</h3><h4 id="12-1-性能优化方法论"><a href="#12-1-性能优化方法论" class="headerlink" title="12.1 性能优化方法论"></a>12.1 性能优化方法论</h4><p>通过各种性能分析方法，终于找到引发性能问题的瓶颈后，是不是立刻就要开始优化了呢？别急，动手之前，你可以先看看下面这三个问题。</p><ul><li>首先，既然要做性能优化，那要怎么判断它是不是有效呢？特别是优化后，到底能提升多少性能呢？</li><li>第二，性能问题通常不是独立的，如果有多个性能问题同时发生，你应该先优化哪一个呢？</li><li>第三，提升性能的方法并不是唯一的，当有多种方法可以选择时，你会选用哪一种呢？是不是总选那个最大程度提升性能的方法就行了呢？</li></ul><p>如果你可以轻松回答这三个问题，那么二话不说就可以开始优化。</p><p>比如，在前面的不可中断进程案例中，通过性能分析，我们发现是因为一个进程的直接 I/O ，导致了 iowait 高达 90%。那是不是用“直接 I/O 换成缓存 I/O”的方法，就可以立即优化了呢？</p><p>按照上面讲的，你可以先自己思考下那三点。如果不能确定，我们一起来看看。</p><ul><li>第一个问题，直接 I/O 换成缓存 I/O，可以把 iowait 从 90% 降到接近 0，性能提升很明显。</li><li>第二个问题，我们没有发现其他性能问题，直接 I/O 是唯一的性能瓶颈，所以不用挑选优化对象。</li><li>第三个问题，缓存 I/O 是我们目前用到的最简单的优化方法，而且这样优化并不会影响应用的功能。</li></ul><p>好的，这三个问题很容易就能回答，所以立即优化没有任何问题。</p><h4 id="12-2-怎么评估性能优化的效果？"><a href="#12-2-怎么评估性能优化的效果？" class="headerlink" title="12.2 怎么评估性能优化的效果？"></a>12.2 怎么评估性能优化的效果？</h4><p>我们解决性能问题的目的，自然是想得到一个性能提升的效果。为了评估这个效果，我们需要对系统的性能指标进行量化，并且要分别测试出优化前、后的性能指标，用前后指标的变化来对比呈现效果。我把这个方法叫做性能评估“三步走”。</p><ol><li><p>确定性能的量化指标。</p><p> 我的建议是不要局限在单一维度的指标上，你至少要从应用程序和系统资源这两个维度，分别选择不同的指标。比如，以 Web 应用为例：</p><ul><li>应用程序的维度，我们可以用吞吐量和请求延迟来评估应用程序的性能。</li><li><p>系统资源的维度，我们可以用 CPU 使用率来评估系统的 CPU 使用情况。</p><p>之所以从这两个不同维度选择指标，主要是因为应用程序和系统资源这两者间相辅相成的关系。</p></li><li><p>好的应用程序是性能优化的最终目的和结果，系统优化总是为应用程序服务的。所以，必须要使用应用程序的指标，来评估性能优化的整体效果。</p></li><li>系统资源的使用情况是影响应用程序性能的根源。所以，需要用系统资源的指标，来观察和分析瓶颈的来源。</li></ul></li><li><p>测试优化前的性能指标。</p></li><li><p>测试优化后的性能指标。</p></li></ol><p>以刚刚的 Web 应用为例，对应上面提到的几个指标，我们可以选择 ab 等工具，测试 Web 应用的并发请求数和响应延迟。而测试的同时，还可以用 vmstat、pidstat 等性能工具，观察系统和进程的 CPU 使用率。这样，我们就同时获得了应用程序和系统资源这两个维度的指标数值。</p><p>不过，在进行性能测试时，有两个特别重要的地方你需要注意下。</p><ol><li><p>第一，要避免性能测试工具干扰应用程序的性能。通常，对 Web 应用来说，性能测试工具跟目标应用程序要在不同的机器上运行。</p><p> 比如，在之前的 Nginx 案例中，我每次都会强调要用两台虚拟机，其中一台运行 Nginx 服务，而另一台运行模拟客户端的工具，就是为了避免这个影响。</p></li><li><p>第二，避免外部环境的变化影响性能指标的评估。这要求优化前、后的应用程序，都运行在相同配置的机器上，并且它们的外部依赖也要完全一致。</p><p> 比如还是拿 Nginx 来说，就可以运行在同一台机器上，并用相同参数的客户端工具来进行性能测试。</p></li></ol><h4 id="12-3-多个性能问题同时存在，要怎么选择？"><a href="#12-3-多个性能问题同时存在，要怎么选择？" class="headerlink" title="12.3 多个性能问题同时存在，要怎么选择？"></a>12.3 多个性能问题同时存在，要怎么选择？</h4><p>系统性能总是牵一发而动全身，所以性能问题通常也不是独立存在的。那当多个性能问题同时发生的时候，应该先去优化哪一个呢？</p><p>在性能测试的领域，流传很广的一个说法是“二八原则”，也就是说 80% 的问题都是由 20% 的代码导致的。只要找出这 20% 的位置，你就可以优化 80% 的性能。所以，我想表达的是，<strong>并不是所有的性能问题都值得优化</strong>。</p><p>我的建议是，动手优化之前先动脑，先把所有这些性能问题给分析一遍，找出最重要的、可以最大程度提升性能的问题，从它开始优化。这样的好处是，不仅性能提升的收益最大，而且很可能其他问题都不用优化，就已经满足了性能要求。</p><p>那关键就在于，怎么判断出哪个性能问题最重要。这其实还是我们性能分析要解决的核心问题，只不过这里要分析的对象，从原来的一个问题，变成了多个问题，思路其实还是一样的。</p><p>所以，你依然可以用我前面讲过的方法挨个分析，分别找出它们的瓶颈。分析完所有问题后，再按照因果等关系，排除掉有因果关联的性能问题。最后，再对剩下的性能问题进行优化。</p><p>如果剩下的问题还是好几个，你就得分别进行性能测试了。比较不同的优化效果后，选择能明显提升性能的那个问题进行修复。这个过程通常会花费较多的时间，这里，我推荐两个可以简化这个过程的方法。</p><ol><li>第一，如果发现是系统资源达到了瓶颈，比如 CPU 使用率达到了 100%，那么首先优化的一定是系统资源使用问题。完成系统资源瓶颈的优化后，我们才要考虑其他问题。</li><li>第二，针对不同类型的指标，首先去优化那些由瓶颈导致的，性能指标变化幅度最大的问题。比如产生瓶颈后，用户 CPU 使用率升高了 10%，而系统 CPU 使用率却升高了 50%，这个时候就应该首先优化系统 CPU 的使用。</li></ol><h4 id="12-4-有多种优化方法时，要如何选择"><a href="#12-4-有多种优化方法时，要如何选择" class="headerlink" title="12.4 有多种优化方法时，要如何选择?"></a>12.4 有多种优化方法时，要如何选择?</h4><p>一般情况下，我们当然想选能最大提升性能的方法，这其实也是性能优化的目标。</p><p>但要注意，现实情况要考虑的因素却没那么简单。最直观来说，性能优化并非没有成本。性能优化通常会带来复杂度的提升，降低程序的可维护性，还可能在优化一个指标时，引发其他指标的异常。也就是说，很可能你优化了一个指标，另一个指标的性能却变差了。</p><p>一个很典型的例子是我将在网络部分讲到的 DPDK（Data Plane Development Kit）。DPDK 是一种优化网络处理速度的方法，它通过绕开内核网络协议栈的方法，提升网络的处理能力。</p><p>不过它有一个很典型的要求，就是要独占一个 CPU 以及一定数量的内存大页，并且总是以 100% 的 CPU 使用率运行。所以，如果你的 CPU 核数很少，就有点得不偿失了。</p><p>所以，在考虑选哪个性能优化方法时，你要综合多方面的因素。切记，不要想着“一步登天”，试图一次性解决所有问题；也不要只会“拿来主义”，把其他应用的优化方法原封不动拿来用，却不经过任何思考和分析。</p><h4 id="12-5-CPU-优化"><a href="#12-5-CPU-优化" class="headerlink" title="12.5 CPU 优化"></a>12.5 CPU 优化</h4><p>清楚了性能优化最基本的三个问题后，我们接下来从应用程序和系统的角度，分别来看看如何才能降低 CPU 使用率，提高 CPU 的并行处理能力。</p><ol><li><p>应用程序优化</p><p> 首先，从应用程序的角度来说，降低 CPU 使用率的最好方法当然是，排除所有不必要的工作，只保留最核心的逻辑。比如减少循环的层次、减少递归、减少动态内存分配等等。</p><p> 除此之外，应用程序的性能优化也包括很多种方法，我在这里列出了最常见的几种，你可以记下来。</p><ul><li><strong>编译器优化</strong>：很多编译器都会提供优化选项，适当开启它们，在编译阶段你就可以获得编译器的帮助，来提升性能。比如， gcc 就提供了优化选项 -O2，开启后会自动对应用程序的代码进行优化。</li><li><strong>算法优化</strong>：使用复杂度更低的算法，可以显著加快处理速度。比如，在数据比较大的情况下，可以用 O(nlogn) 的排序算法（如快排、归并排序等），代替 O(n^2) 的排序算法（如冒泡、插入排序等）。</li><li><strong>异步处理</strong>：使用异步处理，可以避免程序因为等待某个资源而一直阻塞，从而提升程序的并发处理能力。比如，把轮询替换为事件通知，就可以避免轮询耗费 CPU 的问题。</li><li><strong>多线程代替多进程</strong>：前面讲过，相对于进程的上下文切换，线程的上下文切换并不切换进程地址空间，因此可以降低上下文切换的成本。</li><li><strong>善用缓存</strong>：经常访问的数据或者计算过程中的步骤，可以放到内存中缓存起来，这样在下次用时就能直接从内存中获取，加快程序的处理速度。</li></ul></li><li><p>系统优化</p><p> 从系统的角度来说，优化 CPU 的运行，一方面要充分利用 CPU 缓存的本地性，加速缓存访问；另一方面，就是要控制进程的 CPU 使用情况，减少进程间的相互影响。</p><p> 具体来说，系统层面的 CPU 优化方法也有不少，这里我同样列举了最常见的一些方法，方便你记忆和使用。</p><ul><li><p><strong>CPU 绑定</strong>：把进程绑定到一个或者多个 CPU 上，可以提高 CPU 缓存的命中率，减少跨 CPU 调度带来的上下文切换问题。</p></li><li><p><strong>CPU 独占</strong>：跟 CPU 绑定类似，进一步将 CPU 分组，并通过 CPU 亲和性机制为其分配进程。这样，这些 CPU 就由指定的进程独占，换句话说，不允许其他进程再来使用这些 CPU。</p></li><li><p><strong>优先级调整</strong>：使用 nice 调整进程的优先级，正值调低优先级，负值调高优先级。优先级的数值含义前面我们提到过，忘了的话及时复习一下。在这里，适当降低非核心应用的优先级，增高核心应用的优先级，可以确保核心应用得到优先处理。</p></li><li><p><strong>为进程设置资源限制</strong>：使用 Linux cgroups 来设置进程的 CPU 使用上限，可以防止由于某个应用自身的问题，而耗尽系统资源。</p></li><li><p><strong>NUMA（Non-Uniform Memory Access）优化</strong>：支持 NUMA 的处理器会被划分为多个 node，每个 node 都有自己的本地内存空间。NUMA 优化，其实就是让 CPU 尽可能只访问本地内存。</p></li><li><p><strong>中断负载均衡</strong>：无论是软中断还是硬中断，它们的中断处理程序都可能会耗费大量的 CPU。开启 irqbalance 服务或者配置 smp_affinity，就可以把中断处理过程自动负载均衡到多个 CPU 上。</p></li></ul></li></ol><h4 id="12-6-千万避免过早优化"><a href="#12-6-千万避免过早优化" class="headerlink" title="12.6 千万避免过早优化"></a>12.6 千万避免过早优化</h4><p>“过早优化是万恶之源”。</p><p>因为，一方面，优化会带来复杂性的提升，降低可维护性；另一方面，需求不是一成不变的。针对当前情况进行的优化，很可能并不适应快速变化的新需求。这样，在新需求出现时，这些复杂的优化，反而可能阻碍新功能的开发。</p><p>所以，性能优化最好是逐步完善，动态进行，不追求一步到位，而要首先保证能满足当前的性能要求。当发现性能不满足要求或者出现性能瓶颈时，再根据性能评估的结果，选择最重要的性能问题进行优化。</p><h3 id="13-答疑（一）：无法模拟出-RES-中断的问题，怎么办？"><a href="#13-答疑（一）：无法模拟出-RES-中断的问题，怎么办？" class="headerlink" title="13 | 答疑（一）：无法模拟出 RES 中断的问题，怎么办？"></a>13 | 答疑（一）：无法模拟出 RES 中断的问题，怎么办？</h3><h4 id="13-1-问题-1：性能工具版本太低，导致指标不全"><a href="#13-1-问题-1：性能工具版本太低，导致指标不全" class="headerlink" title="13.1 问题 1：性能工具版本太低，导致指标不全"></a>13.1 问题 1：性能工具版本太低，导致指标不全</h4><p>工具只是查找分析的手段，指标才是我们重点分析的对象。</p><p>proc 文件系统提供各项指标。</p><h4 id="13-2-问题-2：使用-stress-命令，无法模拟-iowait-高的场景"><a href="#13-2-问题-2：使用-stress-命令，无法模拟-iowait-高的场景" class="headerlink" title="13.2 问题 2：使用 stress 命令，无法模拟 iowait 高的场景"></a>13.2 问题 2：使用 stress 命令，无法模拟 iowait 高的场景</h4><p>使用 stress 无法模拟 iowait 升高，但是却看到了 sys 升高。这是因为案例中 的 stress -i 参数，它表示通过系统调用 sync() 来模拟 I/O 的问题，但这种方法实际上并不可靠。</p><p>因为 sync() 的本意是刷新内存缓冲区的数据到磁盘中，以确保同步。如果缓冲区内本来就没多少数据，那读写到磁盘中的数据也就不多，也就没法产生 I/O 压力。</p><p>这一点，在使用 SSD 磁盘的环境中尤为明显，很可能你的 iowait 总是 0，却单纯因为大量的系统调用，导致了系统 CPU 使用率 sys 升高。</p><p>推荐使用 stress-ng 来代替 stress。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -i 的含义还是调用 sync，而—hdd 则表示读写临时文件</span>$ stress-ng -i <span class="token number">1</span> --hdd <span class="token number">1</span> --timeout <span class="token number">600</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="13-3-问题-3：无法模拟出-RES-中断的问题"><a href="#13-3-问题-3：无法模拟出-RES-中断的问题" class="headerlink" title="13.3 问题 3：无法模拟出 RES 中断的问题"></a>13.3 问题 3：无法模拟出 RES 中断的问题</h4><p>这个问题是说，即使运行了大量的线程，也无法模拟出重调度中断 RES 升高的问题。</p><p>其实我在 CPU 上下文切换的案例中已经提到，重调度中断是调度器用来分散任务到不同 CPU 的机制，也就是可以唤醒空闲状态的 CPU ，来调度新任务运行，而这通常借助处理器间中断（Inter-Processor Interrupts，IPI）来实现。</p><p>所以，这个中断在单核（只有一个逻辑 CPU）的机器上当然就没有意义了，因为压根儿就不会发生重调度的情况。</p><p>在这里顺便提一下，留言中很常见的一个错误。有些同学会拿 pidstat 中的 %wait 跟 top 中的 iowait% （缩写为 wa）对比，其实这是没有意义的，因为它们是完全不相关的两个指标。</p><ul><li>pidstat 中， %wait 表示进程等待 CPU 的时间百分比。</li><li>top 中 ，iowait% 则表示等待 I/O 的 CPU 时间百分比。</li></ul><h4 id="13-4-问题-4：无法模拟出-I-O-性能瓶颈，以及-I-O-压力过大的问题"><a href="#13-4-问题-4：无法模拟出-I-O-性能瓶颈，以及-I-O-压力过大的问题" class="headerlink" title="13.4 问题 4：无法模拟出 I/O 性能瓶颈，以及 I/O 压力过大的问题"></a>13.4 问题 4：无法模拟出 I/O 性能瓶颈，以及 I/O 压力过大的问题</h4><p>这个问题可以看成是上一个问题的延伸，只是把 stress 命令换成了一个在容器中运行的 app 应用。</p><p>事实上，在 I/O 瓶颈案例中，除了上面这个模拟不成功的留言，还有更多留言的内容刚好相反，说的是案例 I/O 压力过大，导致自己的机器出各种问题，甚至连系统都没响应了。</p><p>之所以这样，其实还是因为每个人的机器配置不同，既包括了 CPU 和内存配置的不同，更是因为磁盘的巨大差异。比如，机械磁盘（HDD）、低端固态磁盘（SSD）与高端固态磁盘相比，性能差异可能达到数倍到数十倍。</p><p>其实，我自己所用的案例机器也只是低端的 SSD，比机械磁盘稍微好一些，但跟高端固态磁盘还是比不了的。所以，相同操作下，我的机器上刚好出现 I/O 瓶颈，但换成一台使用机械磁盘的机器，可能磁盘 I/O 就被压死了（表现为使用率长时间 100%），而换上好一些的 SSD 磁盘，可能又无法产生足够的 I/O 压力。</p><p>另外，由于我在案例中只查找了 /dev/xvd 和 /dev/sd 前缀的磁盘，而没有考虑到使用其他前缀磁盘（比如 /dev/nvme）的同学。如果你正好用的是其他前缀，你可能会碰到跟 Vicky 类似的问题，也就是 app 启动后又很快退出，变成 exited 状态。</p><p>所以，在最新的案例中，我为 app 应用增加了三个选项。</p><ul><li>-d 设置要读取的磁盘，默认前缀为 /dev/sd 或者 /dev/xvd 的磁盘。</li><li>-s 设置每次读取的数据量大小，单位为字节，默认为 67108864（也就是 64MB）。</li><li>-c 设置每个子进程读取的次数，默认为 20 次，也就是说，读取 20*64MB 数据后，子进程退出。</li></ul><p>你可以点击 <a href="https://github.com/feiskyer/linux-perf-examples/tree/master/high-iowait-process">Github</a> 查看它的源码，使用方法我写在了这里：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run --privileged --name<span class="token operator">=</span>app -itd feisky/app:iowait /app -d /dev/sdb -s <span class="token number">67108864</span> -c <span class="token number">20</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>案例运行后，你可以执行 docker logs 查看它的日志。正常情况下，你可以看到下面的输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker logs appReading data from disk /dev/sdb with buffer size <span class="token number">67108864</span> and count <span class="token number">20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="13-5-问题-5：性能工具（如-vmstat）输出中，第一行数据跟其他行差别巨大"><a href="#13-5-问题-5：性能工具（如-vmstat）输出中，第一行数据跟其他行差别巨大" class="headerlink" title="13.5 问题 5：性能工具（如 vmstat）输出中，第一行数据跟其他行差别巨大"></a>13.5 问题 5：性能工具（如 vmstat）输出中，第一行数据跟其他行差别巨大</h4><p>这个问题主要是说，在执行 vmstat 时，第一行数据跟其他行相比较，数值相差特别大。我相信不少同学都注意到了这个现象，这里我简单解释一下。</p><p>首先还是要记住，我总强调的那句话，<strong>在碰到直观上解释不了的现象时，要第一时间去查命令手册</strong>。</p><p>比如，运行 man vmstat 命令，你可以在手册中发现下面这句话：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">The first report produced gives averages since the last reboot.  Additional reports give information on a sampling period of length delay.  The process and memory reports are instantaneous in either case.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也就是说，第一行数据是系统启动以来的平均值，其他行才是你在运行 vmstat 命令时，设置的间隔时间的平均值。另外，进程和内存的报告内容都是即时数值。</p><h3 id="14-答疑（二）：如何用perf工具分析Java程序？"><a href="#14-答疑（二）：如何用perf工具分析Java程序？" class="headerlink" title="14 | 答疑（二）：如何用perf工具分析Java程序？"></a>14 | 答疑（二）：如何用perf工具分析Java程序？</h3><h4 id="14-1-问题-1：-使用-perf-工具时，看到的是-16-进制地址而不是函数名"><a href="#14-1-问题-1：-使用-perf-工具时，看到的是-16-进制地址而不是函数名" class="headerlink" title="14.1 问题 1： 使用 perf 工具时，看到的是 16 进制地址而不是函数名"></a>14.1 问题 1： 使用 perf 工具时，看到的是 16 进制地址而不是函数名</h4><p>这也是留言比较多的一个问题，在 CentOS 系统中，使用 perf 工具看不到函数名，只能看到一些 16 进制格式的函数地址。</p><p>其实，只要你观察一下 perf 界面最下面的那一行，就会发现一个警告信息：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">Failed to open /opt/bitnami/php/lib/php/extensions/opcache.so, continuing without symbols<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这说明，perf 找不到待分析进程依赖的库。当然，实际上这个案例中有很多依赖库都找不到，只不过，perf 工具本身只在最后一行显示警告信息，所以你只能看到这一条警告。</p><p>这个问题，其实也是在分析 Docker 容器应用时，我们经常碰到的一个问题，因为容器应用依赖的库都在镜像里面。</p><p>针对这种情况，我总结了下面四个解决方法。</p><ol><li><p>第一个方法，在容器外面构建相同路径的依赖库。这种方法从原理上可行，但是我并不推荐，一方面是因为找出这些依赖库比较麻烦，更重要的是，构建这些路径，会污染容器主机的环境。</p></li><li><p>第二个方法，在容器内部运行 perf。不过，这需要容器运行在特权模式下，但实际的应用程序往往只以普通容器的方式运行。所以，容器内部一般没有权限执行 perf 分析。</p><p> 比方说，如果你在普通容器内部运行 perf record ，你将会看到下面这个错误提示：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ perf_4.9 record -a -gperf_event_open<span class="token punctuation">(</span><span class="token punctuation">..</span>., PERF_FLAG_FD_CLOEXEC<span class="token punctuation">)</span> failed with unexpected error <span class="token number">1</span> <span class="token punctuation">(</span>Operation not permitted<span class="token punctuation">)</span>perf_event_open<span class="token punctuation">(</span><span class="token punctuation">..</span>., <span class="token number">0</span><span class="token punctuation">)</span> failed unexpectedly with error <span class="token number">1</span> <span class="token punctuation">(</span>Operation not permitted<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 当然，其实你还可以通过配置 /proc/sys/kernel/perf_event_paranoid （比如改成 -1），来允许非特权用户执行 perf 事件分析。</p><p> 不过还是那句话，为了安全起见，这种方法我也不推荐。</p></li><li><p>第三个方法，指定符号路径为容器文件系统的路径。比如对于第 05 讲的应用，你可以执行下面这个命令：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">mkdir</span> /tmp/foo$ <span class="token assign-left variable">PID</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>docker inspect --format <span class="token punctuation">{</span><span class="token punctuation">{</span>.State.Pid<span class="token punctuation">}</span><span class="token punctuation">}</span> phpfpm<span class="token variable">)</span></span>$ bindfs /proc/<span class="token variable">$PID</span>/root /tmp/foo$ perf report --symfs /tmp/foo<span class="token comment"># 使用完成后不要忘记解除绑定</span>$ <span class="token function">umount</span> /tmp/foo/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 不过这里要注意，bindfs 这个工具需要你额外安装。bindfs 的基本功能是实现目录绑定（类似于 mount —bind），这里需要你安装的是 1.13.10 版本（这也是它的最新发布版）。</p><p> 如果你安装的是旧版本，你可以到 <a href="https://github.com/mpartel/bindfs">GitHub</a> 上面下载源码，然后编译安装。</p></li><li><p>第四个方法，在容器外面把分析纪录保存下来，再去容器里查看结果。这样，库和符号的路径也就都对了。</p><p> 比如，你可以这么做。先运行 perf record -g -p &lt; pid&gt;，执行一会儿（比如 15 秒）后，按 Ctrl+C 停止。</p><p> 然后，把生成的 perf.data 文件，拷贝到容器里面来分析：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker <span class="token function">cp</span> perf.data phpfpm:/tmp$ docker <span class="token builtin class-name">exec</span> -i -t phpfpm <span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 接下来，在容器的 bash 中继续运行下面的命令，安装 perf 并使用 perf report 查看报告：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> /tmp/$ <span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token function">install</span> -y linux-tools linux-perf procps$ perf_4.9 report<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 不过，这里也有两点需要你注意。</p><ol><li>首先是 perf 工具的版本问题。在最后一步中，我们运行的工具是容器内部安装的版本 perf_4.9，而不是普通的 perf 命令。这是因为， perf 命令实际上是一个软连接，会跟内核的版本进行匹配，但镜像里安装的 perf 版本跟虚拟机的内核版本有可能并不一致。</li><li>另外，php-fpm 镜像是基于 Debian 系统的，所以安装 perf 工具的命令，跟 Ubuntu 也并不完全一样。</li></ol></li></ol><p>事实上，抛开我们的案例来说，即使是在非容器化的应用中，你也可能会碰到这个问题。假如你的应用程序在编译时，使用 strip 删除了 ELF 二进制文件的符号表，那么你同样也只能看到函数的地址。</p><h4 id="14-2-问题-2：如何用-perf-工具分析-Java-程序"><a href="#14-2-问题-2：如何用-perf-工具分析-Java-程序" class="headerlink" title="14.2 问题 2：如何用 perf 工具分析 Java 程序"></a>14.2 问题 2：如何用 perf 工具分析 Java 程序</h4><p>这两个问题，其实是上一个 perf 问题的延伸。 像是 Java 这种通过 JVM 来运行的应用程序，运行堆栈用的都是 JVM 内置的函数和堆栈管理。所以，从系统层面你只能看到 JVM 的函数堆栈，而不能直接得到 Java 应用程序的堆栈。</p><p>perf_events 实际上已经支持了 JIT，但还需要一个 /tmp/perf-PID.map 文件，来进行符号翻译。当然，开源项目 <a href="https://github.com/jvm-profiling-tools/perf-map-agent">perf-map-agent</a> 可以帮你生成这个符号表。</p><p>此外，为了生成全部调用栈，你还需要开启 JDK 的选项 -XX:+PreserveFramePointer。因为这里涉及到大量的 Java 知识，我就不再详细展开了。如果你的应用刚好基于 Java ，那么你可以参考 NETFLIX 的技术博客 <a href="https://medium.com/netflix-techblog/java-in-flames-e763b3d32166">Java in Flames</a>，来查看详细的使用步骤。</p><p>说到这里，我也想强调一个问题，那就是学习性能优化时，不要一开始就把自己限定在具体的某个编程语言或者性能工具中，纠结于语言或工具的细节出不来。</p><p>掌握整体的分析思路，才是我们首先要做的。因为，性能优化的原理和思路，在任何编程语言中都是相通的。</p><h4 id="14-3-问题-3：为什么-perf-的报告中，很多符号都不显示调用栈"><a href="#14-3-问题-3：为什么-perf-的报告中，很多符号都不显示调用栈" class="headerlink" title="14.3 问题 3：为什么 perf 的报告中，很多符号都不显示调用栈"></a>14.3 问题 3：为什么 perf 的报告中，很多符号都不显示调用栈</h4><p>perf report 是一个可视化展示 perf.data 的工具。在第 08 讲的案例中，我直接给出了最终结果，并没有详细介绍它的参数。估计很多同学的机器在运行时，都碰到了跟路过同学一样的问题，看到的是下面这个界面。</p><p><img src="/images/《Linux性能优化实战》学习笔记/perf报告中很多符号都不显示调用栈.png" alt="perf报告中很多符号都不显示调用栈"></p><p>这个界面可以清楚看到，perf report 的输出中，只有 swapper 显示了调用栈，其他所有符号都不能查看堆栈情况，包括我们案例中的 app 应用。</p><p>这种情况我们以前也遇到过，当你发现性能工具的输出无法理解时，应该怎么办呢？当然还是查工具的手册。比如，你可以执行 man perf-report 命令，找到 -g 参数的说明：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">-g, --call-graph=&lt;print_type,threshold[,print_limit],order,sort_key[,branch],value&gt;           Display call chains using type, min percent threshold, print limit, call order, sort key, optional branch and value. Note that           ordering is not fixed so any parameter can be given in an arbitrary order. One exception is the print_limit which should be           preceded by threshold.               print_type can be either:               - flat: single column, linear exposure of call chains.               - graph: use a graph tree, displaying absolute overhead rates. (default)               - fractal: like graph, but displays relative rates. Each branch of                        the tree is considered as a new profiled object.               - folded: call chains are displayed in a line, separated by semicolons               - none: disable call chain display.               threshold is a percentage value which specifies a minimum percent to be               included in the output call graph.  Default is 0.5 (%).               print_limit is only applied when stdio interface is used.  It's to limit               number of call graph entries in a single hist entry.  Note that it needs               to be given after threshold (but not necessarily consecutive).               Default is 0 (unlimited).               order can be either:               - callee: callee based call graph.               - caller: inverted caller based call graph.               Default is 'caller' when --children is used, otherwise 'callee'.               sort_key can be:               - function: compare on functions (default)               - address: compare on individual code addresses               - srcline: compare on source filename and line number               branch can be:               - branch: include last branch information in callgraph when available.                         Usually more convenient to use --branch-history for this.               value can be:               - percent: diplay overhead percent (default)               - period: display event period               - count: display event count<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过这个说明可以看到，-g 选项等同于 —call-graph，它的参数是后面那些被逗号隔开的选项，意思分别是输出类型、最小阈值、输出限制、排序方法、排序关键词、分支以及值的类型。</p><p>我们可以看到，这里默认的参数是 graph,0.5,caller,function,percent，具体含义文档中都有详细讲解，这里我就不再重复了。</p><p>现在再回过头来看我们的问题，堆栈显示不全，相关的参数当然就是最小阈值 threshold。通过手册中对 threshold 的说明，我们知道，当一个事件发生比例高于这个阈值时，它的调用栈才会显示出来。</p><p>threshold 的默认值为 0.5%，也就是说，事件比例超过 0.5% 时，调用栈才能被显示。再观察我们案例应用 app 的事件比例，只有 0.34%，低于 0.5%，所以看不到 app 的调用栈就很正常了。</p><p>这种情况下，你只需要给 perf report 设置一个小于 0.34% 的阈值，就可以显示我们想看到的调用图了。比如执行下面的命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ perf report -g graph,0.3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="14-4-问题-4：怎么理解-perf-report-报告"><a href="#14-4-问题-4：怎么理解-perf-report-报告" class="headerlink" title="14.4 问题 4：怎么理解 perf report 报告"></a>14.4 问题 4：怎么理解 perf report 报告</h4><p>看到这里，我估计你也曾嘀咕过，为啥不一上来就用 perf 工具解决，还要执行那么多其他工具呢？ 这个问题其实就给出了很好的解释。</p><p>在问题 4 的 perf report 界面中，你也一定注意到了， swapper 高达 99% 的比例。直觉来说，我们应该直接观察它才对，为什么没那么做呢？</p><p>其实，当你清楚了 swapper 的原理后，就很容易理解我们为什么可以忽略它了。</p><p>看到 swapper，你可能首先想到的是 SWAP 分区。实际上， swapper 跟 SWAP 没有任何关系，它只在系统初始化时创建 init 进程，之后，它就成了一个最低优先级的空闲任务。也就是说，当 CPU 上没有其他任务运行时，就会执行 swapper 。所以，你可以称它为“空闲任务”。</p><p>回到我们的问题，在 perf report 的界面中，展开它的调用栈，你会看到， swapper 时钟事件都耗费在了 do_idle 上，也就是在执行空闲任务。</p><p><img src="/images/《Linux性能优化实战》学习笔记/怎么理解perfreport报告.png" alt="怎么理解perfreport报告"></p><p>所以，分析案例时，我们直接忽略了前面这个 99% 的符号，转而分析后面只有 0.3% 的 app。其实从这里你也能理解，为什么我们一开始不先用 perf 分析。</p><p>因为在多任务系统中，次数多的事件，不一定就是性能瓶颈。所以，只观察到一个大数值，并不能说明什么问题。具体有没有瓶颈，还需要你观测多个方面的多个指标，来交叉验证。这也是我在套路篇中不断强调的一点。</p><p>另外，关于 Children 和 Self 的含义，手册里其实有详细说明，还很友好地举了一个例子，来说明它们的百分比的计算方法。简单来说，</p><ul><li>Self 是最后一列的符号（可以理解为函数）本身所占比例；</li><li>Children 是这个符号调用的其他符号（可以理解为子函数，包括直接和间接调用）占用的比例之和。</li></ul><p>所以，使用性能工具时，确实应该考虑工具本身对系统性能的影响。而这种情况，就需要你了解这些工具的原理。比如，</p><ul><li>perf 这种动态追踪工具，会给系统带来一定的性能损失。</li><li>vmstat、pidstat 这些直接读取 proc 文件系统来获取指标的工具，不会带来性能损失。</li></ul><h4 id="14-5-问题-5：性能优化书籍和参考资料推荐"><a href="#14-5-问题-5：性能优化书籍和参考资料推荐" class="headerlink" title="14.5 问题 5：性能优化书籍和参考资料推荐"></a>14.5 问题 5：性能优化书籍和参考资料推荐</h4><p>Brendan Gregg</p><p>《Systems Performance: Enterprise and the Cloud》</p><blockquote><p>中文版 《性能之巅：洞悉系统、企业与云计算》</p></blockquote><p><a href="http://www.brendangregg.com/linuxperf.html">Linux Performance</a></p><h2 id="03-内存性能篇"><a href="#03-内存性能篇" class="headerlink" title="03-内存性能篇"></a><strong>03-内存性能篇</strong></h2><h3 id="15-基础篇：Linux内存是怎么工作的？"><a href="#15-基础篇：Linux内存是怎么工作的？" class="headerlink" title="15 | 基础篇：Linux内存是怎么工作的？"></a>15 | 基础篇：Linux内存是怎么工作的？</h3><h4 id="15-1-内存映射"><a href="#15-1-内存映射" class="headerlink" title="15.1 内存映射"></a>15.1 内存映射</h4><p>通常所说的内存容量，其实指的是物理内存。物理内存也称为主存，大多数计算机用的主存都是动态随机访问内存（DRAM）。只有内核才可以直接访问物理内存。那么，进程要访问内存时，该怎么办呢？</p><p>Linux 内核给每个进程都提供了一个独立的虚拟地址空间，并且这个地址空间是连续的。这样，进程就可以很方便地访问内存，更确切地说是访问虚拟内存。</p><p>虚拟地址空间的内部又被分为内核空间和用户空间两部分，不同字长（也就是单个 CPU 指令可以处理数据的最大长度）的处理器，地址空间的范围也不同。比如最常见的 32 位和 64 位系统，我画了两张图来分别表示它们的虚拟地址空间，如下所示：</p><p><img src="/images/《Linux性能优化实战》学习笔记/内存虚拟地址空间.png" alt="内存虚拟地址空间"></p><p>通过这里可以看出，32 位系统的内核空间占用 1G，位于最高处，剩下的 3G 是用户空间。而 64 位系统的内核空间和用户空间都是 128T，分别占据整个内存空间的最高和最低处，剩下的中间部分是未定义的。</p><p>还记得进程的用户态和内核态吗？进程在用户态时，只能访问用户空间内存；只有进入内核态后，才可以访问内核空间内存。虽然每个进程的地址空间都包含了内核空间，但这些内核空间，其实关联的都是相同的物理内存。这样，进程切换到内核态后，就可以很方便地访问内核空间内存。</p><p>既然每个进程都有一个这么大的地址空间，那么所有进程的虚拟内存加起来，自然要比实际的物理内存大得多。所以，并不是所有的虚拟内存都会分配物理内存，只有那些实际使用的虚拟内存才分配物理内存，并且分配后的物理内存，是通过<strong>内存映射</strong>来管理的。</p><p>内存映射，其实就是将虚拟内存地址映射到物理内存地址。为了完成内存映射，内核为每个进程都维护了一张页表，记录虚拟地址与物理地址的映射关系，如下图所示：</p><p><img src="/images/《Linux性能优化实战》学习笔记/内存映射.png" alt="内存映射"></p><p>页表实际上存储在 CPU 的内存管理单元 MMU 中，这样，正常情况下，处理器就可以直接通过硬件，找出要访问的内存。</p><p>而当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。</p><p> TLB（Translation Lookaside Buffer，转译后备缓冲器）其实就是 MMU 中页表的高速缓存。由于进程的虚拟地址空间是独立的，而 TLB 的访问速度又比 MMU 快得多，所以，通过减少进程的上下文切换，减少 TLB 的刷新次数，就可以提高 TLB 缓存的使用率，进而提高 CPU 的内存访问性能。</p><p> 不过要注意，MMU 并不以字节为单位来管理内存，而是规定了一个内存映射的最小单位，也就是页，通常是 4 KB 大小。这样，每一次内存映射，都需要关联 4 KB 或者 4KB 整数倍的内存空间。</p><p>页的大小只有 4 KB ，导致的另一个问题就是，整个页表会变得非常大。比方说，仅 32 位系统就需要 100 多万个页表项（4GB/4KB），才可以实现整个地址空间的映射。为了解决页表项过多的问题，Linux 提供了两种机制，也就是多级页表和大页（HugePage）。</p><p>多级页表就是把内存分成区块来管理，将原来的映射关系改成区块索引和区块内的偏移。由于虚拟内存空间通常只用了很少一部分，那么，多级页表就只保存这些使用中的区块，这样就可以大大地减少页表的项数。</p><p>Linux 用的正是四级页表来管理内存页，如下图所示，虚拟地址被分为 5 个部分，前 4 个表项用于选择页，而最后一个索引表示页内偏移。</p><p><img src="/images/《Linux性能优化实战》学习笔记/四级页表.png" alt="四级页表"></p><p>再看大页，顾名思义，就是比普通页更大的内存块，常见的大小有 2MB 和 1GB。大页通常用在使用大量内存的进程上，比如 Oracle、DPDK 等。</p><p>通过这些机制，在页表的映射下，进程就可以通过虚拟地址来访问物理内存了。那么具体到一个 Linux 进程中，这些内存又是怎么使用的呢？</p><h4 id="15-2-虚拟内存空间分布"><a href="#15-2-虚拟内存空间分布" class="headerlink" title="15.2 虚拟内存空间分布"></a>15.2 虚拟内存空间分布</h4><p>首先，我们需要进一步了解虚拟内存空间的分布情况。最上方的内核空间不用多讲，下方的用户空间内存，其实又被分成了多个不同的段。以 32 位系统为例，我画了一张图来表示它们的关系。</p><p><img src="/images/《Linux性能优化实战》学习笔记/虚拟内存空间的分布.png" alt="虚拟内存空间的分布"></p><p>通过这张图你可以看到，用户空间内存，从低到高分别是五种不同的内存段。</p><ol><li>只读段，包括代码和常量等。</li><li>数据段，包括全局变量等。</li><li>堆，包括动态分配的内存，从低地址开始向上增长。</li><li>文件映射段，包括动态库、共享内存等，从高地址开始向下增长。</li><li>栈，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。</li></ol><p>在这五个内存段中，堆和文件映射段的内存是动态分配的。比如说，使用 C 标准库的 malloc() 或者 mmap() ，就可以分别在堆和文件映射段动态分配内存。</p><p>其实 64 位系统的内存分布也类似，只不过内存空间要大得多。那么，更重要的问题来了，内存究竟是怎么分配的呢？</p><h4 id="15-3-内存分配与回收"><a href="#15-3-内存分配与回收" class="headerlink" title="15.3 内存分配与回收"></a>15.3 内存分配与回收</h4><p>malloc() 是 C 标准库提供的内存分配函数，对应到系统调用上，有两种实现方式，即 brk() 和 mmap()。</p><ol><li>对小块内存（小于 128K），C 标准库使用 brk() 来分配，也就是通过移动堆顶的位置来分配内存。这些内存释放后并不会立刻归还系统，而是被缓存起来，这样就可以重复使用。</li><li>而大块内存（大于 128K），则直接使用内存映射 mmap() 来分配，也就是在文件映射段找一块空闲内存分配出去。</li></ol><p>这两种方式，自然各有优缺点。</p><ol><li>brk() 方式的缓存，可以减少缺页异常的发生，提高内存访问效率。不过，由于这些内存没有归还系统，在内存工作繁忙时，频繁的内存分配和释放会造成内存碎片。</li><li>而 mmap() 方式分配的内存，会在释放时直接归还系统，所以每次 mmap 都会发生缺页异常。在内存工作繁忙时，频繁的内存分配会导致大量的缺页异常，使内核的管理负担增大。这也是 malloc 只对大块内存使用 mmap 的原因。</li></ol><p>了解这两种调用方式后，我们还需要清楚一点，那就是，当这两种调用发生后，其实并没有真正分配内存。这些内存，都只在首次访问时才分配，也就是通过缺页异常进入内核中，再由内核来分配内存。</p><p>整体来说，Linux 使用伙伴系统来管理内存分配。前面我们提到过，这些内存在 MMU 中以页为单位进行管理，伙伴系统也一样，以页为单位来管理内存，并且会通过相邻页的合并，减少内存碎片化（比如 brk 方式造成的内存碎片）。</p><p>你可能会想到一个问题，如果遇到比页更小的对象，比如不到 1K 的时候，该怎么分配内存呢？</p><p>实际系统运行中，确实有大量比页还小的对象，如果为它们也分配单独的页，那就太浪费内存了。</p><p>所以，在用户空间，malloc 通过 brk() 分配的内存，在释放时并不立即归还系统，而是缓存起来重复利用。在内核空间，Linux 则通过 slab 分配器来管理小内存。你可以把 slab 看成构建在伙伴系统上的一个缓存，主要作用就是分配并释放内核中的小对象。</p><p>当然，系统也不会任由某个进程用完所有内存。在发现内存紧张时，系统就会通过一系列机制来回收内存，比如下面这三种方式：</p><ul><li>回收缓存，比如使用 LRU（Least Recently Used）算法，回收最近使用最少的内存页面；</li><li>回收不常访问的内存，把不常用的内存通过交换分区直接写到磁盘中；</li><li>杀死进程，内存紧张时系统还会通过 OOM（Out of Memory），直接杀掉占用大量内存的进程。</li></ul><p>其中，第二种方式回收不常访问的内存时，会用到交换分区（以下简称 Swap）。Swap 其实就是把一块磁盘空间当成内存来用。它可以把进程暂时不用的数据存储到磁盘中（这个过程称为换出），当进程访问这些内存时，再从磁盘读取这些数据到内存中（这个过程称为换入）。</p><p>所以，你可以发现，Swap 把系统的可用内存变大了。不过要注意，通常只在内存不足时，才会发生 Swap 交换。并且由于磁盘读写的速度远比内存慢，Swap 会导致严重的内存性能问题。</p><p>第三种方式提到的 OOM（Out of Memory），其实是内核的一种保护机制。它监控进程的内存使用情况，并且使用 oom_score 为每个进程的内存使用情况进行评分：</p><ul><li>一个进程消耗的内存越大，oom_score 就越大；</li><li>一个进程运行占用的 CPU 越多，oom_score 就越小。</li></ul><p>这样，进程的 oom_score 越大，代表消耗的内存越多，也就越容易被 OOM 杀死，从而可以更好保护系统。</p><p>当然，为了实际工作的需要，管理员可以通过 /proc 文件系统，手动设置进程的 oom_adj ，从而调整进程的 oom_score。</p><p>oom_adj 的范围是 [-17, 15]，数值越大，表示进程越容易被 OOM 杀死；数值越小，表示进程越不容易被 OOM 杀死，其中 -17 表示禁止 OOM。</p><p>比如用下面的命令，你就可以把 sshd 进程的 oom_adj 调小为 -16，这样， sshd 进程就不容易被 OOM 杀死。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> -16 <span class="token operator">&gt;</span> /proc/<span class="token variable"><span class="token variable">$(</span>pidof sshd<span class="token variable">)</span></span>/oom_adj<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="15-4-如何查看内存使用情况"><a href="#15-4-如何查看内存使用情况" class="headerlink" title="15.4 如何查看内存使用情况"></a>15.4 如何查看内存使用情况</h4><p>下面是一个 free 的输出示例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 注意不同版本的 free 输出可能会有所不同</span>$ <span class="token function">free</span>              total        used        <span class="token function">free</span>      shared  buff/cache   availableMem:        <span class="token number">8169348</span>      <span class="token number">263524</span>     <span class="token number">6875352</span>         <span class="token number">668</span>     <span class="token number">1030472</span>     <span class="token number">7611064</span>Swap:             <span class="token number">0</span>           <span class="token number">0</span>           <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>free 输出的是一个表格，其中的数值都默认以字节为单位。表格总共有两行六列，这两行分别是物理内存 Mem 和交换分区 Swap 的使用情况，而六列中，每列数据的含义分别为：</p><ul><li>第一列，total 是总内存大小；</li><li>第二列，used 是已使用内存的大小，包含了共享内存；</li><li>第三列，free 是未使用内存的大小；</li><li>第四列，shared 是共享内存的大小；</li><li>第五列，buff/cache 是缓存和缓冲区的大小；</li><li>最后一列，available 是新进程可用内存的大小。</li></ul><p>available 不仅包含未使用内存，还包括了可回收的缓存，所以一般会比未使用内存更大。不过，并不是所有缓存都可以回收，因为有些缓存可能正在使用中。</p><p>如果你想查看进程的内存使用情况，可以用 top 或者 ps 等工具。比如，下面是 top 的输出示例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 按下 M 切换到内存排序</span>$ <span class="token function">top</span><span class="token punctuation">..</span>.KiB Mem <span class="token builtin class-name">:</span>  <span class="token number">8169348</span> total,  <span class="token number">6871440</span> free,   <span class="token number">267096</span> used,  <span class="token number">1030812</span> buff/cacheKiB Swap:        <span class="token number">0</span> total,        <span class="token number">0</span> free,        <span class="token number">0</span> used.  <span class="token number">7607492</span> avail Mem  PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND  <span class="token number">430</span> root      <span class="token number">19</span>  -1  <span class="token number">122360</span>  <span class="token number">35588</span>  <span class="token number">23748</span> S   <span class="token number">0.0</span>  <span class="token number">0.4</span>   <span class="token number">0</span>:32.17 systemd-journal <span class="token number">1075</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">771860</span>  <span class="token number">22744</span>  <span class="token number">11368</span> S   <span class="token number">0.0</span>  <span class="token number">0.3</span>   <span class="token number">0</span>:38.89 snapd <span class="token number">1048</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">170904</span>  <span class="token number">17292</span>   <span class="token number">9488</span> S   <span class="token number">0.0</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:00.24 networkd-dispat    <span class="token number">1</span> root      <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">78020</span>   <span class="token number">9156</span>   <span class="token number">6644</span> S   <span class="token number">0.0</span>  <span class="token number">0.1</span>   <span class="token number">0</span>:22.92 systemd<span class="token number">12376</span> azure     <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">76632</span>   <span class="token number">7456</span>   <span class="token number">6420</span> S   <span class="token number">0.0</span>  <span class="token number">0.1</span>   <span class="token number">0</span>:00.01 systemd<span class="token number">12374</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">107984</span>   <span class="token number">7312</span>   <span class="token number">6304</span> S   <span class="token number">0.0</span>  <span class="token number">0.1</span>   <span class="token number">0</span>:00.00 sshd<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>top 输出界面的顶端，也显示了系统整体的内存使用情况，这些数据跟 free 类似，我就不再重复解释。我们接着看下面的内容，跟内存相关的几列数据，比如 VIRT、RES、SHR 以及 %MEM 等。</p><p>这些数据，包含了进程最重要的几个内存使用情况，我们挨个来看。</p><ul><li>VIRT 是进程虚拟内存的大小，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内。</li><li>RES 是常驻内存的大小，也就是进程实际使用的物理内存大小，但不包括 Swap 和共享内存。</li><li>SHR 是共享内存的大小，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等。</li><li>%MEM 是进程使用物理内存占系统总内存的百分比。</li></ul><p>除了要认识这些基本信息，在查看 top 输出时，你还要注意两点。</p><ul><li>第一，虚拟内存通常并不会全部分配物理内存。从上面的输出，你可以发现每个进程的虚拟内存都比常驻内存大得多。</li><li>第二，共享内存 SHR 并不一定是共享的，比方说，程序的代码段、非共享的动态链接库，也都算在 SHR 里。当然，SHR 也包括了进程间真正共享的内存。所以在计算多个进程的内存使用时，不要把所有进程的 SHR 直接相加得出结果。</li></ul><h3 id="16-基础篇：怎么理解内存中的Buffer和Cache？"><a href="#16-基础篇：怎么理解内存中的Buffer和Cache？" class="headerlink" title="16 | 基础篇：怎么理解内存中的Buffer和Cache？"></a>16 | 基础篇：怎么理解内存中的Buffer和Cache？</h3><h4 id="16-1-free-数据的来源"><a href="#16-1-free-数据的来源" class="headerlink" title="16.1 free 数据的来源"></a>16.1 free 数据的来源</h4><p>用 man 命令查询 free 的文档，就可以找到 Buffer 和 Cache 指标的详细说明。比如，我们执行 man free ，就可以看到下面这个界面。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">buffers       Memory used by kernel buffers (Buffers in /proc/meminfo)cache  Memory used by the page cache and slabs (Cached and SReclaimable in /proc/meminfo)buff/cache       Sum of buffers and cache<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从 free 的手册中，你可以看到 buffer 和 cache 的说明。</p><ul><li>Buffers 是内核缓冲区用到的内存，对应的是 /proc/meminfo 中的 Buffers 值。</li><li>Cache 是内核页缓存和 Slab 用到的内存，对应的是 /proc/meminfo 中的 Cached 与 SReclaimable 之和。</li></ul><p>这里的说明告诉我们，这些数值都来自 /proc/meminfo，但更具体的 Buffers、Cached 和 SReclaimable 的含义，还是没有说清楚。</p><p>要弄明白它们到底是什么，我估计你第一反应就是去百度或者 Google 一下。虽然大部分情况下，网络搜索能给出一个答案。但是，且不说筛选信息花费的时间精力，对你来说，这个答案的准确性也是很难保证的。</p><p>要注意，网上的结论可能是对的，但是很可能跟你的环境并不匹配。最简单来说，同一个指标的具体含义，就可能因为内核版本、性能工具版本的不同而有挺大差别。这也是为什么，我总在专栏中强调通用思路和方法，而不是让你死记结论。对于案例实践来说，机器环境就是我们的最大限制。</p><p>那么，有没有更简单、更准确的方法，来查询它们的含义呢？</p><h4 id="16-2-proc-文件系统"><a href="#16-2-proc-文件系统" class="headerlink" title="16.2 proc 文件系统"></a>16.2 proc 文件系统</h4><p>proc 文件系统同时也是很多性能工具的最终数据来源。比如我们刚才看到的 free ，就是通过读取 /proc/meminfo ，得到内存的使用情况。</p><p>执行 man proc ，你就可以得到 proc 文件系统的详细文档。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">Buffers %lu    Relatively temporary storage for raw disk blocks that shouldn't get tremendously large (20MB or so).Cached %lu   In-memory cache for files read from the disk (the page cache).  Doesn't include SwapCached....SReclaimable %lu (since Linux 2.6.19)    Part of Slab, that might be reclaimed, such as caches.SUnreclaim %lu (since Linux 2.6.19)    Part of Slab, that cannot be reclaimed on memory pressure.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过这个文档，我们可以看到：</p><ul><li>Buffers 是对原始磁盘块的临时存储，也就是用来缓存磁盘的数据，通常不会特别大（20MB 左右）。这样，内核就可以把分散的写集中起来，统一优化磁盘的写入，比如可以把多次小的写合并成单次大的写等等。</li><li>Cached 是从磁盘读取文件的页缓存，也就是用来缓存从文件读取的数据。这样，下次访问这些文件数据时，就可以直接从内存中快速获取，而不需要再次访问缓慢的磁盘。</li><li>SReclaimable 是 Slab 的一部分。Slab 包括两部分，其中的可回收部分，用 SReclaimable 记录；而不可回收部分，用 SUnreclaim 记录。</li></ul><p>不过，知道这个定义就真的理解了吗？这里我给你提了两个问题，你先想想能不能回答出来。</p><ul><li>第一个问题，Buffer 的文档没有提到这是磁盘读数据还是写数据的缓存，而在很多网络搜索的结果中都会提到 Buffer 只是对将要写入磁盘数据的缓存。那反过来说，它会不会也缓存从磁盘中读取的数据呢？</li><li>第二个问题，文档中提到，Cache 是对从文件读取数据的缓存，那么它是不是也会缓存写文件的数据呢？</li></ul><p>为了解答这两个问题，接下来，我将用几个案例来展示， Buffer 和 Cache 在不同场景下的使用情况。</p><h4 id="16-3-案例"><a href="#16-3-案例" class="headerlink" title="16.3 案例"></a>16.3 案例</h4><blockquote><p>机器配置： 2 CPU, 8 GB 内存。</p><p>安装软件：<code>apt install sysstat</code>。</p></blockquote><p>为了减少缓存的影响，记得在第一个终端中，运行下面的命令来清理系统缓存：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 清理文件页、目录项、Inodes 等各种缓存</span>$ <span class="token builtin class-name">echo</span> <span class="token number">3</span> <span class="token operator">&gt;</span> /proc/sys/vm/drop_caches<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li><p>场景 1：磁盘和文件写案例</p><p> 在第一个终端，运行下面这个 vmstat 命令：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 每隔 1 秒输出 1 组数据</span>$ <span class="token function">vmstat</span> <span class="token number">1</span>procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----r  b   swpd   <span class="token function">free</span>   buff  cache   si   so    bi    bo   <span class="token keyword">in</span>   cs us sy  <span class="token function">id</span> wa st<span class="token number">0</span>  <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">7743608</span>  <span class="token number">1112</span>  <span class="token number">92168</span>    <span class="token number">0</span>    <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">0</span>   <span class="token number">52</span>  <span class="token number">152</span>  <span class="token number">0</span>  <span class="token number">1</span> <span class="token number">100</span>  <span class="token number">0</span>  <span class="token number">0</span><span class="token number">0</span>  <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">7743608</span>  <span class="token number">1112</span>  <span class="token number">92168</span>    <span class="token number">0</span>    <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">0</span>   <span class="token number">36</span>   <span class="token number">92</span>  <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">100</span>  <span class="token number">0</span>  <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 输出界面里， 内存部分的 buff 和 cache ，以及 io 部分的 bi 和 bo 就是我们要关注的重点。</p><ul><li>buff 和 cache 就是我们前面看到的 Buffers 和 Cache，单位是 KB。</li><li><p>bi 和 bo 则分别表示块设备读取和写入的大小，单位为块 / 秒。因为 Linux 中块的大小是 1KB，所以这个单位也就等价于 KB/s。</p><blockquote><p><code>man vmstat</code>: <a href="https://linux.die.net/man/8/vmstat">All linux blocks are currently 1024 bytes.</a></p></blockquote><p>正常情况下，空闲系统中，你应该看到的是，这几个值在多次结果中一直保持不变。</p><p>接下来，到第二个终端执行 dd 命令，通过读取随机设备，生成一个 500MB 大小的文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/dev/urandom <span class="token assign-left variable">of</span><span class="token operator">=</span>/tmp/file <span class="token assign-left variable">bs</span><span class="token operator">=</span>1M <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">500</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后再回到第一个终端，观察 Buffer 和 Cache 的变化情况：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st0  0      0 7499460   1344 230484    0    0     0     0   29  145  0  0 100  0  01  0      0 7338088   1752 390512    0    0   488     0   39  558  0 47 53  0  01  0      0 7158872   1752 568800    0    0     0     4   30  376  1 50 49  0  01  0      0 6980308   1752 747860    0    0     0     0   24  360  0 50 50  0  00  0      0 6977448   1752 752072    0    0     0     0   29  138  0  0 100  0  00  0      0 6977440   1760 752080    0    0     0   152   42  212  0  1 99  1  0...0  1      0 6977216   1768 752104    0    0    4 122880   33  234  0  1 51 49  00  1      0 6977440   1768 752108    0    0    0  10240   38  196  0  0 50 50  0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过观察 vmstat 的输出，我们发现，在 dd 命令运行时， Cache 在不停地增长，而 Buffer 基本保持不变。</p></li><li><p>在 Cache 刚开始增长时，块设备 I/O 很少，bi 只出现了一次 488 KB/s，bo 则只有一次 4KB。而过一段时间后，才会出现大量的块设备写，比如 bo 变成了 122880。</p></li><li><p>当 dd 命令结束后，Cache 不再增长，但块设备写还会持续一段时间，并且，多次 I/O 写的结果加起来，才是 dd 要写的 500M 的数据。</p><p>把这个结果，跟我们刚刚了解到的 Cache 的定义做个对比，你可能会有点晕乎。为什么前面文档上说 Cache 是文件读的页缓存，怎么现在写文件也有它的份？</p><p>这个疑问，我们暂且先记下来，接着再来看另一个磁盘写的案例。两个案例结束后，我们再统一进行分析。</p><p>不过，对于接下来的案例，我必须强调一点：</p><p>下面的命令对环境要求很高，需要你的系统配置多块磁盘，并且磁盘分区 /dev/sdb1 还要处于未使用状态。如果你只有一块磁盘，千万不要尝试，否则将会对你的磁盘分区造成损坏。</p><p>如果你的系统符合标准，就可以继续在第二个终端中，运行下面的命令。清理缓存后，向磁盘分区 /dev/sdb1 写入 2GB 的随机数据：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 首先清理缓存</span>$ <span class="token builtin class-name">echo</span> <span class="token number">3</span> <span class="token operator">&gt;</span> /proc/sys/vm/drop_caches<span class="token comment"># 然后运行 dd 命令向磁盘分区 /dev/sdb1 写入 2G 数据</span>$ <span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/dev/urandom <span class="token assign-left variable">of</span><span class="token operator">=</span>/dev/sdb1 <span class="token assign-left variable">bs</span><span class="token operator">=</span>1M <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">2048</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后，再回到终端一，观察内存和 I/O 的变化情况：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st1  0      0 7584780 153592  97436    0    0   684     0   31  423  1 48 50  2  01  0      0 7418580 315384 101668    0    0     0     0   32  144  0 50 50  0  01  0      0 7253664 475844 106208    0    0     0     0   20  137  0 50 50  0  01  0      0 7093352 631800 110520    0    0     0     0   23  223  0 50 50  0  01  1      0 6930056 790520 114980    0    0     0 12804   23  168  0 50 42  9  01  0      0 6757204 949240 119396    0    0     0 183804   24  191  0 53 26 21  01  1      0 6591516 1107960 123840    0    0     0 77316   22  232  0 52 16 33  0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从这里你会看到，虽然同是写数据，写磁盘跟写文件的现象还是不同的。写磁盘时（也就是 bo 大于 0 时），Buffer 和 Cache 都在增长，但显然 Buffer 的增长快得多。</p><p>这说明，写磁盘用到了大量的 Buffer，这跟我们在文档中查到的定义是一样的。</p><p>对比两个案例，我们发现，<strong>写文件时会用到 Cache 缓存数据，而写磁盘则会用到 Buffer 来缓存数据</strong>。所以，回到刚刚的问题，虽然文档上只提到，Cache 是文件读的缓存，但实际上，<strong>Cache 也会缓存写文件时的数据</strong>。</p></li></ul></li><li><p>场景 2：磁盘和文件读案例</p><p> 回到第二个终端，运行下面的命令。清理缓存后，从文件 /tmp/file 中，读取数据写入空设备：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 首先清理缓存</span>$ <span class="token builtin class-name">echo</span> <span class="token number">3</span> <span class="token operator">&gt;</span> /proc/sys/vm/drop_caches<span class="token comment"># 运行 dd 命令读取文件数据</span>$ <span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/tmp/file <span class="token assign-left variable">of</span><span class="token operator">=</span>/dev/null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 然后，再回到终端一，观察内存和 I/O 的变化情况：</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st0  1      0 7724164   2380 110844    0    0 16576     0   62  360  2  2 76 21  00  1      0 7691544   2380 143472    0    0 32640     0   46  439  1  3 50 46  00  1      0 7658736   2380 176204    0    0 32640     0   54  407  1  4 50 46  00  1      0 7626052   2380 208908    0    0 32640    40   44  422  2  2 50 46  0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 观察 vmstat 的输出，你会发现读取文件时（也就是 bi 大于 0 时），Buffer 保持不变，而 Cache 则在不停增长。这跟我们查到的定义“Cache 是对文件读的页缓存”是一致的。</p><p> 那么，磁盘读又是什么情况呢？我们再运行第二个案例来看看。</p><p> 首先，回到第二个终端，运行下面的命令。清理缓存后，从磁盘分区 /dev/sda1 中读取数据，写入空设备：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 首先清理缓存</span>$ <span class="token builtin class-name">echo</span> <span class="token number">3</span> <span class="token operator">&gt;</span> /proc/sys/vm/drop_caches<span class="token comment"># 运行 dd 命令读取文件</span>$ <span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/dev/sda1 <span class="token assign-left variable">of</span><span class="token operator">=</span>/dev/null <span class="token assign-left variable">bs</span><span class="token operator">=</span>1M <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">1024</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 然后，再回到终端一，观察内存和 I/O 的变化情况：</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st0  0      0 7225880   2716 608184    0    0     0     0   48  159  0  0 100  0  00  1      0 7199420  28644 608228    0    0 25928     0   60  252  0  1 65 35  00  1      0 7167092  60900 608312    0    0 32256     0   54  269  0  1 50 49  00  1      0 7134416  93572 608376    0    0 32672     0   53  253  0  0 51 49  00  1      0 7101484 126320 608480    0    0 32748     0   80  414  0  1 50 49  0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 观察 vmstat 的输出，你会发现读磁盘时（也就是 bi 大于 0 时），Buffer 和 Cache 都在增长，但显然 Buffer 的增长快很多。这说明读磁盘时，数据缓存到了 Buffer 中。</p><p> 当然，我想，经过上一个场景中两个案例的分析，你自己也可以对比得出这个结论：<strong>读文件时数据会缓存到 Cache 中，而读磁盘时数据会缓存到 Buffer 中</strong>。</p></li></ol><p>到这里你应该发现了，虽然文档提供了对 Buffer 和 Cache 的说明，但是仍不能覆盖到所有的细节。比如说，今天我们了解到的这两点：</p><ul><li>Buffer 既可以用作“将要写入磁盘数据的缓存”，也可以用作“从磁盘读取数据的缓存”。</li><li>Cache 既可以用作“从文件读取数据的页缓存”，也可以用作“写文件的页缓存”。</li></ul><p>这样，我们就回答了案例开始前的两个问题。</p><p>简单来说，<strong>Buffer 是对磁盘数据的缓存，而 Cache 是文件数据的缓存，它们既会用在读请求中，也会用在写请求中</strong>。</p><h3 id="17-案例篇：如何利用系统缓存优化程序的运行效率？"><a href="#17-案例篇：如何利用系统缓存优化程序的运行效率？" class="headerlink" title="17 | 案例篇：如何利用系统缓存优化程序的运行效率？"></a>17 | 案例篇：如何利用系统缓存优化程序的运行效率？</h3><p>简单复习一下，Buffer 和 Cache 的设计目的，是为了提升系统的 I/O 性能。它们利用内存，充当起慢速磁盘与快速 CPU 之间的桥梁，可以加速 I/O 的访问速度。</p><p>Buffer 和 Cache 分别缓存的是对磁盘和文件系统的读写数据。</p><ul><li>从写的角度来说，不仅可以优化磁盘和文件的写入，对应用程序也有好处，应用程序可以在数据真正落盘前，就返回去做其他工作。</li><li>从读的角度来说，不仅可以提高那些频繁访问数据的读取速度，也降低了频繁 I/O 对磁盘的压力。</li></ul><p>既然 Buffer 和 Cache 对系统性能有很大影响，那我们在软件开发的过程中，能不能利用这一点，来优化 I/O 性能，提升应用程序的运行效率呢？</p><h4 id="17-1-缓存命中率"><a href="#17-1-缓存命中率" class="headerlink" title="17.1 缓存命中率"></a>17.1 缓存命中率</h4><p><strong>缓存命中率</strong>，是指直接通过缓存获取数据的请求次数，占所有数据请求次数的百分比。</p><p><strong>命中率越高，表示使用缓存带来的收益越高，应用程序的性能也就越好</strong>。</p><p>实际上，缓存是现在所有高并发系统必需的核心模块，主要作用就是把经常访问的数据（也就是热点数据），提前读入到内存中。这样，下次访问时就可以直接从内存读取数据，而不需要经过硬盘，从而加快应用程序的响应速度。</p><p>这些独立的缓存模块通常会提供查询接口，方便我们随时查看缓存的命中情况。不过 Linux 系统中并没有直接提供这些接口，所以这里我要介绍一下，cachestat 和 cachetop ，它们正是查看系统缓存命中情况的工具。</p><ul><li>cachestat 提供了整个操作系统缓存的读写命中情况。</li><li>cachetop 提供了每个进程的缓存命中情况。</li></ul><p>这两个工具都是 <a href="https://github.com/iovisor/bcc">bcc</a> 软件包的一部分，它们基于 Linux 内核的 eBPF（extended Berkeley Packet Filters）机制，来跟踪内核中管理的缓存，并输出缓存的使用和命中情况。</p><p>使用 cachestat 和 cachetop 前，我们首先要安装 bcc 软件包。比如，在 Ubuntu 系统中，你可以运行下面的命令来安装：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 4052245BD4284CDD<span class="token builtin class-name">echo</span> <span class="token string">"deb https://repo.iovisor.org/apt/xenial xenial main"</span> <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> /etc/apt/sources.list.d/iovisor.list<span class="token function">sudo</span> <span class="token function">apt-get</span> update<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> -y bcc-tools libbcc-examples linux-headers-<span class="token variable"><span class="token variable">$(</span><span class="token function">uname</span> -r<span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：bcc-tools 需要内核版本为 4.1 或者更新的版本，如果你用的是 CentOS，那就需要手动 <a href="https://github.com/iovisor/bcc/issues/462">升级内核版本后再安装</a>。</p></blockquote><p>操作完这些步骤，bcc 提供的所有工具就都安装到 /usr/share/bcc/tools 这个目录中了。不过这里提醒你，bcc 软件包默认不会把这些工具配置到系统的 PATH 路径中，所以你得自己手动配置：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span>:/usr/share/bcc/tools<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置完，你就可以运行 cachestat 和 cachetop 命令了。比如，下面就是一个 cachestat 的运行界面，它以 1 秒的时间间隔，输出了 3 组缓存统计数据：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cachestat <span class="token number">1</span> <span class="token number">3</span>   TOTAL   MISSES     HITS  DIRTIES   BUFFERS_MB  CACHED_MB       <span class="token number">2</span>        <span class="token number">0</span>        <span class="token number">2</span>        <span class="token number">1</span>           <span class="token number">17</span>        <span class="token number">279</span>       <span class="token number">2</span>        <span class="token number">0</span>        <span class="token number">2</span>        <span class="token number">1</span>           <span class="token number">17</span>        <span class="token number">279</span>       <span class="token number">2</span>        <span class="token number">0</span>        <span class="token number">2</span>        <span class="token number">1</span>           <span class="token number">17</span>        <span class="token number">279</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以看到，cachestat 的输出其实是一个表格。每行代表一组数据，而每一列代表不同的缓存统计指标。这些指标从左到右依次表示：</p><ul><li>TOTAL ，表示总的 I/O 次数；</li><li>MISSES ，表示缓存未命中的次数；</li><li>HITS ，表示缓存命中的次数；</li><li>DIRTIES， 表示新增到缓存中的脏页数；</li><li>BUFFERS_MB 表示 Buffers 的大小，以 MB 为单位；</li><li>CACHED_MB 表示 Cache 的大小，以 MB 为单位。</li></ul><p>接下来我们再来看一个 cachetop 的运行界面：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cachetop<span class="token number">11</span>:58:50 Buffers MB: <span class="token number">258</span> / Cached MB: <span class="token number">347</span> / Sort: HITS / Order: ascendingPID      <span class="token environment constant">UID</span>      CMD              HITS     MISSES   DIRTIES  READ_HIT%  WRITE_HIT%<span class="token number">13029</span>    root     python              <span class="token number">1</span>          <span class="token number">0</span>         <span class="token number">0</span>     <span class="token number">100.0</span>%        <span class="token number">0.0</span>%<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>它的输出跟 top 类似，默认按照缓存的命中次数（HITS）排序，展示了每个进程的缓存命中情况。具体到每一个指标，这里的 HITS、MISSES 和 DIRTIES ，跟 cachestat 里的含义一样，分别代表间隔时间内的缓存命中次数、未命中次数以及新增到缓存中的脏页数。</p><p>而 READ_HIT 和 WRITE_HIT ，分别表示读和写的缓存命中率。</p><h4 id="17-2-指定文件的缓存大小"><a href="#17-2-指定文件的缓存大小" class="headerlink" title="17.2 指定文件的缓存大小"></a>17.2 指定文件的缓存大小</h4><p>除了缓存的命中率外，还有一个指标你可能也会很感兴趣，那就是指定文件在内存中的缓存大小。你可以使用 <a href="https://github.com/tobert/pcstat">pcstat</a> 这个工具，来查看文件在内存中的缓存大小以及缓存比例。</p><p>安装完 Go 语言，再运行下面的命令安装 pcstat：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">export</span> <span class="token assign-left variable">GOPATH</span><span class="token operator">=</span>~/go$ <span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span>~/go/bin:<span class="token environment constant">$PATH</span>$ go get golang.org/x/sys/unix$ go get github.com/tobert/pcstat/pcstat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>全部安装完成后，你就可以运行 pcstat 来查看文件的缓存情况了。比如，下面就是一个 pcstat 运行的示例，它展示了 /bin/ls 这个文件的缓存情况：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ pcstat /bin/ls+---------+----------------+------------+-----------+---------+<span class="token operator">|</span> Name    <span class="token operator">|</span> Size <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>   <span class="token operator">|</span> Pages      <span class="token operator">|</span> Cached    <span class="token operator">|</span> Percent <span class="token operator">|</span><span class="token operator">|</span>---------+----------------+------------+-----------+---------<span class="token operator">|</span><span class="token operator">|</span> /bin/ls <span class="token operator">|</span> <span class="token number">133792</span>         <span class="token operator">|</span> <span class="token number">33</span>         <span class="token operator">|</span> <span class="token number">0</span>         <span class="token operator">|</span> 000.000 <span class="token operator">|</span>+---------+----------------+------------+-----------+---------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个输出中，Cached 就是 /bin/ls 在缓存中的大小，而 Percent 则是缓存的百分比。你看到它们都是 0，这说明 /bin/ls 并不在缓存中。</p><p>接着，如果你执行一下 ls 命令，再运行相同的命令来查看的话，就会发现 /bin/ls 都在缓存中了。</p><h4 id="17-3-案例"><a href="#17-3-案例" class="headerlink" title="17.3 案例"></a>17.3 案例</h4><blockquote><p>机器配置： 2 CPU, 8 GB 内存。</p><p>安装软件：<code>apt install docker.io</code> 以及 bcc 和 pcstat。</p></blockquote><ol><li><p>dd 作为一个磁盘和文件的拷贝工具，经常被拿来测试磁盘或者文件系统的读写性能。不过，既然缓存会影响到性能，如果用 dd 对同一个文件进行多次读取测试，测试的结果会怎么样呢？</p><p> 首先，打开两个终端，连接到 Ubuntu 机器上，确保 bcc 已经安装配置成功。</p><p> 然后，使用 dd 命令生成一个临时文件，用于后面的文件读取测试：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 生成一个 512MB 的临时文件</span>$ <span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/dev/sda1 <span class="token assign-left variable">of</span><span class="token operator">=</span>file <span class="token assign-left variable">bs</span><span class="token operator">=</span>1M <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">512</span><span class="token comment"># 清理缓存</span>$ <span class="token builtin class-name">echo</span> <span class="token number">3</span> <span class="token operator">&gt;</span> /proc/sys/vm/drop_caches<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 继续在第一个终端，运行 pcstat 命令，确认刚刚生成的文件不在缓存中。如果一切正常，你会看到 Cached 和 Percent 都是 0:</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ pcstat <span class="token function">file</span>+-------+----------------+------------+-----------+---------+<span class="token operator">|</span> Name  <span class="token operator">|</span> Size <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>   <span class="token operator">|</span> Pages      <span class="token operator">|</span> Cached    <span class="token operator">|</span> Percent <span class="token operator">|</span><span class="token operator">|</span>-------+----------------+------------+-----------+---------<span class="token operator">|</span><span class="token operator">|</span> <span class="token function">file</span>  <span class="token operator">|</span> <span class="token number">536870912</span>      <span class="token operator">|</span> <span class="token number">131072</span>     <span class="token operator">|</span> <span class="token number">0</span>         <span class="token operator">|</span> 000.000 <span class="token operator">|</span>+-------+----------------+------------+-----------+---------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 在第一个终端中，现在运行 cachetop 命令：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 每隔 5 秒刷新一次数据</span>$ cachetop <span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 第二个终端，运行 dd 命令测试文件的读取速度：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>file <span class="token assign-left variable">of</span><span class="token operator">=</span>/dev/null <span class="token assign-left variable">bs</span><span class="token operator">=</span>1M<span class="token number">512</span>+0 records <span class="token keyword">in</span><span class="token number">512</span>+0 records out<span class="token number">536870912</span> bytes <span class="token punctuation">(</span><span class="token number">537</span> MB, <span class="token number">512</span> MiB<span class="token punctuation">)</span> copied, <span class="token number">16.0509</span> s, <span class="token number">33.4</span> MB/s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 从 dd 的结果可以看出，这个文件的读性能是 33.4 MB/s。由于在 dd 命令运行前我们已经清理了缓存，所以 dd 命令读取数据时，肯定要通过文件系统从磁盘中读取。</p><p> 不过，这是不是意味着， dd 所有的读请求都能直接发送到磁盘呢？</p><p> 我们再回到第一个终端， 查看 cachetop 界面的缓存命中情况：</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">PID      UID      CMD              HITS     MISSES   DIRTIES  READ_HIT%  WRITE_HIT%\.\.\.    3264 root     dd                  37077    37330        0      49.8%      50.2%<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 从 cachetop 的结果可以发现，并不是所有的读都落到了磁盘上，事实上读请求的缓存命中率只有 50% 。</p><p> 接下来，我们继续尝试相同的测试命令。先切换到第二个终端，再次执行刚才的 dd 命令：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>file <span class="token assign-left variable">of</span><span class="token operator">=</span>/dev/null <span class="token assign-left variable">bs</span><span class="token operator">=</span>1M<span class="token number">512</span>+0 records <span class="token keyword">in</span><span class="token number">512</span>+0 records out<span class="token number">536870912</span> bytes <span class="token punctuation">(</span><span class="token number">537</span> MB, <span class="token number">512</span> MiB<span class="token punctuation">)</span> copied, <span class="token number">0.118415</span> s, <span class="token number">4.5</span> GB/s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 看到这次的结果，有没有点小惊讶？磁盘的读性能居然变成了 4.5 GB/s，比第一次的结果明显高了太多。为什么这次的结果这么好呢？</p><p> 不妨再回到第一个终端，看看 cachetop 的情况：</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">10:45:22 Buffers MB: 4 / Cached MB: 719 / Sort: HITS / Order: ascendingPID      UID      CMD              HITS     MISSES   DIRTIES  READ_HIT%  WRITE_HIT%\.\.\.32642 root     dd                 131637        0        0     100.0%       0.0%<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 显然，cachetop 也有了不小的变化。你可以发现，这次的读的缓存命中率是 100.0%，也就是说这次的 dd 命令全部命中了缓存，所以才会看到那么高的性能。</p><p> 然后，回到第二个终端，再次执行 pcstat 查看文件 file 的缓存情况：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ pcstat <span class="token function">file</span>+-------+----------------+------------+-----------+---------+<span class="token operator">|</span> Name  <span class="token operator">|</span> Size <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>   <span class="token operator">|</span> Pages      <span class="token operator">|</span> Cached    <span class="token operator">|</span> Percent <span class="token operator">|</span><span class="token operator">|</span>-------+----------------+------------+-----------+---------<span class="token operator">|</span><span class="token operator">|</span> <span class="token function">file</span>  <span class="token operator">|</span> <span class="token number">536870912</span>      <span class="token operator">|</span> <span class="token number">131072</span>     <span class="token operator">|</span> <span class="token number">131072</span>    <span class="token operator">|</span> <span class="token number">100.000</span> <span class="token operator">|</span>+-------+----------------+------------+-----------+---------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 从 pcstat 的结果你可以发现，测试文件 file 已经被全部缓存了起来，这跟刚才观察到的缓存命中率 100% 是一致的。</p><p> 这两次结果说明，系统缓存对第二次 dd 操作有明显的加速效果，可以大大提高文件读取的性能。</p><p> 但同时也要注意，如果我们把 dd 当成测试文件系统性能的工具，由于缓存的存在，就会导致测试结果严重失真。</p></li><li><p>再来看一个文件读写的案例。这个案例类似于前面学过的不可中断状态进程的例子。它的基本功能比较简单，也就是每秒从磁盘分区 /dev/sda1 中读取 32MB 的数据，并打印出读取数据花费的时间。</p><p> 为了方便你运行案例，我把它打包成了一个 <a href="https://github.com/feiskyer/linux-perf-examples/tree/master/io-cached">Docker 镜像</a>。 跟前面案例类似，我提供了下面两个选项，你可以根据系统配置，自行调整磁盘分区的路径以及 I/O 的大小。</p><ul><li>-d 选项，设置要读取的磁盘或分区路径，默认是查找前缀为 /dev/sd 或者 /dev/xvd 的磁盘。</li><li><p>-s 选项，设置每次读取的数据量大小，单位为字节，默认为 33554432（也就是 32MB）。</p><p>这个案例同样需要你开启两个终端。分别 SSH 登录到机器上后，先在第一个终端中运行 cachetop 命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 每隔 5 秒刷新一次数据</span>$ cachetop <span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>接着，再到第二个终端，执行下面的命令运行案例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run --privileged --name<span class="token operator">=</span>app -itd feisky/app:io-direct<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>案例运行后，我们还需要运行下面这个命令，来确认案例已经正常启动。如果一切正常，你应该可以看到类似下面的输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker logs appReading data from disk /dev/sdb1 with buffer size <span class="token number">33554432</span>Time used: <span class="token number">0.929935</span> s to <span class="token builtin class-name">read</span> <span class="token number">33554432</span> bytesTime used: <span class="token number">0.949625</span> s to <span class="token builtin class-name">read</span> <span class="token number">33554432</span> bytes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>从这里你可以看到，每读取 32 MB 的数据，就需要花 0.9 秒。这个时间合理吗？我想你第一反应就是，太慢了吧。那这是不是没用系统缓存导致的呢？</p><p>我们再来检查一下。回到第一个终端，先看看 cachetop 的输出，在这里，我们找到案例进程 app 的缓存使用情况：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">16</span>:39:18 Buffers MB: <span class="token number">73</span> / Cached MB: <span class="token number">281</span> / Sort: HITS / Order: ascendingPID      <span class="token environment constant">UID</span>      CMD              HITS     MISSES   DIRTIES  READ_HIT%  WRITE_HIT%  <span class="token number">21881</span> root     app                  <span class="token number">1024</span>        <span class="token number">0</span>        <span class="token number">0</span>     <span class="token number">100.0</span>%       <span class="token number">0.0</span>%<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这个输出似乎有点意思了。1024 次缓存全部命中，读的命中率是 100%，看起来全部的读请求都经过了系统缓存。但是问题又来了，如果真的都是缓存 I/O，读取速度不应该这么慢。</p><p>至于为什么只能看到 0.8 MB 的 HITS，我们后面再解释，这里你先知道怎么根据结果来分析就可以了。</p><p>这也进一步验证了我们的猜想，这个案例估计没有充分利用系统缓存。其实前面我们遇到过类似的问题，如果为系统调用设置直接 I/O 的标志，就可以绕过系统缓存。</p><p>那么，要判断应用程序是否用了直接 I/O，最简单的方法当然是观察它的系统调用，查找应用程序在调用它们时的选项。使用什么工具来观察系统调用呢？自然还是 strace。</p><p>继续在终端二中运行下面的 strace 命令，观察案例应用的系统调用情况。注意，这里使用了 pgrep 命令来查找案例进程的 PID 号：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># strace -p $(pgrep app)</span>strace: Process <span class="token number">4988</span> attachedrestart_syscall<span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token punctuation">\</span>.<span class="token punctuation">\</span>.<span class="token punctuation">\</span>. resuming interrupted nanosleep <span class="token punctuation">\</span>.<span class="token punctuation">\</span>.<span class="token punctuation">\</span>.<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span>openat<span class="token punctuation">(</span>AT_FDCWD, <span class="token string">"/dev/sdb1"</span>, O_RDONLY<span class="token operator">|</span>O_DIRECT<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">4</span>mmap<span class="token punctuation">(</span>NULL, <span class="token number">33558528</span>, PROT_READ<span class="token operator">|</span>PROT_WRITE, MAP_PRIVATE<span class="token operator">|</span>MAP_ANONYMOUS, -1, <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">=</span> 0x7f448d240000read<span class="token punctuation">(</span><span class="token number">4</span>, <span class="token string">"8vq<span class="token entity" title="\213">\213</span><span class="token entity" title="\314">\314</span><span class="token entity" title="\264">\264</span>u<span class="token entity" title="\373">\373</span><span class="token entity" title="\4">\4</span><span class="token entity" title="\336">\336</span>K<span class="token entity" title="\224">\224</span><span class="token entity" title="\25">\25</span>@<span class="token entity" title="\371">\371</span><span class="token entity" title="\1">\1</span><span class="token entity" title="\252">\252</span><span class="token entity" title="\2">\2</span><span class="token entity" title="\262">\262</span><span class="token entity" title="\252">\252</span>q<span class="token entity" title="\221">\221</span><span class="token entity" title="\n">\n</span>0<span class="token entity" title="\30">\30</span><span class="token entity" title="\225">\225</span>bD<span class="token entity" title="\252">\252</span><span class="token entity" title="\266">\266</span>@J"</span><span class="token punctuation">\</span>.<span class="token punctuation">\</span>.<span class="token punctuation">\</span>., <span class="token number">33554432</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">33554432</span>write<span class="token punctuation">(</span><span class="token number">1</span>, <span class="token string">"Time used: 0.948897 s to read 33"</span><span class="token punctuation">\</span>.<span class="token punctuation">\</span>.<span class="token punctuation">\</span>., <span class="token number">45</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">45</span>close<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>                                <span class="token operator">=</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从 strace 的结果可以看到，案例应用调用了 openat 来打开磁盘分区 /dev/sdb1，并且传入的参数为 O_RDONLY|O_DIRECT（中间的竖线表示或）。</p><p>O_RDONLY 表示以只读方式打开，而 O_DIRECT 则表示以直接读取的方式打开，这会绕过系统的缓存。</p><p>验证了这一点，就很容易理解为什么读 32 MB 的数据就都要那么久了。直接从磁盘读写的速度，自然远慢于对缓存的读写。这也是缓存存在的最大意义了。</p><p>找出问题后，我们还可以在再看看案例应用的<a href="https://github.com/feiskyer/linux-perf-examples/blob/master/io-cached/app.c">源代码</a>，再次验证一下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> flags <span class="token operator">=</span> O_RDONLY <span class="token operator">|</span> O_LARGEFILE <span class="token operator">|</span> O_DIRECT<span class="token punctuation">;</span><span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>disk<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> <span class="token number">0755</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面的代码，很清楚地告诉我们：它果然用了直接 I/O。</p><p>找出了磁盘读取缓慢的原因，优化磁盘读的性能自然不在话下。修改源代码，删除 O_DIRECT 选项，让应用程序使用缓存 I/O ，而不是直接 I/O，就可以加速磁盘读取速度。</p><p><a href="https://github.com/feiskyer/linux-perf-examples/blob/master/io-cached/app-cached.c">app-cached.c</a> 就是修复后的源码，我也把它打包成了一个容器镜像。在第二个终端中，按 Ctrl+C 停止刚才的 strace 命令，运行下面的命令，你就可以启动它：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 删除上述案例应用</span>$ docker <span class="token function">rm</span> -f app<span class="token comment"># 运行修复后的应用</span>$ docker run --privileged --name<span class="token operator">=</span>app -itd feisky/app:io-cached<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还是第二个终端，再来运行下面的命令查看新应用的日志，你应该能看到下面这个输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker logs appReading data from disk /dev/sdb1 with buffer size <span class="token number">33554432</span>Time used: <span class="token number">0.037342</span> s s to <span class="token builtin class-name">read</span> <span class="token number">33554432</span> bytesTime used: <span class="token number">0.029676</span> s to <span class="token builtin class-name">read</span> <span class="token number">33554432</span> bytes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>现在，每次只需要 0.03 秒，就可以读取 32MB 数据，明显比之前的 0.9 秒快多了。所以，这次应该用了系统缓存。</p><p>我们再回到第一个终端，查看 cachetop 的输出来确认一下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">16:40:08 Buffers MB: 73 / Cached MB: 281 / Sort: HITS / Order: ascendingPID      UID      CMD              HITS     MISSES   DIRTIES  READ_HIT%  WRITE_HIT%   22106 root     app                 40960        0        0     100.0%       0.0%<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>果然，读的命中率还是 100%，HITS （即命中数）却变成了 40960，同样的方法计算一下，换算成每秒字节数正好是 32 MB（即 40960*4k/5/1024=32M）。</p><p>这个案例说明，在进行 I/O 操作时，充分利用系统缓存可以极大地提升性能。 但在观察缓存命中率时，还要注意结合应用程序实际的 I/O 大小，综合分析缓存的使用情况。</p><p>案例的最后，再回到开始的问题，为什么优化前，通过 cachetop 只能看到很少一部分数据的全部命中，而没有观察到大量数据的未命中情况呢？这是因为，cachetop 工具并不把直接 I/O 算进来。这也又一次说明了，了解工具原理的重要。</p><blockquote><p>cachetop 的计算方法涉及到 I/O 的原理以及一些内核的知识，如果你想了解它的原理的话，可以点击<a href="https://github.com/iovisor/bcc/blob/master/tools/cachetop.py">这里</a>查看它的源代码。</p></blockquote></li></ul></li></ol><h3 id="18-案例篇：内存泄漏了，我该如何定位和处理？"><a href="#18-案例篇：内存泄漏了，我该如何定位和处理？" class="headerlink" title="18 | 案例篇：内存泄漏了，我该如何定位和处理？"></a>18 | 案例篇：内存泄漏了，我该如何定位和处理？</h3><h4 id="18-1-内存的分配和回收"><a href="#18-1-内存的分配和回收" class="headerlink" title="18.1 内存的分配和回收"></a>18.1 内存的分配和回收</h4><p>用户空间内存包括多个不同的内存段，比如只读段、数据段、堆、栈以及文件映射段等。这些内存段正是应用程序使用内存的基本方式。</p><p>栈内存由系统自动分配和管理。一旦程序运行超出了这个局部变量的作用域，栈内存就会被系统自动回收，所以不会产生内存泄漏的问题。</p><p>堆内存由应用程序自己来分配和管理。除非程序退出，这些堆内存并不会被系统自动释放，而是需要应用程序明确调用库函数 free() 来释放它们。如果应用程序没有正确释放堆内存，就会造成内存泄漏。</p><p>其他内存段是否也会导致内存泄漏呢？</p><ul><li>只读段，包括程序的代码和常量，由于是只读的，不会再去分配新的内存，所以也不会产生内存泄漏。</li><li>数据段，包括全局变量和静态变量，这些变量在定义时就已经确定了大小，所以也不会产生内存泄漏。</li><li>最后一个内存映射段，包括动态链接库和共享内存，其中共享内存由程序动态分配和管理。所以，如果程序在分配后忘了回收，就会导致跟堆内存类似的泄漏问题。</li></ul><p><strong>内存泄漏的危害非常大，这些忘记释放的内存，不仅应用程序自己不能访问，系统也不能把它们再次分配给其他应用</strong>。内存泄漏不断累积，甚至会耗尽系统内存。</p><p>虽然，系统最终可以通过 OOM （Out of Memory）机制杀死进程，但进程在 OOM 前，可能已经引发了一连串的反应，导致严重的性能问题。</p><p>比如，其他需要内存的进程，可能无法分配新的内存；内存不足，又会触发系统的缓存回收以及 SWAP 机制，从而进一步导致 I/O 的性能问题等等。</p><p>如果你已经发现了内存泄漏，该如何定位和处理呢。</p><h4 id="18-2-案例"><a href="#18-2-案例" class="headerlink" title="18.2 案例"></a>18.2 案例</h4><blockquote><p>机器配置： 2 CPU, 8 GB 内存。</p><p>安装软件：<code>apt install docker.io sysstat</code> 以及 bcc。</p></blockquote><ol><li><p>执行下面的命令来运行案例：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run --name<span class="token operator">=</span>app -itd feisky/app:mem-leak<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>案例成功运行后，你需要输入下面的命令，确认案例应用已经正常启动。如果一切正常，你应该可以看到下面这个界面：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker logs app2th <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">1</span>3th <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">2</span>4th <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">3</span>5th <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">5</span>6th <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">8</span>7th <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">13</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 我们应该怎么检查内存情况，判断有没有泄漏发生呢？你首先想到的可能是 top 工具，不过，top 虽然能观察系统和进程的内存占用情况，但今天的案例并不适合。内存泄漏问题，我们更应该关注内存使用的变化趋势。</p></li><li><p>运行下面的 vmstat ，等待一段时间，观察内存的变化情况。如果忘了 vmstat 里各指标的含义，记得复习前面内容，或者执行 man vmstat 查询。</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 每隔 3 秒输出一组数据</span>$ <span class="token function">vmstat</span> <span class="token number">3</span>procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----r  b   swpd   <span class="token function">free</span>   buff  cache   si   so    bi    bo   <span class="token keyword">in</span>   cs us sy <span class="token function">id</span> wa stprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----r  b   swpd   <span class="token function">free</span>   buff  cache   si   so    bi    bo   <span class="token keyword">in</span>   cs us sy <span class="token function">id</span> wa st<span class="token number">0</span>  <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">6601824</span>  <span class="token number">97620</span> <span class="token number">1098784</span>    <span class="token number">0</span>    <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">0</span>   <span class="token number">62</span>  <span class="token number">322</span>  <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">100</span>  <span class="token number">0</span>  <span class="token number">0</span><span class="token number">0</span>  <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">6601700</span>  <span class="token number">97620</span> <span class="token number">1098788</span>    <span class="token number">0</span>    <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">0</span>   <span class="token number">57</span>  <span class="token number">251</span>  <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">100</span>  <span class="token number">0</span>  <span class="token number">0</span><span class="token number">0</span>  <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">6601320</span>  <span class="token number">97620</span> <span class="token number">1098788</span>    <span class="token number">0</span>    <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">3</span>   <span class="token number">52</span>  <span class="token number">306</span>  <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">100</span>  <span class="token number">0</span>  <span class="token number">0</span><span class="token number">0</span>  <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">6601452</span>  <span class="token number">97628</span> <span class="token number">1098788</span>    <span class="token number">0</span>    <span class="token number">0</span>     <span class="token number">0</span>    <span class="token number">27</span>   <span class="token number">63</span>  <span class="token number">326</span>  <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">100</span>  <span class="token number">0</span>  <span class="token number">0</span><span class="token number">2</span>  <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">6601328</span>  <span class="token number">97628</span> <span class="token number">1098788</span>    <span class="token number">0</span>    <span class="token number">0</span>     <span class="token number">0</span>    <span class="token number">44</span>   <span class="token number">52</span>  <span class="token number">299</span>  <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">100</span>  <span class="token number">0</span>  <span class="token number">0</span><span class="token number">0</span>  <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">6601080</span>  <span class="token number">97628</span> <span class="token number">1098792</span>    <span class="token number">0</span>    <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">0</span>   <span class="token number">56</span>  <span class="token number">285</span>  <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">100</span>  <span class="token number">0</span>  <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 从输出中你可以看到，内存的 free 列在不停的变化，并且是下降趋势；而 buffer 和 cache 基本保持不变。</p><p> 未使用内存在逐渐减小，而 buffer 和 cache 基本不变，这说明，系统中使用的内存一直在升高。但这并不能说明有内存泄漏，因为应用程序运行中需要的内存也可能会增大。比如说，程序中如果用了一个动态增长的数组来缓存计算结果，占用内存自然会增长。</p><p> 那怎么确定是不是内存泄漏呢？或者换句话说，有没有简单方法找出让内存增长的进程，并定位增长内存用在哪儿呢？</p><p> 根据前面内容，你应该想到了用 top 或 ps 来观察进程的内存使用情况，然后找出内存使用一直增长的进程，最后再通过 pmap 查看进程的内存分布。</p><p> 但这种方法并不太好用，因为要判断内存的变化情况，还需要你写一个脚本，来处理 top 或者 ps 的输出。</p><p> 这里，我介绍一个专门用来检测内存泄漏的工具，memleak。memleak 可以跟踪系统或指定进程的内存分配、释放请求，然后定期输出一个未释放内存和相应调用栈的汇总情况（默认 5 秒）。</p></li><li><p>memleak 是 bcc 软件包中的一个工具，我们一开始就装好了，执行 /usr/share/bcc/tools/memleak 就可以运行它。比如，我们运行下面的命令：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -a 表示显示每个内存分配请求的大小以及地址</span><span class="token comment"># -p 指定案例应用的 PID 号</span>$ /usr/share/bcc/tools/memleak -a -p <span class="token variable"><span class="token variable">$(</span>pidof app<span class="token variable">)</span></span>WARNING: Couldn<span class="token string">'t find .text section in /appWARNING: BCC can'</span>t handle sym <span class="token function">look</span> ups <span class="token keyword">for</span> /app    addr <span class="token operator">=</span> 7f8f704732b0 size <span class="token operator">=</span> <span class="token number">8192</span>    addr <span class="token operator">=</span> 7f8f704772d0 size <span class="token operator">=</span> <span class="token number">8192</span>    addr <span class="token operator">=</span> 7f8f704712a0 size <span class="token operator">=</span> <span class="token number">8192</span>    addr <span class="token operator">=</span> 7f8f704752c0 size <span class="token operator">=</span> <span class="token number">8192</span>    <span class="token number">32768</span> bytes <span class="token keyword">in</span> <span class="token number">4</span> allocations from stack        <span class="token punctuation">[</span>unknown<span class="token punctuation">]</span> <span class="token punctuation">[</span>app<span class="token punctuation">]</span>        <span class="token punctuation">[</span>unknown<span class="token punctuation">]</span> <span class="token punctuation">[</span>app<span class="token punctuation">]</span>        start_thread+0xdb <span class="token punctuation">[</span>libpthread-2.27.so<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 从 memleak 的输出可以看到，案例应用在不停地分配内存，并且这些分配的地址没有被回收。</p><p> 这里有一个问题，Couldn’t find .text section in /app，所以调用栈不能正常输出，最后的调用栈部分只能看到 [unknown] 的标志。</p><p> 为什么会有这个错误呢？实际上，这是由于案例应用运行在容器中导致的。memleak 工具运行在容器之外，并不能直接访问进程路径 /app。</p><p> 类似的问题，我在 CPU 模块中的 <a href="https://time.geekbang.org/column/article/73738">perf 使用方法</a> 中已经提到好几个解决思路。最简单的方法，就是在容器外部构建相同路径的文件以及依赖库。这个案例只有一个二进制文件，所以只要把案例应用的二进制文件放到 /app 路径中，就可以修复这个问题。</p><p> 比如，你可以运行下面的命令，把 app 二进制文件从容器中复制出来，然后重新运行 memleak 工具：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ /usr/share/bcc/tools/memleak -p <span class="token variable"><span class="token variable">$(</span>pidof app<span class="token variable">)</span></span> -aAttaching to pid <span class="token number">12512</span>, Ctrl+C to quit.<span class="token punctuation">[</span>03:00:41<span class="token punctuation">]</span> Top <span class="token number">10</span> stacks with outstanding allocations:    addr <span class="token operator">=</span> 7f8f70863220 size <span class="token operator">=</span> <span class="token number">8192</span>    addr <span class="token operator">=</span> 7f8f70861210 size <span class="token operator">=</span> <span class="token number">8192</span>    addr <span class="token operator">=</span> 7f8f7085b1e0 size <span class="token operator">=</span> <span class="token number">8192</span>    addr <span class="token operator">=</span> 7f8f7085f200 size <span class="token operator">=</span> <span class="token number">8192</span>    addr <span class="token operator">=</span> 7f8f7085d1f0 size <span class="token operator">=</span> <span class="token number">8192</span>    <span class="token number">40960</span> bytes <span class="token keyword">in</span> <span class="token number">5</span> allocations from stack        fibonacci+0x1f <span class="token punctuation">[</span>app<span class="token punctuation">]</span>        child+0x4f <span class="token punctuation">[</span>app<span class="token punctuation">]</span>        start_thread+0xdb <span class="token punctuation">[</span>libpthread-2.27.so<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 这一次，我们终于看到了内存分配的调用栈，原来是 fibonacci() 函数分配的内存没释放。</p><p> 定位了内存泄漏的来源，下一步自然就应该查看源码，想办法修复它。我们一起来看案例应用的源代码 <a href="https://github.com/feiskyer/linux-perf-examples/blob/master/mem-leak/app.c">app.c</a>：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker <span class="token builtin class-name">exec</span> app <span class="token function">cat</span> /app.c<span class="token punctuation">..</span>.long long *fibonacci<span class="token punctuation">(</span>long long *n0, long long *n1<span class="token punctuation">)</span><span class="token punctuation">{</span>    // 分配 <span class="token number">1024</span> 个长整数空间方便观测内存的变化情况    long long *v <span class="token operator">=</span> <span class="token punctuation">(</span>long long *<span class="token punctuation">)</span> calloc<span class="token punctuation">(</span><span class="token number">1024</span>, sizeof<span class="token punctuation">(</span>long long<span class="token punctuation">))</span><span class="token punctuation">;</span>    *v <span class="token operator">=</span> *n0 + *n1<span class="token punctuation">;</span>    <span class="token builtin class-name">return</span> <span class="token function">v</span><span class="token punctuation">;</span><span class="token punctuation">}</span>void *child<span class="token punctuation">(</span>void *arg<span class="token punctuation">)</span><span class="token punctuation">{</span>    long long n0 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    long long n1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    long long *v <span class="token operator">=</span> NULL<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>int n <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> n <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> n++<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">v</span> <span class="token operator">=</span> fibonacci<span class="token punctuation">(</span><span class="token operator">&amp;</span>n0, <span class="token operator">&amp;</span>n1<span class="token punctuation">)</span><span class="token punctuation">;</span>        n0 <span class="token operator">=</span> n1<span class="token punctuation">;</span>        n1 <span class="token operator">=</span> *v<span class="token punctuation">;</span>        printf<span class="token punctuation">(</span><span class="token string">"%dth =&gt; %lld<span class="token entity" title="\n">\n</span>"</span>, n, *v<span class="token punctuation">)</span><span class="token punctuation">;</span>        sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>我把修复后的代码放到了 <a href="https://github.com/feiskyer/linux-perf-examples/blob/master/mem-leak/app-fix.c">app-fix.c</a>，也打包成了一<br>个 Docker 镜像。你可以运行下面的命令，验证一下内存泄漏是否修复：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 清理原来的案例应用</span>$ docker <span class="token function">rm</span> -f app<span class="token comment"># 运行修复后的应用</span>$ docker run --name<span class="token operator">=</span>app -itd feisky/app:mem-leak-fix<span class="token comment"># 重新执行 memleak 工具检查内存泄漏情况</span>$ /usr/share/bcc/tools/memleak -a -p <span class="token variable"><span class="token variable">$(</span>pidof app<span class="token variable">)</span></span>Attaching to pid <span class="token number">18808</span>, Ctrl+C to quit.<span class="token punctuation">[</span><span class="token number">10</span>:23:18<span class="token punctuation">]</span> Top <span class="token number">10</span> stacks with outstanding allocations:<span class="token punctuation">[</span><span class="token number">10</span>:23:23<span class="token punctuation">]</span> Top <span class="token number">10</span> stacks with outstanding allocations:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="19-案例篇：为什么系统的Swap变高了（上）"><a href="#19-案例篇：为什么系统的Swap变高了（上）" class="headerlink" title="19 | 案例篇：为什么系统的Swap变高了（上）"></a>19 | 案例篇：为什么系统的Swap变高了（上）</h3></li></ol><p>当发生了内存泄漏时，或者运行了大内存的应用程序，导致系统的内存资源紧张时，系统又会如何应对呢？</p><p>这其实会导致两种可能结果，内存回收和 OOM 杀死进程。</p><p>内存资源紧张导致的 OOM（Out Of Memory），相对容易理解，指的是系统杀死占用大量内存的进程，释放这些内存，再分配给其他更需要的进程。</p><p>内存回收，也就是系统释放掉可以回收的内存，比如我前面讲过的缓存和缓冲区，就属于可回收内存。它们在内存管理中，通常被叫做<strong>文件页</strong>（File-backed Page）。</p><p>大部分文件页，都可以直接回收，以后有需要时，再从磁盘重新读取就可以了。而那些被应用程序修改过，并且暂时还没写入磁盘的数据（也就是脏页），就得先写入磁盘，然后才能进行内存释放。</p><p>这些脏页，一般可以通过两种方式写入磁盘。</p><ul><li>可以在应用程序中，通过系统调用 fsync ，把脏页同步到磁盘中；</li><li>也可以交给系统，由内核线程 pdflush 负责这些脏页的刷新。</li></ul><p>除了缓存和缓冲区，通过内存映射获取的文件映射页，也是一种常见的文件页。它也可以被释放掉，下次再访问的时候，从文件重新读取。</p><p>除了文件页外，还有没有其他的内存可以回收呢？比如，应用程序动态分配的堆内存，也就是我们在内存管理中说到的匿名页（Anonymous Page），是不是也可以回收呢？</p><p>我想，你肯定会说，它们很可能还要再次被访问啊，当然不能直接回收了。非常正确，这些内存自然不能直接释放。</p><p>但是，如果这些内存在分配后很少被访问，似乎也是一种资源浪费。是不是可以把它们暂时先存在磁盘里，释放内存给其他更需要的进程？</p><p>其实，这正是 Linux 的 Swap 机制。Swap 把这些不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存就可以了。</p><h4 id="19-1-Swap-原理"><a href="#19-1-Swap-原理" class="headerlink" title="19.1 Swap 原理"></a>19.1 Swap 原理</h4><p>Swap 说白了就是把一块磁盘空间或者一个本地文件（以下讲解以磁盘为例），当成内存来使用。它包括换出和换入两个过程。</p><ul><li>所谓换出，就是把进程暂时不用的内存数据存储到磁盘中，并释放这些数据占用的内存。</li><li>而换入，则是在进程再次访问这些内存的时候，把它们从磁盘读到内存中来。</li></ul><p>Swap 其实是把系统的可用内存变大了。这样，即使服务器的内存不足，也可以运行大内存的应用程序。</p><p>现在的内存便宜多了，服务器一般也会配置很大的内存，那是不是说 Swap 就没有用武之地了呢？</p><p>当然不是。事实上，内存再大，对应用程序来说，也有不够用的时候。</p><p>一个很典型的场景就是，即使内存不足时，有些应用程序也并不想被 OOM 杀死，而是希望能缓一段时间，等待人工介入，或者等系统自动释放其他进程的内存，再分配给它。</p><p>除此之外，我们常见的笔记本电脑的休眠和快速开机的功能，也基于 Swap 。休眠时，把系统的内存存入磁盘，这样等到再次开机时，只要从磁盘中加载内存就可以。这样就省去了很多应用程序的初始化过程，加快了开机速度。</p><p>话说回来，既然 Swap 是为了回收内存，那么 Linux 到底在什么时候需要回收内存呢？前面一直在说内存资源紧张，又该怎么来衡量内存是不是紧张呢？</p><ol><li><p>一个最容易想到的场景就是，有新的大块内存分配请求，但是剩余内存不足。这个时候系统就需要回收一部分内存（比如前面提到的缓存），进而尽可能地满足新内存请求。这个过程通常被称为<strong>直接内存回收</strong>。</p></li><li><p>除了直接内存回收，还有一个专门的内核线程用来定期回收内存，也就是<strong>kswapd0</strong>。为了衡量内存的使用情况，kswapd0 定义了三个内存阈值（watermark，也称为水位），分别是</p><p> 页最小阈值（pages_min）、页低阈值（pages_low）和页高阈值（pages_high）。剩余内存，则使用 pages_free 表示。</p><p> 这里，我画了一张图表示它们的关系。</p><p> <img src="/images/《Linux性能优化实战》学习笔记/kswapd0的三个内存阈值.png" alt="kswapd0的三个内存阈值"></p><p> kswapd0 定期扫描内存的使用情况，并根据剩余内存落在这三个阈值的空间位置，进行内存的回收操作。</p><ul><li>剩余内存小于<strong>页最小阈值</strong>，说明进程可用内存都耗尽了，只有内核才可以分配内存。</li><li>剩余内存落在<strong>页最小阈值</strong>和<strong>页低阈值</strong>中间，说明内存压力比较大，剩余内存不多了。这时 kswapd0 会执行内存回收，直到剩余内存大于高阈值为止。</li><li>剩余内存落在<strong>页低阈值</strong>和<strong>页高阈值</strong>中间，说明内存有一定压力，但还可以满足新内存请求。</li><li><p>剩余内存大于<strong>页高阈值</strong>，说明剩余内存比较多，没有内存压力。</p><p>我们可以看到，一旦剩余内存小于页低阈值，就会触发内存的回收。这个页低阈值，其实可以通过内核选项 /proc/sys/vm/min_free_kbytes 来间接设置。min_free_kbytes 设置了页最小阈值，而其他两个阈值，都是根据页最小阈值计算生成的，计算方法如下 ：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pages_low <span class="token operator">=</span> pages_min*5/4pages_high <span class="token operator">=</span> pages_min*3/2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="19-2-NUMA-与-Swap"><a href="#19-2-NUMA-与-Swap" class="headerlink" title="19.2 NUMA 与 Swap"></a>19.2 NUMA 与 Swap</h4></li></ul></li></ol><p>很多情况下，你明明发现了 Swap 升高，可是在分析系统的内存使用时，却很可能发现，系统剩余内存还多着呢。为什么剩余内存很多的情况下，也会发生 Swap 呢？</p><p>看到上面的标题，你应该已经想到了，这正是处理器的 NUMA （Non-Uniform Memory Access）架构导致的。</p><p>在 NUMA 架构下，多个处理器被划分到不同 Node 上，且每个 Node 都拥有自己的本地内存空间。</p><p>而同一个 Node 内部的内存空间，实际上又可以进一步分为不同的内存域（Zone），比如直接内存访问区（DMA）、普通内存区（NORMAL）、伪内存区（MOVABLE）等，如下图所示：</p><p><img src="/images/《Linux性能优化实战》学习笔记/NUMA与Swap.png" alt="NUMA与Swap"></p><p>先不用特别关注这些内存域的具体含义，我们只要会查看阈值的配置，以及缓存、匿名页的实际使用情况就够了。</p><p>既然 NUMA 架构下的每个 Node 都有自己的本地内存空间，那么，在分析内存的使用时，我们也应该针对每个 Node 单独分析。</p><p>你可以通过 numactl 命令，来查看处理器在 Node 的分布情况，以及每个 Node 的内存使用情况。比如，下面就是一个 numactl 输出的示例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ numactl --hardwareavailable: <span class="token number">1</span> nodes <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>node <span class="token number">0</span> cpus: <span class="token number">0</span> <span class="token number">1</span>node <span class="token number">0</span> size: <span class="token number">7977</span> MBnode <span class="token number">0</span> free: <span class="token number">4416</span> MB<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个界面显示，我的系统中只有一个 Node，也就是 Node 0 ，而且编号为 0 和 1 的两个 CPU， 都位于 Node 0 上。另外，Node 0 的内存大小为 7977 MB，剩余内存为 4416 MB。</p><p>实际上，前面提到的三个内存阈值（页最小阈值、页低阈值和页高阈值），都可以通过内存域在 proc 文件系统中的接口 /proc/zoneinfo 来查看。</p><p>比如，下面就是一个 /proc/zoneinfo 文件的内容示例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> /proc/zoneinfo<span class="token punctuation">..</span>.Node <span class="token number">0</span>, zone   Normal pages <span class="token function">free</span>     <span class="token number">227894</span>       min      <span class="token number">14896</span>       low      <span class="token number">18620</span>       high     <span class="token number">22344</span><span class="token punctuation">..</span>.     nr_free_pages <span class="token number">227894</span>     nr_zone_inactive_anon <span class="token number">11082</span>     nr_zone_active_anon <span class="token number">14024</span>     nr_zone_inactive_file <span class="token number">539024</span>     nr_zone_active_file <span class="token number">923986</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个输出中有大量指标，我来解释一下比较重要的几个。</p><ul><li>pages 处的 min、low、high，就是上面提到的三个内存阈值，而 free 是剩余内存页数，它跟后面的 nr_free_pages 相同。</li><li>nr_zone_active_anon 和 nr_zone_inactive_anon，分别是活跃和非活跃的匿名页数。</li><li>nr_zone_active_file 和 nr_zone_inactive_file，分别是活跃和非活跃的文件页数。</li></ul><p>从这个输出结果可以发现，剩余内存远大于页高阈值，所以此时的 kswapd0 不会回收内存。</p><p>当然，某个 Node 内存不足时，系统可以从其他 Node 寻找空闲内存，也可以从本地内存中回收内存。具体选哪种模式，你可以通过 /proc/sys/vm/zone_reclaim_mode 来调整。它支持以下几个选项：</p><ul><li>默认的 0 ，也就是刚刚提到的模式，表示既可以从其他 Node 寻找空闲内存，也可以从本地回收内存。</li><li>1、2、4 都表示只回收本地内存，2 表示可以回写脏数据回收内存，4 表示可以用 Swap 方式回收内存。</li></ul><h4 id="19-3-swappiness"><a href="#19-3-swappiness" class="headerlink" title="19.3 swappiness"></a>19.3 swappiness</h4><p>到这里，我们就可以理解内存回收的机制了。这些回收的内存既包括了文件页，又包括了匿名页。</p><ul><li>对文件页的回收，当然就是直接回收缓存，或者把脏页写回磁盘后再回收。</li><li>而对匿名页的回收，其实就是通过 Swap 机制，把它们写入磁盘后再释放内存。</li></ul><p>不过，你可能还有一个问题。既然有两种不同的内存回收机制，那么在实际回收内存时，到底该先回收哪一种呢？</p><p>其实，Linux 提供了一个 /proc/sys/vm/swappiness 选项，用来调整使用 Swap 的积极程度。</p><p>swappiness 的范围是 0-100，数值越大，越积极使用 Swap，也就是更倾向于回收匿名页；数值越小，越消极使用 Swap，也就是更倾向于回收文件页。</p><p>虽然 swappiness 的范围是 0-100，不过要注意，这并不是内存的百分比，而是调整 Swap 积极程度的权重，即使你把它设置成 0，当<a href="https://www.kernel.org/doc/Documentation/sysctl/vm.txt">剩余内存 + 文件页小于页高阈值</a>时，还是会发生 Swap。</p><blockquote><p>A value of 0 instructs the kernel not to initiate swap until the amount of free and file-backed pages is less than the high water mark in a zone.</p></blockquote><h3 id="20-案例篇：为什么系统的Swap变高了？（下）"><a href="#20-案例篇：为什么系统的Swap变高了？（下）" class="headerlink" title="20 | 案例篇：为什么系统的Swap变高了？（下）"></a>20 | 案例篇：为什么系统的Swap变高了？（下）</h3><h4 id="20-1-案例"><a href="#20-1-案例" class="headerlink" title="20.1 案例"></a>20.1 案例</h4><blockquote><p>机器配置： 2 CPU, 8 GB 内存。</p><p>安装软件：<code>apt install sysstat</code>。</p></blockquote><ol><li><p>在终端中运行 free 命令，查看 Swap 的使用情况。比如，在我的机器中，输出如下：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">free</span>             total        used        <span class="token function">free</span>      shared  buff/cache   availableMem:        <span class="token number">8169348</span>      <span class="token number">331668</span>     <span class="token number">6715972</span>         <span class="token number">696</span>     <span class="token number">1121708</span>     <span class="token number">7522896</span>Swap:             <span class="token number">0</span>           <span class="token number">0</span>           <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 从这个 free 输出你可以看到，Swap 的大小是 0，这说明我的机器没有配置 Swap。</p></li><li><p>要开启 Swap，我们首先要清楚，Linux 本身支持两种类型的 Swap，即 Swap 分区和 Swap 文件。以 Swap 文件为例，在第一个终端中运行下面的命令开启 Swap，我这里配置 Swap 文件的大小为 8GB：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 创建 Swap 文件</span>$ fallocate -l 8G /mnt/swapfile<span class="token comment"># 修改权限只有根用户可以访问</span>$ <span class="token function">chmod</span> <span class="token number">600</span> /mnt/swapfile<span class="token comment"># 配置 Swap 文件</span>$ <span class="token function">mkswap</span> /mnt/swapfile<span class="token comment"># 开启 Swap</span>$ <span class="token function">swapon</span> /mnt/swapfile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>然后，再执行 free 命令，确认 Swap 配置成功：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">free</span>            total        used        <span class="token function">free</span>      shared  buff/cache   availableMem:        <span class="token number">8169348</span>      <span class="token number">331668</span>     <span class="token number">6715972</span>         <span class="token number">696</span>     <span class="token number">1121708</span>     <span class="token number">7522896</span>Swap:       <span class="token number">8388604</span>           <span class="token number">0</span>     <span class="token number">8388604</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在第一个终端中，运行下面的 dd 命令，模拟大文件的读取：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 写入空设备，实际上只有磁盘的读请求</span>$ <span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/dev/sda1 <span class="token assign-left variable">of</span><span class="token operator">=</span>/dev/null <span class="token assign-left variable">bs</span><span class="token operator">=</span>1G <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">2048</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>接着，在第二个终端中运行 sar 命令，查看内存各个指标的变化情况。你可以多观察一会儿，查看这些指标的变化情况。</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 间隔 1 秒输出一组数据</span><span class="token comment"># -r 表示显示内存使用情况，-S 表示显示 Swap 使用情况</span>$ sar -r -S <span class="token number">1</span>04:39:56    kbmemfree   kbavail kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty04:39:57      <span class="token number">6249676</span>   <span class="token number">6839824</span>   <span class="token number">1919632</span>     <span class="token number">23.50</span>    <span class="token number">740512</span>     <span class="token number">67316</span>   <span class="token number">1691736</span>     <span class="token number">10.22</span>    <span class="token number">815156</span>    <span class="token number">841868</span>         <span class="token number">4</span>04:39:56    kbswpfree kbswpused  %swpused  kbswpcad   %swpcad04:39:57      <span class="token number">8388604</span>         <span class="token number">0</span>      <span class="token number">0.00</span>         <span class="token number">0</span>      <span class="token number">0.00</span>04:39:57    kbmemfree   kbavail kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty04:39:58      <span class="token number">6184472</span>   <span class="token number">6807064</span>   <span class="token number">1984836</span>     <span class="token number">24.30</span>    <span class="token number">772768</span>     <span class="token number">67380</span>   <span class="token number">1691736</span>     <span class="token number">10.22</span>    <span class="token number">847932</span>    <span class="token number">874224</span>        <span class="token number">20</span>04:39:57    kbswpfree kbswpused  %swpused  kbswpcad   %swpcad04:39:58      <span class="token number">8388604</span>         <span class="token number">0</span>      <span class="token number">0.00</span>         <span class="token number">0</span>      <span class="token number">0.00</span>…04:44:06    kbmemfree   kbavail kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty04:44:07       <span class="token number">152780</span>   <span class="token number">6525716</span>   <span class="token number">8016528</span>     <span class="token number">98.13</span>   <span class="token number">6530440</span>     <span class="token number">51316</span>   <span class="token number">1691736</span>     <span class="token number">10.22</span>    <span class="token number">867124</span>   <span class="token number">6869332</span>         <span class="token number">0</span>04:44:06    kbswpfree kbswpused  %swpused  kbswpcad   %swpcad04:44:07      <span class="token number">8384508</span>      <span class="token number">4096</span>      <span class="token number">0.05</span>        <span class="token number">52</span>      <span class="token number">1.27</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 我们可以看到，sar 的输出结果是两个表格，第一个表格表示内存的使用情况，第二个表格表示 Swap 的使用情况。其中，各个指标名称前面的 kb 前缀，表示这些指标的单位是 KB。</p><p> 几个新出现的指标，我来简单介绍一下。</p><ul><li>kbcommit，表示当前系统负载需要的内存。它实际上是为了保证系统内存不溢出，对需要内存的估计值。%commit，就是这个值相对总内存的百分比。</li><li>kbactive，表示活跃内存，也就是最近使用过的内存，一般不会被系统回收。</li><li><p>kbinact，表示非活跃内存，也就是不常访问的内存，有可能会被系统回收。</p><p>清楚了界面指标的含义后，我们再结合具体数值，来分析相关的现象。你可以清楚地看到，总的内存使用率（%memused）在不断增长，从开始的 23% 一直长到了 98%，并且主要内存都被缓冲区（kbbuffers）占用。具体来说：</p></li><li><p>刚开始，剩余内存（kbmemfree）不断减少，而缓冲区（kbbuffers）则不断增大，由此可知，剩余内存不断分配给了缓冲区。</p></li><li><p>一段时间后，剩余内存已经很小，而缓冲区占用了大部分内存。这时候，Swap 的使用开始逐渐增大，缓冲区和剩余内存则只在小范围内波动。</p><p>你可能困惑了，为什么缓冲区在不停增大？这又是哪些进程导致的呢？</p><p>显然，我们还得看看进程缓存的情况。在前面缓存的案例中我们学过， cachetop 正好能满足这一点。那我们就来 cachetop 一下。</p></li></ul></li><li><p>在第二个终端中，按下 Ctrl+C 停止 sar 命令，然后运行下面的 cachetop 命令，观察缓存的使用情况：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cachetop <span class="token number">5</span><span class="token number">12</span>:28:28 Buffers MB: <span class="token number">6349</span> / Cached MB: <span class="token number">87</span> / Sort: HITS / Order: ascendingPID      <span class="token environment constant">UID</span>      CMD              HITS     MISSES   DIRTIES  READ_HIT%  WRITE_HIT%   <span class="token number">18280</span> root     python                 <span class="token number">22</span>        <span class="token number">0</span>        <span class="token number">0</span>     <span class="token number">100.0</span>%       <span class="token number">0.0</span>%   <span class="token number">18279</span> root     <span class="token function">dd</span>                  <span class="token number">41088</span>    <span class="token number">41022</span>        <span class="token number">0</span>      <span class="token number">50.0</span>%      <span class="token number">50.0</span>%<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 通过 cachetop 的输出，我们看到，dd 进程的读写请求只有 50% 的命中率，并且未命中的缓存页数（MISSES）为 41022（单位是页）。这说明，正是案例开始时运行的 dd，导致了缓冲区使用升高。</p><p> 你可能接着会问，为什么 Swap 也跟着升高了呢？直观来说，缓冲区占了系统绝大部分内存，还属于可回收内存，内存不够用时，不应该先回收缓冲区吗？</p><p> 这种情况，我们还得进一步通过 /proc/zoneinfo ，观察剩余内存、内存阈值以及匿名页和文件页的活跃情况。</p></li><li><p>你可以在第二个终端中，按下 Ctrl+C，停止 cachetop 命令。然后运行下面的命令，观察 /proc/zoneinfo 中这几个指标的变化情况：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -d 表示高亮变化的字段</span><span class="token comment"># -A 表示仅显示 Normal 行以及之后的 15 行输出</span>$ <span class="token function">watch</span> -d <span class="token function">grep</span> -A <span class="token number">15</span> <span class="token string">'Normal'</span> /proc/zoneinfoNode <span class="token number">0</span>, zone   Normal  pages <span class="token function">free</span>     <span class="token number">21328</span>        min      <span class="token number">14896</span>        low      <span class="token number">18620</span>        high     <span class="token number">22344</span>        spanned  <span class="token number">1835008</span>        present  <span class="token number">1835008</span>        managed  <span class="token number">1796710</span>        protection: <span class="token punctuation">(</span><span class="token number">0</span>, <span class="token number">0</span>, <span class="token number">0</span>, <span class="token number">0</span>, <span class="token number">0</span><span class="token punctuation">)</span>      nr_free_pages <span class="token number">21328</span>      nr_zone_inactive_anon <span class="token number">79776</span>      nr_zone_active_anon <span class="token number">206854</span>      nr_zone_inactive_file <span class="token number">918561</span>      nr_zone_active_file <span class="token number">496695</span>      nr_zone_unevictable <span class="token number">2251</span>      nr_zone_write_pending <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 你可以发现，剩余内存（pages_free）在一个小范围内不停地波动。当它小于页低阈值（pages_low) 时，又会突然增大到一个大于页高阈值（pages_high）的值。</p><p> 再结合刚刚用 sar 看到的剩余内存和缓冲区的变化情况，我们可以推导出，剩余内存和缓冲区的波动变化，正是由于内存回收和缓存再次分配的循环往复。</p><ul><li>当剩余内存小于页低阈值时，系统会回收一些缓存和匿名内存，使剩余内存增大。其中，缓存的回收导致 sar 中的缓冲区减小，而匿名内存的回收导致了 Swap 的使用增大。</li><li><p>紧接着，由于 dd 还在继续，剩余内存又会重新分配给缓存，导致剩余内存减少，缓冲区增大。</p><p>其实还有一个有趣的现象，如果多次运行 dd 和 sar，你可能会发现，在多次的循环重复中，有时候是 Swap 用得比较多，有时候 Swap 很少，反而缓冲区的波动更大。</p><p>换句话说，系统回收内存时，有时候会回收更多的文件页，有时候又回收了更多的匿名页。</p><p>显然，系统回收不同类型内存的倾向，似乎不那么明显。你应该想到了上节课提到的 swappiness，正是调整不同类型内存回收的配置选项。</p></li></ul></li><li><p>还是在第二个终端中，按下 Ctrl+C 停止 watch 命令，然后运行下面的命令，查看 swappiness 的配置：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> /proc/sys/vm/swappiness<span class="token number">60</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> swappiness 显示的是默认值 60，这是一个相对中和的配置，所以系统会根据实际运行情况，选择合适的回收类型，比如回收不活跃的匿名页，或者不活跃的文件页。</p><p> 到这里，我们已经找出了 Swap 发生的根源。另一个问题就是，刚才的 Swap 到底影响了哪些应用程序呢？换句话说，Swap 换出的是哪些进程的内存？</p><p> 这里我还是推荐 proc 文件系统，用来查看进程 Swap 换出的虚拟内存大小，它保存在 /proc/pid/status 中的 VmSwap 中（推荐你执行 man proc 来查询其他字段的含义）。</p><p> 在第二个终端中运行下面的命令，就可以查看使用 Swap 最多的进程。注意 for、awk、sort 都是最常用的 Linux 命令，如果你还不熟悉，可以用 man 来查询它们的手册，或上网搜索教程来学习。</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 按 VmSwap 使用量对进程排序，输出进程名称、进程 ID 以及 SWAP 用量</span>$ <span class="token keyword">for</span> <span class="token for-or-select variable">file</span> <span class="token keyword">in</span> /proc/*/status <span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token function">awk</span> <span class="token string">'/VmSwap|Name|^Pid/{printf <span class="token variable">$2</span> " " <span class="token variable">$3</span>}END{ print ""}'</span> <span class="token variable">$file</span><span class="token punctuation">;</span> <span class="token keyword">done</span> <span class="token operator">|</span> <span class="token function">sort</span> -k <span class="token number">3</span> -n -r <span class="token operator">|</span> <span class="token function">head</span>dockerd <span class="token number">2226</span> <span class="token number">10728</span> kBdocker-containe <span class="token number">2251</span> <span class="token number">8516</span> kBsnapd <span class="token number">936</span> <span class="token number">4020</span> kBnetworkd-dispat <span class="token number">911</span> <span class="token number">836</span> kBpolkitd <span class="token number">1004</span> <span class="token number">44</span> kB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>也可以使用命令 <code>smem --sort swap</code>。</p></blockquote><p> 这也说明了一点，虽然缓存属于可回收内存，但在类似大文件拷贝这类场景下，系统还是会用 Swap 机制来回收匿名内存，而不仅仅是回收占用绝大部分内存的文件页。</p></li><li><p>最后，如果你在一开始配置了 Swap，不要忘记在案例结束后关闭。你可以运行下面的命令，关闭 Swap：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ swapoff -a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>实际上，关闭 Swap 后再重新打开，也是一种常用的 Swap 空间清理方法，比如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ swapoff -a <span class="token operator">&amp;&amp;</span> <span class="token function">swapon</span> -a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="20-2-小结"><a href="#20-2-小结" class="headerlink" title="20.2 小结"></a>20.2 小结</h4></li></ol><p>在内存资源紧张时，Linux 会通过 Swap ，把不常访问的匿名页换出到磁盘中，下次访问的时候再从磁盘换入到内存中来。你可以设置 /proc/sys/vm/min_free_kbytes，来调整系统定期回收内存的阈值；也可以设置 /proc/sys/vm/swappiness，来调整文件页和匿名页的回收倾向。</p><p>当 Swap 变高时，你可以用 sar、/proc/zoneinfo、/proc/pid/status 等方法，查看系统和进程的内存使用情况，进而找出 Swap 升高的根源和受影响的进程。</p><p>反过来说，通常，降低 Swap 的使用，可以提高系统的整体性能。要怎么做呢？这里，我也总结了几种常见的降低方法。</p><ul><li>禁止 Swap，现在服务器的内存足够大，所以除非有必要，禁用 Swap 就可以了。随着云计算的普及，大部分云平台中的虚拟机都默认禁止 Swap。</li><li>如果实在需要用到 Swap，可以尝试降低 swappiness 的值，减少内存回收时 Swap 的使用倾向。</li><li>响应延迟敏感的应用，如果它们可能在开启 Swap 的服务器中运行，你还可以用库函数 mlock() 或者 mlockall() 锁定内存，阻止它们的内存换出。</li></ul><h3 id="21-套路篇：如何“快准狠”找到系统内存的问题？"><a href="#21-套路篇：如何“快准狠”找到系统内存的问题？" class="headerlink" title="21 | 套路篇：如何“快准狠”找到系统内存的问题？"></a>21 | 套路篇：如何“快准狠”找到系统内存的问题？</h3><h4 id="21-1-内存性能指标"><a href="#21-1-内存性能指标" class="headerlink" title="21.1 内存性能指标"></a>21.1 内存性能指标</h4><p>为了分析内存的性能瓶颈，首先你要知道，怎样衡量内存的性能，也就是性能指标问题。</p><ol><li><p>首先，你最容易想到的是系统内存使用情况，比如已用内存、剩余内存、共享内存、可用内存、缓存和缓冲区的用量等。</p><ul><li>已用内存和剩余内存很容易理解，就是已经使用和还未使用的内存。</li><li>共享内存是通过 tmpfs 实现的，所以它的大小也就是 tmpfs 使用的内存大小。tmpfs 其实也是一种特殊的缓存。</li><li>可用内存是新进程可以使用的最大内存，它包括剩余内存和可回收缓存。</li><li>缓存包括两部分，一部分是磁盘读取文件的页缓存，用来缓存从磁盘读取的数据，可以加快以后再次访问的速度。另一部分，则是 Slab 分配器中的可回收内存。</li><li>缓冲区是对原始磁盘块的临时存储，用来缓存将要写入磁盘的数据。这样，内核就可以把分散的写集中起来，统一优化磁盘写入。</li></ul></li><li><p>第二类很容易想到的，应该是进程内存使用情况，比如进程的虚拟内存、常驻内存、共享内存以及 Swap 内存等。</p><ul><li>虚拟内存，包括了进程代码段、数据段、共享内存、已经申请的堆内存和已经换出的内存等。这里要注意，已经申请的内存，即使还没有分配物理内存，也算作虚拟内存。</li><li>常驻内存是进程实际使用的物理内存，不过，它不包括 Swap 和共享内存。</li><li>共享内存，既包括与其他进程共同使用的真实的共享内存，还包括了加载的动态链接库以及程序的代码段等。</li><li><p>Swap 内存，是指通过 Swap 换出到磁盘的内存。</p><p>当然，这些指标中，常驻内存一般会换算成占系统总内存的百分比，也就是进程的内存使用率。</p></li></ul></li><li><p>除了这些很容易想到的指标外，我还想再强调一下，缺页异常。</p><p> 在内存分配的原理中，我曾经讲到过，系统调用内存分配请求后，并不会立刻为其分配物理内存，而是在请求首次访问时，通过缺页异常来分配。缺页异常又分为下面两种场景。</p><ul><li>可以直接从物理内存中分配时，被称为次缺页异常。</li><li><p>需要磁盘 I/O 介入（比如 Swap）时，被称为主缺页异常。</p><p>显然，主缺页异常升高，就意味着需要磁盘 I/O，那么内存访问也会慢很多。</p></li></ul></li><li><p>除了系统内存和进程内存，第三类重要指标就是 Swap 的使用情况，比如 Swap 的已用空间、剩余空间、换入速度和换出速度等。</p><ul><li>已用空间和剩余空间很好理解，就是字面上的意思，已经使用和没有使用的内存空间。</li><li>换入和换出速度，则表示每秒钟换入和换出内存的大小。</li></ul></li></ol><p><img src="/images/《Linux性能优化实战》学习笔记/内存性能指标分析思维导图.png" alt="内存性能指标分析思维导图"></p><h4 id="21-2-内存性能工具"><a href="#21-2-内存性能工具" class="headerlink" title="21.2 内存性能工具"></a>21.2 内存性能工具</h4><ol><li><p>所有的案例中都用到了 free。这是个最常用的内存工具，可以查看系统的整体内存和 Swap 使用情况。相对应的，你可以用 top 或 ps，查看进程的内存使用情况。</p></li><li><p>在缓存和缓冲区的原理篇中，我们通过 proc 文件系统，找到了内存指标的来源；并通过 vmstat，动态观察了内存的变化情况。与 free 相比，vmstat 除了可以动态查看内存变化，还可以区分缓存和缓冲区、Swap 换入和换出的内存大小。</p></li><li><p>在缓存和缓冲区的案例篇中，为了弄清楚缓存的命中情况，我们又用了 cachestat ，查看整个系统缓存的读写命中情况，并用 cachetop 来观察每个进程缓存的读写命中情况。</p></li><li><p>在内存泄漏的案例中，我们用 vmstat，发现了内存使用在不断增长，又用 memleak，确认发生了内存泄漏。通过 memleak 给出的内存分配栈，我们找到了内存泄漏的可疑位置。</p></li><li><p>在 Swap 的案例中，我们用 sar 发现了缓冲区和 Swap 升高的问题。通过 cachetop，我们找到了缓冲区升高的根源；通过对比剩余内存跟 /proc/zoneinfo 的内存阈，我们发现 Swap 升高是内存回收导致的。案例最后，我们还通过 /proc 文件系统，找出了 Swap 所影响的进程。</p></li></ol><p>理解内存的工作原理，结合性能指标来记忆，拿下工具的使用方法并不难。</p><h4 id="21-3-性能指标和工具的联系"><a href="#21-3-性能指标和工具的联系" class="headerlink" title="21.3 性能指标和工具的联系"></a>21.3 性能指标和工具的联系</h4><p>同 CPU 性能分析一样，我的经验是两个不同维度出发，整理和记忆。</p><ul><li>从内存指标出发，更容易把工具和内存的工作原理关联起来。</li><li>从性能工具出发，可以更快地利用工具，找出我们想观察的性能指标。特别是在工具有限的情况下，我们更得充分利用手头的每一个工具，挖掘出更多的问题。</li></ul><ol><li><p>从内存指标出发，列举了哪些性能工具可以提供这些指标。这样，在实际排查性能问题时，你就可以清楚知道，究竟要用什么工具来辅助分析，提供你想要的指标。</p><p> <img src="/images/《Linux性能优化实战》学习笔记/根据指标找工具（内存性能）.png" alt="根据指标找工具（内存性能）"></p></li><li><p>从性能工具出发，整理了这些常见工具能提供的内存指标。掌握了这个表格，你可以最大化利用已有的工具，尽可能多地找到你要的指标。真正用到时， man 一下查它们的使用手册就可以了。</p><p> <img src="/images/《Linux性能优化实战》学习笔记/根据工具查指标（内存性能）.png" alt="根据工具查指标（内存性能）"></p></li></ol><h4 id="21-4-如何迅速分析内存的性能瓶颈"><a href="#21-4-如何迅速分析内存的性能瓶颈" class="headerlink" title="21.4 如何迅速分析内存的性能瓶颈"></a>21.4 如何迅速分析内存的性能瓶颈</h4><p>为了迅速定位内存问题，我通常会先运行几个覆盖面比较大的性能工具，比如 free、top、vmstat、pidstat 等。</p><p>具体的分析思路主要有这几步。</p><ul><li>先用 free 和 top，查看系统整体的内存使用情况。</li><li>再用 vmstat 和 pidstat，查看一段时间的趋势，从而判断出内存问题的类型。</li><li>最后进行详细分析，比如内存分配分析、缓存 / 缓冲区分析、具体进程的内存使用分析等。</li></ul><p><img src="/images/《Linux性能优化实战》学习笔记/如何迅速分析内存的性能瓶颈.png" alt="如何迅速分析内存的性能瓶颈"></p><p>举几个例子你可能会更容易理解。</p><ol><li><p>当你通过 free，发现大部分内存都被缓存占用后，可以使用 vmstat 或者 sar 观察一下缓存的变化趋势，确认缓存的使用是否还在继续增大。</p><p> 如果继续增大，则说明导致缓存升高的进程还在运行，那你就能用缓存 / 缓冲区分析工具（比如 cachetop、slabtop 等），分析这些缓存到底被哪里占用。</p></li><li><p>当你 free 一下，发现系统可用内存不足时，首先要确认内存是否被缓存 / 缓冲区占用。排除缓存 / 缓冲区后，你可以继续用 pidstat 或者 top，定位占用内存最多的进程。</p><p> 找出进程后，再通过进程内存空间工具（比如 pmap），分析进程地址空间中内存的使用情况就可以了。</p></li><li><p>当你通过 vmstat 或者 sar 发现内存在不断增长后，可以分析中是否存在内存泄漏的问题。</p><p> 比如你可以使用内存分配分析工具 memleak ，检查是否存在内存泄漏。如果存在内存泄漏问题，memleak 会为你输出内存泄漏的进程以及调用堆栈。</p></li></ol><p>注意，这个图里我没有列出所有性能工具，只给出了最核心的几个。这么做，一方面，确实不想让大量的工具列表吓到你。</p><p>另一方面，希望你能把重心先放在核心工具上，通过我提供的案例和真实环境的实践，掌握使用方法和分析思路。 毕竟熟练掌握它们，你就可以解决大多数的内存问题。</p><h4 id="21-5-小结"><a href="#21-5-小结" class="headerlink" title="21.5 小结"></a>21.5 小结</h4><p>找到内存问题的来源后，下一步就是相应的优化工作了。在我看来，内存调优最重要的就是，保证应用程序的热点数据放到内存中，并尽量减少换页和交换。</p><p>常见的优化思路有这么几种。</p><ol><li>最好禁止 Swap。如果必须开启 Swap，降低 swappiness 的值，减少内存回收时 Swap 的使用倾向。</li><li>减少内存的动态分配。比如，可以使用内存池、大页（HugePage）等。</li><li>尽量使用缓存和缓冲区来访问数据。比如，可以使用堆栈明确声明内存空间，来存储需要缓存的数据；或者用 Redis 这类的外部缓存组件，优化数据的访问。</li><li>使用 cgroups 等方式限制进程的内存使用情况。这样，可以确保系统内存不会被异常进程耗尽。</li><li>通过 /proc/pid/oom_adj ，调整核心应用的 oom_score。这样，可以保证即使内存紧张，核心应用也不会被 OOM 杀死。</li></ol><h3 id="22-答疑（三）：文件系统与磁盘的区别是什么？"><a href="#22-答疑（三）：文件系统与磁盘的区别是什么？" class="headerlink" title="22 | 答疑（三）：文件系统与磁盘的区别是什么？"></a>22 | 答疑（三）：文件系统与磁盘的区别是什么？</h3><h4 id="22-1-问题-1：内存回收与-OOM"><a href="#22-1-问题-1：内存回收与-OOM" class="headerlink" title="22.1 问题 1：内存回收与 OOM"></a>22.1 问题 1：内存回收与 OOM</h4><p>虎虎的这个问题，实际上包括四个子问题，即，</p><ol><li>怎么理解 LRU 内存回收？</li><li>回收后的内存又到哪里去了？</li><li>OOM 是按照虚拟内存还是实际内存来打分？</li><li>怎么估计应用程序的最小内存？</li></ol><p>一旦发现内存紧张，系统会通过三种方式回收内存。</p><ul><li>基于 LRU（Least Recently Used）算法，回收缓存；</li><li>基于 Swap 机制，回收不常访问的匿名页；</li><li>基于 OOM（Out of Memory）机制，杀掉占用大量内存的进程。</li></ul><p>前两种方式，缓存回收和 Swap 回收，实际上都是基于 LRU 算法，也就是优先回收不常访问的内存。LRU 回收算法，实际上维护着 active 和 inactive 两个双向链表，其中：</p><ul><li>active 记录活跃的内存页；</li><li>inactive 记录非活跃的内存页。</li></ul><p>越接近链表尾部，就表示内存页越不常访问。这样，在回收内存时，系统就可以根据活跃程度，优先回收不活跃的内存。</p><p>活跃和非活跃的内存页，按照类型的不同，又分别分为文件页和匿名页，对应着缓存回收和 Swap 回收。</p><p>当然，你可以从 /proc/meminfo 中，查询它们的大小，比如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># grep 表示只保留包含 active 的指标（忽略大小写）</span><span class="token comment"># sort 表示按照字母顺序排序</span>$ <span class="token function">cat</span> /proc/meminfo <span class="token operator">|</span> <span class="token function">grep</span> -i active <span class="token operator">|</span> <span class="token function">sort</span>Active<span class="token punctuation">(</span>anon<span class="token punctuation">)</span>:     <span class="token number">167976</span> kBActive<span class="token punctuation">(</span>file<span class="token punctuation">)</span>:     <span class="token number">971488</span> kBActive:          <span class="token number">1139464</span> kBInactive<span class="token punctuation">(</span>anon<span class="token punctuation">)</span>:      <span class="token number">720</span> kBInactive<span class="token punctuation">(</span>file<span class="token punctuation">)</span>:  <span class="token number">2109536</span> kBInactive:        <span class="token number">2110256</span> kB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第三种方式，OOM 机制按照 oom_score 给进程排序。oom_score 越大，进程就越容易被系统杀死。</p><p>当系统发现内存不足以分配新的内存请求时，就会尝试直接内存回收。这种情况下，如果回收完文件页和匿名页后，内存够用了，当然皆大欢喜，把回收回来的内存分配给进程就可以了。但如果内存还是不足，OOM 就要登场了。</p><p>OOM 发生时，你可以在 dmesg 中看到 Out of memory 的信息，从而知道是哪些进程被 OOM 杀死了。比如，你可以执行下面的命令，查询 OOM 日志：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">dmesg</span> <span class="token operator">|</span> <span class="token function">grep</span> -i <span class="token string">"Out of memory"</span>Out of memory: Kill process <span class="token number">9329</span> <span class="token punctuation">(</span>java<span class="token punctuation">)</span> score <span class="token number">321</span> or sacrifice child<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当然了，如果你不希望应用程序被 OOM 杀死，可以调整进程的 oom_score_adj，减小 OOM 分值，进而降低被杀死的概率。或者，你还可以开启内存的 overcommit，允许进程申请超过物理内存的虚拟内存（这儿实际上假设的是，进程不会用光申请到的虚拟内存）。</p><p>这三种方式，我们就复习完了。接下来，我们回到开始的四个问题，相信你自己已经有了答案。</p><ol><li>LRU 算法的原理刚才已经提到了，这里不再重复。</li><li>内存回收后，会被重新放到未使用内存中。这样，新的进程就可以请求、使用它们。</li><li>OOM 触发的时机基于虚拟内存。换句话说，进程在申请内存时，如果申请的虚拟内存加上服务器实际已用的内存之和，比总的物理内存还大，就会触发 OOM。</li><li>要确定一个进程或者容器的最小内存，最简单的方法就是让它运行起来，再通过 ps 或者 smap ，查看它的内存使用情况。不过要注意，进程刚启动时，可能还没开始处理实际业务，一旦开始处理实际业务，就会占用更多内存。所以，要记得给内存留一定的余量。</li></ol><h4 id="22-2-问题-2-文件系统与磁盘的区别"><a href="#22-2-问题-2-文件系统与磁盘的区别" class="headerlink" title="22.2 问题 2: 文件系统与磁盘的区别"></a>22.2 问题 2: 文件系统与磁盘的区别</h4><p>在学习 Buffer 和 Cache 的原理时，我曾提到，Buffer 用于磁盘，而 Cache 用于文件。因此，有不少同学困惑了，比如 JJ 留言中的这两个问题。</p><ul><li>读写文件最终也是读写磁盘，到底要怎么区分，是读写文件还是读写磁盘呢？</li><li>读写磁盘难道可以不经过文件系统吗？</li></ul><p>磁盘是一个存储设备（确切地说是块设备），可以被划分为不同的磁盘分区。而在磁盘或者磁盘分区上，还可以再创建文件系统，并挂载到系统的某个目录中。这样，系统就可以通过这个挂载目录，来读写文件。</p><p>换句话说，磁盘是存储数据的块设备，也是文件系统的载体。所以，文件系统确实还是要通过磁盘，来保证数据的持久化存储。</p><p>你在很多地方都会看到这句话， Linux 中一切皆文件。换句话说，你可以通过相同的文件接口，来访问磁盘和文件（比如 open、read、write、close 等）。</p><ul><li>我们通常说的“文件”，其实是指普通文件。</li><li>而磁盘或者分区，则是指块设备文件。</li></ul><p>你可以执行 “ls -l &lt; 路径 &gt;” 查看它们的区别。如果不懂 ls 输出的含义，别忘了 man 一下就可以。执行 man ls 命令，以及 info ‘(coreutils) ls invocation’ 命令，就可以查到了。</p><p>在读写普通文件时，I/O 请求会首先经过文件系统，然后由文件系统负责，来与磁盘进行交互。而在读写块设备文件时，会跳过文件系统，直接与磁盘交互，也就是所谓的“裸 I/O”。</p><p>这两种读写方式使用的缓存自然不同。文件系统管理的缓存，其实就是 Cache 的一部分。而裸磁盘的缓存，用的正是 Buffer。</p><h4 id="22-3-问题-3-如何统计所有进程的物理内存使用量"><a href="#22-3-问题-3-如何统计所有进程的物理内存使用量" class="headerlink" title="22.3 问题 3: 如何统计所有进程的物理内存使用量"></a>22.3 问题 3: 如何统计所有进程的物理内存使用量</h4><p>把所有进程的 RSS 全部累加这种方法，实际上导致不少地方会被重复计算。RSS 表示常驻内存，把进程用到的共享内存也算了进去。所以，直接累加会导致共享内存被重复计算，不能得到准确的答案。</p><p>可以通过 stackexchange 上的<a href="https://unix.stackexchange.com/questions/33381/getting-information-about-a-process-memory-usage-from-proc-pid-smaps">链接</a>找到答案，不过，我还是更推荐，直接查 proc 文件系统的文档：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">The “proportional set size” (PSS) of a process is the count of pages it has in memory, where each page is divided by the number of processes sharing it. So if a process has 1000 pages all to itself, and 1000 shared with one other process, its PSS will be 1500.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解释一下，每个进程的 PSS ，是指把共享内存平分到各个进程后，再加上进程本身的非共享内存大小的和。</p><p>就像文档中的这个例子，一个进程的非共享内存为 1000 页，它和另一个进程的共享进程也是 1000 页，那么它的 PSS=1000/2+1000=1500 页。</p><p>这样，你就可以直接累加 PSS ，不用担心共享内存重复计算的问题了。</p><p>比如，你可以运行下面的命令来计算：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 使用 grep 查找 Pss 指标后，再用 awk 计算累加值</span>$ <span class="token function">grep</span> Pss /proc/<span class="token punctuation">[</span><span class="token number">1</span>-9<span class="token punctuation">]</span>*/smaps <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{total+=<span class="token variable">$2</span>}; END {printf "%d kB<span class="token entity" title="\n">\n</span>", total }'</span><span class="token number">391266</span> kB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="22-4-问题-4-CentOS-系统中如何安装-bcc-tools"><a href="#22-4-问题-4-CentOS-系统中如何安装-bcc-tools" class="headerlink" title="22.4 问题 4: CentOS 系统中如何安装 bcc-tools"></a>22.4 问题 4: CentOS 系统中如何安装 bcc-tools</h4><p>以 CentOS 7 为例，整个安装主要可以分两步。</p><p>第一步，升级内核。你可以运行下面的命令来操作：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 升级系统</span>yum update -y<span class="token comment"># 安装 ELRepo</span><span class="token function">rpm</span> --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org<span class="token function">rpm</span> -Uvh https://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm<span class="token comment"># 安装新内核</span>yum remove -y kernel-headers kernel-tools kernel-tools-libsyum --enablerepo<span class="token operator">=</span><span class="token string">"elrepo-kernel"</span> <span class="token function">install</span> -y kernel-ml kernel-ml-devel kernel-ml-headers kernel-ml-tools kernel-ml-tools-libs kernel-ml-tools-libs-devel<span class="token comment"># 更新 Grub 后重启</span>grub2-mkconfig -o /boot/grub2/grub.cfggrub2-set-default <span class="token number">0</span><span class="token function">reboot</span><span class="token comment"># 重启后确认内核版本已升级为 4.20.0-1.el7.elrepo.x86_64</span><span class="token function">uname</span> -r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二步，安装 bcc-tools：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 安装 bcc-tools</span>yum <span class="token function">install</span> -y bcc-tools<span class="token comment"># 配置 PATH 路径</span><span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span>:/usr/share/bcc/tools<span class="token comment"># 验证安装成功</span>cachestat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="22-5-问题-5-内存泄漏案例的优化方法"><a href="#22-5-问题-5-内存泄漏案例的优化方法" class="headerlink" title="22.5 问题 5: 内存泄漏案例的优化方法"></a>22.5 问题 5: 内存泄漏案例的优化方法</h4><p>这是我在 <a href="https://time.geekbang.org/column/article/75670">内存泄漏了，我该如何定位和处理</a> 中留的一个思考题。这个问题是这样的：</p><p>在内存泄漏案例的最后，我们通过增加 free() 调用，释放了函数 fibonacci() 分配的内存，修复了内存泄漏的问题。就这个案例而言，还有没有其他更好的修复方法呢？</p><p>很多同学留言写下了自己的想法，都很不错。这里，我重点表扬下郭江伟同学，他给出的方法非常好：</p><p>他的思路是不用动态内存分配的方法，而是用数组来暂存计算结果。这样就可以由系统自动管理这些栈内存，也不存在内存泄漏的问题了。</p><p>这种减少动态内存分配的思路，除了可以解决内存泄漏问题，其实也是常用的内存优化方法。比如，在需要大量内存的场景中，你就可以考虑用栈内存、内存池、HugePage 等方法，来优化内存的分配和管理。</p><h2 id="04-I-O-性能篇"><a href="#04-I-O-性能篇" class="headerlink" title="04-I-O 性能篇"></a><strong>04-I-O 性能篇</strong></h2><h3 id="23-基础篇：Linux-文件系统是怎么工作的？"><a href="#23-基础篇：Linux-文件系统是怎么工作的？" class="headerlink" title="23 | 基础篇：Linux 文件系统是怎么工作的？"></a>23 | 基础篇：Linux 文件系统是怎么工作的？</h3><h4 id="23-1-索引节点和目录项"><a href="#23-1-索引节点和目录项" class="headerlink" title="23.1 索引节点和目录项"></a>23.1 索引节点和目录项</h4><p>文件系统，本身是对存储设备上的文件，进行组织管理的机制。组织方式不同，就会形成不同的文件系统。</p><p>你要记住最重要的一点，在 Linux 中一切皆文件。不仅普通的文件和目录，就连块设备、套接字、管道等，也都要通过统一的文件系统来管理。</p><p>为了方便管理，Linux 文件系统为每个文件都分配两个数据结构，索引节点（index node）和目录项（directory entry）。它们主要用来记录文件的元信息和目录结构。</p><ul><li>索引节点，简称为 inode，用来记录文件的元数据，比如 inode 编号、文件大小、访问权限、修改日期、数据的位置等。索引节点和文件一一对应，它跟文件内容一样，都会被持久化存储到磁盘中。所以记住，索引节点同样占用磁盘空间。</li><li>目录项，简称为 dentry，用来记录文件的名字、索引节点指针以及与其他目录项的关联关系。多个关联的目录项，就构成了文件系统的目录结构。不过，不同于索引节点，目录项是由内核维护的一个内存数据结构，所以通常也被叫做目录项缓存。</li></ul><p>换句话说，索引节点是每个文件的唯一标志，而目录项维护的正是文件系统的树状结构。目录项和索引节点的关系是多对一，你可以简单理解为，一个文件可以有多个别名。</p><p>举个例子，通过硬链接为文件创建的别名，就会对应不同的目录项，不过这些目录项本质上还是链接同一个文件，所以，它们的索引节点相同。</p><p>索引节点和目录项纪录了文件的元数据，以及文件间的目录关系，那么具体来说，文件数据到底是怎么存储的呢？是不是直接写到磁盘中就好了呢？</p><p>实际上，磁盘读写的最小单位是扇区，然而扇区只有 512B 大小，如果每次都读写这么小的单位，效率一定很低。所以，文件系统又把连续的扇区组成了逻辑块，然后每次都以逻辑块为最小单元，来管理数据。常见的逻辑块大小为 4KB，也就是由连续的 8 个扇区组成。</p><p>为了帮助你理解目录项、索引节点以及文件数据的关系，我画了一张示意图。你可以对照着这张图，来回忆刚刚讲过的内容，把知识和细节串联起来。</p><p><img src="/images/《Linux性能优化实战》学习笔记/目录项、索引节点以及文件数据的关系.png" alt="目录项、索引节点以及文件数据的关系"></p><p>不过，这里有两点需要你注意。</p><ol><li><p>第一，目录项本身就是一个内存缓存，而索引节点则是存储在磁盘中的数据。在前面的 Buffer 和 Cache 原理中，我曾经提到过，为了协调慢速磁盘与快速 CPU 的性能差异，文件内容会缓存到页缓存 Cache 中。</p><p> 那么，你应该想到，这些索引节点自然也会缓存到内存中，加速文件的访问。</p></li><li><p>第二，磁盘在执行文件系统格式化时，会被分成三个存储区域，超级块、索引节点区和数据块区。其中，</p><ul><li>超级块，存储整个文件系统的状态。</li><li>索引节点区，用来存储索引节点。</li><li>数据块区，则用来存储文件数据。</li></ul></li></ol><h4 id="23-2-虚拟文件系统"><a href="#23-2-虚拟文件系统" class="headerlink" title="23.2 虚拟文件系统"></a>23.2 虚拟文件系统</h4><p>目录项、索引节点、逻辑块以及超级块，构成了 Linux 文件系统的四大基本要素。不过，为了支持各种不同的文件系统，Linux 内核在用户进程和文件系统的中间，又引入了一个抽象层，也就是虚拟文件系统 VFS（Virtual File System）。</p><p>VFS 定义了一组所有文件系统都支持的数据结构和标准接口。这样，用户进程和内核中的其他子系统，只需要跟 VFS 提供的统一接口进行交互就可以了，而不需要再关心底层各种文件系统的实现细节。</p><p>这里，我画了一张 Linux 文件系统的架构图，帮你更好地理解系统调用、VFS、缓存、文件系统以及块存储之间的关系。</p><p><img src="/images/《Linux性能优化实战》学习笔记/Linux文件系统的架构图.png" alt="Linux文件系统的架构图"></p><p>通过这张图，你可以看到，在 VFS 的下方，Linux 支持各种各样的文件系统，如 Ext4、XFS、NFS 等等。按照存储位置的不同，这些文件系统可以分为三类。</p><ol><li>第一类是基于磁盘的文件系统，也就是把数据直接存储在计算机本地挂载的磁盘中。常见的 Ext4、XFS、OverlayFS 等，都是这类文件系统。</li><li>第二类是基于内存的文件系统，也就是我们常说的虚拟文件系统。这类文件系统，不需要任何磁盘分配存储空间，但会占用内存。我们经常用到的 /proc 文件系统，其实就是一种最常见的虚拟文件系统。此外，/sys 文件系统也属于这一类，主要向用户空间导出层次化的内核对象。</li><li>第三类是网络文件系统，也就是用来访问其他计算机数据的文件系统，比如 NFS、SMB、iSCSI 等。</li></ol><p>这些文件系统，要先挂载到 VFS 目录树中的某个子目录（称为挂载点），然后才能访问其中的文件。拿第一类，也就是基于磁盘的文件系统为例，在安装系统时，要先挂载一个根目录（/），在根目录下再把其他文件系统（比如其他的磁盘分区、/proc 文件系统、/sys 文件系统、NFS 等）挂载进来。</p><h4 id="23-3-文件系统-I-O"><a href="#23-3-文件系统-I-O" class="headerlink" title="23.3 文件系统 I/O"></a>23.3 文件系统 I/O</h4><p>把文件系统挂载到挂载点后，你就能通过挂载点，再去访问它管理的文件了。VFS 提供了一组标准的文件访问接口。这些接口以系统调用的方式，提供给应用程序使用。</p><p>就拿 cat 命令来说，它首先调用 open() ，打开一个文件；然后调用 read() ，读取文件的内容；最后再调用 write() ，把文件内容输出到控制台的标准输出中：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">int open<span class="token punctuation">(</span>const char *pathname, int flags, mode_t mode<span class="token punctuation">)</span><span class="token punctuation">;</span>ssize_t read<span class="token punctuation">(</span>int fd, void *buf, size_t count<span class="token punctuation">)</span><span class="token punctuation">;</span>ssize_t write<span class="token punctuation">(</span>int fd, const void *buf, size_t count<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>文件读写方式的各种差异，导致 I/O 的分类多种多样。最常见的有，缓冲与非缓冲 I/O、直接与非直接 I/O、阻塞与非阻塞 I/O、同步与异步 I/O 等。 接下来，我们就详细看这四种分类。</p><ol><li><p>第一种，根据是否利用标准库缓存，可以把文件 I/O 分为缓冲 I/O 与非缓冲 I/O。</p><ul><li>缓冲 I/O，是指利用标准库缓存来加速文件的访问，而标准库内部再通过系统调度访问文件。</li><li><p>非缓冲 I/O，是指直接通过系统调用来访问文件，不再经过标准库缓存。</p><p>注意，这里所说的“缓冲”，是指标准库内部实现的缓存。比方说，你可能见到过，很多程序遇到换行时才真正输出，而换行前的内容，其实就是被标准库暂时缓存了起来。</p><p>无论缓冲 I/O 还是非缓冲 I/O，它们最终还是要经过系统调用来访问文件。而根据上一节内容，我们知道，系统调用后，还会通过页缓存，来减少磁盘的 I/O 操作。</p></li></ul></li><li><p>第二，根据是否利用操作系统的页缓存，可以把文件 I/O 分为直接 I/O 与非直接 I/O。</p><ul><li>直接 I/O，是指跳过操作系统的页缓存，直接跟文件系统交互来访问文件。</li><li><p>非直接 I/O 正好相反，文件读写时，先要经过系统的页缓存，然后再由内核或额外的系统调用，真正写入磁盘。</p><p>想要实现直接 I/O，需要你在系统调用中，指定 O_DIRECT 标志。如果没有设置过，默认的是非直接 I/O。</p><p>不过要注意，直接 I/O、非直接 I/O，本质上还是和文件系统交互。如果是在数据库等场景中，你还会看到，跳过文件系统读写磁盘的情况，也就是我们通常所说的裸 I/O。</p></li></ul></li><li><p>第三，根据应用程序是否阻塞自身运行，可以把文件 I/O 分为阻塞 I/O 和非阻塞 I/O：</p><ul><li>所谓阻塞 I/O，是指应用程序执行 I/O 操作后，如果没有获得响应，就会阻塞当前线程，自然就不能执行其他任务。</li><li><p>所谓非阻塞 I/O，是指应用程序执行 I/O 操作后，不会阻塞当前的线程，可以继续执行其他的任务，随后再通过轮询或者事件通知的形式，获取调用的结果。</p><p>比方说，访问管道或者网络套接字时，设置 O_NONBLOCK 标志，就表示用非阻塞方式访问；而如果不做任何设置，默认的就是阻塞访问。</p></li></ul></li><li><p>第四，根据是否等待响应结果，可以把文件 I/O 分为同步和异步 I/O：</p><ul><li>所谓同步 I/O，是指应用程序执行 I/O 操作后，要一直等到整个 I/O 完成后，才能获得 I/O 响应。</li><li><p>所谓异步 I/O，是指应用程序执行 I/O 操作后，不用等待完成和完成后的响应，而是继续执行就可以。等到这次 I/O 完成后，响应会用事件通知的方式，告诉应用程序。</p><p>举个例子，在操作文件时，如果你设置了 O_SYNC 或者 O_DSYNC 标志，就代表同步 I/O。如果设置了 O_DSYNC，就要等文件数据写入磁盘后，才能返回；而 O_SYNC，则是在 O_DSYNC 基础上，要求文件元数据也要写入磁盘后，才能返回。</p><p>再比如，在访问管道或者网络套接字时，设置了 O_ASYNC 选项后，相应的 I/O 就是异步 I/O。这样，内核会再通过 SIGIO 或者 SIGPOLL，来通知进程文件是否可读写。</p></li></ul></li></ol><p>你也应该可以理解，“Linux 一切皆文件”的深刻含义。无论是普通文件和块设备、还是网络套接字和管道等，它们都通过统一的 VFS 接口来访问。</p><h4 id="23-4-性能观测"><a href="#23-4-性能观测" class="headerlink" title="23.4 性能观测"></a>23.4 性能观测</h4><p>观察一下文件系统的性能情况。</p><ol><li><p>容量。</p><p> 对文件系统来说，最常见的一个问题就是空间不足。当然，你可能本身就知道，用 df 命令，就能查看文件系统的磁盘空间使用情况。比如：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">df</span> /dev/sda1Filesystem     1K-blocks    Used Available Use% Mounted on/dev/sda1       <span class="token number">30308240</span> <span class="token number">3167020</span>  <span class="token number">27124836</span>  <span class="token number">11</span>% /<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 你可以看到，我的根文件系统只使用了 11% 的空间。这里还要注意，总空间用 1K-blocks 的数量来表示，你可以给 df 加上 -h 选项，以获得更好的可读性：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">df</span> -h /dev/sda1Filesystem      Size  Used Avail Use% Mounted on/dev/sda1        29G  <span class="token number">3</span>.1G   26G  <span class="token number">11</span>% /<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 不过有时候，明明你碰到了空间不足的问题，可是用 df 查看磁盘空间后，却发现剩余空间还有很多。这是怎么回事呢？</p><p> 不知道你还记不记得，刚才我强调的一个细节。除了文件数据，索引节点也占用磁盘空间。你可以给 df 命令加上 -i 参数，查看索引节点的使用情况，如下所示：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">df</span> -i /dev/sda1Filesystem      Inodes  IUsed   IFree IUse% Mounted on/dev/sda1      <span class="token number">3870720</span> <span class="token number">157460</span> <span class="token number">3713260</span>    <span class="token number">5</span>% /<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 索引节点的容量，（也就是 Inode 个数）是在格式化磁盘时设定好的，一般由格式化工具自动生成。当你发现索引节点空间不足，但磁盘空间充足时，很可能就是过多小文件导致的。</p><p> 所以，一般来说，删除这些小文件，或者把它们移动到索引节点充足的其他磁盘中，就可以解决这个问题。</p></li><li><p>缓存</p><p> free 输出的 Cache，是页缓存和可回收 Slab 缓存的和，你可以从 /proc/meminfo ，直接得到它们的大小：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> /proc/meminfo <span class="token operator">|</span> <span class="token function">grep</span> -E <span class="token string">"SReclaimable|Cached"</span>Cached:           <span class="token number">748316</span> kBSwapCached:            <span class="token number">0</span> kBSReclaimable:     <span class="token number">179508</span> kB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 话说回来，文件系统中的目录项和索引节点缓存，又该如何观察呢？</p><p> 实际上，内核使用 Slab 机制，管理目录项和索引节点的缓存。/proc/meminfo 只给出了 Slab 的整体大小，具体到每一种 Slab 缓存，还要查看 /proc/slabinfo 这个文件。</p><p> 比如，运行下面的命令，你就可以得到，所有目录项和各种文件系统索引节点的缓存情况：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> /proc/slabinfo <span class="token operator">|</span> <span class="token function">grep</span> -E <span class="token string">'^#|dentry|inode'</span><span class="token comment"># name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;limit&gt; &lt;batchcount&gt; &lt;sharedfactor&gt; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt;     &lt;sharedavail&gt;</span>xfs_inode              <span class="token number">0</span>      <span class="token number">0</span>    <span class="token number">960</span>   <span class="token number">17</span>    <span class="token number">4</span> <span class="token builtin class-name">:</span> tunables    <span class="token number">0</span>    <span class="token number">0</span>    <span class="token number">0</span> <span class="token builtin class-name">:</span> slabdata      <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span><span class="token punctuation">..</span>.ext4_inode_cache   <span class="token number">32104</span>  <span class="token number">34590</span>   <span class="token number">1088</span>   <span class="token number">15</span>    <span class="token number">4</span> <span class="token builtin class-name">:</span> tunables    <span class="token number">0</span>    <span class="token number">0</span>    <span class="token number">0</span> <span class="token builtin class-name">:</span> slabdata   <span class="token number">2306</span>   <span class="token number">2306</span>      0hugetlbfs_inode_cache     <span class="token number">13</span>     <span class="token number">13</span>    <span class="token number">624</span>   <span class="token number">13</span>    <span class="token number">2</span> <span class="token builtin class-name">:</span> tunables        <span class="token number">0</span>    <span class="token number">0</span>    <span class="token number">0</span> <span class="token builtin class-name">:</span> slabdata      <span class="token number">1</span>      <span class="token number">1</span>      <span class="token number">0</span>sock_inode_cache    <span class="token number">1190</span>   <span class="token number">1242</span>    <span class="token number">704</span>   <span class="token number">23</span>    <span class="token number">4</span> <span class="token builtin class-name">:</span> tunables    <span class="token number">0</span>    <span class="token number">0</span>    <span class="token number">0</span> <span class="token builtin class-name">:</span> slabdata     <span class="token number">54</span>     <span class="token number">54</span>      <span class="token number">0</span>shmem_inode_cache   <span class="token number">1622</span>   <span class="token number">2139</span>    <span class="token number">712</span>   <span class="token number">23</span>    <span class="token number">4</span> <span class="token builtin class-name">:</span> tunables    <span class="token number">0</span>    <span class="token number">0</span>    <span class="token number">0</span> <span class="token builtin class-name">:</span> slabdata     <span class="token number">93</span>     <span class="token number">93</span>      <span class="token number">0</span>proc_inode_cache    <span class="token number">3560</span>   <span class="token number">4080</span>    <span class="token number">680</span>   <span class="token number">12</span>    <span class="token number">2</span> <span class="token builtin class-name">:</span> tunables    <span class="token number">0</span>    <span class="token number">0</span>    <span class="token number">0</span> <span class="token builtin class-name">:</span> slabdata    <span class="token number">340</span>    <span class="token number">340</span>      <span class="token number">0</span>inode_cache        <span class="token number">25172</span>  <span class="token number">25818</span>    <span class="token number">608</span>   <span class="token number">13</span>    <span class="token number">2</span> <span class="token builtin class-name">:</span> tunables    <span class="token number">0</span>    <span class="token number">0</span>    <span class="token number">0</span> <span class="token builtin class-name">:</span> slabdata   <span class="token number">1986</span>   <span class="token number">1986</span>      <span class="token number">0</span>dentry             <span class="token number">76050</span> <span class="token number">121296</span>    <span class="token number">192</span>   <span class="token number">21</span>    <span class="token number">1</span> <span class="token builtin class-name">:</span> tunables    <span class="token number">0</span>    <span class="token number">0</span>    <span class="token number">0</span> <span class="token builtin class-name">:</span> slabdata   <span class="token number">5776</span>   <span class="token number">5776</span>      <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 这个界面中，dentry 行表示目录项缓存，inode_cache 行，表示 VFS 索引节点缓存，其余的则是各种文件系统的索引节点缓存。</p><p> /proc/slabinfo 的列比较多，具体含义你可以查询 man slabinfo。在实际性能分析中，我们更常使用 slabtop ，来找到占用内存最多的缓存类型。</p><p> 比如，下面就是我运行 slabtop 得到的结果：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 按下 c 按照缓存大小排序，按下 a 按照活跃对象数排序</span>$ slabtopActive / Total Objects <span class="token punctuation">(</span>% used<span class="token punctuation">)</span>    <span class="token builtin class-name">:</span> <span class="token number">277970</span> / <span class="token number">358914</span> <span class="token punctuation">(</span><span class="token number">77.4</span>%<span class="token punctuation">)</span>Active / Total Slabs <span class="token punctuation">(</span>% used<span class="token punctuation">)</span>      <span class="token builtin class-name">:</span> <span class="token number">12414</span> / <span class="token number">12414</span> <span class="token punctuation">(</span><span class="token number">100.0</span>%<span class="token punctuation">)</span>Active / Total Caches <span class="token punctuation">(</span>% used<span class="token punctuation">)</span>     <span class="token builtin class-name">:</span> <span class="token number">83</span> / <span class="token number">135</span> <span class="token punctuation">(</span><span class="token number">61.5</span>%<span class="token punctuation">)</span>Active / Total Size <span class="token punctuation">(</span>% used<span class="token punctuation">)</span>       <span class="token builtin class-name">:</span> <span class="token number">57816</span>.88K / <span class="token number">73307</span>.70K <span class="token punctuation">(</span><span class="token number">78.9</span>%<span class="token punctuation">)</span>Minimum / Average / Maximum Object <span class="token builtin class-name">:</span> <span class="token number">0</span>.01K / <span class="token number">0</span>.20K / <span class="token number">22</span>.88K OBJS ACTIVE  USE OBJ SIZE  SLABS OBJ/SLAB CACHE SIZE NAME<span class="token number">69804</span>  <span class="token number">23094</span>   <span class="token number">0</span>%    <span class="token number">0</span>.19K   <span class="token number">3324</span>       <span class="token number">21</span>     13296K dentry<span class="token number">16380</span>  <span class="token number">15854</span>   <span class="token number">0</span>%    <span class="token number">0</span>.59K   <span class="token number">1260</span>       <span class="token number">13</span>     10080K inode_cache<span class="token number">58260</span>  <span class="token number">55397</span>   <span class="token number">0</span>%    <span class="token number">0</span>.13K   <span class="token number">1942</span>       <span class="token number">30</span>      7768K kernfs_node_cache  <span class="token number">485</span>    <span class="token number">413</span>   <span class="token number">0</span>%    <span class="token number">5</span>.69K     <span class="token number">97</span>        <span class="token number">5</span>      3104K task_struct <span class="token number">1472</span>   <span class="token number">1397</span>   <span class="token number">0</span>%    <span class="token number">2</span>.00K     <span class="token number">92</span>       <span class="token number">16</span>      2944K kmalloc-2048<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 从这个结果你可以看到，在我的系统中，目录项和索引节点占用了最多的 Slab 缓存。不过它们占用的内存其实并不大，加起来也只有 23MB 左右。</p></li></ol><h3 id="24-基础篇：Linux-磁盘I-O是怎么工作的（上）"><a href="#24-基础篇：Linux-磁盘I-O是怎么工作的（上）" class="headerlink" title="24 | 基础篇：Linux 磁盘I/O是怎么工作的（上）"></a>24 | 基础篇：Linux 磁盘I/O是怎么工作的（上）</h3><p>回顾一下，文件系统是对存储设备上的文件，进行组织管理的一种机制。而 Linux 在各种文件系统实现上，又抽象了一层虚拟文件系统 VFS，它定义了一组，所有文件系统都支持的，数据结构和标准接口。</p><p>这样，对应用程序来说，只需要跟 VFS 提供的统一接口交互，而不需要关注文件系统的具体实现；对具体的文件系统来说，只需要按照 VFS 的标准，就可以无缝支持各种应用程序。</p><p>VFS 内部又通过目录项、索引节点、逻辑块以及超级块等数据结构，来管理文件。</p><ul><li>目录项，记录了文件的名字，以及文件与其他目录项之间的目录关系。</li><li>索引节点，记录了文件的元数据。</li><li>逻辑块，是由连续磁盘扇区构成的最小读写单元，用来存储文件数据。</li><li>超级块，用来记录文件系统整体的状态，如索引节点和逻辑块的使用情况等。</li></ul><p>其中，目录项是一个内存缓存；而超级块、索引节点和逻辑块，都是存储在磁盘中的持久化数据。</p><p>接下来，我就带你一起看看， Linux 磁盘 I/O 的工作原理。</p><h4 id="24-1-磁盘"><a href="#24-1-磁盘" class="headerlink" title="24.1 磁盘"></a>24.1 磁盘</h4><p>磁盘是可以持久化存储的设备，根据存储介质的不同，常见磁盘可以分为两类：机械磁盘和固态磁盘。</p><p>第一类，机械磁盘，也称为硬盘驱动器（Hard Disk Driver），通常缩写为 HDD。机械磁盘主要由盘片和读写磁头组成，数据就存储在盘片的环状磁道中。在读写数据前，需要移动读写磁头，定位到数据所在的磁道，然后才能访问数据。</p><p>显然，如果 I/O 请求刚好连续，那就不需要磁道寻址，自然可以获得最佳性能。这其实就是我们熟悉的，连续 I/O 的工作原理。与之相对应的，当然就是随机 I/O，它需要不停地移动磁头，来定位数据位置，所以读写速度就会比较慢。</p><p>第二类，固态磁盘（Solid State Disk），通常缩写为 SSD，由固态电子元器件组成。固态磁盘不需要磁道寻址，所以，不管是连续 I/O，还是随机 I/O 的性能，都比机械磁盘要好得多。</p><p>其实，无论机械磁盘，还是固态磁盘，相同磁盘的随机 I/O 都要比连续 I/O 慢很多，原因也很明显。</p><ul><li>对机械磁盘来说，我们刚刚提到过的，由于随机 I/O 需要更多的磁头寻道和盘片旋转，它的性能自然要比连续 I/O 慢。</li><li>而对固态磁盘来说，虽然它的随机性能比机械硬盘好很多，但同样存在“先擦除再写入”的限制。随机读写会导致大量的垃圾回收，所以相对应的，随机 I/O 的性能比起连续 I/O 来，也还是差了很多。</li><li>此外，连续 I/O 还可以通过预读的方式，来减少 I/O 请求的次数，这也是其性能优异的一个原因。很多性能优化的方案，也都会从这个角度出发，来优化 I/O 性能。</li></ul><p>此外，机械磁盘和固态磁盘还分别有一个最小的读写单位。</p><ul><li>机械磁盘的最小读写单位是扇区，一般大小为 512 字节。</li><li>而固态磁盘的最小读写单位是页，通常大小是 4KB、8KB 等。</li></ul><p>在上一节中，我也提到过，如果每次都读写 512 字节这么小的单位的话，效率很低。所以，文件系统会把连续的扇区或页，组成逻辑块，然后以逻辑块作为最小单元来管理数据。常见的逻辑块的大小是 4KB，也就是说，连续 8 个扇区，或者单独的一个页，都可以组成一个逻辑块。</p><p>除了可以按照存储介质来分类，另一个常见的分类方法，是按照接口来分类，比如可以把硬盘分为 IDE（Integrated Drive Electronics）、SCSI（Small Computer System Interface） 、SAS（Serial Attached SCSI） 、SATA（Serial ATA） 、FC（Fibre Channel） 等。</p><p>不同的接口，往往分配不同的设备名称。比如， IDE 设备会分配一个 hd 前缀的设备名，SCSI 和 SATA 设备会分配一个 sd 前缀的设备名。如果是多块同类型的磁盘，就会按照 a、b、c 等的字母顺序来编号。</p><p>除了磁盘本身的分类外，当你把磁盘接入服务器后，按照不同的使用方式，又可以把它们划分为多种不同的架构。</p><p>最简单的，就是直接作为独立磁盘设备来使用。这些磁盘，往往还会根据需要，划分为不同的逻辑分区，每个分区再用数字编号。比如我们前面多次用到的 /dev/sda ，还可以分成两个分区 /dev/sda1 和 /dev/sda2。</p><p>另一个比较常用的架构，是把多块磁盘组合成一个逻辑磁盘，构成冗余独立磁盘阵列，也就是 RAID（Redundant Array of Independent Disks），从而可以提高数据访问的性能，并且增强数据存储的可靠性。</p><p>根据容量、性能和可靠性需求的不同，RAID 一般可以划分为多个级别，如 RAID0、RAID1、RAID5、RAID10 等。</p><ul><li>RAID0 有最优的读写性能，但不提供数据冗余的功能。</li><li>而其他级别的 RAID，在提供数据冗余的基础上，对读写性能也有一定程度的优化。</li></ul><p>最后一种架构，是把这些磁盘组合成一个网络存储集群，再通过 NFS、SMB、iSCSI 等网络存储协议，暴露给服务器使用。</p><p>其实在 Linux 中，<strong>磁盘实际上是作为一个块设备来管理的</strong>，也就是以块为单位读写数据，并且支持随机读写。每个块设备都会被赋予两个设备号，分别是主、次设备号。主设备号用在驱动程序中，用来区分设备类型；而次设备号则是用来给多个同类设备编号。</p><h4 id="24-2-通用块层"><a href="#24-2-通用块层" class="headerlink" title="24.2 通用块层"></a>24.2 通用块层</h4><p>跟我们上一节讲到的虚拟文件系统 VFS 类似，为了减小不同块设备的差异带来的影响，Linux 通过一个统一的通用块层，来管理各种不同的块设备。</p><p>通用块层，其实是处在文件系统和磁盘驱动中间的一个块设备抽象层。它主要有两个功能 。</p><ol><li>第一个功能跟虚拟文件系统的功能类似。向上，为文件系统和应用程序，提供访问块设备的标准接口；向下，把各种异构的磁盘设备抽象为统一的块设备，并提供统一框架来管理这些设备的驱动程序。</li><li>第二个功能，通用块层还会给文件系统和应用程序发来的 I/O 请求排队，并通过重新排序、请求合并等方式，提高磁盘读写的效率。</li></ol><p>其中，对 I/O 请求排序的过程，也就是我们熟悉的 I/O 调度。事实上，Linux 内核支持四种 I/O 调度算法，分别是 NONE、NOOP、CFQ 以及 DeadLine。这里我也分别介绍一下。</p><ol><li><p>第一种 NONE ，更确切来说，并不能算 I/O 调度算法。因为它完全不使用任何 I/O 调度器，对文件系统和应用程序的 I/O 其实不做任何处理，常用在虚拟机中（此时磁盘 I/O 调度完全由物理机负责）。</p></li><li><p>第二种 NOOP ，是最简单的一种 I/O 调度算法。它实际上是一个先入先出的队列，只做一些最基本的请求合并，常用于 SSD 磁盘。</p></li><li><p>第三种 CFQ（Completely Fair Scheduler），也被称为完全公平调度器，是现在很多发行版的默认 I/O 调度器，它为每个进程维护了一个 I/O 调度队列，并按照时间片来均匀分布每个进程的 I/O 请求。</p><p> 类似于进程 CPU 调度，CFQ 还支持进程 I/O 的优先级调度，所以它适用于运行大量进程的系统，像是桌面环境、多媒体应用等。</p></li><li><p>最后一种 DeadLine 调度算法，分别为读、写请求创建了不同的 I/O 队列，可以提高机械磁盘的吞吐量，并确保达到最终期限（deadline）的请求被优先处理。DeadLine 调度算法，多用在 I/O 压力比较重的场景，比如数据库等。</p></li></ol><h4 id="24-3-I-O-栈"><a href="#24-3-I-O-栈" class="headerlink" title="24.3. I/O 栈"></a>24.3. I/O 栈</h4><p>可以把 Linux 存储系统的 I/O 栈，由上到下分为三个层次，分别是文件系统层、通用块层和设备层。这三个 I/O 层的关系如下图所示，这其实也是 Linux 存储系统的 I/O 栈全景图。</p><p><img src="/images/《Linux性能优化实战》学习笔记/Linux存储系统的IO栈全景图.png" alt="Linux存储系统的IO栈全景图"></p><blockquote><p>图片来源：<a href="https://www.thomas-krenn.com/en/wiki/Linux_Storage_Stack_Diagram">Linux Storage Stack Diagram</a></p></blockquote><p>根据这张 I/O 栈的全景图，我们可以更清楚地理解，存储系统 I/O 的工作原理。</p><ol><li>文件系统层，包括虚拟文件系统和其他各种文件系统的具体实现。它为上层的应用程序，提供标准的文件访问接口；对下会通过通用块层，来存储和管理磁盘数据。</li><li>通用块层，包括块设备 I/O 队列和 I/O 调度器。它会对文件系统的 I/O 请求进行排队，再通过重新排序和请求合并，然后才要发送给下一级的设备层。</li><li>设备层，包括存储设备和相应的驱动程序，负责最终物理设备的 I/O 操作。</li></ol><p>存储系统的 I/O ，通常是整个系统中最慢的一环。所以， Linux 通过多种缓存机制来优化 I/O 效率。</p><p>比方说，为了优化文件访问的性能，会使用页缓存、索引节点缓存、目录项缓存等多种缓存机制，以减少对下层块设备的直接调用。</p><p>同样，为了优化块设备的访问效率，会使用缓冲区，来缓存块设备的数据。</p><h4 id="24-4-小结"><a href="#24-4-小结" class="headerlink" title="24.4 小结"></a>24.4 小结</h4><p>通用块层是 Linux 磁盘 I/O 的核心。向上，它为文件系统和应用程序，提供访问了块设备的标准接口；向下，把各种异构的磁盘设备，抽象为统一的块设备，并会对文件系统和应用程序发来的 I/O 请求进行重新排序、请求合并等，提高了磁盘访问的效率。</p><h3 id="25-基础篇：Linux-磁盘I-O是怎么工作的（下）"><a href="#25-基础篇：Linux-磁盘I-O是怎么工作的（下）" class="headerlink" title="25 | 基础篇：Linux 磁盘I/O是怎么工作的（下）"></a>25 | 基础篇：Linux 磁盘I/O是怎么工作的（下）</h3><h4 id="25-1-磁盘性能指标"><a href="#25-1-磁盘性能指标" class="headerlink" title="25.1 磁盘性能指标"></a>25.1 磁盘性能指标</h4><p>说到磁盘性能的衡量标准，必须要提到五个常见指标，也就是我们经常用到的，使用率、饱和度、IOPS、吞吐量以及响应时间等。这五个指标，是衡量磁盘性能的基本指标。</p><ul><li>使用率，是指磁盘处理 I/O 的时间百分比。过高的使用率（比如超过 80%），通常意味着磁盘 I/O 存在性能瓶颈。</li><li>饱和度，是指磁盘处理 I/O 的繁忙程度。过高的饱和度，意味着磁盘存在严重的性能瓶颈。当饱和度为 100% 时，磁盘无法接受新的 I/O 请求。</li><li>IOPS（Input/Output Per Second），是指每秒的 I/O 请求数。</li><li>吞吐量，是指每秒的 I/O 请求大小。</li><li>响应时间，是指 I/O 请求从发出到收到响应的间隔时间。</li></ul><p>这里要注意的是，使用率只考虑有没有 I/O，而不考虑 I/O 的大小。换句话说，当使用率是 100% 的时候，磁盘依然有可能接受新的 I/O 请求。</p><p>这些指标，很可能是你经常挂在嘴边的，一讨论磁盘性能必定提起的对象。不过我还是要强调一点，不要孤立地去比较某一指标，而要结合读写比例、I/O 类型（随机还是连续）以及 I/O 的大小，综合来分析。</p><p>举个例子，在数据库、大量小文件等这类随机读写比较多的场景中，IOPS 更能反映系统的整体性能；而在多媒体等顺序读写较多的场景中，吞吐量才更能反映系统的整体性能。</p><p>一般来说，我们在为应用程序的服务器选型时，要先对磁盘的 I/O 性能进行基准测试，以便可以准确评估，磁盘性能是否可以满足应用程序的需求。</p><p>这一方面，我推荐用性能测试工具 fio ，来测试磁盘的 IOPS、吞吐量以及响应时间等核心指标。但还是那句话，因地制宜，灵活选取。在基准测试时，一定要注意根据应用程序 I/O 的特点，来具体评估指标。</p><p>当然，这就需要你测试出，不同 I/O 大小（一般是 512B 至 1MB 中间的若干值）分别在随机读、顺序读、随机写、顺序写等各种场景下的性能情况。</p><p>用性能工具得到的这些指标，可以作为后续分析应用程序性能的依据。一旦发生性能问题，你就可以把它们作为磁盘性能的极限值，进而评估磁盘 I/O 的使用情况。</p><h4 id="25-2-磁盘-I-O-观测"><a href="#25-2-磁盘-I-O-观测" class="headerlink" title="25.2 磁盘 I/O 观测"></a>25.2 磁盘 I/O 观测</h4><p>第一个要观测的，是每块磁盘的使用情况。</p><p>iostat 是最常用的磁盘 I/O 性能观测工具，它提供了每个磁盘的使用率、IOPS、吞吐量等各种常见的性能指标，当然，这些指标实际上来自 /proc/diskstats。</p><p>iostat 的输出界面如下。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -d -x 表示显示所有磁盘 I/O 的指标</span>$ iostat -d -x <span class="token number">1</span>Device            r/s     w/s     rkB/s     wkB/s   rrqm/s   wrqm/s  %rrqm  %wrqm r_await w_await aqu-sz rareq-sz wareq-sz  svctm  %utilloop0            <span class="token number">0.00</span>    <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>     <span class="token number">0.00</span>     <span class="token number">0.00</span>   <span class="token number">0.00</span>   <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">0.00</span>     <span class="token number">0.00</span>     <span class="token number">0.00</span>   <span class="token number">0.00</span>   <span class="token number">0.00</span>loop1            <span class="token number">0.00</span>    <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>     <span class="token number">0.00</span>     <span class="token number">0.00</span>   <span class="token number">0.00</span>   <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">0.00</span>     <span class="token number">0.00</span>     <span class="token number">0.00</span>   <span class="token number">0.00</span>   <span class="token number">0.00</span>sda              <span class="token number">0.00</span>    <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>     <span class="token number">0.00</span>     <span class="token number">0.00</span>   <span class="token number">0.00</span>   <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">0.00</span>     <span class="token number">0.00</span>     <span class="token number">0.00</span>   <span class="token number">0.00</span>   <span class="token number">0.00</span>sdb              <span class="token number">0.00</span>    <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>     <span class="token number">0.00</span>     <span class="token number">0.00</span>   <span class="token number">0.00</span>   <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">0.00</span>     <span class="token number">0.00</span>     <span class="token number">0.00</span>   <span class="token number">0.00</span>   <span class="token number">0.00</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/《Linux性能优化实战》学习笔记/iostat指标解读.png" alt="iostat指标解读"></p><p>这些指标中，你要注意：</p><ul><li>%util ，就是我们前面提到的磁盘 I/O 使用率；</li><li>r/s+ w/s ，就是 IOPS；</li><li>rkB/s+wkB/s ，就是吞吐量；</li><li>r_await+w_await ，就是响应时间。</li></ul><p>在观测指标时，也别忘了结合请求的大小（ rareq-sz 和 wareq-sz）一起分析。</p><p>你可能注意到，从 iostat 并不能直接得到磁盘饱和度。事实上，饱和度通常也没有其他简单的观测方法，不过，你可以把观测到的，平均请求队列长度或者读写请求完成的等待时间，跟基准测试的结果（比如通过 fio）进行对比，综合评估磁盘的饱和情况。</p><h4 id="25-3-进程-I-O-观测"><a href="#25-3-进程-I-O-观测" class="headerlink" title="25.3 进程 I/O 观测"></a>25.3 进程 I/O 观测</h4><p>除了每块磁盘的 I/O 情况，每个进程的 I/O 情况也是我们需要关注的重点。</p><p>上面提到的 iostat 只提供磁盘整体的 I/O 性能数据，缺点在于，并不能知道具体是哪些进程在进行磁盘读写。要观察进程的 I/O 情况，你还可以使用 pidstat 和 iotop 这两个工具。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ pidstat -d <span class="token number">1</span><span class="token number">13</span>:39:51      <span class="token environment constant">UID</span>       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command<span class="token number">13</span>:39:52      <span class="token number">102</span>       <span class="token number">916</span>      <span class="token number">0.00</span>      <span class="token number">4.00</span>      <span class="token number">0.00</span>       <span class="token number">0</span>  rsyslogd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>从 pidstat 的输出你能看到，它可以实时查看每个进程的 I/O 情况，包括下面这些内容。</p><ul><li>用户 ID（UID）和进程 ID（PID） 。</li><li>每秒读取的数据大小（kB_rd/s） ，单位是 KB。</li><li>每秒发出的写请求数据大小（kB_wr/s） ，单位是 KB。</li><li>每秒取消的写请求数据大小（kB_ccwr/s） ，单位是 KB。</li><li>块 I/O 延迟（iodelay），包括等待同步块 I/O 和换入块 I/O 结束的时间，单位是时钟周期。</li></ul><p>除了可以用 pidstat 实时查看，根据 I/O 大小对进程排序，也是性能分析中一个常用的方法。这一点，我推荐另一个工具， iotop。它是一个类似于 top 的工具，你可以按照 I/O 大小对进程排序，然后找到 I/O 较大的那些进程。</p><p>iotop 的输出如下所示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ iotopTotal DISK READ <span class="token builtin class-name">:</span>       <span class="token number">0.00</span> B/s <span class="token operator">|</span> Total DISK WRITE <span class="token builtin class-name">:</span>       <span class="token number">7.85</span> K/sActual DISK READ:       <span class="token number">0.00</span> B/s <span class="token operator">|</span> Actual DISK WRITE:       <span class="token number">0.00</span> B/s  TID  PRIO  <span class="token environment constant">USER</span>     DISK READ  DISK WRITE  SWAPIN     IO<span class="token operator">&gt;</span>    COMMAND<span class="token number">15055</span> be/3 root        <span class="token number">0.00</span> B/s    <span class="token number">7.85</span> K/s  <span class="token number">0.00</span> %  <span class="token number">0.00</span> % systemd-journald<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从这个输出，你可以看到，前两行分别表示，进程的磁盘读写大小总数和磁盘真实的读写大小总数。因为缓存、缓冲区、I/O 合并等因素的影响，它们可能并不相等。</p><p>剩下的部分，则是从各个角度来分别表示进程的 I/O 情况，包括线程 ID、I/O 优先级、每秒读磁盘的大小、每秒写磁盘的大小、换入和等待 I/O 的时钟百分比等。</p><p>这两个工具，是我们分析磁盘 I/O 性能时最常用到的。你先了解它们的功能和指标含义，具体的使用方法，接下来的案例实战中我们一起学习。</p><h3 id="26-案例篇：如何找出狂打日志的“内鬼”？"><a href="#26-案例篇：如何找出狂打日志的“内鬼”？" class="headerlink" title="26 | 案例篇：如何找出狂打日志的“内鬼”？"></a>26 | 案例篇：如何找出狂打日志的“内鬼”？</h3><p>文件系统，是对存储设备上的文件进行组织管理的一种机制。为了支持各类不同的文件系统，Linux 在各种文件系统上，抽象了一层虚拟文件系统 VFS。</p><p>它定义了一组所有文件系统都支持的数据结构和标准接口。这样，应用程序和内核中的其他子系统，就只需要跟 VFS 提供的统一接口进行交互。</p><p>在文件系统的下层，为了支持各种不同类型的存储设备，Linux 又在各种存储设备的基础上，抽象了一个通用块层。</p><p>通用块层，为文件系统和应用程序提供了访问块设备的标准接口；同时，为各种块设备的驱动程序提供了统一的框架。此外，通用块层还会对文件系统和应用程序发送过来的 I/O 请求进行排队，并通过重新排序、请求合并等方式，提高磁盘读写的效率。</p><p>通用块层的下一层，自然就是设备层了，包括各种块设备的驱动程序以及物理存储设备。</p><p>文件系统、通用块层以及设备层，就构成了 Linux 的存储 I/O 栈。存储系统的 I/O ，通常是整个系统中最慢的一环。所以，Linux 采用多种缓存机制，来优化 I/O 的效率，比方说，</p><ul><li>为了优化文件访问的性能，采用页缓存、索引节点缓存、目录项缓存等多种缓存机制，减少对下层块设备的直接调用。</li><li>同样的，为了优化块设备的访问效率，使用缓冲区来缓存块设备的数据。</li></ul><p>不过，在碰到文件系统和磁盘的 I/O 问题时，具体应该怎么定位和分析呢？</p><h4 id="26-1-案例"><a href="#26-1-案例" class="headerlink" title="26.1 案例"></a>26.1 案例</h4><blockquote><p>机器配置： 2 CPU, 8 GB 内存。</p><p>安装软件：<code>apt install docker.io sysstat</code>。</p></blockquote><ol><li><p>在终端中执行下面的命令，运行今天的目标应用：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run -v /tmp:/tmp --name<span class="token operator">=</span>app -itd feisky/logapp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>然后，在终端中运行 ps 命令，确认案例应用正常启动。如果操作无误，你应该可以在 ps 的输出中，看到一个 app.py 的进程：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ps</span> -ef <span class="token operator">|</span> <span class="token function">grep</span> /app.pyroot     <span class="token number">18940</span> <span class="token number">18921</span> <span class="token number">73</span> <span class="token number">14</span>:41 pts/0    00:00:02 python /app.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 接着，我们来看看系统有没有性能问题。要观察哪些性能指标呢？前面文章中，我们知道 CPU、内存和磁盘 I/O 等系统资源，很容易出现资源瓶颈，这就是我们观察的方向了。我们来观察一下这些资源的使用情况。</p><p> 我的想法是，我们可以先用 top ，来观察 CPU 和内存的使用情况；然后再用 iostat ，来观察磁盘的 I/O 情况。</p></li><li><p>所以，接下来，你可以在终端中运行 top 命令，观察 CPU 和内存的使用情况：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 按 1 切换到每个 CPU 的使用情况</span>$ <span class="token function">top</span><span class="token function">top</span> - <span class="token number">14</span>:43:43 up <span class="token number">1</span> day,  <span class="token number">1</span>:39,  <span class="token number">2</span> users,  load average: <span class="token number">2.48</span>, <span class="token number">1.09</span>, <span class="token number">0.63</span>Tasks: <span class="token number">130</span> total,   <span class="token number">2</span> running,  <span class="token number">74</span> sleeping,   <span class="token number">0</span> stopped,   <span class="token number">0</span> zombie%Cpu0  <span class="token builtin class-name">:</span>  <span class="token number">0.7</span> us,  <span class="token number">6.0</span> sy,  <span class="token number">0.0</span> ni,  <span class="token number">0.7</span> id, <span class="token number">92.7</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> st%Cpu1  <span class="token builtin class-name">:</span>  <span class="token number">0.0</span> us,  <span class="token number">0.3</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">92.3</span> id,  <span class="token number">7.3</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> stKiB Mem <span class="token builtin class-name">:</span>  <span class="token number">8169308</span> total,   <span class="token number">747684</span> free,   <span class="token number">741336</span> used,  <span class="token number">6680288</span> buff/cacheKiB Swap:        <span class="token number">0</span> total,        <span class="token number">0</span> free,        <span class="token number">0</span> used.  <span class="token number">7113124</span> avail Mem  PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND<span class="token number">18940</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">656108</span> <span class="token number">355740</span>   <span class="token number">5236</span> R   <span class="token number">6.3</span>  <span class="token number">4.4</span>   <span class="token number">0</span>:12.56 python <span class="token number">1312</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">236532</span>  <span class="token number">24116</span>   <span class="token number">9648</span> S   <span class="token number">0.3</span>  <span class="token number">0.3</span>   <span class="token number">9</span>:29.80 python3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 观察 top 的输出，你会发现，CPU0 的使用率非常高，它的系统 CPU 使用率（sys%）为 6%，而 iowait 超过了 90%。这说明 CPU0 上，可能正在运行 I/O 密集型的进程。</p><p> 接着我们来看，进程部分的 CPU 使用情况。你会发现， python 进程的 CPU 使用率已经达到了 6%，而其余进程的 CPU 使用率都比较低，不超过 0.3%。看起来 python 是个可疑进程。</p><p> 最后再看内存的使用情况，总内存 8G，剩余内存只有 730 MB，而 Buffer/Cache 占用内存高达 6GB 之多，这说明内存主要被缓存占用。虽然大部分缓存可回收，我们还是得了解下缓存的去处，确认缓存使用都是合理的。</p><p> 到这一步，你基本可以判断出，CPU 使用率中的 iowait 是一个潜在瓶颈，而内存部分的缓存占比较大，那磁盘 I/O 又是怎么样的情况呢？</p></li><li><p>我们在终端中按 Ctrl+C ，停止 top 命令，再运行 iostat 命令，观察 I/O 的使用情况：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -d 表示显示 I/O 性能指标，-x 表示显示扩展统计（即所有 I/O 指标）</span>$ iostat -x -d <span class="token number">1</span>Device            r/s     w/s     rkB/s     wkB/s   rrqm/s   wrqm/s  %rrqm  %wrqm r_await w_await aqu-sz rareq-sz wareq-sz  svctm  %utilloop0            <span class="token number">0.00</span>    <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>     <span class="token number">0.00</span>     <span class="token number">0.00</span>   <span class="token number">0.00</span>   <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">0.00</span>     <span class="token number">0.00</span>     <span class="token number">0.00</span>   <span class="token number">0.00</span>   <span class="token number">0.00</span>sdb              <span class="token number">0.00</span>    <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>     <span class="token number">0.00</span>     <span class="token number">0.00</span>   <span class="token number">0.00</span>   <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">0.00</span>     <span class="token number">0.00</span>     <span class="token number">0.00</span>   <span class="token number">0.00</span>   <span class="token number">0.00</span>sda              <span class="token number">0.00</span>   <span class="token number">64.00</span>      <span class="token number">0.00</span>  <span class="token number">32768.00</span>     <span class="token number">0.00</span>     <span class="token number">0.00</span>   <span class="token number">0.00</span>   <span class="token number">0.00</span>    <span class="token number">0.00</span> <span class="token number">7270.44</span> <span class="token number">1102.18</span>     <span class="token number">0.00</span>   <span class="token number">512.00</span>  <span class="token number">15.50</span>  <span class="token number">99.20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 观察 iostat 的最后一列，你会看到，磁盘 sda 的 I/O 使用率已经高达 99%，很可能已经接近 I/O 饱和。</p><p> 再看前面的各个指标，每秒写磁盘请求数是 64 ，写大小是 32 MB，写请求的响应时间为 7 秒，而请求队列长度则达到了 1100。</p><p> 超慢的响应时间和特长的请求队列长度，进一步验证了 I/O 已经饱和的猜想。此时，sda 磁盘已经遇到了严重的性能瓶颈。</p><p> 到这里，也就可以理解，为什么前面看到的 iowait 高达 90% 了，这正是磁盘 sda 的 I/O 瓶颈导致的。接下来的重点就是分析 I/O 性能瓶颈的根源了。那要怎么知道，这些 I/O 请求相关的进程呢？</p></li><li><p>使用 pidstat 加上 -d 参数，就可以显示每个进程的 I/O 情况。所以，你可以在终端中运行如下命令来观察：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ pidstat -d <span class="token number">1</span><span class="token number">15</span>:08:35      <span class="token environment constant">UID</span>       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command<span class="token number">15</span>:08:36        <span class="token number">0</span>     <span class="token number">18940</span>      <span class="token number">0.00</span>  <span class="token number">45816.00</span>      <span class="token number">0.00</span>      <span class="token number">96</span>  python<span class="token number">15</span>:08:36      <span class="token environment constant">UID</span>       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command<span class="token number">15</span>:08:37        <span class="token number">0</span>       <span class="token number">354</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>     <span class="token number">350</span>  jbd2/sda1-8<span class="token number">15</span>:08:37        <span class="token number">0</span>     <span class="token number">18940</span>      <span class="token number">0.00</span>  <span class="token number">46000.00</span>      <span class="token number">0.00</span>      <span class="token number">96</span>  python<span class="token number">15</span>:08:37        <span class="token number">0</span>     <span class="token number">20065</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>    <span class="token number">1503</span>  kworker/u4:2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 从 pidstat 的输出，你可以发现，只有 python 进程的写比较大，而且每秒写的数据超过 45 MB，比上面 iostat 发现的 32MB 的结果还要大。很明显，正是 python 进程导致了 I/O 瓶颈。</p><p> 再往下看 iodelay 项。虽然只有 python 在大量写数据，但你应该注意到了，有两个进程 （kworker 和 jbd2 ）的延迟，居然比 python 进程还大很多。</p><p> 这其中，kworker 是一个内核线程，而 jbd2 是 ext4 文件系统中，用来保证数据完整性的内核线程。他们都是保证文件系统基本功能的内核线程，所以具体细节暂时就不用管了，我们只需要明白，它们延迟的根源还是大量 I/O。</p><p> 综合 pidstat 的输出来看，还是 python 进程的嫌疑最大。接下来，我们来分析 python 进程到底在写什么。</p><p> 首先留意一下 python 进程的 PID 号， 18940。看到 18940 ，你有没有觉得熟悉？其实前面在使用 top 时，我们记录过的 CPU 使用率最高的进程，也正是它。不过，虽然在 top 中使用率最高，也不过是 6%，并不算高。所以，以 I/O 问题为分析方向还是正确的。</p><p> 知道了进程的 PID 号，具体要怎么查看写的情况呢？</p><p> 其实，我在系统调用的案例中讲过，读写文件必须通过系统调用完成。观察系统调用情况，就可以知道进程正在写的文件。想起 strace 了吗，它正是我们分析系统调用时最常用的工具。</p></li><li><p>接下来，我们在终端中运行 strace 命令，并通过 -p 18940 指定 python 进程的 PID 号：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">strace</span> -p <span class="token number">18940</span>strace: Process <span class="token number">18940</span> attached<span class="token punctuation">..</span>.mmap<span class="token punctuation">(</span>NULL, <span class="token number">314576896</span>, PROT_READ<span class="token operator">|</span>PROT_WRITE, MAP_PRIVATE<span class="token operator">|</span>MAP_ANONYMOUS, -1, <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">=</span> 0x7f0f7aee9000mmap<span class="token punctuation">(</span>NULL, <span class="token number">314576896</span>, PROT_READ<span class="token operator">|</span>PROT_WRITE, MAP_PRIVATE<span class="token operator">|</span>MAP_ANONYMOUS, -1, <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">=</span> 0x7f0f682e8000write<span class="token punctuation">(</span><span class="token number">3</span>, <span class="token string">"2018-12-05 15:23:01,709 - __main"</span><span class="token punctuation">..</span>., <span class="token number">314572844</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">314572844</span>munmap<span class="token punctuation">(</span>0x7f0f682e8000, <span class="token number">314576896</span><span class="token punctuation">)</span>       <span class="token operator">=</span> <span class="token number">0</span>write<span class="token punctuation">(</span><span class="token number">3</span>, <span class="token string">"<span class="token entity" title="\n">\n</span>"</span>, <span class="token number">1</span><span class="token punctuation">)</span>                       <span class="token operator">=</span> <span class="token number">1</span>munmap<span class="token punctuation">(</span>0x7f0f7aee9000, <span class="token number">314576896</span><span class="token punctuation">)</span>       <span class="token operator">=</span> <span class="token number">0</span>close<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>                                <span class="token operator">=</span> <span class="token number">0</span>stat<span class="token punctuation">(</span><span class="token string">"/tmp/logtest.txt.1"</span>, <span class="token punctuation">{</span>st_mode<span class="token operator">=</span>S_IFREG<span class="token operator">|</span>0644, <span class="token assign-left variable">st_size</span><span class="token operator">=</span><span class="token number">943718535</span>, <span class="token punctuation">..</span>.<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 从 write() 系统调用上，我们可以看到，进程向文件描述符编号为 3 的文件中，写入了 300MB 的数据。看来，它应该是我们要找的文件。不过，write() 调用中只能看到文件的描述符编号，文件名和路径还是未知的。</p><p> 再观察后面的 stat() 调用，你可以看到，它正在获取 /tmp/logtest.txt.1 的状态。 这种“点 + 数字格式”的文件，在日志回滚中非常常见。我们可以猜测，这是第一个日志回滚文件，而正在写的日志文件路径，则是 /tmp/logtest.txt。</p></li><li><p>接下来，我们在终端中运行下面的 lsof 命令，看看进程 18940 都打开了哪些文件：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">lsof</span> -p <span class="token number">18940</span>COMMAND   PID <span class="token environment constant">USER</span>   FD   TYPE DEVICE  SIZE/OFF    NODE NAMEpython  <span class="token number">18940</span> root  cwd    DIR   <span class="token number">0,50</span>      <span class="token number">4096</span> <span class="token number">1549389</span> /python  <span class="token number">18940</span> root  rtd    DIR   <span class="token number">0,50</span>      <span class="token number">4096</span> <span class="token number">1549389</span> /…python  <span class="token number">18940</span> root    2u   CHR  <span class="token number">136,0</span>       0t0       <span class="token number">3</span> /dev/pts/0python  <span class="token number">18940</span> root    3w   REG    <span class="token number">8,1</span> <span class="token number">117944320</span>     <span class="token number">303</span> /tmp/logtest.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 有几列我简单介绍一下，FD 表示文件描述符号，TYPE 表示文件类型，NAME 表示文件路径。这也是我们需要关注的重点。</p><p> 再看最后一行，这说明，这个进程打开了文件 /tmp/logtest.txt，并且它的文件描述符是 3 号，而 3 后面的 w ，表示以写的方式打开。</p><p> 这跟刚才 strace 完我们猜测的结果一致，看来这就是问题的根源：进程 18940 以每次 300MB 的速度，在“疯狂”写日志，而日志文件的路径是 /tmp/logtest.txt。</p></li><li><p>你可以运行 docker cp 命令，把案例应用的源代码拷贝出来，然后查看它的内容。（你也可以点击<a href="https://github.com/feiskyer/linux-perf-examples/tree/master/logging-app">这里</a>查看案例应用的源码）：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 拷贝案例应用源代码到当前目录</span>$ docker <span class="token function">cp</span> app:/app.py <span class="token builtin class-name">.</span><span class="token comment"># 查看案例应用的源代码</span>$ <span class="token function">cat</span> app.pylogger <span class="token operator">=</span> logging.getLogger<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>logger.setLevel<span class="token punctuation">(</span>level<span class="token operator">=</span>logging.INFO<span class="token punctuation">)</span>rHandler <span class="token operator">=</span> RotatingFileHandler<span class="token punctuation">(</span><span class="token string">"/tmp/logtest.txt"</span>, <span class="token assign-left variable">maxBytes</span><span class="token operator">=</span><span class="token number">1024</span> * <span class="token number">1024</span> * <span class="token number">1024</span>, <span class="token assign-left variable">backupCount</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>rHandler.setLevel<span class="token punctuation">(</span>logging.INFO<span class="token punctuation">)</span>def write_log<span class="token punctuation">(</span>size<span class="token punctuation">)</span>:  <span class="token string">''</span><span class="token string">'Write logs to file'</span><span class="token string">''</span>  message <span class="token operator">=</span> get_message<span class="token punctuation">(</span>size<span class="token punctuation">)</span>  <span class="token keyword">while</span> True:    logger.info<span class="token punctuation">(</span>message<span class="token punctuation">)</span>    time.sleep<span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token builtin class-name">:</span>  msg_size <span class="token operator">=</span> <span class="token number">300</span> * <span class="token number">1024</span> * <span class="token number">1024</span>  write_log<span class="token punctuation">(</span>msg_size<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 分析这个源码，我们发现，它的日志路径是 /tmp/logtest.txt，默认记录 INFO 级别以上的所有日志，而且每次写日志的大小是 300MB。这跟我们上面的分析结果是一致的。</p></li><li><p>一般来说，生产系统的应用程序，应该有动态调整日志级别的功能。继续查看源码，你会发现，这个程序也可以调整日志级别。如果你给它发送 SIGUSR1 信号，就可以把日志调整为 INFO 级；发送 SIGUSR2 信号，则会调整为 WARNING 级：</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">set_logging_info</span><span class="token punctuation">(</span>signal_num<span class="token punctuation">,</span> frame<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token triple-quoted-string string">'''Set loging level to INFO when receives SIGUSR1'''</span>logger<span class="token punctuation">.</span>setLevel<span class="token punctuation">(</span>logging<span class="token punctuation">.</span>INFO<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">set_logging_warning</span><span class="token punctuation">(</span>signal_num<span class="token punctuation">,</span> frame<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token triple-quoted-string string">'''Set loging level to WARNING when receives SIGUSR2'''</span>logger<span class="token punctuation">.</span>setLevel<span class="token punctuation">(</span>logging<span class="token punctuation">.</span>WARNING<span class="token punctuation">)</span>signal<span class="token punctuation">.</span>signal<span class="token punctuation">(</span>signal<span class="token punctuation">.</span>SIGUSR1<span class="token punctuation">,</span> set_logging_info<span class="token punctuation">)</span>signal<span class="token punctuation">.</span>signal<span class="token punctuation">(</span>signal<span class="token punctuation">.</span>SIGUSR2<span class="token punctuation">,</span> set_logging_warning<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 根据源码中的日志调用 logger. info(message) ，我们知道，它的日志是 INFO 级，这也正是它的默认级别。那么，只要把默认级别调高到 WARNING 级，日志问题应该就解决了。</p></li><li><p>接下来，我们就来检查一下，刚刚的分析对不对。在终端中运行下面的 kill 命令，给进程 18940 发送 SIGUSR2 信号：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">kill</span> -SIGUSR2 <span class="token number">18940</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>然后，再执行 top 和 iostat 观察一下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">top</span><span class="token punctuation">..</span>.%Cpu<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:  <span class="token number">0.3</span> us,  <span class="token number">0.2</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">99.5</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> st<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ iostat -d -x <span class="token number">1</span>Device            r/s     w/s     rkB/s     wkB/s   rrqm/s   wrqm/s  %rrqm  %wrqm r_await w_await aqu-sz rareq-sz wareq-sz  svctm  %utilloop0            <span class="token number">0.00</span>    <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>     <span class="token number">0.00</span>     <span class="token number">0.00</span>   <span class="token number">0.00</span>   <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">0.00</span>     <span class="token number">0.00</span>     <span class="token number">0.00</span>   <span class="token number">0.00</span>   <span class="token number">0.00</span>sdb              <span class="token number">0.00</span>    <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>     <span class="token number">0.00</span>     <span class="token number">0.00</span>   <span class="token number">0.00</span>   <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">0.00</span>     <span class="token number">0.00</span>     <span class="token number">0.00</span>   <span class="token number">0.00</span>   <span class="token number">0.00</span>sda              <span class="token number">0.00</span>    <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>     <span class="token number">0.00</span>     <span class="token number">0.00</span>   <span class="token number">0.00</span>   <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">0.00</span>     <span class="token number">0.00</span>     <span class="token number">0.00</span>   <span class="token number">0.00</span>   <span class="token number">0.00</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>观察 top 和 iostat 的输出，你会发现，稍等一段时间后，iowait 会变成 0，而 sda 磁盘的 I/O 使用率也会逐渐减少到 0。</p></li></ol><h4 id="26-2-问答区"><a href="#26-2-问答区" class="headerlink" title="26.2 问答区"></a>26.2 问答区</h4><p>“日志回滚文件”，打印日志的过程中从直觉来看很容易误认为日志是在“回滚”，我也犯过这样的错误；rotating英文直译为“旋转”或“轮流”，实际的日志打印过程中，日志名称是“旋转”的，例如log.1(当前打印的日志文件并且一直会打印这个文件)，log.2(较早日志)，log.3(更早日志)，当触发“旋转”条件时，日志名称会发生变更，假如log.3是上限数，那么log.3发生“旋转”就被remove，log.2被rename为log.3。更形象一点的描述是，日志名称发生了滚动，log.1=&gt;log.2=&gt;log.3不断的更新。</p><h3 id="27-案例篇：为什么我的磁盘I-O延迟很高？"><a href="#27-案例篇：为什么我的磁盘I-O延迟很高？" class="headerlink" title="27 | 案例篇：为什么我的磁盘I/O延迟很高？"></a>27 | 案例篇：为什么我的磁盘I/O延迟很高？</h3><h4 id="27-1-案例"><a href="#27-1-案例" class="headerlink" title="27.1 案例"></a>27.1 案例</h4><blockquote><p>机器配置： 2 CPU, 8 GB 内存。</p><p>安装软件：<code>apt install docker.io sysstat</code>。</p></blockquote><ol><li><p>在第一个终端中执行下面的命令，运行本次案例要分析的目标应用：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run --name<span class="token operator">=</span>app -p <span class="token number">10000</span>:80 -itd feisky/word-pop<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>在第二个终端中运行 curl 命令，访问 <a href="http://192.168.0.10:1000/，确认案例正常启动。你应该可以在">http://192.168.0.10:1000/，确认案例正常启动。你应该可以在</a> curl 的输出界面里，看到一个 hello world 的输出：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">curl</span> http://192.168.0.10:10000/hello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>接下来，在第二个终端中，访问案例应用的单词热度接口，也就是 <a href="http://192.168.0.10:1000/popularity/word。">http://192.168.0.10:1000/popularity/word。</a></p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">curl</span> http://192.168.0.10:1000/popularity/word<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 稍等一会儿，你会发现，这个接口居然这么长时间都没响应，究竟是怎么回事呢？我们先回到终端一来分析一下。</p><p> 我们试试在第一个终端里，随便执行一个命令，比如执行 df 命令，查看一下文件系统的使用情况。奇怪的是，这么简单的命令，居然也要等好久才有输出。</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">df</span>Filesystem     1K-blocks    Used Available Use% Mounted onudev             <span class="token number">4073376</span>       <span class="token number">0</span>   <span class="token number">4073376</span>   <span class="token number">0</span>% /devtmpfs             <span class="token number">816932</span>    <span class="token number">1188</span>    <span class="token number">815744</span>   <span class="token number">1</span>% /run/dev/sda1       <span class="token number">30308240</span> <span class="token number">8713640</span>  <span class="token number">21578216</span>  <span class="token number">29</span>% /<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 通过 df 我们知道，系统还有足够多的磁盘空间。那为什么响应会变慢呢？看来还是得观察一下，系统的资源使用情况，像是 CPU、内存和磁盘 I/O 等的具体使用情况。</p><p> 这里的思路其实跟上一个案例比较类似，我们可以先用 top 来观察 CPU 和内存的使用情况，然后再用 iostat 来观察磁盘的 I/O 情况。</p></li><li><p>为了避免分析过程中 curl 请求突然结束，我们回到终端二，按 Ctrl+C 停止刚才的应用程序；然后，把 curl 命令放到一个循环里执行；这次我们还要加一个 time 命令，观察每次的执行时间：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token keyword">while</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token function">time</span> <span class="token function">curl</span> http://192.168.0.10:10000/popularity/word<span class="token punctuation">;</span> <span class="token function">sleep</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>继续回到终端一来分析性能。我们在终端一中运行 top 命令，观察 CPU 和内存的使用情况：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">top</span><span class="token function">top</span> - <span class="token number">14</span>:27:02 up <span class="token number">10</span>:30,  <span class="token number">1</span> user,  load average: <span class="token number">1.82</span>, <span class="token number">1.26</span>, <span class="token number">0.76</span>Tasks: <span class="token number">129</span> total,   <span class="token number">1</span> running,  <span class="token number">74</span> sleeping,   <span class="token number">0</span> stopped,   <span class="token number">0</span> zombie%Cpu0  <span class="token builtin class-name">:</span>  <span class="token number">3.5</span> us,  <span class="token number">2.1</span> sy,  <span class="token number">0.0</span> ni,  <span class="token number">0.0</span> id, <span class="token number">94.4</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> st%Cpu1  <span class="token builtin class-name">:</span>  <span class="token number">2.4</span> us,  <span class="token number">0.7</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">70.4</span> id, <span class="token number">26.5</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> stKiB Mem <span class="token builtin class-name">:</span>  <span class="token number">8169300</span> total,  <span class="token number">3323248</span> free,   <span class="token number">436748</span> used,  <span class="token number">4409304</span> buff/cacheKiB Swap:        <span class="token number">0</span> total,        <span class="token number">0</span> free,        <span class="token number">0</span> used.  <span class="token number">7412556</span> avail Mem  PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND<span class="token number">12280</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">103304</span>  <span class="token number">28824</span>   <span class="token number">7276</span> S  <span class="token number">14.0</span>  <span class="token number">0.4</span>   <span class="token number">0</span>:08.77 python   <span class="token number">16</span> root      <span class="token number">20</span>   <span class="token number">0</span>       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> S   <span class="token number">0.3</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:09.22 ksoftirqd/1<span class="token number">1549</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">236712</span>  <span class="token number">24480</span>   <span class="token number">9864</span> S   <span class="token number">0.3</span>  <span class="token number">0.3</span>   <span class="token number">3</span>:31.38 python3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 观察 top 的输出可以发现，两个 CPU 的 iowait 都非常高。特别是 CPU0， iowait 已经高达 94 %，而剩余内存还有 3GB，看起来也是充足的。</p><p> 再往下看，进程部分有一个 python 进程的 CPU 使用率稍微有点高，达到了 14%。虽然 14% 并不能成为性能瓶颈，不过有点嫌疑——可能跟 iowait 的升高有关。</p><p> 那这个 PID 号为 12280 的 python 进程，到底是不是我们的案例应用呢？</p></li><li><p>我们在第一个终端中，按下 Ctrl+C，停止 top 命令；然后执行下面的 ps 命令，查找案例应用 app.py 的 PID 号：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">grep</span> app.pyroot     <span class="token number">12222</span>  <span class="token number">0.4</span>  <span class="token number">0.2</span>  <span class="token number">96064</span> <span class="token number">23452</span> pts/0    Ss+  <span class="token number">14</span>:37   <span class="token number">0</span>:00 python /app.pyroot     <span class="token number">12280</span> <span class="token number">13.9</span>  <span class="token number">0.3</span> <span class="token number">102424</span> <span class="token number">27904</span> pts/0    Sl+  <span class="token number">14</span>:37   <span class="token number">0</span>:09 /usr/local/bin/python /app.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 从 ps 的输出，你可以看到，这个 CPU 使用率较高的进程，正是我们的案例应用。不过先别着急分析 CPU 问题，毕竟 iowait 已经高达 94%， I/O 问题才是我们首要解决的。</p></li><li><p>接下来，我们在终端一中，运行下面的 iostat 命令，其中:</p><ul><li>-d 选项是指显示出 I/O 的性能指标；</li><li><p>-x 选项是指显示出扩展统计信息（即显示所有 I/O 指标）。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ iostat -d -x <span class="token number">1</span>Device            r/s     w/s     rkB/s     wkB/s   rrqm/s   wrqm/s  %rrqm  %wrqm r_await w_await aqu-sz rareq-sz wareq-sz  svctm  %utilloop0            <span class="token number">0.00</span>    <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>     <span class="token number">0.00</span>     <span class="token number">0.00</span>   <span class="token number">0.00</span>   <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">0.00</span>     <span class="token number">0.00</span>     <span class="token number">0.00</span>   <span class="token number">0.00</span>   <span class="token number">0.00</span>sda              <span class="token number">0.00</span>   <span class="token number">71.00</span>      <span class="token number">0.00</span>  <span class="token number">32912.00</span>     <span class="token number">0.00</span>     <span class="token number">0.00</span>   <span class="token number">0.00</span>   <span class="token number">0.00</span>    <span class="token number">0.00</span> <span class="token number">18118.31</span> <span class="token number">241.89</span>     <span class="token number">0.00</span>   <span class="token number">463.55</span>  <span class="token number">13.86</span>  <span class="token number">98.40</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现，磁盘 sda 的 I/O 使用率已经达到 98% ，接近饱和了。而且，写请求的响应时间高达 18 秒，每秒的写数据为 32 MB，显然写磁盘碰到了瓶颈。</p><p>那要怎么知道，这些 I/O 请求到底是哪些进程导致的呢？</p></li></ul></li><li><p>在终端一中，运行下面的 pidstat 命令，观察进程的 I/O 情况：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ pidstat -d <span class="token number">1</span><span class="token number">14</span>:39:14      <span class="token environment constant">UID</span>       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command<span class="token number">14</span>:39:15        <span class="token number">0</span>     <span class="token number">12280</span>      <span class="token number">0.00</span> <span class="token number">335716.00</span>      <span class="token number">0.00</span>       <span class="token number">0</span>  python<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 从 pidstat 的输出，我们再次看到了 PID 号为 12280 的结果。这说明，正是案例应用引发 I/O 的性能瓶颈。</p><p> 走到这一步，你估计觉得，接下来就很简单了，上一个案例不刚刚学过吗？无非就是，先用 strace 确认它是不是在写文件，再用 lsof 找出文件描述符对应的文件即可。</p></li><li><p>到底是不是这样呢？我们不妨来试试。还是在终端一中，执行下面的 strace 命令：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">strace</span> -p <span class="token number">12280</span>strace: Process <span class="token number">12280</span> attachedselect<span class="token punctuation">(</span><span class="token number">0</span>, NULL, NULL, NULL, <span class="token punctuation">{</span>tv_sec<span class="token operator">=</span><span class="token number">0</span>, <span class="token assign-left variable">tv_usec</span><span class="token operator">=</span><span class="token number">567708</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">(</span>Timeout<span class="token punctuation">)</span>stat<span class="token punctuation">(</span><span class="token string">"/usr/local/lib/python3.7/importlib/_bootstrap.py"</span>, <span class="token punctuation">{</span>st_mode<span class="token operator">=</span>S_IFREG<span class="token operator">|</span>0644, <span class="token assign-left variable">st_size</span><span class="token operator">=</span><span class="token number">39278</span>, <span class="token punctuation">..</span>.<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span>stat<span class="token punctuation">(</span><span class="token string">"/usr/local/lib/python3.7/importlib/_bootstrap.py"</span>, <span class="token punctuation">{</span>st_mode<span class="token operator">=</span>S_IFREG<span class="token operator">|</span>0644, <span class="token assign-left variable">st_size</span><span class="token operator">=</span><span class="token number">39278</span>, <span class="token punctuation">..</span>.<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 从 strace 中，你可以看到大量的 stat 系统调用，并且大都为 python 的文件，但是，请注意，这里并没有任何 write 系统调用。</p><p> 由于 strace 的输出比较多，我们可以用 grep ，来过滤一下 write，比如：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">strace</span> -p <span class="token number">12280</span> <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;1</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token function">write</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 遗憾的是，这里仍然没有任何输出。</p><p> 难道此时已经没有性能问题了吗？重新执行刚才的 top 和 iostat 命令，你会不幸地发现，性能问题仍然存在。</p><p> 我们只好综合 strace、pidstat 和 iostat 这三个结果来分析了。很明显，你应该发现了这里的矛盾：iostat 已经证明磁盘 I/O 有性能瓶颈，而 pidstat 也证明了，这个瓶颈是由 12280 号进程导致的，但 strace 跟踪这个进程，却没有找到任何 write 系统调用。</p><p> 这就奇怪了。难道因为案例使用的编程语言是 Python ，而 Python 是解释型的，所以找不到？还是说，因为案例运行在 Docker 中呢？这里留个悬念，你自己想想。</p><p> 文件写，明明应该有相应的 write 系统调用，但用现有工具却找不到痕迹，这时就该想想换工具的问题了。怎样才能知道哪里在写文件呢？</p><p> 这里我给你介绍一个新工具， <a href="https://github.com/iovisor/bcc/blob/master/tools/filetop.py">filetop</a> 。它是 <a href="https://github.com/iovisor/bcc">bcc</a> 软件包的一部分，基于 Linux 内核的 eBPF（extended Berkeley Packet Filters）机制，主要跟踪内核中文件的读写情况，并输出线程 ID（TID）、读写大小、读写类型以及文件名称。</p></li><li><p>首先，在终端一中运行下面的命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 切换到工具目录</span>$ <span class="token builtin class-name">cd</span> /usr/share/bcc/tools<span class="token comment"># -C 选项表示输出新内容时不清空屏幕</span>$ ./filetop -CTID    COMM             READS  WRITES R_Kb    W_Kb    T FILE<span class="token number">514</span>    python           <span class="token number">0</span>      <span class="token number">1</span>      <span class="token number">0</span>       <span class="token number">2832</span>    R <span class="token number">669</span>.txt<span class="token number">514</span>    python           <span class="token number">0</span>      <span class="token number">1</span>      <span class="token number">0</span>       <span class="token number">2490</span>    R <span class="token number">667</span>.txt<span class="token number">514</span>    python           <span class="token number">0</span>      <span class="token number">1</span>      <span class="token number">0</span>       <span class="token number">2685</span>    R <span class="token number">671</span>.txt<span class="token number">514</span>    python           <span class="token number">0</span>      <span class="token number">1</span>      <span class="token number">0</span>       <span class="token number">2392</span>    R <span class="token number">670</span>.txt<span class="token number">514</span>    python           <span class="token number">0</span>      <span class="token number">1</span>      <span class="token number">0</span>       <span class="token number">2050</span>    R <span class="token number">672</span>.txt<span class="token punctuation">..</span>.TID    COMM             READS  WRITES R_Kb    W_Kb    T FILE<span class="token number">514</span>    python           <span class="token number">2</span>      <span class="token number">0</span>      <span class="token number">5957</span>    <span class="token number">0</span>       R <span class="token number">651</span>.txt<span class="token number">514</span>    python           <span class="token number">2</span>      <span class="token number">0</span>      <span class="token number">5371</span>    <span class="token number">0</span>       R <span class="token number">112</span>.txt<span class="token number">514</span>    python           <span class="token number">2</span>      <span class="token number">0</span>      <span class="token number">4785</span>    <span class="token number">0</span>       R <span class="token number">861</span>.txt<span class="token number">514</span>    python           <span class="token number">2</span>      <span class="token number">0</span>      <span class="token number">4736</span>    <span class="token number">0</span>       R <span class="token number">213</span>.txt<span class="token number">514</span>    python           <span class="token number">2</span>      <span class="token number">0</span>      <span class="token number">4443</span>    <span class="token number">0</span>       R <span class="token number">45</span>.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你会看到，filetop 输出了 8 列内容，分别是线程 ID、线程命令行、读写次数、读写的大小（单位 KB）、文件类型以及读写的文件名称。</p><p>这些内容里，你可能会看到很多动态链接库，不过这不是我们的重点，暂且忽略即可。我们的重点，是一个 python 应用，所以要特别关注 python 相关的内容。</p><p>多观察一会儿，你就会发现，每隔一段时间，线程号为 514 的 python 应用就会先写入大量的 txt 文件，再大量地读。</p></li><li><p>线程号为 514 的线程，属于哪个进程呢？我们可以用 ps 命令查看。先在终端一中，按下 Ctrl+C ，停止 filetop ；然后，运行下面的 ps 命令。这个输出的第二列内容，就是我们想知道的进程号：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ps</span> -efT <span class="token operator">|</span> <span class="token function">grep</span> <span class="token number">514</span>root     <span class="token number">12280</span>  <span class="token number">514</span> <span class="token number">14626</span> <span class="token number">33</span> <span class="token number">14</span>:47 pts/0    00:00:05 /usr/local/bin/python /app.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们看到，这个线程正是案例应用 12280 的线程。终于可以先松一口气，不过还没完，filetop 只给出了文件名称，却没有文件路径，还得继续找啊。</p><p>我再介绍一个好用的工具，opensnoop 。它同属于 bcc 软件包，可以动态跟踪内核中的 open 系统调用。这样，我们就可以找出这些 txt 文件的路径。</p></li><li><p>接下来，在终端一中，运行下面的 opensnoop 命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ opensnoop<span class="token number">12280</span>  python              <span class="token number">6</span>   <span class="token number">0</span> /tmp/9046db9e-fe25-11e8-b13f-0242ac110002/650.txt<span class="token number">12280</span>  python              <span class="token number">6</span>   <span class="token number">0</span> /tmp/9046db9e-fe25-11e8-b13f-0242ac110002/651.txt<span class="token number">12280</span>  python              <span class="token number">6</span>   <span class="token number">0</span> /tmp/9046db9e-fe25-11e8-b13f-0242ac110002/652.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这次，通过 opensnoop 的输出，你可以看到，这些 txt 路径位于 /tmp 目录下。你还能看到，它打开的文件数量，按照数字编号，从 0.txt 依次增大到 999.txt，这可远多于前面用 filetop 看到的数量。</p></li><li><p>综合 filetop 和 opensnoop ，我们就可以进一步分析了。我们可以大胆猜测，案例应用在写入 1000 个 txt 文件后，又把这些内容读到内存中进行处理。我们来检查一下，这个目录中是不是真的有 1000 个文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> /tmp/9046db9e-fe25-11e8-b13f-0242ac110002 <span class="token operator">|</span> <span class="token function">wc</span> -lls: cannot access <span class="token string">'/tmp/9046db9e-fe25-11e8-b13f-0242ac110002'</span><span class="token builtin class-name">:</span> No such <span class="token function">file</span> or directory<span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>操作后却发现，目录居然不存在了。怎么回事呢？我们回到 opensnoop 再观察一会儿：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ opensnoop<span class="token number">12280</span>  python              <span class="token number">6</span>   <span class="token number">0</span> /tmp/defee970-fe25-11e8-b13f-0242ac110002/261.txt<span class="token number">12280</span>  python              <span class="token number">6</span>   <span class="token number">0</span> /tmp/defee970-fe25-11e8-b13f-0242ac110002/840.txt<span class="token number">12280</span>  python              <span class="token number">6</span>   <span class="token number">0</span> /tmp/defee970-fe25-11e8-b13f-0242ac110002/136.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>原来，这时的路径已经变成了另一个目录。这说明，这些目录都是应用程序动态生成的，用完就删了。</p><p>结合前面的所有分析，我们基本可以判断，案例应用会动态生成一批文件，用来临时存储数据，用完就会删除它们。但不幸的是，正是这些文件读写，引发了 I/O 的性能瓶颈，导致整个处理过程非常慢。</p></li><li><p>当然，我们还需要验证这个猜想。老办法，还是查看应用程序的源码 app.py，</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>route</span><span class="token punctuation">(</span><span class="token string">"/popularity/&lt;word&gt;"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">word_popularity</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">:</span>dir_path <span class="token operator">=</span> <span class="token string">'/tmp/{}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>uuid<span class="token punctuation">.</span>uuid1<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>count <span class="token operator">=</span> <span class="token number">0</span>sample_size <span class="token operator">=</span> <span class="token number">1000</span><span class="token keyword">def</span> <span class="token function">save_to_file</span><span class="token punctuation">(</span>file_name<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>file_name<span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>    <span class="token comment"># initial directory firstly</span>    os<span class="token punctuation">.</span>mkdir<span class="token punctuation">(</span>dir_path<span class="token punctuation">)</span>    <span class="token comment"># save article to files</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sample_size<span class="token punctuation">)</span><span class="token punctuation">:</span>        file_name <span class="token operator">=</span> <span class="token string">'{}/{}.txt'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>dir_path<span class="token punctuation">,</span> i<span class="token punctuation">)</span>        article <span class="token operator">=</span> generate_article<span class="token punctuation">(</span><span class="token punctuation">)</span>        save_to_file<span class="token punctuation">(</span>file_name<span class="token punctuation">,</span> article<span class="token punctuation">)</span>    <span class="token comment"># count word popularity</span>    <span class="token keyword">for</span> root<span class="token punctuation">,</span> dirs<span class="token punctuation">,</span> files <span class="token keyword">in</span> os<span class="token punctuation">.</span>walk<span class="token punctuation">(</span>dir_path<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> file_name <span class="token keyword">in</span> files<span class="token punctuation">:</span>            <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'{}/{}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>dir_path<span class="token punctuation">,</span> file_name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>                <span class="token keyword">if</span> validate<span class="token punctuation">(</span>word<span class="token punctuation">,</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    count <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">finally</span><span class="token punctuation">:</span>        <span class="token comment"># clean files</span>        shutil<span class="token punctuation">.</span>rmtree<span class="token punctuation">(</span>dir_path<span class="token punctuation">,</span> ignore_errors<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> jsonify<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'popularity'</span><span class="token punctuation">:</span> count <span class="token operator">/</span> sample_size <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">'word'</span><span class="token punctuation">:</span> word<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>源码中可以看到，这个案例应用，在每个请求的处理过程中，都会生成一批临时文件，然后读入内存处理，最后再把整个目录删除掉。</p><p>这是一种常见的利用磁盘空间处理大量数据的技巧，不过，本次案例中的 I/O 请求太重，导致磁盘 I/O 利用率过高。</p><p>要解决这一点，其实就是算法优化问题了。比如在内存充足时，就可以把所有数据都放到内存中处理，这样就能避免 I/O 的性能问题。</p></li></ol><h4 id="27-2-思考"><a href="#27-2-思考" class="headerlink" title="27.2 思考"></a>27.2 思考</h4><p>今天的案例中，iostat 已经证明，磁盘 I/O 出现了性能瓶颈， pidstat 也证明了这个瓶颈是由 12280 号进程导致的。但是，strace 跟踪这个进程，却没有发现任何 write 系统调用。</p><p>答案：在strace -p PID后加上-f，多进程和多线程都可以跟踪。</p><h3 id="28-案例篇：一个SQL查询要15秒，这是怎么回事？"><a href="#28-案例篇：一个SQL查询要15秒，这是怎么回事？" class="headerlink" title="28 | 案例篇：一个SQL查询要15秒，这是怎么回事？"></a>28 | 案例篇：一个SQL查询要15秒，这是怎么回事？</h3><h4 id="28-1-案例"><a href="#28-1-案例" class="headerlink" title="28.1 案例"></a>28.1 案例</h4><blockquote><p>机器配置： 2 CPU, 8 GB 内存。</p><p>安装软件：<code>apt install docker.io sysstat make git</code>。</p></blockquote><p>案例总共由三个容器组成，包括一个 MySQL 数据库应用、一个商品搜索应用以及一个数据处理的应用。其中，商品搜索应用以 HTTP 的形式提供了一个接口：</p><ul><li>/：返回 Index Page；</li><li>/db/insert/products/：插入指定数量的商品信息；</li><li>/products/：查询指定商品的信息，并返回处理时间。</li></ul><ol><li><p>在第一个终端中执行下面命令，拉取本次案例所需脚本：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> clone https://github.com/feiskyer/linux-perf-examples$ <span class="token builtin class-name">cd</span> linux-perf-examples/mysql-slow<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>接着，执行下面的命令，运行本次的目标应用。正常情况下，你应该可以看到下面的输出：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 注意下面的随机字符串是容器 ID，每次运行均会不同，并且你不需要关注它，因为我们只会用到名字</span>$ <span class="token function">make</span> rundocker run --name<span class="token operator">=</span>mysql -itd -p <span class="token number">10000</span>:80 -m 800m feisky/mysql:5.6WARNING: Your kernel does not support swap limit capabilities or the cgroup is not mounted. Memory limited without swap.4156780da5be0b9026bcf27a3fa56abc15b8408e358fa327f472bcc5add4453fdocker run --name<span class="token operator">=</span>dataservice -itd --privileged feisky/mysql-dataservicef724d0816d7e47c0b2b1ff701e9a39239cb9b5ce70f597764c793b68131122bbdocker run --name<span class="token operator">=</span>app --network<span class="token operator">=</span>container:mysql -itd feisky/mysql-slow81d3392ba25bb8436f6151662a13ff6182b6bc6f2a559fc2e9d873cd07224ab6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>然后，再运行 docker ps 命令，确认三个容器都处在运行（Up）状态：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker <span class="token function">ps</span>CONTAINER ID        IMAGE                      COMMAND                  CREATED             STATUS              PORTS                             NAMES9a4e3c580963        feisky/mysql-slow          <span class="token string">"python /app.py"</span>         <span class="token number">42</span> seconds ago      Up <span class="token number">36</span> seconds                                         app2a47aab18082        feisky/mysql-dataservice   <span class="token string">"python /dataservice…"</span>   <span class="token number">46</span> seconds ago      Up <span class="token number">41</span> seconds                                         dataservice4c3ff7b24748        feisky/mysql:5.6           <span class="token string">"docker-entrypoint.s…"</span>   <span class="token number">47</span> seconds ago      Up <span class="token number">46</span> seconds       <span class="token number">3306</span>/tcp, <span class="token number">0.0</span>.0.0:10000-<span class="token operator">&gt;</span><span class="token number">80</span>/tcp   mysql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> MySQL 数据库的启动过程，需要做一些初始化工作，这通常需要花费几分钟时间。你可以运行 docker logs 命令，查看它的启动过程。</p></li><li><p>当你看到下面这个输出时，说明 MySQL 初始化完成，可以接收外部请求了：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker logs -f mysql<span class="token punctuation">..</span>.<span class="token punctuation">..</span>. <span class="token punctuation">[</span>Note<span class="token punctuation">]</span> mysqld: ready <span class="token keyword">for</span> connections.Version: <span class="token string">'5.6.42-log'</span>  socket: <span class="token string">'/var/run/mysqld/mysqld.sock'</span>  port: <span class="token number">3306</span>  MySQL Community Server <span class="token punctuation">(</span>GPL<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>而商品搜索应用则是在 10000 端口监听。你可以按 Ctrl+C ，停止 docker logs 命令；然后，执行下面的命令，确认它也已经正常运行。如果一切正常，你会看到 Index Page 的输出：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">curl</span> http://127.0.0.1:10000/Index Page<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>接下来，运行 make init 命令，初始化数据库，并插入 10000 条商品信息。这个过程比较慢，比如在我的机器中，就花了十几分钟时间。耐心等待一段时间后，你会看到如下的输出：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">make</span> initdocker <span class="token builtin class-name">exec</span> -i mysql mysql -uroot -P3306 <span class="token operator">&lt;</span> tables.sql<span class="token function">curl</span> http://127.0.0.1:10000/db/insert/products/10000insert <span class="token number">10000</span> lines<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>接着，我们切换到第二个终端，访问一下商品搜索的接口，看看能不能找到想要的商品。执行如下的 curl 命令：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">curl</span> http://192.168.0.10:10000/products/geektimeGot data: <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token number">15.364538192749023</span> sec<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 稍等一会儿，你会发现，这个接口返回的是空数据，而且处理时间超过 15 秒。这么慢的响应速度让人无法忍受，到底出了什么问题呢？</p><p> 既然今天用了 MySQL，你估计会猜到是慢查询的问题。</p><p> 不过别急，在具体分析前，为了避免在分析过程中客户端的请求结束，我们把 curl 命令放到一个循环里执行。同时，为了避免给系统过大压力，我们设置在每次查询后，都先等待 5 秒，然后再开始新的请求。</p></li><li><p>所以，你可以在终端二中，继续执行下面的命令：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token keyword">while</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token function">curl</span> http://192.168.0.10:10000/products/geektime<span class="token punctuation">;</span> <span class="token function">sleep</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 接下来，重新回到终端一中，分析接口响应速度慢的原因。不过，重回终端一后，你会发现系统响应也明显变慢了，随便执行一个命令，都得停顿一会儿才能看到输出。</p></li><li><p>首先，我们在终端一执行 top 命令，分析系统的 CPU 使用情况：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">top</span><span class="token function">top</span> - <span class="token number">12</span>:02:15 up <span class="token number">6</span> days,  <span class="token number">8</span>:05,  <span class="token number">1</span> user,  load average: <span class="token number">0.66</span>, <span class="token number">0.72</span>, <span class="token number">0.59</span>Tasks: <span class="token number">137</span> total,   <span class="token number">1</span> running,  <span class="token number">81</span> sleeping,   <span class="token number">0</span> stopped,   <span class="token number">0</span> zombie%Cpu0  <span class="token builtin class-name">:</span>  <span class="token number">0.7</span> us,  <span class="token number">1.3</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">35.9</span> id, <span class="token number">62.1</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> st%Cpu1  <span class="token builtin class-name">:</span>  <span class="token number">0.3</span> us,  <span class="token number">0.7</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">84.7</span> id, <span class="token number">14.3</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> stKiB Mem <span class="token builtin class-name">:</span>  <span class="token number">8169300</span> total,  <span class="token number">7238472</span> free,   <span class="token number">546132</span> used,   <span class="token number">384696</span> buff/cacheKiB Swap:        <span class="token number">0</span> total,        <span class="token number">0</span> free,        <span class="token number">0</span> used.  <span class="token number">7316952</span> avail Mem  PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND<span class="token number">27458</span> <span class="token number">999</span>       <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">833852</span>  <span class="token number">57968</span>  <span class="token number">13176</span> S   <span class="token number">1.7</span>  <span class="token number">0.7</span>   <span class="token number">0</span>:12.40 mysqld<span class="token number">27617</span> root      <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">24348</span>   <span class="token number">9216</span>   <span class="token number">4692</span> S   <span class="token number">1.0</span>  <span class="token number">0.1</span>   <span class="token number">0</span>:04.40 python <span class="token number">1549</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">236716</span>  <span class="token number">24568</span>   <span class="token number">9864</span> S   <span class="token number">0.3</span>  <span class="token number">0.3</span>  <span class="token number">51</span>:46.57 python3<span class="token number">22421</span> root      <span class="token number">20</span>   <span class="token number">0</span>       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> I   <span class="token number">0.3</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:01.16 kworker/u<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 观察 top 的输出，我们发现，两个 CPU 的 iowait 都比较高，特别是 CPU0，iowait 已经超过 60%。而具体到各个进程， CPU 使用率并不高，最高的也只有 1.7%。</p></li><li><p>既然 CPU 的嫌疑不大，那问题应该还是出在了 I/O 上。我们仍然在第一个终端，按下 Ctrl+C，停止 top 命令；然后，执行下面的 iostat 命令，看看有没有 I/O 性能问题：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ iostat -d -x <span class="token number">1</span>Device            r/s     w/s     rkB/s     wkB/s   rrqm/s   wrqm/s  %rrqm  %wrqm r_await w_await aqu-sz rareq-sz wareq-sz  svctm  %util<span class="token punctuation">..</span>.sda            <span class="token number">273.00</span>    <span class="token number">0.00</span>  <span class="token number">32568.00</span>      <span class="token number">0.00</span>     <span class="token number">0.00</span>     <span class="token number">0.00</span>   <span class="token number">0.00</span>   <span class="token number">0.00</span>    <span class="token number">7.90</span>    <span class="token number">0.00</span>   <span class="token number">1.16</span>   <span class="token number">119.30</span>     <span class="token number">0.00</span>   <span class="token number">3.56</span>  <span class="token number">97.20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>iostat 的输出你应该非常熟悉。观察这个界面，我们发现，磁盘 sda 每秒的读数据为 32 MB， 而 I/O 使用率高达 97% ，接近饱和，这说明，磁盘 sda 的读取确实碰到了性能瓶颈。</p></li><li><p>那要怎么知道，这些 I/O 请求到底是哪些进程导致的呢？当然可以找我们的老朋友， pidstat。接下来，在终端一中，按下 Ctrl+C 停止 iostat 命令，然后运行下面的 pidstat 命令，观察进程的 I/O 情况：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -d 选项表示展示进程的 I/O 情况</span>$ pidstat -d <span class="token number">1</span><span class="token number">12</span>:04:11      <span class="token environment constant">UID</span>       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command<span class="token number">12</span>:04:12      <span class="token number">999</span>     <span class="token number">27458</span>  <span class="token number">32640.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>       <span class="token number">0</span>  mysqld<span class="token number">12</span>:04:12        <span class="token number">0</span>     <span class="token number">27617</span>      <span class="token number">4.00</span>      <span class="token number">4.00</span>      <span class="token number">0.00</span>       <span class="token number">3</span>  python<span class="token number">12</span>:04:12        <span class="token number">0</span>     <span class="token number">27864</span>      <span class="token number">0.00</span>      <span class="token number">4.00</span>      <span class="token number">0.00</span>       <span class="token number">0</span>  systemd-journal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从 pidstat 的输出可以看到，PID 为 27458 的 mysqld 进程正在进行大量的读，而且读取速度是 32 MB/s，跟刚才 iostat 的发现一致。两个结果一对比，我们自然就找到了磁盘 I/O 瓶颈的根源，即 mysqld 进程。</p><p>不过，这事儿还没完。我们自然要怀疑一下，为什么 mysqld 会去读取大量的磁盘数据呢？按照前面猜测，我们提到过，这有可能是个慢查询问题。</p><p>可是，回想一下，慢查询的现象大多是 CPU 使用率高（比如 100% ），但这里看到的却是 I/O 问题。看来，这并不是一个单纯的慢查询问题，我们有必要分析一下 MySQL 读取的数据。</p><p>要分析进程的数据读取，当然还要靠上一节用到过的 strace+ lsof 组合。</p></li><li><p>接下来，还是在终端一中，执行 strace 命令，并且指定 mysqld 的进程号 27458。我们知道，MySQL 是一个多线程的数据库应用，为了不漏掉这些线程的数据读取情况，你要记得在执行 stace 命令时，加上 -f 参数：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">strace</span> -f -p <span class="token number">27458</span><span class="token punctuation">[</span>pid <span class="token number">28014</span><span class="token punctuation">]</span> read<span class="token punctuation">(</span><span class="token number">38</span>, <span class="token string">"934EiwT363aak7VtqF1mHGa4LL4Dhbks"</span><span class="token punctuation">..</span>., <span class="token number">131072</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">131072</span><span class="token punctuation">[</span>pid <span class="token number">28014</span><span class="token punctuation">]</span> read<span class="token punctuation">(</span><span class="token number">38</span>, <span class="token string">"hSs7KBDepBqA6m4ce6i6iUfFTeG9Ot9z"</span><span class="token punctuation">..</span>., <span class="token number">20480</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">20480</span><span class="token punctuation">[</span>pid <span class="token number">28014</span><span class="token punctuation">]</span> read<span class="token punctuation">(</span><span class="token number">38</span>, <span class="token string">"NRhRjCSsLLBjTfdqiBRLvN9K6FRfqqLm"</span><span class="token punctuation">..</span>., <span class="token number">131072</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">131072</span><span class="token punctuation">[</span>pid <span class="token number">28014</span><span class="token punctuation">]</span> read<span class="token punctuation">(</span><span class="token number">38</span>, <span class="token string">"AKgsik4BilLb7y6OkwQUjjqGeCTQTaRl"</span><span class="token punctuation">..</span>., <span class="token number">24576</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">24576</span><span class="token punctuation">[</span>pid <span class="token number">28014</span><span class="token punctuation">]</span> read<span class="token punctuation">(</span><span class="token number">38</span>, <span class="token string">"hFMHx7FzUSqfFI22fQxWCpSnDmRjamaW"</span><span class="token punctuation">..</span>., <span class="token number">131072</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">131072</span><span class="token punctuation">[</span>pid <span class="token number">28014</span><span class="token punctuation">]</span> read<span class="token punctuation">(</span><span class="token number">38</span>, <span class="token string">"ajUzLmKqivcDJSkiw7QWf2ETLgvQIpfC"</span><span class="token punctuation">..</span>., <span class="token number">20480</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">20480</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>观察一会，你会发现，线程 28014 正在读取大量数据，且读取文件的描述符编号为 38。这儿的 38 又对应着哪个文件呢？我们可以执行下面的 lsof 命令，并且指定线程号 28014 ，具体查看这个可疑线程和可疑文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">lsof</span> -p <span class="token number">28014</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>奇怪的是，lsof 并没有给出任何输出。实际上，如果你查看 lsof 命令的返回值，就会发现，这个命令的执行失败了。</p><p>我们知道，在 SHELL 中，特殊标量 $? 表示上一条命令退出时的返回值。查看这个特殊标量，你会发现它的返回值是 1。可是别忘了，在 Linux 中，返回值为 0 ，才表示命令执行成功。返回值为 1，显然表明执行失败。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token variable">$?</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>事实上，通过查询 lsof 的文档，你会发现，-p 参数需要指定进程号，而我们刚才传入的是线程号，所以 lsof 失败了。你看，任何一个细节都可能成为性能分析的“拦路虎”。</p></li><li><p>回过头我们看，mysqld 的进程号是 27458，而 28014 只是它的一个线程。而且，如果你观察 一下 mysqld 进程的线程，你会发现，mysqld 其实还有很多正在运行的其他线程：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -t 表示显示线程，-a 表示显示命令行参数</span>$ pstree -t -a -p <span class="token number">27458</span>mysqld,27458 --log_bin<span class="token operator">=</span>on --sync_binlog<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">..</span>.  ├─<span class="token punctuation">{</span>mysqld<span class="token punctuation">}</span>,27922  ├─<span class="token punctuation">{</span>mysqld<span class="token punctuation">}</span>,27923  └─<span class="token punctuation">{</span>mysqld<span class="token punctuation">}</span>,28014<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>找到了原因，lsof 的问题就容易解决了。把线程号换成进程号，继续执行 lsof 命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">lsof</span> -p <span class="token number">27458</span>COMMAND  PID <span class="token environment constant">USER</span>   FD   TYPE DEVICE SIZE/OFF NODE NAME<span class="token punctuation">..</span>.​mysqld  <span class="token number">27458</span>      <span class="token number">999</span>   38u   REG    <span class="token number">8,1</span> <span class="token number">512440000</span> <span class="token number">2601895</span> /var/lib/mysql/test/products.MYD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这次我们得到了 lsof 的输出。从输出中可以看到， mysqld 进程确实打开了大量文件，而根据文件描述符（FD）的编号，我们知道，描述符为 38 的是一个路径为 /var/lib/mysql/test/products.MYD 的文件。这里注意， 38 后面的 u 表示， mysqld 以读写的方式访问文件。</p><p>看到这个文件，熟悉 MySQL 的你可能笑了：</p><ul><li>MYD 文件，是 MyISAM 引擎用来存储表数据的文件；</li><li>文件名就是数据表的名字；</li><li>而这个文件的父目录，也就是数据库的名字。</li></ul><p>换句话说，这个文件告诉我们，mysqld 在读取数据库 test 中的 products 表。</p></li><li><p>实际上，你可以执行下面的命令，查看 mysqld 在管理数据库 test 时的存储文件。不过要注意，由于 MySQL 运行在容器中，你需要通过 docker exec 到容器中查看：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker <span class="token builtin class-name">exec</span> -it mysql <span class="token function">ls</span> /var/lib/mysql/test/db.opt    products.MYD  products.MYI  products.frm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从这里你可以发现，/var/lib/mysql/test/ 目录中有四个文件，每个文件的作用分别是：</p><ul><li>MYD 文件用来存储表的数据；</li><li>MYI 文件用来存储表的索引；</li><li>frm 文件用来存储表的元信息（比如表结构）；</li><li>opt 文件则用来存储数据库的元信息（比如字符集、字符校验规则等）。</li></ul><p>当然，看到这些，你可能还有一个疑问，那就是，这些文件到底是不是 mysqld 正在使用的数据库文件呢？有没有可能是不再使用的旧数据呢？其实，这个很容易确认，查一下 mysqld 配置的数据路径即可。</p></li><li><p>你可以在终端一中，继续执行下面的命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker <span class="token builtin class-name">exec</span> -i -t mysql mysql -e <span class="token string">'show global variables like "%datadir%";'</span>+---------------+-----------------+<span class="token operator">|</span> Variable_name <span class="token operator">|</span> Value           <span class="token operator">|</span>+---------------+-----------------+<span class="token operator">|</span> datadir       <span class="token operator">|</span> /var/lib/mysql/ <span class="token operator">|</span>+---------------+-----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里可以看到，/var/lib/mysql/ 确实是 mysqld 正在使用的数据存储目录。刚才分析得出的数据库 test 和数据表 products ，都是正在使用。</p><blockquote><p>注：其实 lsof 的结果已经可以确认，它们都是 mysqld 正在访问的文件。再查询 datadir ，只是想换一个思路，进一步确认一下。</p></blockquote></li><li><p>既然已经找出了数据库和表，接下来要做的，就是弄清楚数据库中正在执行什么样的 SQL 了。我们继续在终端一中，运行下面的 docker exec 命令，进入 MySQL 的命令行界面：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker <span class="token builtin class-name">exec</span> -i -t mysql mysql<span class="token punctuation">..</span>.​Type <span class="token string">'help;'</span> or <span class="token string">'\h'</span> <span class="token keyword">for</span> help. Type <span class="token string">'<span class="token entity" title="\c">\c</span>'</span> to <span class="token function">clear</span> the current input statement.​mysql<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>为了保证 SQL 语句不截断，这里我们可以执行 show full processlist 命令。如果一切正常，你应该可以看到如下输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql<span class="token operator">&gt;</span> show full processlist<span class="token punctuation">;</span>+----+------+-----------------+------+---------+------+--------------+-----------------------------------------------------+<span class="token operator">|</span> Id <span class="token operator">|</span> User <span class="token operator">|</span> Host            <span class="token operator">|</span> db   <span class="token operator">|</span> Command <span class="token operator">|</span> Time <span class="token operator">|</span> State        <span class="token operator">|</span> Info                                                <span class="token operator">|</span>+----+------+-----------------+------+---------+------+--------------+-----------------------------------------------------+<span class="token operator">|</span> <span class="token number">27</span> <span class="token operator">|</span> root <span class="token operator">|</span> localhost       <span class="token operator">|</span> <span class="token builtin class-name">test</span> <span class="token operator">|</span> Query   <span class="token operator">|</span>    <span class="token number">0</span> <span class="token operator">|</span> init         <span class="token operator">|</span> show full processlist                               <span class="token operator">|</span><span class="token operator">|</span> <span class="token number">28</span> <span class="token operator">|</span> root <span class="token operator">|</span> <span class="token number">127.0</span>.0.1:42262 <span class="token operator">|</span> <span class="token builtin class-name">test</span> <span class="token operator">|</span> Query   <span class="token operator">|</span>    <span class="token number">1</span> <span class="token operator">|</span> Sending data <span class="token operator">|</span> <span class="token keyword">select</span> * from products where <span class="token assign-left variable">productName</span><span class="token operator">=</span><span class="token string">'geektime'</span> <span class="token operator">|</span>+----+------+-----------------+------+---------+------+--------------+-----------------------------------------------------+<span class="token number">2</span> rows <span class="token keyword">in</span> <span class="token builtin class-name">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个输出中，</p><ul><li>db 表示数据库的名字；</li><li>Command 表示 SQL 类型；</li><li>Time 表示执行时间；</li><li>State 表示状态；</li><li>而 Info 则包含了完整的 SQL 语句。</li></ul><p>多执行几次 show full processlist 命令，你可看到 select * from products where productName=‘geektime’ 这条 SQL 语句的执行时间比较长。</p><p>再回忆一下，案例开始时，我们在终端二查询的产品名称 <a href="http://192.168.0.10:10000/products/geektime，其中的">http://192.168.0.10:10000/products/geektime，其中的</a> geektime 也符合这条查询语句的条件。</p><p>我们知道，MySQL 的慢查询问题，很可能是没有利用好索引导致的，那这条查询语句是不是这样呢？我们又该怎么确认，查询语句是否利用了索引呢？</p></li><li><p>其实，MySQL 内置的 explain 命令，就可以帮你解决这个问题。继续在 MySQL 终端中，运行下面的 explain 命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 切换到 test 库</span>mysql<span class="token operator">&gt;</span> use <span class="token builtin class-name">test</span><span class="token punctuation">;</span><span class="token comment"># 执行 explain 命令</span>mysql<span class="token operator">&gt;</span> explain <span class="token keyword">select</span> * from products where <span class="token assign-left variable">productName</span><span class="token operator">=</span><span class="token string">'geektime'</span><span class="token punctuation">;</span>+----+-------------+----------+------+---------------+------+---------+------+-------+-------------+<span class="token operator">|</span> <span class="token function">id</span> <span class="token operator">|</span> select_type <span class="token operator">|</span> table    <span class="token operator">|</span> <span class="token builtin class-name">type</span> <span class="token operator">|</span> possible_keys <span class="token operator">|</span> key  <span class="token operator">|</span> key_len <span class="token operator">|</span> ref  <span class="token operator">|</span> rows  <span class="token operator">|</span> Extra       <span class="token operator">|</span>+----+-------------+----------+------+---------------+------+---------+------+-------+-------------+<span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> SIMPLE      <span class="token operator">|</span> products <span class="token operator">|</span> ALL  <span class="token operator">|</span> NULL          <span class="token operator">|</span> NULL <span class="token operator">|</span> NULL    <span class="token operator">|</span> NULL <span class="token operator">|</span> <span class="token number">10000</span> <span class="token operator">|</span> Using where <span class="token operator">|</span>+----+-------------+----------+------+---------------+------+---------+------+-------+-------------+<span class="token number">1</span> row <span class="token keyword">in</span> <span class="token builtin class-name">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>观察这次的输出。这个界面中，有几个比较重要的字段需要你注意，我就以这个输出为例，分别解释一下：</p><ul><li>select_type 表示查询类型，而这里的 SIMPLE 表示此查询不包括 UNION 查询或者子查询；</li><li>table 表示数据表的名字，这里是 products；</li><li>type 表示查询类型，这里的 ALL 表示全表查询，但索引查询应该是 index 类型才对；</li><li>possible_keys 表示可能选用的索引，这里是 NULL；</li><li>key 表示确切会使用的索引，这里也是 NULL；</li><li>rows 表示查询扫描的行数，这里是 10000。</li></ul><p>根据这些信息，我们可以确定，这条查询语句压根儿没有使用索引，所以查询时，会扫描全表，并且扫描行数高达 10000 行。响应速度那么慢也就难怪了。</p><p>走到这一步，你应该很容易想到优化方法，没有索引那我们就自己建立，给 productName 建立索引就可以了。不过，增加索引前，你需要先弄清楚，这个表结构到底长什么样儿。</p></li><li><p>执行下面的 MySQL 命令，查询 products 表的结构，你会看到，它只有一个 id 主键，并不包括 productName 的索引：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql<span class="token operator">&gt;</span> show create table products<span class="token punctuation">;</span><span class="token punctuation">..</span>.<span class="token operator">|</span> products <span class="token operator">|</span> CREATE TABLE <span class="token variable"><span class="token variable">`</span>products<span class="token variable">`</span></span> <span class="token punctuation">(</span>  <span class="token variable"><span class="token variable">`</span><span class="token function">id</span><span class="token variable">`</span></span> int<span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> NOT NULL,  <span class="token variable"><span class="token variable">`</span>productCode<span class="token variable">`</span></span> text NOT NULL COMMENT <span class="token string">'产品代码'</span>,  <span class="token variable"><span class="token variable">`</span>productName<span class="token variable">`</span></span> text NOT NULL COMMENT <span class="token string">'产品名称'</span>,<span class="token punctuation">..</span>.  PRIMARY KEY <span class="token punctuation">(</span><span class="token variable"><span class="token variable">`</span><span class="token function">id</span><span class="token variable">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token assign-left variable">ENGINE</span><span class="token operator">=</span>MyISAM DEFAULT <span class="token assign-left variable">CHARSET</span><span class="token operator">=</span>utf8 <span class="token assign-left variable">ROW_FORMAT</span><span class="token operator">=</span>DYNAMIC <span class="token operator">|</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>接下来，我们就可以给 productName 建立索引了，也就是执行下面的 CREATE INDEX 命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql<span class="token operator">&gt;</span> CREATE INDEX products_index ON products <span class="token punctuation">(</span>productName<span class="token punctuation">)</span><span class="token punctuation">;</span>ERROR <span class="token number">1170</span> <span class="token punctuation">(</span><span class="token number">42000</span><span class="token punctuation">)</span>: BLOB/TEXT <span class="token function">column</span> <span class="token string">'productName'</span> used <span class="token keyword">in</span> key specification without a key length<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>不过，醒目的 ERROR 告诉我们，这条命令运行失败了。根据错误信息，productName 是一个 BLOB/TEXT 类型，需要设置一个长度。所以，想要创建索引，就必须为 productName 指定一个前缀长度。</p></li><li><p>那前缀长度设置为多大比较合适呢？这里其实有专门的算法，即通过计算前缀长度的选择性，来确定索引的长度。不过，我们可以稍微简化一下，直接使用一个固定数值（比如 64），执行下面的命令创建索引：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql<span class="token operator">&gt;</span> CREATE INDEX products_index ON products <span class="token punctuation">(</span>productName<span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">))</span><span class="token punctuation">;</span>Query OK, <span class="token number">10000</span> rows affected <span class="token punctuation">(</span><span class="token number">14.45</span> sec<span class="token punctuation">)</span>Records: <span class="token number">10000</span>  Duplicates: <span class="token number">0</span>  Warnings: <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>我们切换到终端二中，查看还在执行的 curl 命令的结果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">Got data: ()in 15.383180141448975 secGot data: ()in 15.384996891021729 secGot data: ()in 0.0021054744720458984 secGot data: ()in 0.003951072692871094 sec<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>显然，查询时间已经从 15 秒缩短到了 3 毫秒。看来，没有索引果然就是这次性能问题的罪魁祸首，解决了索引，就解决了查询慢的问题。</p></li></ol><h4 id="28-2-案例思考"><a href="#28-2-案例思考" class="headerlink" title="28.2 案例思考"></a>28.2 案例思考</h4><p>案例开始时，我们启动的几个容器应用。除了 MySQL 和商品搜索应用外，还有一个 DataService 应用。为什么这个案例开始时，要运行一个看起来毫不相关的应用呢？</p><p>实际上，DataService 是一个严重影响 MySQL 性能的干扰应用。抛开上述索引优化方法不说，这个案例还有一种优化方法，也就是停止 DataService 应用。</p><p>接下来，我们就删除数据库索引，回到原来的状态；然后停止 DataService 应用，看看优化效果如何。</p><ol><li><p>在终端二中停止 curl 命令，然后回到终端一中，执行下面的命令删除索引：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 删除索引</span>$ docker <span class="token builtin class-name">exec</span> -i -t mysql mysql​mysql<span class="token operator">&gt;</span> use <span class="token builtin class-name">test</span><span class="token punctuation">;</span>mysql<span class="token operator">&gt;</span> DROP INDEX products_index ON products<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在终端二中重新运行 curl 命令。当然，这次你会发现，处理时间又变慢了：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token keyword">while</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token function">curl</span> http://192.168.0.10:10000/products/geektime<span class="token punctuation">;</span> <span class="token function">sleep</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token keyword">done</span>Got data: <span class="token punctuation">(</span><span class="token punctuation">)</span>in <span class="token number">16.884345054626465</span> sec<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>再次回到终端一中，执行下面的命令，停止 DataService 应用：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 停止 DataService 应用</span>$ docker <span class="token function">rm</span> -f dataservice<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>最后，我们回到终端二中，观察 curl 的结果：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Got data: <span class="token punctuation">(</span><span class="token punctuation">)</span>in <span class="token number">16.884345054626465</span> secGot data: <span class="token punctuation">(</span><span class="token punctuation">)</span>in <span class="token number">15.238174200057983</span> secGot data: <span class="token punctuation">(</span><span class="token punctuation">)</span>in <span class="token number">0.12604427337646484</span> secGot data: <span class="token punctuation">(</span><span class="token punctuation">)</span>in <span class="token number">0.1101069450378418</span> secGot data: <span class="token punctuation">(</span><span class="token punctuation">)</span>in <span class="token number">0.11235237121582031</span> sec<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 果然，停止 DataService 后，处理时间从 15 秒缩短到了 0.1 秒，虽然比不上增加索引后的 3 毫秒，但相对于 15 秒来说，优化效果还是非常明显的。</p><p> 那么，这种情况下，还有没有 I/O 瓶颈了呢？</p></li><li><p>我们切换到终端一中，运行下面的 vmstat 命令（注意不是 iostat，稍后解释原因），观察 I/O 的变化情况：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">vmstat</span> <span class="token number">1</span>procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r  b   swpd   <span class="token function">free</span>   buff  cache   si   so    bi    bo   <span class="token keyword">in</span>   cs us sy <span class="token function">id</span> wa st <span class="token number">0</span>  <span class="token number">1</span>      <span class="token number">0</span> <span class="token number">6809304</span>   <span class="token number">1368</span> <span class="token number">856744</span>    <span class="token number">0</span>    <span class="token number">0</span> <span class="token number">32640</span>     <span class="token number">0</span>   <span class="token number">52</span>  <span class="token number">478</span>  <span class="token number">1</span>  <span class="token number">0</span> <span class="token number">50</span> <span class="token number">49</span>  <span class="token number">0</span> <span class="token number">0</span>  <span class="token number">1</span>      <span class="token number">0</span> <span class="token number">6776620</span>   <span class="token number">1368</span> <span class="token number">889456</span>    <span class="token number">0</span>    <span class="token number">0</span> <span class="token number">32640</span>     <span class="token number">0</span>   <span class="token number">33</span>  <span class="token number">490</span>  <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">50</span> <span class="token number">49</span>  <span class="token number">0</span> <span class="token number">0</span>  <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">6747540</span>   <span class="token number">1368</span> <span class="token number">918576</span>    <span class="token number">0</span>    <span class="token number">0</span> <span class="token number">29056</span>     <span class="token number">0</span>   <span class="token number">42</span>  <span class="token number">568</span>  <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">56</span> <span class="token number">44</span>  <span class="token number">0</span> <span class="token number">0</span>  <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">6747540</span>   <span class="token number">1368</span> <span class="token number">918576</span>    <span class="token number">0</span>    <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">0</span>   <span class="token number">40</span>  <span class="token number">141</span>  <span class="token number">1</span>  <span class="token number">0</span> <span class="token number">100</span>  <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">0</span>  <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">6747160</span>   <span class="token number">1368</span> <span class="token number">918576</span>    <span class="token number">0</span>    <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">0</span>   <span class="token number">40</span>  <span class="token number">148</span>  <span class="token number">0</span>  <span class="token number">1</span> <span class="token number">99</span>  <span class="token number">0</span>  <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在查看 I/O 情况时，我并没用 iostat 命令，而是用了 vmstat。其实，相对于 iostat 来说，vmstat 可以同时提供 CPU、内存和 I/O 的使用情况。</p></blockquote></li></ol><h4 id="28-3-思考"><a href="#28-3-思考" class="headerlink" title="28.3 思考"></a>28.3 思考</h4><p>停止 DataService 后，商品搜索应用的处理时间，从 15 秒缩短到了 0.1 秒。这是为什么呢？</p><p>我给个小小的提示。你可以先查看 <a href="https://github.com/feiskyer/linux-perf-examples/blob/master/mysql-slow/dataservice.py">dataservice.py</a>，你会发现，DataService 实际上是在读写一个仅包括 “data” 字符串的小文件。不过在读取文件前，它会先把 /proc/sys/vm/drop_caches 改成 1。</p><p>答案：echo 1&gt;/proc/sys/vm/drop_caches表示释放pagecache，也就是文件缓存，而mysql读书的数据就是文件缓存，dataservice不停的释放文件缓存，就导致MySQL都无法利用磁盘缓存，也就慢了。</p><h3 id="29-案例篇：Redis响应严重延迟，如何解决？"><a href="#29-案例篇：Redis响应严重延迟，如何解决？" class="headerlink" title="29 | 案例篇：Redis响应严重延迟，如何解决？"></a>29 | 案例篇：Redis响应严重延迟，如何解决？</h3><h4 id="29-1-案例"><a href="#29-1-案例" class="headerlink" title="29.1 案例"></a>29.1 案例</h4><blockquote><p>机器配置： 2 CPU, 8 GB 内存。</p><p>安装软件：<code>apt install docker.io sysstat</code>。</p></blockquote><p>今天的案例由 Python 应用 +Redis 两部分组成。其中，Python 应用是一个基于 Flask 的应用，它会利用 Redis ，来管理应用程序的缓存，并对外提供三个 HTTP 接口：</p><ul><li><p>/：返回 hello redis；</p></li><li><p>/init/：插入指定数量的缓存数据，如果不指定数量，默认的是 5000 条；</p><p>  缓存的键格式为 uuid；</p><p>  缓存的值为 good、bad 或 normal 三者之一。</p></li><li><p>/get_cache/<type_name>：查询指定值的缓存数据，并返回处理时间。其中，type_name 参数只支持 good, bad 和 normal（也就是找出具有相同 value 的 key 列表）。</type_name></p></li></ul><ol><li><p>在第一个终端中，执行下面的命令，运行本次案例要分析的目标应用。正常情况下，你应该可以看到下面的输出：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 注意下面的随机字符串是容器 ID，每次运行均会不同，并且你不需要关注它</span>$ docker run --name<span class="token operator">=</span>redis -itd -p <span class="token number">10000</span>:80 feisky/redis-serverec41cb9e4dd5cb7079e1d9f72b7cee7de67278dbd3bd0956b4c0846bff211803$ docker run --name<span class="token operator">=</span>app --network<span class="token operator">=</span>container:redis -itd feisky/redis-app2c54eb252d0552448320d9155a2618b799a1e71d7289ec7277a61e72a9de5fd0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>然后，再运行 docker ps 命令，确认两个容器都处于运行（Up）状态：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker <span class="token function">ps</span>CONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS              PORTS                             NAMES2c54eb252d05        feisky/redis-app      <span class="token string">"python /app.py"</span>         <span class="token number">48</span> seconds ago      Up <span class="token number">47</span> seconds                                         appec41cb9e4dd5        feisky/redis-server   <span class="token string">"docker-entrypoint.s…"</span>   <span class="token number">49</span> seconds ago      Up <span class="token number">48</span> seconds       <span class="token number">6379</span>/tcp, <span class="token number">0.0</span>.0.0:10000-<span class="token operator">&gt;</span><span class="token number">80</span>/tcp   redis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>我们切换到第二个终端，使用 curl 工具，访问应用首页。如果你看到 hello redis 的输出，说明应用正常启动：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">curl</span> http://192.168.0.10:10000/hello redis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>接下来，继续在终端二中，执行下面的 curl 命令，来调用应用的 /init 接口，初始化 Redis 缓存，并且插入 5000 条缓存信息。这个过程比较慢，比如我的机器就花了十几分钟时间。耐心等一会儿后，你会看到下面这行输出：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 案例插入 5000 条数据，在实践时可以根据磁盘的类型适当调整，比如使用 SSD 时可以调大，而 HDD 可以适当调小</span>$ <span class="token function">curl</span> http://192.168.0.10:10000/init/5000<span class="token punctuation">{</span><span class="token string">"elapsed_seconds"</span>:30.26814079284668,<span class="token string">"keys_initialized"</span>:5000<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>继续执行下一个命令，访问应用的缓存查询接口。如果一切正常，你会看到如下输出：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">curl</span> http://192.168.0.10:10000/get_cache<span class="token punctuation">{</span><span class="token string">"count"</span>:1677,<span class="token string">"data"</span>:<span class="token punctuation">[</span><span class="token string">"d97662fa-06ac-11e9-92c7-0242ac110002"</span>,<span class="token punctuation">..</span>.<span class="token punctuation">]</span>,<span class="token string">"elapsed_seconds"</span>:10.545469760894775,<span class="token string">"type"</span><span class="token builtin class-name">:</span><span class="token string">"good"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>为了避免分析过程中客户端的请求结束，在进行性能分析前，我们先要把 curl 命令放到一个循环里来执行。你可以在终端二中，继续执行下面的命令：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token keyword">while</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token function">curl</span> http://192.168.0.10:10000/get_cache<span class="token punctuation">;</span> <span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>在终端一中执行 top 命令，分析系统的 CPU 使用情况：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">top</span><span class="token function">top</span> - <span class="token number">12</span>:46:18 up <span class="token number">11</span> days,  <span class="token number">8</span>:49,  <span class="token number">1</span> user,  load average: <span class="token number">1.36</span>, <span class="token number">1.36</span>, <span class="token number">1.04</span>Tasks: <span class="token number">137</span> total,   <span class="token number">1</span> running,  <span class="token number">79</span> sleeping,   <span class="token number">0</span> stopped,   <span class="token number">0</span> zombie%Cpu0  <span class="token builtin class-name">:</span>  <span class="token number">6.0</span> us,  <span class="token number">2.7</span> sy,  <span class="token number">0.0</span> ni,  <span class="token number">5.7</span> id, <span class="token number">84.7</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">1.0</span> si,  <span class="token number">0.0</span> st%Cpu1  <span class="token builtin class-name">:</span>  <span class="token number">1.0</span> us,  <span class="token number">3.0</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">94.7</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">1.3</span> si,  <span class="token number">0.0</span> stKiB Mem <span class="token builtin class-name">:</span>  <span class="token number">8169300</span> total,  <span class="token number">7342244</span> free,   <span class="token number">432912</span> used,   <span class="token number">394144</span> buff/cacheKiB Swap:        <span class="token number">0</span> total,        <span class="token number">0</span> free,        <span class="token number">0</span> used.  <span class="token number">7478748</span> avail Mem  PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND <span class="token number">9181</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">193004</span>  <span class="token number">27304</span>   <span class="token number">8716</span> S   <span class="token number">8.6</span>  <span class="token number">0.3</span>   <span class="token number">0</span>:07.15 python <span class="token number">9085</span> systemd+  <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">28352</span>   <span class="token number">9760</span>   <span class="token number">1860</span> D   <span class="token number">5.0</span>  <span class="token number">0.1</span>   <span class="token number">0</span>:04.34 redis-server  <span class="token number">368</span> root      <span class="token number">20</span>   <span class="token number">0</span>       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> D   <span class="token number">1.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:33.88 jbd2/sda1-8  <span class="token number">149</span> root       <span class="token number">0</span> -20       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> I   <span class="token number">0.3</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:10.63 kworker/0:1H <span class="token number">1549</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">236716</span>  <span class="token number">24576</span>   <span class="token number">9864</span> S   <span class="token number">0.3</span>  <span class="token number">0.3</span>  <span class="token number">91</span>:37.30 python3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 观察 top 的输出可以发现，CPU0 的 iowait 比较高，已经达到了 84%；而各个进程的 CPU 使用率都不太高，最高的 python 和 redis-server ，也分别只有 8% 和 5%。再看内存，总内存 8GB，剩余内存还有 7GB 多，显然内存也没啥问题。</p><p> 综合 top 的信息，最有嫌疑的就是 iowait。所以，接下来还是要继续分析，是不是 I/O 问题。</p></li><li><p>还在第一个终端中，先按下 Ctrl+C，停止 top 命令；然后，执行下面的 iostat 命令，查看有没有 I/O 性能问题：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ iostat -d -x <span class="token number">1</span>Device            r/s     w/s     rkB/s     wkB/s   rrqm/s   wrqm/s  %rrqm  %wrqm r_await w_await aqu-sz rareq-sz wareq-sz  svctm  %util<span class="token punctuation">..</span>.sda              <span class="token number">0.00</span>  <span class="token number">492.00</span>      <span class="token number">0.00</span>   <span class="token number">2672.00</span>     <span class="token number">0.00</span>   <span class="token number">176.00</span>   <span class="token number">0.00</span>  <span class="token number">26.35</span>    <span class="token number">0.00</span>    <span class="token number">1.76</span>   <span class="token number">0.00</span>     <span class="token number">0.00</span>     <span class="token number">5.43</span>   <span class="token number">0.00</span>   <span class="token number">0.00</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 观察 iostat 的输出，我们发现，磁盘 sda 每秒的写数据（wkB/s）为 2.5MB，I/O 使用率（%util）是 0。看来，虽然有些 I/O 操作，但并没导致磁盘的 I/O 瓶颈。</p><p> 排查一圈儿下来，CPU 和内存使用没问题，I/O 也没有瓶颈，接下来好像就没啥分析方向了？</p><p> 回想一下，今天的案例问题是从 Redis 缓存中查询数据慢。对查询来说，对应的 I/O 应该是磁盘的读操作，但刚才我们用 iostat 看到的却是写操作。虽说 I/O 本身并没有性能瓶颈，但这里的磁盘写也是比较奇怪的。为什么会有磁盘写呢？那我们就得知道，到底是哪个进程在写磁盘。</p></li><li><p>要知道 I/O 请求来自哪些进程，还是要靠我们的老朋友 pidstat。在终端一中运行下面的 pidstat 命令，观察进程的 I/O 情况：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ pidstat -d <span class="token number">1</span><span class="token number">12</span>:49:35      <span class="token environment constant">UID</span>       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command<span class="token number">12</span>:49:36        <span class="token number">0</span>       <span class="token number">368</span>      <span class="token number">0.00</span>     <span class="token number">16.00</span>      <span class="token number">0.00</span>      <span class="token number">86</span>  jbd2/sda1-8<span class="token number">12</span>:49:36      <span class="token number">100</span>      <span class="token number">9085</span>      <span class="token number">0.00</span>    <span class="token number">636.00</span>      <span class="token number">0.00</span>       <span class="token number">1</span>  redis-server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 从 pidstat 的输出，我们看到，I/O 最多的进程是 PID 为 9085 的 redis-server，并且它也刚好是在写磁盘。这说明，确实是 redis-server 在进行磁盘写。</p><p> 当然，光找到读写磁盘的进程还不够，我们还要再用 strace+lsof 组合，看看 redis-server 到底在写什么。</p></li><li><p>接下来，还是在终端一中，执行 strace 命令，并且指定 redis-server 的进程号 9085：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -f 表示跟踪子进程和子线程，-T 表示显示系统调用的时长，-tt 表示显示跟踪时间</span>$ <span class="token function">strace</span> -f -T -tt -p <span class="token number">9085</span><span class="token punctuation">[</span>pid  <span class="token number">9085</span><span class="token punctuation">]</span> <span class="token number">14</span>:20:16.826131 epoll_pwait<span class="token punctuation">(</span><span class="token number">5</span>, <span class="token punctuation">[</span><span class="token punctuation">{</span>EPOLLIN, <span class="token punctuation">{</span>u32<span class="token operator">=</span><span class="token number">8</span>, <span class="token assign-left variable">u64</span><span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">]</span>, <span class="token number">10128</span>, <span class="token number">65</span>, NULL, <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;</span><span class="token number">0.00005</span><span class="token operator"><span class="token file-descriptor important">5</span>&gt;</span><span class="token punctuation">[</span>pid  <span class="token number">9085</span><span class="token punctuation">]</span> <span class="token number">14</span>:20:16.826301 read<span class="token punctuation">(</span><span class="token number">8</span>, <span class="token string">"*2<span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span><span class="token variable">$3</span><span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span>GET<span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span><span class="token variable">$41</span><span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span>uuid:5b2e76cc-"</span><span class="token punctuation">..</span>., <span class="token number">16384</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">61</span> <span class="token operator">&lt;</span><span class="token number">0.00007</span><span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token punctuation">[</span>pid  <span class="token number">9085</span><span class="token punctuation">]</span> <span class="token number">14</span>:20:16.826477 read<span class="token punctuation">(</span><span class="token number">3</span>, 0x7fff366a5747, <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> -1 EAGAIN <span class="token punctuation">(</span>Resource temporarily unavailable<span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token number">0.00006</span><span class="token operator"><span class="token file-descriptor important">3</span>&gt;</span><span class="token punctuation">[</span>pid  <span class="token number">9085</span><span class="token punctuation">]</span> <span class="token number">14</span>:20:16.826645 write<span class="token punctuation">(</span><span class="token number">8</span>, <span class="token string">"<span class="token variable">$3</span><span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span>bad<span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span>"</span>, <span class="token number">9</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">9</span> <span class="token operator">&lt;</span><span class="token number">0.00017</span><span class="token operator"><span class="token file-descriptor important">3</span>&gt;</span><span class="token punctuation">[</span>pid  <span class="token number">9085</span><span class="token punctuation">]</span> <span class="token number">14</span>:20:16.826907 epoll_pwait<span class="token punctuation">(</span><span class="token number">5</span>, <span class="token punctuation">[</span><span class="token punctuation">{</span>EPOLLIN, <span class="token punctuation">{</span>u32<span class="token operator">=</span><span class="token number">8</span>, <span class="token assign-left variable">u64</span><span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">]</span>, <span class="token number">10128</span>, <span class="token number">65</span>, NULL, <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;</span><span class="token number">0.00003</span><span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token punctuation">[</span>pid  <span class="token number">9085</span><span class="token punctuation">]</span> <span class="token number">14</span>:20:16.827030 read<span class="token punctuation">(</span><span class="token number">8</span>, <span class="token string">"*2<span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span><span class="token variable">$3</span><span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span>GET<span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span><span class="token variable">$41</span><span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span>uuid:55862ada-"</span><span class="token punctuation">..</span>., <span class="token number">16384</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">61</span> <span class="token operator">&lt;</span><span class="token number">0.00004</span><span class="token operator"><span class="token file-descriptor important">4</span>&gt;</span><span class="token punctuation">[</span>pid  <span class="token number">9085</span><span class="token punctuation">]</span> <span class="token number">14</span>:20:16.827149 read<span class="token punctuation">(</span><span class="token number">3</span>, 0x7fff366a5747, <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> -1 EAGAIN <span class="token punctuation">(</span>Resource temporarily unavailable<span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token number">0.00004</span><span class="token operator"><span class="token file-descriptor important">3</span>&gt;</span><span class="token punctuation">[</span>pid  <span class="token number">9085</span><span class="token punctuation">]</span> <span class="token number">14</span>:20:16.827285 write<span class="token punctuation">(</span><span class="token number">8</span>, <span class="token string">"<span class="token variable">$3</span><span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span>bad<span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span>"</span>, <span class="token number">9</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">9</span> <span class="token operator">&lt;</span><span class="token number">0.00014</span><span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token punctuation">[</span>pid  <span class="token number">9085</span><span class="token punctuation">]</span> <span class="token number">14</span>:20:16.827514 epoll_pwait<span class="token punctuation">(</span><span class="token number">5</span>, <span class="token punctuation">[</span><span class="token punctuation">{</span>EPOLLIN, <span class="token punctuation">{</span>u32<span class="token operator">=</span><span class="token number">8</span>, <span class="token assign-left variable">u64</span><span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">]</span>, <span class="token number">10128</span>, <span class="token number">64</span>, NULL, <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;</span><span class="token number">0.00004</span><span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span><span class="token punctuation">[</span>pid  <span class="token number">9085</span><span class="token punctuation">]</span> <span class="token number">14</span>:20:16.827641 read<span class="token punctuation">(</span><span class="token number">8</span>, <span class="token string">"*2<span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span><span class="token variable">$3</span><span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span>GET<span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span><span class="token variable">$41</span><span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span>uuid:53522908-"</span><span class="token punctuation">..</span>., <span class="token number">16384</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">61</span> <span class="token operator">&lt;</span><span class="token number">0.00004</span><span class="token operator"><span class="token file-descriptor important">3</span>&gt;</span><span class="token punctuation">[</span>pid  <span class="token number">9085</span><span class="token punctuation">]</span> <span class="token number">14</span>:20:16.827784 read<span class="token punctuation">(</span><span class="token number">3</span>, 0x7fff366a5747, <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> -1 EAGAIN <span class="token punctuation">(</span>Resource temporarily unavailable<span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token number">0.00003</span><span class="token operator"><span class="token file-descriptor important">4</span>&gt;</span><span class="token punctuation">[</span>pid  <span class="token number">9085</span><span class="token punctuation">]</span> <span class="token number">14</span>:20:16.827945 write<span class="token punctuation">(</span><span class="token number">8</span>, <span class="token string">"<span class="token variable">$4</span><span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span>good<span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span>"</span>, <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">&lt;</span><span class="token number">0.00028</span><span class="token operator"><span class="token file-descriptor important">8</span>&gt;</span><span class="token punctuation">[</span>pid  <span class="token number">9085</span><span class="token punctuation">]</span> <span class="token number">14</span>:20:16.828339 epoll_pwait<span class="token punctuation">(</span><span class="token number">5</span>, <span class="token punctuation">[</span><span class="token punctuation">{</span>EPOLLIN, <span class="token punctuation">{</span>u32<span class="token operator">=</span><span class="token number">8</span>, <span class="token assign-left variable">u64</span><span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">]</span>, <span class="token number">10128</span>, <span class="token number">63</span>, NULL, <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;</span><span class="token number">0.00005</span><span class="token operator"><span class="token file-descriptor important">7</span>&gt;</span><span class="token punctuation">[</span>pid  <span class="token number">9085</span><span class="token punctuation">]</span> <span class="token number">14</span>:20:16.828486 read<span class="token punctuation">(</span><span class="token number">8</span>, <span class="token string">"*3<span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span><span class="token variable">$4</span><span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span>SADD<span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span><span class="token variable">$4</span><span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span>good<span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span><span class="token variable">$36</span><span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span>535"</span><span class="token punctuation">..</span>., <span class="token number">16384</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">67</span> <span class="token operator">&lt;</span><span class="token number">0.00004</span><span class="token operator"><span class="token file-descriptor important">0</span>&gt;</span><span class="token punctuation">[</span>pid  <span class="token number">9085</span><span class="token punctuation">]</span> <span class="token number">14</span>:20:16.828623 read<span class="token punctuation">(</span><span class="token number">3</span>, 0x7fff366a5747, <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> -1 EAGAIN <span class="token punctuation">(</span>Resource temporarily unavailable<span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token number">0.00005</span><span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token punctuation">[</span>pid  <span class="token number">9085</span><span class="token punctuation">]</span> <span class="token number">14</span>:20:16.828760 write<span class="token punctuation">(</span><span class="token number">7</span>, <span class="token string">"*3<span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span><span class="token variable">$4</span><span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span>SADD<span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span><span class="token variable">$4</span><span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span>good<span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span><span class="token variable">$36</span><span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span>535"</span><span class="token punctuation">..</span>., <span class="token number">67</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">67</span> <span class="token operator">&lt;</span><span class="token number">0.00006</span><span class="token operator"><span class="token file-descriptor important">0</span>&gt;</span><span class="token punctuation">[</span>pid  <span class="token number">9085</span><span class="token punctuation">]</span> <span class="token number">14</span>:20:16.828970 fdatasync<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">&lt;</span><span class="token number">0.00541</span><span class="token operator"><span class="token file-descriptor important">5</span>&gt;</span><span class="token punctuation">[</span>pid  <span class="token number">9085</span><span class="token punctuation">]</span> <span class="token number">14</span>:20:16.834493 write<span class="token punctuation">(</span><span class="token number">8</span>, <span class="token string">":1<span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span>"</span>, <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">4</span> <span class="token operator">&lt;</span><span class="token number">0.00025</span><span class="token operator"><span class="token file-descriptor important">0</span>&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>事实上，从系统调用来看， epoll_pwait、read、write、fdatasync 这些系统调用都比较频繁。那么，刚才观察到的写磁盘，应该就是 write 或者 fdatasync 导致的了。</p></li><li><p>接着再来运行 lsof 命令，找出这些系统调用的操作对象：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">lsof</span> -p <span class="token number">9085</span>redis-ser <span class="token number">9085</span> systemd-network    3r     FIFO   <span class="token number">0,12</span>      0t0 <span class="token number">15447970</span> piperedis-ser <span class="token number">9085</span> systemd-network    4w     FIFO   <span class="token number">0,12</span>      0t0 <span class="token number">15447970</span> piperedis-ser <span class="token number">9085</span> systemd-network    5u  a_inode   <span class="token number">0,13</span>        <span class="token number">0</span>    <span class="token number">10179</span> <span class="token punctuation">[</span>eventpoll<span class="token punctuation">]</span>redis-ser <span class="token number">9085</span> systemd-network    6u     sock    <span class="token number">0,9</span>      0t0 <span class="token number">15447972</span> protocol: TCPredis-ser <span class="token number">9085</span> systemd-network    7w      REG    <span class="token number">8,1</span>  <span class="token number">8830146</span>  <span class="token number">2838532</span> /data/appendonly.aofredis-ser <span class="token number">9085</span> systemd-network    8u     sock    <span class="token number">0,9</span>      0t0 <span class="token number">15448709</span> protocol: TCP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在你会发现，描述符编号为 3 的是一个 pipe 管道，5 号是 eventpoll，7 号是一个普通文件，而 8 号是一个 TCP socket。</p><p>结合磁盘写的现象，我们知道，只有 7 号普通文件才会产生磁盘写，而它操作的文件路径是 /data/appendonly.aof，相应的系统调用包括 write 和 fdatasync。</p><p>如果你对 Redis 的持久化配置比较熟，看到这个文件路径以及 fdatasync 的系统调用，你应该能想到，这对应着正是 Redis 持久化配置中的 appendonly 和 appendfsync 选项。很可能是因为它们的配置不合理，导致磁盘写比较多。</p><p>接下来就验证一下这个猜测，我们可以通过 Redis 的命令行工具，查询这两个选项的配置。</p></li><li><p>继续在终端一中，运行下面的命令，查询 appendonly 和 appendfsync 的配置：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker <span class="token builtin class-name">exec</span> -it redis redis-cli config get <span class="token string">'append*'</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"appendfsync"</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"always"</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"appendonly"</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">"yes"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从这个结果你可以发现，appendfsync 配置的是 always，而 appendonly 配置的是 yes。这两个选项的详细含义，你可以从 <a href="https://redis.io/topics/persistence">Redis Persistence</a> 的文档中查到，这里我做一下简单介绍。</p><p>Redis 提供了两种数据持久化的方式，分别是快照和追加文件。</p><ol><li><p>快照方式，会按照指定的时间间隔，生成数据的快照，并且保存到磁盘文件中。为了避免阻塞主进程，Redis 还会 fork 出一个子进程，来负责快照的保存。这种方式的性能好，无论是备份还是恢复，都比追加文件好很多。</p><p> 不过，它的缺点也很明显。在数据量大时，fork 子进程需要用到比较大的内存，保存数据也很耗时。所以，你需要设置一个比较长的时间间隔来应对，比如至少 5 分钟。这样，如果发生故障，你丢失的就是几分钟的数据。</p></li><li><p>追加文件，则是用在文件末尾追加记录的方式，对 Redis 写入的数据，依次进行持久化，所以它的持久化也更安全。</p><p> 此外，它还提供了一个用 appendfsync 选项设置 fsync 的策略，确保写入的数据都落到磁盘中，具体选项包括 always、everysec、no 等。</p><ul><li>always 表示，每个操作都会执行一次 fsync，是最为安全的方式；</li><li>everysec 表示，每秒钟调用一次 fsync ，这样可以保证即使是最坏情况下，也只丢失 1 秒的数据；</li><li>而 no 表示交给操作系统来处理。</li></ul></li></ol><p>回忆一下我们刚刚看到的配置，appendfsync 配置的是 always，意味着每次写数据时，都会调用一次 fsync，从而造成比较大的磁盘 I/O 压力。</p><p>当然，你还可以用 strace ，观察这个系统调用的执行情况。比如通过 -e 选项指定 fdatasync 后，你就会得到下面的结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">strace</span> -f -p <span class="token number">9085</span> -T -tt -e fdatasyncstrace: Process <span class="token number">9085</span> attached with <span class="token number">4</span> threads<span class="token punctuation">[</span>pid  <span class="token number">9085</span><span class="token punctuation">]</span> <span class="token number">14</span>:22:52.013547 fdatasync<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">&lt;</span><span class="token number">0.00711</span><span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token punctuation">[</span>pid  <span class="token number">9085</span><span class="token punctuation">]</span> <span class="token number">14</span>:22:52.022467 fdatasync<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">&lt;</span><span class="token number">0.00857</span><span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token punctuation">[</span>pid  <span class="token number">9085</span><span class="token punctuation">]</span> <span class="token number">14</span>:22:52.032223 fdatasync<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">&lt;</span><span class="token number">0.00676</span><span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span><span class="token punctuation">..</span>.<span class="token punctuation">[</span>pid  <span class="token number">9085</span><span class="token punctuation">]</span> <span class="token number">14</span>:22:52.139629 fdatasync<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">&lt;</span><span class="token number">0.00818</span><span class="token operator"><span class="token file-descriptor important">3</span>&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从这里你可以看到，每隔 10ms 左右，就会有一次 fdatasync 调用，并且每次调用本身也要消耗 7~8ms。</p><p>不管哪种方式，都可以验证我们的猜想，配置确实不合理。这样，我们就找出了 Redis 正在进行写入的文件，也知道了产生大量 I/O 的原因。</p></li><li><p>不过，回到最初的疑问，为什么查询时会有磁盘写呢？按理来说不应该只有数据的读取吗？这就需要我们再来审查一下 strace -f -T -tt -p 9085 的结果。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">read<span class="token punctuation">(</span><span class="token number">8</span>, <span class="token string">"*2<span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span><span class="token variable">$3</span><span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span>GET<span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span><span class="token variable">$41</span><span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span>uuid:53522908-"</span><span class="token punctuation">..</span>., <span class="token number">16384</span><span class="token punctuation">)</span>write<span class="token punctuation">(</span><span class="token number">8</span>, <span class="token string">"<span class="token variable">$4</span><span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span>good<span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span>"</span>, <span class="token number">10</span><span class="token punctuation">)</span>read<span class="token punctuation">(</span><span class="token number">8</span>, <span class="token string">"*3<span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span><span class="token variable">$4</span><span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span>SADD<span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span><span class="token variable">$4</span><span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span>good<span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span><span class="token variable">$36</span><span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span>535"</span><span class="token punctuation">..</span>., <span class="token number">16384</span><span class="token punctuation">)</span>write<span class="token punctuation">(</span><span class="token number">7</span>, <span class="token string">"*3<span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span><span class="token variable">$4</span><span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span>SADD<span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span><span class="token variable">$4</span><span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span>good<span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span><span class="token variable">$36</span><span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span>535"</span><span class="token punctuation">..</span>., <span class="token number">67</span><span class="token punctuation">)</span>write<span class="token punctuation">(</span><span class="token number">8</span>, <span class="token string">":1<span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span>"</span>, <span class="token number">4</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>细心的你应该记得，根据 lsof 的分析，文件描述符编号为 7 的是一个普通文件 /data/appendonly.aof，而编号为 8 的是 TCP socket。而观察上面的内容，8 号对应的 TCP 读写，是一个标准的“请求 - 响应”格式，即：</p><ul><li>从 socket 读取 GET uuid:53522908-… 后，响应 good；</li><li>再从 socket 读取 SADD good 535… 后，响应 1。</li></ul><p>对 Redis 来说，SADD 是一个写操作，所以 Redis 还会把它保存到用于持久化的 appendonly.aof 文件中。</p><p>观察更多的 strace 结果，你会发现，每当 GET 返回 good 时，随后都会有一个 SADD 操作，这也就导致了，明明是查询接口，Redis 却有大量的磁盘写。</p><p>到这里，我们就找出了 Redis 写磁盘的原因。不过，在下最终结论前，我们还是要确认一下，8 号 TCP socket 对应的 Redis 客户端，到底是不是我们的案例应用。</p><p>我们可以给 lsof 命令加上 -i 选项，找出 TCP socket 对应的 TCP 连接信息。不过，由于 Redis 和 Python 应用都在容器中运行，我们需要进入容器的网络命名空间内部，才能看到完整的 TCP 连接。</p></li><li><p>还是在终端一中，运行下面的命令：</p><blockquote><p>注意：下面的命令用到的 <a href="http://man7.org/linux/man-pages/man1/nsenter.1.html">nsenter</a> 工具，可以进入容器命名空间。如果你的系统没有安装，请运行下面命令安装 nsenter：</p><p>docker run —rm -v /usr/local/bin:/target jpetazzo/nsenter</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 由于这两个容器共享同一个网络命名空间，所以我们只需要进入 app 的网络命名空间即可</span>$ <span class="token assign-left variable">PID</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>docker inspect --format <span class="token punctuation">{</span><span class="token punctuation">{</span>.State.Pid<span class="token punctuation">}</span><span class="token punctuation">}</span> app<span class="token variable">)</span></span><span class="token comment"># -i 表示显示网络套接字信息</span>$ nsenter --target <span class="token variable">$PID</span> --net -- <span class="token function">lsof</span> -iCOMMAND    PID            <span class="token environment constant">USER</span>   FD   TYPE   DEVICE SIZE/OFF NODE NAMEredis-ser <span class="token number">9085</span> systemd-network    6u  IPv4 <span class="token number">15447972</span>      0t0  TCP localhost:6379 <span class="token punctuation">(</span>LISTEN<span class="token punctuation">)</span>redis-ser <span class="token number">9085</span> systemd-network    8u  IPv4 <span class="token number">15448709</span>      0t0  TCP localhost:6379-<span class="token operator">&gt;</span>localhost:32996 <span class="token punctuation">(</span>ESTABLISHED<span class="token punctuation">)</span>python    <span class="token number">9181</span>            root    3u  IPv4 <span class="token number">15448677</span>      0t0  TCP *:http <span class="token punctuation">(</span>LISTEN<span class="token punctuation">)</span>python    <span class="token number">9181</span>            root    5u  IPv4 <span class="token number">15449632</span>      0t0  TCP localhost:32996-<span class="token operator">&gt;</span>localhost:6379 <span class="token punctuation">(</span>ESTABLISHED<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，redis-server 的 8 号文件描述符，对应 TCP 连接 localhost:6379-&gt;localhost:32996。其中， localhost:6379 是 redis-server 自己的监听端口，自然 localhost:32996 就是 redis 的客户端。再观察最后一行，localhost:32996 对应的，正是我们的 Python 应用程序（进程号为 9181）。</p><p>历经各种波折，我们总算找出了 Redis 响应延迟的潜在原因。总结一下，我们找到两个问题。</p><ul><li>第一个问题，Redis 配置的 appendfsync 是 always，这就导致 Redis 每次的写操作，都会触发 fdatasync 系统调用。今天的案例，没必要用这么高频的同步写，使用默认的 1s 时间间隔，就足够了。</li><li>第二个问题，Python 应用在查询接口中会调用 Redis 的 SADD 命令，这很可能是不合理使用缓存导致的。</li></ul></li><li><p>对于第一个配置问题，我们可以执行下面的命令，把 appendfsync 改成 everysec：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker <span class="token builtin class-name">exec</span> -it redis redis-cli config <span class="token builtin class-name">set</span> appendfsync everysecOK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>改完后，切换到终端二中查看，你会发现，现在的请求时间，已经缩短到了 0.9s：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">{..., "elapsed_seconds":0.9368953704833984,"type":"good"}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>而第二个问题，就要查看应用的源码了。点击 <a href="https://github.com/feiskyer/linux-perf-examples/blob/master/redis-slow/app.py">Github</a> ，你就可以查看案例应用的源代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_cache</span><span class="token punctuation">(</span>type_name<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">'''handler for /get_cache'''</span>    <span class="token keyword">for</span> key <span class="token keyword">in</span> redis_client<span class="token punctuation">.</span>scan_iter<span class="token punctuation">(</span><span class="token string">"uuid:*"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        value <span class="token operator">=</span> redis_client<span class="token punctuation">.</span>get<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        <span class="token keyword">if</span> value <span class="token operator">==</span> type_name<span class="token punctuation">:</span>            redis_client<span class="token punctuation">.</span>sadd<span class="token punctuation">(</span>type_name<span class="token punctuation">,</span> key<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    data <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>redis_client<span class="token punctuation">.</span>smembers<span class="token punctuation">(</span>type_name<span class="token punctuation">)</span><span class="token punctuation">)</span>    redis_client<span class="token punctuation">.</span>delete<span class="token punctuation">(</span>type_name<span class="token punctuation">)</span>    <span class="token keyword">return</span> jsonify<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"type"</span><span class="token punctuation">:</span> type_name<span class="token punctuation">,</span> <span class="token string">'count'</span><span class="token punctuation">:</span> <span class="token builtin">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'data'</span><span class="token punctuation">:</span> data<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>果然，Python 应用把 Redis 当成临时空间，用来存储查询过程中找到的数据。不过我们知道，这些数据放内存中就可以了，完全没必要再通过网络调用存储到 Redis 中。</p><p>基于这个思路，我把修改后的代码也推送到了相同的源码文件中，你可以通过 <a href="http://192.168.0.10:10000/get_cache_data">http://192.168.0.10:10000/get_cache_data</a> 这个接口来访问它。</p></li><li><p>我们切换到终端二，按 Ctrl+C 停止之前的 curl 命令；然后执行下面的 curl 命令，调用 <a href="http://192.168.0.10:10000/get_cache_data">http://192.168.0.10:10000/get_cache_data</a> 新接口：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token keyword">while</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token function">curl</span> http://192.168.0.10:10000/get_cache_data<span class="token punctuation">;</span> <span class="token keyword">done</span><span class="token punctuation">{</span><span class="token punctuation">..</span>.,<span class="token string">"elapsed_seconds"</span>:0.16034674644470215,<span class="token string">"type"</span><span class="token builtin class-name">:</span><span class="token string">"good"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="30-套路篇：如何迅速分析出系统I-O的瓶颈在哪里？"><a href="#30-套路篇：如何迅速分析出系统I-O的瓶颈在哪里？" class="headerlink" title="30 | 套路篇：如何迅速分析出系统I/O的瓶颈在哪里？"></a>30 | 套路篇：如何迅速分析出系统I/O的瓶颈在哪里？</h3></li></ol><h4 id="30-1-性能指标"><a href="#30-1-性能指标" class="headerlink" title="30.1 性能指标"></a>30.1 性能指标</h4><p><img src="/images/《Linux性能优化实战》学习笔记/Linux存储系统的IO栈全景图.png" alt="Linux存储系统的IO栈全景图"></p><ol><li><p>文件系统 I/O 性能指标</p><ol><li><p><strong>首先，最容易想到的是存储空间的使用情况，包括容量、使用量以及剩余空间等。</strong></p><p> 不过要注意，这些只是文件系统向外展示的空间使用，而非在磁盘空间的真实用量，因为文件系统的元数据也会占用磁盘空间。</p><p> 而且，如果你配置了 RAID，从文件系统看到的使用量跟实际磁盘的占用空间，也会因为 RAID 级别的不同而不一样。比方说，配置 RAID10 后，你从文件系统最多也只能看到所有磁盘容量的一半。</p><p> 除了数据本身的存储空间，还有一个<strong>容易忽略的是索引节点的使用情况，它也包括容量、使用量以及剩余量等三个指标</strong>。如果文件系统中存储过多的小文件，就可能碰到索引节点容量已满的问题。</p></li><li><p><strong>其次，你应该想到的是前面多次提到过的缓存使用情况，包括页缓存、目录项缓存、索引节点缓存以及各个具体文件系统（如 ext4、XFS 等）的缓存</strong>。这些缓存会使用速度更快的内存，用来临时存储文件数据或者文件系统的元数据，从而可以减少访问慢速磁盘的次数。</p></li><li><p>除了以上这两点，文件 I/O 也是很重要的性能指标，包括 IOPS（包括 r/s 和 w/s）、响应时间（延迟）以及吞吐量（B/s）等。在考察这类指标时，通常还要考虑实际文件的读写情况。比如，结合文件大小、文件数量、I/O 类型等，综合分析文件 I/O 的性能。</p></li></ol></li><li><p>磁盘 I/O 性能指标</p><p> 在磁盘 I/O 原理的文章中，我曾提到过四个核心的磁盘 I/O 指标。</p><ol><li>使用率，是指磁盘忙处理 I/O 请求的百分比。过高的使用率（比如超过 60%）通常意味着磁盘 I/O 存在性能瓶颈。</li><li>IOPS（Input/Output Per Second），是指每秒的 I/O 请求数。</li><li>吞吐量，是指每秒的 I/O 请求大小。</li><li><p>响应时间，是指从发出 I/O 请求到收到响应的间隔时间。</p><p>考察这些指标时，一定要注意综合 I/O 的具体场景来分析，比如读写类型（顺序还是随机）、读写比例、读写大小、存储类型（有无 RAID 以及 RAID 级别、本地存储还是网络存储）等。</p><p>不过，这里有个大忌，就是把不同场景的 I/O 性能指标，直接进行分析对比。这是很常见的一个误区，你一定要避免。</p></li></ol></li></ol><p><img src="/images/《Linux性能优化实战》学习笔记/IO性能指标思维导图.png" alt="IO性能指标思维导图"></p><h4 id="30-2-性能工具"><a href="#30-2-性能工具" class="headerlink" title="30.2 性能工具"></a>30.2 性能工具</h4><ol><li><p>在文件系统的原理中，我介绍了查看文件系统容量的工具 df。它既可以查看文件系统数据的空间容量，也可以查看索引节点的容量。至于文件系统缓存，我们通过 /proc/meminfo、/proc/slabinfo 以及 slabtop 等各种来源，观察页缓存、目录项缓存、索引节点缓存以及具体文件系统的缓存情况。</p></li><li><p>在磁盘 I/O 的原理中，我们分别用 iostat 和 pidstat 观察了磁盘和进程的 I/O 情况。它们都是最常用的 I/O 性能分析工具。通过 iostat ，我们可以得到磁盘的 I/O 使用率、吞吐量、响应时间以及 IOPS 等性能指标；而通过 pidstat ，则可以观察到进程的 I/O 吞吐量以及块设备 I/O 的延迟等。</p></li><li><p>在狂打日志的案例中，我们先用 top 查看系统的 CPU 使用情况，发现 iowait 比较高；然后，又用 iostat 发现了磁盘的 I/O 使用率瓶颈，并用 pidstat 找出了大量 I/O 的进程；最后，通过 strace 和 lsof，我们找出了问题进程正在读写的文件，并最终锁定性能问题的来源——原来是进程在狂打日志。</p></li><li><p>在磁盘 I/O 延迟的单词热度案例中，我们同样先用 top、iostat ，发现磁盘有 I/O 瓶颈，并用 pidstat 找出了大量 I/O 的进程。可接下来，想要照搬上次操作的我们失败了。在随后的 strace 命令中，我们居然没看到 write 系统调用。于是，我们换了一个思路，用新工具 filetop 和 opensnoop ，从内核中跟踪系统调用，最终找出瓶颈的来源。</p></li><li><p>在 MySQL 和 Redis 的案例中，同样的思路，我们先用 top、iostat 以及 pidstat ，确定并找出 I/O 性能问题的瓶颈来源，它们正是 mysqld 和 redis-server。随后，我们又用 strace+lsof 找出了它们正在读写的文件。</p><p> 关于 MySQL 案例，根据 mysqld 正在读写的文件路径，再结合 MySQL 数据库引擎的原理，我们不仅找出了数据库和数据表的名称，还进一步发现了慢查询的问题，最终通过优化索引解决了性能瓶颈。</p><p> 至于 Redis 案例，根据 redis-server 读写的文件，以及正在进行网络通信的 TCP Socket，再结合 Redis 的工作原理，我们发现 Redis 持久化选项配置有问题；从 TCP Socket 通信的数据中，我们还发现了客户端的不合理行为。于是，我们修改 Redis 配置选项，并优化了客户端使用 Redis 的方式，从而减少网络通信次数，解决性能问题。</p></li></ol><h4 id="30-3-性能指标和工具的联系"><a href="#30-3-性能指标和工具的联系" class="headerlink" title="30.3 性能指标和工具的联系"></a>30.3 性能指标和工具的联系</h4><p>同前面 CPU 和内存板块的学习一样，我建议从指标和工具两个不同维度出发，整理记忆。</p><ul><li>从 I/O 指标出发，你更容易把性能工具同系统工作原理关联起来，对性能问题有宏观的认识和把握。</li><li>而从性能工具出发，可以让你更快上手使用工具，迅速找出我们想观察的性能指标。特别是在工具有限的情况下，我们更要充分利用好手头的每一个工具，少量工具也要尽力挖掘出大量信息。</li></ul><ol><li><p><strong>第一个维度，从文件系统和磁盘 I/O 的性能指标出发。换句话说，当你想查看某个性能指标时，要清楚知道，哪些工具可以做到。</strong></p><p> 根据不同的性能指标，对提供指标的性能工具进行分类和理解。这样，在实际排查性能问题时，你就可以清楚知道，什么工具可以提供你想要的指标，而不是毫无根据地挨个尝试，撞运气。</p><p> <img src="/images/《Linux性能优化实战》学习笔记/根据指标找工具（文件系统和磁盘IO）.png" alt="根据指标找工具（文件系统和磁盘IO）"></p></li><li><p><strong>第二个维度，从工具出发。也就是当你已经安装了某个工具后，要知道这个工具能提供哪些指标。</strong></p><p> 这在实际环境中，特别是生产环境中也是非常重要的。因为很多情况下，你并没有权限安装新的工具包，只能最大化地利用好系统已有的工具，而这就需要你对它们有足够的了解。</p><p> 具体到每个工具的使用方法，一般都支持丰富的配置选项。不过不用担心，这些配置选项并不用背下来。你只要知道有哪些工具，以及这些工具的基本功能是什么就够了。真正要用到的时候， 通过 man 命令，查它们的使用手册就可以了。</p><p> <img src="/images/《Linux性能优化实战》学习笔记/根据工具查指标（文件系统和磁盘IO）.png" alt="根据工具查指标（文件系统和磁盘IO）"></p></li></ol><h4 id="30-4-如何迅速分析-I-O-的性能瓶颈"><a href="#30-4-如何迅速分析-I-O-的性能瓶颈" class="headerlink" title="30.4 如何迅速分析 I/O 的性能瓶颈"></a>30.4 如何迅速分析 I/O 的性能瓶颈</h4><p>虽然文件系统和磁盘的 I/O 性能指标仍比较多，但核心的性能工具，其实就是那么几个。熟练掌握它们，再根据实际系统的现象，并配合系统和应用程序的原理， I/O 性能分析就很清晰了。</p><p><strong>想弄清楚性能指标的关联性，就要通晓每种性能指标的工作原理。</strong></p><p>以我们前面几期的案例为例，如果你仔细对比前面的几个案例，从 I/O 延迟的案例到 MySQL 和 Redis 的案例，就会发现，虽然这些问题千差万别，但从 I/O 角度来分析，最开始的分析思路基本上类似，都是：</p><ol><li>先用 iostat 发现磁盘 I/O 性能瓶颈；</li><li>再借助 pidstat ，定位出导致瓶颈的进程；</li><li>随后分析进程的 I/O 行为；</li><li>最后，结合应用程序的原理，分析这些 I/O 的来源。</li></ol><p><strong>所以，为了缩小排查范围，我通常会先运行那几个支持指标较多的工具，如 iostat、vmstat、pidstat 等</strong>。然后再根据观察到的现象，结合系统和应用程序的原理，寻找下一步的分析方向。</p><p><img src="/images/《Linux性能优化实战》学习笔记/如何迅速分析IO的性能瓶颈.png" alt="如何迅速分析IO的性能瓶颈"></p><p>图中列出了最常用的几个文件系统和磁盘 I/O 性能分析工具，以及相应的分析流程，箭头则表示分析方向。这其中，iostat、vmstat、pidstat 是最核心的几个性能工具，它们也提供了最重要的 I/O 性能指标。举几个例子你可能更容易理解。</p><p>例如，在前面讲过的 MySQL 和 Redis 案例中，我们就是通过 iostat 确认磁盘出现 I/O 性能瓶颈，然后用 pidstat 找出 I/O 最大的进程，接着借助 strace 找出该进程正在读写的文件，最后结合应用程序的原理，找出大量 I/O 的原因。</p><p>再如，当你用 iostat 发现磁盘有 I/O 性能瓶颈后，再用 pidstat 和 vmstat 检查，可能会发现 I/O 来自内核线程，如 Swap 使用大量升高。这种情况下，你就得进行内存分析了，先找出占用大量内存的进程，再设法减少内存的使用。</p><h3 id="31-套路篇：磁盘-I-O-性能优化的几个思路"><a href="#31-套路篇：磁盘-I-O-性能优化的几个思路" class="headerlink" title="31 | 套路篇：磁盘 I/O 性能优化的几个思路"></a>31 | 套路篇：磁盘 I/O 性能优化的几个思路</h3><h4 id="31-1-I-O-基准测试"><a href="#31-1-I-O-基准测试" class="headerlink" title="31.1 I/O 基准测试"></a>31.1 I/O 基准测试</h4><p>按照我的习惯，优化之前，我会先问自己， I/O 性能优化的目标是什么？换句话说，我们观察的这些 I/O 性能指标（比如 IOPS、吞吐量、延迟等），要达到多少才合适呢？</p><p>事实上，I/O 性能指标的具体标准，每个人估计会有不同的答案，因为我们每个人的应用场景、使用的文件系统和物理磁盘等，都有可能不一样。</p><p>为了更客观合理地评估优化效果，我们首先应该对磁盘和文件系统进行基准测试，得到文件系统或者磁盘 I/O 的极限性能。</p><p><a href="https://github.com/axboe/fio">fio</a>（Flexible I/O Tester）正是最常用的文件系统和磁盘 I/O 性能基准测试工具。它提供了大量的可定制化选项，可以用来测试，裸盘或者文件系统在各种场景下的 I/O 性能，包括了不同块大小、不同 I/O 引擎以及是否使用缓存等场景。</p><p>fio 的选项非常多， 我会通过几个常见场景的测试方法，介绍一些最常用的选项。这些常见场景包括随机读、随机写、顺序读以及顺序写等，你可以执行下面这些命令来测试：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 随机读</span>fio -name<span class="token operator">=</span>randread -direct<span class="token operator">=</span><span class="token number">1</span> -iodepth<span class="token operator">=</span><span class="token number">64</span> -rw<span class="token operator">=</span>randread -ioengine<span class="token operator">=</span>libaio -bs<span class="token operator">=</span>4k -size<span class="token operator">=</span>1G -numjobs<span class="token operator">=</span><span class="token number">1</span> -runtime<span class="token operator">=</span><span class="token number">1000</span> -group_reporting -filename<span class="token operator">=</span>/dev/sdb<span class="token comment"># 随机写</span>fio -name<span class="token operator">=</span>randwrite -direct<span class="token operator">=</span><span class="token number">1</span> -iodepth<span class="token operator">=</span><span class="token number">64</span> -rw<span class="token operator">=</span>randwrite -ioengine<span class="token operator">=</span>libaio -bs<span class="token operator">=</span>4k -size<span class="token operator">=</span>1G -numjobs<span class="token operator">=</span><span class="token number">1</span> -runtime<span class="token operator">=</span><span class="token number">1000</span> -group_reporting -filename<span class="token operator">=</span>/dev/sdb<span class="token comment"># 顺序读</span>fio -name<span class="token operator">=</span>read -direct<span class="token operator">=</span><span class="token number">1</span> -iodepth<span class="token operator">=</span><span class="token number">64</span> -rw<span class="token operator">=</span>read -ioengine<span class="token operator">=</span>libaio -bs<span class="token operator">=</span>4k -size<span class="token operator">=</span>1G -numjobs<span class="token operator">=</span><span class="token number">1</span> -runtime<span class="token operator">=</span><span class="token number">1000</span> -group_reporting -filename<span class="token operator">=</span>/dev/sdb<span class="token comment"># 顺序写</span>fio -name<span class="token operator">=</span>write -direct<span class="token operator">=</span><span class="token number">1</span> -iodepth<span class="token operator">=</span><span class="token number">64</span> -rw<span class="token operator">=</span>write -ioengine<span class="token operator">=</span>libaio -bs<span class="token operator">=</span>4k -size<span class="token operator">=</span>1G -numjobs<span class="token operator">=</span><span class="token number">1</span> -runtime<span class="token operator">=</span><span class="token number">1000</span> -group_reporting -filename<span class="token operator">=</span>/dev/sdb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这其中，有几个参数需要你重点关注一下。</p><ul><li>direct，表示是否跳过系统缓存。上面示例中，我设置的 1 ，就表示跳过系统缓存。</li><li>iodepth，表示使用异步 I/O（asynchronous I/O，简称 AIO）时，同时发出的 I/O 请求上限。在上面的示例中，我设置的是 64。</li><li>rw，表示 I/O 模式。我的示例中， read/write 分别表示顺序读 / 写，而 randread/randwrite 则分别表示随机读 / 写。</li><li>ioengine，表示 I/O 引擎，它支持同步（sync）、异步（libaio）、内存映射（mmap）、网络（net）等各种 I/O 引擎。上面示例中，我设置的 libaio 表示使用异步 I/O。</li><li>bs，表示 I/O 的大小。示例中，我设置成了 4K（这也是默认值）。</li><li>filename，表示文件路径，当然，它可以是磁盘路径（测试磁盘性能），也可以是文件路径（测试文件系统性能）。示例中，我把它设置成了磁盘 /dev/sdb。不过注意，用磁盘路径测试写，会破坏这个磁盘中的文件系统，所以在使用前，你一定要事先做好数据备份。</li></ul><p>下面就是我使用 fio 测试顺序读的一个报告示例。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">read: (g=0): rw=read, bs=(R) 4096B-4096B, (W) 4096B-4096B, (T) 4096B-4096B, ioengine=libaio, iodepth=64fio-3.1Starting 1 processJobs: 1 (f=1): [R(1)][100.0%][r=16.7MiB/s,w=0KiB/s][r=4280,w=0 IOPS][eta 00m:00s]read: (groupid=0, jobs=1): err= 0: pid=17966: Sun Dec 30 08:31:48 2018   read: IOPS=4257, BW=16.6MiB/s (17.4MB/s)(1024MiB/61568msec)    slat (usec): min=2, max=2566, avg= 4.29, stdev=21.76    clat (usec): min=228, max=407360, avg=15024.30, stdev=20524.39     lat (usec): min=243, max=407363, avg=15029.12, stdev=20524.26    clat percentiles (usec):     |  1.00th=[   498],  5.00th=[  1020], 10.00th=[  1319], 20.00th=[  1713],     | 30.00th=[  1991], 40.00th=[  2212], 50.00th=[  2540], 60.00th=[  2933],     | 70.00th=[  5407], 80.00th=[ 44303], 90.00th=[ 45351], 95.00th=[ 45876],     | 99.00th=[ 46924], 99.50th=[ 46924], 99.90th=[ 48497], 99.95th=[ 49021],     | 99.99th=[404751]   bw (  KiB/s): min= 8208, max=18832, per=99.85%, avg=17005.35, stdev=998.94, samples=123   iops        : min= 2052, max= 4708, avg=4251.30, stdev=249.74, samples=123  lat (usec)   : 250=0.01%, 500=1.03%, 750=1.69%, 1000=2.07%  lat (msec)   : 2=25.64%, 4=37.58%, 10=2.08%, 20=0.02%, 50=29.86%  lat (msec)   : 100=0.01%, 500=0.02%  cpu          : usr=1.02%, sys=2.97%, ctx=33312, majf=0, minf=75  IO depths    : 1=0.1%, 2=0.1%, 4=0.1%, 8=0.1%, 16=0.1%, 32=0.1%, &gt;=64=100.0%     submit    : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, &gt;=64=0.0%     complete  : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.1%, &gt;=64=0.0%     issued rwt: total=262144,0,0, short=0,0,0, dropped=0,0,0     latency   : target=0, window=0, percentile=100.00%, depth=64Run status group 0 (all jobs):   READ: bw=16.6MiB/s (17.4MB/s), 16.6MiB/s-16.6MiB/s (17.4MB/s-17.4MB/s), io=1024MiB (1074MB), run=61568-61568msecDisk stats (read/write):  sdb: ios=261897/0, merge=0/0, ticks=3912108/0, in_queue=3474336, util=90.09%<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个报告中，需要我们重点关注的是， slat、clat、lat ，以及 bw 和 iops 这几行。</p><p>先来看刚刚提到的前三个参数。事实上，slat、clat、lat 都是指 I/O 延迟（latency）。不同之处在于：</p><ul><li>slat ，是指从 I/O 提交到实际执行 I/O 的时长（Submission latency）；</li><li>clat ，是指从 I/O 提交到 I/O 完成的时长（Completion latency）；</li><li>而 lat ，指的是从 fio 创建 I/O 到 I/O 完成的总时长。</li></ul><p>这里需要注意的是，对同步 I/O 来说，由于 I/O 提交和 I/O 完成是一个动作，所以 slat 实际上就是 I/O 完成的时间，而 clat 是 0。而从示例可以看到，使用异步 I/O（libaio）时，lat 近似等于 slat + clat 之和。</p><p>再来看 bw ，它代表吞吐量。在我上面的示例中，你可以看到，平均吞吐量大约是 16 MB（17005 KiB/1024）。</p><p>最后的 iops ，其实就是每秒 I/O 的次数，上面示例中的平均 IOPS 为 4250。</p><p>通常情况下，应用程序的 I/O 都是读写并行的，而且每次的 I/O 大小也不一定相同。所以，刚刚说的这几种场景，并不能精确模拟应用程序的 I/O 模式。那怎么才能精确模拟应用程序的 I/O 模式呢？</p><p>幸运的是，fio 支持 I/O 的重放。借助前面提到过的 blktrace，再配合上 fio，就可以实现对应用程序 I/O 模式的基准测试。你需要先用 blktrace ，记录磁盘设备的 I/O 访问情况；然后使用 fio ，重放 blktrace 的记录。</p><p>比如你可以运行下面的命令来操作：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 使用 blktrace 跟踪磁盘 I/O，注意指定应用程序正在操作的磁盘</span>$ blktrace /dev/sdb<span class="token comment"># 查看 blktrace 记录的结果</span><span class="token comment"># ls</span>sdb.blktrace.0  sdb.blktrace.1<span class="token comment"># 将结果转化为二进制文件</span>$ blkparse sdb -d sdb.bin<span class="token comment"># 使用 fio 重放日志</span>$ fio --name<span class="token operator">=</span>replay --filename<span class="token operator">=</span>/dev/sdb --direct<span class="token operator">=</span><span class="token number">1</span> --read_iolog<span class="token operator">=</span>sdb.bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，我们就通过 blktrace+fio 的组合使用，得到了应用程序 I/O 模式的基准测试报告。</p><h4 id="31-2-I-O-性能优化"><a href="#31-2-I-O-性能优化" class="headerlink" title="31.2 I/O 性能优化"></a>31.2 I/O 性能优化</h4><p>得到 I/O 基准测试报告后，再用上我们上一节总结的性能分析套路，找出 I/O 的性能瓶颈并优化，就是水到渠成的事情了。当然， 想要优化 I/O 性能，肯定离不开 Linux 系统的 I/O 栈图的思路辅助。你可以结合下面的 I/O 栈图再回顾一下。</p><p><img src="/images/《Linux性能优化实战》学习笔记/Linux存储系统的IO栈全景图.png" alt="Linux存储系统的IO栈全景图"></p><ol><li><p>应用程序优化</p><p> 应用程序处于整个 I/O 栈的最上端，它可以通过系统调用，来调整 I/O 模式（如顺序还是随机、同步还是异步）， 同时，它也是 I/O 数据的最终来源。在我看来，可以有这么几种方式来优化应用程序的 I/O 性能。</p><ol><li>第一，可以用追加写代替随机写，减少寻址开销，加快 I/O 写的速度。</li><li>第二，可以借助缓存 I/O ，充分利用系统缓存，降低实际 I/O 的次数。</li><li><p>第三，可以在应用程序内部构建自己的缓存，或者用 Redis 这类外部缓存系统。这样，一方面，能在应用程序内部，控制缓存的数据和生命周期；另一方面，也能降低其他应用程序使用缓存对自身的影响。</p><p> 比如，在前面的 MySQL 案例中，我们已经见识过，只是因为一个干扰应用清理了系统缓存，就会导致 MySQL 查询有数百倍的性能差距（0.1s vs 15s）。</p><p> 再如， C 标准库提供的 fopen、fread 等库函数，都会利用标准库的缓存，减少磁盘的操作。而你直接使用 open、read 等系统调用时，就只能利用操作系统提供的页缓存和缓冲区等，而没有库函数的缓存可用。</p></li><li><p>第四，在需要频繁读写同一块磁盘空间时，可以用 mmap 代替 read/write，减少内存的拷贝次数。</p></li><li>第五，在需要同步写的场景中，尽量将写请求合并，而不是让每个请求都同步写入磁盘，即可以用 fsync() 取代 O_SYNC。</li><li>第六，在多个应用程序共享相同磁盘时，为了保证 I/O 不被某个应用完全占用，推荐你使用 cgroups 的 I/O 子系统，来限制进程 / 进程组的 IOPS 以及吞吐量。</li><li>最后，在使用 CFQ 调度器时，可以用 ionice 来调整进程的 I/O 调度优先级，特别是提高核心应用的 I/O 优先级。ionice 支持三个优先级类：Idle、Best-effort 和 Realtime。其中， Best-effort 和 Realtime 还分别支持 0-7 的级别，数值越小，则表示优先级别越高。</li></ol></li><li><p>文件系统优化</p><p> 应用程序访问普通文件时，实际是由文件系统间接负责，文件在磁盘中的读写。所以，跟文件系统中相关的也有很多优化 I/O 性能的方式。</p><ol><li><p>第一，你可以根据实际负载场景的不同，选择最适合的文件系统。比如 Ubuntu 默认使用 ext4 文件系统，而 CentOS 7 默认使用 xfs 文件系统。</p><p> 相比于 ext4 ，xfs 支持更大的磁盘分区和更大的文件数量，如 xfs 支持大于 16TB 的磁盘。但是 xfs 文件系统的缺点在于无法收缩，而 ext4 则可以。</p></li><li><p>第二，在选好文件系统后，还可以进一步优化文件系统的配置选项，包括文件系统的特性（如 ext_attr、dir_index）、日志模式（如 journal、ordered、writeback）、挂载选项（如 noatime）等等。</p><p> 比如， 使用 tune2fs 这个工具，可以调整文件系统的特性（tune2fs 也常用来查看文件系统超级块的内容）。 而通过 /etc/fstab ，或者 mount 命令行参数，我们可以调整文件系统的日志模式和挂载选项等。</p></li><li><p>第三，可以优化文件系统的缓存。</p><p> 比如，你可以优化 pdflush 脏页的刷新频率（比如设置 dirty_expire_centisecs 和 dirty_writeback_centisecs）以及脏页的限额（比如调整 dirty_background_ratio 和 dirty_ratio 等）。</p><p> 再如，你还可以优化内核回收目录项缓存和索引节点缓存的倾向，即调整 vfs_cache_pressure（/proc/sys/vm/vfs_cache_pressure，默认值 100），数值越大，就表示越容易回收。</p></li><li>最后，在不需要持久化时，你还可以用内存文件系统 tmpfs，以获得更好的 I/O 性能 。tmpfs 把数据直接保存在内存中，而不是磁盘中。比如 /dev/shm/ ，就是大多数 Linux 默认配置的一个内存文件系统，它的大小默认为总内存的一半。</li></ol></li><li><p>磁盘优化</p><p> 数据的持久化存储，最终还是要落到具体的物理磁盘中，同时，磁盘也是整个 I/O 栈的最底层。从磁盘角度出发，自然也有很多有效的性能优化方法。</p><ol><li><p>第一，最简单有效的优化方法，就是换用性能更好的磁盘，比如用 SSD 替代 HDD。</p></li><li><p>第二，我们可以使用 RAID ，把多块磁盘组合成一个逻辑磁盘，构成冗余独立磁盘阵列。这样做既可以提高数据的可靠性，又可以提升数据的访问性能。</p></li><li><p>第三，针对磁盘和应用程序 I/O 模式的特征，我们可以选择最适合的 I/O 调度算法。比方说，SSD 和虚拟机中的磁盘，通常用的是 noop 调度算法。而数据库应用，我更推荐使用 deadline 算法。</p></li><li><p>第四，我们可以对应用程序的数据，进行磁盘级别的隔离。比如，我们可以为日志、数据库等 I/O 压力比较重的应用，配置单独的磁盘。</p></li><li><p>第五，在顺序读比较多的场景中，我们可以增大磁盘的预读数据，比如，你可以通过下面两种方法，调整 /dev/sdb 的预读大小。</p><ul><li>调整内核选项 /sys/block/sdb/queue/read_ahead_kb，默认大小是 128 KB，单位为 KB。</li><li>使用 blockdev 工具设置，比如 blockdev —setra 8192 /dev/sdb，注意这里的单位是 512B（0.5KB），所以它的数值总是 read_ahead_kb 的两倍。</li></ul></li><li><p>第六，我们可以优化内核块设备 I/O 的选项。比如，可以调整磁盘队列的长度 /sys/block/sdb/queue/nr_requests，适当增大队列长度，可以提升磁盘的吞吐量（当然也会导致 I/O 延迟增大）。</p></li><li><p>最后，要注意，磁盘本身出现硬件错误，也会导致 I/O 性能急剧下降，所以发现磁盘性能急剧下降时，你还需要确认，磁盘本身是不是出现了硬件错误。</p><p> 比如，你可以查看 dmesg 中是否有硬件 I/O 故障的日志。 还可以使用 badblocks、smartctl 等工具，检测磁盘的硬件问题，或用 e2fsck 等来检测文件系统的错误。如果发现问题，你可以使用 fsck 等工具来修复。</p></li></ol></li></ol><h3 id="32-答疑（四）：阻塞、非阻塞-I-O-与同步、异步-I-O-的区别和联系"><a href="#32-答疑（四）：阻塞、非阻塞-I-O-与同步、异步-I-O-的区别和联系" class="headerlink" title="32 | 答疑（四）：阻塞、非阻塞 I/O 与同步、异步 I/O 的区别和联系"></a>32 | 答疑（四）：阻塞、非阻塞 I/O 与同步、异步 I/O 的区别和联系</h3><h4 id="32-1-问题-1：阻塞、非阻塞-I-O-与同步、异步-I-O-的区别和联系"><a href="#32-1-问题-1：阻塞、非阻塞-I-O-与同步、异步-I-O-的区别和联系" class="headerlink" title="32.1 问题 1：阻塞、非阻塞 I/O 与同步、异步 I/O 的区别和联系"></a>32.1 问题 1：阻塞、非阻塞 I/O 与同步、异步 I/O 的区别和联系</h4><p>首先我们来看阻塞和非阻塞 I/O。根据应用程序是否阻塞自身运行，可以把 I/O 分为阻塞 I/O 和非阻塞 I/O。</p><ul><li>所谓阻塞 I/O，是指应用程序在执行 I/O 操作后，如果没有获得响应，就会阻塞当前线程，不能执行其他任务。</li><li>所谓非阻塞 I/O，是指应用程序在执行 I/O 操作后，不会阻塞当前的线程，可以继续执行其他的任务。</li></ul><p>再来看同步 I/O 和异步 I/O。根据 I/O 响应的通知方式的不同，可以把文件 I/O 分为同步 I/O 和异步 I/O。</p><ul><li>所谓同步 I/O，是指收到 I/O 请求后，系统不会立刻响应应用程序；等到处理完成，系统才会通过系统调用的方式，告诉应用程序 I/O 结果。</li><li>所谓异步 I/O，是指收到 I/O 请求后，系统会先告诉应用程序 I/O 请求已经收到，随后再去异步处理；等处理完成后，系统再通过事件通知的方式，告诉应用程序结果。</li></ul><p>你可以看出，阻塞 / 非阻塞和同步 / 异步，其实就是两个不同角度的 I/O 划分方式。它们描述的对象也不同，阻塞 / 非阻塞针对的是 I/O 调用者（即应用程序），而同步 / 异步针对的是 I/O 执行者（即系统）。</p><p>我举个例子来进一步解释下。比如在 Linux I/O 调用中，</p><ul><li>系统调用 read 是同步读，所以，在没有得到磁盘数据前，read 不会响应应用程序。</li><li>而 aio_read 是异步读，系统收到 AIO 读请求后不等处理就返回了，而具体的 read 结果，再通过回调异步通知应用程序。</li></ul><p>再如，在网络套接字的接口中，</p><ul><li>使用 send() 直接向套接字发送数据时，如果套接字没有设置 O_NONBLOCK 标识，那么 send() 操作就会一直阻塞，当前线程也没法去做其他事情。</li><li>当然，如果你用了 epoll，系统会告诉你这个套接字的状态，那就可以用非阻塞的方式使用。当这个套接字不可写的时候，你可以去做其他事情，比如读写其他套接字。</li></ul><h4 id="32-2-“文件系统”课后思考"><a href="#32-2-“文件系统”课后思考" class="headerlink" title="32.2 “文件系统”课后思考"></a>32.2 “文件系统”课后思考</h4><p>执行 find 命令时，会不会导致系统的缓存升高呢？如果会导致，升高的又是哪种类型的缓存呢？</p><p>通过学习 Linux 文件系统的原理，我们知道，文件名以及文件之间的目录关系，都放在目录项缓存中。而这是一个基于内存的数据结构，会根据需要动态构建。所以，查找文件时，Linux 就会动态构建不在缓存中的目录项结构，导致 dentry 缓存升高。</p><p><img src="/images/《Linux性能优化实战》学习笔记/执行find命令导致系统的缓存升高答案1.png" alt="执行find命令导致系统的缓存升高答案1"></p><p><img src="/images/《Linux性能优化实战》学习笔记/执行find命令导致系统的缓存升高答案2.png" alt="执行find命令导致系统的缓存升高答案2"></p><p>事实上，除了目录项缓存增加，Buffer 的使用也会增加。如果你用 vmstat 观察一下，会发现 Buffer 和 Cache 都在增长：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">vmstat</span> <span class="token number">1</span>procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r  b   swpd   <span class="token function">free</span>   buff  cache   si   so    bi    bo   <span class="token keyword">in</span>   cs us sy <span class="token function">id</span> wa st <span class="token number">0</span>  <span class="token number">1</span>      <span class="token number">0</span> <span class="token number">7563744</span>   <span class="token number">6024</span> <span class="token number">225944</span>    <span class="token number">0</span>    <span class="token number">0</span>  <span class="token number">3736</span>     <span class="token number">0</span>  <span class="token number">574</span> <span class="token number">3249</span>  <span class="token number">3</span>  <span class="token number">5</span> <span class="token number">89</span>  <span class="token number">3</span>  <span class="token number">0</span> <span class="token number">1</span>  <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">7542792</span>  <span class="token number">14736</span> <span class="token number">236856</span>    <span class="token number">0</span>    <span class="token number">0</span>  <span class="token number">8708</span>     <span class="token number">0</span> <span class="token number">13494</span> <span class="token number">32335</span>  <span class="token number">8</span> <span class="token number">19</span> <span class="token number">66</span>  <span class="token number">7</span>  <span class="token number">0</span> <span class="token number">0</span>  <span class="token number">1</span>      <span class="token number">0</span> <span class="token number">7494452</span>  <span class="token number">27280</span> <span class="token number">272284</span>    <span class="token number">0</span>    <span class="token number">0</span> <span class="token number">12544</span>     <span class="token number">0</span> <span class="token number">4550</span> <span class="token number">17084</span>  <span class="token number">5</span> <span class="token number">15</span> <span class="token number">68</span> <span class="token number">13</span>  <span class="token number">0</span> <span class="token number">0</span>  <span class="token number">1</span>      <span class="token number">0</span> <span class="token number">7475084</span>  <span class="token number">42380</span> <span class="token number">276320</span>    <span class="token number">0</span>    <span class="token number">0</span> <span class="token number">15096</span>     <span class="token number">0</span> <span class="token number">2541</span> <span class="token number">14253</span>  <span class="token number">2</span>  <span class="token number">6</span> <span class="token number">78</span> <span class="token number">13</span>  <span class="token number">0</span> <span class="token number">0</span>  <span class="token number">1</span>      <span class="token number">0</span> <span class="token number">7455728</span>  <span class="token number">57600</span> <span class="token number">280436</span>    <span class="token number">0</span>    <span class="token number">0</span> <span class="token number">15220</span>     <span class="token number">0</span> <span class="token number">2025</span> <span class="token number">14518</span>  <span class="token number">2</span>  <span class="token number">6</span> <span class="token number">70</span> <span class="token number">22</span>  <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里，Buffer 的增长是因为，构建目录项缓存所需的元数据（比如文件名称、索引节点等），需要从文件系统中读取。</p><h4 id="32-3-问题-3：“磁盘-I-O-延迟”课后思考"><a href="#32-3-问题-3：“磁盘-I-O-延迟”课后思考" class="headerlink" title="32.3 问题 3：“磁盘 I/O 延迟”课后思考"></a>32.3 问题 3：“磁盘 I/O 延迟”课后思考</h4><p>我们通过 iostat ，确认磁盘 I/O 已经出现了性能瓶颈，还用 pidstat 找出了大量磁盘 I/O 的进程。但是，随后使用 strace 跟踪这个进程，却找不到任何 write 系统调用。这是为什么呢？</p><p>strace -p PID 后面需要加 -f 选项，以便跟踪多进程和多线程的系统调用情况。</p><h4 id="32-4-问题-4：“MySQL-案例”课后思考"><a href="#32-4-问题-4：“MySQL-案例”课后思考" class="headerlink" title="32.4 问题 4：“MySQL 案例”课后思考"></a>32.4 问题 4：“MySQL 案例”课后思考</h4><p>为什么 DataService 应用停止后，即使仍没有索引，MySQL 的查询速度还是快了很多，并且磁盘 I/O 瓶颈也消失了呢？</p><p>ninuxer 的留言基本解释了这个问题，不过还不够完善。</p><blockquote><p>ninuxer 的留言：echo 1&gt;/proc/sys/vm/drop_caches表示释放pagecache，也就是文件缓存，而mysql读书的数据就是文件缓存，dataservice不停的释放文件缓存，就导致MySQL都无法利用磁盘缓存，也就慢了。</p></blockquote><p>事实上，当你看到 DataService 在修改 /proc/sys/vm/drop_caches 时，就应该想到前面学过的 Cache 的作用。</p><p>我们知道，案例应用访问的数据表，基于 MyISAM 引擎，而 MyISAM 的一个特点，就是只在内存中缓存索引，并不缓存数据。所以，在查询语句无法使用索引时，就需要数据表从数据库文件读入内存，然后再进行处理。</p><p>所以，如果你用 vmstat 工具，观察缓存和 I/O 的变化趋势，就会发现下面这样的结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">vmstat</span> <span class="token number">1</span>procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r  b   swpd   <span class="token function">free</span>   buff  cache   si   so    bi    bo   <span class="token keyword">in</span>   cs us sy <span class="token function">id</span> wa st<span class="token comment"># 备注： DataService 正在运行</span><span class="token number">0</span>  <span class="token number">1</span>      <span class="token number">0</span> <span class="token number">7293416</span>    <span class="token number">132</span> <span class="token number">366704</span>    <span class="token number">0</span>    <span class="token number">0</span> <span class="token number">32516</span>    <span class="token number">12</span>   <span class="token number">36</span>  <span class="token number">546</span>  <span class="token number">1</span>  <span class="token number">3</span> <span class="token number">49</span> <span class="token number">48</span>  <span class="token number">0</span> <span class="token number">0</span>  <span class="token number">1</span>      <span class="token number">0</span> <span class="token number">7260772</span>    <span class="token number">132</span> <span class="token number">399256</span>    <span class="token number">0</span>    <span class="token number">0</span> <span class="token number">32640</span>     <span class="token number">0</span>   <span class="token number">37</span>  <span class="token number">463</span>  <span class="token number">1</span>  <span class="token number">1</span> <span class="token number">49</span> <span class="token number">48</span>  <span class="token number">0</span> <span class="token number">0</span>  <span class="token number">1</span>      <span class="token number">0</span> <span class="token number">7228088</span>    <span class="token number">132</span> <span class="token number">432088</span>    <span class="token number">0</span>    <span class="token number">0</span> <span class="token number">32640</span>     <span class="token number">0</span>   <span class="token number">30</span>  <span class="token number">477</span>  <span class="token number">0</span>  <span class="token number">1</span> <span class="token number">49</span> <span class="token number">49</span>  <span class="token number">0</span> <span class="token number">0</span>  <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">7306560</span>    <span class="token number">132</span> <span class="token number">353084</span>    <span class="token number">0</span>    <span class="token number">0</span> <span class="token number">20572</span>     <span class="token number">4</span>   <span class="token number">90</span>  <span class="token number">574</span>  <span class="token number">1</span>  <span class="token number">4</span> <span class="token number">69</span> <span class="token number">27</span>  <span class="token number">0</span> <span class="token number">0</span>  <span class="token number">2</span>      <span class="token number">0</span> <span class="token number">7282300</span>    <span class="token number">132</span> <span class="token number">368536</span>    <span class="token number">0</span>    <span class="token number">0</span> <span class="token number">15468</span>     <span class="token number">0</span>   <span class="token number">32</span>  <span class="token number">304</span>  <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">79</span> <span class="token number">20</span>  <span class="token number">0</span><span class="token comment"># 备注：DataService 从这里开始停止</span> <span class="token number">0</span>  <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">7241852</span>   <span class="token number">1360</span> <span class="token number">424164</span>    <span class="token number">0</span>    <span class="token number">0</span>   <span class="token number">864</span>   <span class="token number">320</span>  <span class="token number">133</span> <span class="token number">1266</span>  <span class="token number">1</span>  <span class="token number">1</span> <span class="token number">94</span>  <span class="token number">5</span>  <span class="token number">0</span> <span class="token number">0</span>  <span class="token number">1</span>      <span class="token number">0</span> <span class="token number">7228956</span>   <span class="token number">1368</span> <span class="token number">437400</span>    <span class="token number">0</span>    <span class="token number">0</span> <span class="token number">13328</span>     <span class="token number">0</span>   <span class="token number">45</span>  <span class="token number">366</span>  <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">83</span> <span class="token number">17</span>  <span class="token number">0</span> <span class="token number">0</span>  <span class="token number">1</span>      <span class="token number">0</span> <span class="token number">7196320</span>   <span class="token number">1368</span> <span class="token number">470148</span>    <span class="token number">0</span>    <span class="token number">0</span> <span class="token number">32640</span>     <span class="token number">0</span>   <span class="token number">33</span>  <span class="token number">413</span>  <span class="token number">1</span>  <span class="token number">1</span> <span class="token number">50</span> <span class="token number">49</span>  <span class="token number">0</span><span class="token punctuation">..</span>. <span class="token number">0</span>  <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">6747540</span>   <span class="token number">1368</span> <span class="token number">918576</span>    <span class="token number">0</span>    <span class="token number">0</span> <span class="token number">29056</span>     <span class="token number">0</span>   <span class="token number">42</span>  <span class="token number">568</span>  <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">56</span> <span class="token number">44</span>  <span class="token number">0</span> <span class="token number">0</span>  <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">6747540</span>   <span class="token number">1368</span> <span class="token number">918576</span>    <span class="token number">0</span>    <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">0</span>   <span class="token number">40</span>  <span class="token number">141</span>  <span class="token number">1</span>  <span class="token number">0</span> <span class="token number">100</span>  <span class="token number">0</span>  <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 DataService 停止前，cache 会连续增长三次后再降回去，这正是因为 DataService 每隔 3 秒清理一次页缓存。而 DataService 停止后，cache 就会不停地增长，直到增长为 918576 后，就不再变了。</p><p>这时，磁盘的读（bi）降低到 0，同时，iowait（wa）也降低到 0，这说明，此时的所有数据都已经在系统的缓存中了。我们知道，缓存是内存的一部分，它的访问速度比磁盘快得多，这也就能解释，为什么 MySQL 的查询速度变快了很多。</p><p>从这个案例，你会发现，MySQL 的 MyISAM 引擎，本身并不缓存数据，而要依赖系统缓存来加速磁盘 I/O 的访问。一旦系统中还有其他应用同时运行，MyISAM 引擎就很难充分利用系统缓存。因为系统缓存可能被其他应用程序占用，甚至直接被清理掉。</p><p>所以，一般来说，我并不建议，把应用程序的性能优化完全建立在系统缓存上。还是那句话，最好能在应用程序的内部分配内存，构建完全自主控制的缓存，比如 MySQL 的 InnoDB 引擎，就同时缓存了索引和数据；或者，可以使用第三方的缓存应用，比如 Memcached、Redis 等。</p><h2 id="05-网络性能篇"><a href="#05-网络性能篇" class="headerlink" title="05-网络性能篇"></a><strong>05-网络性能篇</strong></h2><h3 id="33-关于-Linux-网络，你必须知道这些（上）"><a href="#33-关于-Linux-网络，你必须知道这些（上）" class="headerlink" title="33 | 关于 Linux 网络，你必须知道这些（上）"></a>33 | 关于 Linux 网络，你必须知道这些（上）</h3><h4 id="33-1-网络模型"><a href="#33-1-网络模型" class="headerlink" title="33.1 网络模型"></a>33.1 网络模型</h4><p>说到网络，我想你肯定经常提起七层负载均衡、四层负载均衡，或者三层设备、二层设备等等。那么，这里说的二层、三层、四层、七层又都是什么意思呢？</p><p>实际上，这些层都来自国际标准化组织制定的开放式系统互联通信参考模型（Open System Interconnection Reference Model），简称为 OSI 网络模型。</p><ul><li>应用层，负责为应用程序提供统一的接口。</li><li>表示层，负责把数据转换成兼容接收系统的格式。</li><li>会话层，负责维护计算机之间的通信连接。</li><li>传输层，负责为数据加上传输表头，形成数据包。</li><li>网络层，负责数据的路由和转发。</li><li>数据链路层，负责 MAC 寻址、错误侦测和改错。</li><li>物理层，负责在物理网络中传输数据帧。</li></ul><p>但是 OSI 模型还是太复杂了，也没能提供一个可实现的方法。所以，在 Linux 中，我们实际上使用的是另一个更实用的四层模型，即 TCP/IP 网络模型。</p><p>TCP/IP 模型，把网络互联的框架分为应用层、传输层、网络层、网络接口层等四层，其中，</p><ul><li>应用层，负责向用户提供一组应用程序，比如 HTTP、FTP、DNS 等。</li><li>传输层，负责端到端的通信，比如 TCP、UDP 等。</li><li>网络层，负责网络包的封装、寻址和路由，比如 IP、ICMP 等。</li><li>网络接口层，负责网络包在物理网络中的传输，比如 MAC 寻址、错误侦测以及通过网卡传输网络帧等。</li></ul><p><img src="/images/《Linux性能优化实战》学习笔记/TCPIP与OSI模型的关系.png" alt="TCPIP与OSI模型的关系"></p><p>TCP/IP 模型包括了大量的网络协议，这些协议的原理，也是我们每个人必须掌握的核心基础知识。如果你不太熟练，推荐你去学《TCP/IP 详解》的卷一和卷二，或者学习极客时间出品的 <a href="https://time.geekbang.org/course/intro/85">《趣谈网络协议》</a> 专栏。</p><h4 id="33-2-Linux-网络栈"><a href="#33-2-Linux-网络栈" class="headerlink" title="33.2 Linux 网络栈"></a>33.2 Linux 网络栈</h4><p>有了 TCP/IP 模型后，在进行网络传输时，数据包就会按照协议栈，对上一层发来的数据进行逐层处理；然后封装上该层的协议头，再发送给下一层。</p><p>当然，网络包在每一层的处理逻辑，都取决于各层采用的网络协议。比如在应用层，一个提供 REST API 的应用，可以使用 HTTP 协议，把它需要传输的 JSON 数据封装到 HTTP 协议中，然后向下传递给 TCP 层。</p><p>而封装做的事情就很简单了，只是在原来的负载前后，增加固定格式的元数据，原始的负载数据并不会被修改。</p><p>比如，以通过 TCP 协议通信的网络包为例，通过下面这张图，我们可以看到，应用程序数据在每个层的封装格式。</p><p><img src="/images/《Linux性能优化实战》学习笔记/TCPIP协议栈.png" alt="TCPIP协议栈"></p><p>其中：</p><ul><li>传输层在应用程序数据前面增加了 TCP 头；</li><li>网络层在 TCP 数据包前增加了 IP 头；</li><li>而网络接口层，又在 IP 数据包前后分别增加了帧头和帧尾。</li></ul><p>这些新增的头部和尾部，都按照特定的协议格式填充，想了解具体格式，你可以查看协议的文档。 比如，你可以查看<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE#%E5%B0%81%E5%8C%85%E7%B5%90%E6%A7%8B">这里</a>，了解 TCP 头的格式。</p><p>这些新增的头部和尾部，增加了网络包的大小，但我们都知道，物理链路中并不能传输任意大小的数据包。网络接口配置的最大传输单元（MTU），就规定了最大的 IP 包大小。在我们最常用的以太网中，MTU 默认值是 1500（这也是 Linux 的默认值）。</p><p>一旦网络包超过 MTU 的大小，就会在网络层分片，以保证分片后的 IP 包不大于 MTU 值。显然，MTU 越大，需要的分包也就越少，自然，网络吞吐能力就越好。</p><p>理解了 TCP/IP 网络模型和网络包的封装原理后，你很容易能想到，Linux 内核中的网络栈，其实也类似于 TCP/IP 的四层结构。如下图所示，就是 Linux 通用 IP 网络栈的示意图：</p><p><img src="/images/《Linux性能优化实战》学习笔记/Linux通用IP网络栈的示意图.png" alt="Linux通用IP网络栈的示意图"></p><blockquote><p>（图片参考《性能之巅》图 10.7 通用 IP 网络栈绘制）</p></blockquote><p>我们从上到下来看这个网络栈，你可以发现，</p><ul><li>最上层的应用程序，需要通过系统调用，来跟套接字接口进行交互；</li><li>套接字的下面，就是我们前面提到的传输层、网络层和网络接口层；</li><li>最底层，则是网卡驱动程序以及物理网卡设备。</li></ul><p>网卡是发送和接收网络包的基本设备。在系统启动过程中，网卡通过内核中的网卡驱动程序注册到系统中。而在网络收发过程中，内核通过中断跟网卡进行交互。</p><p>再结合前面提到的 Linux 网络栈，可以看出，网络包的处理非常复杂。所以，网卡硬中断只处理最核心的网卡数据读取或发送，而协议栈中的大部分逻辑，都会放到软中断中处理。</p><h4 id="33-3-Linux-网络收发流程"><a href="#33-3-Linux-网络收发流程" class="headerlink" title="33.3 Linux 网络收发流程"></a>33.3 Linux 网络收发流程</h4><p>了解了 Linux 网络栈后，我们再来看看， Linux 到底是怎么收发网络包的。</p><blockquote><p>注意，以下内容都以物理网卡为例。事实上，Linux 还支持众多的虚拟网络设备，而它们的网络收发流程会有一些差别。</p></blockquote><p><img src="/images/《Linux性能优化实战》学习笔记/网络包的发送接收流程.png" alt="网络包的发送接收流程"></p><ol><li><p>网络包的接收流程</p><p> 当一个网络帧到达网卡后，网卡会通过 DMA 方式，把这个网络包放到收包队列中；然后通过硬中断，告诉中断处理程序已经收到了网络包。</p><p> 接着，网卡中断处理程序会为网络帧分配内核数据结构（sk_buff），并将其拷贝到 sk_buff 缓冲区中；然后再通过软中断，通知内核收到了新的网络帧。</p><p> 接下来，内核协议栈从缓冲区中取出网络帧，并通过网络协议栈，从下到上逐层处理这个网络帧。比如，</p><ul><li>在链路层检查报文的合法性，找出上层协议的类型（比如 IPv4 还是 IPv6），再去掉帧头、帧尾，然后交给网络层。</li><li>网络层取出 IP 头，判断网络包下一步的走向，比如是交给上层处理还是转发。当网络层确认这个包是要发送到本机后，就会取出上层协议的类型（比如 TCP 还是 UDP），去掉 IP 头，再交给传输层处理。</li><li><p>传输层取出 TCP 头或者 UDP 头后，根据 &lt; 源 IP、源端口、目的 IP、目的端口 &gt; 四元组作为标识，找出对应的 Socket，并把数据拷贝到 Socket 的接收缓存中。</p><p>最后，应用程序就可以使用 Socket 接口，读取到新接收到的数据了。</p></li></ul></li><li><p>网络包的发送流程</p><p> 首先，应用程序调用 Socket API（比如 sendmsg）发送网络包。</p><p> 由于这是一个系统调用，所以会陷入到内核态的套接字层中。套接字层会把数据包放到 Socket 发送缓冲区中。</p><p> 接下来，网络协议栈从 Socket 发送缓冲区中，取出数据包；再按照 TCP/IP 栈，从上到下逐层处理。比如，传输层和网络层，分别为其增加 TCP 头和 IP 头，执行路由查找确认下一跳的 IP，并按照 MTU 大小进行分片。</p><p> 分片后的网络包，再送到网络接口层，进行物理地址寻址，以找到下一跳的 MAC 地址。然后添加帧头和帧尾，放到发包队列中。这一切完成后，会有软中断通知驱动程序：发包队列中有新的网络帧需要发送。</p><p> 最后，驱动程序通过 DMA ，从发包队列中读出网络帧，并通过物理网卡把它发送出去。</p></li></ol><h3 id="34-关于-Linux-网络，你必须知道这些（下）"><a href="#34-关于-Linux-网络，你必须知道这些（下）" class="headerlink" title="34 | 关于 Linux 网络，你必须知道这些（下）"></a>34 | 关于 Linux 网络，你必须知道这些（下）</h3><h4 id="34-1-性能指标"><a href="#34-1-性能指标" class="headerlink" title="34.1 性能指标"></a>34.1 性能指标</h4><p>实际上，我们通常用带宽、吞吐量、延时、PPS（Packet Per Second）等指标衡量网络的性能。</p><ul><li><strong>带宽</strong>，表示链路的最大传输速率，单位通常为 b/s （比特 / 秒）。</li><li><strong>吞吐量</strong>，表示单位时间内成功传输的数据量，单位通常为 b/s（比特 / 秒）或者 B/s（字节 / 秒）。吞吐量受带宽限制，而吞吐量 / 带宽，也就是该网络的使用率。</li><li><strong>延时</strong>，表示从网络请求发出后，一直到收到远端响应，所需要的时间延迟。在不同场景中，这一指标可能会有不同含义。比如，它可以表示，建立连接需要的时间（比如 TCP 握手延时），或一个数据包往返所需的时间（比如 RTT）。</li><li><strong>PPS</strong>，是 Packet Per Second（包 / 秒）的缩写，表示以网络包为单位的传输速率。PPS 通常用来评估网络的转发能力，比如硬件交换机，通常可以达到线性转发（即 PPS 可以达到或者接近理论最大值）。而基于 Linux 服务器的转发，则容易受网络包大小的影响。</li></ul><p>除了这些指标，<strong>网络的可用性</strong>（网络能否正常通信）、<strong>并发连接数</strong>（TCP 连接数量）、<strong>丢包率</strong>（丢包百分比）、<strong>重传率</strong>（重新传输的网络包比例）等也是常用的性能指标。</p><h4 id="34-2-网络配置"><a href="#34-2-网络配置" class="headerlink" title="34.2 网络配置"></a>34.2 网络配置</h4><p>可以使用 ifconfig 或者 ip 命令，来查看网络的配置。我个人更推荐使用 ip 工具，因为它提供了更丰富的功能和更易用的接口。</p><blockquote><p>ifconfig 和 ip 分别属于软件包 net-tools 和 iproute2，iproute2 是 net-tools 的下一代。通常情况下它们会在发行版中默认安装。但如果你找不到 ifconfig 或者 ip 命令，可以安装这两个软件包。</p></blockquote><p>以网络接口 eth0 为例，你可以运行下面的两个命令，查看它的配置和状态：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ifconfig</span> eth0eth0: <span class="token assign-left variable">flags</span><span class="token operator">=</span><span class="token number">416</span><span class="token operator"><span class="token file-descriptor important">3</span>&lt;</span>UP,BROADCAST,RUNNING,MULTICAST<span class="token operator">&gt;</span> mtu <span class="token number">1500</span>      inet <span class="token number">10.240</span>.0.30 netmask <span class="token number">255.240</span>.0.0 broadcast <span class="token number">10.255</span>.255.255      inet6 fe80::20d:3aff:fe07:cf2a prefixlen <span class="token number">64</span> scopeid 0x2<span class="token operator"><span class="token file-descriptor important">0</span>&lt;</span>link<span class="token operator">&gt;</span>      ether <span class="token number">78</span>:0d:3a:07:cf:3a txqueuelen <span class="token number">1000</span> <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>      RX packets <span class="token number">40809142</span> bytes <span class="token number">9542369803</span> <span class="token punctuation">(</span><span class="token number">9.5</span> GB<span class="token punctuation">)</span>      RX errors <span class="token number">0</span> dropped <span class="token number">0</span> overruns <span class="token number">0</span> frame <span class="token number">0</span>      TX packets <span class="token number">32637401</span> bytes <span class="token number">4815573306</span> <span class="token punctuation">(</span><span class="token number">4.8</span> GB<span class="token punctuation">)</span>      TX errors <span class="token number">0</span> dropped <span class="token number">0</span> overruns <span class="token number">0</span> carrier <span class="token number">0</span> collisions <span class="token number">0</span>​$ <span class="token function">ip</span> -s addr show dev eth0<span class="token number">2</span>: eth0: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">1500</span> qdisc mq state UP group default qlen <span class="token number">1000</span>  link/ether <span class="token number">78</span>:0d:3a:07:cf:3a brd ff:ff:ff:ff:ff:ff  inet <span class="token number">10.240</span>.0.30/12 brd <span class="token number">10.255</span>.255.255 scope global eth0      valid_lft forever preferred_lft forever  inet6 fe80::20d:3aff:fe07:cf2a/64 scope <span class="token function">link</span>      valid_lft forever preferred_lft forever  RX: bytes packets errors dropped overrun mcast   <span class="token number">9542432350</span> <span class="token number">40809397</span> <span class="token number">0</span>       <span class="token number">0</span>       <span class="token number">0</span>       <span class="token number">193</span>  TX: bytes packets errors dropped carrier collsns   <span class="token number">4815625265</span> <span class="token number">32637658</span> <span class="token number">0</span>       <span class="token number">0</span>       <span class="token number">0</span>       <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些具体指标的含义，在文档中都有详细的说明，不过，这里有几个跟网络性能密切相关的指标，需要你特别关注一下。</p><ol><li><p>第一，网络接口的状态标志。ifconfig 输出中的 RUNNING ，或 ip 输出中的 LOWER_UP ，都表示物理网络是连通的，即网卡已经连接到了交换机或者路由器中。如果你看不到它们，通常表示网线被拔掉了。</p></li><li><p>第二，MTU 的大小。MTU 默认大小是 1500，根据网络架构的不同（比如是否使用了 VXLAN 等叠加网络），你可能需要调大或者调小 MTU 的数值。</p></li><li><p>第三，网络接口的 IP 地址、子网以及 MAC 地址。这些都是保障网络功能正常工作所必需的，你需要确保配置正确。</p></li><li><p>第四，网络收发的字节数、包数、错误数以及丢包情况，特别是 TX 和 RX 部分的 errors、dropped、overruns、carrier 以及 collisions 等指标不为 0 时，通常表示出现了网络 I/O 问题。其中：</p><ol><li>errors 表示发生错误的数据包数，比如校验错误、帧同步错误等；</li><li>dropped 表示丢弃的数据包数，即数据包已经收到了 Ring Buffer，但因为内存不足等原因丢包；</li><li>overruns 表示超限数据包数，即网络 I/O 速度过快，导致 Ring Buffer 中的数据包来不及处理（队列满）而导致的丢包；</li><li>carrier 表示发生 carrirer 错误的数据包数，比如双工模式不匹配、物理电缆出现问题等；</li><li>collisions 表示碰撞数据包数。</li></ol></li></ol><h4 id="34-3-套接字信息"><a href="#34-3-套接字信息" class="headerlink" title="34.3 套接字信息"></a>34.3 套接字信息</h4><p>使用 ss 来查询网络的连接信息，因为它比 netstat 提供了更好的性能（速度更快）。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># head -n 3 表示只显示前面 3 行</span><span class="token comment"># -l 表示只显示监听套接字</span><span class="token comment"># -n 表示显示数字地址和端口 (而不是名字)</span><span class="token comment"># -p 表示显示进程信息</span>$ <span class="token function">netstat</span> -nlp <span class="token operator">|</span> <span class="token function">head</span> -n <span class="token number">3</span>Active Internet connections <span class="token punctuation">(</span>only servers<span class="token punctuation">)</span>Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program nametcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">127.0</span>.0.53:53           <span class="token number">0.0</span>.0.0:*               LISTEN      <span class="token number">840</span>/systemd-resolve<span class="token comment"># -l 表示只显示监听套接字</span><span class="token comment"># -t 表示只显示 TCP 套接字</span><span class="token comment"># -n 表示显示数字地址和端口 (而不是名字)</span><span class="token comment"># -p 表示显示进程信息</span>$ ss -ltnp <span class="token operator">|</span> <span class="token function">head</span> -n <span class="token number">3</span>State    Recv-Q    Send-Q        Local Address:Port        Peer Address:PortLISTEN   <span class="token number">0</span>         <span class="token number">128</span>           <span class="token number">127.0</span>.0.53%lo:53               <span class="token number">0.0</span>.0.0:*        users:<span class="token variable"><span class="token punctuation">((</span>"systemd<span class="token operator">-</span>resolve"<span class="token punctuation">,</span>pid<span class="token operator">=</span><span class="token number">840</span><span class="token punctuation">,</span>fd<span class="token operator">=</span><span class="token number">13</span><span class="token punctuation">))</span></span>LISTEN   <span class="token number">0</span>         <span class="token number">128</span>                 <span class="token number">0.0</span>.0.0:22               <span class="token number">0.0</span>.0.0:*        users:<span class="token variable"><span class="token punctuation">((</span>"sshd"<span class="token punctuation">,</span>pid<span class="token operator">=</span><span class="token number">1459</span><span class="token punctuation">,</span>fd<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">))</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，接收队列（Recv-Q）和发送队列（Send-Q）需要你特别关注，它们通常应该是 0。当你发现它们不是 0 时，说明有网络包的堆积发生。当然还要注意，在不同套接字状态下，它们的含义不同。</p><p>当套接字处于连接状态（Established）时，</p><ul><li>Recv-Q 表示套接字缓冲还没有被应用程序取走的字节数（即接收队列长度）。</li><li>而 Send-Q 表示还没有被远端主机确认的字节数（即发送队列长度）。</li></ul><p>当套接字处于监听状态（Listening）时，</p><ul><li>Recv-Q 表示 syn backlog 的当前值。</li><li>而 Send-Q 表示最大的 syn backlog 值。</li></ul><p>而 syn backlog 是 TCP 协议栈中的半连接队列长度，相应的也有一个全连接队列（accept queue），它们都是维护 TCP 状态的重要机制。</p><p>顾名思义，所谓半连接，就是还没有完成 TCP 三次握手的连接，连接只进行了一半，而服务器收到了客户端的 SYN 包后，就会把这个连接放到半连接队列中，然后再向客户端发送 SYN+ACK 包。</p><p>而全连接，则是指服务器收到了客户端的 ACK，完成了 TCP 三次握手，然后就会把这个连接挪到全连接队列中。这些全连接中的套接字，还需要再被 accept() 系统调用取走，这样，服务器就可以开始真正处理客户端的请求了。</p><h4 id="34-4-协议栈统计信息"><a href="#34-4-协议栈统计信息" class="headerlink" title="34.4 协议栈统计信息"></a>34.4 协议栈统计信息</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">netstat</span> -s<span class="token punctuation">..</span>.Tcp:    <span class="token number">3244906</span> active connection openings    <span class="token number">23143</span> passive connection openings    <span class="token number">115732</span> failed connection attempts    <span class="token number">2964</span> connection resets received    <span class="token number">1</span> connections established    <span class="token number">13025010</span> segments received    <span class="token number">17606946</span> segments sent out    <span class="token number">44438</span> segments retransmitted    <span class="token number">42</span> bad segments received    <span class="token number">5315</span> resets sent    InCsumErrors: <span class="token number">42</span><span class="token punctuation">..</span>.$ ss -sTotal: <span class="token number">186</span> <span class="token punctuation">(</span>kernel <span class="token number">1446</span><span class="token punctuation">)</span>TCP:   <span class="token number">4</span> <span class="token punctuation">(</span>estab <span class="token number">1</span>, closed <span class="token number">0</span>, orphaned <span class="token number">0</span>, synrecv <span class="token number">0</span>, timewait <span class="token number">0</span>/0<span class="token punctuation">)</span>, ports <span class="token number">0</span>Transport Total     IP        IPv6*     <span class="token number">1446</span>      -         -RAW   <span class="token number">2</span>         <span class="token number">1</span>         <span class="token number">1</span>UDP   <span class="token number">2</span>         <span class="token number">2</span>         <span class="token number">0</span>TCP   <span class="token number">4</span>         <span class="token number">3</span>         <span class="token number">1</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些协议栈的统计信息都很直观。ss 只显示已经连接、关闭、孤儿套接字等简要统计，而 netstat 则提供的是更详细的网络协议栈信息。</p><p>比如，上面 netstat 的输出示例，就展示了 TCP 协议的主动连接、被动连接、失败重试、发送和接收的分段数量等各种信息。</p><h4 id="34-5-网络吞吐和-PPS"><a href="#34-5-网络吞吐和-PPS" class="headerlink" title="34.5 网络吞吐和 PPS"></a>34.5 网络吞吐和 PPS</h4><p>给 sar 增加 -n 参数就可以查看网络的统计信息，比如网络接口（DEV）、网络接口错误（EDEV）、TCP、UDP、ICMP 等等。执行下面的命令，你就可以得到网络接口统计信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 数字 1 表示每隔 1 秒输出一组数据</span>$ sar -n DEV <span class="token number">1</span>Linux <span class="token number">4.15</span>.0-1035-azure <span class="token punctuation">(</span>ubuntu<span class="token punctuation">)</span>    01/06/19    _x86_64_    <span class="token punctuation">(</span><span class="token number">2</span> CPU<span class="token punctuation">)</span><span class="token number">13</span>:21:40        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil<span class="token number">13</span>:21:41         eth0     <span class="token number">18.00</span>     <span class="token number">20.00</span>      <span class="token number">5.79</span>      <span class="token number">4.25</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span><span class="token number">13</span>:21:41      docker0      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span><span class="token number">13</span>:21:41           lo      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这儿输出的指标比较多，我来简单解释下它们的含义。</p><ul><li>rxpck/s 和 txpck/s 分别是接收和发送的 PPS，单位为包 / 秒。</li><li>rxkB/s 和 txkB/s 分别是接收和发送的吞吐量，单位是 KB/ 秒。</li><li>rxcmp/s 和 txcmp/s 分别是接收和发送的压缩数据包数，单位是包 / 秒。</li><li>%ifutil 是网络接口的使用率，即半双工模式下为 (rxkB/s+txkB/s)/Bandwidth，而全双工模式下为 max(rxkB/s, txkB/s)/Bandwidth。</li></ul><p>其中，Bandwidth 可以用 ethtool 来查询，它的单位通常是 Gb/s 或者 Mb/s，不过注意这里小写字母 b ，表示比特而不是字节。我们通常提到的千兆网卡、万兆网卡等，单位也都是比特。如下你可以看到，我的 eth0 网卡就是一个千兆网卡：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ethtool</span> eth0 <span class="token operator">|</span> <span class="token function">grep</span> Speed    Speed: 1000Mb/s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="34-6-连通性和延时"><a href="#34-6-连通性和延时" class="headerlink" title="34.6 连通性和延时"></a>34.6 连通性和延时</h4><p>最后，我们通常使用 ping ，来测试远程主机的连通性和延时，而这基于 ICMP 协议。比如，执行下面的命令，你就可以测试本机到 114.114.114.114 这个 IP 地址的连通性和延时：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -c3 表示发送三次 ICMP 包后停止</span>$ <span class="token function">ping</span> -c3 <span class="token number">114.114</span>.114.114PING <span class="token number">114.114</span>.114.114 <span class="token punctuation">(</span><span class="token number">114.114</span>.114.114<span class="token punctuation">)</span> <span class="token number">56</span><span class="token punctuation">(</span><span class="token number">84</span><span class="token punctuation">)</span> bytes of data.<span class="token number">64</span> bytes from <span class="token number">114.114</span>.114.114: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">54</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">244</span> ms<span class="token number">64</span> bytes from <span class="token number">114.114</span>.114.114: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">2</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">47</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">244</span> ms<span class="token number">64</span> bytes from <span class="token number">114.114</span>.114.114: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">3</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">67</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">244</span> ms--- <span class="token number">114.114</span>.114.114 <span class="token function">ping</span> statistics ---<span class="token number">3</span> packets transmitted, <span class="token number">3</span> received, <span class="token number">0</span>% packet loss, <span class="token function">time</span> 2001msrtt min/avg/max/mdev <span class="token operator">=</span> <span class="token number">244.023</span>/244.070/244.105/0.034 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ping 的输出，可以分为两部分。</p><ul><li>第一部分，是每个 ICMP 请求的信息，包括 ICMP 序列号（icmp_seq）、TTL（生存时间，或者跳数）以及往返延时。</li><li>第二部分，则是三次 ICMP 请求的汇总。</li></ul><p>比如上面的示例显示，发送了 3 个网络包，并且接收到 3 个响应，没有丢包发生，这说明测试主机到 114.114.114.114 是连通的；平均往返延时（RTT）是 244ms，也就是从发送 ICMP 开始，到接收到 114.114.114.114 回复的确认，总共经历 244ms。</p><h3 id="35-基础篇：C10K-和-C1000K-回顾"><a href="#35-基础篇：C10K-和-C1000K-回顾" class="headerlink" title="35 | 基础篇：C10K 和 C1000K 回顾"></a>35 | 基础篇：C10K 和 C1000K 回顾</h3><p>回顾下经典的 C10K 和 C1000K 问题，以更好理解 Linux 网络的工作原理，并进一步分析，如何做到单机支持 C10M。</p><p>注意，C10K 和 C1000K 的首字母 C 是 Client 的缩写。C10K 就是单机同时处理 1 万个请求（并发连接 1 万）的问题，而 C1000K 也就是单机支持处理 100 万个请求（并发连接 100 万）的问题。</p><h4 id="35-1-C10K"><a href="#35-1-C10K" class="headerlink" title="35.1 C10K"></a>35.1 C10K</h4><p><a href="http://www.kegel.com/c10k.html">C10K 问题</a>最早由 Dan Kegel 在 1999 年提出。那时的服务器还只是 32 位系统，运行着 Linux 2.2 版本（后来又升级到了 2.4 和 2.6，而 2.6 才支持 x86_64），只配置了很少的内存（2GB）和千兆网卡。</p><p>怎么在这样的系统中支持并发 1 万的请求呢？</p><p>从资源上来说，对 2GB 内存和千兆网卡的服务器来说，同时处理 10000 个请求，只要每个请求处理占用不到 200KB（2GB/10000）的内存和 100Kbit （1000Mbit/10000）的网络带宽就可以。所以，物理资源是足够的，接下来自然是软件的问题，特别是网络的 I/O 模型问题。</p><p>说到 I/O 的模型，我在文件系统的原理中，曾经介绍过文件 I/O，其实网络 I/O 模型也类似。在 C10K 以前，Linux 中网络处理都用同步阻塞的方式，也就是每个请求都分配一个进程或者线程。请求数只有 100 个时，这种方式自然没问题，但增加到 10000 个请求时，10000 个进程或线程的调度、上下文切换乃至它们占用的内存，都会成为瓶颈。</p><p>既然每个请求分配一个线程的方式不合适，那么，为了支持 10000 个并发请求，这里就有两个问题需要我们解决。</p><ol><li>第一，怎样在一个线程内处理多个请求，也就是要在一个线程内响应多个网络 I/O。以前的同步阻塞方式下，一个线程只能处理一个请求，到这里不再适用，是不是可以用非阻塞 I/O 或者异步 I/O 来处理多个网络请求呢？</li><li>第二，怎么更节省资源地处理客户请求，也就是要用更少的线程来服务这些请求。是不是可以继续用原来的 100 个或者更少的线程，来服务现在的 10000 个请求呢？</li></ol><p>当然，事实上，现在 C10K 的问题早就解决了，在继续学习下面的内容前，你可以先自己思考一下这两个问题。结合前面学过的内容，你是不是已经有了解决思路呢？</p><h4 id="35-2-I-O-模型优化"><a href="#35-2-I-O-模型优化" class="headerlink" title="35.2 I/O 模型优化"></a>35.2 I/O 模型优化</h4><p>异步、非阻塞 I/O 的解决思路，你应该听说过，其实就是我们在网络编程中经常用到的 I/O 多路复用（I/O Multiplexing）。I/O 多路复用是什么意思呢？</p><p>别急，详细了解前，我先来讲两种 I/O 事件通知的方式：水平触发和边缘触发，它们常用在套接字接口的文件描述符中。</p><ul><li>水平触发：只要文件描述符可以非阻塞地执行 I/O ，就会触发通知。也就是说，应用程序可以随时检查文件描述符的状态，然后再根据状态，进行 I/O 操作。</li><li>边缘触发：只有在文件描述符的状态发生改变（也就是 I/O 请求达到）时，才发送一次通知。这时候，应用程序需要尽可能多地执行 I/O，直到无法继续读写，才可以停止。如果 I/O 没执行完，或者因为某种原因没来得及处理，那么这次通知也就丢失了。</li></ul><p>接下来，我们再回过头来看 I/O 多路复用的方法。这里其实有很多实现方法，我带你来逐个分析一下。</p><ol><li><p><strong>第一种，使用非阻塞 I/O 和水平触发通知，比如使用 select 或者 poll。</strong></p><p> 这种方式的最大优点，是对应用程序比较友好，它的 API 非常简单。</p><p> 但是，应用软件使用 select 和 poll 时，需要对这些文件描述符列表进行轮询，这样，请求数多的时候就会比较耗时。并且，select 和 poll 还有一些其他的限制。</p><p> select 使用固定长度的位相量，表示文件描述符的集合，因此会有最大描述符数量的限制。比如，在 32 位系统中，默认限制是 1024。并且，在 select 内部，检查套接字状态是用轮询的方法，再加上应用软件使用时的轮询，就变成了一个 O(n^2) 的关系。</p><p> 而 poll 改进了 select 的表示方法，换成了一个没有固定长度的数组，这样就没有了最大描述符数量的限制（当然还会受到系统文件描述符限制）。但应用程序在使用 poll 时，同样需要对文件描述符列表进行轮询，这样，处理耗时跟描述符数量就是 O(N) 的关系。</p><p> 除此之外，应用程序每次调用 select 和 poll 时，还需要把文件描述符的集合，从用户空间传入内核空间，由内核修改后，再传出到用户空间中。这一来一回的内核空间与用户空间切换，也增加了处理成本。</p></li><li><p><strong>第二种，使用非阻塞 I/O 和边缘触发通知，比如 epoll。</strong></p><p> 既然 select 和 poll 有那么多的问题，就需要继续对其进行优化，而 epoll 就很好地解决了这些问题。</p><ul><li>epoll 使用红黑树，在内核中管理文件描述符的集合，这样，就不需要应用程序在每次操作时都传入、传出这个集合。</li><li>epoll 使用事件驱动的机制，只关注有 I/O 事件发生的文件描述符，不需要轮询扫描整个集合。</li></ul></li><li><p><strong>第三种，使用异步 I/O（Asynchronous I/O，简称为 AIO）。</strong></p><p> 异步 I/O 允许应用程序同时发起很多 I/O 操作，而不用等待这些操作完成。而在 I/O 完成后，系统会用事件通知（比如信号或者回调函数）的方式，告诉应用程序。这时，应用程序才会去查询 I/O 操作的结果。</p><p> 异步 I/O 也是到了 Linux 2.6 才支持的功能，并且在很长时间里都处于不完善的状态，比如 glibc 提供的异步 I/O 库，就一直被社区诟病。同时，由于异步 I/O 跟我们的直观逻辑不太一样，想要使用的话，一定要小心设计，其使用难度比较高。</p></li></ol><h4 id="35-3-工作模型优化"><a href="#35-3-工作模型优化" class="headerlink" title="35.3 工作模型优化"></a>35.3 工作模型优化</h4><p>使用 I/O 多路复用后，就可以在一个进程或线程中处理多个请求，其中，又有下面两种不同的工作模型。</p><ol><li><p><strong>第一种，主进程 + 多个 worker 子进程，这也是最常用的一种模型。</strong> 这种方法的一个通用工作模式就是：</p><ul><li>主进程执行 bind() + listen() 后，创建多个子进程；</li><li><p>然后，在每个子进程中，都通过 accept() 或 epoll_wait() ，来处理相同的套接字。</p><p>比如，最常用的反向代理服务器 Nginx 就是这么工作的。它也是由主进程和多个 worker 进程组成。主进程主要用来初始化套接字，并管理子进程的生命周期；而 worker 进程，则负责实际的请求处理。我画了一张图来表示这个关系。</p><p><img src="/images/《Linux性能优化实战》学习笔记/主进程多个worker子进程工作模型.png" alt="主进程多个worker子进程工作模型"></p><p>这里要注意，accept() 和 epoll_wait() 调用，还存在一个惊群的问题。换句话说，当网络 I/O 事件发生时，多个进程被同时唤醒，但实际上只有一个进程来响应这个事件，其他被唤醒的进程都会重新休眠。</p></li><li><p>其中，accept() 的惊群问题，已经在 Linux 2.6 中解决了；</p></li><li><p>而 epoll 的问题，到了 Linux 4.5 ，才通过 EPOLLEXCLUSIVE 解决。</p><p>为了避免惊群问题， Nginx 在每个 worker 进程中，都增加一个了全局锁（accept_mutex）。这些 worker 进程需要首先竞争到锁，只有竞争到锁的进程，才会加入到 epoll 中，这样就确保只有一个 worker 子进程被唤醒。</p><p>不过，根据前面 CPU 模块的学习，你应该还记得，进程的管理、调度、上下文切换的成本非常高。那为什么使用多进程模式的 Nginx ，却具有非常好的性能呢？</p><p>这里最主要的一个原因就是，这些 worker 进程，实际上并不需要经常创建和销毁，而是在没任务时休眠，有任务时唤醒。只有在 worker 由于某些异常退出时，主进程才需要创建新的进程来代替它。</p><p>当然，你也可以用线程代替进程：主线程负责套接字初始化和子线程状态的管理，而子线程则负责实际的请求处理。由于线程的调度和切换成本比较低，实际上你可以进一步把 epoll_wait() 都放到主线程中，保证每次事件都只唤醒主线程，而子线程只需要负责后续的请求处理。</p></li></ul></li><li><p><strong>第二种，监听到相同端口的多进程模型。</strong> 在这种方式下，所有的进程都监听相同的接口，并且开启 SO_REUSEPORT 选项，由内核负责将请求负载均衡到这些监听进程中去。这一过程如下图所示。</p><p> <img src="/images/《Linux性能优化实战》学习笔记/监听到相同端口的多进程工作模型.png" alt="监听到相同端口的多进程工作模型"></p><p> 由于内核确保了只有一个进程被唤醒，就不会出现惊群问题了。比如，Nginx 在 1.9.1 中就已经支持了这种模式。</p><p> <img src="/images/《Linux性能优化实战》学习笔记/Nginx监听到相同端口的多进程工作模型.png" alt="Nginx监听到相同端口的多进程工作模型"></p><blockquote><p>图片来自 <a href="https://www.nginx.com/blog/socket-sharding-nginx-release-1-9-1/">Nginx 官网博客</a></p></blockquote></li></ol><h4 id="35-4-C1000K"><a href="#35-4-C1000K" class="headerlink" title="35.4 C1000K"></a>35.4 C1000K</h4><p>首先从物理资源使用上来说，100 万个请求需要大量的系统资源。比如，</p><ul><li>假设每个请求需要 16KB 内存的话，那么总共就需要大约 15 GB 内存。</li><li>而从带宽上来说，假设只有 20% 活跃连接，即使每个连接只需要 1KB/s 的吞吐量，总共也需要 1.6 Gb/s 的吞吐量。千兆网卡显然满足不了这么大的吞吐量，所以还需要配置万兆网卡，或者基于多网卡 Bonding 承载更大的吞吐量。</li></ul><p>其次，从软件资源上来说，大量的连接也会占用大量的软件资源，比如文件描述符的数量、连接状态的跟踪（CONNTRACK）、网络协议栈的缓存大小（比如套接字读写缓存、TCP 读写缓存）等等。</p><p>断负载均衡、CPU 绑定、RPS/RFS（软中断负载均衡到多个 CPU 核上），以及将网络包的处理卸载（Offload）到网络设备（如 TSO/GSO、LRO/GRO、VXLAN OFFLOAD）等各种硬件和软件的优化。</p><p>C1000K 的解决方法，本质上还是构建在 epoll 的非阻塞 I/O 模型上。只不过，除了 I/O 模型之外，还需要从应用程序到 Linux 内核、再到 CPU、内存和网络等各个层次的深度优化，特别是需要借助硬件，来卸载那些原来通过软件处理的大量功能。</p><h4 id="35-5-C10M"><a href="#35-5-C10M" class="headerlink" title="35.5 C10M"></a>35.5 C10M</h4><p>显然，人们对于性能的要求是无止境的。再进一步，有没有可能在单机中，同时处理 1000 万的请求呢？这也就是 <a href="http://c10m.robertgraham.com/p/blog-page.html">C10M</a> 问题。</p><p>实际上，在 C1000K 问题中，各种软件、硬件的优化很可能都已经做到头了。特别是当升级完硬件（比如足够多的内存、带宽足够大的网卡、更多的网络功能卸载等）后，你可能会发现，无论你怎么优化应用程序和内核中的各种网络参数，想实现 1000 万请求的并发，都是极其困难的。</p><p>究其根本，还是 Linux 内核协议栈做了太多太繁重的工作。从网卡中断带来的硬中断处理程序开始，到软中断中的各层网络协议处理，最后再到应用程序，这个路径实在是太长了，就会导致网络包的处理优化，到了一定程度后，就无法更进一步了。</p><p>要解决这个问题，最重要就是跳过内核协议栈的冗长路径，把网络包直接送到要处理的应用程序那里去。这里有两种常见的机制，DPDK 和 XDP。</p><ol><li><p>第一种机制，DPDK，是用户态网络的标准。它跳过内核协议栈，直接由用户态进程通过轮询的方式，来处理网络接收。</p><p> <img src="/images/《Linux性能优化实战》学习笔记/DPDK.png" alt="DPDK"></p><blockquote><p>（图片来自 <a href="https://blog.selectel.com/introduction-dpdk-architecture-principles/">https://blog.selectel.com/introduction-dpdk-architecture-principles/</a>）</p></blockquote><p> 说起轮询，你肯定会下意识认为它是低效的象征，但是进一步反问下自己，它的低效主要体现在哪里呢？是查询时间明显多于实际工作时间的情况下吧！那么，换个角度来想，如果每时每刻都有新的网络包需要处理，轮询的优势就很明显了。比如：</p><ul><li>在 PPS 非常高的场景中，查询时间比实际工作时间少了很多，绝大部分时间都在处理网络包；</li><li><p>而跳过内核协议栈后，就省去了繁杂的硬中断、软中断再到 Linux 网络协议栈逐层处理的过程，应用程序可以针对应用的实际场景，有针对性地优化网络包的处理逻辑，而不需要关注所有的细节。</p><p>此外，DPDK 还通过大页、CPU 绑定、内存对齐、流水线并发等多种机制，优化网络包的处理效率。</p></li></ul></li><li><p>第二种机制，XDP（eXpress Data Path），则是 Linux 内核提供的一种高性能网络数据路径。它允许网络包，在进入内核协议栈之前，就进行处理，也可以带来更高的性能。XDP 底层跟我们之前用到的 bcc-tools 一样，都是基于 Linux 内核的 eBPF 机制实现的。</p><p> XDP 的原理如下图所示：</p><p> <img src="/images/《Linux性能优化实战》学习笔记/XDP.png" alt="XDP"></p><blockquote><p>（图片来自 <a href="https://www.iovisor.org/technology/xdp">https://www.iovisor.org/technology/xdp</a>）</p></blockquote><p> 你可以看到，XDP 对内核的要求比较高，需要的是 Linux <a href="https://github.com/iovisor/bcc/blob/master/docs/kernel-versions.md#xdp">4.8 以上版本</a>，并且它也不提供缓存队列。基于 XDP 的应用程序通常是专用的网络应用，常见的有 IDS（入侵检测系统）、DDoS 防御、 <a href="https://github.com/cilium/cilium">cilium</a> 容器网络插件等。</p></li></ol><h4 id="35-4-小结"><a href="#35-4-小结" class="headerlink" title="35.4 小结"></a>35.4 小结</h4><p>C10K 问题的根源，一方面在于系统有限的资源；另一方面，也是更重要的因素，是同步阻塞的 I/O 模型以及轮询的套接字接口，限制了网络事件的处理效率。Linux 2.6 中引入的 epoll ，完美解决了 C10K 的问题，现在的高性能网络方案都基于 epoll。</p><p>从 C10K 到 C100K ，可能只需要增加系统的物理资源就可以满足；但从 C100K 到 C1000K ，就不仅仅是增加物理资源就能解决的问题了。这时，就需要多方面的优化工作了，从硬件的中断处理和网络功能卸载、到网络协议栈的文件描述符数量、连接状态跟踪、缓存队列等内核的优化，再到应用程序的工作模型优化，都是考虑的重点。</p><p>再进一步，要实现 C10M ，就不只是增加物理资源，或者优化内核和应用程序可以解决的问题了。这时候，就需要用 XDP 的方式，在内核协议栈之前处理网络包；或者用 DPDK 直接跳过网络协议栈，在用户空间通过轮询的方式直接处理网络包。</p><p>当然了，实际上，在大多数场景中，我们并不需要单机并发 1000 万的请求。通过调整系统架构，把这些请求分发到多台服务器中来处理，通常是更简单和更容易扩展的方案。</p><h3 id="36-套路篇：怎么评估系统的网络性能？"><a href="#36-套路篇：怎么评估系统的网络性能？" class="headerlink" title="36 | 套路篇：怎么评估系统的网络性能？"></a>36 | 套路篇：怎么评估系统的网络性能？</h3><h4 id="36-1-性能指标回顾"><a href="#36-1-性能指标回顾" class="headerlink" title="36.1 性能指标回顾"></a>36.1 性能指标回顾</h4><ol><li><p>首先，<strong>带宽</strong>，表示链路的最大传输速率，单位是 b/s（比特 / 秒）。在你为服务器选购网卡时，带宽就是最核心的参考指标。常用的带宽有 1000M、10G、40G、100G 等。</p></li><li><p>第二，<strong>吞吐量</strong>，表示没有丢包时的最大数据传输速率，单位通常为 b/s （比特 / 秒）或者 B/s（字节 / 秒）。吞吐量受带宽的限制，吞吐量 / 带宽也就是该网络链路的使用率。</p></li><li><p>第三，<strong>延时</strong>，表示从网络请求发出后，一直到收到远端响应，所需要的时间延迟。这个指标在不同场景中可能会有不同的含义。它可以表示建立连接需要的时间（比如 TCP 握手延时），或者一个数据包往返所需时间（比如 RTT）。</p></li><li><p>最后，<strong>PPS</strong>，是 Packet Per Second（包 / 秒）的缩写，表示以网络包为单位的传输速率。PPS 通常用来评估网络的转发能力，而基于 Linux 服务器的转发，很容易受到网络包大小的影响（交换机通常不会受到太大影响，即交换机可以线性转发）。</p></li></ol><p>这四个指标中，带宽跟物理网卡配置是直接关联的。一般来说，网卡确定后，带宽也就确定了（当然，实际带宽会受限于整个网络链路中最小的那个模块）。</p><p>另外，你可能在很多地方听说过“网络带宽测试”，这里测试的实际上不是带宽，而是网络吞吐量。Linux 服务器的网络吞吐量一般会比带宽小，而对交换机等专门的网络设备来说，吞吐量一般会接近带宽。</p><p>最后的 PPS，则是以网络包为单位的网络传输速率，通常用在需要大量转发的场景中。而对 TCP 或者 Web 服务来说，更多会用并发连接数和每秒请求数（QPS，Query per Second）等指标，它们更能反应实际应用程序的性能。</p><h4 id="36-2-网络基准测试"><a href="#36-2-网络基准测试" class="headerlink" title="36.2 网络基准测试"></a>36.2 网络基准测试</h4><p>测试之前，你应该弄清楚，你要评估的网络性能，究竟属于协议栈的哪一层？换句话说，你的应用程序基于协议栈的哪一层呢？</p><p>根据前面学过的 TCP/IP 协议栈的原理，这个问题应该不难回答。比如：</p><ul><li>基于 HTTP 或者 HTTPS 的 Web 应用程序，显然属于应用层，需要我们测试 HTTP/HTTPS 的性能；</li><li>而对大多数游戏服务器来说，为了支持更大的同时在线人数，通常会基于 TCP 或 UDP ，与客户端进行交互，这时就需要我们测试 TCP/UDP 的性能；</li><li>当然，还有一些场景，是把 Linux 作为一个软交换机或者路由器来用的。这种情况下，你更关注网络包的处理能力（即 PPS），重点关注网络层的转发性能。</li></ul><p>接下来，我就带你从下往上，了解不同协议层的网络性能测试方法。不过要注意，低层协议是其上的各层网络协议的基础。自然，低层协议的性能，也就决定了高层的网络性能。</p><h4 id="36-3-各协议层的性能测试"><a href="#36-3-各协议层的性能测试" class="headerlink" title="36.3 各协议层的性能测试"></a>36.3 各协议层的性能测试</h4><ol><li><p>转发性能</p><p> 我们首先来看，网络接口层和网络层，它们主要负责网络包的封装、寻址、路由以及发送和接收。在这两个网络协议层中，每秒可处理的网络包数 PPS，就是最重要的性能指标。特别是 64B 小包的处理能力，值得我们特别关注。那么，如何来测试网络包的处理能力呢？</p><p> 说到网络包相关的测试，你可能会觉得陌生。不过，其实在专栏开头的 CPU 性能篇中，我们就接触过一个相关工具，也就是软中断案例中的 hping3。</p><p> 在那个案例中，hping3 作为一个 SYN 攻击的工具来使用。实际上， hping3 更多的用途，是作为一个测试网络包处理能力的性能工具。</p><p> 今天我再来介绍另一个更常用的工具，Linux 内核自带的高性能网络测试工具 pktgen。pktgen 支持丰富的自定义选项，方便你根据实际需要构造所需网络包，从而更准确地测试出目标服务器的性能。</p><p> 不过，在 Linux 系统中，你并不能直接找到 pktgen 命令。因为 pktgen 作为一个内核线程来运行，需要你加载 pktgen 内核模块后，再通过 /proc 文件系统来交互。下面就是 pktgen 启动的两个内核线程和 /proc 文件系统的交互文件：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ modprobe pktgen$ <span class="token function">ps</span> -ef <span class="token operator">|</span> <span class="token function">grep</span> pktgen <span class="token operator">|</span> <span class="token function">grep</span> -v <span class="token function">grep</span>root     <span class="token number">26384</span>     <span class="token number">2</span>  <span class="token number">0</span> 06:17 ?        00:00:00 <span class="token punctuation">[</span>kpktgend_0<span class="token punctuation">]</span>root     <span class="token number">26385</span>     <span class="token number">2</span>  <span class="token number">0</span> 06:17 ?        00:00:00 <span class="token punctuation">[</span>kpktgend_1<span class="token punctuation">]</span>$ <span class="token function">ls</span> /proc/net/pktgen/kpktgend_0  kpktgend_1  pgctrl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> pktgen 在每个 CPU 上启动一个内核线程，并可以通过 /proc/net/pktgen 下面的同名文件，跟这些线程交互；而 pgctrl 则主要用来控制这次测试的开启和停止。</p><blockquote><p>如果 modprobe 命令执行失败，说明你的内核没有配置 CONFIG_NET_PKTGEN 选项。这就需要你配置 pktgen 内核模块（即 CONFIG_NET_PKTGEN=m）后，重新编译内核，才可以使用。</p></blockquote><p> 在使用 pktgen 测试网络性能时，需要先给每个内核线程 kpktgend_X 以及测试网卡，配置 pktgen 选项，然后再通过 pgctrl 启动测试。</p><p> 以发包测试为例，假设发包机器使用的网卡是 eth0，而目标机器的 IP 地址为 192.168.0.30，MAC 地址为 11:11:11:11:11:11。</p><p> 接下来，就是一个发包测试的示例。</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 定义一个工具函数，方便后面配置各种测试选项</span><span class="token keyword">function</span> <span class="token function-name function">pgset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token builtin class-name">local</span> result    <span class="token builtin class-name">echo</span> <span class="token variable">$1</span> <span class="token operator">&gt;</span> <span class="token variable">$PGDEV</span>    <span class="token assign-left variable">result</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">cat</span> $PGDEV <span class="token operator">|</span> <span class="token function">fgrep</span> <span class="token string">"Result: OK:"</span><span class="token variable">`</span></span>    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$result</span>"</span> <span class="token operator">=</span> <span class="token string">""</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>         <span class="token function">cat</span> <span class="token variable">$PGDEV</span> <span class="token operator">|</span> <span class="token function">fgrep</span> Result:    <span class="token keyword">fi</span><span class="token punctuation">}</span><span class="token comment"># 为 0 号线程绑定 eth0 网卡</span><span class="token assign-left variable">PGDEV</span><span class="token operator">=</span>/proc/net/pktgen/kpktgend_0pgset <span class="token string">"rem_device_all"</span>   <span class="token comment"># 清空网卡绑定</span>pgset <span class="token string">"add_device eth0"</span>  <span class="token comment"># 添加 eth0 网卡</span><span class="token comment"># 配置 eth0 网卡的测试选项</span><span class="token assign-left variable">PGDEV</span><span class="token operator">=</span>/proc/net/pktgen/eth0pgset <span class="token string">"count 1000000"</span>    <span class="token comment"># 总发包数量</span>pgset <span class="token string">"delay 5000"</span>       <span class="token comment"># 不同包之间的发送延迟 (单位纳秒)</span>pgset <span class="token string">"clone_skb 0"</span>      <span class="token comment"># SKB 包复制</span>pgset <span class="token string">"pkt_size 64"</span>      <span class="token comment"># 网络包大小</span>pgset <span class="token string">"dst 192.168.0.30"</span> <span class="token comment"># 目的 IP</span>pgset <span class="token string">"dst_mac 11:11:11:11:11:11"</span>  <span class="token comment"># 目的 MAC</span><span class="token comment"># 启动测试</span><span class="token assign-left variable">PGDEV</span><span class="token operator">=</span>/proc/net/pktgen/pgctrlpgset <span class="token string">"start"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 稍等一会儿，测试完成后，结果可以从 /proc 文件系统中获取。通过下面代码段中的内容，我们可以查看刚才的测试报告：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> /proc/net/pktgen/eth0Params: count <span class="token number">1000000</span>  min_pkt_size: <span class="token number">64</span>  max_pkt_size: <span class="token number">64</span>    frags: <span class="token number">0</span>  delay: <span class="token number">0</span>  clone_skb: <span class="token number">0</span>  ifname: eth0    flows: <span class="token number">0</span> flowlen: <span class="token number">0</span><span class="token punctuation">..</span>.Current:    pkts-sofar: <span class="token number">1000000</span>  errors: <span class="token number">0</span>    started: 1534853256071us  stopped: 1534861576098us idle: 70673us<span class="token punctuation">..</span>.Result: OK: <span class="token number">8320027</span><span class="token punctuation">(</span>c8249354+d70673<span class="token punctuation">)</span> usec, <span class="token number">1000000</span> <span class="token punctuation">(</span>64byte,0frags<span class="token punctuation">)</span>120191pps 61Mb/sec <span class="token punctuation">(</span>61537792bps<span class="token punctuation">)</span> errors: <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 你可以看到，测试报告主要分为三个部分：</p><ul><li>第一部分的 Params 是测试选项；</li><li>第二部分的 Current 是测试进度，其中， packts so far（pkts-sofar）表示已经发送了 100 万个包，也就表明测试已完成。</li><li><p>第三部分的 Result 是测试结果，包含测试所用时间、网络包数量和分片、PPS、吞吐量以及错误数。</p><p>根据上面的结果，我们发现，PPS 为 12 万，吞吐量为 61 Mb/s，没有发生错误。那么，12 万的 PPS 好不好呢？</p><p>作为对比，你可以计算一下千兆交换机的 PPS。交换机可以达到线速（满负载时，无差错转发），它的 PPS 就是 1000Mbit 除以以太网帧的大小，即 1000Mbps/((64+20)*8bit) = 1.5 Mpps（其中，20B 为以太网帧前导和帧间距的大小）。</p><p>你看，即使是千兆交换机的 PPS，也可以达到 150 万 PPS，比我们测试得到的 12 万大多了。所以，看到这个数值你并不用担心，现在的多核服务器和万兆网卡已经很普遍了，稍做优化就可以达到数百万的 PPS。而且，如果你用了上节课讲到的 DPDK 或 XDP ，还能达到千万数量级。</p></li></ul></li><li><p>TCP/UDP 性能</p><p> 掌握了 PPS 的测试方法，接下来，我们再来看 TCP 和 UDP 的性能测试方法。说到 TCP 和 UDP 的测试，我想你已经很熟悉了，甚至可能一下子就能想到相应的测试工具，比如 iperf 或者 netperf。</p><p> 特别是现在的云计算时代，在你刚拿到一批虚拟机时，首先要做的，应该就是用 iperf ，测试一下网络性能是否符合预期。</p><p> iperf 和 netperf 都是最常用的网络性能测试工具，测试 TCP 和 UDP 的吞吐量。它们都以客户端和服务器通信的方式，测试一段时间内的平均吞吐量。</p><p> 接下来，我们就以 iperf 为例，看一下 TCP 性能的测试方法。目前，iperf 的最新版本为 iperf3，你可以运行下面的命令来安装：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Ubuntu</span><span class="token function">apt-get</span> <span class="token function">install</span> iperf3<span class="token comment"># CentOS</span>yum <span class="token function">install</span> iperf3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 然后，在目标机器上启动 iperf 服务端：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -s 表示启动服务端，-i 表示汇报间隔，-p 表示监听端口</span>$ iperf3 -s -i <span class="token number">1</span> -p <span class="token number">10000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 接着，在另一台机器上运行 iperf 客户端，运行测试：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -c 表示启动客户端，192.168.0.30 为目标服务器的 IP</span><span class="token comment"># -b 表示目标带宽 (单位是 bits/s)</span><span class="token comment"># -t 表示测试时间</span><span class="token comment"># -P 表示并发数，-p 表示目标服务器监听端口</span>$ iperf3 -c <span class="token number">192.168</span>.0.30 -b 1G -t <span class="token number">15</span> -P <span class="token number">2</span> -p <span class="token number">10000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 稍等一会儿（15 秒）测试结束后，回到目标服务器，查看 iperf 的报告：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span> ID<span class="token punctuation">]</span> Interval           Transfer     Bandwidth<span class="token punctuation">..</span>.<span class="token punctuation">[</span>SUM<span class="token punctuation">]</span>   <span class="token number">0.00</span>-15.04  sec  <span class="token number">0.00</span> Bytes  <span class="token number">0.00</span> bits/sec                  sender<span class="token punctuation">[</span>SUM<span class="token punctuation">]</span>   <span class="token number">0.00</span>-15.04  sec  <span class="token number">1.51</span> GBytes   <span class="token number">860</span> Mbits/sec                  receiver<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 最后的 SUM 行就是测试的汇总结果，包括测试时间、数据传输量以及带宽等。按照发送和接收，这一部分又分为了 sender 和 receiver 两行。</p><p> 从测试结果你可以看到，这台机器 TCP 接收的带宽（吞吐量）为 860 Mb/s， 跟目标的 1Gb/s 相比，还是有些差距的。</p></li><li><p>HTTP 性能</p><p> 要测试 HTTP 的性能，也有大量的工具可以使用，比如 ab、webbench 等，都是常用的 HTTP 压力测试工具。其中，ab 是 Apache 自带的 HTTP 压测工具，主要测试 HTTP 服务的每秒请求数、请求延迟、吞吐量以及请求延迟的分布情况等。</p><p> 运行下面的命令，你就可以安装 ab 工具：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Ubuntu</span>$ <span class="token function">apt-get</span> <span class="token function">install</span> -y apache2-utils<span class="token comment"># CentOS</span>$ yum <span class="token function">install</span> -y httpd-tools<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 接下来，在目标机器上，使用 Docker 启动一个 Nginx 服务，然后用 ab 来测试它的性能。首先，在目标机器上运行下面的命令：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run -p <span class="token number">80</span>:80 -itd nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 而在另一台机器上，运行 ab 命令，测试 Nginx 的性能：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -c 表示并发请求数为 1000，-n 表示总的请求数为 10000</span>$ ab -c <span class="token number">1000</span> -n <span class="token number">10000</span> http://192.168.0.30/<span class="token punctuation">..</span>.Server Software:        nginx/1.15.8Server Hostname:        <span class="token number">192.168</span>.0.30Server Port:            <span class="token number">80</span><span class="token punctuation">..</span>.Requests per second:    <span class="token number">1078.54</span> <span class="token punctuation">[</span><span class="token comment">#/sec] (mean)</span>Time per request:       <span class="token number">927.183</span> <span class="token punctuation">[</span>ms<span class="token punctuation">]</span> <span class="token punctuation">(</span>mean<span class="token punctuation">)</span>Time per request:       <span class="token number">0.927</span> <span class="token punctuation">[</span>ms<span class="token punctuation">]</span> <span class="token punctuation">(</span>mean, across all concurrent requests<span class="token punctuation">)</span>Transfer rate:          <span class="token number">890.00</span> <span class="token punctuation">[</span>Kbytes/sec<span class="token punctuation">]</span> receivedConnection Times <span class="token punctuation">(</span>ms<span class="token punctuation">)</span>              min  mean<span class="token punctuation">[</span>+/-sd<span class="token punctuation">]</span> median   maxConnect:        <span class="token number">0</span>   <span class="token number">27</span> <span class="token number">152.1</span>      <span class="token number">1</span>    <span class="token number">1038</span>Processing:     <span class="token number">9</span>  <span class="token number">207</span> <span class="token number">843.0</span>     <span class="token number">22</span>    <span class="token number">9242</span>Waiting:        <span class="token number">8</span>  <span class="token number">207</span> <span class="token number">843.0</span>     <span class="token number">22</span>    <span class="token number">9242</span>Total:         <span class="token number">15</span>  <span class="token number">233</span> <span class="token number">857.7</span>     <span class="token number">23</span>    <span class="token number">9268</span>Percentage of the requests served within a certain <span class="token function">time</span> <span class="token punctuation">(</span>ms<span class="token punctuation">)</span>  <span class="token number">50</span>%     <span class="token number">23</span>  <span class="token number">66</span>%     <span class="token number">24</span>  <span class="token number">75</span>%     <span class="token number">24</span>  <span class="token number">80</span>%     <span class="token number">26</span>  <span class="token number">90</span>%    <span class="token number">274</span>  <span class="token number">95</span>%   <span class="token number">1195</span>  <span class="token number">98</span>%   <span class="token number">2335</span>  <span class="token number">99</span>%   <span class="token number">4663</span> <span class="token number">100</span>%   <span class="token number">9268</span> <span class="token punctuation">(</span>longest request<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 可以看到，ab 的测试结果分为三个部分，分别是请求汇总、连接时间汇总还有请求延迟汇总。以上面的结果为例，我们具体来看。</p><p> 在请求汇总部分，你可以看到：</p><ul><li>Requests per second 为 1074；</li><li>每个请求的延迟（Time per request）分为两行，第一行的 927 ms 表示平均延迟，包括了线程运行的调度时间和网络请求响应时间，而下一行的 0.927ms ，则表示实际请求的响应时间；</li><li><p>Transfer rate 表示吞吐量（BPS）为 890 KB/s。</p><p>连接时间汇总部分，则是分别展示了建立连接、请求、等待以及汇总等的各类时间，包括最小、最大、平均以及中值处理时间。</p><p>最后的请求延迟汇总部分，则给出了不同时间段内处理请求的百分比，比如， 90% 的请求，都可以在 274ms 内完成。</p></li></ul></li><li><p>应用负载性能</p><p> 当你用 iperf 或者 ab 等测试工具，得到 TCP、HTTP 等的性能数据后，这些数据是否就能表示应用程序的实际性能呢？我想，你的答案应该是否定的。</p><p> 比如，你的应用程序基于 HTTP 协议，为最终用户提供一个 Web 服务。这时，使用 ab 工具，可以得到某个页面的访问性能，但这个结果跟用户的实际请求，很可能不一致。因为用户请求往往会附带着各种各种的负载（payload），而这些负载会影响 Web 应用程序内部的处理逻辑，从而影响最终性能。</p><p> 那么，为了得到应用程序的实际性能，就要求性能工具本身可以模拟用户的请求负载，而 iperf、ab 这类工具就无能为力了。幸运的是，我们还可以用 wrk、TCPCopy、Jmeter 或者 LoadRunner 等实现这个目标。</p><p> 以 <a href="https://github.com/wg/wrk">wrk</a> 为例，它是一个 HTTP 性能测试工具，内置了 LuaJIT，方便你根据实际需求，生成所需的请求负载，或者自定义响应的处理方法。</p><p> wrk 工具本身不提供 yum 或 apt 的安装方法，需要通过源码编译来安装。比如，你可以运行下面的命令，来编译和安装 wrk：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ https://github.com/wg/wrk$ <span class="token builtin class-name">cd</span> wrk$ <span class="token function">apt-get</span> <span class="token function">install</span> build-essential -y$ <span class="token function">make</span>$ <span class="token function">sudo</span> <span class="token function">cp</span> wrk /usr/local/bin/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> wrk 的命令行参数比较简单。比如，我们可以用 wrk ，来重新测一下前面已经启动的 Nginx 的性能。</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -c 表示并发连接数 1000，-t 表示线程数为 2</span>$ wrk -c <span class="token number">1000</span> -t <span class="token number">2</span> http://192.168.0.30/Running 10s <span class="token builtin class-name">test</span> @ http://192.168.0.30/  <span class="token number">2</span> threads and <span class="token number">1000</span> connections  Thread Stats   Avg      Stdev     Max   +/- Stdev    Latency    <span class="token number">65</span>.83ms  <span class="token number">174</span>.06ms   <span class="token number">1</span>.99s    <span class="token number">95.85</span>%    Req/Sec     <span class="token number">4</span>.87k   <span class="token number">628.73</span>     <span class="token number">6</span>.78k    <span class="token number">69.00</span>%  <span class="token number">96954</span> requests <span class="token keyword">in</span> <span class="token number">10</span>.06s, <span class="token number">78</span>.59MB <span class="token builtin class-name">read</span>  Socket errors: connect <span class="token number">0</span>, <span class="token builtin class-name">read</span> <span class="token number">0</span>, <span class="token function">write</span> <span class="token number">0</span>, <span class="token function">timeout</span> <span class="token number">179</span>Requests/sec:   <span class="token number">9641.31</span>Transfer/sec:      <span class="token number">7</span>.82MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 这里使用 2 个线程、并发 1000 连接，重新测试了 Nginx 的性能。你可以看到，每秒请求数为 9641，吞吐量为 7.82MB，平均延迟为 65ms，比前面 ab 的测试结果要好很多。</p><p> 这也说明，性能工具本身的性能，对性能测试也是至关重要的。不合适的性能工具，并不能准确测出应用程序的最佳性能。</p><p> 当然，wrk 最大的优势，是其内置的 LuaJIT，可以用来实现复杂场景的性能测试。wrk 在调用 Lua 脚本时，可以将 HTTP 请求分为三个阶段，即 setup、running、done，如下图所示：</p><p> <img src="/images/《Linux性能优化实战》学习笔记/wrk脚本执行流程.png" alt="wrk脚本执行流程"></p><blockquote><p>图片来自<a href="https://sq.163yun.com/blog/article/200008406328934400">网易云博客</a></p></blockquote><p> 比如，你可以在 setup 阶段，为请求设置认证参数（来自于 wrk 官方<a href="https://github.com/wg/wrk/blob/master/scripts/auth.lua">示例</a>）：</p> <pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token comment">-- example script that demonstrates response handling and</span><span class="token comment">-- retrieving an authentication token to set on all future</span><span class="token comment">-- requests</span>token <span class="token operator">=</span> <span class="token keyword">nil</span>path  <span class="token operator">=</span> <span class="token string">"/authenticate"</span>request <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token keyword">return</span> wrk<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token keyword">end</span>response <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>status<span class="token punctuation">,</span> headers<span class="token punctuation">,</span> body<span class="token punctuation">)</span>   <span class="token keyword">if</span> <span class="token keyword">not</span> token <span class="token keyword">and</span> status <span class="token operator">==</span> <span class="token number">200</span> <span class="token keyword">then</span>      token <span class="token operator">=</span> headers<span class="token punctuation">[</span><span class="token string">"X-Token"</span><span class="token punctuation">]</span>      path  <span class="token operator">=</span> <span class="token string">"/resource"</span>      wrk<span class="token punctuation">.</span>headers<span class="token punctuation">[</span><span class="token string">"X-Token"</span><span class="token punctuation">]</span> <span class="token operator">=</span> token   <span class="token keyword">end</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 而在执行测试时，通过 -s 选项，执行脚本的路径：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ wrk -c <span class="token number">1000</span> -t <span class="token number">2</span> -s auth.lua http://192.168.0.30/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> wrk 需要你用 Lua 脚本，来构造请求负载。这对于大部分场景来说，可能已经足够了 。不过，它的缺点也正是，所有东西都需要代码来构造，并且工具本身不提供 GUI 环境。</p><p> 像 Jmeter 或者 LoadRunner（商业产品），则针对复杂场景提供了脚本录制、回放、GUI 等更丰富的功能，使用起来也更加方便。</p></li></ol><h4 id="36-4-小结"><a href="#36-4-小结" class="headerlink" title="36.4 小结"></a>36.4 小结</h4><p>性能评估是优化网络性能的前提，只有在你发现网络性能瓶颈时，才需要进行网络性能优化。根据 TCP/IP 协议栈的原理，不同协议层关注的性能重点不完全一样，也就对应不同的性能测试方法。比如，</p><ul><li>在应用层，你可以使用 wrk、Jmeter 等模拟用户的负载，测试应用程序的每秒请求数、处理延迟、错误数等；</li><li>而在传输层，则可以使用 iperf 等工具，测试 TCP 的吞吐情况；</li><li>再向下，你还可以用 Linux 内核自带的 pktgen ，测试服务器的 PPS。</li></ul><p>由于低层协议是高层协议的基础。所以，一般情况下，我们需要从上到下，对每个协议层进行性能测试，然后根据性能测试的结果，结合 Linux 网络协议栈的原理，找出导致性能瓶颈的根源，进而优化网络性能。</p><h3 id="37-案例篇：DNS-解析时快时慢，我该怎么办？"><a href="#37-案例篇：DNS-解析时快时慢，我该怎么办？" class="headerlink" title="37 | 案例篇：DNS 解析时快时慢，我该怎么办？"></a>37 | 案例篇：DNS 解析时快时慢，我该怎么办？</h3><h4 id="37-1-域名与-DNS-解析"><a href="#37-1-域名与-DNS-解析" class="headerlink" title="37.1 域名与 DNS 解析"></a>37.1 域名与 DNS 解析</h4><p>域名我们本身都比较熟悉，由一串用点分割开的字符组成，被用作互联网中的某一台或某一组计算机的名称，目的就是为了方便识别，互联网中提供各种服务的主机位置。</p><p>要注意，域名是全球唯一的，需要通过专门的域名注册商才可以申请注册。为了组织全球互联网中的众多计算机，域名同样用点来分开，形成一个分层的结构。而每个被点分割开的字符串，就构成了域名中的一个层级，并且位置越靠后，层级越高。</p><p>我们以极客时间的网站 time.geekbang.org 为例，来理解域名的含义。这个字符串中，最后面的 org 是顶级域名，中间的 geekbang 是二级域名，而最左边的 time 则是三级域名。</p><p>如下图所示，注意点（.）是所有域名的根，也就是说所有域名都以点作为后缀，也可以理解为，在域名解析的过程中，所有域名都以点结束。</p><p><img src="/images/《Linux性能优化实战》学习笔记/域名结构.png" alt="域名结构"></p><p>域名主要是为了方便让人记住，而 IP 地址是机器间的通信的真正机制。把域名转换为 IP 地址的服务，也就是我们开头提到的，域名解析服务（DNS），而对应的服务器就是域名服务器，网络协议则是 DNS 协议。</p><p>这里注意，DNS 协议在 TCP/IP 栈中属于应用层，不过实际传输还是基于 UDP 或者 TCP 协议（UDP 居多） ，并且域名服务器一般监听在端口 53 上。</p><p>既然域名以分层的结构进行管理，相对应的，域名解析其实也是用递归的方式（从顶级开始，以此类推），发送给每个层级的域名服务器，直到得到解析结果。</p><p>不过不要担心，递归查询的过程并不需要你亲自操作，DNS 服务器会替你完成，你要做的，只是预先配置一个可用的 DNS 服务器就可以了。</p><p>当然，我们知道，通常来说，每级 DNS 服务器，都会有最近解析记录的缓存。当缓存命中时，直接用缓存中的记录应答就可以了。如果缓存过期或者不存在，才需要用刚刚提到的递归方式查询。</p><p>所以，系统管理员在配置 Linux 系统的网络时，除了需要配置 IP 地址，还需要给它配置 DNS 服务器，这样它才可以通过域名来访问外部服务。</p><p>比如，我的系统配置的就是 114.114.114.114 这个域名服务器。你可以执行下面的命令，来查询你的系统配置：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> /etc/resolv.confnameserver <span class="token number">114.114</span>.114.114<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>另外，DNS 服务通过资源记录的方式，来管理所有数据，它支持 A、CNAME、MX、NS、PTR 等多种类型的记录。比如：</p><ul><li>A 记录，用来把域名转换成 IP 地址；</li><li>CNAME 记录，用来创建别名；</li><li>而 NS 记录，则表示该域名对应的域名服务器地址。</li></ul><p>简单来说，当我们访问某个网址时，就需要通过 DNS 的 A 记录，查询该域名对应的 IP 地址，然后再通过该 IP 来访问 Web 服务。</p><p>比如，还是以极客时间的网站 time.geekbang.org 为例，执行下面的 nslookup 命令，就可以查询到这个域名的 A 记录，可以看到，它的 IP 地址是 39.106.233.176：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">nslookup</span> time.geekbang.org<span class="token comment"># 域名服务器及端口信息</span>Server:     <span class="token number">114.114</span>.114.114Address:    <span class="token number">114.114</span>.114.114<span class="token comment">#53</span><span class="token comment"># 非权威查询结果</span>Non-authoritative answer:Name:   time.geekbang.orgAddress: <span class="token number">39.106</span>.233.17<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里要注意，由于 114.114.114.114 并不是直接管理 time.geekbang.org 的域名服务器，所以查询结果是非权威的。使用上面的命令，你只能得到 114.114.114.114 查询的结果。</p><p>前面还提到了，如果没有命中缓存，DNS 查询实际上是一个递归过程，那有没有方法可以知道整个递归查询的执行呢？</p><p>其实除了 nslookup，另外一个常用的 DNS 解析工具 dig ，就提供了 trace 功能，可以展示递归查询的整个过程。比如你可以执行下面的命令，得到查询结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># +trace 表示开启跟踪查询</span><span class="token comment"># +nodnssec 表示禁止 DNS 安全扩展</span>$ <span class="token function">dig</span> +trace +nodnssec time.geekbang.org<span class="token punctuation">;</span> <span class="token operator">&lt;&lt;</span><span class="token operator">&gt;&gt;</span> DiG <span class="token number">9.11</span>.3-1ubuntu1.3-Ubuntu <span class="token operator">&lt;&lt;</span><span class="token operator">&gt;&gt;</span> +trace +nodnssec time.geekbang.org<span class="token punctuation">;</span><span class="token punctuation">;</span> global options: +cmd<span class="token builtin class-name">.</span>           <span class="token number">322086</span>  IN  NS  m.root-servers.net.<span class="token builtin class-name">.</span>           <span class="token number">322086</span>  IN  NS  a.root-servers.net.<span class="token builtin class-name">.</span>           <span class="token number">322086</span>  IN  NS  i.root-servers.net.<span class="token builtin class-name">.</span>           <span class="token number">322086</span>  IN  NS  d.root-servers.net.<span class="token builtin class-name">.</span>           <span class="token number">322086</span>  IN  NS  g.root-servers.net.<span class="token builtin class-name">.</span>           <span class="token number">322086</span>  IN  NS  l.root-servers.net.<span class="token builtin class-name">.</span>           <span class="token number">322086</span>  IN  NS  c.root-servers.net.<span class="token builtin class-name">.</span>           <span class="token number">322086</span>  IN  NS  b.root-servers.net.<span class="token builtin class-name">.</span>           <span class="token number">322086</span>  IN  NS  h.root-servers.net.<span class="token builtin class-name">.</span>           <span class="token number">322086</span>  IN  NS  e.root-servers.net.<span class="token builtin class-name">.</span>           <span class="token number">322086</span>  IN  NS  k.root-servers.net.<span class="token builtin class-name">.</span>           <span class="token number">322086</span>  IN  NS  j.root-servers.net.<span class="token builtin class-name">.</span>           <span class="token number">322086</span>  IN  NS  f.root-servers.net.<span class="token punctuation">;</span><span class="token punctuation">;</span> Received <span class="token number">239</span> bytes from <span class="token number">114.114</span>.114.114<span class="token comment">#53(114.114.114.114) in 1340 ms</span>org.            <span class="token number">172800</span>  IN  NS  a0.org.afilias-nst.info.org.            <span class="token number">172800</span>  IN  NS  a2.org.afilias-nst.info.org.            <span class="token number">172800</span>  IN  NS  b0.org.afilias-nst.org.org.            <span class="token number">172800</span>  IN  NS  b2.org.afilias-nst.org.org.            <span class="token number">172800</span>  IN  NS  c0.org.afilias-nst.info.org.            <span class="token number">172800</span>  IN  NS  d0.org.afilias-nst.org.<span class="token punctuation">;</span><span class="token punctuation">;</span> Received <span class="token number">448</span> bytes from <span class="token number">198.97</span>.190.53<span class="token comment">#53(h.root-servers.net) in 708 ms</span>geekbang.org.       <span class="token number">86400</span>   IN  NS  dns9.hichina.com.geekbang.org.       <span class="token number">86400</span>   IN  NS  dns10.hichina.com.<span class="token punctuation">;</span><span class="token punctuation">;</span> Received <span class="token number">96</span> bytes from <span class="token number">199.19</span>.54.1<span class="token comment">#53(b0.org.afilias-nst.org) in 1833 ms</span>time.geekbang.org.  <span class="token number">600</span> IN  A   <span class="token number">39.106</span>.233.176<span class="token punctuation">;</span><span class="token punctuation">;</span> Received <span class="token number">62</span> bytes from <span class="token number">140.205</span>.41.16<span class="token comment">#53(dns10.hichina.com) in 4 ms</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>dig trace 的输出，主要包括四部分。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">- 第一部分，是从 <span class="token number">114.114</span>.114.114 查到的一些根域名服务器（.）的 NS 记录。- 第二部分，是从 NS 记录结果中选一个（h.root-servers.net），并查询顶级域名 org. 的 NS 记录。- 第三部分，是从 org. 的 NS 记录中选择一个（b0.org.afilias-nst.org），并查询二级域名 geekbang.org. 的 NS 服务器。- 最后一部分，就是从 geekbang.org. 的 NS 服务器（dns10.hichina.com）查询最终主机 time.geekbang.org. 的 A 记录。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这个输出里展示的各级域名的 NS 记录，其实就是各级域名服务器的地址，可以让你更清楚 DNS 解析的过程。</p><p><img src="/images/《Linux性能优化实战》学习笔记/DNS解析的过程.png" alt="DNS解析的过程"></p><p>当然，不仅仅是发布到互联网的服务需要域名，很多时候，我们也希望能对局域网内部的主机进行域名解析（即内网域名，大多数情况下为主机名）。Linux 也支持这种行为。</p><p>所以，你可以把主机名和 IP 地址的映射关系，写入本机的 /etc/hosts 文件中。这样，指定的主机名就可以在本地直接找到目标 IP。比如，你可以执行下面的命令来操作：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> /etc/hosts<span class="token number">127.0</span>.0.1   localhost localhost.localdomain::1         localhost6 localhost6.localdomain6<span class="token number">192.168</span>.0.100 domain.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>或者，你还可以在内网中，搭建自定义的 DNS 服务器，专门用来解析内网中的域名。而内网 DNS 服务器，一般还会设置一个或多个上游 DNS 服务器，用来解析外网的域名。</p><h4 id="37-2-案例"><a href="#37-2-案例" class="headerlink" title="37.2 案例"></a>37.2 案例</h4><blockquote><p>机器配置： 2 CPU, 8 GB 内存。</p><p>安装软件：<code>apt install docker.io</code>。</p></blockquote><p>你可以先打开一个终端，SSH 登录到 Ubuntu 机器中，然后执行下面的命令，拉取案例中使用的 Docker 镜像：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker pull feisky/dnsutilsUsing default tag: latest<span class="token punctuation">..</span>.Status: Downloaded newer image <span class="token keyword">for</span> feisky/dnsutils:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后，运行下面的命令，查看主机当前配置的 DNS 服务器：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> /etc/resolv.confnameserver <span class="token number">114.114</span>.114.114<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以看到，我这台主机配置的 DNS 服务器是 114.114.114.114。</p><ol><li><p>案例 1：DNS 解析失败</p><p> 首先，执行下面的命令，进入今天的第一个案例。如果一切正常，你将可以看到下面这个输出：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 进入案例环境的 SHELL 终端中</span>$ docker run -it --rm -v <span class="token variable"><span class="token variable">$(</span>mktemp<span class="token variable">)</span></span>:/etc/resolv.conf feisky/dnsutils <span class="token function">bash</span>root@7e9ed6ed4974:/<span class="token comment">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 注意，这儿 root 后面的 7e9ed6ed4974，是 Docker 生成容器的 ID 前缀，你的环境中很可能是不同的 ID，所以直接忽略这一项就可以了。</p><blockquote><p>注意：下面的代码段中， /# 开头的命令都表示在容器内部运行的命令。</p></blockquote><p> 接着，继续在容器终端中，执行 DNS 查询命令，我们还是查询 time.geekbang.org 的 IP 地址：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/<span class="token comment"># nslookup time.geekbang.org</span><span class="token punctuation">;</span><span class="token punctuation">;</span> connection timed out<span class="token punctuation">;</span> no servers could be reached<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 你可以发现，这个命令阻塞很久后，还是失败了，报了 connection timed out 和 no servers could be reached 错误。</p><p> 看到这里，估计你的第一反应就是网络不通了，到底是不是这样呢？我们用 ping 工具检查试试。执行下面的命令，就可以测试本地到 114.114.114.114 的连通性：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/<span class="token comment"># ping -c3 114.114.114.114</span>PING <span class="token number">114.114</span>.114.114 <span class="token punctuation">(</span><span class="token number">114.114</span>.114.114<span class="token punctuation">)</span>: <span class="token number">56</span> data bytes<span class="token number">64</span> bytes from <span class="token number">114.114</span>.114.114: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">56</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">31.116</span> ms<span class="token number">64</span> bytes from <span class="token number">114.114</span>.114.114: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">60</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">31.245</span> ms<span class="token number">64</span> bytes from <span class="token number">114.114</span>.114.114: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">2</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">68</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">31.128</span> ms--- <span class="token number">114.114</span>.114.114 <span class="token function">ping</span> statistics ---<span class="token number">3</span> packets transmitted, <span class="token number">3</span> packets received, <span class="token number">0</span>% packet lossround-trip min/avg/max/stddev <span class="token operator">=</span> <span class="token number">31.116</span>/31.163/31.245/0.058 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 那要怎么知道 nslookup 命令失败的原因呢？这里其实有很多方法，最简单的一种，就是开启 nslookup 的调试输出，查看查询过程中的详细步骤，排查其中是否有异常。</p><p> 比如，我们可以继续在容器终端中，执行下面的命令：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/<span class="token comment"># nslookup -debug time.geekbang.org</span><span class="token punctuation">;</span><span class="token punctuation">;</span> Connection to <span class="token number">127.0</span>.0.1<span class="token comment">#53(127.0.0.1) for time.geekbang.org failed: connection refused.</span><span class="token punctuation">;</span><span class="token punctuation">;</span> Connection to ::1<span class="token comment">#53(::1) for time.geekbang.org failed: address not available.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 从这次的输出可以看到，nslookup 连接环回地址（127.0.0.1 和 ::1）的 53 端口失败。这里就有问题了，为什么会去连接环回地址，而不是我们的先前看到的 114.114.114.114 呢？</p><p> 你可能已经想到了症结所在——有可能是因为容器中没有配置 DNS 服务器。那我们就执行下面的命令确认一下：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/<span class="token comment"># cat /etc/resolv.conf</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 果然，这个命令没有任何输出，说明容器里的确没有配置 DNS 服务器。到这一步，很自然的，我们就知道了解决方法。在 /etc/resolv.conf 文件中，配置上 DNS 服务器就可以了。</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/<span class="token comment"># echo "nameserver 114.114.114.114" &gt; /etc/resolv.conf</span>/<span class="token comment"># nslookup time.geekbang.org</span>Server:     <span class="token number">114.114</span>.114.114Address:    <span class="token number">114.114</span>.114.114<span class="token comment">#53</span>Non-authoritative answer:Name:   time.geekbang.orgAddress: <span class="token number">39.106</span>.233.176<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>案例 2：DNS 解析不稳定</p><p> 接下来，我们再来看第二个案例。执行下面的命令，启动一个新的容器，并进入它的终端中：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run -it --rm --cap-add<span class="token operator">=</span>NET_ADMIN --dns <span class="token number">8.8</span>.8.8 feisky/dnsutils <span class="token function">bash</span>root@0cd3ee0c8ecb:/<span class="token comment">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 然后，跟上一个案例一样，还是运行 nslookup 命令，解析 time.geekbang.org 的 IP 地址。不过，这次要加一个 time 命令，输出解析所用时间。如果一切正常，你可能会看到如下输出：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/<span class="token comment"># time nslookup time.geekbang.org</span>Server:     <span class="token number">8.8</span>.8.8Address:    <span class="token number">8.8</span>.8.8<span class="token comment">#53</span>Non-authoritative answer:Name:   time.geekbang.orgAddress: <span class="token number">39.106</span>.233.176real    0m10.349suser    0m0.004ssys     0m0.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 可以看到，这次解析非常慢，居然用了 10 秒。如果你多次运行上面的 nslookup 命令，可能偶尔还会碰到下面这种错误：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/<span class="token comment"># time nslookup time.geekbang.org</span><span class="token punctuation">;</span><span class="token punctuation">;</span> connection timed out<span class="token punctuation">;</span> no servers could be reachedreal    0m15.011suser    0m0.006ssys     0m0.006s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 换句话说，跟上一个案例类似，也会出现解析失败的情况。综合来看，现在 DNS 解析的结果不但比较慢，而且还会发生超时失败的情况。</p><p> 这是为什么呢？碰到这种问题该怎么处理呢？</p><p> 其实，根据前面的讲解，我们知道，DNS 解析，说白了就是客户端与服务器交互的过程，并且这个过程还使用了 UDP 协议。</p><p> 那么，对于整个流程来说，解析结果不稳定，就有很多种可能的情况了。比方说：</p><ul><li>DNS 服务器本身有问题，响应慢并且不稳定；</li><li>或者是，客户端到 DNS 服务器的网络延迟比较大；</li><li><p>再或者，DNS 请求或者响应包，在某些情况下被链路中的网络设备弄丢了。</p><p>根据上面 nslookup 的输出，你可以看到，现在客户端连接的 DNS 是 8.8.8.8，这是 Google 提供的 DNS 服务。对 Google 我们还是比较放心的，DNS 服务器出问题的概率应该比较小。基本排除了 DNS 服务器的问题，那是不是第二种可能，本机到 DNS 服务器的延迟比较大呢？</p><p>前面讲过，ping 可以用来测试服务器的延迟。比如，你可以运行下面的命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/<span class="token comment"># ping -c3 8.8.8.8</span>PING <span class="token number">8.8</span>.8.8 <span class="token punctuation">(</span><span class="token number">8.8</span>.8.8<span class="token punctuation">)</span>: <span class="token number">56</span> data bytes<span class="token number">64</span> bytes from <span class="token number">8.8</span>.8.8: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">31</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">137.637</span> ms<span class="token number">64</span> bytes from <span class="token number">8.8</span>.8.8: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">31</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">144.743</span> ms<span class="token number">64</span> bytes from <span class="token number">8.8</span>.8.8: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">2</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">31</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">138.576</span> ms--- <span class="token number">8.8</span>.8.8 <span class="token function">ping</span> statistics ---<span class="token number">3</span> packets transmitted, <span class="token number">3</span> packets received, <span class="token number">0</span>% packet lossround-trip min/avg/max/stddev <span class="token operator">=</span> <span class="token number">137.637</span>/140.319/144.743/3.152 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从 ping 的输出可以看到，这里的延迟已经达到了 140ms，这也就可以解释，为什么解析这么慢了。实际上，如果你多次运行上面的 ping 测试，还会看到偶尔出现的丢包现象。</p><p>如果更改了 DNS 解析时间还是太长了，该怎么解决这个问题呢？我想你一定已经想到了，那就是使用 DNS 缓存。这样，只有第一次查询时需要去 DNS 服务器请求，以后的查询，只要 DNS 记录不过期，使用缓存中的记录就可以了。</p><p>不过要注意，我们使用的主流 Linux 发行版，除了最新版本的 Ubuntu （如 18.04 或者更新版本）外，其他版本并没有自动配置 DNS 缓存。</p><p>所以，想要为系统开启 DNS 缓存，就需要你做额外的配置。比如，最简单的方法，就是使用 dnsmasq。</p><p>dnsmasq 是最常用的 DNS 缓存服务之一，还经常作为 DHCP 服务来使用。它的安装和配置都比较简单，性能也可以满足绝大多数应用程序对 DNS 缓存的需求。</p><p>我们继续在刚才的容器终端中，执行下面的命令，就可以启动 dnsmasq：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/<span class="token comment"># /etc/init.d/dnsmasq start</span> * Starting DNS forwarder and DHCP server dnsmasq                    <span class="token punctuation">[</span> OK <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后，修改 /etc/resolv.conf，将 DNS 服务器改为 dnsmasq 的监听地址，这儿是 127.0.0.1。接着，重新执行多次 nslookup 命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/<span class="token comment"># echo nameserver 127.0.0.1 &gt; /etc/resolv.conf</span>/<span class="token comment"># time nslookup time.geekbang.org</span>Server:     <span class="token number">127.0</span>.0.1Address:    <span class="token number">127.0</span>.0.1<span class="token comment">#53</span>Non-authoritative answer:Name:   time.geekbang.orgAddress: <span class="token number">39.106</span>.233.176real    0m0.492suser    0m0.007ssys     0m0.006s/<span class="token comment"># time nslookup time.geekbang.org</span>Server:     <span class="token number">127.0</span>.0.1Address:    <span class="token number">127.0</span>.0.1<span class="token comment">#53</span>Non-authoritative answer:Name:   time.geekbang.orgAddress: <span class="token number">39.106</span>.233.176real    0m0.011suser    0m0.008ssys     0m0.003s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在我们可以看到，只有第一次的解析很慢，需要 0.5s，以后的每次解析都很快，只需要 11ms。并且，后面每次 DNS 解析需要的时间也都很稳定。</p></li></ul></li></ol><h4 id="37-3-小结"><a href="#37-3-小结" class="headerlink" title="37.3 小结"></a>37.3 小结</h4><p>在应用程序的开发过程中，我们必须考虑到 DNS 解析可能带来的性能问题，掌握常见的优化方法。这里，我总结了几种常见的 DNS 优化方法。</p><ul><li>对 DNS 解析的结果进行缓存。缓存是最有效的方法，但要注意，一旦缓存过期，还是要去 DNS 服务器重新获取新记录。不过，这对大部分应用程序来说都是可接受的。</li><li>对 DNS 解析的结果进行预取。这是浏览器等 Web 应用中最常用的方法，也就是说，不等用户点击页面上的超链接，浏览器就会在后台自动解析域名，并把结果缓存起来。</li><li>使用 HTTPDNS 取代常规的 DNS 解析。这是很多移动应用会选择的方法，特别是如今域名劫持普遍存在，使用 HTTP 协议绕过链路中的 DNS 服务器，就可以避免域名劫持的问题。</li><li>基于 DNS 的全局负载均衡（GSLB）。这不仅为服务提供了负载均衡和高可用的功能，还可以根据用户的位置，返回距离最近的 IP 地址。</li></ul><h3 id="38-案例篇：怎么使用-tcpdump-和-Wireshark-分析网络流量？"><a href="#38-案例篇：怎么使用-tcpdump-和-Wireshark-分析网络流量？" class="headerlink" title="38 | 案例篇：怎么使用 tcpdump 和 Wireshark 分析网络流量？"></a>38 | 案例篇：怎么使用 tcpdump 和 Wireshark 分析网络流量？</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 禁止接收从 DNS 服务器发送过来并包含 googleusercontent 的包</span>$ iptables -I INPUT -p udp --sport <span class="token number">53</span> -m string --string googleusercontent --algo bm -j DROP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当你发现针对相同的网络服务，使用 IP 地址快而换成域名却慢很多时，就要想到，有可能是 DNS 在捣鬼。DNS 的解析，不仅包括从域名解析出 IP 地址的 A 记录请求，还包括性能工具帮你，“聪明”地从 IP 地址反查域名的 PTR 请求。</p><p>实际上，<strong>根据 IP 地址反查域名、根据端口号反查协议名称，是很多网络工具默认的行为，而这往往会导致性能工具的工作缓慢</strong>。所以，通常，网络性能工具都会提供一个选项（比如 -n 或者 -nn），来禁止名称解析。</p><h3 id="39-案例篇：怎么缓解-DDoS-攻击带来的性能下降问题？"><a href="#39-案例篇：怎么缓解-DDoS-攻击带来的性能下降问题？" class="headerlink" title="39 | 案例篇：怎么缓解 DDoS 攻击带来的性能下降问题？"></a>39 | 案例篇：怎么缓解 DDoS 攻击带来的性能下降问题？</h3><h4 id="39-1-DDoS-简介"><a href="#39-1-DDoS-简介" class="headerlink" title="39.1 DDoS 简介"></a>39.1 DDoS 简介</h4><p>从攻击的原理上来看，DDoS 可以分为下面几种类型。</p><ul><li>第一种，耗尽带宽。无论是服务器还是路由器、交换机等网络设备，带宽都有固定的上限。带宽耗尽后，就会发生网络拥堵，从而无法传输其他正常的网络报文。</li><li>第二种，耗尽操作系统的资源。网络服务的正常运行，都需要一定的系统资源，像是 CPU、内存等物理资源，以及连接表等软件资源。一旦资源耗尽，系统就不能处理其他正常的网络连接。</li><li>第三种，消耗应用程序的运行资源。应用程序的运行，通常还需要跟其他的资源或系统交互。如果应用程序一直忙于处理无效请求，也会导致正常请求的处理变慢，甚至得不到响应。</li></ul><h4 id="39-2-案例"><a href="#39-2-案例" class="headerlink" title="39.2 案例"></a>39.2 案例</h4><blockquote><p>机器配置： 2 CPU, 8 GB 内存。</p><p>安装软件：<code>apt-get install docker.io hping3 tcpdump curl</code>。</p></blockquote><p>一台虚拟机运行 Nginx ，用来模拟待分析的 Web 服务器；而另外两台作为 Web 服务器的客户端，其中一台用作 DoS 攻击，而另一台则是正常的客户端。使用多台虚拟机的目的，自然还是为了相互隔离，避免“交叉感染”。</p><p>打开三个终端，分别 SSH 登录到三台机器上。</p><ol><li><p>在终端一中，执行下面的命令运行案例，也就是启动一个最基本的 Nginx 应用：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 运行 Nginx 服务并对外开放 80 端口</span><span class="token comment"># --network=host 表示使用主机网络（这是为了方便后面排查问题）</span>$ docker run -itd --name<span class="token operator">=</span>nginx --network<span class="token operator">=</span>host nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>在终端二和终端三中，使用 curl 访问 Nginx 监听的端口，确认 Nginx 正常启动。假设 192.168.0.30 是 Nginx 所在虚拟机的 IP 地址，那么运行 curl 命令后，你应该会看到下面这个输出界面：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -w 表示只输出 HTTP 状态码及总时间，-o 表示将响应重定向到 /dev/null</span>$ <span class="token function">curl</span> -s -w <span class="token string">'Http code: %{http_code}<span class="token entity" title="\n">\n</span>Total time:%{time_total}s<span class="token entity" title="\n">\n</span>'</span> -o /dev/null http://192.168.0.30/<span class="token punctuation">..</span>.Http code: <span class="token number">200</span>Total time:0.002s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 从这里可以看到，正常情况下，我们访问 Nginx 只需要 2ms（0.002s）。</p></li><li><p>在终端二中，运行 hping3 命令，来模拟 DoS 攻击：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -S 参数表示设置 TCP 协议的 SYN（同步序列号），-p 表示目的端口为 80</span><span class="token comment"># -i u10 表示每隔 10 微秒发送一个网络帧</span>$ hping3 -S -p <span class="token number">80</span> -i u10 <span class="token number">192.168</span>.0.30<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 再回到终端一，你就会发现，现在不管执行什么命令，都慢了很多。不过，在实践时要注意：</p><ul><li>如果你的现象不那么明显，那么请尝试把参数里面的 u10 调小（比如调成 u1），或者加上–flood 选项；</li><li>如果你的终端一完全没有响应了，那么请适当调大 u10（比如调成 u30），否则后面就不能通过 SSH 操作 VM1。</li></ul></li><li><p>然后，到终端三中，执行下面的命令，模拟正常客户端的连接：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># --connect-timeout 表示连接超时时间</span>$ <span class="token function">curl</span> -w <span class="token string">'Http code: %{http_code}<span class="token entity" title="\n">\n</span>Total time:%{time_total}s<span class="token entity" title="\n">\n</span>'</span> -o /dev/null --connect-timeout <span class="token number">10</span> http://192.168.0.30<span class="token punctuation">..</span>.Http code: 000Total time:10.001scurl: <span class="token punctuation">(</span><span class="token number">28</span><span class="token punctuation">)</span> Connection timed out after <span class="token number">10000</span> milliseconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 你可以发现，在终端三中，正常客户端的连接超时了，并没有收到 Nginx 服务的响应。</p><p> 这是发生了什么问题呢？我们再回到终端一中，检查网络状况。你应该还记得我们多次用过的 sar，它既可以观察 PPS（每秒收发的报文数），还可以观察 BPS（每秒收发的字节数）。</p></li><li><p>我们可以回到终端一中，执行下面的命令：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ sar -n DEV <span class="token number">1</span>08:55:49        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil08:55:50      docker0      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>08:55:50         eth0  <span class="token number">22274.00</span>    <span class="token number">629.00</span>   <span class="token number">1174.64</span>     <span class="token number">37.78</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.02</span>08:55:50           lo      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 从这次 sar 的输出中，你可以看到，网络接收的 PPS 已经达到了 20000 多，但是 BPS 却只有 1174 kB，这样每个包的大小就只有 54B（1174*1024/22274=54）。</p><p> 这明显就是个小包了，不过具体是个什么样的包呢？那我们就用 tcpdump 抓包看看吧。</p></li><li><p>在终端一中，执行下面的 tcpdump 命令：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -i eth0 只抓取 eth0 网卡，-n 不解析协议名和主机名</span><span class="token comment"># tcp port 80 表示只抓取 tcp 协议并且端口号为 80 的网络帧</span>$ tcpdump -i eth0 -n tcp port <span class="token number">80</span>09:15:48.287047 IP <span class="token number">192.168</span>.0.2.27095 <span class="token operator">&gt;</span> <span class="token number">192.168</span>.0.30: Flags <span class="token punctuation">[</span>S<span class="token punctuation">]</span>, <span class="token function">seq</span> <span class="token number">1288268370</span>, win <span class="token number">512</span>, length <span class="token number">0</span>09:15:48.287050 IP <span class="token number">192.168</span>.0.2.27131 <span class="token operator">&gt;</span> <span class="token number">192.168</span>.0.30: Flags <span class="token punctuation">[</span>S<span class="token punctuation">]</span>, <span class="token function">seq</span> <span class="token number">2084255254</span>, win <span class="token number">512</span>, length <span class="token number">0</span>09:15:48.287052 IP <span class="token number">192.168</span>.0.2.27116 <span class="token operator">&gt;</span> <span class="token number">192.168</span>.0.30: Flags <span class="token punctuation">[</span>S<span class="token punctuation">]</span>, <span class="token function">seq</span> <span class="token number">677393791</span>, win <span class="token number">512</span>, length <span class="token number">0</span>09:15:48.287055 IP <span class="token number">192.168</span>.0.2.27141 <span class="token operator">&gt;</span> <span class="token number">192.168</span>.0.30: Flags <span class="token punctuation">[</span>S<span class="token punctuation">]</span>, <span class="token function">seq</span> <span class="token number">1276451587</span>, win <span class="token number">512</span>, length <span class="token number">0</span>09:15:48.287068 IP <span class="token number">192.168</span>.0.2.27154 <span class="token operator">&gt;</span> <span class="token number">192.168</span>.0.30: Flags <span class="token punctuation">[</span>S<span class="token punctuation">]</span>, <span class="token function">seq</span> <span class="token number">1851495339</span>, win <span class="token number">512</span>, length <span class="token number">0</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 这个输出中，Flags [S] 表示这是一个 SYN 包。大量的 SYN 包表明，这是一个 SYN Flood 攻击。实际上，SYN Flood 正是互联网中最经典的 DDoS 攻击方式。</p><p> 它的原理：</p><ul><li>即客户端构造大量的 SYN 包，请求建立 TCP 连接；</li><li><p>而服务器收到包后，会向源 IP 发送 SYN+ACK 报文，并等待三次握手的最后一次 ACK 报文，直到超时。</p><p>这种等待状态的 TCP 连接，通常也称为半开连接。由于连接表的大小有限，大量的半开连接就会导致连接表迅速占满，从而无法建立新的 TCP 连接。</p><p>参考下面这张 TCP 状态图，你能看到，此时，服务器端的 TCP 连接，会处于 SYN_RECEIVED 状态：</p><p><img src="/images/《Linux性能优化实战》学习笔记/TCP状态图.png" alt="TCP状态图"></p><blockquote><p>图片来自 <a href="https://en.wikipedia.org/wiki/File:Tcp_state_diagram.png">Wikipedia</a></p></blockquote><p>这其实提示了我们，查看 TCP 半开连接的方法，关键在于 SYN_RECEIVED 状态的连接。我们可以使用 netstat ，来查看所有连接的状态，不过要注意， SYN_RECEIVED 的状态，通常被缩写为 SYN_RECV。</p></li></ul></li><li><p>我们继续在终端一中，执行下面的 netstat 命令：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -n 表示不解析名字，-p 表示显示连接所属进程</span>$ <span class="token function">netstat</span> -n -p <span class="token operator">|</span> <span class="token function">grep</span> SYN_RECtcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">192.168</span>.0.30:80          <span class="token number">192.168</span>.0.2:12503      SYN_RECV    -tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">192.168</span>.0.30:80          <span class="token number">192.168</span>.0.2:13502      SYN_RECV    -tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">192.168</span>.0.30:80          <span class="token number">192.168</span>.0.2:15256      SYN_RECV    -tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">192.168</span>.0.30:80          <span class="token number">192.168</span>.0.2:18117      SYN_RECV    -<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 从结果中，你可以发现大量 SYN_RECV 状态的连接，并且源 IP 地址为 192.168.0.2。</p></li><li><p>进一步，我们还可以通过 wc 工具，来统计所有 SYN_RECV 状态的连接数：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">netstat</span> -n -p <span class="token operator">|</span> <span class="token function">grep</span> SYN_REC <span class="token operator">|</span> <span class="token function">wc</span> -l<span class="token number">193</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>找出源 IP 后，要解决 SYN 攻击的问题，只要丢掉相关的包就可以。这时，iptables 可以帮你完成这个任务。你可以在终端一中，执行下面的 iptables 命令：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ iptables -I INPUT -s <span class="token number">192.168</span>.0.2 -p tcp -j REJECT<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>然后回到终端三中，再次执行 curl 命令，查看正常用户访问 Nginx 的情况：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">curl</span> -w <span class="token string">'Http code: %{http_code}<span class="token entity" title="\n">\n</span>Total time:%{time_total}s<span class="token entity" title="\n">\n</span>'</span> -o /dev/null --connect-timeout <span class="token number">10</span> http://192.168.0.30Http code: <span class="token number">200</span>Total time:1.572171s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>现在，你可以发现，正常用户也可以访问 Nginx 了，只是响应比较慢，从原来的 2ms 变成了现在的 1.5s。</p><p>不过，一般来说，SYN Flood 攻击中的源 IP 并不是固定的。比如，你可以在 hping3 命令中，加入 —rand-source 选项，来随机化源 IP。不过，这时，刚才的方法就不适用了。</p></li><li><p>幸好，我们还有很多其他方法，实现类似的目标。比如，你可以用以下两种方法，来限制 syn 包的速率：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 限制 syn 并发数为每秒 1 次</span>$ iptables -A INPUT -p tcp --syn -m limit --limit <span class="token number">1</span>/s -j ACCEPT<span class="token comment"># 限制单个 IP 在 60 秒新建立的连接数为 10</span>$ iptables -I INPUT -p tcp --dport <span class="token number">80</span> --syn -m recent --name SYN_FLOOD --update --seconds <span class="token number">60</span> --hitcount <span class="token number">10</span> -j REJECT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到这里，我们已经初步限制了 SYN Flood 攻击。不过这还不够，因为我们的案例还只是单个的攻击源。</p><p>如果是多台机器同时发送 SYN Flood，这种方法可能就直接无效了。因为你很可能无法 SSH 登录（SSH 也是基于 TCP 的）到机器上去，更别提执行上述所有的排查命令。</p><p>所以，这还需要你事先对系统做一些 TCP 优化。</p><p>比如，SYN Flood 会导致 SYN_RECV 状态的连接急剧增大。在上面的 netstat 命令中，你也可以看到 190 多个处于半开状态的连接。</p></li><li><p>不过，半开状态的连接数是有限制的，执行下面的命令，你就可以看到，默认的半连接容量只有 256：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ sysctl net.ipv4.tcp_max_syn_backlognet.ipv4.tcp_max_syn_backlog <span class="token operator">=</span> <span class="token number">256</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>换句话说， SYN 包数再稍微增大一些，就不能 SSH 登录机器了。 所以，你还应该增大半连接的容量，比如，你可以用下面的命令，将其增大为 1024：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ sysctl -w net.ipv4.tcp_max_syn_backlog<span class="token operator">=</span><span class="token number">1024</span>net.ipv4.tcp_max_syn_backlog <span class="token operator">=</span> <span class="token number">1024</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>另外，连接每个 SYN_RECV 时，如果失败的话，内核还会自动重试，并且默认的重试次数是 5 次。你可以执行下面的命令，将其减小为 1 次：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ sysctl -w net.ipv4.tcp_synack_retries<span class="token operator">=</span><span class="token number">1</span>net.ipv4.tcp_synack_retries <span class="token operator">=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>除此之外，TCP SYN Cookies 也是一种专门防御 SYN Flood 攻击的方法。SYN Cookies 基于连接信息（包括源地址、源端口、目的地址、目的端口等）以及一个加密种子（如系统启动时间），计算出一个哈希值（SHA1），这个哈希值称为 cookie。</p><p>然后，这个 cookie 就被用作序列号，来应答 SYN+ACK 包，并释放连接状态。当客户端发送完三次握手的最后一次 ACK 后，服务器就会再次计算这个哈希值，确认是上次返回的 SYN+ACK 的返回包，才会进入 TCP 的连接状态。</p><p>因而，开启 SYN Cookies 后，就不需要维护半开连接状态了，进而也就没有了半连接数的限制。</p><blockquote><p>注意，开启 TCP syncookies 后，内核选项 net.ipv4.tcp_max_syn_backlog 也就无效了。</p></blockquote></li><li><p>可以通过下面的命令，开启 TCP SYN Cookies：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ sysctl -w net.ipv4.tcp_syncookies<span class="token operator">=</span><span class="token number">1</span>net.ipv4.tcp_syncookies <span class="token operator">=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="29-3-DDoS-到底该怎么防御"><a href="#29-3-DDoS-到底该怎么防御" class="headerlink" title="29.3 DDoS 到底该怎么防御"></a>29.3 DDoS 到底该怎么防御</h4></li></ol><p>当 DDoS 报文到达服务器后，Linux 提供的机制只能缓解，而无法彻底解决。即使像是 SYN Flood 这样的小包攻击，其巨大的 PPS ，也会导致 Linux 内核消耗大量资源，进而导致其他网络报文的处理缓慢。</p><p>所以，当时提到的 C10M 的方法，用到这里同样适合。比如，你可以基于 XDP 或者 DPDK，构建 DDoS 方案，在内核网络协议栈前，或者跳过内核协议栈，来识别并丢弃 DDoS 报文，避免 DDoS 对系统其他资源的消耗。</p><p>不过，对于流量型的 DDoS 来说，当服务器的带宽被耗尽后，在服务器内部处理就无能为力了。这时，只能在服务器外部的网络设备中，设法识别并阻断流量（当然前提是网络设备要能扛住流量攻击）。比如，购置专业的入侵检测和防御设备，配置流量清洗设备阻断恶意流量等。</p><p>既然 DDoS 这么难防御，这是不是说明， Linux 服务器内部压根儿就不关注这一点，而是全部交给专业的网络设备来处理呢？</p><p>当然不是，因为 DDoS 并不一定是因为大流量或者大 PPS，有时候，慢速的请求也会带来巨大的性能下降（这种情况称为慢速 DDoS）。</p><p>比如，很多针对应用程序的攻击，都会伪装成正常用户来请求资源。这种情况下，请求流量可能本身并不大，但响应流量却可能很大，并且应用程序内部也很可能要耗费大量资源处理。</p><p>这时，就需要应用程序考虑识别，并尽早拒绝掉这些恶意流量，比如合理利用缓存、增加 WAF（Web Application Firewall）、使用 CDN 等等。</p><h3 id="40-案例篇：网络请求延迟变大了，我该怎么办？"><a href="#40-案例篇：网络请求延迟变大了，我该怎么办？" class="headerlink" title="40 | 案例篇：网络请求延迟变大了，我该怎么办？"></a>40 | 案例篇：网络请求延迟变大了，我该怎么办？</h3><h4 id="40-1-网络延迟"><a href="#40-1-网络延迟" class="headerlink" title="40.1 网络延迟"></a>40.1 网络延迟</h4><p>很多网络服务会把 ICMP 禁止掉，这也就导致我们无法用 ping ，来测试网络服务的可用性和往返延时。这时，你可以用 traceroute 或 hping3 的 TCP 和 UDP 模式，来获取网络延迟。</p><p>比如，以 baidu.com 为例，你可以执行下面的 hping3 命令，测试你的机器到百度搜索服务器的网络延迟：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -c 表示发送 3 次请求，-S 表示设置 TCP SYN，-p 表示端口号为 80</span>$ hping3 -c <span class="token number">3</span> -S -p <span class="token number">80</span> baidu.comHPING baidu.com <span class="token punctuation">(</span>eth0 <span class="token number">123.125</span>.115.110<span class="token punctuation">)</span>: S set, <span class="token number">40</span> headers + <span class="token number">0</span> data bytes<span class="token assign-left variable">len</span><span class="token operator">=</span><span class="token number">46</span> <span class="token assign-left variable">ip</span><span class="token operator">=</span><span class="token number">123.125</span>.115.110 <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">51</span> <span class="token assign-left variable">id</span><span class="token operator">=</span><span class="token number">47908</span> <span class="token assign-left variable">sport</span><span class="token operator">=</span><span class="token number">80</span> <span class="token assign-left variable">flags</span><span class="token operator">=</span>SA <span class="token assign-left variable">seq</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">win</span><span class="token operator">=</span><span class="token number">8192</span> <span class="token assign-left variable">rtt</span><span class="token operator">=</span><span class="token number">20.9</span> ms<span class="token assign-left variable">len</span><span class="token operator">=</span><span class="token number">46</span> <span class="token assign-left variable">ip</span><span class="token operator">=</span><span class="token number">123.125</span>.115.110 <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">51</span> <span class="token assign-left variable">id</span><span class="token operator">=</span><span class="token number">6788</span>  <span class="token assign-left variable">sport</span><span class="token operator">=</span><span class="token number">80</span> <span class="token assign-left variable">flags</span><span class="token operator">=</span>SA <span class="token assign-left variable">seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">win</span><span class="token operator">=</span><span class="token number">8192</span> <span class="token assign-left variable">rtt</span><span class="token operator">=</span><span class="token number">20.9</span> ms<span class="token assign-left variable">len</span><span class="token operator">=</span><span class="token number">46</span> <span class="token assign-left variable">ip</span><span class="token operator">=</span><span class="token number">123.125</span>.115.110 <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">51</span> <span class="token assign-left variable">id</span><span class="token operator">=</span><span class="token number">37699</span> <span class="token assign-left variable">sport</span><span class="token operator">=</span><span class="token number">80</span> <span class="token assign-left variable">flags</span><span class="token operator">=</span>SA <span class="token assign-left variable">seq</span><span class="token operator">=</span><span class="token number">2</span> <span class="token assign-left variable">win</span><span class="token operator">=</span><span class="token number">8192</span> <span class="token assign-left variable">rtt</span><span class="token operator">=</span><span class="token number">20.9</span> ms--- baidu.com hping statistic ---<span class="token number">3</span> packets transmitted, <span class="token number">3</span> packets received, <span class="token number">0</span>% packet lossround-trip min/avg/max <span class="token operator">=</span> <span class="token number">20.9</span>/20.9/20.9 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，我们用 traceroute ，也可以得到类似结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># --tcp 表示使用 TCP 协议，-p 表示端口号，-n 表示不对结果中的 IP 地址执行反向域名解析</span>$ <span class="token function">traceroute</span> --tcp -p <span class="token number">80</span> -n baidu.com<span class="token function">traceroute</span> to baidu.com <span class="token punctuation">(</span><span class="token number">123.125</span>.115.110<span class="token punctuation">)</span>, <span class="token number">30</span> hops max, <span class="token number">60</span> byte packets <span class="token number">1</span>  * * * <span class="token number">2</span>  * * * <span class="token number">3</span>  * * * <span class="token number">4</span>  * * * <span class="token number">5</span>  * * * <span class="token number">6</span>  * * * <span class="token number">7</span>  * * * <span class="token number">8</span>  * * * <span class="token number">9</span>  * * *<span class="token number">10</span>  * * *<span class="token number">11</span>  * * *<span class="token number">12</span>  * * *<span class="token number">13</span>  * * *<span class="token number">14</span>  <span class="token number">123.125</span>.115.110  <span class="token number">20.684</span> ms *  <span class="token number">20.798</span> ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>traceroute 会在路由的每一跳发送三个包，并在收到响应后，输出往返延时。如果无响应或者响应超时（默认 5s），就会输出一个星号。</p><h4 id="40-2-案例"><a href="#40-2-案例" class="headerlink" title="40.2 案例"></a>40.2 案例</h4><blockquote><p>机器配置： 2 CPU, 8 GB 内存。</p><p>安装软件：<code>apt-get install docker.io hping3 tcpdump curl</code>。</p></blockquote><p>打开两个终端，分别 SSH 登录到两台机器上。</p><ol><li><p>为了对比得出延迟增大的影响，首先，我们来运行一个最简单的 Nginx，也就是用官方的 Nginx 镜像启动一个容器。在终端一中，执行下面的命令，运行官方 Nginx，它会在 80 端口监听：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run --network<span class="token operator">=</span>host --name<span class="token operator">=</span>good -itd nginxfb4ed7cb9177d10e270f8320a7fb64717eac3451114c9fab3c50e02be2e88ba2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>继续在终端一中，执行下面的命令，运行案例应用，它会监听 8080 端口：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run --name nginx --network<span class="token operator">=</span>host -itd feisky/nginx:latencyb99bd136dcfd907747d9c803fdc0255e578bad6d66f4e9c32b826d75b6812724<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>然后，在终端二中执行 curl 命令，验证两个容器已经正常启动。如果一切正常，你将看到如下的输出：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 80 端口正常</span>$ <span class="token function">curl</span> http://192.168.0.30<span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">&gt;</span><span class="token operator">&lt;</span>html<span class="token operator">&gt;</span><span class="token punctuation">..</span>.<span class="token operator">&lt;</span>p<span class="token operator">&gt;</span><span class="token operator">&lt;</span>em<span class="token operator">&gt;</span>Thank you <span class="token keyword">for</span> using nginx.<span class="token operator">&lt;</span>/em<span class="token operator">&gt;</span><span class="token operator">&lt;</span>/p<span class="token operator">&gt;</span><span class="token operator">&lt;</span>/body<span class="token operator">&gt;</span><span class="token operator">&lt;</span>/html<span class="token operator">&gt;</span><span class="token comment"># 8080 端口正常</span>$ <span class="token function">curl</span> http://192.168.0.30:8080<span class="token punctuation">..</span>.<span class="token operator">&lt;</span>p<span class="token operator">&gt;</span><span class="token operator">&lt;</span>em<span class="token operator">&gt;</span>Thank you <span class="token keyword">for</span> using nginx.<span class="token operator">&lt;</span>/em<span class="token operator">&gt;</span><span class="token operator">&lt;</span>/p<span class="token operator">&gt;</span><span class="token operator">&lt;</span>/body<span class="token operator">&gt;</span><span class="token operator">&lt;</span>/html<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>接着，我们再用上面提到的 hping3 ，来测试它们的延迟，看看有什么区别。还是在终端二，执行下面的命令，分别测试案例机器 80 端口和 8080 端口的延迟：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 测试 80 端口延迟</span>$ hping3 -c <span class="token number">3</span> -S -p <span class="token number">80</span> <span class="token number">192.168</span>.0.30HPING <span class="token number">192.168</span>.0.30 <span class="token punctuation">(</span>eth0 <span class="token number">192.168</span>.0.30<span class="token punctuation">)</span>: S set, <span class="token number">40</span> headers + <span class="token number">0</span> data bytes<span class="token assign-left variable">len</span><span class="token operator">=</span><span class="token number">44</span> <span class="token assign-left variable">ip</span><span class="token operator">=</span><span class="token number">192.168</span>.0.30 <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> DF <span class="token assign-left variable">id</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">sport</span><span class="token operator">=</span><span class="token number">80</span> <span class="token assign-left variable">flags</span><span class="token operator">=</span>SA <span class="token assign-left variable">seq</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">win</span><span class="token operator">=</span><span class="token number">29200</span> <span class="token assign-left variable">rtt</span><span class="token operator">=</span><span class="token number">7.8</span> ms<span class="token assign-left variable">len</span><span class="token operator">=</span><span class="token number">44</span> <span class="token assign-left variable">ip</span><span class="token operator">=</span><span class="token number">192.168</span>.0.30 <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> DF <span class="token assign-left variable">id</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">sport</span><span class="token operator">=</span><span class="token number">80</span> <span class="token assign-left variable">flags</span><span class="token operator">=</span>SA <span class="token assign-left variable">seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">win</span><span class="token operator">=</span><span class="token number">29200</span> <span class="token assign-left variable">rtt</span><span class="token operator">=</span><span class="token number">7.7</span> ms<span class="token assign-left variable">len</span><span class="token operator">=</span><span class="token number">44</span> <span class="token assign-left variable">ip</span><span class="token operator">=</span><span class="token number">192.168</span>.0.30 <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> DF <span class="token assign-left variable">id</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">sport</span><span class="token operator">=</span><span class="token number">80</span> <span class="token assign-left variable">flags</span><span class="token operator">=</span>SA <span class="token assign-left variable">seq</span><span class="token operator">=</span><span class="token number">2</span> <span class="token assign-left variable">win</span><span class="token operator">=</span><span class="token number">29200</span> <span class="token assign-left variable">rtt</span><span class="token operator">=</span><span class="token number">7.6</span> ms--- <span class="token number">192.168</span>.0.30 hping statistic ---<span class="token number">3</span> packets transmitted, <span class="token number">3</span> packets received, <span class="token number">0</span>% packet lossround-trip min/avg/max <span class="token operator">=</span> <span class="token number">7.6</span>/7.7/7.8 ms<span class="token comment"># 测试 8080 端口延迟</span>$ hping3 -c <span class="token number">3</span> -S -p <span class="token number">8080</span> <span class="token number">192.168</span>.0.30HPING <span class="token number">192.168</span>.0.30 <span class="token punctuation">(</span>eth0 <span class="token number">192.168</span>.0.30<span class="token punctuation">)</span>: S set, <span class="token number">40</span> headers + <span class="token number">0</span> data bytes<span class="token assign-left variable">len</span><span class="token operator">=</span><span class="token number">44</span> <span class="token assign-left variable">ip</span><span class="token operator">=</span><span class="token number">192.168</span>.0.30 <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> DF <span class="token assign-left variable">id</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">sport</span><span class="token operator">=</span><span class="token number">8080</span> <span class="token assign-left variable">flags</span><span class="token operator">=</span>SA <span class="token assign-left variable">seq</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">win</span><span class="token operator">=</span><span class="token number">29200</span> <span class="token assign-left variable">rtt</span><span class="token operator">=</span><span class="token number">7.7</span> ms<span class="token assign-left variable">len</span><span class="token operator">=</span><span class="token number">44</span> <span class="token assign-left variable">ip</span><span class="token operator">=</span><span class="token number">192.168</span>.0.30 <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> DF <span class="token assign-left variable">id</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">sport</span><span class="token operator">=</span><span class="token number">8080</span> <span class="token assign-left variable">flags</span><span class="token operator">=</span>SA <span class="token assign-left variable">seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">win</span><span class="token operator">=</span><span class="token number">29200</span> <span class="token assign-left variable">rtt</span><span class="token operator">=</span><span class="token number">7.6</span> ms<span class="token assign-left variable">len</span><span class="token operator">=</span><span class="token number">44</span> <span class="token assign-left variable">ip</span><span class="token operator">=</span><span class="token number">192.168</span>.0.30 <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> DF <span class="token assign-left variable">id</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">sport</span><span class="token operator">=</span><span class="token number">8080</span> <span class="token assign-left variable">flags</span><span class="token operator">=</span>SA <span class="token assign-left variable">seq</span><span class="token operator">=</span><span class="token number">2</span> <span class="token assign-left variable">win</span><span class="token operator">=</span><span class="token number">29200</span> <span class="token assign-left variable">rtt</span><span class="token operator">=</span><span class="token number">7.3</span> ms--- <span class="token number">192.168</span>.0.30 hping statistic ---<span class="token number">3</span> packets transmitted, <span class="token number">3</span> packets received, <span class="token number">0</span>% packet lossround-trip min/avg/max <span class="token operator">=</span> <span class="token number">7.3</span>/7.6/7.7 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 从这个输出你可以看到，两个端口的延迟差不多，都是 7ms。不过，这只是单个请求的情况。换成并发请求的话，又会怎么样呢？接下来，我们就用 wrk 试试。</p></li><li><p>这次在终端二中，执行下面的新命令，分别测试案例机器并发 100 时， 80 端口和 8080 端口的性能：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 测试 80 端口性能</span>$ <span class="token comment"># wrk --latency -c 100 -t 2 --timeout 2 http://192.168.0.30/</span>Running 10s <span class="token builtin class-name">test</span> @ http://192.168.0.30/<span class="token number">2</span> threads and <span class="token number">100</span> connectionsThread Stats   Avg      Stdev     Max   +/- Stdev    Latency     <span class="token number">9</span>.19ms   <span class="token number">12</span>.32ms <span class="token number">319</span>.61ms   <span class="token number">97.80</span>%    Req/Sec     <span class="token number">6</span>.20k   <span class="token number">426.80</span>     <span class="token number">8</span>.25k    <span class="token number">85.50</span>%Latency Distribution    <span class="token number">50</span>%    <span class="token number">7</span>.78ms    <span class="token number">75</span>%    <span class="token number">8</span>.22ms    <span class="token number">90</span>%    <span class="token number">9</span>.14ms    <span class="token number">99</span>%   <span class="token number">50</span>.53ms<span class="token number">123558</span> requests <span class="token keyword">in</span> <span class="token number">10</span>.01s, <span class="token number">100</span>.15MB <span class="token builtin class-name">read</span>Requests/sec:  <span class="token number">12340.91</span>Transfer/sec:     <span class="token number">10</span>.00MB<span class="token comment"># 测试 8080 端口性能</span>$ wrk --latency -c <span class="token number">100</span> -t <span class="token number">2</span> --timeout <span class="token number">2</span> http://192.168.0.30:8080/Running 10s <span class="token builtin class-name">test</span> @ http://192.168.0.30:8080/<span class="token number">2</span> threads and <span class="token number">100</span> connectionsThread Stats   Avg      Stdev     Max   +/- Stdev    Latency    <span class="token number">43</span>.60ms    <span class="token number">6</span>.41ms  <span class="token number">56</span>.58ms   <span class="token number">97.06</span>%    Req/Sec     <span class="token number">1</span>.15k   <span class="token number">120.29</span>     <span class="token number">1</span>.92k    <span class="token number">88.50</span>%Latency Distribution    <span class="token number">50</span>%   <span class="token number">44</span>.02ms    <span class="token number">75</span>%   <span class="token number">44</span>.33ms    <span class="token number">90</span>%   <span class="token number">47</span>.62ms    <span class="token number">99</span>%   <span class="token number">48</span>.88ms<span class="token number">22853</span> requests <span class="token keyword">in</span> <span class="token number">10</span>.01s, <span class="token number">18</span>.55MB <span class="token builtin class-name">read</span>Requests/sec:   <span class="token number">2283.31</span>Transfer/sec:      <span class="token number">1</span>.85MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 从上面两个输出可以看到，官方 Nginx（监听在 80 端口）的平均延迟是 9.19ms，而案例 Nginx 的平均延迟（监听在 8080 端口）则是 43.6ms。从延迟的分布上来看，官方 Nginx 90% 的请求，都可以在 9ms 以内完成；而案例 Nginx 50% 的请求，就已经达到了 44 ms。</p></li><li><p>在终端一中，执行下面的 tcpdump 命令，抓取 8080 端口上收发的网络包，并保存到 nginx.pcap 文件：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ tcpdump -nn tcp port <span class="token number">8080</span> -w nginx.pcap<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>然后切换到终端二中，重新执行 wrk 命令：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 测试 8080 端口性能</span>$ wrk --latency -c <span class="token number">100</span> -t <span class="token number">2</span> --timeout <span class="token number">2</span> http://192.168.0.30:8080/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 当 wrk 命令结束后，再次切换回终端一，并按下 Ctrl+C 结束 tcpdump 命令。然后，再把抓取到的 nginx.pcap ，复制到装有 Wireshark 的机器中（如果 VM1 已经带有图形界面，那么可以跳过复制步骤），并用 Wireshark 打开它。</p><p> 由于网络包的数量比较多，我们可以先过滤一下。比如，在选择一个包后，你可以单击右键并选择 “Follow” -&gt; “TCP Stream”，如下图所示：</p><p> <img src="/images/《Linux性能优化实战》学习笔记/打开Wireshark中TCPStream的Follow.png" alt="打开Wireshark中TCPStream的Follow"></p><p> 然后，关闭弹出来的对话框，回到 Wireshark 主窗口。这时候，你会发现 Wireshark 已经自动帮你设置了一个过滤表达式 tcp.stream eq 24。如下图所示（图中省去了源和目的 IP 地址）：</p><p> <img src="/images/《Linux性能优化实战》学习笔记/Wireshark过滤表达式tcp.stream-eq-24.png" alt="Wireshark过滤表达式tcp.stream-eq-24"></p><p> 从这里，你可以看到这个 TCP 连接从三次握手开始的每个请求和响应情况。当然，这可能还不够直观，你可以继续点击菜单栏里的 Statics -&gt; Flow Graph，选中 “Limit to display filter” 并设置 Flow type 为 “TCP Flows”：</p><p> <img src="/images/《Linux性能优化实战》学习笔记/网络请求延迟变大案例Wireshark截图.png" alt="网络请求延迟变大案例Wireshark截图"></p><p> 注意，这个图的左边是客户端，而右边是 Nginx 服务器。通过这个图就可以看出，前面三次握手，以及第一次 HTTP 请求和响应还是挺快的，但第二次 HTTP 请求就比较慢了，特别是客户端在收到服务器第一个分组后，40ms 后才发出了 ACK 响应（图中蓝色行）。</p><p> 看到 40ms 这个值，你有没有想起什么东西呢？实际上，这是 TCP 延迟确认（Delayed ACK）的最小超时时间。</p><p> 这里我解释一下延迟确认。这是针对 TCP ACK 的一种优化机制，也就是说，不用每次请求都发送一个 ACK，而是先等一会儿（比如 40ms），看看有没有“顺风车”。如果这段时间内，正好有其他包需要发送，那就捎带着 ACK 一起发送过去。当然，如果一直等不到其他包，那就超时后单独发送 ACK。</p><p> 因为案例中 40ms 发生在客户端上，我们有理由怀疑，是客户端开启了延迟确认机制。而这儿的客户端，实际上就是前面运行的 wrk。</p><p> 查询 TCP 文档（执行 man tcp），你就会发现，只有 TCP 套接字专门设置了 TCP_QUICKACK ，才会开启快速确认模式；否则，默认情况下，采用的就是延迟确认机制：</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">TCP_QUICKACK (since Linux 2.4.4)    Enable  quickack mode if set or disable quickack mode if cleared.  In quickack mode, acks are sent imme‐    diately, rather than delayed if needed in accordance to normal TCP operation.  This flag is  not  perma‐    nent,  it only enables a switch to or from quickack mode.  Subsequent operation of the TCP protocol will    once again enter/leave quickack mode depending on internal  protocol  processing  and  factors  such  as    delayed ack timeouts occurring and data transfer.  This option should not be used in code intended to be    portable.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 为了验证我们的猜想，确认 wrk 的行为，我们可以用 strace ，来观察 wrk 为套接字设置了哪些 TCP 选项。</p><p> 比如，你可以切换到终端二中，执行下面的命令：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">strace</span> -f wrk --latency -c <span class="token number">100</span> -t <span class="token number">2</span> --timeout <span class="token number">2</span> http://192.168.0.30:8080/<span class="token punctuation">..</span>.setsockopt<span class="token punctuation">(</span><span class="token number">52</span>, SOL_TCP, TCP_NODELAY, <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>, <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 这样，你可以看到，wrk 只设置了 TCP_NODELAY 选项，而没有设置 TCP_QUICKACK。这说明 wrk 采用的正是延迟确认，也就解释了上面这个 40ms 的问题。</p><p> 不过，别忘了，这只是客户端的行为，按理来说，Nginx 服务器不应该受到这个行为的影响。那是不是我们分析网络包时，漏掉了什么线索呢？让我们回到 Wireshark 重新观察一下。</p><p> <img src="/images/《Linux性能优化实战》学习笔记/网络请求延迟变大案例Wireshark截图二.png" alt="网络请求延迟变大案例Wireshark截图二"></p><p> 仔细观察 Wireshark 的界面，其中， 1173 号包，就是刚才说到的延迟 ACK 包；下一行的 1175 ，则是 Nginx 发送的第二个分组包，它跟 697 号包组合起来，构成一个完整的 HTTP 响应（ACK 号都是 85）。</p><p> 第二个分组没跟前一个分组（697 号）一起发送，而是等到客户端对第一个分组的 ACK 后（1173 号）才发送，这看起来跟延迟确认有点像，只不过，这儿不再是 ACK，而是发送数据。</p><p> 看到这里，我估计你想起了一个东西—— Nagle 算法（纳格算法）。进一步分析案例前，我先简单介绍一下这个算法。</p><p> Nagle 算法，是 TCP 协议中用于减少小包发送数量的一种优化算法，目的是为了提高实际带宽的利用率。</p><p> 举个例子，当有效负载只有 1 字节时，再加上 TCP 头部和 IP 头部分别占用的 20 字节，整个网络包就是 41 字节，这样实际带宽的利用率只有 2.4%（1/41）。往大了说，如果整个网络带宽都被这种小包占满，那整个网络的有效利用率就太低了。</p><p> Nagle 算法正是为了解决这个问题。它通过合并 TCP 小包，提高网络带宽的利用率。Nagle 算法规定，一个 TCP 连接上，最多只能有一个未被确认的未完成分组；在收到这个分组的 ACK 前，不发送其他分组。这些小分组会被组合起来，并在收到 ACK 后，用同一个分组发送出去。</p><p> 显然，Nagle 算法本身的想法还是挺好的，但是知道 Linux 默认的延迟确认机制后，你应该就不这么想了。因为它们一起使用时，网络延迟会明显。如下图所示：</p><p> <img src="/images/《Linux性能优化实战》学习笔记/DelayedACK和Nagle算法一起使用.png" alt="DelayedACK和Nagle算法一起使用"></p><ul><li>当 Sever 发送了第一个分组后，由于 Client 开启了延迟确认，就需要等待 40ms 后才会回复 ACK。</li><li>同时，由于 Server 端开启了 Nagle，而这时还没收到第一个分组的 ACK，Server 也会在这里一直等着。</li><li><p>直到 40ms 超时后，Client 才会回复 ACK，然后，Server 才会继续发送第二个分组。</p><p>既然可能是 Nagle 的问题，那该怎么知道，案例 Nginx 有没有开启 Nagle 呢？</p><p>查询 tcp 的文档，你就会知道，只有设置了 TCP_NODELAY 后，Nagle 算法才会禁用。所以，我们只需要查看 Nginx 的 tcp_nodelay 选项就可以了。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">TCP_NODELAY    If set, disable the Nagle algorithm.  This means that segments are always sent as soon as possible, even    if there is only a small amount of data.  When not set, data is buffered until  there  is  a  sufficient    amount  to  send out, thereby avoiding the frequent sending of small packets, which results in poor uti‐    lization of the network.  This option is overridden by TCP_CORK; however, setting this option forces  an    explicit flush of pending output, even if TCP_CORK is currently set.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>我们回到终端一中，执行下面的命令，查看案例 Nginx 的配置:</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker <span class="token builtin class-name">exec</span> nginx <span class="token function">cat</span> /etc/nginx/nginx.conf <span class="token operator">|</span> <span class="token function">grep</span> tcp_nodelay    tcp_nodelay    off<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 果然，你可以看到，案例 Nginx 的 tcp_nodelay 是关闭的，将其设置为 on ，应该就可以解决了。</p></li><li><p>改完后，问题是否就解决了呢？自然需要验证我们一下。修改后的应用，我已经打包到了 Docker 镜像中，在终端一中执行下面的命令，你就可以启动它：</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 删除案例应用</span>$ docker <span class="token function">rm</span> -f nginx<span class="token comment"># 启动优化后的应用</span>$ docker run --name nginx --network<span class="token operator">=</span>host -itd feisky/nginx:nodelay<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>接着，切换到终端二，重新执行 wrk 测试延迟：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ wrk --latency -c <span class="token number">100</span> -t <span class="token number">2</span> --timeout <span class="token number">2</span> http://192.168.0.30:8080/Running 10s <span class="token builtin class-name">test</span> @ http://192.168.0.30:8080/  <span class="token number">2</span> threads and <span class="token number">100</span> connections  Thread Stats   Avg      Stdev     Max   +/- Stdev    Latency     <span class="token number">9</span>.58ms   <span class="token number">14</span>.98ms <span class="token number">350</span>.08ms   <span class="token number">97.91</span>%    Req/Sec     <span class="token number">6</span>.22k   <span class="token number">282.13</span>     <span class="token number">6</span>.93k    <span class="token number">68.50</span>%  Latency Distribution     <span class="token number">50</span>%    <span class="token number">7</span>.78ms     <span class="token number">75</span>%    <span class="token number">8</span>.20ms     <span class="token number">90</span>%    <span class="token number">9</span>.02ms     <span class="token number">99</span>%   <span class="token number">73</span>.14ms  <span class="token number">123990</span> requests <span class="token keyword">in</span> <span class="token number">10</span>.01s, <span class="token number">100</span>.50MB <span class="token builtin class-name">read</span>Requests/sec:  <span class="token number">12384.04</span>Transfer/sec:     <span class="token number">10</span>.04MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>果然，现在延迟已经缩短成了 9ms，跟我们测试的官方 Nginx 镜像是一样的（Nginx 默认就是开启 tcp_nodelay 的） 。</p><p>作为对比，我们用 tcpdump ，抓取优化后的网络包（这儿实际上抓取的是官方 Nginx 监听的 80 端口）。你可以得到下面的结果：</p><p><img src="/images/《Linux性能优化实战》学习笔记/开启tcp_nodelay后wireshark的截图.png" alt="开启tcp_nodelay后wireshark的截图"></p><p>从图中你可以发现，由于 Nginx 不用再等 ACK，536 和 540 两个分组是连续发送的；而客户端呢，虽然仍开启了延迟确认，但这时收到了两个需要回复 ACK 的包，所以也不用等 40ms，可以直接合并回复 ACK。</p></li></ol><h4 id="40-3-小结"><a href="#40-3-小结" class="headerlink" title="40.3 小结"></a>40.3 小结</h4><p>在发现网络延迟增大后，你可以用 traceroute、hping3、tcpdump、Wireshark、strace 等多种工具，来定位网络中的潜在问题。比如，</p><ul><li>使用 hping3 以及 wrk 等工具，确认单次请求和并发请求情况的网络延迟是否正常。</li><li>使用 traceroute，确认路由是否正确，并查看路由中每一跳网关的延迟。</li><li>使用 tcpdump 和 Wireshark，确认网络包的收发是否正常。</li><li>使用 strace 等，观察应用程序对网络套接字的调用情况是否正常。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能分析 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux性能分析</title>
      <link href="linux-xing-neng-fen-xi/"/>
      <url>linux-xing-neng-fen-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="1-cpupower"><a href="#1-cpupower" class="headerlink" title="1. cpupower"></a>1. cpupower</h2><p>可以设置 CPU 为 performance 模式来提高性能。</p><ol><li><p>查看 CPU 支持的模式。</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>设置为 performance 模式。</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cpupower frequency-set -g performance<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://wsgzao.github.io/post/cpupower/">CPU 优化建议使用 cpupower 设置 CPU Performance 模式</a></p></li></ol><h2 id="2-top"><a href="#2-top" class="headerlink" title="2. top"></a>2. top</h2><pre class="line-numbers language-text" data-language="text"><code class="language-text">top - 12:20:32 up 18:33,  0 users,  load average: 0.00, 0.00, 0.00Tasks:   9 total,   1 running,   8 sleeping,   0 stopped,   0 zombie%Cpu(s):  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 stKiB Mem : 16345516 total, 15938648 free,   273724 used,   133144 buff/cacheKiB Swap:  4194304 total,  4194304 free,        0 used. 15840516 avail Mem  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND    1 root      20   0    1744   1088   1016 S   0.0  0.0   0:00.00 init    7 root      20   0    1764     76      0 S   0.0  0.0   0:00.00 init    8 root      20   0    1764     92      0 S   0.0  0.0   0:00.05 init    9 k         20   0   75332  11712   4500 S   0.0  0.1   0:02.33 zsh   13 k         20   0   58876   5144   2092 S   0.0  0.0   0:00.00 zsh   53 k         20   0   75612   6764   1332 S   0.0  0.0   0:00.00 zsh   54 k         20   0   75596   5424      0 S   0.0  0.0   0:00.30 zsh   56 k         20   0    4536   1000    884 S   0.0  0.0   0:00.94 gitstatusd-linu   94 k         20   0   45728   3712   3228 R   0.0  0.0   0:00.00 top<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>执行命令 <code>uptime</code> 也能得到与命令 <code>top</code> 结果第一行一样的结果。命令 <code>w</code> 和命令 <code>cat /proc/loadavg</code> 也能得到类似的结果。</p></blockquote><h3 id="2-1-指标说明"><a href="#2-1-指标说明" class="headerlink" title="2.1 指标说明"></a>2.1 指标说明</h3><p><a href="https://www.booleanworld.com/guide-linux-top-command/">A Guide to the Linux “Top” Command</a></p><h4 id="2-1-1-系统时间、正常运行时间和用户会话"><a href="#2-1-1-系统时间、正常运行时间和用户会话" class="headerlink" title="2.1.1 系统时间、正常运行时间和用户会话"></a>2.1.1 系统时间、正常运行时间和用户会话</h4><p><code>12:20:32 up 18:33,  0 users</code>表示系统时间、正常运行时间和用户会话。</p><blockquote><p>可以使用 <code>who</code> 命令来查看当前那些用户在线。</p></blockquote><h4 id="2-1-2-内存使用情况"><a href="#2-1-2-内存使用情况" class="headerlink" title="2.1.2 内存使用情况"></a>2.1.2 内存使用情况</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">KiB Mem : 16345516 total, 15938648 free,   273724 used,   133144 buff/cacheKiB Swap:  4194304 total,  4194304 free,        0 used. 15840516 avail Mem<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>KiB Mem</code> 和 <code>KiB Swap</code> 后的 <code>total</code> 、 <code>free</code> 以及 <code>used</code> 分别表示系统内存和交换区总大小、可用大小、已使用的大小。</p><p><code>avail Mem</code> 表示不使用交换分区的情况下，可以分配给进程使用的大小。</p><p><code>buff/cache</code> 系统使用的缓冲区和缓存的总和。</p><blockquote><p><code>buff</code> 表示内核缓冲区使用的内存，<code>cache</code> 表示页缓存和 slab 使用的内存。</p><p>可以通过 <code>man free</code> 命令来获取详细的说明。</p></blockquote><p><a href="https://unix.stackexchange.com/questions/390518/what-do-the-buff-cache-and-avail-mem-fields-in-top-mean">What do the “buff/cache” and “avail mem” fields in top mean?</a></p><h4 id="2-1-3-任务"><a href="#2-1-3-任务" class="headerlink" title="2.1.3 任务"></a>2.1.3 任务</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">Tasks:   9 total,   1 running,   8 sleeping,   0 stopped,   0 zombie<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/Linux性能分析/linux-process-states.jpg" alt="linux-process-states"></p><blockquote><p>图片来源：<a href="https://www.tutorialworks.com/linux-top-command-explained/">How to Make Sense of Linux System Stats in Top</a></p></blockquote><p>在 Linux 中，进程可能处于以下状态：</p><ol><li>可运行 (R,Runnable)：处于这种状态的进程要么在 CPU 上执行，要么出现在运行队列中，准备执行。</li><li>可中断睡眠 (S, Interruptible sleep)：处于此状态的进程正在等待事件完成。</li><li>不间断睡眠 (D, Uninterruptible sleep)：在这种情况下，进程正在等待 I/O 操作完成。</li><li>已停止 (T, Stopped)：这些进程已被<a href="https://www.gnu.org/software/libc/manual/html_node/Job-Control-Signals.html">作业控制信号</a>（例如按 Ctrl+Z）停止或因为它们正在被跟踪。</li><li>僵尸（Z, Zombie）：内核在内存中维护各种数据结构以跟踪进程。一个进程可能会创建多个子进程，并且它们可能会在父进程还在时退出。但是，必须保留这些数据结构，直到父进程获得子进程的状态。这种数据结构仍然存在的终止进程称为僵尸进程。</li></ol><p>D 和 S 状态的进程显示为 sleeping ，T状态的进程显示为 stopped 。僵尸的数量显示为  zombie 值。</p><blockquote><p><code>top</code> 命令默认显示的是进程相关的信息，可以按 <code>SHIFT + H</code> 键切换到显示线程相关的信息。</p></blockquote><h4 id="2-1-4-CPU-使用率"><a href="#2-1-4-CPU-使用率" class="headerlink" title="2.1.4 CPU 使用率"></a>2.1.4 CPU 使用率</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">%Cpu(s):  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://www.man7.org/linux/man-pages/man1/top.1.html">top(1) — Linux manual page</a></p><p>CPU 使用率部分显示了用于各种任务的 CPU 时间百分比：</p><ol><li><code>us, user</code> 是 CPU 在用户空间中执行进程所花费的时间(time running un-niced user processes)。</li><li><code>sy, system</code> 是运行内核空间进程所花费的时间。</li><li><code>ni, nice</code> 是使用手动设置的 nice 执行进程所花费的时间(time running niced user processes)。<blockquote><p>Linux 使用 nice 值来确定进程的优先级。具有高 nice 值的进程对其他进程更好，并获得低优先级。同样，具有较低 nice 的进程获得更高的优先级。可以手动更改默认的 nice 值。</p></blockquote></li><li><code>id, idle</code> 是 CPU 保持空闲的时间。</li><li><code>wa, IO-wait</code> 是 CPU 等待 I/O 完成所花费的时间。</li><li><code>hi, hardware interrupts</code> 是处理硬件所花费的时间。</li><li><code>si, software interrupts</code> 是处理软件所花费的时间。</li><li><code>st, stolen, time</code> hypervisor 从这个 vm 窃取的时间 (time stolen from this vm by the hypervisor)。<blockquote><p>在虚拟化环境中，一部分 CPU 资源分配给每个虚拟机 (VM)。操作系统检测到它何时有工作要做，但它无法执行它们，因为 CPU 在某个其他 VM 上很忙。以这种方式损失的时间量是被窃取时间。</p></blockquote></li></ol><h4 id="2-1-5-平均负载"><a href="#2-1-5-平均负载" class="headerlink" title="2.1.5 平均负载"></a>2.1.5 平均负载</h4><p><code>load average: 0.00, 0.00, 0.00</code> 表示一分钟、五分钟和十五分钟内的系统的平均负载。</p><p>在 Linux 上，负载是在任何给定时刻处于 R 和 D 状态的进程数。平均负载值提供了一个相对衡量 CPU 必须等待事情完成的时间。</p><blockquote><p>平均负载的解释也可以通过命令 <code>man uptime</code> 获得：</p><p>System load averages is the average number of processes that are either in a runnable or uninterruptable state.  A process in a runnable state  is  either  using the  CPU  or  waiting  to  use the CPU.  A process in uninterruptable state is waiting for some I/O access, eg waiting for disk.  The averages are taken over the three time intervals.  Load averages are not normalized for the number of CPUs in a system, so a load average of 1 means a single CPU system is  loaded  all  the time while on a 4 CPU system it means it was idle 75% of the time.</p></blockquote><p>另外，平均负载是一个<a href="https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average">指数移动平均</a>，意味着之前的负载平均值的一小部分被计入当前值。更多的细节：<a href="https://www.linuxjournal.com/article/9001">Examining Load Average</a>。</p><p>如何<a href="http://www.ruanyifeng.com/blog/2011/07/linux_load_average_explained.html">理解 Linux 系统负荷</a>呢？</p><p>为便于理解，把 CPU 想象成一个大桥，桥上只有一根车道（相当于 CPU 只有一个核），所有的车辆都要从这根到通过。</p><ol><li>系统负载为 0，表示车道上一个车都没有。</li><li>系统负载为 0.5， 表示车道上一半的路段有车。</li><li>系统负载为 1，表示车道上全是车，但是所有车都能正常顺利的通行。</li><li>系统负载为 1.7，大桥已经被占满了（100%），后面等着上桥的车辆为桥面车辆的70%。</li></ol><blockquote><p>在多核系统上，需要将负载平均值除以 CPU 内核数以获得类似的度量。</p></blockquote><p>区分 CPU 使用率和平均负载</p><p><a href="https://serverfault.com/questions/667078/high-cpu-utilization-but-low-load-average">High CPU utilization but low load average</a></p><ul><li>平均负载是衡量一段时间内在内核运行队列中等待的任务数量。</li><li>CPU 利用率是衡量当前 CPU 繁忙程度的指标。</li></ul><p>单个 CPU 线程在 1 分钟内保持 100% 的 CPU 使用率可以让 <code>1分钟平均负载</code> 加 1。具有超线程（8 个虚拟内核）的 4 核 CPU 保持 100% 的 CPU 使用率 1 分钟可以让 <code>1分钟平均负载</code> 加 8。</p><h4 id="2-1-6-任务区"><a href="#2-1-6-任务区" class="headerlink" title="2.1.6 任务区"></a>2.1.6 任务区</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND  1 root      20   0    1744   1088   1016 S   0.0  0.0   0:00.00 init  7 root      20   0    1764     76      0 S   0.0  0.0   0:00.00 init  8 root      20   0    1764     92      0 S   0.0  0.0   0:00.05 init  9 k         20   0   75332  11712   4500 S   0.0  0.1   0:02.33 zsh 13 k         20   0   58876   5144   2092 S   0.0  0.0   0:00.00 zsh 53 k         20   0   75612   6764   1332 S   0.0  0.0   0:00.00 zsh 54 k         20   0   75596   5424      0 S   0.0  0.0   0:00.30 zsh 56 k         20   0    4536   1000    884 S   0.0  0.0   0:00.94 gitstatusd-linu 94 k         20   0   45728   3712   3228 R   0.0  0.0   0:00.00 top<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>PID</p><p> 进程 ID，一个唯一的正整数，用于标识进程。</p></li><li><p>USER</p><p> 启动进程的用户的 <code>有效(effective)</code> 用户名（映射到用户 ID）。Linux为进程分配一个 <code>真实用户ID(real user ID)</code> 和一个 <code>有效用户ID(effective user ID)</code>；后者允许进程代表另一个用户进行操作。（例如，非 root 用户可以提升为 root 以安装软​​件包。）</p></li><li><p>PR 和 NI</p><p> NI 字段显示进程的 nice 值。PR 字段从内核的角度显示了进程的调度优先级。nice 值影响进程的优先级。</p></li><li><p>VIRT、RES、SHR 和 %MEM</p><p> 这三个字段与进程的内存消耗有关。</p><ul><li>VIRT 是进程消耗的内存总量。这包括程序代码、进程存储在内存中的数据以及已交换到磁盘的任何内存区域。</li><li>RES 是进程在 RAM 中消耗的内存，%MEM 表示该值占可用 RAM 总量的百分比。</li><li>SHR 是与其他进程共享的内存量。</li></ul></li><li><p>S</p><p> 一个进程可能处于不同的状态。此字段以单字母形式显示进程状态。</p><blockquote><p>D – 不间断睡眠，I – 空闲，R – 运行，S – 睡眠，T – 被作业控制信号停止，t – 在跟踪期间被调试器停止, Z – 僵尸。</p></blockquote></li><li><p>TIME+</p><p> 进程自启动以来使用的总 CPU 时间，精确到百分之一秒。</p></li><li><p>COMMAND</p><p> 进程的名称。</p></li></ol><h4 id="2-1-7-Linux-内存类型"><a href="#2-1-7-Linux-内存类型" class="headerlink" title="2.1.7 Linux 内存类型"></a>2.1.7 Linux 内存类型</h4><p>下面的内容意译自 <a href="https://www.man7.org/linux/man-pages/man1/top.1.html">top(1) — Linux manual page</a> 中 Linux Memory Types 部分。</p><p>Linux 中有三种类型的内存，其中一种是可选的。</p><ol><li>物理内存：一种有限的资源，代码和数据在执行或引用时必须驻留在其中。</li><li>交换文件（可选的）：当物理内存不足时，可以存放修改后的（脏）内存并在以后检索的地方。</li><li>虚拟内存：一种几乎无限的资源，用于以下目标。<ol><li>抽象，不受物理内存地址/限制。</li><li>隔离，每个进程在一个单独的地址空间。</li><li>共享，单个映射可以满足多个需求。</li><li>灵活性，为文件分配一个虚拟地址。</li></ol></li></ol><p>无论内存采用哪种形式，都作为内存页(page)管理（通常 4096 字节）。</p><p>每个内存页都被限制为下表中的一个象限中。物理内存和虚拟内存都可以包含这四个中的任何一个，而交换文件只能包含象限 1 和象限 3。象限 4 中的内存在修改后会作为进程自己的专用交换文件。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">                           Private | Shared                       1           |          2  Anonymous  . stack               |             . malloc()            |             . brk()/sbrk()        | . POSIX shm*             . mmap(PRIVATE, ANON) | . mmap(SHARED, ANON)            -----------------------+----------------------             . mmap(PRIVATE, fd)   | . mmap(SHARED, fd)File-backed  . pgms/shared libs    |                       3           |          4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是对 <code>top</code> 命令中一些字段的解释：</p><ol><li><code>%MEM</code>：<code>RES</code> 的值除以总物理内存。</li><li><code>CODE</code>：象限 3 中 <code>pgms</code> 的大小。</li><li><code>DATA</code>：整个象限 1 中的值加上象限 3 中显示 <code>mmap</code> 文件支持(File-backed)的内存页大小的和。</li><li><code>RES</code>：任何占用物理内存的东西。从 Linux-4.5 开始，是以下三个字段的总和：<ol><li><code>RSan</code>：象限 1 中内存页的大小，包括象限 3 中之前修改过的内存页的大小。</li><li><code>RSfd</code>：象限 3 加上象限 4。</li><li><code>RSsh</code>：象限 2。</li></ol></li><li><code>RSlk</code>：<code>RES</code> 中不能被换出内存的部分（所有象限）。</li><li><code>SHR</code>：<code>RES</code> 中排除象限 1 ，但包括象限 2 和象限 4 以及部分象限 3。</li><li><code>SWAP</code>：可能是除象限 4 外的其他象限中的任何内容。</li><li><code>USED</code>：<code>RES</code> 和 <code>SWAP</code> 的和。</li><li><code>VIRT</code>：正在使用和/或保留的所有内容（所有象限）。</li></ol><blockquote><p>注意：虽然程序映像和共享库被认为是进程私有的，但在内核中被当做共享的(shared, SHR)。</p></blockquote><h3 id="2-2-关注指标"><a href="#2-2-关注指标" class="headerlink" title="2.2 关注指标"></a>2.2 关注指标</h3><h4 id="2-2-1-us-和-sy"><a href="#2-2-1-us-和-sy" class="headerlink" title="2.2.1 us 和 sy"></a>2.2.1 <code>us</code> 和 <code>sy</code></h4><p><code>us</code> 低 和 <code>sy</code> 高的情况一般有两种：</p><ol><li>用户态的代码写的很好，都压缩成了系统调用。</li><li>用户态的代码写的很差，导致全是小的系统调佣。</li></ol><h4 id="2-2-2-wa"><a href="#2-2-2-wa" class="headerlink" title="2.2.2 wa"></a>2.2.2 <code>wa</code></h4><p><code>wa</code> 高表示硬盘或者网络 I/O wait 高。</p><h4 id="2-2-3-si"><a href="#2-2-3-si" class="headerlink" title="2.2.3 si"></a>2.2.3 <code>si</code></h4><p>网络压测时，很有可能会出现单个 CPU 的 <code>si</code> 很高的情况。优化思路就是让 <code>si</code> 均衡到多个 CPU 上，方式有：</p><blockquote><p>完整资料：<a href="https://www.kernel.org/doc/Documentation/networking/scaling.txt">Scaling in the Linux Networking Stack</a></p></blockquote><ol><li><p>RSS(Receive Side Scaling)</p><p> 就是俗称的网卡多队列。需要网卡硬件支持。</p><p> 把不同的流分散的不同的网卡多列中，至于网卡队列由哪个cpu处理还需要绑定网卡队列中断与 CPU。</p><blockquote><p>队列应不超过机器上 CPU 物理核的数量。</p></blockquote><p> <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/performance_tuning_guide/network-rss">RECEIVE-SIDE SCALING (RSS)</a></p><p> 还有一种叫XPS(Transmit Packet Steering)的技术：根据当前处理软中断的cpu选择网卡发包队列，适合于多队列网卡。主要是为了避免 CPU 由 RX 队列的中断进入到 TX 队列的中断时发生切换，导致 CPU cache 失效损失性能。</p></li><li><p>RPS(Receive Packet Steering)</p><p> 网卡多队列的软件实现。</p><p> 单队列网卡或者虚拟网卡，把该网卡上的数据流让多个 CPU 处理。</p><p> <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/performance_tuning_guide/network-rps">RECEIVE PACKET STEERING (RPS)</a></p><p> 开启脚本：<a href="https://gist.github.com/wsgzao/18828f69147635f3e38a14690a633daf">rps.sh</a></p><p> 在 RPS 之上优化的版本叫 RFS(Receive Flow Steering)。</p><p> 当流量需要传输到用户态处理时，用处理软中断的 CPU 去处理用户态的逻辑。主要是为了避免 CPU 由内核态进入到用户态的时候发生切换，导致 CPU cache 失效损失性能。</p><p> <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/performance_tuning_guide/network-rfs">RECEIVE FLOW STEERING (RFS)</a></p><p> 使用硬件加速版本的 RFS 叫 Accelerated RFS(Receive Flow Steering)。</p><p> <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/performance_tuning_guide/network-acc-rfs">ACCELERATED RFS</a></p></li><li><p>Kernel Bypass</p><p> Kernel Bypass（内核旁路）是绕过Linux内核（TCPIP协议栈）的技术，不使用Linux内核子系统的功能，采用自己实现的相同功能的代码来处理，从用户空间直接访问和控制设备内存，避免数据从设备拷贝到内核，再从内核拷贝到用户空间。</p><p> Kernel Bypass目前主流实现方案有：DPDK、SolarFlare。</p></li></ol><blockquote><p>其他资料：</p><ol><li><a href="https://blog.yufeng.info/archives/2037">MYSQL数据库网卡软中断不平衡问题及解决方案</a></li><li><a href="https://wsgzao.github.io/post/rps/">RPS 和 RFS 网卡多队列性能调优实践</a></li><li><a href="https://tech.meituan.com/2018/03/16/redis-high-concurrency-optimization.html">Redis 高负载下的中断优化</a></li><li><a href="https://www.cnblogs.com/scottieyuyang/p/5665731.html">Linux RSS/RPS/RFS/XPS对比</a></li></ol></blockquote><h2 id="3-nmon"><a href="#3-nmon" class="headerlink" title="3. nmon"></a>3. nmon</h2><h3 id="3-1-关注指标"><a href="#3-1-关注指标" class="headerlink" title="3.1 关注指标"></a>3.1 关注指标</h3><h4 id="3-1-1-内核指标-k"><a href="#3-1-1-内核指标-k" class="headerlink" title="3.1.1 内核指标(k)"></a>3.1.1 内核指标(<code>k</code>)</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">Kernel and Load Average ---------------------------------------------------------||Global-CPU-Stats----&gt;     0.5% user      Load Average  CPU use since boottime   || /proc/stat line 1        0.0% user_nice  1 mins  0.00 Uptime Days Hours Mins   ||100 ticks per second      0.5% system     5 mins  0.00 Uptime    0    17   15   ||100%=1 CPUcoreThread   1195.6% idle      15 mins  0.00 Idle      0    17  939   ||       1   RunQueue       0.0% iowait                  Uptime has overflowed    ||       0   Blocked        0.0% irq                                              ||    1731.3 Context        0.0% softirq                 12 CPU core threads      ||           Switch         0.0% steal                                            ||       0.5 Forks          0.0% guest                   Boot time 1635930655     ||    1743.8 Interrupts     0.0% guest_nice              05:10 PM 03-Nov-2021     |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果 <code>Context Switch</code> 比较高，可能代码中的 <code>syscall</code> 非常多，或者程序中线程非常多。</p><p><code>Interrupts</code> 指标反应了中断的密集情况。</p><ol><li>如果网络程序压测试，<code>Context Switch</code> 和 <code>Interrupts</code> 都非常高，说明网络发送的都是小包，没有批量发送(<code>writev</code>)。</li></ol><h2 id="4-nload"><a href="#4-nload" class="headerlink" title="4. nload"></a>4. nload</h2><p><code>nload -u H</code> 用于看网卡实时网速。</p><blockquote><p><code>PageUp</code> 和 <code>PageDown</code> 切换网卡。</p></blockquote><h2 id="5-tcpflow"><a href="#5-tcpflow" class="headerlink" title="5. tcpflow"></a>5. tcpflow</h2><p>更方便的实时解析网络数据包。比如解析 HTTP 协议：<code>sudo tcpflow -c -e http</code> 。</p><h2 id="6-ifconfig"><a href="#6-ifconfig" class="headerlink" title="6. ifconfig"></a>6. ifconfig</h2><h3 id="6-1-关注指标"><a href="#6-1-关注指标" class="headerlink" title="6.1 关注指标"></a>6.1 关注指标</h3><p>主要关注每个网络下的 <code>RX errors 0  dropped 0  overruns 0  frame 0</code> 和 <code>TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code> 这几个指标，判断网络是否出现丢包错误之类的。</p><h2 id="7-netstat"><a href="#7-netstat" class="headerlink" title="7. netstat"></a>7. netstat</h2><h3 id="7-1-关注指标"><a href="#7-1-关注指标" class="headerlink" title="7.1 关注指标"></a>7.1 关注指标</h3><h3 id="7-1-1-网络栈统计信息"><a href="#7-1-1-网络栈统计信息" class="headerlink" title="7.1.1 网络栈统计信息"></a>7.1.1 网络栈统计信息</h3><p>想看内核网络栈的统计信息应用命令 <code>netstat -s</code> ，其他的方式会有比较大的负担。</p><p>统计信息中主要关注的有统计数据中关于重传的数据：<code>netstat -s | grep -i retran</code></p><pre class="line-numbers language-text" data-language="text"><code class="language-text">23919133 segments retransmittedTCPLostRetransmit: 616895912901177 fast retransmits4674395 retransmits in slow startTCPSynRetrans: 3104<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-1-2-网卡-MTU-和统计信息"><a href="#7-1-2-网卡-MTU-和统计信息" class="headerlink" title="7.1.2 网卡 MTU 和统计信息"></a>7.1.2 网卡 MTU 和统计信息</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">netstat</span> -i<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">Kernel Interface tableIface      MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flgdocker0   1500        0      0      0 0             0      0      0      0 BMUenp4s0    1500 117099502      0  45104 0      109843615      0      0      0 BMRUlo       65536   323529      0      0 0        323529      0      0      0 LRU<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-ss"><a href="#8-ss" class="headerlink" title="8. ss"></a>8. ss</h2><h3 id="8-1-关注指标"><a href="#8-1-关注指标" class="headerlink" title="8.1 关注指标"></a>8.1 关注指标</h3><h4 id="8-1-1-连接的统计信息"><a href="#8-1-1-连接的统计信息" class="headerlink" title="8.1.1 连接的统计信息"></a>8.1.1 连接的统计信息</h4><p>想看 TCP 各个状态的连接数量：<code>ss -s</code> 。</p><h4 id="8-1-2-TCP-连接的-timer-信息"><a href="#8-1-2-TCP-连接的-timer-信息" class="headerlink" title="8.1.2 TCP 连接的 timer 信息"></a>8.1.2 TCP 连接的 timer 信息</h4><p>命令 <code>ss -et</code> 可以看 TCP 上 keepalive 相关的信息。</p><h4 id="8-1-3-TCP-连接上流量控制和拥塞控制的信息"><a href="#8-1-3-TCP-连接上流量控制和拥塞控制的信息" class="headerlink" title="8.1.3 TCP 连接上流量控制和拥塞控制的信息"></a>8.1.3 TCP 连接上流量控制和拥塞控制的信息</h4><p>命令 <code>ss -it</code> 可以看 TCP 连接上流量控制和拥塞控制的信息。</p><h2 id="9-strace"><a href="#9-strace" class="headerlink" title="9. strace"></a>9. strace</h2><p><code>sudo strace -p $pid</code> 查看某个进程的系统调用。</p><h2 id="10-perf"><a href="#10-perf" class="headerlink" title="10. perf"></a>10. perf</h2><p><code>sudo perf top</code> 是 on-cpu 系统分析工具。</p><blockquote><p>on-cpu 时间即进程获得 CPU 使用权的时间，同理 off-cpu 即进程失去cpu使用权时度过的时间。</p></blockquote><p>更多资料：</p><ol><li><a href="https://www.brendangregg.com/perf.html">perf Examples</a>。</li><li><a href="https://www.brendangregg.com/offcpuanalysis.html">Off-CPU Analysis</a></li></ol><h2 id="11-其他工具"><a href="#11-其他工具" class="headerlink" title="11. 其他工具"></a>11. 其他工具</h2><p><img src="/images/Linux性能分析/linux_observability_tools.png" alt="linux_observability_tools.png"></p><p><img src="/images/Linux性能分析/linux_static_tools.png" alt="linux_static_tools.png"></p><p><img src="/images/Linux性能分析/linux_benchmarking_tools.png" alt="linux_benchmarking_tools.png"></p><p><img src="/images/Linux性能分析/linux_tuning_tools.png" alt="linux_tuning_tools.png"></p><p><img src="/images/Linux性能分析/linux_observability_sar.png" alt="linux_observability_sar.png"></p><p><img src="/images/Linux性能分析/perf-tools_2016.png" alt="perf-tools_2016.png"></p><p><img src="/images/Linux性能分析/bcc_tracing_tools.png" alt="bcc_tracing_tools.png"></p><blockquote><p>图片来源 <a href="https://www.brendangregg.com/linuxperf.html">Linux Performance</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Go进阶训练营》学习笔记</title>
      <link href="go-jin-jie-xun-lian-ying-xue-xi-bi-ji/"/>
      <url>go-jin-jie-xun-lian-ying-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>重点资料：</p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html">Practical Go: Real world advice for writing maintainable Go programs</a></p><p><a href="https://research.swtch.com/mm">Memory Models</a></p><h2 id="第1课-微服务-微服务概览与治理"><a href="#第1课-微服务-微服务概览与治理" class="headerlink" title="第1课 微服务(微服务概览与治理)"></a>第1课 微服务(微服务概览与治理)</h2><h3 id="1-1-微服务概览"><a href="#1-1-微服务概览" class="headerlink" title="1.1 微服务概览"></a>1.1 微服务概览</h3><h4 id="1-1-1-单体架构"><a href="#1-1-1-单体架构" class="headerlink" title="1.1.1 单体架构"></a>1.1.1 单体架构</h4><p>缺点：无法扩展，可靠性低。无法敏捷性开发和部署。</p><p>应对：化繁为简，分而治之。</p><h4 id="1-1-2-微服务起源"><a href="#1-1-2-微服务起源" class="headerlink" title="1.1.2 微服务起源"></a>1.1.2 微服务起源</h4><p>SOA（Service-Oriented Architecture，面向服务的架构）和微服务的关系：微服务是 SOA 的一种实践。</p><blockquote><p>You should instead think of Microservices as a specific approach for SOA in the same way that XP or Scrum are specific approaches for Agile software development.</p></blockquote><p>微服务更细致的定义：</p><ul><li>小即是美：小的服务代码少，bug 也少，易测试，易维护，也更容易不断迭代完善的精致进而美妙。</li><li>单一职责：一个服务也只需要做好一件事，专注才能做好。</li><li>尽可能早地创建原型：尽可能早的提供服务API，建立服务契约，达成服务间沟通的一致性约定，至于实现和完善可以慢慢再做。</li><li>可移植性比效率更重要：服务间的轻量级交互协议在效率和可移植性二者间，首要依然考虑兼容性和移植性。</li></ul><h4 id="1-1-3-微服务的定义"><a href="#1-1-3-微服务的定义" class="headerlink" title="1.1.3 微服务的定义"></a>1.1.3 微服务的定义</h4><p>围绕业务功能构建的，服务关注单一业务，服务间采用轻量级的通信机制，可以全自动独立部署，可以使用不同的编程语言和数据存储技术。微服务架构通过业务拆分实现服务组件化，通过组件组合快速开发系统，业务单一的服务组件又可以独立部署<br>使得整个系统变得清晰灵活：</p><ul><li>原子服务</li><li>独立进程</li><li>隔离部署</li><li>去中心化服务治理</li></ul><p>缺点：</p><ul><li>基础设施的建设、复杂度高</li></ul><h4 id="1-1-4-微服务的不足"><a href="#1-1-4-微服务的不足" class="headerlink" title="1.1.4 微服务的不足"></a>1.1.4 微服务的不足</h4><ul><li>微服务应用是分布式系统，由此会带来固有的复杂性。开发者不得不使用 RPC 或者消息传递，来实现进程间通信；此外，必须要写代码来处理消息传递中速度过慢或者服务不可用等局部失效问题。</li><li>分区的数据库架构，同时更新多个业务主体的事务很普遍。这种事务对于单体式应用来说很容易，因为只有一个数据库。在微服务架构应用中，需要更新不同服务所使用的不同的数据库，从而对开发者提出了更高的要求和挑战。</li><li>测试一个基于微服务架构的应用也是很复杂的任务。</li><li>服务模块间的依赖，应用的升级有可能会波及多个服务模块的修改。</li><li>对运维基础设施的挑战比较大。</li></ul><h4 id="1-1-5-组件服务化"><a href="#1-1-5-组件服务化" class="headerlink" title="1.1.5 组件服务化"></a>1.1.5 组件服务化</h4><p>传统实现组件的方式是通过库(library)，库是和应用一起运行在进程中，库的局部变化意味着整个应用的重新部署。通过服务来实现组件，意味着将应用拆散为一系列的服务运行在不同的进程中，那么单一服务的局部变化只需重新部署对应的服务进程。我们用 Go 实施一个微服务：</p><ul><li>kit：一个微服务的基础库(框架)</li><li>service：业务代码 + kit 依赖 + 第三方依赖组成的业务微服务</li><li>rpc + message queue：轻量级通讯</li></ul><p>本质上等同于，多个微服务组合(compose)完成了一个完整的用户场景(usecase)。</p><h4 id="1-1-6-按业务组织服务"><a href="#1-1-6-按业务组织服务" class="headerlink" title="1.1.6 按业务组织服务"></a>1.1.6 按业务组织服务</h4><p>按业务能力组织服务的意思是服务提供的能力和业务功能对应，比如：订单服务和数据访问服务，前者反应了真实的订单相关业务，后者是一种技术抽象服务不反应真实的业务。所以按微服务架构理念来划分服务时，是不应该存在数据访问服务这样一个服务的。</p><p>事实上传统应用设计架构的分层结构正反映了不同角色的沟通结构。所以若要按微服务的方式来构建应用，也需要对应调整团队的组织架构。每个服务背后的小团队的组织是跨功能的，包含实现业务所需的全面的技能。</p><p>我们的模式：大前端(移动/Web) =》网关接入=》业务服务=》平台服务=》基础设施(PaaS/Saas)</p><p>开发团队对软件在生产环境的运行负全部责任！</p><blockquote><p>You built it, you fix it.</p></blockquote><h4 id="1-1-7-去中心化"><a href="#1-1-7-去中心化" class="headerlink" title="1.1.7 去中心化"></a>1.1.7 去中心化</h4><p>每个服务面临的业务场景不同，可以针对性的选择合适的技术解决方案。但也需要避免过度多样化，结合团队实际情况来选择取舍，要是每个服务都用不同的语言的技术栈来实现，想想维护成本真够高的。</p><ul><li>数据去中心化</li><li>治理去中心化</li><li>技术去中心化</li></ul><p>每个服务独享自身的数据存储设施(缓存，数据库等)，不像传统应用共享一个缓存和数据库，这样有利于服务的独立性，隔离相关干扰。</p><h4 id="1-1-8-基础设施自动化"><a href="#1-1-8-基础设施自动化" class="headerlink" title="1.1.8 基础设施自动化"></a>1.1.8 基础设施自动化</h4><p>无自动化不微服务，自动化包括测试和部署。单一进程的传统应用被拆分为一系列的多进程服务后，意味着开发、调试、测试、监控和部署的复杂度都会相应增大，必须要有合适的自动化基础设施来支持微服务架构模式，否则开发、运维成本将大大增加。</p><ul><li>CICD：Gitlab + Gitlab Hooks + k8s</li><li>Testing：测试环境、单元测试、API自动化测试</li><li>在线运行时：k8s，以及一系列Prometheus、ELK、Control Panel</li></ul><h4 id="1-1-9-可用性-amp-兼容性设计"><a href="#1-1-9-可用性-amp-兼容性设计" class="headerlink" title="1.1.9 可用性 &amp; 兼容性设计"></a>1.1.9 可用性 &amp; 兼容性设计</h4><p>著名的 Design For Failure 思想，微服务架构采用粗粒度的进程间通信，引入了额外的复杂性和需要处理的新问题，如网络延迟、消息格式、负载均衡和容错，忽略其中任何一点都属于对“分布式计算的误解”。</p><ul><li>隔离</li><li>超时控制</li><li>负载保护</li><li>限流</li><li>降级</li><li>重试</li><li>负载均衡</li></ul><p>一旦采用了微服务架构模式，那么在服务需要变更时我们要特别小心，服务提供者的变更可能引发服务消费者的兼容性破坏，时刻谨记保持服务契约(接口)的兼容性。</p><p>Be conservative in what you send, be liberal in what you accept.</p><p>发送时要保守，接收时要开放。按照伯斯塔尔法则的思想来设计和实现服务时，发送的数据要更保守，意味着最小化的传送必要的信息，接收时更开放意味着要最大限度的容忍冗余数据，保证兼容性。</p><h3 id="1-2-微服务设计"><a href="#1-2-微服务设计" class="headerlink" title="1.2 微服务设计"></a>1.2 微服务设计</h3><h4 id="1-2-1-API-Gateway"><a href="#1-2-1-API-Gateway" class="headerlink" title="1.2.1 API Gateway"></a>1.2.1 API Gateway</h4><ol><li><p>第一版的设计</p><p> <img src="/images/《Go进阶训练营》学习笔记/APIGateway第一版.png" alt="APIGateway第一版"></p><p> 我们进行了 SOA 服务化的架构演进，按照垂直功能进行了拆分，对外暴露了一批微服务，但是因为缺乏统一的出口面临了不少困难：</p><ul><li>客户端到微服务直接通信，强耦合（很老的客户端的可能一直存在）。</li><li>需要多次请求，客户端聚合数据，工作量巨大，延迟高（客户端工作量巨大）。</li><li>协议不利于统一，各个部门间有差异，需要端来兼容（各个部门的接口不统一）。</li><li>面向“端”的 API 适配，耦合到了内部服务（各个终端的适配代码复杂并耦合到服务内部）。</li><li>多终端兼容逻辑复杂，每个服务都需要处理。</li><li><p>统一逻辑无法收敛，比如安全认证、限流（每个服务都要做验证）。</p><p>我们之前提到了我们工作模型，要内聚模式配合。</p></li></ul></li><li><p>第二版的设计</p><p> <img src="/images/《Go进阶训练营》学习笔记/APIGateway第二版.png" alt="APIGateway第二版"></p><p> 我们新增了一个 app-interface 用于统一的协议出口，在服务内进行大量的 dataset join，按照业务场景来设计粗粒度的 API，给后续服务的演进带来的很多优势：</p><ul><li>轻量交互：协议精简、聚合。</li><li>差异服务：数据裁剪以及聚合、针对终端定制化 API。</li><li>动态升级：原有系统兼容升级，更新服务而非协议。</li><li><p>沟通效率提升，协作模式演进为移动业务+网关小组。</p><p>BFF 可以认为是一种适配服务，将后端的微服务进行适配(主要包括聚合裁剪和格式适配等逻辑)，向无线端设备暴露友好和统一的API，方便无线设备接入访问后端服务。</p></li></ul></li><li><p>第三版的设计</p><p> <img src="/images/《Go进阶训练营》学习笔记/APIGateway第三版.png" alt="APIGateway第三版"></p><p> 最致命的一个问题是整个 app-interface 属于 single point of failure，严重代码缺陷或者流量洪峰可能引发集群宕机。</p><ul><li><p>单个模块也会导致后续业务集成复杂度高，根据康威法则，单块的无线BFF和多团队之间就出现不匹配问题，团队之间沟通协调成本高，交付效率低下。</p><p>解决方法是按照业务域和重要性拆分出了一些大的网关。这种模式在微服务设计模式中叫做 <a href="https://microservices.io/patterns/data/api-composition.html">API Composition</a>。</p></li></ul></li><li><p>第四版的设计</p><p> <img src="/images/《Go进阶训练营》学习笔记/APIGateway第四版.png" alt="APIGateway第四版"></p><p> 很多跨横切面逻辑，比如安全认证，日志监控，限流熔断等。随着时间的推移，代码变得越来越复杂，技术债越堆越多。</p><p> 跨横切面(Cross-Cutting Concerns)的功能，需要协调更新框架升级发版(路由、认证、限流、安全)，因此全部上沉，引入了API Gateway，把业务集成度高的BFF 层和通用功能服务层APIGateway 进行了分层处理。</p><p> 在新的架构中，网关承担了重要的角色，它是解耦拆分和后续升级迁移的利器。在网关的配合下，单块BFF实现了解耦拆分，各业务线团队可以独立开发和交付各自的微服务，研发效率大大提升。另外，把跨横切面逻辑从BFF 剥离到网关上去以后，BFF 的开发人员可以更加专注业务逻辑交付，实现了架构上的关注分离(Separation of Concerns)。</p><p> 我们业务流量实际为：</p><p> 移动端-&gt; API Gateway -&gt; BFF -&gt; Microservice，在Front-end Web业务中，BFF 可以是nodejs 来做服务端渲染(SSR，Server-Side Rendering)，注意这里忽略了上游的CDN、4/7层负载均衡(ELB)。</p></li></ol><h4 id="1-2-2-Microservice-划分"><a href="#1-2-2-Microservice-划分" class="headerlink" title="1.2.2 Microservice 划分"></a>1.2.2 Microservice 划分</h4><p>微服务架构时遇到的第一个问题就是如何划分服务的边界。在实际项目中通常会采用两种不同的方式划分服务边界，即通过业务职能(BusinessCapability)或是DDD 的限界上下文(BoundedContext)。</p><p>在不熟悉业务领域时，可以用两种方式划分：</p><ul><li>Business Capability<br>  按部门划分，由公司内部不同部门提供的职能。例如客户服务部门提供客户服务的职能，财务部门提供财务相关的职能。</li><li>Bounded Context<br>  限界上下文是 DDD 中用来划分不同业务边界的元素，这里业务边界的含义是“解决不同业务问题”的问题域和对应的解决方案域，为了解决某种类型的业务问题，贴近领域知识，也就是业务。</li></ul><p>这本质上也促进了组织结构的演进：Service per team 。</p><p>建议：</p><ul><li>尽量闭环的团队负责一个服务。</li><li>尽量在服务划分的很细，需要扇出的请求特别多时再和服务的整合。</li></ul><h4 id="1-2-3-Microservice-划分之-CQRS"><a href="#1-2-3-Microservice-划分之-CQRS" class="headerlink" title="1.2.3 Microservice 划分之 CQRS"></a>1.2.3 Microservice 划分之 CQRS</h4><p>CQRS，将应用程序分为两部分：命令端和查询端。命令端处理程序创建，更新和删除请求，并在数据更改时发出事件。查询端通过针对一个或多个物化视图执行查询来处理查询，这些物化视图通过订阅数据更改时发出的事件流而保持最新。</p><p><img src="/images/《Go进阶训练营》学习笔记/稿件服务的CQRS.png" alt="稿件服务的CQRS"></p><p>在稿件服务演进过程中，我们发现围绕着创作稿件、审核稿件、最终发布稿件有大量的逻辑揉在一块，其中稿件本身的状态也有非常多种，但是最终前台用户只关注稿件能否查看，我们依赖稿件数据库 binlog 以及订阅 binlog 的中间件 canal，将我们的稿件结果发布到消息队列 kafka 中，最终消费数据独立组建一个稿件查阅结果数据库，并对外提供一个独立查询服务，来拆分复杂架构和业务。</p><p>我们架构也从 Polling publisher -&gt; Transaction log tailing 进行了演进(Pull vs Push)。</p><h4 id="1-2-4-Microservice-安全"><a href="#1-2-4-Microservice-安全" class="headerlink" title="1.2.4 Microservice 安全"></a>1.2.4 Microservice 安全</h4><p>对于外网的请求来说，我们通常在 API Gateway 进行统一的认证拦截，一旦认证成功，我们会使<br>用 JWT 方式通过 RPC 元数据传递的方式带到 BFF 层，BFF 校验 Token 完整性后把身份信息注入到应用的Context 中，BFF 到其他下层的微服务，建议是直接在 RPC Request 中带入用户身份信息(UserID)请求服务。</p><ul><li>API Gateway -&gt; BFF -&gt; Service</li><li>Biz Auth -&gt; JWT -&gt; Request Args</li></ul><p>对于服务内部，一般要区分身份认证和授权（先做认证再做授权再通过RBAC控制）。</p><ul><li>Full Trust：认证且加密</li><li>Half Trust：认证但不加密</li><li>Zero Trust：不认证不加密</li></ul><h3 id="1-3-gRPC-amp-服务发现"><a href="#1-3-gRPC-amp-服务发现" class="headerlink" title="1.3 gRPC &amp; 服务发现"></a>1.3 gRPC &amp; 服务发现</h3><h4 id="1-3-1-gRPC"><a href="#1-3-1-gRPC" class="headerlink" title="1.3.1 gRPC"></a>1.3.1 gRPC</h4><ul><li>多语言：语言中立，支持多种语言。</li><li>轻量级、高性能：序列化支持PB(Protocol Buffer)和JSON，PB 是一种语言无关的高性能序列化框架。</li><li>可插拔</li><li>IDL：基于文件定义服务，通过proto3 工具生成指定语言的数据结构、服务端接口以及客户端Stub。</li><li>设计理念</li><li>移动端：基于标准的HTTP2 设计，支持双向流、消息头压缩、单TCP 的多路复用、服务端推送等特性，这些特性使得gRPC 在移动端设备上更加省电和节省网络流量。</li><li>服务而非对象、消息而非引用：促进微服务的系统间粗粒度消息交互设计理念。</li><li>负载无关的：不同的服务需要使用不同的消息类型和编码，例如protocol buffers、JSON、XML 和Thrift。</li><li>流：Streaming API。</li><li>阻塞式和非阻塞式：支持异步和同步处理在客户端和服务端间交互的消息序列。</li><li>元数据交换：常见的横切关注点，如认证或跟踪，依赖数据交换。</li><li>标准化状态码：客户端通常以有限的方式响应API 调用返回的错误。</li></ul><p>不要过早关注性能问题，先标准化。</p><h4 id="1-3-2-gRPC-HealthCheck"><a href="#1-3-2-gRPC-HealthCheck" class="headerlink" title="1.3.2 gRPC - HealthCheck"></a>1.3.2 gRPC - HealthCheck</h4><p><img src="/images/《Go进阶训练营》学习笔记/gRPCHealthCheck.png" alt="gRPCHealthCheck"></p><p>gRPC 有一个标准的健康检测协议，在 gRPC 的所有语言实现中基本都提供了生成代码和用于设置运行状态的功能。</p><p>主动健康检查 health check，可以在服务提供者服务不稳定时，被消费者所感知，临时从负载均衡中摘除，减少错误请求。当服务提供者重新稳定后，health check成功，重新加入到消费者的负载均衡，恢复请求。<br>health check，同样也被用于外挂方式的容器健康检测，或者流量检测(k8s liveness &amp; readiness)。</p><p><img src="/images/《Go进阶训练营》学习笔记/k8s平滑发布.png" alt="k8s平滑发布"></p><h4 id="1-3-3-服务发现"><a href="#1-3-3-服务发现" class="headerlink" title="1.3.3 服务发现"></a>1.3.3 服务发现</h4><ol><li><p>客户端发现模式</p><p> 一个服务实例被启动时，它的网络地址会被写到注册表上；当服务实例终止时，再从注册表中删除；这个服务实例的注册表通过心跳机制动态刷新；客户端使用一个负载均衡算法，去选择一个可用的服务实例，来响应这个请求。</p></li><li><p>服务端发现模式</p><p> 客户端通过负载均衡器向一个服务发送请求，这个负载均衡器会查询服务注册表，并将请求路由到可用的服务实例上。服务实例在服务注册表上被注册和注销(Consul Template+Nginx，kubernetes+etcd)。</p></li><li><p>对比</p><p> 客户端发现： 直连，比服务端服务发现少一次网络跳转，Consumer 需要内置特定的服务发现客户端和发现逻辑。<br> 服务端发现：Consumer 无需关注服务发现具体细节，只需知道服务的DNS 域名即可，支持异构语言开发，需要基础设施支撑，多了一次网络跳转，可能有性能损失。</p><p> <img src="/images/《Go进阶训练营》学习笔记/服务发现模式对比.png" alt="服务发现模式对比"></p><p> 微服务的核心是去中心化，我们使用客户端发现模式。</p></li></ol><h4 id="1-3-4-服务发送的使用"><a href="#1-3-4-服务发送的使用" class="headerlink" title="1.3.4 服务发送的使用"></a>1.3.4 服务发送的使用</h4><p><img src="/images/《Go进阶训练营》学习笔记/服务发现应用对比.png" alt="服务发现应用对比"></p><p>早期我们使用最熟悉的 Zookeeper 作为服务发现，但是实际场景是海量服务发现和注册，服务状态可以弱一致, 需要的是 AP 系统。</p><ul><li>分布式协调服务(要求任何时刻对 ZooKeeper 的访问请求能得到一致的数据，从而牺牲可用性)。</li><li>网络抖动或网络分区会导致的 master 节点因为其他节点失去联系而重新选举或超过半数不可用导致服务注册发现瘫痪。</li><li>大量服务长连接导致性能瓶颈。</li></ul><p>我们参考了 Eureka 实现了自己的 AP 发现服务。</p><blockquote><p>现在推荐直接使用 <a href="https://nacos.io/zh-cn/">nacos</a> 。</p></blockquote><p><img src="/images/《Go进阶训练营》学习笔记/Eureka原理.png" alt="Eureka原理"></p><p>更多的细节：</p><ul><li>通过Family(appid) 和Addr(IP:Port) 定位实例，除此之外还可以附加更多的元数据：权重、染色标签、集群等。<blockquote><p>appid: 使用三段式命名，business.service.xxx</p></blockquote></li><li>Provider 注册后定期(30s)心跳一次，注册，心跳，下线都需要进行同步，注册和下线需要进行长轮询推送。<blockquote><p>新启动节点，需要load cache，JVM 预热。</p><p>故障时，Provider 不建议重启和发布。</p></blockquote></li><li>Consumer 启动时拉取实例，发起30s长轮询。<blockquote><p>故障时，需要client 侧cache 节点信息。</p></blockquote></li><li>Server 定期(60s) 检测失效(90s)的实例，失效则剔除。短时间里丢失了大量的心跳连接(15分钟内心跳低于期望值*85%)，开启自我保护，保留过期服务不删除。</li></ul><p>试想两个场景，牺牲一致性，最终一致性的情况：</p><ul><li>注册的事件延迟</li><li>注销的事件延迟：有点到点 RPC 的 health check 能让节点及时的下线。</li></ul><h3 id="1-4-多集群-amp-多租户"><a href="#1-4-多集群-amp-多租户" class="headerlink" title="1.4 多集群 &amp; 多租户"></a>1.4 多集群 &amp; 多租户</h3><h4 id="1-4-1-多集群"><a href="#1-4-1-多集群" class="headerlink" title="1.4.1 多集群"></a>1.4.1 多集群</h4><p><strong>这里指定的是单个机房内的多集群。</strong></p><p>Level 0（最重要的服务等级）服务，类似像我们账号，之前是一套大集群，一旦故障影响返回巨大，所以我们从几个角度考虑多集群的必要性：</p><ul><li>从单一集群考虑，多个节点保证可用性，我们通常使用N+2 的方式来冗余节点。</li><li>从单一集群故障带来的影响面角度考虑冗余多套集群。</li><li>单个机房内的机房故障导致的问题。</li></ul><p><img src="/images/《Go进阶训练营》学习笔记/多集群.png" alt="多集群"></p><p>我们利用 paas 平台，给某个 appid 服务建立多套集群(物理上相当于两套资源，逻辑上维护 cluster 的概念)，对于不同集群服务启动后，从环境变量里可以获取当下服务的 cluster，在服务发现注册的时候，带入这些元信息。当然，不同集群可以隔离使用不同的缓存资源等。</p><blockquote><p>实际使用时，是为不同的业务单独搭一套。比如：为直播的业务搭一套账号，为游戏的业务搭一套账号。</p></blockquote><ul><li>多套冗余的集群对应多套独占的缓存，带来更好的性能和冗余能力。</li><li>尽量避免业务隔离使用或者sharding 带来的 cache hit 影响（按照业务划分集群资源）。</li></ul><p>业务隔离集群带来的问题是 cache hit ratio 下降，不同业务形态数据正交（会导致连其他业务对应的账号服务时有巨量的缓存穿透），我们退而求其次整个集群全部连接（让所有客户端连接所有(m x n)业务的账号服务，这样就能让所有账号服务对应的缓存热起来）。</p><h4 id="1-4-2-多集群的高资源占用处理"><a href="#1-4-2-多集群的高资源占用处理" class="headerlink" title="1.4.2 多集群的高资源占用处理"></a>1.4.2 多集群的高资源占用处理</h4><p>让所有客户端都连接所有的账号服，导致即使空闲时，gRPC 因处理 HealthCheck 的 CPU 也高达 30% 。</p><blockquote><p>下面的解决思路来自 <a href="https://book.douban.com/subject/26675256/">Google SRE</a> 。</p></blockquote><p>统一为一套逻辑集群（物理上多套资源池），即 gRPC 客户端默认忽略服务发现中的 cluster 信息，按照全部节点，全部连接。能不能找到一种算法从全集群中选取一批节点(子集)，利用划分子集限制连接池大小。</p><ul><li>长连接导致的内存和CPU 开销，HealthCheck 可以高达30%。</li><li>短连接极大的资源成本和延迟。</li></ul><p><img src="/images/《Go进阶训练营》学习笔记/多集群子集算法.png" alt="多集群子集算法"></p><p>合适的子集大小和选择算法：</p><ul><li>通常20-100个后端，部分场景需要大子集，比如大批量读写操作。</li><li>后端平均分给客户端。</li><li>客户端重启，保持重新均衡，同时对后端重启保持透明，同时连接的变动最小。</li></ul><h4 id="1-4-3-多租户"><a href="#1-4-3-多租户" class="headerlink" title="1.4.3 多租户"></a>1.4.3 多租户</h4><p>在一个微服务架构中允许多系统共存是利用微服务稳定性以及模块化最有效的方式之一，这种方式一般被称为多租户(multi-tenancy)。租户可以是测试，金丝雀发布，影子系统(shadow systems)，甚至服务层或者产品线，使用租户能够保证代码的隔离性并且能够基于流量租户做路由决策。</p><p>对于传输中的数据(data-in-flight)（例如，消息队列中的请求或者消息）以及静态数据(data-at-rest)（例如，存储或者持久化缓存），租户都能够保证隔离性和公平性，以及基于租户的路由机会。</p><p><img src="/images/《Go进阶训练营》学习笔记/多租户.png" alt="多租户"></p><p>如果我们对服务 B 做出改变，我们需要确保它仍然能够和服务 A、C、D 正常交互。在微服务架构中，我们需要做这些集成测试场景，也就是测试和该系统中其他服务的交互。通常来说，微服务架构有两种基本的集成测试方式：并行测试和生产环境测试。</p><ol><li><p>并行测试</p><p> <img src="/images/《Go进阶训练营》学习笔记/并行测试.png" alt="并行测试"></p><p> 并行测试需要一个和生产环境一样的过渡(staging)环境，并且只是用来处理测试流量。在并行测试中，工程师团队首先完成生产服务的一次变动，然后将变动的代码部署到测试栈。这种方法可以在不影响生产环境的情况下让开发者稳定的测试服务，同时能够在发布前更容易的识别和控制bug。尽管并行测试是一种非常有效的集成测试方法，但是它也带来了一些可能影响微服务架构成功的挑战：</p><ul><li>混用环境导致的不可靠测试。</li><li>多套环境带来的硬件成本。</li><li>难以做负载测试，仿真线上真实流量情况。</li></ul></li><li><p>灰度测试</p><p> <img src="/images/《Go进阶训练营》学习笔记/灰度测试.png" alt="灰度测试"></p><p> 使用这种方法(内部叫染色发布)，我们可以把待测试的服务 B 在一个隔离的沙盒环境中启动，并且在沙盒环境下可以访问集成环境(UAT) C 和 D。我们把测试流量路由到服务B，同时保持生产流量正常流入到集成服务。服务 B 仅仅处理测试流量而不处理生产流量。另外要确保集成流量不要被测试流量影响。生产中的测试提出了两个基本要求，它们也构成了多租户体系结构的基础：</p><ul><li>流量路由：能够基于流入栈中的流量类型做路由。</li><li><p>隔离性：能够可靠的隔离测试和生产中的资源，这样可以保证对于关键业务微服务没有副作用。</p><p>灰度测试成本代价很大，影响 1/N 的用户。其中 N 为节点数量。</p></li></ul></li><li><p>多租户</p><p> <img src="/images/《Go进阶训练营》学习笔记/多租户测试.png" alt="多租户测试"></p><p> 给入站请求绑定上下文(如: http header)， in-process 使用 context 传递，跨服务使用metadata 传递(如: opentracing baggage item)，在这个架构中每一个基础组件都能够理解租户信息，并且能够基于租户路由隔离流量，同时在我们的平台中允许对运行不同的微服务有更多的控制，比如指标和日志。在微服务架构中典型的基础组件是日志，指标，存储，消息队列，缓存以及配置。基于租户信息隔离数据需要分别处理基础组件。</p><p> 多租户架构本质上描述为：跨服务传递请求携带上下文(context)，数据隔离的流量路由方案。</p><p> 利用服务发现注册租户信息，注册成特定的租户。</p></li></ol><h2 id="第2课-异常处理"><a href="#第2课-异常处理" class="headerlink" title="第2课 异常处理"></a>第2课 异常处理</h2><h3 id="2-1-Error-vs-Exception"><a href="#2-1-Error-vs-Exception" class="headerlink" title="2.1 Error vs Exception"></a>2.1 Error vs Exception</h3><h4 id="2-1-1-Go-中的-error"><a href="#2-1-1-Go-中的-error" class="headerlink" title="2.1.1 Go 中的 error"></a>2.1.1 Go 中的 error</h4><p>Go error 就是普通的一个接口，普通的值。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// The error built-in interface type is the conventional interface for</span><span class="token comment">// representing an error condition, with the nil value representing no error.</span><span class="token keyword">type</span> <span class="token builtin">error</span> <span class="token keyword">interface</span> <span class="token punctuation">{</span>    <span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>经常使用 errors.New() 来返回一个 error 对象。<br>errors.New() 返回的是内部 errorString 对象的指针。</p><blockquote><p>返回指针是为了保证即使值相同的但是错误依然要不同（见代码中的注释）。</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// New returns an error that formats as the given text.</span><span class="token comment">// Each call to New returns a distinct error value even if the text is identical.</span><span class="token keyword">func</span> <span class="token function">New</span><span class="token punctuation">(</span>text <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span>errorString<span class="token punctuation">{</span>text<span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-2-其他语言中的错误处理"><a href="#2-1-2-其他语言中的错误处理" class="headerlink" title="2.1.2 其他语言中的错误处理"></a>2.1.2 其他语言中的错误处理</h4><p>各个语言的演进历史：</p><ol><li><p>C</p><p> 单返回值，一般通过传递指针作为入参，返回值为 int 表示成功还是失败。</p></li><li><p>C++</p><p> 引入了 exception，但是无法知道被调用方会抛出什么异常。</p></li><li><p>Java</p><p> 引入了 checked exception，方法的所有者必须申明，调用者必须处理。在启动时抛出大量的异常是司空见惯的事情，并在它们的调用堆栈中尽职地记录下来。Java 异常不再是异常，而是变得司空见惯了。它们从良性到灾难性都有使用，异常的严重性由函数的调用者来区分。</p></li><li><p>Go</p><p> Go 的处理异常逻辑是不引入 exception，支持多参数返回，所以你很容易的在函数签名中带上实现了 error interface 的对象，交由调用者来判定。</p><blockquote><p>如果一个函数返回了 value, error，你不能对这个 value 做任何假设，必须先判定 error。唯一可以忽略 error 的是，如果你连 value 也不关心。</p></blockquote><p> Go 中有 panic 的机制，如果你认为和其他语言的 exception 一样，那你就错了。当我们抛出异常的时候，相当于你把 exception 扔给了调用者来处理。</p><blockquote><p>比如，你在 C++ 中，把 string 转为 int，如果转换失败，会抛出异常。或者在 java 中转换 string 为 date 失败时，会抛出异常。</p><p>Go panic 意味着 fatal error(就是挂了)。不能假设调用者来解决 panic，意味着代码不能继续运行。</p></blockquote><p> 使用多个返回值和一个简单的约定，Go 解决了让程序员知道什么时候出了问题，并为真正的异常情况保留了 panic。</p></li></ol><p>对于真正意外的情况，那些表示不可恢复的程序错误，例如索引越界、不可恢复的环境问题、栈溢出，我们才使用 panic。对于其他的错误情况，我们应该是期望使用 error 来进行判定。</p><blockquote><p>you only need to check the error value if you care about the result.  — Dave</p><p>This <a href="https://devblogs.microsoft.com/oldnewthing/?p=36693">blog post</a> from Microsoft’s engineering blog in 2005 still holds true today, namely:</p><blockquote><p>My point isn’t that exceptions are bad. My point is that exceptions are too hard and I’m not smart enough to handle them.</p></blockquote></blockquote><p>Go 的错误设计：</p><ul><li>简单。</li><li>考虑失败，而不是成功(Plan for failure, not success)。</li><li>没有隐藏的控制流。</li><li>完全交给你来控制 error。</li><li>Error are values。</li></ul><h3 id="2-2-Error-Type"><a href="#2-2-Error-Type" class="headerlink" title="2.2 Error Type"></a>2.2 Error Type</h3><h4 id="2-2-1-Sentinel-Error"><a href="#2-2-1-Sentinel-Error" class="headerlink" title="2.2.1 Sentinel Error"></a>2.2.1 Sentinel Error</h4><p>预定义的特定错误，我们叫为 <code>sentinel error</code>，这个名字来源于计算机编程中使用一个特定值来表示不可能进行进一步处理的做法。所以对于 Go，我们使用特定的值来表示错误。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> err <span class="token operator">==</span> ErrSomething <span class="token punctuation">{</span> … <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类似的 <code>io.EOF</code>，更底层的 <code>syscall.ENOENT</code>。</p><blockquote><p>使用 sentinel 值是最不灵活的错误处理策略，因为调用方必须使用 == 将结果与预先声明的值进行比较。当您想要提供更多的上下文时，这就出现了一个问题，因为返回一个不同的错误将破坏相等性检查。</p><p>甚至是一些有意义的 fmt.Errorf 携带一些上下文，也会破坏调用者的 == ，调用者将被迫查看 error.Error() 方法的输出，以查看它是否与特定的字符串匹配。</p></blockquote><ol><li><p>不依赖检查 error.Error 的输出。</p><p> 不应该依赖检测 error.Error 的输出，Error 方法存在于 error 接口主要用于方便程序员使用，但不是程序(编写测试可能会依赖这个返回)。这个输出的字符串用于记录日志、输出到 stdout 等。</p></li><li><p>Sentinel errors 成为你 API 公共部分。</p><p> 如果您的公共函数或方法返回一个特定值的错误，那么该值必须是公共的，当然要有文档记录，这会增加 API 的表面积。</p><p> 如果 API 定义了一个返回特定错误的 interface，则该接口的所有实现都将被限制为仅返回该错误，即使它们可以提供更具描述性的错误。</p><p> 比如 io.Reader。像 io.Copy 这类函数需要 reader 的实现者比如返回 io.EOF 来告诉调用者没有更多数据了，但这又不是错误。</p></li><li><p>Sentinel errors 在两个包之间创建了依赖。</p><p> sentinel errors 最糟糕的问题是它们在两个包之间创建了源代码依赖关系。例如，检查错误是否等于 io.EOF，您的代码必须导入 io 包。这个特定的例子听起来并不那么糟糕，因为它非常常见，但是想象一下，当项目中的许多包导出错误值时，存在耦合，项目中的其他包必须导入这些错误值才能检查特定的错误条件(in the form of an import loop)。</p></li><li><p>结论: 尽可能避免 sentinel errors。</p><p> 我的建议是避免在编写的代码中使用 sentinel errors。在标准库中有一些使用它们的情况，但这不是一个您应该模仿的模式。</p></li></ol><h4 id="2-2-2-Error-types"><a href="#2-2-2-Error-types" class="headerlink" title="2.2.2 Error types"></a>2.2.2 Error types</h4><p>Error type 是实现了 error 接口的自定义类型。例如 MyError 类型记录了文件和行号以展示发生了什么。因为 MyError 是一个 type，调用者可以使用断言转换成这个类型，来获取更多的上下文信息。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> MyError <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Msg  <span class="token builtin">string</span>    File <span class="token builtin">string</span>    Line <span class="token builtin">int</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>e <span class="token operator">*</span>MyError<span class="token punctuation">)</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%s:%d: %s"</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>File<span class="token punctuation">,</span> e<span class="token punctuation">.</span>Line<span class="token punctuation">,</span> e<span class="token punctuation">.</span>Msg<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span>MyError<span class="token punctuation">{</span><span class="token string">"kibazen.cn"</span><span class="token punctuation">,</span> <span class="token string">"server.go"</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    err <span class="token operator">:=</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">switch</span> err <span class="token operator">:=</span> err<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token boolean">nil</span><span class="token punctuation">:</span>        <span class="token comment">// call succeeded, nothing to do</span>    <span class="token keyword">case</span> <span class="token operator">*</span>MyError<span class="token punctuation">:</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"error occurred on line: "</span><span class="token punctuation">,</span> err<span class="token punctuation">.</span>Line<span class="token punctuation">)</span>    <span class="token keyword">default</span><span class="token punctuation">:</span>        <span class="token comment">// unknown error</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与错误值相比，错误类型的一大改进是它们能够包装底层错误以提供更多上下文。<br>一个不错的例子就是 os.PathError 他提供了底层执行了什么操作、那个路径出了什么问题。</p><p><img src="/images/《Go进阶训练营》学习笔记/os.PathError.png" alt="os.PathError"></p><p>调用者要使用类型断言和类型 <code>switch</code> ，就要让自定义的 <code>error</code> 变为 public。这种模型会导致和调用者产生强耦合，从而导致 API 变得脆弱。</p><p>结论是尽量避免使用 error types，虽然错误类型比 sentinel errors 更好，因为它们可以捕获关于出错的更多上下文，但是 error types 共享 error values 许多相同的问题。</p><p>因此，我的建议是避免错误类型，或者至少避免将它们作为公共 API 的一部分。</p><h4 id="2-2-3-Opaque-errors"><a href="#2-2-3-Opaque-errors" class="headerlink" title="2.2.3 Opaque errors"></a>2.2.3 Opaque errors</h4><p>在我看来，这是最灵活的错误处理策略，因为它要求代码和调用者之间的耦合最少。</p><p>我将这种风格称为不透明错误处理，因为虽然您知道发生了错误，但您没有能力看到错误的内部。作为调用者，关于操作的结果，您所知道的就是它起作用了，或者没有起作用(成功还是失败)。</p><p>这就是不透明错误处理的全部功能–只需返回错误而不假设其内容。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>    x<span class="token punctuation">,</span> err <span class="token operator">:=</span> bar<span class="token punctuation">.</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> err    <span class="token punctuation">}</span>    <span class="token comment">// use x</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Assert errors for behaviour, not type.</strong></p><p>在少数情况下，这种二分错误处理方法是不够的。例如，与进程外的世界进行交互(如网络活动)，需要调用方调查错误的性质，以确定重试该操作是否合理。在这种情况下，我们可以断言错误实现了特定的行为，而不是断言错误是特定的类型或值。考虑这个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> net<span class="token comment">// An Error represents a network error.</span><span class="token keyword">type</span> Error <span class="token keyword">interface</span> <span class="token punctuation">{</span>    <span class="token builtin">error</span>    <span class="token function">Timeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span>   <span class="token comment">// Is the error a timeout?</span>    <span class="token function">Temporary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token comment">// Is the error temporary?</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> temporary <span class="token keyword">interface</span> <span class="token punctuation">{</span>    <span class="token function">Temporary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span><span class="token punctuation">}</span><span class="token comment">// IsTemporary returns true if err is temporary.</span><span class="token keyword">func</span> <span class="token function">IsTemporary</span><span class="token punctuation">(</span>err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>    te<span class="token punctuation">,</span> ok <span class="token operator">:=</span> errors<span class="token punctuation">.</span><span class="token function">Cause</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span>temporary<span class="token punctuation">)</span>    <span class="token keyword">return</span> ok <span class="token operator">&amp;&amp;</span> te<span class="token punctuation">.</span><span class="token function">Temporary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的关键是，这个逻辑可以在不导入定义错误的包或者实际上不了解 err 的底层类型的情况下实现——我们只对它的行为感兴趣。</p><h3 id="2-3-Handling-Error"><a href="#2-3-Handling-Error" class="headerlink" title="2.3 Handling Error"></a>2.3 Handling Error</h3><h4 id="2-3-1-Indented-flow-is-for-errors"><a href="#2-3-1-Indented-flow-is-for-errors" class="headerlink" title="2.3.1 Indented flow is for errors"></a>2.3.1 Indented flow is for errors</h4><p>无错误的正常流程代码，将成为一条直线，而不是缩进的代码。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">f<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token comment">// handle error</span>    <span class="token punctuation">}</span>    <span class="token comment">// do stuff</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-2-Eliminate-error-handling-by-eliminating-errors"><a href="#2-3-2-Eliminate-error-handling-by-eliminating-errors" class="headerlink" title="2.3.2 Eliminate error handling by eliminating errors"></a>2.3.2 Eliminate error handling by eliminating errors</h4><p><a href="https://dave.cheney.net/2019/01/27/eliminate-error-handling-by-eliminating-errors">Eliminate error handling by eliminating errors</a></p><h4 id="2-3-3-Wrap-error"><a href="#2-3-3-Wrap-error" class="headerlink" title="2.3.3 Wrap error"></a>2.3.3 Wrap error</h4><p><a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully">Don’t just check errors, handle them gracefully</a></p><ol><li>在你的应用代码中，使用 errors.New 或者 errros.Errorf 返回错误。</li><li>如果调用其他的函数，通常简单的直接返回。</li><li>如果和其他库进行协作，考虑使用 errors.Wrap 或者 errors.Wrapf 保存堆栈信息。同样适用于和标准库协作的时候。</li><li>直接返回错误，而不是每个错误产生的地方到处打日志。</li><li>在程序的顶部或者是工作的 goroutine 顶部(请求入口)，使用 %+v 把堆栈详情记录。</li><li>使用 errors.Cause 获取 root error，再进行和 sentinel error 判定。</li></ol><h4 id="2-3-4-总结"><a href="#2-3-4-总结" class="headerlink" title="2.3.4 总结"></a>2.3.4 总结</h4><ol><li><p>Packages that are reusable across many projects only return root error values.</p><p> 选择 wrap error 是只有 applications 可以选择应用的策略。具有最高可重用性的包只能返回根错误值。此机制与 Go 标准库中使用的相同(kit 库的 sql.ErrNoRows)。</p></li><li><p>If the error is not going to be handled, wrap and return up the call stack.</p><p> 这是关于函数/方法调用返回的每个错误的基本问题。如果函数/方法不打算处理错误，那么用足够的上下文 wrap errors 并将其返回到调用堆栈中。例如，额外的上下文可以是使用的输入参数或失败的查询语句。确定您记录的上下文是足够多还是太多的一个好方法是检查日志并验证它们在开发期间是否为您工作。</p></li><li><p>Once an error is handled, it is not allowed to be passed up the call stack any longer.</p><p> 一旦确定函数/方法将处理错误，错误就不再是错误。如果函数/方法仍然需要发出返回，则它不能返回错误值。它应该只返回零(比如降级处理中，你返回了降级数据，然后需要 return nil)。</p></li></ol><h3 id="2-4-Go-1-13-errors"><a href="#2-4-Go-1-13-errors" class="headerlink" title="2.4 Go 1.13 errors"></a>2.4 Go 1.13 errors</h3><p><a href="https://go.dev/blog/go1.13-errors">Working with Errors in Go 1.13</a></p><h4 id="2-4-1-Unwrap"><a href="#2-4-1-Unwrap" class="headerlink" title="2.4.1 Unwrap"></a>2.4.1 Unwrap</h4><p>go1.13为 errors 和 fmt 标准库包引入了新特性，以简化处理包含其他错误的错误。其中最重要的是: 包含另一个错误的 error 可以实现返回底层错误的 Unwrap 方法。如果 e1.Unwrap() 返回 e2，那么我们说 e1 包装 e2，您可以展开 e1 以获得 e2。</p><p>go1.13 errors 包包含两个用于检查错误的新函数：Is 和 As。</p><h4 id="2-4-2-Wrapping-errors-with-w"><a href="#2-4-2-Wrapping-errors-with-w" class="headerlink" title="2.4.2 Wrapping errors with %w"></a>2.4.2 Wrapping errors with %w</h4><p>使用 fmt.Errorf 向错误添加附加信息。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"decompress %v: %v"</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在 Go 1.13中 fmt.Errorf 支持新的 %w 谓词。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>    <span class="token comment">// Return an error which unwraps to err.</span>    <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"decompress %v: %w"</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>用 %w 包装错误可用于 errors.Is 以及 errors.As。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">err <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"access denied: %w"</span><span class="token punctuation">,</span> ErrPermission<span class="token punctuation">)</span><span class="token operator">...</span><span class="token keyword">if</span> errors<span class="token punctuation">.</span><span class="token function">Is</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> ErrPermission<span class="token punctuation">)</span> <span class="token operator">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-5-Go-2-Error-Inspection"><a href="#2-5-Go-2-Error-Inspection" class="headerlink" title="2.5 Go 2 Error Inspection"></a>2.5 Go 2 Error Inspection</h3><p><a href="https://go.googlesource.com/proposal/+/master/design/29934-error-values.md">Proposal: Go 2 Error Inspection</a></p><h3 id="2-6-References"><a href="#2-6-References" class="headerlink" title="2.6 References"></a>2.6 References</h3><p><a href="https://dave.cheney.net/2012/01/18/why-go-gets-exceptions-right">https://dave.cheney.net/2012/01/18/why-go-gets-exceptions-right</a><br><a href="https://dave.cheney.net/2015/01/26/errors-and-exceptions-redux">https://dave.cheney.net/2015/01/26/errors-and-exceptions-redux</a><br><a href="https://dave.cheney.net/2014/11/04/error-handling-vs-exceptions-redux">https://dave.cheney.net/2014/11/04/error-handling-vs-exceptions-redux</a><br><a href="https://rauljordan.com/2020/07/06/why-go-error-handling-is-awesome.html">https://rauljordan.com/2020/07/06/why-go-error-handling-is-awesome.html</a><br><a href="https://morsmachine.dk/error-handling">https://morsmachine.dk/error-handling</a><br><a href="https://blog.golang.org/error-handling-and-go">https://blog.golang.org/error-handling-and-go</a><br><a href="https://www.ardanlabs.com/blog/2014/10/error-handling-in-go-part-i.html">https://www.ardanlabs.com/blog/2014/10/error-handling-in-go-part-i.html</a><br><a href="https://www.ardanlabs.com/blog/2014/11/error-handling-in-go-part-ii.html">https://www.ardanlabs.com/blog/2014/11/error-handling-in-go-part-ii.html</a><br><a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully">https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully</a><br><a href="https://commandcenter.blogspot.com/2017/12/error-handling-in-upspin.html">https://commandcenter.blogspot.com/2017/12/error-handling-in-upspin.html</a><br><a href="https://blog.golang.org/errors-are-values">https://blog.golang.org/errors-are-values</a><br><a href="https://dave.cheney.net/2016/06/12/stack-traces-and-the-errors-package">https://dave.cheney.net/2016/06/12/stack-traces-and-the-errors-package</a><br><a href="https://www.ardanlabs.com/blog/2017/05/design-philosophy-on-logging.html">https://www.ardanlabs.com/blog/2017/05/design-philosophy-on-logging.html</a><br><a href="https://crawshaw.io/blog/xerrors">https://crawshaw.io/blog/xerrors</a><br><a href="https://blog.golang.org/go1.13-errors">https://blog.golang.org/go1.13-errors</a><br><a href="https://medium.com/gett-engineering/error-handling-in-go-53b8a7112d04">https://medium.com/gett-engineering/error-handling-in-go-53b8a7112d04</a><br><a href="https://medium.com/gett-engineering/error-handling-in-go-1-13-5ee6d1e0a55c">https://medium.com/gett-engineering/error-handling-in-go-1-13-5ee6d1e0a55c</a></p><h2 id="第3课-并行编程"><a href="#第3课-并行编程" class="headerlink" title="第3课 并行编程"></a>第3课 并行编程</h2><h3 id="3-1-Goroutine"><a href="#3-1-Goroutine" class="headerlink" title="3.1 Goroutine"></a>3.1 Goroutine</h3><h4 id="3-1-1-Processes-and-Threads"><a href="#3-1-1-Processes-and-Threads" class="headerlink" title="3.1.1 Processes and Threads"></a>3.1.1 Processes and Threads</h4><p>操作系统会为该应用程序创建一个进程。作为一个应用程序，它像一个为所有资源而运行的容器。这些资源包括内存地址空间、文件句柄、设备和线程。</p><p>线程是操作系统调度的一种执行路径，用于在处理器执行我们在函数中编写的代码。一个进程从一个线程开始，即主线程，当该线程终止时，进程终止。这是因为主线程是应用程序的原点。然后，主线程可以依次启动更多的线程，而这些线程可以启动更多的线程。</p><p>无论线程属于哪个进程，操作系统都会安排线程在可用处理器上运行。每个操作系统都有自己的算法来做出这些决定。</p><h4 id="3-1-2-Goroutines-and-Parallelism"><a href="#3-1-2-Goroutines-and-Parallelism" class="headerlink" title="3.1.2 Goroutines and Parallelism"></a>3.1.2 Goroutines and Parallelism</h4><p>Go 语言层面支持的 go 关键字，可以快速的让一个函数创建为 goroutine，我们可以认为 main 函数就是作为 goroutine 执行的。操作系统调度线程在可用处理器上运行，Go运行时调度 goroutines 在绑定到单个操作系统线程的逻辑处理器中运行(P)。即使使用这个单一的逻辑处理器和操作系统线程，也可以调度数十万 goroutine 以惊人的效率和性能并发运行。</p><blockquote><p>Concurrency is not Parallelism.</p></blockquote><p>并发不是并行。并行是指两个或多个线程同时在不同的处理器执行代码。如果将运行时配置为使用多个逻辑处理器，则调度程序将在这些逻辑处理器之间分配 goroutine，这将导致 goroutine 在不同的操作系统线程上运行。但是，要获得真正的并行性，您需要在具有多个物理处理器的计算机上运行程序。否则，goroutines 将针对单个物理处理器并发运行，即使 Go 运行时使用多个逻辑处理器。</p><h4 id="3-1-3-Keep-yourself-busy-or-do-the-work-yourself"><a href="#3-1-3-Keep-yourself-busy-or-do-the-work-yourself" class="headerlink" title="3.1.3 Keep yourself busy or do the work yourself"></a>3.1.3 Keep yourself busy or do the work yourself</h4><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_keep_yourself_busy_or_do_the_work_yourself">Keep yourself busy or do the work yourself</a></p><p>空的 select 语句将永远阻塞。</p><p>如果你的 goroutine 在从另一个 goroutine 获得结果之前无法取得进展，那么通常情况下，你自己去做这项工作比委托它( go func() )更简单。<br>这通常消除了将结果从 goroutine 返回到其启动器所需的大量状态跟踪和 chan 操作。</p><h4 id="3-1-4-Leave-concurrency-to-the-caller"><a href="#3-1-4-Leave-concurrency-to-the-caller" class="headerlink" title="3.1.4 Leave concurrency to the caller"></a>3.1.4 Leave concurrency to the caller</h4><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_leave_concurrency_to_the_caller">Leave concurrency to the caller</a></p><p>这两个 API 有什么区别？</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// ListDirectory returns the contents of dir.</span><span class="token keyword">func</span> <span class="token function">ListDirectory</span><span class="token punctuation">(</span>dir <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token comment">// ListDirectory returns a channel over which</span><span class="token comment">// directory entries will be published. When the list</span><span class="token comment">// of entries is exhausted, the channel will be closed.</span><span class="token keyword">func</span> <span class="token function">ListDirectory</span><span class="token punctuation">(</span>dir <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token keyword">chan</span> <span class="token builtin">string</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>将目录读取到一个 slice 中，然后返回整个切片，或者如果出现错误，则返回错误。这是同步调用的，ListDirectory 的调用方会阻塞，直到读取所有目录条目。根据目录的大小，这可能需要很长时间，并且可能会分配大量内存来构建目录条目名称的 slice。</li><li>ListDirectory 返回一个 chan string，将通过该 chan 传递目录。当通道关闭时，这表示不再有目录。由于在 ListDirectory 返回后发生通道的填充，ListDirectory 可能内部启动 goroutine 来填充通道。</li></ol><p>ListDirectory chan 版本还有两个问题：</p><ol><li>通过使用一个关闭的通道作为不再需要处理的项目的信号，ListDirectory 无法告诉调用者通过通道返回的项目集不完整，因为中途遇到了错误。调用方无法区分空目录与完全从目录读取的错误之间的区别。这两种方法都会导致从 ListDirectory 返回的通道会立即关闭。</li><li>调用者必须继续从通道读取，直到它关闭，因为这是调用者知道开始填充通道的 goroutine 已经停止的唯一方法。这对 ListDirectory 的使用是一个严重的限制，调用者必须花时间从通道读取数据，即使它可能已经收到了它想要的答案。对于大中型目录，它可能在内存使用方面更为高校，但这种方法并不比原始的基于 slice 的方法快。</li></ol><p>正确的方法是使用回调函数。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">ListDirectory</span><span class="token punctuation">(</span>dir <span class="token builtin">string</span><span class="token punctuation">,</span> fn <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>filepath.WalkDir 也是类似的模型，如果函数启动 goroutine，则必须向调用方提供显式停止该goroutine 的方法。通常，将异步执行函数的决定权交给该函数的调用方通常更容易。</p><h4 id="3-1-5-Never-start-a-goroutine-without-knowning-when-it-will-stop"><a href="#3-1-5-Never-start-a-goroutine-without-knowning-when-it-will-stop" class="headerlink" title="3.1.5 Never start a goroutine without knowning when it will stop"></a>3.1.5 Never start a goroutine without knowning when it will stop</h4><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_never_start_a_goroutine_without_knowning_when_it_will_stop">Never start a goroutine without knowning when it will stop</a></p><p>Any time you start a Goroutine you must ask yourself:</p><ul><li>When will it terminate?</li><li>What could prevent it from terminating?</li></ul><blockquote><p>Only use log.Fatal from main.main or init functions.</p></blockquote><h4 id="3-1-6-Incomplete-Work"><a href="#3-1-6-Incomplete-Work" class="headerlink" title="3.1.6 Incomplete Work"></a>3.1.6 Incomplete Work</h4><p><a href="https://www.ardanlabs.com/blog/2019/04/concurrency-trap-2-incomplete-work.html">Concurrency Trap #2: Incomplete Work</a></p><p>使用 sync.WaitGroup 来追踪每一个创建的 goroutine。</p><p>将 wg.Wait() 操作托管到其他 goroutine，owner goroutine 使用 context 处理超时。</p><p><a href="https://play.golang.org/p/p4gsDkpw1Gh">https://play.golang.org/p/p4gsDkpw1Gh</a></p><h3 id="3-2-Memory-model"><a href="#3-2-Memory-model" class="headerlink" title="3.2 Memory model"></a>3.2 Memory model</h3><h4 id="3-2-1-Memory-model"><a href="#3-2-1-Memory-model" class="headerlink" title="3.2.1 Memory model"></a>3.2.1 Memory model</h4><p>如何保证在一个 goroutine 中看到在另一个 goroutine 修改的变量的值，如果程序中修改数据时有其他 goroutine 同时读取，那么必须将读取串行化。为了串行化访问，请使用 channel 或其他同步原语，例如 sync 和 sync/atomic 来保护数据。</p><p><a href="https://golang.org/ref/mem">https://golang.org/ref/mem</a></p><p>先行发生（happens before）：如果事件 e1 发生在 e2 前，我们可以说 e2 发生在 e1 后。如果 e1不发生在 e2 前也不发生在 e2 后，我们就说 e1 和 e2 是并发的。</p><p>写入单个 machine word 将是原子的。</p><blockquote><p>Reads and writes of values larger than a single machine word behave as multiple machine-word-sized operations in an unspecified order.</p></blockquote><p><a href="https://www.jianshu.com/p/5e44168f47a3">Go的内存模型</a></p><h4 id="3-2-2-Memory-Reordering"><a href="#3-2-2-Memory-Reordering" class="headerlink" title="3.2.2 Memory Reordering"></a>3.2.2 Memory Reordering</h4><p><a href="https://www.cs.utexas.edu/~bornholt/post/memory-models.html">Memory Consistency Models: A Tutorial</a></p><h3 id="3-3-Package-sync"><a href="#3-3-Package-sync" class="headerlink" title="3.3 Package sync"></a>3.3 Package sync</h3><h4 id="3-3-1-Share-Memory-By-Communicating"><a href="#3-3-1-Share-Memory-By-Communicating" class="headerlink" title="3.3.1 Share Memory By Communicating"></a>3.3.1 Share Memory By Communicating</h4><p><a href="https://go.dev/blog/codelab-share">Share Memory By Communicating</a></p><p>传统的线程模型(通常在编写 Java、C++ 和Python 程序时使用)程序员在线程之间通信需要使用共享内存。通常，共享数据结构由锁保护，线程将争用这些锁来访问数据。在某些情况下，通过使用线程安全的数据结构(如Python的Queue)，这会变得更容易。</p><p>Go 的并发原语 goroutines 和 channels 为构造并发软件提供了一种优雅而独特的方法。Go 没有显式地使用锁来协调对共享数据的访问，而是鼓励使用 chan 在 goroutine 之间传递对数据的引用。这种方法确保在给定的时间只有一个goroutine 可以访问数据。</p><p>Do not communicate by sharing memory; instead, share memory by communicating.</p><h4 id="3-3-2-Detecting-Race-Conditions-With-Go"><a href="#3-3-2-Detecting-Race-Conditions-With-Go" class="headerlink" title="3.3.2 Detecting Race Conditions With Go"></a>3.3.2 Detecting Race Conditions With Go</h4><p><a href="https://www.ardanlabs.com/blog/2013/09/detecting-race-conditions-with-go.html">Detecting Race Conditions With Go</a></p><p><a href="https://go.dev/blog/race-detector">Introducing the Go Race Detector</a></p><p>data race 是两个或多个 goroutine 访问同一个资源(如变量或数据结构)，并尝试对该资源进行读写而不考虑其他 goroutine。这种类型的代码可以创建您见过的最疯狂和最随机的 bug。通常需要大量的日志记录和运气才能找到这些类型的bug。</p><p><a href="https://dave.cheney.net/2014/06/27/ice-cream-makers-and-data-races">Ice cream makers and data races</a></p><p>interface 内部是是两个 machine word 的值。</p><blockquote><p>Type 指向实现了接口的 struct，Data 指向了实际的值。Data 作为通过 interface 中任何方法调用的接收方传递。</p></blockquote><p><img src="/images/《Go进阶训练营》学习笔记/interface的结构.png" alt="interface的结构"></p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> <span class="token keyword">interface</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Type <span class="token builtin">uintptr</span>     <span class="token comment">// points to the type of the interface implementation</span>    Data <span class="token builtin">uintptr</span>     <span class="token comment">// holds the data for the interface's receiver</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-3-sync-atomic"><a href="#3-3-3-sync-atomic" class="headerlink" title="3.3.3 sync.atomic"></a>3.3.3 sync.atomic</h4><p>Copy-On-Write 思路在微服务降级或者 local cache 场景中经常使用。写时复制指的是，写操作时候复制全量老数据到一个新的对象中，携带上本次新写的数据，之后利用原子替换(atomic.Value)，更新调用者的变量。来完成无锁访问共享数据。</p><p><img src="/images/《Go进阶训练营》学习笔记/Copy-On-Write.png" alt="Copy-On-Write"></p><h4 id="3-3-4-Mutex"><a href="#3-3-4-Mutex" class="headerlink" title="3.3.4 Mutex"></a>3.3.4 Mutex</h4><p><a href="https://medium.com/a-journey-with-go/go-mutex-and-starvation-3f4f4e75ad50">Go: Mutex and Starvation</a></p><ol><li><p>饥饿问题</p> <pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    done <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">bool</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> mu sync<span class="token punctuation">.</span>Mutex    <span class="token comment">// goroutine 1</span>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">{</span>            <span class="token keyword">select</span> <span class="token punctuation">{</span>            <span class="token keyword">case</span> <span class="token operator">&lt;-</span>done<span class="token punctuation">:</span>                <span class="token keyword">return</span>            <span class="token keyword">default</span><span class="token punctuation">:</span>                mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">100</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Microsecond<span class="token punctuation">)</span>                mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// goroutine 2</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">100</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Microsecond<span class="token punctuation">)</span>        mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    done <span class="token operator">&lt;-</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 这个案例基于两个 goroutine:</p><ol><li>goroutine 1 持有锁很长时间</li><li><p>goroutine 2 每100ms 持有一次锁</p><p>都是100ms 的周期，但是由于 goroutine 1 不断的请求锁，可预期它会更频繁的持续到锁。我们基于 Go 1.8 循环了10次，下面是锁的请求占用分布:</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">Lock acquired per goroutine:g1: 7200216g2: 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Mutex 被 g1 获取了700多万次，而 g2 只获取了10次。</p></li></ol></li><li><p>分析</p><p> 首先，goroutine1 将获得锁并休眠100ms。当goroutine2 试图获取锁时，它将被添加到锁的队列中- FIFO 顺序，goroutine 将进入等待状态：</p><p> <img src="/images/《Go进阶训练营》学习笔记/mutex的锁饥饿问题一.png" alt="mutex的锁饥饿问题一"></p><p> 然后，当 goroutine1 完成它的工作时，它将释放锁。这次释放将通知队列唤醒 goroutine2。goroutine2 将被标记为可运行的，并且正在等待 Go 调度程序在线程上运行：</p><p> <img src="/images/《Go进阶训练营》学习笔记/mutex的锁饥饿问题二.png" alt="mutex的锁饥饿问题二"></p><p> 然而，当 goroutine2 等待运行时，goroutine1将再次请求锁：</p><p> <img src="/images/《Go进阶训练营》学习笔记/mutex的锁饥饿问题三.png" alt="mutex的锁饥饿问题三"></p><p> goroutine2 尝试去获取锁，结果悲剧的发现锁又被人持有了，它自己继续进入到等待模式：</p><p> <img src="/images/《Go进阶训练营》学习笔记/mutex的锁饥饿问题四.png" alt="mutex的锁饥饿问题四"></p><p> goroutine 2对锁的获取将取决于它在线程上运行获取锁所需的时间。</p><blockquote><p>The acquisition of the lock by goroutine 2 will depend on the time it takes for it to run on a thread.</p></blockquote></li><li><p>解法方法</p><ul><li><p>Barging</p><p>  这种模式是为了提高吞吐量，当锁被释放时，它会唤醒第一个等待者，然后把锁给第一个等待者或者给第一个请求锁的人。</p></li><li><p>Handsoff</p><p>  当锁释放时候，锁会一直持有直到第一个等待者准备好获取锁。它降低了吞吐量，因为锁被持有，即使另一个 goroutine 准备获取它。</p><blockquote><p>一个互斥锁的 handsoff 会完美地平衡两个goroutine 之间的锁分配，但是会降低性能，因为它会迫使第一个 goroutine 等待锁。</p></blockquote></li><li><p>Spinning</p><p>  自旋在等待队列为空或者应用程序重度使用锁时效果不错。Parking 和 Unparking goroutines 有不低的性能成本开销，相比自旋来说要慢得多。</p></li></ul></li><li><p>饥饿模式</p><p> Go 1.8 使用了 Barging 和 Spining 的结合实现。当试图获取已经被持有的锁时，如果本地队列为空并且 P 的数量大于1，goroutine 将自旋几次(用一个 P 旋转会阻塞程序)。自旋后，goroutine park。在程序高频使用锁的情况下，它充当了一个快速路径。</p><p> Go 1.9 通过添加一个新的饥饿模式来解决先前解释的问题，该模式将会在释放时候触发 handsoff。所有等待锁超过一毫秒的 goroutine(也称为有界等待)将被诊断为饥饿。当被标记为饥饿状态时，unlock 方法会 handsoff 把锁直接扔给第一个等待者。</p><p> 在饥饿模式下，自旋也被停用，因为传入的goroutines 将没有机会获取为下一个等待者保留的锁。</p><p> 使用 Go 1.9 运行上面的代码会得到一个更公平的结果：</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">Lock acquired per goroutine:g1: 57g2: 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="3-3-5-errgroup"><a href="#3-3-5-errgroup" class="headerlink" title="3.3.5 errgroup"></a>3.3.5 errgroup</h4><p>我们把一个复杂的任务，尤其是依赖多个微服务 rpc 需要聚合数据的任务，分解为依赖和并行，依赖的意思为: 需要上游 a 的数据才能访问下游 b 的数据进行组合。但是并行的意思为: 分解为多个小任务并行执行，最终等全部执行完毕。</p><p><a href="https://pkg.go.dev/golang.org/x/sync/errgroup">https://pkg.go.dev/golang.org/x/sync/errgroup</a></p><p>核心原理: 利用 sync.Waitgroup 管理并行执行的 goroutine 。</p><ul><li>并行工作流</li><li>错误处理 或者 优雅降级</li><li>context 传播和取消</li><li>利用局部变量+闭包</li></ul><h4 id="3-3-6-sync-Pool"><a href="#3-3-6-sync-Pool" class="headerlink" title="3.3.6 sync.Pool"></a>3.3.6 sync.Pool</h4><p>sync.Pool 的场景是用来保存和复用临时对象，以减少内存分配，降低 GC 压力(Request-Driven 特别合适)。</p><p>Get 返回 Pool 中的任意一个对象。如果 Pool 为空，则调用 New 返回一个新创建的对象。</p><p>放进 Pool 中的对象，会在说不准什么时候被回收掉。所以如果事先 Put 进去 100 个对象，下次 Get 的时候发现 Pool 是空也是有可能的。不过这个特性的一个好处就在于不用担心 Pool 会一直增长，因为 Go 已经帮你在 Pool 中做了回收机制。</p><p>这个清理过程是在每次垃圾回收之前做的。之前每次GC 时都会清空 pool，而在1.13版本中引入了 victim cache，会将 pool 内数据拷贝一份，避免 GC 将其清空，即使没有引用的内容也可以保留最多两轮 GC。</p><h3 id="3-4-chan"><a href="#3-4-chan" class="headerlink" title="3.4 chan"></a>3.4 chan</h3><h4 id="3-4-1-Channels"><a href="#3-4-1-Channels" class="headerlink" title="3.4.1 Channels"></a>3.4.1 Channels</h4><p>channels 是一种类型安全的消息队列，充当两个 goroutine 之间的管道，将通过它同步的进行任意资源的交换。chan 控制 goroutines 交互的能力从而创建了 Go 同步机制。当创建的 chan 没有容量时，称为无缓冲通道。反过来，使用容量创建的 chan 称为缓冲通道。</p><h4 id="3-4-2-Unbuffered-Channels"><a href="#3-4-2-Unbuffered-Channels" class="headerlink" title="3.4.2 Unbuffered Channels"></a>3.4.2 Unbuffered Channels</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go">ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>无缓冲 chan 没有容量，因此进行任何交换前需要两个 goroutine 同时准备好。当 goroutine 试图将一个资源发送到一个无缓冲的通道并且没有goroutine 等待接收该资源时，该通道将锁住发送 goroutine 并使其等待。当 goroutine 尝试从无缓冲通道接收，并且没有 goroutine 等待发送资源时，该通道将锁住接收 goroutine 并使其等待。</p><blockquote><p>无缓冲信道的本质是保证同步。</p></blockquote><p><img src="/images/《Go进阶训练营》学习笔记/无缓冲chan.png" alt="无缓冲chan"></p><p>第一个 goroutine 在发送消息 foo 之后被阻塞，因为还没有接收者准备好。规范中对这种行为进行了很好的解释：</p><p><a href="https://golang.org/ref/spec#Channel_types">https://golang.org/ref/spec#Channel_types</a></p><blockquote><p>“If the capacity is zero or absent, the channel is unbuffered and communication succeeds only when both a sender and receiver are ready.”</p></blockquote><p><a href="https://golang.org/doc/effective_go.html#channels">https://golang.org/doc/effective_go.html#channels</a></p><blockquote><p>“If the channel is unbuffered, the sender blocks until the receiver has received the value”</p></blockquote><ul><li>Receive 先于 Send 发生。</li><li>好处: 100% 保证能收到。</li><li>代价: 延迟时间未知。</li></ul><h4 id="3-4-3-Buffered-Channels"><a href="#3-4-3-Buffered-Channels" class="headerlink" title="3.4.3 Buffered Channels"></a>3.4.3 Buffered Channels</h4><p>buffered channel 具有容量，因此其行为可能有点不同。当 goroutine 试图将资源发送到缓冲通道，而该通道已满时，该通道将锁住 goroutine并使其等待缓冲区可用。如果通道中有空间，发送可以立即进行，goroutine 可以继续。当goroutine 试图从缓冲通道接收数据，而缓冲通道为空时，该通道将锁住 goroutine 并使其等待资源被发送。</p><p><img src="/images/《Go进阶训练营》学习笔记/有缓冲chan.png" alt="有缓冲chan"></p><p>在 chan 创建过程中定义的缓冲区大小可能会极大地影响性能。</p><ul><li>Send 先于 Receive 发生。</li><li>好处: 延迟更小。</li><li>代价: 不保证数据到达，越大的 buffer，越小的保障到达。buffer = 1 时，给你延迟一个消息的保障。</li></ul><h4 id="3-4-4-Go-Concurrency-Patterns"><a href="#3-4-4-Go-Concurrency-Patterns" class="headerlink" title="3.4.4 Go Concurrency Patterns"></a>3.4.4 Go Concurrency Patterns</h4><ul><li>Timing out</li><li>Moving on</li><li>Pipeline</li><li>Fan-out, Fan-in</li><li>Cancellation<ul><li>Close 先于 Receive 发生(类似 Buffered)。</li><li>不需要传递数据，或者传递 nil。</li><li>非常适合去掉和超时控制。</li></ul></li><li>Contex</li></ul><p><a href="https://blog.golang.org/concurrency-timeouts">https://blog.golang.org/concurrency-timeouts</a><br><a href="https://blog.golang.org/pipelines">https://blog.golang.org/pipelines</a><br><a href="https://talks.golang.org/2013/advconc.slide#1">https://talks.golang.org/2013/advconc.slide#1</a><br><a href="https://github.com/go-kratos/kratos/tree/master/pkg/sync">https://github.com/go-kratos/kratos/tree/master/pkg/sync</a></p><h4 id="3-4-5-Design-Philosophy"><a href="#3-4-5-Design-Philosophy" class="headerlink" title="3.4.5 Design Philosophy"></a>3.4.5 Design Philosophy</h4><ol><li><p>If any given Send on a channel CAN cause the sending goroutine to block:</p><ul><li>Not allowed to use a Buffered channel larger than 1.<ul><li>Buffers larger than 1 must have reason/measurements.</li></ul></li><li>Must know what happens when the sending goroutine blocks.</li></ul></li><li><p>If any given Send on a channel WON’T cause the sending goroutine to block:</p><ul><li>You have the exact number of buffers for each send.<ul><li>Fan Out pattern</li></ul></li><li>You have the buffer measured for max capacity.<ul><li>Drop pattern</li></ul></li></ul></li><li><p>Less is more with buffers.</p><ul><li>Don’t think about performance when thinking about buffers.</li><li><p>Buffers can help to reduce blocking latency between signaling.</p><ul><li>Reducing blocking latency towards zero does not necessarily - mean better throughput.</li><li>If a buffer of one is giving you good enough throughput then - keep it.</li><li>Question buffers that are larger than one and measure for size.</li><li>Find the smallest buffer possible that provides good enough - throughput.</li></ul></li></ul></li></ol><h3 id="3-5-Package-context"><a href="#3-5-Package-context" class="headerlink" title="3.5 Package context"></a>3.5 Package context</h3><h4 id="3-5-1-Request-scoped-context"><a href="#3-5-1-Request-scoped-context" class="headerlink" title="3.5.1 Request-scoped context"></a>3.5.1 Request-scoped context</h4><p>在 Go 服务中，每个传入的请求都在其自己的goroutine 中处理。请求处理程序通常启动额外的 goroutine 来访问其他后端，如数据库和 RPC服务。处理请求的 goroutine 通常需要访问特定于请求(request-specific context)的值，例如最终用户的身份、授权令牌和请求的截止日期(deadline)。当一个请求被取消或超时时，处理该请求的所有 goroutine 都应该快速退出(fail fast)，这样系统就可以回收它们正在使用的任何资源。</p><p>Go 1.7 引入一个 context 包，它使得跨 API 边界的请求范围元数据、取消信号和截止日期很容易传递给处理请求所涉及的所有 goroutine(显示传递)。</p><p>在将 context 集成到 API 中时，要记住的最重要的一点是，它的作用域是请求级别的。例如，沿单个数据库查询存在是有意义的，但沿数据库对象存在则没有意义。</p><p>目前有两种方法可以将 context 对象集成到 API 中：</p><ol><li><p>The first parameter of a function call</p><p> 首参数传递 context 对象，比如，参考  net 包 Dialer.DialContext。此函数执行正常的 Dial 操作，但可以通过 context 对象取消函数调用。</p> <pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>d <span class="token operator">*</span>Dialer<span class="token punctuation">)</span> <span class="token function">DialContext</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> network<span class="token punctuation">,</span> address <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Conn<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>Optional config on a request structure</p><p> 在第一个 request 对象中携带一个可选的 context 对象。例如 net/http 库的 Request.WithContext，通过携带给定的 context 对象，返回一个新的 Request 对象。</p> <pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token function">WithContext</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token operator">*</span>Request<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h4 id="3-5-2-Do-not-store-Contexts-inside-a-struct-type"><a href="#3-5-2-Do-not-store-Contexts-inside-a-struct-type" class="headerlink" title="3.5.2 Do not store Contexts inside a struct type"></a>3.5.2 Do not store Contexts inside a struct type</h4><p><a href="https://pkg.go.dev/context">https://pkg.go.dev/context</a></p><p>Do not store Contexts inside a struct type; instead, pass a Context explicitly to each function that needs it. The Context should be the first parameter, typically named ctx:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">DoSomething</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> arg Arg<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>    <span class="token comment">// ... use ctx ...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Do not pass a nil Context, even if a function permits it. Pass context.TODO if you are unsure about which Context to use.</p><p><a href="https://brunoscheufler.com/blog/2019-11-03-understanding-the-go-context">Understanding Go’s context package</a></p><p>Incoming requests to a server should create a Context, and outgoing calls to servers should accept a Context.</p><p>The chain of function calls between them must propagate the Context, optionally replacing it with a derived Context created using WithCancel, WithDeadline, WithTimeout, or WithValue.</p><p>When a Context is canceled, all Contexts derived from it are also canceled.</p><p><a href="https://medium.com/@cep21/how-to-correctly-use-context-context-in-go-1-7-8f2c0fafdf39">How to correctly use context.Context in Go 1.7</a></p><p>使用 context 的一个很好的心智模型是它应该在程序中流动，应该贯穿你的代码。这通常意味着您不希望将其存储在结构体之中。它从一个函数传递到另一个函数，并根据需要进行扩展。理想情况下，每个请求都会创建一个 context 对象，并在请求结束时过期。</p><p>不存储上下文的一个例外是，当您需要将它放入一个结构中时，该结构纯粹用作通过通道传递的消息。如下例所示：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// A message processes parameter and returns the result on responseChan.</span><span class="token comment">// ctx is places in a struct, but this is ok to do.</span><span class="token keyword">type</span> message <span class="token keyword">struct</span> <span class="token punctuation">{</span>    responseChan <span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token builtin">int</span>    parameter    <span class="token builtin">string</span>    ctx          context<span class="token punctuation">.</span>Context<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-5-3-context-WithValue"><a href="#3-5-3-context-WithValue" class="headerlink" title="3.5.3 context.WithValue"></a>3.5.3 context.WithValue</h4><p>context.WithValue 内部基于 valueCtx 实现:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// A valueCtx carries a key-value pair. It implements Value for that key and</span><span class="token comment">// delegates all other calls to the embedded Context.</span><span class="token keyword">type</span> valueCtx <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Context    key<span class="token punctuation">,</span> val <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了实现不断的 WithValue，构建新的 context，内部在查找 key 时候，使用递归方式不断从当前，从父节点寻找匹配的 key，直到 root context(Background 和 TODO Value 函数会返回 nil)。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>valueCtx<span class="token punctuation">)</span> <span class="token function">Value</span><span class="token punctuation">(</span>key <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> c<span class="token punctuation">.</span>key <span class="token operator">==</span> key <span class="token punctuation">{</span>        <span class="token keyword">return</span> c<span class="token punctuation">.</span>val    <span class="token punctuation">}</span>    <span class="token keyword">return</span> c<span class="token punctuation">.</span>Context<span class="token punctuation">.</span><span class="token function">Value</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>context.WithValue 方法允许上下文携带请求范围的数据。这些数据必须是安全的，以便多个 goroutine 同时使用。这里的数据，更多是面向请求的元数据，不应该作为函数的可选参数来使用(比如 context 里面挂了一个sql.Tx 对象，传递到 Dao 层使用)，因为元数据相对函数参数更加是隐含的，面向请求的。而参数是更加显示的。</p><p>同一个 context 对象可以传递给在不同 goroutine 中运行的函数；上下文对于多个 goroutine 同时使用是安全的。对于值类型最容易犯错的地方，在于 context value 应该是 immutable 的，每次重新赋值应该是新的 context，即:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">context<span class="token punctuation">.</span><span class="token function">WithValue</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> oldvalue<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Context.Value should inform, not control.</p><p><a href="https://pkg.go.dev/context">https://pkg.go.dev/context</a></p><p><a href="https://www.linkedin.com/pulse/its-time-understand-golang-contexts-lucas-schenkel-schieferdecker">It’s time to understand Golang Contexts.</a></p><p>Use context values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.</p><blockquote><p>比如 染色，API 重要性，Trace。</p></blockquote><h4 id="3-5-4-When-a-Context-is-canceled-all-Contexts-derived-from-it-are-also-canceled"><a href="#3-5-4-When-a-Context-is-canceled-all-Contexts-derived-from-it-are-also-canceled" class="headerlink" title="3.5.4 When a Context is canceled, all Contexts derived from it are also canceled"></a>3.5.4 When a Context is canceled, all Contexts derived from it are also canceled</h4><p>当一个 context 被取消时，从它派生的所有 context 也将被取消。WithCancel(ctx) 参数 ctx 认为是 parent ctx，在内部会进行一个传播关系链的关联。Done() 返回 一个 chan，当我们取消某个parent context, 实际上上会递归层层 cancel 掉自己的 child context 的 done chan 从而让整个调用链中所有监听 cancel 的 goroutine退出。</p><h4 id="3-5-5-All-blocking-long-operations-should-be-cancelable"><a href="#3-5-5-All-blocking-long-operations-should-be-cancelable" class="headerlink" title="3.5.5 All blocking/long operations should be cancelable"></a>3.5.5 All blocking/long operations should be cancelable</h4><p>如果要实现一个超时控制，通过上面的context 的parent/child 机制，其实我们只需要启动一个定时器，然后在超时的时候，直接将当前的 context 给 cancel 掉，就可以实现监听在当前和下层的额context.Done() 的 goroutine 的退出。</p><h4 id="3-5-6-Final-Notes"><a href="#3-5-6-Final-Notes" class="headerlink" title="3.5.6 Final Notes"></a>3.5.6 Final Notes</h4><ul><li>Incoming requests to a server should create a Context.</li><li>Outgoing calls to servers should accept a Context.</li><li>Do not store Contexts inside a struct type; instead, pass a Context explicitly to each function that - needs it.</li><li>The chain of function calls between them must propagate the Context.</li><li>Replace a Context using WithCancel, WithDeadline, WithTimeout, or WithValue.</li><li>When a Context is canceled, all Contexts derived from it are also canceled.</li><li>The same Context may be passed to functions running in different goroutines; Contexts are safe for - simultaneous use by multiple goroutines.</li><li>Do not pass a nil Context, even if a function permits it. Pass a TODO context if you are unsure about - which Context to use.</li><li>Use context values only for request-scoped data that transits processes and APIs, not for passing - optional parameters to functions.</li><li>All blocking/long operations should be cancelable.</li><li>Context.Value obscures your program’s flow.</li><li>Context.Value should inform, not control.</li><li>Try not to use context.Value.</li></ul><p><a href="https://talks.golang.org/2014/gotham-context.slide#1">https://talks.golang.org/2014/gotham-context.slide#1</a></p><h3 id="3-6-References"><a href="#3-6-References" class="headerlink" title="3.6 References"></a>3.6 References</h3><p><a href="https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html">https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html</a><br><a href="https://www.ardanlabs.com/blog/2019/04/concurrency-trap-2-incomplete-work.html">https://www.ardanlabs.com/blog/2019/04/concurrency-trap-2-incomplete-work.html</a><br><a href="https://www.ardanlabs.com/blog/2014/01/concurrency-goroutines-and-gomaxprocs.html">https://www.ardanlabs.com/blog/2014/01/concurrency-goroutines-and-gomaxprocs.html</a><br><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_concurrency">https://dave.cheney.net/practical-go/presentations/qcon-china.html#_concurrency</a><br><a href="https://golang.org/ref/mem">https://golang.org/ref/mem</a><br><a href="https://blog.csdn.net/caoshangpa/article/details/78853919">https://blog.csdn.net/caoshangpa/article/details/78853919</a><br><a href="https://blog.csdn.net/qcrao/article/details/92759907">https://blog.csdn.net/qcrao/article/details/92759907</a><br><a href="https://cch123.github.io/ooo/">https://cch123.github.io/ooo/</a><br><a href="https://blog.golang.org/codelab-share">https://blog.golang.org/codelab-share</a><br><a href="https://dave.cheney.net/2018/01/06/if-aligned-memory-writes-are-atomic-why-do-we-need-the-sync-atomic-package">https://dave.cheney.net/2018/01/06/if-aligned-memory-writes-are-atomic-why-do-we-need-the-sync-atomic-package</a><br><a href="http://blog.golang.org/race-detector">http://blog.golang.org/race-detector</a><br><a href="https://dave.cheney.net/2014/06/27/ice-cream-makers-and-data-races">https://dave.cheney.net/2014/06/27/ice-cream-makers-and-data-races</a><br><a href="https://www.ardanlabs.com/blog/2014/06/ice-cream-makers-and-data-races-part-ii.html">https://www.ardanlabs.com/blog/2014/06/ice-cream-makers-and-data-races-part-ii.html</a><br><a href="https://medium.com/a-journey-with-go/go-how-to-reduce-lock-contention-with-the-atomic-package-ba3b2664b549">https://medium.com/a-journey-with-go/go-how-to-reduce-lock-contention-with-the-atomic-package-ba3b2664b549</a><br><a href="https://medium.com/a-journey-with-go/go-discovery-of-the-trace-package-e5a821743c3c">https://medium.com/a-journey-with-go/go-discovery-of-the-trace-package-e5a821743c3c</a><br><a href="https://medium.com/a-journey-with-go/go-mutex-and-starvation-3f4f4e75ad50">https://medium.com/a-journey-with-go/go-mutex-and-starvation-3f4f4e75ad50</a><br><a href="https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html">https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html</a><br><a href="https://medium.com/a-journey-with-go/go-buffered-and-unbuffered-channels-29a107c00268">https://medium.com/a-journey-with-go/go-buffered-and-unbuffered-channels-29a107c00268</a><br><a href="https://medium.com/a-journey-with-go/go-ordering-in-select-statements-fd0ff80fd8d6">https://medium.com/a-journey-with-go/go-ordering-in-select-statements-fd0ff80fd8d6</a><br><a href="https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html">https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html</a><br><a href="https://www.ardanlabs.com/blog/2014/02/the-nature-of-channels-in-go.html">https://www.ardanlabs.com/blog/2014/02/the-nature-of-channels-in-go.html</a><br><a href="https://www.ardanlabs.com/blog/2013/10/my-channel-select-bug.html">https://www.ardanlabs.com/blog/2013/10/my-channel-select-bug.html</a><br><a href="https://blog.golang.org/io2013-talk-concurrency">https://blog.golang.org/io2013-talk-concurrency</a><br><a href="https://blog.golang.org/waza-talk">https://blog.golang.org/waza-talk</a><br><a href="https://blog.golang.org/io2012-videos">https://blog.golang.org/io2012-videos</a><br><a href="https://blog.golang.org/concurrency-timeouts">https://blog.golang.org/concurrency-timeouts</a><br><a href="https://blog.golang.org/pipelines">https://blog.golang.org/pipelines</a><br><a href="https://www.ardanlabs.com/blog/2014/02/running-queries-concurrently-against.html">https://www.ardanlabs.com/blog/2014/02/running-queries-concurrently-against.html</a><br><a href="https://blogtitle.github.io/go-advanced-concurrency-patterns-part-3-channels/">https://blogtitle.github.io/go-advanced-concurrency-patterns-part-3-channels/</a><br><a href="https://www.ardanlabs.com/blog/2013/05/thread-pooling-in-go-programming.html">https://www.ardanlabs.com/blog/2013/05/thread-pooling-in-go-programming.html</a><br><a href="https://www.ardanlabs.com/blog/2013/09/pool-go-routines-to-process-task.html">https://www.ardanlabs.com/blog/2013/09/pool-go-routines-to-process-task.html</a><br><a href="https://blogtitle.github.io/categories/concurrency/">https://blogtitle.github.io/categories/concurrency/</a><br><a href="https://medium.com/a-journey-with-go/go-context-and-cancellation-by-propagation-7a808bbc889c">https://medium.com/a-journey-with-go/go-context-and-cancellation-by-propagation-7a808bbc889c</a><br><a href="https://blog.golang.org/context">https://blog.golang.org/context</a><br><a href="https://www.ardanlabs.com/blog/2019/09/context-package-semantics-in-go.html">https://www.ardanlabs.com/blog/2019/09/context-package-semantics-in-go.html</a><br><a href="https://golang.org/ref/spec#Channel_types">https://golang.org/ref/spec#Channel_types</a><br><a href="https://drive.google.com/file/d/1nPdvhB0PutEJzdCq5ms6UI58dp50fcAN/view">https://drive.google.com/file/d/1nPdvhB0PutEJzdCq5ms6UI58dp50fcAN/view</a><br><a href="https://medium.com/a-journey-with-go/go-context-and-cancellation-by-propagation-7a808bbc889c">https://medium.com/a-journey-with-go/go-context-and-cancellation-by-propagation-7a808bbc889c</a><br><a href="https://blog.golang.org/context">https://blog.golang.org/context</a><br><a href="https://www.ardanlabs.com/blog/2019/09/context-package-semantics-in-go.html">https://www.ardanlabs.com/blog/2019/09/context-package-semantics-in-go.html</a><br><a href="https://golang.org/doc/effective_go.html#concurrency">https://golang.org/doc/effective_go.html#concurrency</a><br><a href="https://zhuanlan.zhihu.com/p/34417106?hmsr=toutiao.io">https://zhuanlan.zhihu.com/p/34417106?hmsr=toutiao.io</a><br><a href="https://talks.golang.org/2014/gotham-context.slide#1">https://talks.golang.org/2014/gotham-context.slide#1</a><br><a href="mailto:https://medium.com/@cep21/how-to-correctly-use-context-context-in-go-1-7-8f2c0fafdf39">https://medium.com/@cep21/how-to-correctly-use-context-context-in-go-1-7-8f2c0fafdf39</a></p><h2 id="第4课-Go-工程化实践"><a href="#第4课-Go-工程化实践" class="headerlink" title="第4课 Go 工程化实践"></a>第4课 Go 工程化实践</h2><h3 id="4-1-工程项目结构"><a href="#4-1-工程项目结构" class="headerlink" title="4.1 工程项目结构"></a>4.1 工程项目结构</h3><h4 id="4-1-1-Standard-Go-Project-Layout"><a href="#4-1-1-Standard-Go-Project-Layout" class="headerlink" title="4.1.1 Standard Go Project Layout"></a>4.1.1 Standard Go Project Layout</h4><p><a href="https://github.com/golang-standards/project-layout/blob/master/README_zh.md">https://github.com/golang-standards/project-layout/blob/master/README_zh.md</a></p><p>如果你尝试学习 Go，或者你正在为自己建立一个 PoC 或一个玩具项目，这个项目布局是没啥必要的。从一些非常简单的事情开始(一个 main.go 文件绰绰有余)。当有更多的人参与这个项目时，你将需要更多的结构，包括需要一个 toolkit 来方便生成项目的模板，尽可能大家统一的工程目录布局。</p><ol><li><p>/cmd</p><p> 本项目的主干。</p><p> 每个应用程序的目录名应该与你想要的可执行文件的名称相匹配(例如，/cmd/myapp)。</p><p> 不要在这个目录中放置太多代码。如果你认为代码可以导入并在其他项目中使用，那么它应该位于 /pkg 目录中。如果代码不是可重用的，或者你不希望其他人重用它，请将该代码放到 /internal 目录中。</p></li><li><p>/internal</p><p> 私有应用程序和库代码。这是你不希望其他人在其应用程序或库中导入代码。请注意，这个布局模式是由 Go 编译器本身执行的。有关更多细节，请参阅Go 1.4 <a href="https://golang.org/doc/go1.4#internalpackages">release notes</a>。注意，你并不局限于顶级 internal 目录。在项目树的任何级别上都可以有多个内部目录。</p><p> 你可以选择向 internal 包中添加一些额外的结构，以分隔共享和非共享的内部代码。这不是必需的(特别是对于较小的项目)，但是最好有有可视化的线索来显示预期的包的用途。你的实际应用程序代码可以放在 /internal/app 目录下(例如 /internal/app/myapp)，这些应用程序共享的代码可以放在 /internal/pkg 目录下(例如 /internal/pkg/myprivlib)。</p><p> 因为我们习惯把相关的服务，比如账号服务，内部有 rpc、job、admin 等，相关的服务整合一起后，需要区分 app。单一的服务，可以去掉 /internal/myapp。</p></li><li><p>/pkg</p><p>  外部应用程序可以使用的库代码(例如 /pkg/mypubliclib)。其他项目会导入这些库，所以在这里放东西之前要三思:-)注意，internal 目录是确保私有包不可导入的更好方法，因为它是由 Go 强制执行的。/pkg 目录仍然是一种很好的方式，可以显式地表示该目录中的代码对于其他人来说是安全使用的好方法。</p><p> /pkg 目录内，可以参考 go 标准库的组织方式，按照功能分类。/internla/pkg 一般用于项目内的 跨多个应用的公共共享代码，但其作用域仅在单个项目工程内。</p><p> 由 Travis Jeffery  撰写的 <a href="https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/">I’ll take pkg over internal</a> 博客文章提供了 pkg 和 internal 目录的一个很好的概述，以及什么时候使用它们是有意义的。</p><p> 当根目录包含大量非 Go 组件和目录时，这也是一种将 Go 代码分组到一个位置的方法，这使得运行各种 Go 工具变得更加容易组织。</p></li></ol><h4 id="4-1-2-Kit-Project-Layout"><a href="#4-1-2-Kit-Project-Layout" class="headerlink" title="4.1.2 Kit Project Layout"></a>4.1.2 Kit Project Layout</h4><p>每个公司都应当为不同的微服务建立一个统一的 kit 工具包项目(基础库/框架) 和 app 项目。</p><p>基础库 kit 为独立项目，公司级建议只有一个，按照功能目录来拆分会带来不少的管理工作，因此建议合并整合。</p><p>by <a href="https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html">Package Oriented Design</a></p><p>“To this end, the Kit project is not allowed to have a vendor folder. If any of packages are dependent on 3rd party packages, they must always build against the latest version of those dependences.”</p><p>kit 项目必须具备的特点:</p><ul><li>统一</li><li>标准库方式布局</li><li>高度抽象</li><li>支持插件</li></ul><h4 id="4-1-3-Service-Application-Project-Layout"><a href="#4-1-3-Service-Application-Project-Layout" class="headerlink" title="4.1.3 Service Application Project Layout"></a>4.1.3 Service Application Project Layout</h4><ol><li><p>/api</p><p> API 协议定义目录，xxapi.proto protobuf 文件，以及生成的 go 文件。我们通常把 api 文档直接在 proto 文件中描述。</p></li><li><p>/configs</p><p> 配置文件模板或默认配置。</p></li><li><p>/test</p><p> 额外的外部测试应用程序和测试数据。你可以随时根据需求构造 /test 目录。对于较大的项目，有一个数据子目录是有意义的。例如，你可以使用 /test/data 或 /test/testdata (如果你需要忽略目录中的内容)。请注意，Go 还会忽略以“.”或“_”开头的目录或文件，因此在如何命名测试数据目录方面有更大的灵活性。</p></li><li><p>不应该包含：/src</p><p> 有些 Go 项目确实有一个 src 文件夹，但这通常发生在开发人员有 Java 背景，在那里它是一种常见的模式。不要将项目级别 src 目录与 Go 用于其工作空间的 src 目录。</p></li></ol><h4 id="4-1-4-Service-Application-Project"><a href="#4-1-4-Service-Application-Project" class="headerlink" title="4.1.4 Service Application Project"></a>4.1.4 Service Application Project</h4><p>一个 gitlab 的 project 里可以放置多个微服务的app(类似 monorepo)。也可以按照 gitlab 的 group 里建立多个 project，每个 project 对应一个 app。</p><ul><li>多 app 的方式，app 目录内的每个微服务按照自己的全局唯一名称，比如 “account.service.vip” 来建立目录，如: account/vip/*。</li><li>和 app 平级的目录 pkg 存放业务有关的公共库（非基础框架库）。如果应用不希望导出这些目录，可以放置到 myapp/internal/pkg 中。</li></ul><p>微服务中的 app 服务类型分为4类：interface、service、job、admin。</p><ul><li>interface: 对外的 BFF 服务，接受来自用户的请求，比如暴露了 HTTP/gRPC 接口。</li><li>service: 对内的微服务，仅接受来自内部其他服务或者网关的请求，比如暴露了gRPC 接口只对内服务。</li><li>admin：区别于 service，更多是面向运营测的服务，通常数据权限更高，隔离带来更好的代码级别安全。</li><li>job: 流式任务处理的服务，上游一般依赖 message broker。</li><li>task: 定时任务，类似 cronjob，部署到 task 托管平台中。</li></ul><blockquote><p>cmd 应用目录负责程序的: 启动、关闭、配置初始化等。</p></blockquote><h4 id="4-1-5-Service-Application-Project-v1"><a href="#4-1-5-Service-Application-Project-v1" class="headerlink" title="4.1.5 Service Application Project - v1"></a>4.1.5 Service Application Project - v1</h4><p><img src="/images/《Go进阶训练营》学习笔记/ServiceApplicationProject-v1-structure.png" alt="ServiceApplicationProject-v1-structure"></p><p><strong>我们老的布局</strong> ，app 目录下有 api、cmd、configs、internal 目录，目录里一般还会放置 README、CHANGELOG、OWNERS。</p><ul><li>api: 放置 API 定义(protobuf)，以及对应的生成的 client 代码，基于 pb 生成的 swagger.json。</li><li>configs: 放服务所需要的配置文件，比如database.yaml、redis.yaml、application.yaml。</li><li>internal: 是为了避免有同业务下有人跨目录引用了内部的 model、dao 等内部 struct。</li><li>server: 放置 HTTP/gRPC 的路由代码，以及 DTO 转换的代码。</li></ul><blockquote><p>DTO(Data Transfer Object)：数据传输对象，这个概念来源于J2EE 的设计模式。但在这里，泛指用于展示层/API 层与服务层(业务逻辑层)之间的数据传输对象。</p></blockquote><p><img src="/images/《Go进阶训练营》学习笔记/ServiceApplicationProject-v1-dependence.png" alt="ServiceApplicationProject-v1-dependence"></p><p>项目的依赖路径为: model -&gt; dao -&gt; service -&gt; api，model struct 串联各个层，直到 api 需要做 DTO 对象转换。</p><ul><li>model: 放对应“存储层”的结构体，是对存储的一一隐射。</li><li>dao: 数据读写层，数据库和缓存全部在这层统一处理，包括 cache miss 处理。</li><li>service: 组合各种数据访问来构建业务逻辑。</li><li>server: 依赖 proto 定义的服务作为入参，提供快捷的启动服务全局方法。</li><li>api: 定义了 API proto 文件，和生成的 stub 代码，它生成的 interface，其实现者在 service 中。</li></ul><p>service 的方法签名因为实现了 API 的 接口定义，DTO 直接在业务逻辑层直接使用了，更有 dao 直接使用，最简化代码。</p><p>DO(Domain Object): 领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。缺乏 DTO -&gt; DO 的对象转换。</p><h4 id="4-1-6-Service-Application-Project-v2"><a href="#4-1-6-Service-Application-Project-v2" class="headerlink" title="4.1.6 Service Application Project - v2"></a>4.1.6 Service Application Project - v2</h4><p><img src="/images/《Go进阶训练营》学习笔记/ServiceApplicationProject-v2-structure.png" alt="ServiceApplicationProject-v2-structure"></p><p>app 目录下有 api、cmd、configs、internal 目录，目录里一般还会放置 README、CHANGELOG、OWNERS。</p><ul><li><p>internal: 是为了避免有同业务下有人跨目录引用了内部的 biz、data、service 等内部 struct。</p><ul><li>biz: 业务逻辑的组装层，类似 DDD 的 domain 层，data 类似 DDD 的 repo，repo 接口在这里定义，使用依赖倒置的原则。</li><li>data: 业务数据访问，包含 cache、db 等封装，实现了 biz 的 repo 接口。我们可能会把 data 与 dao 混淆在一起，data 偏重业务的含义，它所要做的是将领域对象重新拿出来，我们去掉了 DDD 的 infra层。</li><li>service: 实现了 api 定义的服务层，类似 DDD 的 application 层，处理 DTO 到 biz 领域实体的转换(DTO -&gt; DO)，同时协同各类 biz 交互，但是不应处理复杂逻辑。</li></ul></li></ul><p>PO(Persistent Object): 持久化对象，它跟持久层（通常是关系型数据库）的数据结构形成一一对应的映射关系，如果持久层是关系型数据库，那么数据表中的每个字段（或若干个）就对应 PO 的一个（或若干个）属性。</p><p><a href="https://github.com/facebook/ent">https://github.com/facebook/ent</a></p><h4 id="4-1-7-Lifecycle"><a href="#4-1-7-Lifecycle" class="headerlink" title="4.1.7 Lifecycle"></a>4.1.7 Lifecycle</h4><p>Lifecycle 需要考虑服务应用的对象初始化以及生命周期的管理，所有 HTTP/gRPC 依赖的前置资源初始化，包括 data、biz、service，之后再启动监听服务。我们使用 <a href="https://github.com/google/wire">https://github.com/google/wire</a> ，来管理所有资源的依赖注入。为何需要依赖注入？</p><p><img src="/images/《Go进阶训练营》学习笔记/依赖注入.png" alt="依赖注入"></p><p>核心是为了：</p><ol><li>方便测试；</li><li>单次初始化和复用；</li></ol><h4 id="4-1-8-Wire"><a href="#4-1-8-Wire" class="headerlink" title="4.1.8 Wire"></a>4.1.8 Wire</h4><p><a href="https://blog.golang.org/wire">https://blog.golang.org/wire</a></p><p>手撸资源的初始化和关闭是非常繁琐，容易出错的。上面提到我们使用依赖注入的思路 DI，结合 google wire，静态的 go generate 生成静态的代码，可以在很方便诊断和查看，不是在运行时利用 reflection 实现。</p><h3 id="4-2-API-设计"><a href="#4-2-API-设计" class="headerlink" title="4.2 API 设计"></a>4.2 API 设计</h3><h4 id="4-2-1-gRPC"><a href="#4-2-1-gRPC" class="headerlink" title="4.2.1 gRPC"></a>4.2.1 gRPC</h4><h4 id="4-2-2-API-Project"><a href="#4-2-2-API-Project" class="headerlink" title="4.2.2 API Project"></a>4.2.2 API Project</h4><p><a href="https://github.com/googleapis/googleapis">https://github.com/googleapis/googleapis</a><br><a href="https://github.com/envoyproxy/data-plane-api">https://github.com/envoyproxy/data-plane-api</a><br><a href="https://github.com/istio/api">https://github.com/istio/api</a></p><p>为了统一检索和规范 API，我们内部建立了一个统一的 bapis 仓库，整合所有对内对外 API。</p><ul><li>API 仓库，方便跨部门协作。</li><li>版本管理，基于 git 控制。</li><li>规范化检查，API lint。</li><li>API design review，变更 diff。</li><li>权限管理，目录 OWNERS。</li></ul><h4 id="4-2-3-API-Project-Layout"><a href="#4-2-3-API-Project-Layout" class="headerlink" title="4.2.3 API Project Layout"></a>4.2.3 API Project Layout</h4><p><img src="/images/《Go进阶训练营》学习笔记/APIProjectLayout.png" alt="APIProjectLayout"></p><p>项目中定义 proto，以 api 为包名根目录：</p><p><img src="/images/《Go进阶训练营》学习笔记/APIProjectLayout-project.png" alt="APIProjectLayout-project"></p><p>在统一仓库中管理 proto ，以仓库为包名根目录:</p><p><img src="/images/《Go进阶训练营》学习笔记/APIProjectLayout-repo.png" alt="APIProjectLayout-repo"></p><h4 id="4-2-4-API-Compatibility"><a href="#4-2-4-API-Compatibility" class="headerlink" title="4.2.4 API Compatibility"></a>4.2.4 API Compatibility</h4><p>向后兼容(非破坏性)的修改</p><ul><li>给 API 服务定义添加 API 接口<blockquote><p> 从协议的角度来看，这始终是安全的。</p></blockquote></li><li>给请求消息添加字段<blockquote><p>只要客户端在新版和旧版中对该字段的处理不保持一致，添加请求字段就是兼容的。</p></blockquote></li><li>给响应消息添加字段<blockquote><p>在不改变其他响应字段的行为的前提下，非资源（例如，ListBooksResponse）的响应消息可以扩展而不必破坏客户端的兼容性。即使会引入冗余，先前在响应中填充的任何字段应继续使用相同的语义填充。</p></blockquote></li></ul><p>向后不兼容(破坏性)的修改</p><ul><li>删除或重命名服务，字段，方法或枚举值<blockquote><p>从根本上说，如果客户端代码可以引用某些东西，那么删除或重命名它都是不兼容的变化，这时必须修改major 版本号。</p></blockquote></li><li>修改字段的类型<blockquote><p>即使新类型是传输格式兼容的，这也可能会导致客户端库生成的代码发生变化，因此必须增加major版本号。 对于编译型静态语言来说，会容易引入编译错误。</p></blockquote></li><li>修改现有请求的可见行为<blockquote><p>客户端通常依赖于 API 行为和语义，即使这样的行为没有被明确支持或记录。 因此，在大多数情况下，修改 API 数据的行为或语义将被消费者视为是破坏性的。如果行为没有加密隐藏，您应该假设用户已经发现它，并将依赖于它。</p></blockquote></li><li>给资源消息添加 读取/写入 字段</li></ul><h4 id="4-2-5-API-Naming-Conventions"><a href="#4-2-5-API-Naming-Conventions" class="headerlink" title="4.2.5 API Naming Conventions"></a>4.2.5 API Naming Conventions</h4><p>包名为应用的标识(APP_ID)，用于生成 gRPC 请求路径，或者 proto 之间进行引用 Message。文件中声明的包名称应该与产品和服务名称保持一致。带有版本的 API 的软件包名称必须以此版本结尾。</p><blockquote><p>my.package.v1，为 API 目录，定义service相关接口，用于提供业务使用。</p></blockquote><pre class="line-numbers language-proto3" data-language="proto3"><code class="language-proto3">// RequestURL: /&lt;package_name&gt;.&lt;version&gt;.&lt;service_name&gt;/{method}package &lt;package_name&gt;.&lt;version&gt;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/images/《Go进阶训练营》学习笔记/示例api接口文档.png" alt="示例api接口文档"></p><p><img src="/images/《Go进阶训练营》学习笔记/示例api接口定义.png" alt="示例api接口定义"></p><h4 id="4-2-6-API-Primitive-Fields"><a href="#4-2-6-API-Primitive-Fields" class="headerlink" title="4.2.6 API Primitive Fields"></a>4.2.6 API Primitive Fields</h4><p>gRPC 默认使用 Protobuf v3 格式，因为去除了 required 和 optional 关键字，默认全部都是 optional 字段。如果没有赋值的字段，默认会基础类型字段的默认值，比如 0 或者 “”。</p><p>Protobuf v3 中，建议使用：<a href="https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/wrappers.proto">https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/wrappers.proto</a></p><p>Warpper 类型的字段，即包装一个 message，使用时变为指针。</p><blockquote><p>Protobuf 作为强 schema 的描述文件，也可以方便扩展，是不是用于配置文件定义也可以？</p></blockquote><h4 id="4-2-7-API-Errors"><a href="#4-2-7-API-Errors" class="headerlink" title="4.2.7 API Errors"></a>4.2.7 API Errors</h4><p><img src="/images/《Go进阶训练营》学习笔记/gRPC标准错误.png" alt="gRPC标准错误"></p><p>使用一小组标准错误配合大量资源</p><ul><li>例如，服务器没有定义不同类型的“找不到”错误，而是使用一个标准 google.rpc.Code.NOT_FOUND 错误代码并告诉客户端找不到哪个特定资源。状态空间变小降低了文档的复杂性，在客户端库中提供了更好的惯用映射，并降低了客户端的逻辑复杂性，同时不限制是否包含可操作信息(<a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/error_details.proto">/google/rpc/error_details</a>)。</li></ul><p>错误传播</p><ul><li><p>如果您的 API 服务依赖于其他服务，则不应盲目地将这些服务的错误传播到您的客户端。在翻译错误时，我们建议执行以下操作：</p><ul><li>隐藏实现详细信息和机密信息。</li><li>调整负责该错误的一方。例如，从另一个服务接收 INVALID_ARGUMENT 错误的服务器应该将 INTERNAL 传播给它自己的调用者。</li></ul></li></ul><p>全局错误码</p><ul><li>全局错误码，是松散、易被破坏契约的，基于我们上述讨论的，在每个服务传播错误的时候，做一次翻译，这样保证每个服务 + 错误枚举，应该是唯一的，而且在 proto 定义中是可以写出来文档的。</li></ul><p><img src="/images/《Go进阶训练营》学习笔记/全局错误码一.png" alt="全局错误码一"></p><p><img src="/images/《Go进阶训练营》学习笔记/全局错误码二.png" alt="全局错误码二"></p><blockquote><p>Status.details 中存放的就是 ErrorInfo 。</p></blockquote><h4 id="4-2-8-API-Design"><a href="#4-2-8-API-Design" class="headerlink" title="4.2.8 API Design"></a>4.2.8 API Design</h4><p><a href="https://netflixtechblog.com/practical-api-design-at-netflix-part-1-using-protobuf-fieldmask-35cfdc606518">Practical API Design at Netflix, Part 1: Using Protobuf FieldMask</a></p><p><a href="https://dataintegration.info/practical-api-design-at-netflix-part-2-protobuf-fieldmask-for-mutation-operations">Practical API Design at Netflix, Part 2: Protobuf FieldMask for Mutation Operations</a></p><p>FieldMask 部分更新的方案:</p><ul><li>客户端可以执行需要更新的字段信息。</li><li>空 FieldMask 默认应用到 “所有字段”。</li></ul><h3 id="4-3-配置管理"><a href="#4-3-配置管理" class="headerlink" title="4.3 配置管理"></a>4.3 配置管理</h3><h4 id="4-3-1-Configuration"><a href="#4-3-1-Configuration" class="headerlink" title="4.3.1 Configuration"></a>4.3.1 Configuration</h4><ul><li>环境变量(配置)<br>  Region、Zone、Cluster、Environment、Color、Discovery、AppID、Host，等之类的环境信息，都是通过在线运行时平台打入到容器或者物理机，供 kit 库读取使用。</li><li>静态配置<br>  资源需要初始化的配置信息，比如 http/gRPC server、redis、mysql 等，这类资源在线变更配置的风险非常大，我通常不鼓励 on-the-fly 变更，很可能会导致业务出现不可预期的事故，变更静态配置和发布 binary app 没有区别，应该走一次迭代发布的流程。</li><li>动态配置<br>  应用程序可能需要一些在线的开关，来控制业务的一些简单策略，会频繁的调整和使用，我们把这类是基础类型(int, bool)等配置，用于可以动态变更业务流的收归一起，同时可以考虑结合类似 <a href="https://pkg.go.dev/expvar">https://pkg.go.dev/expvar</a> 来结合使用。</li><li>全局配置<br>  通常，我们依赖的各类组件、中间件都有大量的默认配置或者指定配置，在各个项目里大量拷贝复制，容易出现意外，所以我们使用全局配置模板来定制化常用的组件，然后再特化的应用里进行局部替换。</li></ul><h4 id="4-3-2-Functional-options"><a href="#4-3-2-Functional-options" class="headerlink" title="4.3.2 Functional options"></a>4.3.2 Functional options</h4><ol><li><p>灵活的设置选项</p><p> <a href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis">Functional options for friendly APIs</a> — Dave Cheney</p> <pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// DialOption specifies an option for dialing a Redis server.</span><span class="token keyword">type</span> DialOption <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token operator">*</span>dialOptions<span class="token punctuation">)</span><span class="token comment">// Dial connects to the Redis server at the given network and</span><span class="token comment">// address using the specified options.</span><span class="token keyword">func</span> <span class="token function">Dial</span><span class="token punctuation">(</span>network<span class="token punctuation">,</span> address <span class="token builtin">string</span><span class="token punctuation">,</span> options <span class="token operator">...</span>DialOption<span class="token punctuation">)</span> <span class="token punctuation">(</span>Conn<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    do <span class="token operator">:=</span> dialOptions<span class="token punctuation">{</span>        dial<span class="token punctuation">:</span> net<span class="token punctuation">.</span>Dial<span class="token punctuation">,</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> option <span class="token operator">:=</span> <span class="token keyword">range</span> options <span class="token punctuation">{</span>        <span class="token function">option</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>do<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment">// ...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>临时改变配置的优雅做法</p><p> <a href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html">Self-referential functions and the design of options</a> — Rob Pike</p> <pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> option <span class="token keyword">func</span><span class="token punctuation">(</span>f <span class="token operator">*</span>Foo<span class="token punctuation">)</span> option<span class="token comment">// Verbosity sets Foo's verbosity level to v.</span><span class="token keyword">func</span> <span class="token function">Verbosity</span><span class="token punctuation">(</span>v <span class="token builtin">int</span><span class="token punctuation">)</span> option <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>f <span class="token operator">*</span>Foo<span class="token punctuation">)</span> option <span class="token punctuation">{</span>        prev <span class="token operator">:=</span> f<span class="token punctuation">.</span>verbosity        f<span class="token punctuation">.</span>verbosity <span class="token operator">=</span> v        <span class="token keyword">return</span> <span class="token function">Verbosity</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">DoSomethingVerbosely</span><span class="token punctuation">(</span>foo <span class="token operator">*</span>Foo<span class="token punctuation">,</span> verbosity <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// Could combine the next two lines,</span>    <span class="token comment">// with some loss of readability.</span>    prev <span class="token operator">:=</span> foo<span class="token punctuation">.</span><span class="token function">Option</span><span class="token punctuation">(</span>pkg<span class="token punctuation">.</span><span class="token function">Verbosity</span><span class="token punctuation">(</span>verbosity<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">defer</span> foo<span class="token punctuation">.</span><span class="token function">Option</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span>    <span class="token comment">// ... do some stuff with foo under high verbosity.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>支持使用者扩展选项</p><p> 在 gRPC 中任何服务的实现都会接收一个 <code>grpc.CallOption</code> 类型的参数：</p> <pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> GreeterClient <span class="token keyword">interface</span> <span class="token punctuation">{</span>    <span class="token function">SayHello</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> in <span class="token operator">*</span>HelloRequest<span class="token punctuation">,</span> opts <span class="token operator">...</span>grpc<span class="token punctuation">.</span>CallOption<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>HelloReply<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> <code>grpc.CallOption</code> 的实现如下：</p> <pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// CallOption configures a Call before it starts or extracts information from</span><span class="token comment">// a Call after it completes.</span><span class="token keyword">type</span> CallOption <span class="token keyword">interface</span> <span class="token punctuation">{</span>    <span class="token comment">// before is called before the call is sent to any server.  If before</span>    <span class="token comment">// returns a non-nil error, the RPC fails with that error.</span>    <span class="token function">before</span><span class="token punctuation">(</span><span class="token operator">*</span>callInfo<span class="token punctuation">)</span> <span class="token builtin">error</span>    <span class="token comment">// after is called after the call has completed.  after cannot return an</span>    <span class="token comment">// error, so any failures should be reported via output parameters.</span>    <span class="token function">after</span><span class="token punctuation">(</span><span class="token operator">*</span>callInfo<span class="token punctuation">,</span> <span class="token operator">*</span>csAttempt<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 为了支持使用者扩展这个选项，gRPC 提供了一个 <code>EmptyCallOption</code> ，它实现了 <code>CallOption</code> 接口的一个空实现。</p> <pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// EmptyCallOption does not alter the Call configuration.</span><span class="token comment">// It can be embedded in another structure to carry satellite data for use</span><span class="token comment">// by interceptors.</span><span class="token keyword">type</span> EmptyCallOption <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>EmptyCallOption<span class="token punctuation">)</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token operator">*</span>callInfo<span class="token punctuation">)</span> <span class="token builtin">error</span>      <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token boolean">nil</span> <span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>EmptyCallOption<span class="token punctuation">)</span> <span class="token function">after</span><span class="token punctuation">(</span><span class="token operator">*</span>callInfo<span class="token punctuation">,</span> <span class="token operator">*</span>csAttempt<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 任何想要扩展选项的客户端都可以自定义结构体并包含 <code>EmptyCallOption</code> 来完成扩展：</p> <pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// TimeoutCallOption timeout option.</span><span class="token keyword">type</span> TimeoutCallOption <span class="token keyword">struct</span> <span class="token punctuation">{</span>    grpc<span class="token punctuation">.</span>EmptyCallOption    Timeout time<span class="token punctuation">.</span>Duration<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 实际的完整的使用实例可以参考：<a href="https://github.com/grpc-ecosystem/go-grpc-middleware/blob/master/retry/examples_test.go">https://github.com/grpc-ecosystem/go-grpc-middleware/blob/master/retry/examples_test.go</a></p></li></ol><h4 id="4-3-3-Hybrid-APIs"><a href="#4-3-3-Hybrid-APIs" class="headerlink" title="4.3.3 Hybrid APIs"></a>4.3.3 Hybrid APIs</h4><p>使用了 Functional options 后：</p><ol><li>“JSON/YAML 配置怎么加载，无法映射 DialOption 啊！”<br>2。 “嗯，不依赖配置的走 options，配置加载走config”</li></ol><p>一定需要维护两套 API 么？</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Dial connects to the Redis server at the given network and</span><span class="token comment">// address using the specified options.</span><span class="token keyword">func</span> <span class="token function">Dial</span><span class="token punctuation">(</span>network<span class="token punctuation">,</span> address <span class="token builtin">string</span><span class="token punctuation">,</span> options <span class="token operator">...</span>DialOption<span class="token punctuation">)</span> <span class="token punctuation">(</span>Conn<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token comment">// NewConn new a redis conn.</span><span class="token keyword">func</span> <span class="token function">NewConn</span><span class="token punctuation">(</span>c <span class="token operator">*</span>Config<span class="token punctuation">)</span> <span class="token punctuation">(</span>cn Conn<span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-3-4-Configuration-amp-APIs"><a href="#4-3-4-Configuration-amp-APIs" class="headerlink" title="4.3.4 Configuration &amp; APIs"></a>4.3.4 Configuration &amp; APIs</h4><blockquote><p>“For example, both your infrastructure and interface might use plain JSON. However, avoid tight coupling between the data format you use as the interface and the data format you use internally. For example, you may use a data structure internally that contains the data structure consumed from configuration. The internal data structure might also contain completely implementation-specific data that never needs to be surfaced outside of the system.”</p><p>— the-site-reliability-workbook 2</p></blockquote><p>正确做法：</p><ol><li><p>仅保留 options API;</p> <pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Dial connects to the Redis server at the given network and</span><span class="token comment">// address using the specified options.</span><span class="token keyword">func</span> <span class="token function">Dial</span><span class="token punctuation">(</span>network<span class="token punctuation">,</span> address <span class="token builtin">string</span><span class="token punctuation">,</span> options <span class="token operator">...</span>DialOption<span class="token punctuation">)</span> <span class="token punctuation">(</span>Conn<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>config file 和 options struct 解耦;</p><p> 加载配置文件得到一个内存中的 Config 配置对象：</p><blockquote><p>可以使用 protobuf 来定义和生成 Config 这个配置对象。</p></blockquote> <pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// instead use load yaml file.</span>c <span class="token operator">:=</span> <span class="token operator">&amp;</span>Config<span class="token punctuation">{</span>    Network<span class="token punctuation">:</span> <span class="token string">"tcp"</span><span class="token punctuation">,</span>    Addr<span class="token punctuation">:</span> <span class="token string">"127.0.0.1:3389"</span><span class="token punctuation">,</span>    Database<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    Password<span class="token punctuation">:</span> <span class="token string">"Hello"</span><span class="token punctuation">,</span>    ReadTimeout<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">,</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 提供配置转换为 Functional options 的方法：</p> <pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Options apply config to options.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Config<span class="token punctuation">)</span> <span class="token function">Options</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>redis<span class="token punctuation">.</span>Options <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>redis<span class="token punctuation">.</span>Options<span class="token punctuation">{</span>        redis<span class="token punctuation">.</span><span class="token function">DialDatabase</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>Database<span class="token punctuation">)</span><span class="token punctuation">,</span>        redis<span class="token punctuation">.</span><span class="token function">DialPassword</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>Password<span class="token punctuation">)</span><span class="token punctuation">,</span>        redis<span class="token punctuation">.</span><span class="token function">DialReadTimeout</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>ReadTimeout<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 最后使用转换后的 Functional options 来调用 options API：</p> <pre class="line-numbers language-go" data-language="go"><code class="language-go">r<span class="token punctuation">,</span> err <span class="token operator">:=</span> redis<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>Network<span class="token punctuation">,</span> c<span class="token punctuation">.</span>Address<span class="token punctuation">,</span> <span class="token function">Options</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token operator">...</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置工具的实践：</p></li></ol><ul><li>语义验证</li><li>高亮</li><li>Lint</li><li>格式化</li></ul><blockquote><p>最后B站实际使用的是 YAML + Protobuf 这种方式。</p></blockquote><h4 id="4-3-5-Configuration-Best-Pratice"><a href="#4-3-5-Configuration-Best-Pratice" class="headerlink" title="4.3.5 Configuration Best Pratice"></a>4.3.5 Configuration Best Pratice</h4><p>代码更改系统功能是一个冗长且复杂的过程，往往还涉及Review、测试等流程，但更改单个配置选项可能会对功能产生重大影响，通常配置还未经测试。配置的目标：</p><ul><li>避免复杂</li><li>多样的配置</li><li>简单化努力</li><li>以基础设施 -&gt; 面向用户进行转变</li><li>配置的必选项和可选项</li><li>配置的防御编程</li><li>权限和变更跟踪</li><li>配置的版本和应用对齐</li><li>安全的配置变更：逐步部署、回滚更改、自动回滚</li></ul><h3 id="4-4-包管理"><a href="#4-4-包管理" class="headerlink" title="4.4 包管理"></a>4.4 包管理</h3><p><a href="https://github.com/gomods/athens">https://github.com/gomods/athens</a><br><a href="https://goproxy.cn">https://goproxy.cn</a></p><p><a href="https://blog.golang.org/modules2019">https://blog.golang.org/modules2019</a><br><a href="https://blog.golang.org/using-go-modules">https://blog.golang.org/using-go-modules</a><br><a href="https://blog.golang.org/migrating-to-go-modules">https://blog.golang.org/migrating-to-go-modules</a><br><a href="https://blog.golang.org/module-mirror-launch">https://blog.golang.org/module-mirror-launch</a><br><a href="https://blog.golang.org/publishing-go-modules">https://blog.golang.org/publishing-go-modules</a><br><a href="https://blog.golang.org/v2-go-modules">https://blog.golang.org/v2-go-modules</a><br><a href="https://blog.golang.org/module-compatibility">https://blog.golang.org/module-compatibility</a></p><h3 id="4-5-测试"><a href="#4-5-测试" class="headerlink" title="4.5 测试"></a>4.5 测试</h3><h4 id="4-5-1-Unittest"><a href="#4-5-1-Unittest" class="headerlink" title="4.5.1 Unittest"></a>4.5.1 Unittest</h4><p><img src="/images/《Go进阶训练营》学习笔记/单元测试.png" alt="单元测试"></p><ul><li>小型测试带来优秀的代码质量、良好的异常处理、优雅的错误报告；大中型测试会带来整体产品质量和数据验证。<blockquote><p>单元测试。</p></blockquote></li><li>不同类型的项目，对测试的需求不同，总体上有一个经验法则，即70/20/10原则：70%是小型测试，20%是中型测试，10%是大型测试。<blockquote><p>集成测试。</p></blockquote></li><li>如果一个项目是面向用户的，拥有较高的集成度，或者用户接口比较复杂，他们就应该有更多的中型和大型测试；如果是基础平台或者面向数据的项目，例如索引或网络爬虫，则最好有大量的小型测试，中型测试和大型测试的数量要求会少很多。<blockquote><p>E2E，end-to-end 测试，端测试。</p></blockquote></li></ul><blockquote><p>kit 库，基础库需要写的比较多的单元测试。</p><p>中间件要写单元测试和 chaos 测试。</p><p>大型测试直接测试接口。</p></blockquote><p>“自动化实现的，用于验证一个单独函数或独立功能模块的代码是否按照预期工作，着重于典型功能性问题、数据损坏、错误条件和大小差一错误（译注：大小差一(off-by-one)错误是一类常见的程序设计错误）等方面的验证” - 《Google软件测试之道》</p><p>单元测试的基本要求：</p><ul><li>快速</li><li>环境一致</li><li>任意顺序</li><li>并行</li></ul><p>基于 docker-compose 实现跨平台跨语言环境的容器依赖管理方案，以解决运行 unittest 场景下的(mysql, redis, mc)容器依赖问题:</p><ul><li>本地安装 Docker。</li><li>无侵入式的环境初始化。</li><li>快速重置环境。</li><li>随时随地运行(不依赖外部服务)。</li><li>语义式 API 声明资源。</li><li>真实外部依赖，而非 in-process 模拟。</li></ul><p>细节：</p><ul><li>正确的对容器内服务进行健康检测，避免 unittest 启动时候资源还未 ready。</li><li>应该交由 app 自己来初始化数据，比如 db 的scheme，初始的 sql 数据等，为了满足测试的一致性，在每次结束后，都会销毁容器。</li><li>在单元测试开始前，导入封装好的 testing 库，方便启动和销毁容器。</li><li>对于 service 的单元测试，使用 gomock 等库把 dao mock 掉，所以在设计包的时候，应该面向抽象编程。</li><li>在本地执行依赖 Docker，在 CI 环境里执行Unittest，需要考虑在物理机里的 Docker 网络，或者在 Docker 里再次启动一个 Docker。</li></ul><p>利用 go 官方提供的: Subtests  + Gomock 完成整个单元测试。</p><p><a href="https://go.dev/blog/subtests">Using Subtests and Sub-benchmarks</a></p><ul><li><p>/api</p><p>  比较适合进行集成测试，直接测试 API，使用 API 测试框架(例如: yapi)，维护大量业务测试 case。</p></li><li><p>/data</p><p>  docker compose 把底层基础设施真实模拟，因此可以去掉 infra 的抽象层。</p></li><li><p>/biz</p><p>  依赖  repo、rpc client，利用 gomock 模拟 interface 的实现，来进行业务单元测试。</p></li><li><p>/service</p><p>  依赖 biz 的实现，构建 biz 的实现类传入，进行单元测试。</p></li></ul><blockquote><p>基于 git branch 进行 feature 开发，本地进行 unittest，之后提交 gitlab merge request 进行 CI 的单元测试，基于 feature branch 进行构建，完成功能测试，之后合并 master，进行集成测试，上线后进行回归测试。</p></blockquote><p><a href="https://www.ardanlabs.com/blog/2019/03/integration-testing-in-go-executing-tests-with-docker.html">Integration Testing in Go: Part I - Executing Tests with Docker</a></p><p><a href="https://www.ardanlabs.com/blog/2019/10/integration-testing-in-go-set-up-and-writing-tests.html">Integration Testing in Go: Part II - Set-up and Writing Tests</a></p><p>Without integration tests, it’s difficult to trust the end-to-end operation of a web service.</p><h3 id="4-6-References"><a href="#4-6-References" class="headerlink" title="4.6 References"></a>4.6 References</h3><p><a href="https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html">https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html</a><br><a href="https://www.ardanlabs.com/blog/2017/02/design-philosophy-on-packaging.html">https://www.ardanlabs.com/blog/2017/02/design-philosophy-on-packaging.html</a><br><a href="https://github.com/golang-standards/project-layout">https://github.com/golang-standards/project-layout</a><br><a href="https://github.com/golang-standards/project-layout/blob/master/README_zh.md">https://github.com/golang-standards/project-layout/blob/master/README_zh.md</a><br><a href="https://www.cnblogs.com/zxf330301/p/6534643.html">https://www.cnblogs.com/zxf330301/p/6534643.html</a><br><a href="https://blog.csdn.net/k6T9Q8XKs6iIkZPPIFq/article/details/109192475?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160561008419724839224387%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=160561008419724839224387&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-6-109192475.first_rank_ecpm_v3_pc_rank_v2&amp;utm_term=阿里技术专家详解DDD系列&amp;spm=1018.2118.3001.4449">https://blog.csdn.net/k6T9Q8XKs6iIkZPPIFq/article/details/109192475?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160561008419724839224387%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=160561008419724839224387&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-6-109192475.first_rank_ecpm_v3_pc_rank_v2&amp;utm_term=阿里技术专家详解DDD系列&amp;spm=1018.2118.3001.4449</a><br><a href="https://blog.csdn.net/chikuai9995/article/details/100723540?biz_id=102&amp;utm_term=阿里技术专家详解DDD系列&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-100723540&amp;spm=1018.2118.3001.4449">https://blog.csdn.net/chikuai9995/article/details/100723540?biz_id=102&amp;utm_term=阿里技术专家详解DDD系列&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-100723540&amp;spm=1018.2118.3001.4449</a><br><a href="https://blog.csdn.net/Taobaojishu/article/details/101444324?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160561008419724838528569%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=160561008419724838528569&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-101444324.first_rank_ecpm_v3_pc_rank_v2&amp;utm_term=阿里技术专家详解DDD系列&amp;spm=1018.2118.3001.4449">https://blog.csdn.net/Taobaojishu/article/details/101444324?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160561008419724838528569%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=160561008419724838528569&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-101444324.first_rank_ecpm_v3_pc_rank_v2&amp;utm_term=阿里技术专家详解DDD系列&amp;spm=1018.2118.3001.4449</a></p><p><a href="https://blog.csdn.net/taobaojishu/article/details/106152641">https://blog.csdn.net/taobaojishu/article/details/106152641</a><br><a href="https://cloud.google.com/apis/design/errors">https://cloud.google.com/apis/design/errors</a><br><a href="https://kb.cnblogs.com/page/520743/">https://kb.cnblogs.com/page/520743/</a></p><p><a href="https://zhuanlan.zhihu.com/p/105466656">https://zhuanlan.zhihu.com/p/105466656</a><br><a href="https://zhuanlan.zhihu.com/p/105648986">https://zhuanlan.zhihu.com/p/105648986</a><br><a href="https://zhuanlan.zhihu.com/p/106634373">https://zhuanlan.zhihu.com/p/106634373</a><br><a href="https://zhuanlan.zhihu.com/p/107347593">https://zhuanlan.zhihu.com/p/107347593</a><br><a href="https://zhuanlan.zhihu.com/p/109048532">https://zhuanlan.zhihu.com/p/109048532</a><br><a href="https://zhuanlan.zhihu.com/p/110252394">https://zhuanlan.zhihu.com/p/110252394</a><br><a href="https://www.jianshu.com/p/dfa427762975">https://www.jianshu.com/p/dfa427762975</a><br><a href="https://www.citerus.se/go-ddd/">https://www.citerus.se/go-ddd/</a><br><a href="https://www.citerus.se/part-2-domain-driven-design-in-go/">https://www.citerus.se/part-2-domain-driven-design-in-go/</a><br><a href="https://www.citerus.se/part-3-domain-driven-design-in-go/">https://www.citerus.se/part-3-domain-driven-design-in-go/</a><br><a href="https://www.jianshu.com/p/dfa427762975">https://www.jianshu.com/p/dfa427762975</a><br><a href="https://www.jianshu.com/p/5732b69bd1a1">https://www.jianshu.com/p/5732b69bd1a1</a></p><p><a href="https://www.cnblogs.com/qixuejia/p/10789612.html">https://www.cnblogs.com/qixuejia/p/10789612.html</a><br><a href="https://www.cnblogs.com/qixuejia/p/4390086.html">https://www.cnblogs.com/qixuejia/p/4390086.html</a><br><a href="https://www.cnblogs.com/qixuejia/p/10789621.html">https://www.cnblogs.com/qixuejia/p/10789621.html</a><br><a href="https://zhuanlan.zhihu.com/p/46603988">https://zhuanlan.zhihu.com/p/46603988</a><br><a href="https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/wrappers.proto">https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/wrappers.proto</a><br><a href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis">https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis</a><br><a href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html">https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html</a><br><a href="https://blog.csdn.net/taobaojishu/article/details/106152641">https://blog.csdn.net/taobaojishu/article/details/106152641</a></p><p><a href="https://apisyouwonthate.com/blog/creating-good-api-errors-in-rest-graphql-and-grpc">https://apisyouwonthate.com/blog/creating-good-api-errors-in-rest-graphql-and-grpc</a><br><a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html</a><br><a href="https://www.youtube.com/watch?v=oL6JBUk6tj0">https://www.youtube.com/watch?v=oL6JBUk6tj0</a><br><a href="https://github.com/zitryss/go-sample">https://github.com/zitryss/go-sample</a><br><a href="https://github.com/danceyoung/paper-code/blob/master/package-oriented-design/packageorienteddesign.md">https://github.com/danceyoung/paper-code/blob/master/package-oriented-design/packageorienteddesign.md</a><br><a href="mailto:https://medium.com/@eminetto/clean-architecture-using-golang-b63587aa5e3f">https://medium.com/@eminetto/clean-architecture-using-golang-b63587aa5e3f</a><br><a href="https://hackernoon.com/golang-clean-archithecture-efd6d7c43047">https://hackernoon.com/golang-clean-archithecture-efd6d7c43047</a><br><a href="mailto:https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1">https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1</a><br><a href="https://medium.com/wtf-dial/wtf-dial-domain-model-9655cd523182">https://medium.com/wtf-dial/wtf-dial-domain-model-9655cd523182</a></p><p><a href="https://hackernoon.com/golang-clean-archithecture-efd6d7c43047">https://hackernoon.com/golang-clean-archithecture-efd6d7c43047</a><br><a href="https://hackernoon.com/trying-clean-architecture-on-golang-2-44d615bf8fdf">https://hackernoon.com/trying-clean-architecture-on-golang-2-44d615bf8fdf</a><br><a href="https://manuel.kiessling.net/2012/09/28/applying-the-clean-architecture-to-go-applications/">https://manuel.kiessling.net/2012/09/28/applying-the-clean-architecture-to-go-applications/</a><br><a href="https://github.com/katzien/go-structure-examples">https://github.com/katzien/go-structure-examples</a><br><a href="https://www.youtube.com/watch?v=MzTcsI6tn-0">https://www.youtube.com/watch?v=MzTcsI6tn-0</a><br><a href="https://www.appsdeveloperblog.com/dto-to-entity-and-entity-to-dto-conversion/">https://www.appsdeveloperblog.com/dto-to-entity-and-entity-to-dto-conversion/</a><br><a href="https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/">https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/</a><br><a href="https://github.com/google/wire/blob/master/docs/best-practices.md">https://github.com/google/wire/blob/master/docs/best-practices.md</a><br><a href="https://github.com/google/wire/blob/master/docs/guide.md">https://github.com/google/wire/blob/master/docs/guide.md</a><br><a href="https://blog.golang.org/wire">https://blog.golang.org/wire</a><br><a href="https://github.com/google/wire">https://github.com/google/wire</a></p><p><a href="https://www.ardanlabs.com/blog/2019/03/integration-testing-in-go-executing-tests-with-docker.html">https://www.ardanlabs.com/blog/2019/03/integration-testing-in-go-executing-tests-with-docker.html</a><br><a href="https://www.ardanlabs.com/blog/2019/10/integration-testing-in-go-set-up-and-writing-tests.html">https://www.ardanlabs.com/blog/2019/10/integration-testing-in-go-set-up-and-writing-tests.html</a><br><a href="https://blog.golang.org/examples">https://blog.golang.org/examples</a><br><a href="https://blog.golang.org/subtests">https://blog.golang.org/subtests</a><br><a href="https://blog.golang.org/cover">https://blog.golang.org/cover</a><br><a href="https://blog.golang.org/module-compatibility">https://blog.golang.org/module-compatibility</a><br><a href="https://blog.golang.org/v2-go-modules">https://blog.golang.org/v2-go-modules</a><br><a href="https://blog.golang.org/publishing-go-modules">https://blog.golang.org/publishing-go-modules</a><br><a href="https://blog.golang.org/module-mirror-launch">https://blog.golang.org/module-mirror-launch</a><br><a href="https://blog.golang.org/migrating-to-go-modules">https://blog.golang.org/migrating-to-go-modules</a><br><a href="https://blog.golang.org/using-go-modules">https://blog.golang.org/using-go-modules</a></p><p><a href="https://blog.golang.org/modules2019">https://blog.golang.org/modules2019</a><br><a href="https://blog.codecentric.de/en/2017/08/gomock-tutorial/">https://blog.codecentric.de/en/2017/08/gomock-tutorial/</a><br><a href="https://pkg.go.dev/github.com/golang/mock/gomock">https://pkg.go.dev/github.com/golang/mock/gomock</a><br><a href="https://medium.com/better-programming/a-gomock-quick-start-guide-71bee4b3a6f1">https://medium.com/better-programming/a-gomock-quick-start-guide-71bee4b3a6f1</a></p><h2 id="第5课-评论系统架构设计"><a href="#第5课-评论系统架构设计" class="headerlink" title="第5课 评论系统架构设计"></a>第5课 评论系统架构设计</h2><h3 id="5-1-功能模块"><a href="#5-1-功能模块" class="headerlink" title="5.1 功能模块"></a>5.1 功能模块</h3><p><img src="/images/《Go进阶训练营》学习笔记/评论系统架构设计-功能模块.png" alt="评论系统架构设计-功能模块"></p><p>架构设计最重要的就是理解整个产品体系在系统中的定位。搞清楚系统背后的背景，才能做出最佳的设计和抽象。不要做需求的翻译机，先理解业务背后的本质，事情的初衷。<br>评论系统，我们往小里做就是视频评论系统，往大里做就是评论平台，可以接入各种业务形态。</p><blockquote><p>发布评论: 支持回复楼层、楼中楼。<br>读取评论: 按照时间、热度排序。<br>删除评论: 用户删除、作者删除。<br>管理评论: 作者置顶、后台运营管理(搜索、删除、审核等)。</p></blockquote><p>在动手设计前，反复思考，真正编码的时间只有5%。</p><h3 id="5-2-架构设计"><a href="#5-2-架构设计" class="headerlink" title="5.2 架构设计"></a>5.2 架构设计</h3><h4 id="5-2-1-概览"><a href="#5-2-1-概览" class="headerlink" title="5.2.1 概览"></a>5.2.1 概览</h4><p><img src="/images/《Go进阶训练营》学习笔记/评论系统架构设计-架构设计-概览.png" alt="评论系统架构设计-架构设计-概览"></p><ol><li><p>BFF: comment</p><p> 复杂评论业务的服务编排，比如访问账号服务进行等级判定，同时需要在 BFF 面向移动端/WEB场景来设计 API，这一层抽象把评论的本身的内容列表处理(加载、分页、排序等)进行了隔离，关注在业务平台化逻辑上。</p></li><li><p>Service: comment-service</p><p> 服务层，去平台业务的逻辑，专注在评论功能的 API 实现上，比如发布、读取、删除等，关注在稳定性、可用性上，这样让上游可以灵活组织逻辑把基础能力和业务能力剥离。</p></li><li><p>Job: comment-job</p><p> 消息队列的最大用途是消峰处理。</p></li><li><p>Admin: comment-admin</p><p> 管理平台，按照安全等级划分服务，尤其划分运营平台，他们会共享服务层的存储层(MySQL、Redis)。运营体系的数据大量都是检索，我们使用 canal 进行同步到 ES 中，整个数据的展示都是通过 ES，再通过业务主键更新业务数据层，这样运营端的查询压力就下方给了独立的 fulltext search 系统。</p></li><li><p>Dependency: account-service、filter-service</p><p> 整个评论服务还会依赖一些外部 gRPC 服务，统一的平台业务逻辑在 comment BFF 层收敛，这里 account-service 主要是账号服务，filter-service 是敏感词过滤服务。</p></li></ol><p>架构设计等同于数据设计，梳理清楚数据的走向和逻辑。尽量避免环形依赖、数据双向请求等。</p><h4 id="5-2-2-comment-service"><a href="#5-2-2-comment-service" class="headerlink" title="5.2.2 comment-service"></a>5.2.2 comment-service</h4><p><img src="/images/《Go进阶训练营》学习笔记/评论系统架构设计-架构设计-comment-service.png" alt="评论系统架构设计-架构设计-comment-service"></p><p>comment-service，专注在评论数据处理(认真想下 Separation of Concerns)。</p><p>我们一开始是 comment-service 和 comment 是一层，业务耦合和功能耦合在一起，非常不利于迭代，当然在设计层面可以考虑目录结构进行拆分，但是架构层次来说，迭代隔离也是好的。</p><ol><li><p>读的核心逻辑:</p><p> Cache-Aside 模式，先读取缓存，再读取存储。早期 cache rebuild 是做到服务里的，对于重建逻辑，一般会使用 read ahead 的思路，即预读，用户访问了第一页，很有可能访问第二页，所以缓存会超前加载，避免频繁 cache miss。当缓存抖动是否，特别容易引起集群 hundering herd 现象，大量的请求会触发 cache rebuild，因为使用了预加载，容易导致服务 OOM。所以我们开到回源的逻辑里，我们使用了消息队列来进行逻辑异步化，对于当前请求只返回 mysql 中部分数据即止。</p></li><li><p>写的核心逻辑:</p><p> 我们担心类似“明星出轨”等热点事件的发生，而且写和读相比较，写可以认为是透穿到存储层的，系统的瓶颈往往就来自于存储层，或者有状态层。对于写的设计上，我们认为刚发布的评论有极短的延迟(通常小于几 ms)对用户可见是可接受的，把对存储的直接冲击下放到消息队列，按照消息反压的思路，即如果存储 latency 升高，消费能力就下降，自然消息容易堆积，系统始终以最大化方式消费。</p><p> Kafka 是存在 partition 概念的，可以认为是物理上的一个小队列，一个 topic 是由一组 partition 组成的，所以 Kafka 的吞吐模型理解为: 全局并行，局部串行的生产消费方式。对于入队的消息，可以按照 hash(comment_subject) % N(partitions) 的方式进行分发。那么某个 partition 中的 评论主题的数据一定都在一起，这样方便我们串行消费。</p></li></ol><p>同样的，我们处理回源消息也是类似的思路。</p><h4 id="5-2-3-comment-admin"><a href="#5-2-3-comment-admin" class="headerlink" title="5.2.3 comment-admin"></a>5.2.3 comment-admin</h4><p><img src="/images/《Go进阶训练营》学习笔记/评论系统架构设计-架构设计-comment-admin.png" alt="评论系统架构设计-架构设计-comment-admin"></p><p>mysql binlog 中的数据被 canal 中间件流式消费，获取到业务的原始 CRUD 操作，需要回放录入到 es 中，但是 es 中的数据最终是面向运营体系提供服务能力，需要检索的数据维度比较多，在入 es 前需要做一个异构的 joiner，把单表变宽预处理好 join 逻辑，然后倒入到 es 中。</p><p>一般来说，运营后台的检索条件都是组合的，使用 es 的好处是避免依赖 mysql 来做多条件组合检索，同时 mysql 毕竟是 oltp 面向线上联机事务处理的。通过冗余数据的方式，使用其他引擎来实现。<br>es 一般会存储检索、展示、primary key 等数据，当我们操作编辑的时候，找到记录的 primary key，最后交由 comment-admin 进行运营测的 CRUD 操作。</p><p>我们内部运营体系基本都是基于 es 来完成的。</p><h4 id="5-2-4-comment"><a href="#5-2-4-comment" class="headerlink" title="5.2.4 comment"></a>5.2.4 comment</h4><p><img src="/images/《Go进阶训练营》学习笔记/评论系统架构设计-架构设计-comment.png" alt="评论系统架构设计-架构设计-comment"></p><p>comment 作为 BFF，是面向端，面向平台，面向业务组合的服务。所以平台扩展的能力，我们都在 comment 服务来实现，方便统一和准入平台，以统一的接口形式提供平台化的能力。</p><ul><li>依赖其他 gRPC 服务，整合统一平台测的逻辑(比如发布评论用户等级限定)。</li><li>直接向端上提供接口，提供数据的读写接口，甚至可以整合端上，提供统一的端上 SDK。</li><li>需要对非核心依赖的 gRPC 服务进行降级，当这些服务不稳定时。</li></ul><h3 id="5-3-存储设计"><a href="#5-3-存储设计" class="headerlink" title="5.3 存储设计"></a>5.3 存储设计</h3><h4 id="5-3-1-数据库设计"><a href="#5-3-1-数据库设计" class="headerlink" title="5.3.1 数据库设计"></a>5.3.1 数据库设计</h4><p><img src="/images/《Go进阶训练营》学习笔记/评论系统架构设计-存储设计-数据库设计.png" alt="评论系统架构设计-存储设计-数据库设计"></p><p>表说明：</p><ol><li><p><code>comment_subject</code> 主题表</p><ul><li>为了方便接入各种系统加入了字段 <code>obj_id</code> 和 <code>obj_type</code> 来表示不同的主题及子主题（比如：视频中用 <code>obj_id</code> 字段放视频 ID ，<code>obj_type</code> 中的某个值表示视频）。</li><li><code>member_id</code> 作者 ID 。</li><li><code>count</code> 是评论总数，也当作楼层使用（与表 <code>comment_index</code> 中的 <code>floor</code> 是相同的值）。</li><li><code>root_count</code> 表示评论（不包含评论下的回复）总数。</li><li><code>all_count</code> 表示评论以及评论下的回复的总数（避免在数据库中进行 <code>count (*)</code> 操作）。</li><li><code>state</code> 评论状态。</li><li><code>attrs</code> 评论属性。</li><li><code>create_time</code> 和 <code>update_time</code> 表示创建时间和更新时间。每张 MySQL 表都会有这两个字段。</li><li><p><code>id</code> 自增主键。因为 MySQL 写的核心优化一定要顺序写（随机写会导致 btree 不断的分裂，而导致大量的分页（mysql data page size is 16k））。如果一个张表没有主键， MySQL 会有一个隐藏的主键。</p><p>[0-49] 用于 sharding 分片。因为担心数据量比较大，将 <code>comment_subject</code> 拆分成了 50 张表。</p></li></ul></li><li><p><code>comment_index</code> 索引表</p><ul><li><code>obj_id</code> 和 <code>obj_type</code> 与 <code>comment_subject</code> 主题表中的字段相同。</li><li>用 <code>root</code> 和 <code>parent</code> 来表示有层级的设计（这种方式很常见）。</li><li><code>id</code> 使用发号器生成的 ID 来保证全局唯一，方便后面存放到 kv 中。</li></ul></li><li><p><code>comment_content</code> 内容表</p><ul><li><code>comment_id</code> 的值与 <code>comment_index</code> 中 <code>id</code> 的相同，且为主键，这是为了避免 MySQL 的二次索引查找。</li></ul></li></ol><blockquote><p>为什么要分 <code>comment_index</code> 索引表和 <code>comment_content</code> 内容表？</p><p>因为 MySQL 的 IO 单位是 data page。如果每个 data page 中仅包含了几个评论，那么在读取一条视频的评论时将有大量的 IO。</p></blockquote><p>数据操作：</p><ol><li><p>数据写入:</p><p> 事务更新 comment_subject，comment_index，comment_content 三张表，其中 content 属于非强制需要一致性考虑的。可以先写入 content （可以把内容放到 KV 数据库中），之后事务更新其他表。即便 content 先成功，后续失败仅仅存在一条 ghost 数据。</p><p> 当有新评论时，用 <code>SELECT FOR UPDATE</code> 从 <code>comment_subject</code> 表中读出 <code>count</code> 并加一，然后将得到的值作为 <code>comment_index</code> 中的 <code>floor</code> 写入 <code>comment_index</code> 中。</p></li><li><p>数据读取</p><p> 基于 obj_id + obj_type 在 comment_index 表找到评论列表，WHERE root = 0 ORDER BY floor。之后根据 comment_index 的 id 字段捞出 comment_content 的评论内容。对于二级的子楼层，WHERE parent/root IN (id…)。</p></li></ol><blockquote><p>注意每个表里面都有 <code>create_time</code> 和 <code>update_time</code> 这两个字段。</p></blockquote><p>因为产品形态上只存在二级列表，因此只需要迭代查询两次即可。对于嵌套层次多的，产品上，可以通过二次点击支持。</p><blockquote><p>是不是可以 Graph 存储？DGraph、HugeGraph 类似的图存储思路。</p></blockquote><h4 id="5-3-2-索引内容分离"><a href="#5-3-2-索引内容分离" class="headerlink" title="5.3.2 索引内容分离"></a>5.3.2 索引内容分离</h4><p><img src="/images/《Go进阶训练营》学习笔记/评论系统架构设计-存储设计-索引内容分离.png" alt="评论系统架构设计-存储设计-索引内容分离"></p><p>comment_index: 评论楼层的索引组织表，实际并不包含内容。</p><p>comment_content: 评论内容的表，包含评论的具体内容。其中 comment_index 的 id 字段和 comment_content 是1对1的关系，这里面包含几种设计思想。</p><ul><li>表都有主键，即 cluster index，是物理组织形式存放的，comment_content 没有 id，是为了减少一次 二级索引查找，直接基于主键检索，同时 comment_id 在写入要尽可能的顺序自增。</li><li>索引、内容分离，方便 mysql datapage 缓存更多的 row，如果和 context 耦合，会导致更大的 IO。长远来看 content 信息可以直接使用 KV storage 存储。</li></ul><p>动静分离，comment_content 的内容几乎不会变。把经常变的数据和不经常边的数据分开放。</p><h4 id="5-3-3-缓存设计"><a href="#5-3-3-缓存设计" class="headerlink" title="5.3.3 缓存设计"></a>5.3.3 缓存设计</h4><p><img src="/images/《Go进阶训练营》学习笔记/评论系统架构设计-存储设计-缓存设计.png" alt="评论系统架构设计-存储设计-缓存设计"></p><ol><li><p>comment_subject_cache</p><p> 对应主题的缓存，value 使用 protobuf 序列化的方式存入。我们早期使用 memcache 来进行缓存，因为 redis 早期单线程模型，吞吐能力不高。</p></li><li><p>comment_index_cache</p><p> 使用 redis sortedset 进行索引的缓存，索引即数据的组织顺序，而非数据内容。参考过百度的贴吧，他们使用自己研发的拉链存储来组织索引，我认为 mysql 作为主力存储，利用 redis 来做加速完全足够，因为 cache miss 的构建，我们前面讲过使用 kafka 的消费者中处理，预加载少量数据，通过增量加载的方式逐渐预热填充缓存，而 redis sortedset skiplist 的实现，可以做到 O(logN) + O(M) 的时间复杂度，效率很高。</p><p> sorted set 是要增量追加的，因此必须判定 key 存在（用 expire 而不是用 exists），才能 zadd。</p><blockquote><p>redis 中 sorted_set 的 score 是 double 类型，不能保存 int64 的值，会有溢出。</p><p>翻页功能可以用 zrang 做。</p></blockquote></li><li><p>comment_content_cache</p><p> 对应评论内容数据，使用 protobuf 序列化的方式存入。类似的我们早期使用 memcache 进行缓存。</p></li></ol><p>增量加载 + lazy 加载</p><h3 id="5-4-可用性设计"><a href="#5-4-可用性设计" class="headerlink" title="5.4 可用性设计"></a>5.4 可用性设计</h3><h4 id="5-4-1-Singleflight"><a href="#5-4-1-Singleflight" class="headerlink" title="5.4.1 Singleflight"></a>5.4.1 Singleflight</h4><p><img src="/images/《Go进阶训练营》学习笔记/评论系统架构设计-可用性设计-Singleflight.png" alt="评论系统架构设计-可用性设计-Singleflight"></p><p>对于热门的主题，如果存在缓存穿透的情况，会导致大量的同进程、跨进程的数据回源到存储层，可能会引起存储过载的情况，如何只交给同进程内，一个人去做加载存储?</p><p>使用归并回源的思路: <a href="https://pkg.go.dev/golang.org/x/sync/singleflight">https://pkg.go.dev/golang.org/x/sync/singleflight</a></p><p>同进程只交给一个人去获取 mysql 数据，然后批量返回。同时这个 lease owner 投递一个 kafka 消息，做 index cache 的 recovery 操作。这样可以大大减少 mysql 的压力，以及大量透穿导致的密集写 kafka 的问题。</p><p>更进一步的，后续连续的请求，仍然可能会短时 cache miss，我们可以在进程内设置一个 short-lived flag，标记最近有一个人投递了 cache rebuild 的消息，直接 drop。</p><blockquote><p>为什么我们不用分布式锁之类的思路？</p><p>太复杂，容易出问题，难调试。</p></blockquote><h4 id="5-4-2-热点"><a href="#5-4-2-热点" class="headerlink" title="5.4.2 热点"></a>5.4.2 热点</h4><p><img src="/images/《Go进阶训练营》学习笔记/评论系统架构设计-可用性设计-热点.png" alt="评论系统架构设计-可用性设计-热点"></p><p>流量热点是因为突然热门的主题，被高频次的访问，因为底层的 cache 设计，一般是按照主题 key 进行一致性 hash 来进行分片，但是热点 key 一定命中某一个节点，这时候 remote cache 可能会变为瓶颈，因此做 cache 的升级 local cache 是有必要的，我们一般使用单进程自适应发现热点的思路，附加一个短时的 ttl local cache，可以在进程内吞掉大量的读请求。</p><p>在内存中使用 hashmap 统计每个 key 的访问频次，这里可以使用滑动窗口统计，即每个窗口中，维护一个 hashmap，之后统计所有未过期的 bucket，汇总所有 key 的数据。</p><p>之后使用小堆计算 TopK 的数据，自动进行热点识别。</p><h3 id="5-5-References"><a href="#5-5-References" class="headerlink" title="5.5 References"></a>5.5 References</h3><h2 id="第6课-微服务-微服务可用性设计"><a href="#第6课-微服务-微服务可用性设计" class="headerlink" title="第6课 微服务(微服务可用性设计)"></a>第6课 微服务(微服务可用性设计)</h2><h3 id="6-1-隔离"><a href="#6-1-隔离" class="headerlink" title="6.1 隔离"></a>6.1 隔离</h3><p>隔离，本质上是对系统或资源进行分割，从而实现当系统发生故障时能限定传播范围和影响范围，即发生故障后只有出问题的服务不可用，保证其他服务仍然可用。</p><h4 id="6-1-1-服务隔离"><a href="#6-1-1-服务隔离" class="headerlink" title="6.1.1 服务隔离"></a>6.1.1 服务隔离</h4><ol><li><p>动静分离</p><p> <img src="/images/《Go进阶训练营》学习笔记/网站动静分离架构示意图.png" alt="网站动静分离架构示意图"></p><p> 小到 CPU 的 cacheline false sharing、数据库 mysql 表设计中避免 bufferpool 频繁过期，隔离动静表，大到架构设计中的图片、静态资源等缓存加速。本质上都体现的一样的思路，即加速/缓存访问变换频次小的。比如 CDN 场景中，将静态资源和动态 API 分离，也是体现了隔离的思路:</p><ul><li>降低应用服务器负载，静态文件访问负载全部通过CDN。</li><li>对象存储存储费用最低。</li><li>海量存储空间，无需考虑存储架构升级。</li><li><p>静态CDN带宽加速，延迟低。</p><p><img src="/images/《Go进阶训练营》学习笔记/稿件表和稿件统计表分离.png" alt="稿件表和稿件统计表分离"></p><p>archive: 稿件表，存储稿件的名称、作者、分类、tag、状态等信息，表示稿件的基本信息。</p><blockquote><p>在一个投稿流程中，一旦稿件创建改动的频率比较低。</p></blockquote><p>archive_stat: 稿件统计表，表示稿件的播放、点赞、收藏、投币数量，比较高频的更新。</p><blockquote><p>随着稿件获取流量，稿件被用户所消费，各类计数信息更新比较频繁。</p><p>MySQL BufferPool 是用于缓存 DataPage 的，DataPage 可以理解为缓存了表的行，那么如果频繁更新 DataPage 不断会置换，会导致命中率下降的问题，所以我们在表设计中，仍然可以沿用类似的思路，其主表基本更新，在上游 Cache 未命中，透穿到 MySQL，仍然有 BufferPool 的缓存。</p></blockquote></li></ul></li><li><p>读写分离</p><p> 主从、Replicaset、CQRS。</p></li></ol><h4 id="6-1-2-轻重隔离"><a href="#6-1-2-轻重隔离" class="headerlink" title="6.1.2 轻重隔离"></a>6.1.2 轻重隔离</h4><ol><li><p>核心隔离</p><p> <img src="/images/《Go进阶训练营》学习笔记/核心隔离.png" alt="核心隔离"></p><p> 业务按照 Level 进行资源池划分(L0/L1/L2)。</p><ul><li>核心/非核心的故障域的差异隔离(机器资源、依赖资源)。</li><li>多集群，通过冗余资源来提升吞吐和容灾能力。</li></ul></li><li><p>快慢隔离</p><p> <img src="/images/《Go进阶训练营》学习笔记/快慢隔离.png" alt="快慢隔离"></p><p> 我们可以把服务的吞吐想象为一个池，当突然洪流进来时，池子需要一定时间才能排放完，这时候其他支流在池子里待的时间取决于前面的排放能力，耗时就会增高，对小请求产生影响。</p><p> 日志传输体系的架构设计中，整个流都会投放到一个 kafka topic 中(早期设计目的: 更好的顺序IO)，流内会区分不同的 logid，logid 会有不同的 sink 端，它们之前会出现差速，比如 HDFS 抖动吞吐下降，ES 正常水位，全局数据就会整体反压。</p><p> 按照各种纬度隔离：sink、部门、业务、logid、重要性(S/A/B/C)。</p><p> 业务日志也属于某个 logid，日志等级就可以作为隔离通道。</p></li><li><p>热点隔离</p><p> <img src="/images/《Go进阶训练营》学习笔记/热点隔离.png" alt="热点隔离"></p><p> 何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行缓存。比如：</p><ul><li>小表广播: 从 remotecache 提升为 localcache，app 定时更新，甚至可以让运营平台支持广播刷新 localcache。atomic.Value</li><li>主动预热: 比如直播房间页高在线情况下bypass 监控主动防御。</li></ul></li></ol><h4 id="6-1-3-物理隔离"><a href="#6-1-3-物理隔离" class="headerlink" title="6.1.3 物理隔离"></a>6.1.3 物理隔离</h4><ol><li><p>线程隔离</p><p> <img src="/images/《Go进阶训练营》学习笔记/线程隔离.png" alt="线程隔离"></p><p> 主要通过线程池进行隔离，也是实现服务隔离的基础。把业务进行分类并交给不同的线程池进行处理，当某个线程池处理一种业务请求发生问题时，不会讲故障扩散和影响到其他线程池，保证服务可用。</p><p> 对于 Go 来说，所有 IO 都是 Nonblocking，且托管给了 Runtime，只会阻塞Goroutine，不阻塞 M，我们只需要考虑 Goroutine 总量的控制，不需要线程模型语言的线程隔离。</p><p> Java 除了线程池隔离，也有基于信号量的做法。</p><p> <img src="/images/《Go进阶训练营》学习笔记/基于信号量的线程隔离.png" alt="基于信号量的线程隔离"></p><p> 当信号量达到 maxConcurrentRequests 后，再请求会触发 fallback。</p></li><li><p>进程隔离</p><p> 容器化(docker)，容器编排引擎(k8s)。我们15年在 KVM 上部署服务；16年使用 Docker Swarm；17年迁移到 Kubernetes，到年底在线应用就全托管了，之后很快在线应用弹性公有云上线；20年离线 Yarn 和 在线 K8s 做了在离线混部(错峰使用)，之后计划弹性公有云配合自建 IDC 做到离线的混合云架构。</p></li><li><p>集群隔离</p><p> 回顾 gRPC，我们介绍过多集群方案，即逻辑上是一个应用，物理上部署多套应用，通过 cluster 区分。</p><p> 多活建设完毕后，我们应用可以划分为：region.zone.cluster.appid</p><p> <img src="/images/《Go进阶训练营》学习笔记/账号多活.png" alt="账号多活"></p></li><li><p>机房隔离</p></li></ol><h4 id="6-1-4-Case-Study"><a href="#6-1-4-Case-Study" class="headerlink" title="6.1.4 Case Study"></a>6.1.4 Case Study</h4><ul><li>早期转码集群被超大视频攻击，导致转码大量延迟。</li><li>入口Nginx(SLB)故障，影响全机房流量入口故障。</li><li>缩略图服务，被大图实时缩略吃完所有 CPU，导致正常的小图缩略被丢弃，大量503。</li><li>数据库实例 cgroup 未隔离，导致大 SQL 引起的集体故障。</li><li>INFO 日志量过大，导致异常 ERROR 日志采集延迟。</li></ul><h3 id="6-2-超时控制"><a href="#6-2-超时控制" class="headerlink" title="6.2 超时控制"></a>6.2 超时控制</h3><p>超时控制，我们的组件能够快速失效(fail fast)，因为我们不希望等到断开的实例直到超时。没有什么比挂起的请求和无响应的界面更令人失望。这不仅浪费资源，而且还会让用户体验变得更差。我们的服务是互相调用的，所以在这些延迟叠加前，应该特别注意防止那些超时的操作。</p><ul><li>网路传递具有不确定性。</li><li>客户端和服务端不一致的超时策略导致资源浪费。</li><li>“默认值”策略。</li><li>高延迟服务导致 client 浪费资源等待，使用超时传递: 进程间传递 + 跨进程传递。</li></ul><blockquote><p>超时控制是微服务可用性的第一道关，良好的超时策略，可以尽可能让服务不堆积请求，尽快清空高延迟的请求，释放 Goroutine。</p></blockquote><p>实际业务开发中，我们依赖的微服务的超时策略并不清楚，或者随着业务迭代耗时超生了变化，意外的导致依赖者出现了超时。</p><ul><li>服务提供者定义好 latency SLO(Service level objectives)，更新到 gRPC Proto 定义中，服务后续迭代，都应保证 SLO。</li></ul><p><img src="/images/《Go进阶训练营》学习笔记/服务提供SLO.png" alt="服务提供SLO"></p><pre class="line-numbers language-proto3" data-language="proto3"><code class="language-proto3">package google.example.library.v1;service LibraryService {    // Lagency SLO: 95th in 100ms, 99th in 150ms.    rpc CreateBook(CreateBookRequest) returns (Book);    rpc GetBook(GetBookRequest) returns Book);    rpc ListBooks(ListBooksRequest) returns (ListBooksResponse);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>避免出现意外的默认超时策略，或者意外的配置超时策略。</p><ul><li>kit 基础库兜底默认超时，比如 100ms，进行配置防御保护，避免出现类似 60s 之类的超大超时策略。</li><li>配置中心公共模版，对于未配置的服务使用公共配置。</li></ul><h4 id="6-2-1-超时传递"><a href="#6-2-1-超时传递" class="headerlink" title="6.2.1 超时传递"></a>6.2.1 超时传递</h4><p><img src="/images/《Go进阶训练营》学习笔记/超时控制.png" alt="超时控制"></p><p>超时传递: 当上游服务已经超时返回 504，但下游服务仍然在执行，会导致浪费资源做无用功。超时传递指的是把当前服务的剩余 Quota 传递到下游服务中，继承超时策略，控制请求级别的全局超时控制。</p><p>进程内超时控制</p><ul><li>一个请求在每个阶段(网络请求)开始前，就要检查是否还有足够的剩余来处理请求，以及继承他的超时策略，使用 Go 标准库的 <a href="https://pkg.go.dev/context#WithTimeout">context.WithTimeout</a>。</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>asiiConn<span class="token punctuation">)</span> <span class="token function">Get</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>result <span class="token operator">*</span>Item<span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    c<span class="token punctuation">.</span>conn<span class="token punctuation">.</span><span class="token function">SetWriteDeadline</span><span class="token punctuation">(</span><span class="token function">shrinkDeadline</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> c<span class="token punctuation">.</span>writeTimeout<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">=</span> fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>rw<span class="token punctuation">,</span> <span class="token string">"gets %s\r\n"</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="6-2-2-gRPC-的超时传递"><a href="#6-2-2-gRPC-的超时传递" class="headerlink" title="6.2.2 gRPC 的超时传递"></a>6.2.2 gRPC 的超时传递</h4><p><img src="/images/《Go进阶训练营》学习笔记/gRPC的超时传递.png" alt="gRPC的超时传递"></p><ol><li>A gRPC 请求 B，1s超时。</li><li>B 使用了300ms 处理请求，再转发请求 C。</li><li>C 配置了600ms 超时，但是实际只用了500ms。</li><li>到其他的下游，发现余量不足，取消传递。</li></ol><blockquote><p>在需要强制执行时，下游的服务可以覆盖上游的超时传递和配额。</p><p>在 gRPC 框架中，会依赖 gRPC Metadata Exchange，基于 HTTP2 的 Headers 传递 grpc-timeout 字段，自动传递到下游，构建带 timeout 的 context。</p></blockquote><h4 id="6-2-3-细节控制"><a href="#6-2-3-细节控制" class="headerlink" title="6.2.3 细节控制"></a>6.2.3 细节控制</h4><ul><li>双峰分布: 95%的请求耗时在100ms内，5%的请求可能永远不会完成(长超时)。</li><li>对于监控不要只看mean，可以看看耗时分布统计，比如 95th，99th。</li><li>设置合理的超时，拒绝超长请求，或者当Server 不可用要主动失败。</li></ul><blockquote><p>超时决定着服务线程耗尽。</p></blockquote><h4 id="6-2-4-Case-Study"><a href="#6-2-4-Case-Study" class="headerlink" title="6.2.4 Case Study"></a>6.2.4 Case Study</h4><ul><li>SLB 入口 Nginx 没配置超时导致连锁故障。</li><li>服务依赖的 DB 连接池漏配超时，导致请求阻塞，最终服务集体 OOM。</li><li>下游服务发版耗时增加，而上游服务配置超时过短，导致上游请求失败。</li></ul><h3 id="6-3-过载保护"><a href="#6-3-过载保护" class="headerlink" title="6.3 过载保护"></a>6.3 过载保护</h3><h4 id="6-3-1-令牌桶算法"><a href="#6-3-1-令牌桶算法" class="headerlink" title="6.3.1 令牌桶算法"></a>6.3.1 令牌桶算法</h4><p><img src="/images/《Go进阶训练营》学习笔记/令牌桶算法.png" alt="令牌桶算法"></p><p>是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌。令牌桶算法的描述如下：</p><ul><li>假设限制2r/s，则按照500毫秒的固定速率往桶中添加令牌。</li><li>桶中最多存放 b 个令牌，当桶满时，新添加的令牌被丢弃或拒绝。</li><li>当一个 n 个字节大小的数据包到达，将从桶中删除 n 个令牌，接着数据包被发送到网络上。</li><li>如果桶中的令牌不足 n 个，则不会删除令牌，且该数据包将被限流（要么丢弃，要么缓冲区等待）。</li></ul><p>token-bucket rate limit algorithm: <a href="https://pkg.go.dev/golang.org/x/time/rate">/x/time/rate</a></p><h4 id="6-3-2-漏桶算法"><a href="#6-3-2-漏桶算法" class="headerlink" title="6.3.2 漏桶算法"></a>6.3.2 漏桶算法</h4><p><img src="/images/《Go进阶训练营》学习笔记/漏桶算法.png" alt="漏桶算法"></p><p>作为计量工具(The Leaky Bucket Algorithm as a Meter)时，可以用于流量整形(Traffic Shaping)和流量控制(TrafficPolicing)，漏桶算法的描述如下：</p><ul><li>一个固定容量的漏桶，按照常量固定速率流出水滴。</li><li>如果桶是空的，则不需流出水滴。</li><li>可以以任意速率流入水滴到漏桶。</li><li>如果流入水滴超出了桶的容量，则流入的水滴溢出了（被丢弃），而漏桶容量是不变的。</li></ul><p>leaky-bucket rate limit algorithm: <a href="https://pkg.go.dev/go.uber.org/ratelimit">/go.uber.org/ratelimit</a></p><h4 id="6-3-3-过载保护算法的缺陷"><a href="#6-3-3-过载保护算法的缺陷" class="headerlink" title="6.3.3 过载保护算法的缺陷"></a>6.3.3 过载保护算法的缺陷</h4><p>漏斗桶/令牌桶确实能够保护系统不被拖垮, 但不管漏斗桶还是令牌桶, 其防护思路都是设定一个指标, 当超过该指标后就阻止或减少流量的继续进入，当系统负载降低到某一水平后则恢复流量的进入。但其通常都是被动的，其实际效果取决于限流阈值设置是否合理，但往往设置合理不是一件容易的事情。</p><ul><li>集群增加机器或者减少机器限流阈值是否要重新设置?</li><li>设置限流阈值的依据是什么?</li><li>人力运维成本是否过高?</li><li>当调用方反馈429时, 这个时候重新设置限流, 其实流量高峰已经过了重新评估限流是否有意义?</li></ul><p>这些其实都是采用漏斗桶/令牌桶的缺点, 总体来说就是太被动, 不能快速适应流量变化。</p><p>因此我们需要一种自适应的限流算法，即: 过载保护，根据系统当前的负载自动丢弃流量。</p><h4 id="6-3-5-过载保护"><a href="#6-3-5-过载保护" class="headerlink" title="6.3.5 过载保护"></a>6.3.5 过载保护</h4><p>计算系统临近过载时的峰值吞吐作为限流的阈值来进行流量控制，达到系统保护。</p><ul><li>服务器临近过载时，主动抛弃一定量的负载，目标是自保。</li><li>在系统稳定的前提下，保持系统的吞吐量。</li></ul><p><img src="/images/《Go进阶训练营》学习笔记/利特尔法则.png" alt="利特尔法则"></p><blockquote><p>在微服务中，流入速度是 QPS ，耗时就是 latency，整个系统的吞吐就是 QPS * latency 。</p><p>BBR 的思路就是交替探测出网络的 输入速度 和 延迟 。</p></blockquote><p>常见做法：<strong>利特尔法则</strong></p><ul><li>CPU、内存作为信号量进行节流。<blockquote><p>GO 一般仅用 CPU 就可以了。因为在 GO 中，如果内存涨的很快，要么就是每 2 分钟进行一次 GC，要么就是新申请的内存容量比之前的涨了多少倍，最终都会 GC 并反应在 CPU 上。</p></blockquote></li><li>队列管理: 队列长度、LIFO。</li><li>可控延迟算法: <a href="https://blog.csdn.net/dog250/article/details/72849893">CoDel</a></li></ul><p>如何计算接近峰值时的系统吞吐？</p><ul><li><p>CPU: 使用一个独立的线程采样，每隔 250ms 触发一次。在计算均值时，使用了简单滑动平均去除峰值的影响。</p><p>  <img src="/images/《Go进阶训练营》学习笔记/系统吞吐CPU采样.png" alt="系统吞吐CPU采样"></p></li><li><p>Inflight: 当前服务中正在进行的请求的数量。</p><p>  atomic.int 来一个请求加一，处理完一个请求减一。用于计算QPS。</p></li><li><p>Pass&amp;RT: 最近5s，pass 为每100ms采样窗口内成功请求的数量最大值，rt 为单个采样窗口中平均响应时间（与取最大 pass 值对应时间窗口）。</p><p>  <img src="/images/《Go进阶训练营》学习笔记/系统吞吐窗口采样.png" alt="系统吞吐窗口采样"></p></li></ul><p>具体做法：</p><blockquote><p>思路是：在服务器临近过载时（比如 CPU 80% 时），认为这个时候系统的吞吐就是系统的最大值。如果系统实际的吞吐比最大吞吐大，就丢掉部分 QPS ，如果系统实际吞吐比最大吞吐小，就放行更多的 QPS 进入系统。</p></blockquote><ol><li>我们使用 CPU 的滑动均值(CPU &gt; 800)作为启发阈值，一旦触发进入到过载保护阶段，算法为：(pass * rt) &lt; inflight</li><li>限流效果生效后，CPU 会在临界值(800)附近抖动，如果不使用冷却时间，那么一个短时间的 CPU 下降就可能导致大量请求被放行，严重时会打满 CPU。</li><li>在冷却时间(2s)后，重新判断阈值(CPU &gt; 800 )，是否持续进入过载保护。</li></ol><p><img src="/images/《Go进阶训练营》学习笔记/过载保护具体做法.png" alt="过载保护具体做法"></p><h3 id="6-4-限流"><a href="#6-4-限流" class="headerlink" title="6.4 限流"></a>6.4 限流</h3><h4 id="6-4-1-介绍"><a href="#6-4-1-介绍" class="headerlink" title="6.4.1 介绍"></a>6.4.1 介绍</h4><p>限流是指在一段时间内，定义某个客户或应用可以接收或处理多少个请求的技术。例如，通过限流，你可以过滤掉产生流量峰值的客户和微服务，或者可以确保你的应用程序在自动扩展(Auto Scaling)失效前都不会出现过载的情况。</p><ul><li>令牌桶、漏桶 针对单个节点，无法分布式限流。</li><li>QPS 限流<ul><li>不同的请求可能需要数量迥异的资源来处理。</li><li>某种静态 QPS 限流不是特别准。</li></ul></li><li>给每个用户设置限制<ul><li>全局过载发生时候，针对某些“异常”进行控制。</li><li>一定程度的“超卖”配额。</li></ul></li><li>按照优先级丢弃。</li><li>拒绝请求也需要成本。</li></ul><h4 id="6-4-2-分布式限流"><a href="#6-4-2-分布式限流" class="headerlink" title="6.4.2 分布式限流"></a>6.4.2 分布式限流</h4><p>分布式限流，是为了控制某个应用全局的流量，而非真对单个节点纬度。</p><ul><li>单个大流量的接口，使用 redis 容易产生热点。</li><li>pre-request 模式（使用redis 的 incr 计数限流）对性能有一定影响，高频的网络往返。</li></ul><p><img src="/images/《Go进阶训练营》学习笔记/使用redis限流.png" alt="使用redis限流"></p><p>思考：</p><ul><li>从获取单个 quota 升级成批量 quota（将incr换成incrby）。quota: 表示速率，获取后使用令牌桶算法来限制。</li></ul><h4 id="6-4-3-改进的分布式限流"><a href="#6-4-3-改进的分布式限流" class="headerlink" title="6.4.3 改进的分布式限流"></a>6.4.3 改进的分布式限流</h4><p><img src="/images/《Go进阶训练营》学习笔记/使用redis限流-批量获取quota.png" alt="使用redis限流-批量获取quota"></p><p>每次心跳后，异步批量获取 quota，可以大大减少请求 redis 的频次，获取完以后本地消费，基于令牌桶拦截。</p><p>每次申请的配额需要手动设定静态值略欠灵活，比如每次要20，还是50（限制的是QPS不是个数）。</p><blockquote><p>如何基于单个节点按需申请，并且避免出现不公平的现象？</p><p>初次使用默认值，一旦有过去历史窗口的数据，可以基于历史窗口数据进行 quota 请求。</p></blockquote><p>思考：<br>我们经常面临给一组用户划分稀有资源的问题，他们都享有等价的权利来获取资源，但是其中一些用户实际上只需要比其他用户少的资源。</p><p>那么我们如何来分配资源呢？一种在实际中广泛使用的分享技术称作“最大最小公平分享”(Max-Min Fairness)。</p><p>直观上，公平分享分配给每个用户想要的可以满足的最小需求，然后将没有使用的资源均匀的分配给需要‘大资源’的用户。</p><p><img src="/images/《Go进阶训练营》学习笔记/最大最小公平分享.png" alt="最大最小公平分享"></p><p>最大最小公平分配算法的形式化定义如下：</p><ul><li>资源按照需求递增的顺序进行分配。</li><li>不存在用户得到的资源超过自己的需求。</li><li>未得到满足的用户等价的分享资源。</li></ul><h4 id="6-4-4-限流方式对比"><a href="#6-4-4-限流方式对比" class="headerlink" title="6.4.4 限流方式对比"></a>6.4.4 限流方式对比</h4><p><img src="/images/《Go进阶训练营》学习笔记/限流方式对比.png" alt="限流方式对比"></p><h4 id="6-4-5-重要性"><a href="#6-4-5-重要性" class="headerlink" title="6.4.5 重要性"></a>6.4.5 重要性</h4><p>每个接口配置阈值，运营工作繁重，最简单的我们配置服务级别 quota，更细粒度的，我们可以根据不同重要性设定 quota，我们引入了重要性(criticality):</p><ul><li>最重要 CRITICAL_PLUS，为最终的要求预留的类型，拒绝这些请求会造成非常严重的用户可见的问题。</li><li>重要 CRITICAL，生产任务发出的默认请求类型。拒绝这些请求也会造成用户可见的问题。但是可能没那么严重。</li><li>可丢弃的 SHEDDABLE_PLUS 这些流量可以容忍某种程度的不可用性。这是批量任务发出的请求的默认值。这些请求通常可以过几分钟、几小时后重试。</li><li>可丢弃的 SHEDDABLE 这些流量可能会经常遇到部分不可用情况，偶尔会完全不可用。</li></ul><p>gRPC 系统之间，需要自动传递重要性信息。如果后端接受到请求 A，在处理过程中发出了请求 B 和 C 给其他后端，请求 B 和 C 会使用与 A 相同的重要性属性。</p><ul><li>全局配额不足时，优先拒绝低优先级的。</li><li>全局配额，可以按照重要性分别设置。</li><li>过载保护时，低优先级的请求先被拒绝。</li></ul><h4 id="6-4-6-熔断"><a href="#6-4-6-熔断" class="headerlink" title="6.4.6 熔断"></a>6.4.6 熔断</h4><p>断路器(Circuit Breakers): 为了限制操作的持续时间，我们可以使用超时，超时可以防止挂起操作并保证系统可以响应。因为我们处于高度动态的环境中，几乎不可能确定在每种情况下都能正常工作的准确的时间限制。断路器以现实世界的电子元件命名，因为它们的行为是都是相同的。断路器在分布式系统中非常有用，因为重复的故障可能会导致雪球效应，并使整个系统崩溃。</p><p><img src="/images/《Go进阶训练营》学习笔记/熔断原理.png" alt="熔断原理"></p><ul><li>服务依赖的资源出现大量错误。</li><li>某个用户超过资源配额时，后端任务会快速拒绝请求，返回“配额不足”的错误，但是拒绝回复仍然会消耗一定资源。有可能后端忙着不停发送拒绝请求，导致过载。</li></ul><p>原始的熔断器在熔断后的请求是一刀切（所有的请求都会失败），不够友好。</p><h4 id="6-4-7-更友好的熔断恢复方式"><a href="#6-4-7-更友好的熔断恢复方式" class="headerlink" title="6.4.7 更友好的熔断恢复方式"></a>6.4.7 更友好的熔断恢复方式</h4><p><img src="/images/《Go进阶训练营》学习笔记/更友好的熔断恢复方式.png" alt="更友好的熔断恢复方式"></p><p>Google SRE：<code>max(0, (requests - K*accepts) / (requests + 1))</code> 得出的是一个丢弃的比率。</p><blockquote><p>K 是常量，表示丢弃的激进性。一般用2。</p></blockquote><h4 id="6-4-8-Gutter"><a href="#6-4-8-Gutter" class="headerlink" title="6.4.8 Gutter"></a>6.4.8 Gutter</h4><p><img src="/images/《Go进阶训练营》学习笔记/限流-Gutter.png" alt="限流-Gutter"></p><p>基于熔断的 gutter kafka ，用于接管自动修复系统运行过程中的负载，这样只需要付出10%的资源就能解决部分系统可用性问题。</p><p>我们经常使用 failover 的思路，但是完整的 failover 需要翻倍的机器资源，平常不接受流量时，资源浪费。高负载情况下接管流量又不一定完整能接住。所以这里核心利用熔断的思路，是把抛弃的流量转移到 gutter 集群，如果 gutter 也接受不住的流量，重新回抛到主集群，最大力度来接受。</p><h4 id="6-4-9-客户端流控"><a href="#6-4-9-客户端流控" class="headerlink" title="6.4.9 客户端流控"></a>6.4.9 客户端流控</h4><p><img src="/images/《Go进阶训练营》学习笔记/限流-客户端流控.png" alt="限流-客户端流控"></p><p>positive feedback: 用户总是积极重试（失败时客户端自动重试），访问一个不可达的服务。</p><ul><li>客户端需要限制请求频次，retry backoff 做一定的请求退让。</li><li>可以通过接口级别的 error_details，挂载到每个 API 返回的响应里（即把客户端自动重试的间隔设置在返回的错误信息中，客户端也需要有默认值）。</li></ul><h4 id="6-4-10-Case-Study"><a href="#6-4-10-Case-Study" class="headerlink" title="6.4.10 Case Study"></a>6.4.10 Case Study</h4><ul><li>二层缓存穿透、大量回源导致的核心服务故障。</li><li>异常客户端引起的服务故障(query of death)<ul><li>请求放大。</li><li>资源数放大。</li></ul></li><li>用户重试导致的大面积故障。</li></ul><h3 id="6-5-降级"><a href="#6-5-降级" class="headerlink" title="6.5 降级"></a>6.5 降级</h3><h4 id="6-5-1-介绍"><a href="#6-5-1-介绍" class="headerlink" title="6.5.1 介绍"></a>6.5.1 介绍</h4><p>通过降级回复来减少工作量，或者丢弃不重要的请求。而且需要了解哪些流量可以降级，并且有能力区分不同的请求。我们通常提供降低回复的质量来答复减少所需的计算量或者时间。我们自动降级通常需要考虑几个点：</p><ul><li>确定具体采用哪个指标作为流量评估和优雅降级的决定性指标(如，CPU、延迟、队列长度、线程数量、错误等)。</li><li>当服务进入降级模式时，需要执行什么动作？</li><li>流量抛弃或者优雅降级应该在服务的哪一层实现？是否需要在整个服务的每一层都实现，还是可以选择某个高层面的关键节点来实现？</li></ul><blockquote><p>降级通常在 BFF 或者 API Gateway 中做。在下游做的话上游感觉不到降级，可能会污染缓存等，也需要做的很复杂。</p></blockquote><p>同时我们要考虑一下几点：</p><ul><li>优雅降级不应该被经常触发 - 通常触发条件现实了容量规划的失误，或者是意外的负载。</li><li>演练，代码平时不会触发和使用，需要定期针对一小部分的流量进行演练，保证模式的正常。</li><li>应该足够简单。</li></ul><p>降级本质为: 提供有损服务。</p><ul><li><p>UI 模块化，非核心模块降级。</p><ul><li>BFF 层聚合 API，模块降级。</li></ul></li><li><p>页面上一次缓存副本。</p></li><li>默认值、热门推荐等。</li><li>流量拦截 + 定期数据缓存(过期副本策略)。</li></ul><p>处理策略</p><ul><li>页面降级、延迟服务、写/读降级、缓存降级</li><li>抛异常、返回约定协议、Mock 数据、Fallback 处理</li></ul><h4 id="6-5-2-Case-Study"><a href="#6-5-2-Case-Study" class="headerlink" title="6.5.2 Case Study"></a>6.5.2 Case Study</h4><ul><li>客户端解析协议失败，app 奔溃。</li><li>客户端部分协议不兼容，导致页面失败。</li><li>local cache 数据源缓存，发版失效 + 依赖接口故障，引起的白屏。</li><li>没有 playbook（SOP），导致的平均修复时间（Mean time to repair，MTTR）上升。</li></ul><h3 id="6-6-重试"><a href="#6-6-重试" class="headerlink" title="6.6 重试"></a>6.6 重试</h3><h4 id="6-6-1-介绍"><a href="#6-6-1-介绍" class="headerlink" title="6.6.1 介绍"></a>6.6.1 介绍</h4><p>当请求返回错误(例: 配额不足、超时、内部错误等)，对于 backend 部分节点过载的情况下，倾向于立刻重试，但是需要留意重试带来的流量放大:</p><ul><li>限制重试次数和基于重试分布的策略(重试比率: 10%)。</li><li>随机化、指数型递增的重试周期: exponential ackoff + jitter。</li><li>client 测记录重试次数直方图，传递到 server，进行分布判定，交由 server 判定拒绝。</li><li>只应该在失败的这层进行重试，当重试仍然失败，全局约定错误码“过载，无须重试”，避免级联重试。</li></ul><h4 id="6-6-2-Case-Study"><a href="#6-6-2-Case-Study" class="headerlink" title="6.6.2 Case Study"></a>6.6.2 Case Study</h4><ul><li>Nginx upstream retry 过大，导致服务雪崩。</li><li>业务不幂等，导致的重试，数据重复。<ul><li>全局唯一 ID: 根据业务生成一个全局唯一 ID，在调用接口时会传入该 ID，接口提供方会从相应的存储系统比如 redis 中去检索这个全局 ID 是否存在，如果存在则说明该操作已经执行过了，将拒绝本次服务请求；否则将相应该服务请求并将全局 ID 存入存储系统中,之后包含相同业务 ID 参数的请求将被拒绝。</li><li>去重表: 这种方法适用于在业务中有唯一标识的插入场景。比如在支付场景中，一个订单只会支付一次，可以建立一张去重表,将订单 ID 作为唯一索引。把支付并且写入支付单据到去重表放入一个事务中了，这样当出现重复支付时，数据库就会抛出唯一约束异常,操作就会回滚。这样保证了订单只会被支付一次。</li><li>多版本并发控制: 适合对更新请求作幂等性控制,比如要更新商品的名字，这是就可以在更新的接口中增加一个版本号来做幂等性控制。</li></ul></li><li>多层级重试传递，放大流量引起雪崩。</li></ul><h3 id="6-7-负载均衡"><a href="#6-7-负载均衡" class="headerlink" title="6.7 负载均衡"></a>6.7 负载均衡</h3><p>数据中心内部的负载均衡</p><p>在理想情况下，某个服务的负载会完全均匀地分发给所有的后端任务。在任何时刻，最忙和最不忙的节点永远消耗同样数量的CPU。</p><p>目标：</p><ul><li>均衡的流量分发。</li><li>可靠的识别异常节点。</li><li>scale-out，增加同质节点扩容。</li><li>减少错误，提高可用性。</li></ul><p>我们发现在 backend 之间的 load 差异比较大：</p><ul><li>每个请求的处理成本不同。</li><li>物理机环境的差异:<ul><li>服务器很难强同质性。</li><li>存在共享资源争用（内存缓存、带宽、IO等）。</li></ul></li><li>性能因素:<ul><li>FullGC。</li><li>JVM JIT。</li></ul></li></ul><p>参考JSQ（最闲轮训）负载均衡算法带来的问题，缺乏的是服务端全局视图，因此我们目标需要综合考虑：负载+可用性。</p><p>参考了《The power of two choices in randomized load balancing》的思路，我们使用 the choice-of-2 算法，随机选取的两个节点进行打分，选择更优的节点:</p><ul><li>选择 backend：CPU，client：health、inflight、latency 作为指标，使用一个简单的线性方程进行打分。</li><li>对新启动的节点使用常量惩罚值(penalty)，以及使用探针方式最小化放量，进行预热。</li><li><p>打分比较低的节点，避免进入“永久黑名单”而无法恢复，使用统计衰减的方式，让节点指标逐渐恢复到初始状态(即默认值)。</p><p>  指标计算结合 moving average，使用时间衰减，计算 <code>vt = v(t-1) * β + at * (1-β)</code> ，β为若干次幂的倒数即: Math.Exp((-span) / 600ms)</p></li></ul><h3 id="6-8-最佳实践"><a href="#6-8-最佳实践" class="headerlink" title="6.8 最佳实践"></a>6.8 最佳实践</h3><ul><li>变更管理:<ul><li>70％的问题是由变更引起的，恢复可用代码并不总是坏事。</li></ul></li><li>避免过载:<ul><li>过载保护、流量调度等。</li></ul></li><li>依赖管理:<ul><li>任何依赖都可能故障，做 chaos monkey testing，注入故障测试。</li></ul></li><li>优雅降级:<ul><li>有损服务，避免核心链路依赖故障。</li></ul></li><li>重试退避:<ul><li>退让算法，冻结时间，API retry detail 控制策略。</li></ul></li><li>超时控制:<ul><li>进程内 + 服务间 超时控制。</li></ul></li><li>极限压测 + 故障演练。</li><li>扩容 + 重启 + 消除有害流量。</li></ul><h3 id="6-9-References"><a href="#6-9-References" class="headerlink" title="6.9 References"></a>6.9 References</h3><p><a href="http://www.360doc.com/content/16/1124/21/31263000_609259745.shtml">http://www.360doc.com/content/16/1124/21/31263000_609259745.shtml</a><br><a href="http://www.infoq.com/cn/articles/basis-frameworkto-implement-micro-service/">http://www.infoq.com/cn/articles/basis-frameworkto-implement-micro-service/</a><br><a href="http://www.infoq.com/cn/news/2017/04/linkerd-celebrates-one-year">http://www.infoq.com/cn/news/2017/04/linkerd-celebrates-one-year</a><br><a href="https://medium.com/netflix-techblog/netflix-edge-load-balancing-695308b5548c">https://medium.com/netflix-techblog/netflix-edge-load-balancing-695308b5548c</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzAwNjQwNzU2NQ==&amp;mid=402841629&amp;idx=1&amp;sn=f598fec9b370b8a6f2062233b31122e0&amp;mpshare=1&amp;scene=23&amp;srcid=0404qP0fH8zRiIiFzQBiuzuU#rd">https://mp.weixin.qq.com/s?__biz=MzAwNjQwNzU2NQ==&amp;mid=402841629&amp;idx=1&amp;sn=f598fec9b370b8a6f2062233b31122e0&amp;mpshare=1&amp;scene=23&amp;srcid=0404qP0fH8zRiIiFzQBiuzuU#rd</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzIzMzk2NDQyMw==&amp;mid=2247486641&amp;idx=1&amp;sn=1660fb41b0c5b8d8d6eacdfc1b26b6a6&amp;source=41#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzIzMzk2NDQyMw==&amp;mid=2247486641&amp;idx=1&amp;sn=1660fb41b0c5b8d8d6eacdfc1b26b6a6&amp;source=41#wechat_redirect</a><br><a href="https://blog.acolyer.org/2018/11/16/overload-control-for-scaling-wechat-microservices/">https://blog.acolyer.org/2018/11/16/overload-control-for-scaling-wechat-microservices/</a><br><a href="https://www.cs.columbia.edu/~ruigu/papers/socc18-final100.pdf">https://www.cs.columbia.edu/~ruigu/papers/socc18-final100.pdf</a><br><a href="https://github.com/alibaba/Sentinel/wiki/系统负载保护">https://github.com/alibaba/Sentinel/wiki/系统负载保护</a><br><a href="https://blog.csdn.net/okiwilldoit/article/details/81738782">https://blog.csdn.net/okiwilldoit/article/details/81738782</a><br><a href="http://alex-ii.github.io/notes/2019/02/13/predictive_load_balancing.html">http://alex-ii.github.io/notes/2019/02/13/predictive_load_balancing.html</a><br><a href="https://blog.csdn.net/m0_38106113/article/details/81542863">https://blog.csdn.net/m0_38106113/article/details/81542863</a></p><h2 id="第7课-播放历史架构设计"><a href="#第7课-播放历史架构设计" class="headerlink" title="第7课 播放历史架构设计"></a>第7课 播放历史架构设计</h2><h3 id="7-1-功能模块"><a href="#7-1-功能模块" class="headerlink" title="7.1 功能模块"></a>7.1 功能模块</h3><p><a href="https://www.bilibili.com/account/history">https://www.bilibili.com/account/history</a></p><p>为了大部分用户的基本功能体验，满足用户需求，例如播放历史查看、播放进度同步等。离线型用户，app 本地保留历史记录数据。</p><p>同样的，也要考虑平台化，视频、文章、漫画等业务扩展接入。</p><ul><li>变更功能：添加记录、删除记录、清空历史。</li><li>读取功能：按照 timeline 返回 top N，点查获取进度信息。</li><li>其他功能：暂停/恢复记录，首次观察增加经验等。</li></ul><p>历史记录类型的业务，是一个极高 tps 写入，高 qps 读取的业务服务。分析清楚系统的 hot path，投入优化，而不是哪哪都去优化。</p><h3 id="7-2-架构设计"><a href="#7-2-架构设计" class="headerlink" title="7.2 架构设计"></a>7.2 架构设计</h3><h4 id="7-2-1-概览"><a href="#7-2-1-概览" class="headerlink" title="7.2.1 概览"></a>7.2.1 概览</h4><p><img src="/images/《Go进阶训练营》学习笔记/播放历史架构设计-架构设计-概览.png" alt="播放历史架构设计-架构设计-概览"></p><ol><li><p>BFF: app-interface、history<br> 历史 BFF 层接受来自外部用户的读请求，依赖其他例如稿件、漫画服务来组装完整的面向历史业务（页面）需要的数据的组合。同时接受来自内部其他业务线的写请求，通常都是业务方自己进行业务 ID 的判定，然后投递到历史服务的 BFF 写接口中。最终 BFF 是打包在 app-interface 大杂烩 BFF 中，考虑到隔离性，读写流量很大，独立成 history BFF 服务。</p></li><li><p>Service: history-service<br> 服务层，去平台业务的逻辑，专注在历史数据的持久化上(因为对于播放类业务，BFF 专注平台业务数据组织，service 负责数据的读、写、删、清理等操作。播放进度是非常高频同步的，需要考虑性能优化)。</p><p> 使用 write-back 的思路，把状态数据先入分布式缓存，再回写数据库。</p></li><li><p>Job: history-job<br> job 消费上游 kafka 的数据，利用消息队列的堆积能力，对于存储层的差速(消费能力跟不上生产速度时)，可以进行一定的数据反压。配合上游 service 批量打包过来的数据持久化。</p></li><li><p>Upstream: some-app，some-api<br> 整个历史服务还会被一些外部 gRPC 服务所依赖，所以 history 还充当了内网的 gRPC Provider，这些上游服务，使用历史服务的写接口，把自己业务的数据进行持久化。</p></li></ol><p>历史服务最重要的设计，就是批量打包(pipeline)聚合数据。将高频、密集的写请求先入缓存(write-back)，批量消费减少对存储的直接压力，类似的设计随处可见。</p><h4 id="7-2-2-history-service"><a href="#7-2-2-history-service" class="headerlink" title="7.2.2 history-service"></a>7.2.2 history-service</h4><p><img src="/images/《Go进阶训练营》学习笔记/播放历史架构设计-架构设计-history-service.png" alt="播放历史架构设计-架构设计-history-service"></p><p>history-service，专注在历史数据处理。</p><ol><li><p>写的核心逻辑:<br> 用户观看的稿件、漫画等，带有进度信息的数据，同一个 id 最后一次的数据即可，即 last-write win，高频的用户端同步逻辑，只需要最后一次数据持久化即可。我们可以在 in-process 内存中，定时定量来聚合不同用户的“同一个对象的最后一次进度”，使用 kafka 消息队列来消除写入峰值。但同时我们需要保证用户数据可以实时被观察到，不能出现上报进度后，需要一阵子才能体现进度变化。所以我们即在内存中打包数据，同时实时写入到 redis 中，这样即保证了实时，又避免海量写入冲击存储。</p><p> kafka 是为高吞吐设计，超高频的写入并不是最优，所以内存聚合和分片算法比较重要，按照 uid 来sharding 数据，写放大仍然很大，这里我们使用 region sharding，打包一组数据当作一个 kafka message(比如 uid % 100数据打包)。</p><p> 写逻辑的数据流向: 实时写 redis -&gt; 内存维护用户数据 -&gt; 定时/定量写入到 kafka。</p></li><li><p>读的核心逻辑:</p><p> 历史数据，实时写入 redis 后，不会无限制的存储，会按量截断，所以分布式缓存中数据不是完整数据，</p><p> 历史数据从 redis sortedset 中读取后，如果发现尾部数据不足，会触发 cache-aside 模式，从存储中回捞数据，但是不会重新回填缓存，因为拉取过去更久远的数据，属于用户纬度的低频度行为。历史数据通常是按照 timeline 来组织，游标的 key 可以使用时间戳进行翻页或者下拉。</p></li></ol><h4 id="7-2-3-history-job"><a href="#7-2-3-history-job" class="headerlink" title="7.2.3 history-job"></a>7.2.3 history-job</h4><p>history-job，获取打包好的用户数据，进行批量持久化。</p><p>上游 history-service 按照 uid region sharding 聚合好的数据，在 job 中消费取出，为了节约传输过程，以及 history-service 的 in-process cache 的内存使用，我们只维护了用户的 uid 以及 id 列表，最小化存储和传输。因为数据是不完整的，我们额外需要从 redis 中按照 id 对应的数据内容，再持久化。从原来的 N 条记录变为一个用户一条记录。</p><p>对于存储的选型，我们认为 HBase 非常合适高密度写入。后续我们会单独讨论我们经历过的几次存储迭代和选型。</p><h4 id="7-2-4-history"><a href="#7-2-4-history" class="headerlink" title="7.2.4 history"></a>7.2.4 history</h4><p><img src="/images/《Go进阶训练营》学习笔记/播放历史架构设计-架构设计-history.png" alt="播放历史架构设计-架构设计-history"></p><p>history 作为 BFF，对用户端提供统一的用户记录记录入口接口，同时也对内提供 gRPC 写入历史接口。如果业务场景中不存在统一的用户入口访问历史记录，可以去掉 BFF 层，直接使用 history-service 提供读接口，这样需要每个业务方自己实现自己的数据组装。</p><p>我们也有类似用户首次播放、观看等加经验或者奖励积分类似的操作，所以我们这里依赖 redis，进行判定用户当天是否是首次访问，我们比较容易想到使用 bitmap 或者 bloom filter 来进行判断，然后往下游 kafka 投递消息，而不直接依赖业务的某个服务。</p><p>因为我们有关闭历史记录的功能，这样每次写入操作都需要前置读取一次，是否打开了开关，同样的每次首次发送奖励也是一样，你有更好的办法吗？</p><h3 id="7-3-存储设计"><a href="#7-3-存储设计" class="headerlink" title="7.3 存储设计"></a>7.3 存储设计</h3><h4 id="7-3-1-数据库设计"><a href="#7-3-1-数据库设计" class="headerlink" title="7.3.1 数据库设计"></a>7.3.1 数据库设计</h4><p><img src="/images/《Go进阶训练营》学习笔记/播放历史架构设计-存储设计-数据库设计.png" alt="播放历史架构设计-存储设计-数据库设计"></p><p>我们最早的主力存储选型是: HBase。</p><ol><li>数据写入:<br> PUT mid, values，只需要写入到 column_family 的 info 列簇，rowkey 使用用户 id md5 以后的头两位 + 用户，避免 rowkey 热点密集到一个 region 中，导致写/读热点。 对于 column_family: info，存储一个列 obj_id + obj_type，例如 稿件业务:1、稿件ID: 100，100_1 作为列名，对于 value 使用 protobuf 序列化一个结构体接入。所以只需要单次更新 kv store。另外我们使用 HBase TTL 的能力，只需要保存90天的用户数据即可。(删除同理)</li><li>数据读取:<br> 列表获取为 GET mid，直接获取1000条，在内存中排序和翻页。点查 GET mid columns，在茫茫多视频查看当前视频的阅读进度，cache miss 会非常严重，虽然支持点查，但是对于上层 cache miss 后，不再回源请求 HBase。</li></ol><h4 id="7-3-2-缓存设计"><a href="#7-3-2-缓存设计" class="headerlink" title="7.3.2 缓存设计"></a>7.3.2 缓存设计</h4><p><img src="/images/《Go进阶训练营》学习笔记/播放历史架构设计-存储设计-缓存设计.png" alt="播放历史架构设计-存储设计-缓存设计"></p><ol><li><p>数据写入:<br> 每次产生的历史数据，需要立马更新 redis，使用 sorted set 基于时间排序的列表，member 为业务 ID。同时存储一份数据到 redis string 中，使用 protobuf 序列化完整的数据内容。为了避免 redis 中单个用户数据无限增长，需要超过一定量后对数据进行截断。</p></li><li><p>数据读取:<br> 分为两个场景，一个是历史页面，这时候使用 sorted set，排序查找即可，拿到列表后，mget 批量获取 history_content 内容。</p></li></ol><p>另外一个是点查进度，比如我们点击进入一个视频详情页，这时候直接查找 history_content 进行点查，不再回源 HBase，因为命中率太低。</p><p>首次触发某行为，增加经验的，我们在缓存设计中，经常使用 bitmap(roaring bitmap)、bloom filter 缓存加速访问，但是在使用缓存时，需要注意规避热点问题，某个key sharding 命中 node 是固定的，因此我们可以利用构建多组 bitmap 或 bloom filter，来进行打散。</p><p>prefix_key = hash(mid) % 1000</p><p>根据 prefix_key 找到对应的 cache 再进行操作，这样 1000 个 key 尽可能均匀的分布到更小集合的 node，而不会产生数据热点。</p><p>但是仍然每次触发行为，都为前置判定，有更好的优化方案吗？</p><h3 id="7-4-可用性设计"><a href="#7-4-可用性设计" class="headerlink" title="7.4 可用性设计"></a>7.4 可用性设计</h3><h4 id="7-4-1-Write-Back"><a href="#7-4-1-Write-Back" class="headerlink" title="7.4.1 Write-Back"></a>7.4.1 Write-Back</h4><p><img src="/images/《Go进阶训练营》学习笔记/播放历史架构设计-可用性设计-Write-Back.png" alt="播放历史架构设计-可用性设计-Write-Back"></p><p>在 history-service 中实时写入 redis 数据，因此只需要重点优化缓存架构中，扛住峰值的流量写入。之后在服务内存中，使用 map[int]map[int]struct{} 聚合数据，之后利用 chan 在内部发送每个小消息，再聚合成一个大map，在 sendproc 中，使用 timer 和 定量判定逻辑，发送到下游 kafka 中。</p><p>在 history-job 中，获取消息后，重新去 redis 中回捞数据即: history-content，然后构建完整的数据批量写入到 HBase 中。</p><p>这里存在两个风险:</p><ol><li>history-service 重启过程中，预聚合的消息丢失；</li><li>history-job 读取 redis 构建数据，但 redis 丢失；</li></ol><p>我们在这里进行了 trade-off，高收敛比的设计，意味着存在数据丢失的风险，对于历史场景，非 L0 的业务服务/数据，我们认为极端情况下可接受。</p><h4 id="7-4-2-聚合"><a href="#7-4-2-聚合" class="headerlink" title="7.4.2 聚合"></a>7.4.2 聚合</h4><p>经过 BFF history 的流量 per-request 都会发送给 history-service，我们最容易想到的优化就是聚合上移来减少发送给下游的 rpc。但是按照 mid region sharding 的思路非常具有业务的耦合性，所以不应该把逻辑上移，而只是数据上移，所以可以考虑简单 batch put 请求，做一个无逻辑的数据聚合再发送给 history-service，这样可以大大的减少内网的流量，节约资源。</p><p>我们发现经过 API Gateway 的流量都会触发高频的 per-rpc auth，给内网的 identify-service 带来了不少压力。我们认为大部分历史行为通过心跳的方式同步进度，为何不连接一个长连接，长连接服务再握手后先进行用户级的身份验证，之后维持身份信息，而不是每次发送 request 都进行验证，这样可以大大减少内网的 identify-service 的流量。</p><p>我们内网使用 boardcast(goim) 服务维护长连接，长连接一次验证，不断使用。</p><h4 id="7-4-3-广播"><a href="#7-4-3-广播" class="headerlink" title="7.4.3 广播"></a>7.4.3 广播</h4><p>用户首次触发的行为，需要发送消息给下游系统进行触发其他奖励等。如何减少这类一天只用一次的标记位缓存请求？</p><p>使用 in-process localcache，只有高频的用户访问，带来的收益就越大，我们很容易想到使用 LRU 维护这个集合，但用户分布很广，很难覆盖，命中率很低。</p><p>越源头解决架构问题，通常越简单，效率越高。</p><p>我们在写操作(高频请求)中，把当前的 flag 返回到 API 协议中，作为一个日期值，客户端保存到本地，下次请求的时候带上，如果发现该值在，获取以后直接使用不再请求缓存，例如: 2021-1-1，发现当前时间还是2021-1-1，直接不再请求 redis，如果发现当前时间是2021-1-2，需要触发一次 redis 访问，返回新的 flag 到客户端，这样把状态广播同步到任何其他设备，可以大大减少判定缓存。</p><p>实现成本在于，你认为的代价高低。</p><h3 id="7-5-References"><a href="#7-5-References" class="headerlink" title="7.5 References"></a>7.5 References</h3><p><a href="https://en.wikipedia.org/wiki/Cache#Writing_Policies">https://en.wikipedia.org/wiki/Cache#Writing_Policies</a><br><a href="https://blog.csdn.net/jiaomeng/article/details/1495500">https://blog.csdn.net/jiaomeng/article/details/1495500</a><br><a href="https://blog.csdn.net/yizishou/article/details/78342499">https://blog.csdn.net/yizishou/article/details/78342499</a><br><a href="https://blog.csdn.net/caoshangpa/article/details/78783749">https://blog.csdn.net/caoshangpa/article/details/78783749</a></p><h2 id="第8课-分布式缓存和分布式事务"><a href="#第8课-分布式缓存和分布式事务" class="headerlink" title="第8课 分布式缓存和分布式事务"></a>第8课 分布式缓存和分布式事务</h2><h3 id="8-1-缓存选型"><a href="#8-1-缓存选型" class="headerlink" title="8.1 缓存选型"></a>8.1 缓存选型</h3><h4 id="8-1-1-memcache"><a href="#8-1-1-memcache" class="headerlink" title="8.1.1 memcache"></a>8.1.1 memcache</h4><p><img src="/images/《Go进阶训练营》学习笔记/分布式缓存-缓存选型-memcache.png" alt="分布式缓存-缓存选型-memcache"></p><p>memcache 提供简单的 kv cache 存储，value 大小不超过1mb。</p><p>我使用 memcache 作为大文本或者简单的 kv结构使用。</p><p>memcache 使用了slab 方式做内存管理，存在一定的浪费，如果大量接近的 item，建议调整 memcache 参数来优化每一个 slab 增长的 ratio、可以通过设置 slab_automove &amp; slab_reassign 开启memcache 的动态/手动 move slab，防止某些 slab 热点导致内存足够的情况下引发 LRU。</p><p>大部分情况下，简单 KV 推荐使用 Memcache，吞吐和相应都足够好。</p><p>每个 slab 包含若干大小为1M的内存页，这些内存又被分割成多个 chunk，每个 chunk存储一个 item；</p><p>在 memcache 启动初始化时，每个 slab 都预分配一个 1M 的内存页，由slabs_preallocate 完成(也可将相应代码注释掉关闭预分配功能)。</p><p>chunk 的增长因子由 -f 指定，默认1.25，起始大小为48字节。</p><p>内存池有很多种设计，可以参考下: nginx ngx_pool_t，tcmalloc 的设计等等。</p><h4 id="8-1-2-redis"><a href="#8-1-2-redis" class="headerlink" title="8.1.2 redis"></a>8.1.2 redis</h4><p>redis 有丰富的数据类型，支持增量方式的修改部分数据，比如排行榜，集合，数组等。</p><p>比较常用的方式是使用 redis 作为数据索引，比如评论的列表 ID，播放历史的列表 ID 集合，我们的关系链列表 ID。</p><p>redis 因为没有使用内存池，所以是存在一定的内存碎片的，一般会使用 jemalloc 来优化内存分配，需要编译时候使用 jemalloc 库代替 glib 的 malloc 使用。</p><h4 id="8-1-3-redis-vs-memcache"><a href="#8-1-3-redis-vs-memcache" class="headerlink" title="8.1.3 redis vs memcache"></a>8.1.3 redis vs memcache</h4><p><img src="/images/《Go进阶训练营》学习笔记/分布式缓存-缓存选型-redis-vs-memcache.png" alt="分布式缓存-缓存选型-redis-vs-memcache"></p><p>Redis 和 Memcache 最大的区别其实是 redis 单线程(新版本双线程)，memcache 多线程，所以 QPS 可能两者差异不大，但是吞吐会有很大的差别，比如大数据 value 返回的时候，redis qps 会抖动下降的的很厉害，因为单线程工作，其他查询进不来(新版本有不少的改善)。</p><p>所以建议纯 kv 都走 memcache，比如我们的关系链服务中用了 hashs 存储双向关系，但是我们也会使用 memcache 档一层来避免hgetall 导致的吞吐下降问题。</p><p>我们系统中多次使用 memcache + redis 双缓存设计。</p><blockquote><p>redis 6 已经支持了多线程的网络 IO 。</p><p>memcached 使用 slab 方式做内存管理，存在一定的浪费。如果有大量接近的 item，建议调整 memcache 参数来优化每一个 slab 增长的 ratio ，可以通过设置 <code>slab_automove</code> 和 <code>slab_reassign</code> 开启 memcached 的动态/手动 move slab，防止某些 slab 热点导致内存足够的情况下引发 LRU 。</p></blockquote><h4 id="8-1-4-Proxy"><a href="#8-1-4-Proxy" class="headerlink" title="8.1.4 Proxy"></a>8.1.4 Proxy</h4><p>早期使用 twemproxy 作为缓存代理，但是在使用上有如下一些痛点：</p><ul><li>单进程单线程模型和 redis 类似，在处理一些大 key 的时候可能出现 io 瓶颈；</li><li>二次开发成本难度高，难以于公司运维平台进行深度集成；</li><li>不支持自动伸缩，不支持 autorebalance 增删节点需要重启才能生效；</li><li>运维不友好，没有控制面板；</li></ul><p>业界开源的的其他代理工具：</p><ul><li>codis: 只支持 redis 协议，且需要使用 patch版本的 redis；</li><li>mcrouter: 只支持 memcache 协议，C 开发，与运维集成开发难度高；</li></ul><blockquote><p>现在推荐直接用redis cluster。</p></blockquote><p><img src="/images/《Go进阶训练营》学习笔记/分布式缓存-缓存选型-Proxy.png" alt="分布式缓存-缓存选型-Proxy"></p><p>从集中式访问缓存到 Sidecar 访问缓存：</p><ul><li>微服务强调去中心化；</li><li>LVS 运维困难，容易流量热点，随下游扩容而扩容，连接不均衡等问题；</li><li>Sidecar 伴生容器随 App 容器启动而启动，配置简化；</li></ul><h4 id="8-1-5-一致性Hash"><a href="#8-1-5-一致性Hash" class="headerlink" title="8.1.5 一致性Hash"></a>8.1.5 一致性Hash</h4><p><img src="/images/《Go进阶训练营》学习笔记/分布式缓存-缓存选型-一致性Hash.png" alt="分布式缓存-缓存选型-一致性Hash"><br><img src="/images/《Go进阶训练营》学习笔记/分布式缓存-缓存选型-一致性Hash-添加节点.png" alt="分布式缓存-缓存选型-一致性Hash-添加节点"></p><p>一致性 hash 是将数据按照特征值映射到一个首尾相接的 hash 环上，同时也将节点（按照 IP 地址或者机器名 hash）映射到这个环上。</p><p>对于数据，从数据在环上的位置开始，顺时针找到的第一个节点即为数据的存储节点。</p><p>余数分布式算法由于保存键的服务器会发生巨大变化而影响缓存的命中率，但Consistent Hashing 中，只有在园（continuum）上增加服务器的地点逆时针方向的第一台服务器上的键会受到影响。</p><ul><li>平衡性(Balance)：尽可能分布到所有的缓冲中去</li><li>单调性(Monotonicity)：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲区加入到系统中，那么哈希的结果应能够保证原有已分配的内容可以被映射到新的缓冲区中去，而不会被映射到旧的缓冲集合中的其他缓冲区。</li><li>分散性(Spread)：相同内容被存储到不同缓冲中去，降低了系统存储的效率，需要尽量降低分散性。</li><li>负载(Load)：哈希算法应能够尽量降低缓冲的负荷。</li><li>平滑性(Smoothness)：缓存服务器的数目平滑改变和缓存对象的平滑改变是一致的。</li></ul><p>一致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜问题。</p><p><img src="/images/《Go进阶训练营》学习笔记/分布式缓存-缓存选型-一致性Hash-虚拟节点.png" alt="分布式缓存-缓存选型-一致性Hash-虚拟节点"></p><p>此时必然造成大量数据集中到 Node A 上，而只有极少量会定位到 Node B 上。为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。</p><p>具体做法可以在服务器 ip 或主机名的后面增加编号来实现。</p><p>例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3” 的哈希值，于是形成六个虚拟节点。</p><p>同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到 “Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到 Node A 上。这样就解决了服务节点少时数据倾斜的问题。</p><p>参考微信红包的写合并优化： <a href="https://www.cnblogs.com/chinanetwind/articles/9460820.html">https://www.cnblogs.com/chinanetwind/articles/9460820.html</a></p><p>在网关层，使用一致性 hash，对红包 id 进行分片，命中到某一个逻辑服务器处理，在进程内做写操作的合并，减少存储层的单行锁争用。</p><p><img src="/images/《Go进阶训练营》学习笔记/分布式缓存-缓存选型-有界负载一致性hash.png" alt="分布式缓存-缓存选型-有界负载一致性hash"></p><p>我认为更好的做法是 有界负载一致性 hash。</p><h4 id="8-1-6-Hash"><a href="#8-1-6-Hash" class="headerlink" title="8.1.6 Hash"></a>8.1.6 Hash</h4><p>数据分片的 hash 方式也是这个思想，即按照数据的某一特征（key）来计算哈希值，并将哈希值与系统中的节点建立映射关系,从而将哈希值不同的数据分布到不同的节点上。</p><p>按照 hash 方式做数据分片，映射关系非常简单；需要管理的元数据也非常之少，只需要记录节点的数目以及 hash 方式就行了。</p><p>当加入或者删除一个节点的时候，大量的数据需要移动。比如在这里增加一个节点 N3，因此 hash 方式变为了 mod 4。</p><p>均衡问题：原始数据的特征值分布不均匀，导致大量的数据集中到一个物理节点上；第二，对于可修改的记录数据，单条记录的数据变大。</p><p>高级玩法是抽象 slot，基于 Hash 的 Slot Sharding，例如 Redis-Cluster。</p><h4 id="8-1-7-Slot"><a href="#8-1-7-Slot" class="headerlink" title="8.1.7 Slot"></a>8.1.7 Slot</h4><p><img src="/images/《Go进阶训练营》学习笔记/分布式缓存-缓存选型-Slot.png" alt="分布式缓存-缓存选型-Slot"></p><p>redis cluster 的做法：</p><p>1.把 16384 槽按照节点数量进行平均分配，由节点进行管理<br>2.对每个 key 按照 CRC16 规则进行 hash 运算<br>3.把 hash 结果对 16383 进行取余<br>4.把余数发送给 redis 节点<br>5.节点接收到数据，验证是否在自己管理的槽编号的范围<br>    如果在自己管理的槽编号范围内，则把数据保存到数据槽中，然后返回执行结果<br>    如果在自己管理的槽编号范围外，则会把数据发送给正确的节点，由正确的节点来把数据保存在对应的槽中</p><blockquote><p><code>16384 = (1&lt;&lt;14)</code> 。</p><p>Redis Cluster的节点之间会共享消息，每个节点都会知道是哪个节点负责哪个范围内的数据槽</p><p><a href="https://www.cnblogs.com/renpingsheng/p/9862485.html">高可用Redis(十二)：Redis Cluster</a></p></blockquote><h3 id="8-2-缓存模式"><a href="#8-2-缓存模式" class="headerlink" title="8.2 缓存模式"></a>8.2 缓存模式</h3><h4 id="8-2-1-数据一致性"><a href="#8-2-1-数据一致性" class="headerlink" title="8.2.1 数据一致性"></a>8.2.1 数据一致性</h4><p><img src="/images/《Go进阶训练营》学习笔记/分布式缓存-缓存模式-数据一致性.png" alt="分布式缓存-缓存模式-数据一致性"></p><p>Storage 和 Cache 同步更新容易出现数据不一致。</p><p>模拟 MySQL Slave 做数据复制，再把消息投递到 Kafka，保证至少一次消费：</p><ol><li>同步操作DB；</li><li>同步操作Cache；</li><li>利用Job消费消息，重新补偿一次缓存操作</li></ol><p>保证时效性和一致性。</p><p><img src="/images/《Go进阶训练营》学习笔记/分布式缓存-缓存模式-数据一致性-CacheAside模型.png" alt="分布式缓存-缓存模式-数据一致性-CacheAside模型"></p><p>Cache Aside 模型中，读缓存 Miss 的回填操作，和修改数据同步更新缓存，包括消息队列的异步补偿缓存，都无法满足 “Happens Before”，会存在相互覆盖的情况。</p><p><img src="/images/《Go进阶训练营》学习笔记/分布式缓存-缓存模式-数据一致性-CacheAside模型-错误的使用.png" alt="分布式缓存-缓存模式-数据一致性-CacheAside模型-错误的使用"></p><p>错误的使用：</p><ol><li>读操作，读缓存，缓存 MISS</li><li>读操作，读 DB，读取到数据</li><li>写操作，更新 DB 数据</li><li>写操作 SET/DELETE Cache（可 Job 异步操作）</li><li>读操作，SET操作数据回写缓存（可 Job 异步操作）</li></ol><p>这种交互下，由于4和5操作步骤都是设置缓存，导致写入的值互相覆盖；并且操作的顺序性不确定，从而导致 cache 存在脏缓存的情况。</p><p><img src="/images/《Go进阶训练营》学习笔记/分布式缓存-缓存模式-数据一致性-CacheAside模型-正确的使用.png" alt="分布式缓存-缓存模式-数据一致性-CacheAside模型-正确的使用"></p><p>正确的使用：</p><ol><li>读操作，读缓存，缓存 MISS</li><li>读操作，读 DB，读取到数据</li><li>写操作，更新 DB 数据</li><li>写操作 SET Cache（可异步 job 操作，Redis 可以使用 SETEX 操作）</li><li>读操作，ADD 操作数据回写缓存（可 Job异步操作，Redis 可以使用 SETNX 操作）</li><li>写操作使用 SET 操作命令，覆盖写缓存；读操作，使用 ADD 操作回写 MISS 数据，从而保证写操作的最新数据不会被读操作的回写数据覆盖。</li></ol><blockquote><ol><li><p>读操作流程</p><ol><li>从 Redis 读取数据，如果有就直接返回；</li><li>如果 Redis 中没有数据，从 MySQL 中读取数据；</li><li>将结果使用 <code>SETNX</code> 回填到 Redis 中，并返回数据。</li></ol></li><li><p>写操作流程</p><ol><li>直接更新 MySQL ；</li><li><p>删除或更新 Redis ；</p><p>用删除操作可能会导致缓存穿透问题，对热点数据不建议使用删除操作。</p><p>用更新操作可能会有 ABA 的问题，如：两次更新 v1 和 v2 ，缓存中的值会出现 v1 -&gt; v2 -&gt; v1 -&gt; v2 。</p></li><li><p>使用 Canal 解析 MySQL 的 binlog，将解析的结果投递到一个消息队列中（如：kafka），然后再消费该消息队列更新 Redis 来保证最终一致性。</p></li></ol></li></ol></blockquote><h4 id="8-2-2-多级缓存"><a href="#8-2-2-多级缓存" class="headerlink" title="8.2.2 多级缓存"></a>8.2.2 多级缓存</h4><p><img src="/images/《Go进阶训练营》学习笔记/分布式缓存-缓存模式-多级缓存.png" alt="分布式缓存-缓存模式-多级缓存.png"></p><p>微服务拆分细粒度原子业务下的整合服务（聚合服务），用于提供粗粒度的接口，以及二级缓存加速，减少扇出的 rpc 网络请求，减少延迟。</p><p>最重要是保证多级缓存的一致性：</p><ul><li>清理的优先级是有要求的，先优先清理下游再上游；</li><li>下游的缓存expire要大于上游，里面穿透回源；</li></ul><p>天下大势分久必合，适当的微服务合并也是不错的做法，再使用 DDD 思路以及我们介绍的目录结构组织方式，区分不同的 Usecase。</p><h4 id="8-2-3-热点缓存"><a href="#8-2-3-热点缓存" class="headerlink" title="8.2.3 热点缓存"></a>8.2.3 热点缓存</h4><p><img src="/images/《Go进阶训练营》学习笔记/分布式缓存-缓存模式-热点缓存.png" alt="分布式缓存-缓存模式-热点缓存"></p><p>对于热点缓存 Key，按照如下思路解决：</p><ul><li>小表广播，从 RemoteCache 提升为LocalCache，App 定时更新，甚至可以让运营平台支持广播刷新 LocalCache；</li><li>主动监控防御预热，比如直播房间页高在线情况下直接外挂服务主动防御；</li><li>基础库框架支持热点发现，自动短时的 short-live cache；</li><li>多 Cluster 支持；<ul><li>多 Key 设计: 使用多副本，减小节点热点的问题</li><li>使用多副本 ms_1,ms_2,ms_3 每个节点保存一份数据，使得请求分散到多个节点，避免单点热点问题。</li></ul></li></ul><p><img src="/images/《Go进阶训练营》学习笔记/分布式缓存-缓存模式-热点缓存-多Cluster.png" alt="分布式缓存-缓存模式-热点缓存-多Cluster.png"></p><p>建立多个 Cluster ，和微服务、存储等一起组成一个 Region。</p><p>这样相当于是用空间换时间：</p><p>同一个 key 在每一个 frontend cluster 都可能有一个 copy，这样会带来 consistency 的问题，但是这样能够降低 latency 和提高 availability。利用 MySQL Binlog 消息 anycast 到不同集群的某个节点清理或者更新缓存；</p><p>当业务频繁更新时候，cache频繁过期，会导致命中率低: stale sets</p><p>如果应用程序层可以忍受稍微过期一点的数据，针对这点可以进一步降低系统负载。当一个key 被删除的时候（delete 请求或者 cache 爆棚清空间了），它被放倒一个临时的数据结构里，会再续上比较短的一段时间。当有请求进来的时候会返回这个数据并标记为“Stale”。对于大部分应用场景而言，Stale Value 是可以忍受的。(需要改 memcache、redis 源码，或者基础库支持）；</p><blockquote><p>最好通过改 Redis 源码来实现，因为要高效的处理边缘情况（比如：该数据本身的过期时间已经比 10 秒小了)。</p></blockquote><h4 id="8-2-4-穿透缓存"><a href="#8-2-4-穿透缓存" class="headerlink" title="8.2.4 穿透缓存"></a>8.2.4 穿透缓存</h4><ul><li>singlefly<br>  对关键字进行一致性 hash，使其某一个维度的 key 一定命中某个节点，然后在节点内使用互斥锁，保证归并回源，但是对于批量查询无解；</li><li>分布式锁<br>  设置一个 lock key，有且只有一个人成功，并且返回，交由这个人来执行回源操作，其他候选者轮训 cache 这个 lock key，如果不存在去读数据缓存，hit 就返回，miss 继续抢锁；</li><li>队列<br>  如果 cache miss，交由队列聚合一个key，来 load 数据回写缓存，对于 miss 当前请求可以使用 singlefly 保证回源，如评论架构实现。适合回源加载数据重的任务，比如评论 miss 只返回第一页，但是需要构建完成评论数据索引。</li><li>lease<br>  通过加入 lease 机制，可以很好避免这两个问题，lease 是 64-bit 的 token，与客户端请求的 key 绑定，对于过时设置，在写入时验证 lease，可以解决这个问题；对于 thundering herd，每个key 10s 分配一次，当 client 在没有获取到 lease 时，可以稍微等一下再访问 cache，这时往往cache 中已有数据。（基础库支持 &amp; 修改 cache 源码）；</li></ul><h3 id="8-3-缓存技巧"><a href="#8-3-缓存技巧" class="headerlink" title="8.3 缓存技巧"></a>8.3 缓存技巧</h3><h4 id="8-3-1-Incast-Congestion"><a href="#8-3-1-Incast-Congestion" class="headerlink" title="8.3.1 Incast Congestion"></a>8.3.1 Incast Congestion</h4><p>如果在网路中的包太多，就会发生 Incast Congestion 的问题（可以理解为，network 有很多switch，router 啥的，一旦一次性发一堆包，这些包同时到达 switch，这些 switch 就会忙不过来）。</p><p>应对这个问题就是不要让大量包在同一时间发送出去，在客户端限制每次发出去的包的数量（具体实现就是客户端弄个队列）。</p><p>每次发送的包的数量称为“Window size”。这个值太小的话，发送太慢，自然延迟会变高；这个值太大，发送的包太多把 network switch 搞崩溃了，就可能发生比如丢包之类的情况，可能被当作 cache miss，这样延迟也会变高。所以这个值需要调，一般会在 proxy 层面实现。</p><h4 id="8-3-2-小技巧"><a href="#8-3-2-小技巧" class="headerlink" title="8.3.2 小技巧"></a>8.3.2 小技巧</h4><ul><li>易读性的前提下，key 设置尽可能小，减少资源的占用，redis value 可以用 int 就不要用string，对于小于 N 的 value，redis 内部有 shared_object 缓存。</li><li>拆分 key。主要是用在 redis 使用 hashes 情况下。同一个 hashes key 会落到同一个 redis 节点，hashes 过大的情况下会导致内存及请求分布的不均匀。考虑对 hash 进行拆分为小的hash，使得节点内存均匀及避免单节点请求热点。</li><li>空缓存设置。对于部分数据，可能数据库始终为空，这时应该设置空缓存，避免每次请求都缓存 miss 直接打到 DB。</li><li>空缓存保护策略。</li><li>读失败后的写缓存策略（降级后一般读失败不触发回写缓存）。</li><li>序列化使用 protobuf，尽可能减少 size。</li><li>工具化浇水代码</li></ul><p><img src="/images/《Go进阶训练营》学习笔记/分布式缓存-缓存技巧-工具化浇水代码.png" alt="分布式缓存-缓存技巧-工具化浇水代码"></p><h4 id="8-3-3-memcache-小技巧"><a href="#8-3-3-memcache-小技巧" class="headerlink" title="8.3.3 memcache 小技巧"></a>8.3.3 memcache 小技巧</h4><ul><li>flag 使用：标识 compress、encoding、large value 等；</li><li>memcache 支持 gets，尽量读取，尽可能的 pipeline，减少网络往返；</li><li>使用二进制协议，支持 pipeline delete，UDP 读取、TCP 更新；</li></ul><h4 id="8-3-4-redis-小技巧"><a href="#8-3-4-redis-小技巧" class="headerlink" title="8.3.4 redis 小技巧"></a>8.3.4 redis 小技巧</h4><ul><li>增量更新一致性：EXPIRE、ZADD/HSET 等，保证索引结构体务必存在的情况下去操作新增数据；</li><li>BITSET: 存储每日登陆用户，单个标记位置（boolean），为了避免单个 BITSET 过大或者热点，需要使用 region sharding，比如按照mid求余 %和/ 10000，商为 KEY、余数- 作为offset；</li><li>List:抽奖的奖池、顶弹幕，用于类似 Stack PUSH/POP操作；</li><li>Sortedset: 翻页、排序、有序的集合，杜绝 zrange 或者 zrevrange 返回的集合过大；<blockquote><p>Sortedset 的 score 是 double 类型，不能存放下 int64，注意不要溢出了。</p></blockquote></li><li>Hashs: 过小的时候会使用压缩列表、过大的情况容易导致 rehash 内存浪费，也杜绝返回hgetall，对于小结构体，建议直接使用 memcache KV；</li><li>String: SET 的 EX/NX 等 KV 扩展指令，SETNX 可以用于分布式锁、SETEX 聚合了SET + EXPIRE；</li><li>Sets: 类似 Hashs，无 Value，去重等；</li><li>尽可能的 PIPELINE 指令，但是避免集合过大；</li><li>避免超大 Value；</li></ul><h3 id="8-4-References"><a href="#8-4-References" class="headerlink" title="8.4 References"></a>8.4 References</h3><p><a href="https://blog.csdn.net/chen_kkw/article/details/82724330">https://blog.csdn.net/chen_kkw/article/details/82724330</a><br><a href="https://zhuanlan.zhihu.com/p/328728595">https://zhuanlan.zhihu.com/p/328728595</a><br><a href="https://www.cnblogs.com/chinanetwind/articles/9460820.html">https://www.cnblogs.com/chinanetwind/articles/9460820.html</a><br><a href="https://medium.com/vimeo-engineering-blog/improving-load-balancing-with-a-new-consistent-hashing-algorithm-9f1bd75709ed">https://medium.com/vimeo-engineering-blog/improving-load-balancing-with-a-new-consistent-hashing-algorithm-9f1bd75709ed</a><br><a href="https://www.jianshu.com/p/5fa447c60327">https://www.jianshu.com/p/5fa447c60327</a><br><a href="https://writings.sh/post/consistent-hashing-algorithms-part-1-the-problem-and-the-concept">https://writings.sh/post/consistent-hashing-algorithms-part-1-the-problem-and-the-concept</a><br><a href="https://www.cnblogs.com/williamjie/p/11132211.html">https://www.cnblogs.com/williamjie/p/11132211.html</a></p><h3 id="8-5-分布式事务"><a href="#8-5-分布式事务" class="headerlink" title="8.5 分布式事务"></a>8.5 分布式事务</h3><h4 id="8-5-1-转账问题"><a href="#8-5-1-转账问题" class="headerlink" title="8.5.1 转账问题"></a>8.5.1 转账问题</h4><p><img src="/images/《Go进阶训练营》学习笔记/分布式事务-转账问题.png" alt="分布式事务-转账问题"></p><p>讲到事务，又得搬出经典的转账问题了：</p><ol><li>支付宝账户表：A (id, user_id, amount)</li><li>余额宝账户表：B (id, user_id, amount)</li></ol><p>用户的 user_id = 1，从支付宝转帐1万快到余额宝分为两个步骤：</p><ol><li>支付宝表扣除1万：<br> UPDATE A SET amount = amount - 10000 WHERE user_id = 1;</li><li>余额宝表增加1万：<br> UPDATE B SET amount = amount + 10000 WHERE user_id = 1;</li></ol><p>如何保证数据一致性呢？</p><p>单个数据库，我们保证 ACID 使用 数据库事务。</p><h4 id="8-5-2-微服务架构下转账问题"><a href="#8-5-2-微服务架构下转账问题" class="headerlink" title="8.5.2 微服务架构下转账问题"></a>8.5.2 微服务架构下转账问题</h4><p><img src="/images/《Go进阶训练营》学习笔记/分布式事务-微服务架构下转账问题.png" alt="分布式事务-微服务架构下转账问题"></p><p>随着我们系统变大，我们进行了微服务架构的改造，因为每个微服务独占了一个数据库实例，从 user_id = 1 发起的转帐动作，跨越了两个微服务：pay 和 balance 服务。<br>我们需要保证，跨多个服务的步骤数据一致性：</p><ol><li>微服务 pay 的支付宝表扣除1万；</li><li>微服务 balance 的余额宝表增加1万；</li></ol><p>每个系统都对应一个独立的数据源，且可能位于不同机房，同时调用多个系统的服务很难保证同时成功，这就是跨服务分布式事务问题。</p><p>我们系统应该能保证每个服务自身的 ACID，基于这个假设，我们事务消息解决分布式事务问题。</p><h4 id="8-5-3-事务消息"><a href="#8-5-3-事务消息" class="headerlink" title="8.5.3 事务消息"></a>8.5.3 事务消息</h4><p><img src="/images/《Go进阶训练营》学习笔记/分布式事务-事务消息.png" alt="分布式事务-事务消息.png"></p><p>在北京很有名的姚记炒肝点了炒肝并付了钱后，他们并不会直接把你点的炒肝给你，往往是给你一张小票，然后让你拿着小票到出货区排队去取。</p><p>为什么他们要将付钱和取货两个动作分开呢？原因很多，其中一个很重要的原因是为了使他们接待能力增强（并发量更高）。</p><p>只要这张小票在，你最终是能拿到炒肝的。同理转账服务也是如此。</p><p>当支付宝账户扣除1万后，我们只要生成一个凭证（消息）即可，这个凭证（消息）上写着“让余额宝账户增加 1万”，只要这个凭证（消息）能可靠保存，我们最终是可以拿着这个凭证（消息）让余额宝账户增加1万的，即我们能依靠这个凭证（消息）完成最终一致性。</p><p>如何可靠的保存消息凭证？</p><p>要解决消息可靠存储，我们实际上需要解决的问题是，本地的 mysql 存储和 message 存储的一致性问题。</p><ul><li>Transactional outbox</li><li>Polling publisher</li><li>Transaction log tailing</li><li>2PC Message Queue</li></ul><p>事务消息一旦被可靠的持久化，我们整个分布式事务，变为了最终一致性，消息的消费才能保障最终业务数据的完整性，所以我们要尽最大努力，把消息送达到下游的业务消费方，称为：Best Effort。只有消息被消费，整个交易才能算是完整完结。</p><h4 id="8-5-4-Best-Effort"><a href="#8-5-4-Best-Effort" class="headerlink" title="8.5.4 Best Effort"></a>8.5.4 Best Effort</h4><p><img src="/images/《Go进阶训练营》学习笔记/分布式事务-BestEffort.png" alt="分布式事务-BestEffort"></p><p>即尽最大努力交付，主要用于在这样一种场景：不同的服务平台之间的事务性保证。</p><p>比如我们在电商购物，使用支付宝支付；又比如玩网游的时候，通过 App Store 充值。</p><p>拿购物为例，电商平台与支付平台是相互独立的，隶属于不同的公司，即使是同一个公司也很可能是独立的部门。</p><p>“ 做过支付宝交易接口的同学都知道，我们一般会在支付宝的回调页面和接口里，解密参数，然后调用系统中更新交易状态相关的服务，将订单更新为付款成功。</p><p>同时，只有当我们回调页面中输出了success 字样或者标识业务处理成功相应状态码时，支付宝才会停止回调请求。否则，支付宝会每间隔一段时间后，再向客户方发起回调请求，直到输出成功标识为止。”</p><h4 id="8-5-5-Transactional-outbox"><a href="#8-5-5-Transactional-outbox" class="headerlink" title="8.5.5 Transactional outbox"></a>8.5.5 Transactional outbox</h4><p><img src="/images/《Go进阶训练营》学习笔记/分布式事务-Transactionaloutbox.png" alt="分布式事务-Transactionaloutbox.png"></p><p>Transactional outbox，支付宝在完成扣款的同时，同时记录消息数据，这个消息数据与业务数据保存在同一数据库实例里（消息记录表表名为 msg）。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">BEGIN</span> <span class="token keyword">TRANSACTION</span>    <span class="token keyword">UPDATE</span> A <span class="token keyword">SET</span> amount <span class="token operator">=</span> amount <span class="token operator">-</span> <span class="token number">10000</span> <span class="token keyword">WHERE</span> user_id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> msg<span class="token punctuation">(</span>user_id<span class="token punctuation">,</span> amount<span class="token punctuation">,</span> <span class="token keyword">status</span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">END</span> <span class="token keyword">TRANSACTION</span><span class="token keyword">COMMIT</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述事务能保证只要支付宝账户里被扣了钱，消息一定能保存下来。当上述事务提交成功后，我们想办法将此消息通知余额宝，余额宝处理成功后发送回复成功消息，支付宝收到回复后删除该条消息数据。</p><h4 id="8-5-6-Polling-publisher"><a href="#8-5-6-Polling-publisher" class="headerlink" title="8.5.6 Polling publisher"></a>8.5.6 Polling publisher</h4><p><img src="/images/《Go进阶训练营》学习笔记/分布式事务-Pollingpublisher.png" alt="分布式事务-Pollingpublisher"></p><p>Polling publisher，我们定时的轮训 msg 表，把 status = 1 的消息统统拿出来消费，可以按照自增 id 排序，保证顺序消费。在这里我们独立了一个  pay_task 服务，把拖出来的消息 publish 给我们消息队列，balance 服务自己来消费队列，或者直接 rpc 发送给 balance 服务。</p><p>实际我们第一个版本的 archive-service 在使用 CQRS 时，就用的这个模型，Pull 的模型，从延迟来说不够好，Pull 太猛对 Database 有一定压力，Pull 频次低了，延迟比较高。</p><h4 id="8-5-6-Transaction-log-tailing"><a href="#8-5-6-Transaction-log-tailing" class="headerlink" title="8.5.6 Transaction log tailing"></a>8.5.6 Transaction log tailing</h4><p><img src="/images/《Go进阶训练营》学习笔记/分布式事务-Transactionlogtailing.png" alt="分布式事务-Transactionlogtailing"></p><p>Transaction log tailing，上述保存消息的方式使得消息数据和业务数据紧耦合在一起，从架构上看不够优雅，而且容易诱发其他问题。</p><p>有一些业务场景，可以直接使用主表被 canal 订阅使用，有一些业务场景自带这类 message 表，比如订单或者交易流水，可以直接使用这类流水表作为 message 表使用。</p><p>使用 canal 订阅以后，是实时流式消费数据，在消费者 balance 或者 balance-job 必须努力送达到。</p><p>我们发现，所有努力送达的模型，必须是先预扣（预占资源）的做法。</p><h4 id="8-5-7-幂等"><a href="#8-5-7-幂等" class="headerlink" title="8.5.7 幂等"></a>8.5.7 幂等</h4><p><img src="/images/《Go进阶训练营》学习笔记/分布式事务-幂等.png" alt="分布式事务-幂等"></p><p>还有一个很严重的问题就是消息重复投递，如果相同的消息被重复投递两次，那么我们余额宝账户将会增加2万而不是1万了。</p><p>为什么相同的消息会被重复投递？比如余额宝处理完消息 msg 后，发送了处理成功的消息给支付宝，正常情况下支付宝应该要删除消息msg，但如果支付宝这时候悲剧的挂了，重启后一看消息 msg 还在，就会继续发送消息 msg。</p><ul><li>全局唯一 ID+ 去重表<br>  在余额宝这边增加消息应用状态表 msg_apply，通俗来说就是个账本，用于记录消息的消费情况，每次来一个消息，在真正执行之前，先去消息应用状态表中查询一遍，如果找到说明是重复消息，丢弃即可，如果没找到才执行，同时插入到消息应用状态表（同一事务）。</li><li>版本号</li></ul><h4 id="8-5-8-2PC"><a href="#8-5-8-2PC" class="headerlink" title="8.5.8 2PC"></a>8.5.8 2PC</h4><p><img src="/images/《Go进阶训练营》学习笔记/分布式事务-2PC.png" alt="分布式事务-2PC.png"></p><p>两阶段提交协议(Two Phase Commitment Protocol)中，涉及到两种角色</p><ul><li>一个事务协调者（coordinator）：负责协调多个参与者进行事务投票及提交(回滚)</li><li>多个事务参与者（participants）：即本地事务执行者</li></ul><p>总共处理步骤有两个</p><ol><li>投票阶段（voting phase）：协调者将通知事务参与者准备提交或取消事务，然后进入表决过程。参与者将告知协调者自己的决策：同意（事务参与者本地事务执行成功，但未提交）或取消（本地事务执行故障）；</li><li>提交阶段（commit phase）：收到参与者的通知后，协调者再向参与者发出通知，根据反馈情况决定各参与者是否要提交还是回滚；</li></ol><h4 id="8-5-9-2PC-Message-Queue"><a href="#8-5-9-2PC-Message-Queue" class="headerlink" title="8.5.9 2PC Message Queue"></a>8.5.9 2PC Message Queue</h4><p><img src="/images/《Go进阶训练营》学习笔记/分布式事务-2PCMessageQueue.png" alt="分布式事务-2PCMessageQueue.png"></p><h4 id="8-5-10-Seata-2PC"><a href="#8-5-10-Seata-2PC" class="headerlink" title="8.5.10 Seata 2PC"></a>8.5.10 Seata 2PC</h4><p><img src="/images/《Go进阶训练营》学习笔记/分布式事务-Seata2PC.png" alt="分布式事务-Seata2PC"></p><p>Seata 实现 2PC 与传统 2PC 的差别</p><ul><li>架构层次方面：传统 2PC 方案的 RM 实际上是在数据库层，RM 本质上就是数据库自身，通过 XA 协议实现，而 Seata 的 RM 是以 jar 包的形式作为中间件层部署在应用程序这一侧的。</li><li>两阶段提交方面：传统 2PC无论第二阶段的决议是 commit 还是 rollback ，事务性资源的锁都要保持到 Phase2 完成才释放。而 Seata 的做法是在 Phase1 就将本地事务提交，这样就可以省去 Phase2 持锁的时间，整体提高效率。</li></ul><h3 id="8-5-11-TCC"><a href="#8-5-11-TCC" class="headerlink" title="8.5.11 TCC"></a>8.5.11 TCC</h3><p><img src="/images/《Go进阶训练营》学习笔记/分布式事务-TCC.png" alt="分布式事务-TCC"></p><p>TCC 是 Try、Conﬁrm、Cancel 三个词语的缩写，TCC 要求每个分支事务实现三个操作：预处理 Try、确认 Conﬁrm、撤销 Cancel。</p><p>Try 操作做业务检查及资源预留，Conﬁrm 做业务确认操作，Cancel 实现一个与 Try 相反的操作即回滚操作。</p><p>TM 首先发起所有的分支事务的 Try 操作，任何一个分支事务的 Try 操作执行失败，TM 将会发起所有分支事务的 Cancel 操作，若 Try 操作全部成功，TM 将会发起所有分支事务的 Conﬁrm 操作，其中 Conﬁrm/Cancel 操作若执行失败，TM 会进行重试。</p><p>需要注意：</p><ul><li>空回滚</li><li>防悬挂</li></ul><h3 id="8-6-微服务"><a href="#8-6-微服务" class="headerlink" title="8.6 微服务"></a>8.6 微服务</h3><ul><li>Event sourcing</li><li>Saga</li></ul><h3 id="8-7-References"><a href="#8-7-References" class="headerlink" title="8.7 References"></a>8.7 References</h3><p><a href="https://blog.csdn.net/hosaos/article/details/89136666">https://blog.csdn.net/hosaos/article/details/89136666</a><br><a href="https://zhuanlan.zhihu.com/p/183753774">https://zhuanlan.zhihu.com/p/183753774</a><br><a href="https://www.cnblogs.com/dyzcs/p/13780668.html">https://www.cnblogs.com/dyzcs/p/13780668.html</a><br><a href="https://blog.csdn.net/bjweimengshu/article/details/79607522">https://blog.csdn.net/bjweimengshu/article/details/79607522</a><br><a href="https://microservices.io/patterns/data/event-sourcing.html">https://microservices.io/patterns/data/event-sourcing.html</a><br><a href="https://microservices.io/patterns/data/saga.html">https://microservices.io/patterns/data/saga.html</a><br><a href="https://microservices.io/patterns/data/polling-publisher.html">https://microservices.io/patterns/data/polling-publisher.html</a><br><a href="https://microservices.io/patterns/data/polling-publisher.html">https://microservices.io/patterns/data/polling-publisher.html</a><br><a href="https://microservices.io/patterns/data/transaction-log-tailing.html">https://microservices.io/patterns/data/transaction-log-tailing.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客时间 </tag>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>epoll、select和poll源码简析</title>
      <link href="epoll-select-he-poll-yuan-ma-jian-xi/"/>
      <url>epoll-select-he-poll-yuan-ma-jian-xi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文使用的 Linux 内核版本为 4.19.194 。</p></blockquote><h2 id="一、epoll-create-系统调用"><a href="#一、epoll-create-系统调用" class="headerlink" title="一、epoll_create 系统调用"></a>一、epoll_create 系统调用</h2><ol><li><p>系统调用 <code>epoll_create1</code> 和 <code>epoll_create</code> 的定义分别位于 <code>fs/eventpoll.c</code> 文件中的 1979 行和 1984 行。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE1</span><span class="token punctuation">(</span>epoll_create1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">do_epoll_create</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">SYSCALL_DEFINE1</span><span class="token punctuation">(</span>epoll_create<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">do_epoll_create</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>主要工作就是调用 <code>do_epoll_create</code> 函数。</li></ol><h3 id="1-1-do-epoll-create-函数"><a href="#1-1-do-epoll-create-函数" class="headerlink" title="1.1 do_epoll_create 函数"></a>1.1 do_epoll_create 函数</h3><ol><li><p>函数 <code>do_epoll_create</code> 的定义位于 <code>fs/eventpoll.c</code> 文件中的 1936 行。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/** Open an eventpoll file descriptor.*/</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">do_epoll_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> flags<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>首先，对传入的 <code>flags</code> 参数做简单的验证。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Check the EPOLL_* constant for consistency.  */</span><span class="token function">BUILD_BUG_ON</span><span class="token punctuation">(</span>EPOLL_CLOEXEC <span class="token operator">!=</span> O_CLOEXEC<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> <span class="token operator">~</span>EPOLL_CLOEXEC<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>然后，申请分配 <code>eventpoll</code> 所需的内存并初始化。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token operator">*</span>ep <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">/** Create the internal data structure ("struct eventpoll").*/</span>error <span class="token operator">=</span> <span class="token function">ep_alloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>error <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> error<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>接下来，分配一个空闲的文件描述符 <code>fd</code> 和匿名文件 <code>file</code> 。注意，<code>eventpoll</code> 实例会保存一份匿名文件的引用，并通过调用 <code>fd_install</code> 将文件描述符和匿名文件关联起来。</p><p> 另外还需注意 <code>anon_inode_getfile</code> 调用时将 <code>eventpoll</code> 作为匿名文件的 <code>private_data</code> 保存了起来。后面就可以通过 <code>epoll</code> 实例的文件描述符快速的找到 <code>eventpoll</code> 对象。</p><p> 最后，将文件描述符 <code>fd</code> 作为 epoll 的句柄返回给调用者。<strong><code>epoll</code> 实例其实就是一个匿名文件。</strong></p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/** Creates all the items needed to setup an eventpoll file. That is,* a file structure and a free file descriptor.*/</span>fd <span class="token operator">=</span> <span class="token function">get_unused_fd_flags</span><span class="token punctuation">(</span>O_RDWR <span class="token operator">|</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> O_CLOEXEC<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    error <span class="token operator">=</span> fd<span class="token punctuation">;</span>    <span class="token keyword">goto</span> out_free_ep<span class="token punctuation">;</span><span class="token punctuation">}</span>file <span class="token operator">=</span> <span class="token function">anon_inode_getfile</span><span class="token punctuation">(</span><span class="token string">"[eventpoll]"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>eventpoll_fops<span class="token punctuation">,</span> ep<span class="token punctuation">,</span>            O_RDWR <span class="token operator">|</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> O_CLOEXEC<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    error <span class="token operator">=</span> <span class="token function">PTR_ERR</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">goto</span> out_free_fd<span class="token punctuation">;</span><span class="token punctuation">}</span>ep<span class="token operator">-&gt;</span>file <span class="token operator">=</span> file<span class="token punctuation">;</span><span class="token function">fd_install</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> file<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> fd<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="二、epoll-ctl-系统调用"><a href="#二、epoll-ctl-系统调用" class="headerlink" title="二、epoll_ctl 系统调用"></a>二、epoll_ctl 系统调用</h2><ol><li><p>系统调用 <code>epoll_ctl</code> 的定义位于 <code>fs/eventpoll.c</code> 文件中的 1997 行。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/** The following function implements the controller interface for* the eventpoll file that enables the insertion/removal/change of* file descriptors inside the interest set.*/</span><span class="token function">SYSCALL_DEFINE4</span><span class="token punctuation">(</span>epoll_ctl<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span>        <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> event<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>首先，获取 <code>epoll</code> 实例对应的匿名文件。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c">f <span class="token operator">=</span> <span class="token function">fdget</span><span class="token punctuation">(</span>epfd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>f<span class="token punctuation">.</span>file<span class="token punctuation">)</span>    <span class="token keyword">goto</span> error_return<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>然后，获得添加的套接字对应的文件。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Get the "struct file *" for the target file */</span>tf <span class="token operator">=</span> <span class="token function">fdget</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tf<span class="token punctuation">.</span>file<span class="token punctuation">)</span>    <span class="token keyword">goto</span> error_fput<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>接着，进行一系列的数据验证，保存用户传入的参数是合法的。</p><p> 判断待处理的文件有没有实现 <code>poll</code> 接口，使用 <code>epoll</code> 监听的资源需要实现 <code>poll</code> 钩子。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* The target file descriptor must support poll */</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">file_can_poll</span><span class="token punctuation">(</span>tf<span class="token punctuation">.</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">goto</span> error_tgt_fput<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 保证被操作的 <code>fd</code> 不是自己，并且自己是 <code>epoll</code> 。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* * We have to check that the file structure underneath the file descriptor * the user passed to us _is_ an eventpoll file. And also we do not permit * adding an epoll file descriptor inside itself. */</span><span class="token keyword">if</span> <span class="token punctuation">(</span>f<span class="token punctuation">.</span>file <span class="token operator">==</span> tf<span class="token punctuation">.</span>file <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">is_file_epoll</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">goto</span> error_tgt_fput<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果获得的是一个真正的 <code>epoll</code> 实例句柄，就通过匿名文件的 <code>private_data</code> 获取之前创建的 <code>eventpoll</code> 实例。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token operator">*</span>ep<span class="token punctuation">;</span><span class="token comment">/* * At this point it is safe to assume that the "private_data" contains * our own data structure. */</span>ep <span class="token operator">=</span> f<span class="token punctuation">.</span>file<span class="token operator">-&gt;</span>private_data<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在 <code>eventpoll</code> 实例里的中查找待添加的套接字。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">epitem</span> <span class="token operator">*</span>epi<span class="token punctuation">;</span><span class="token comment">/* * Try to lookup the file inside our RB tree, Since we grabbed "mtx" * above, we can be sure to be able to use the item looked up by * ep_find() till we release the mutex. */</span>epi <span class="token operator">=</span> <span class="token function">ep_find</span><span class="token punctuation">(</span>ep<span class="token punctuation">,</span> tf<span class="token punctuation">.</span>file<span class="token punctuation">,</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <code>eventpoll</code> 实例中通过红黑树跟踪了当前监听的所有文件的描述符，而红黑树的根就保存在 <code>eventpoll</code> 中。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token punctuation">{</span>    <span class="token comment">/* RB tree root used to store monitored fd structs */</span>    <span class="token keyword">struct</span> <span class="token class-name">rb_root_cached</span> rbr<span class="token punctuation">;</span>    <span class="token comment">// ...</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 对于每个被监听的文件描述符，都有一个的 <code>epitem</code> 与之对应，<code>epitem</code> 就作为红黑树的节点保存在红黑树中。作为二叉树的节点，<code>epitem</code> 必须提供比较能力，以便可以按照大小顺序构建出一颗有序的二叉树。其排序能力是靠 <code>epitem</code> 中的 <code>epoll_filefd</code> 结构体来完成的。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">epitem</span> <span class="token punctuation">{</span>    <span class="token comment">/* The file descriptor information this item refers to */</span>    <span class="token keyword">struct</span> <span class="token class-name">epoll_filefd</span> ffd<span class="token punctuation">;</span>    <span class="token comment">//...</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">epoll_filefd</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">;</span>    <span class="token keyword">int</span> fd<span class="token punctuation">;</span><span class="token punctuation">}</span> __packed<span class="token punctuation">;</span><span class="token comment">/* Compare RB tree keys */</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">ep_cmp_ffd</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">epoll_filefd</span> <span class="token operator">*</span>p1<span class="token punctuation">,</span>                <span class="token keyword">struct</span> <span class="token class-name">epoll_filefd</span> <span class="token operator">*</span>p2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>p1<span class="token operator">-&gt;</span>file <span class="token operator">&gt;</span> p2<span class="token operator">-&gt;</span>file <span class="token operator">?</span> <span class="token operator">+</span><span class="token number">1</span><span class="token operator">:</span>            <span class="token punctuation">(</span>p1<span class="token operator">-&gt;</span>file <span class="token operator">&lt;</span> p2<span class="token operator">-&gt;</span>file <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> p1<span class="token operator">-&gt;</span>fd <span class="token operator">-</span> p2<span class="token operator">-&gt;</span>fd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <code>epoll_filefd</code> 之间的比较首先按照文件地址大小排序。如果文件地址大小相同，就按照文件描述符的大小来排序。</p></li><li><p>在进行完红黑树查找后，如果是一个 ADD 操作，并且在树中没有找到对应的二叉树节点的话，就会调用 <code>ep_insert</code> 添加。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">case</span> EPOLL_CTL_ADD<span class="token operator">:</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>epi<span class="token punctuation">)</span> <span class="token punctuation">{</span>        epds<span class="token punctuation">.</span>events <span class="token operator">|=</span> EPOLLERR <span class="token operator">|</span> EPOLLHUP<span class="token punctuation">;</span>        error <span class="token operator">=</span> <span class="token function">ep_insert</span><span class="token punctuation">(</span>ep<span class="token punctuation">,</span> <span class="token operator">&amp;</span>epds<span class="token punctuation">,</span> tf<span class="token punctuation">.</span>file<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> full_check<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span>        error <span class="token operator">=</span> <span class="token operator">-</span>EEXIST<span class="token punctuation">;</span>    <span class="token keyword">break</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="2-1-ep-insert-函数"><a href="#2-1-ep-insert-函数" class="headerlink" title="2.1 ep_insert 函数"></a>2.1 ep_insert 函数</h3><ol><li><p>函数 <code>ep_insert</code> 的定义位于 <code>fs/eventpoll.c</code> 文件中的 1418 行。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/** Must be called with "mtx" held.*/</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ep_insert</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token operator">*</span>ep<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>event<span class="token punctuation">,</span>            <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>tfile<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> full_check<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>首先，判断当前监控的文件数量是否超过了 <code>/proc/sys/fs/epoll/max_user_watches</code> 中预设的最大值，如果超过了就返回错误。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c">user_watches <span class="token operator">=</span> <span class="token function">atomic_long_read</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-&gt;</span>user<span class="token operator">-&gt;</span>epoll_watches<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>user_watches <span class="token operator">&gt;=</span> max_user_watches<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">-</span>ENOSPC<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>然后分配 <code>epitem</code> 对象并初始化。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">epitem</span> <span class="token operator">*</span>epi<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>epi <span class="token operator">=</span> <span class="token function">kmem_cache_alloc</span><span class="token punctuation">(</span>epi_cache<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">-</span>ENOMEM<span class="token punctuation">;</span><span class="token comment">/* Item initialization follow here ... */</span><span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>epi<span class="token operator">-&gt;</span>rdllink<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>epi<span class="token operator">-&gt;</span>fllink<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>epi<span class="token operator">-&gt;</span>pwqlist<span class="token punctuation">)</span><span class="token punctuation">;</span>epi<span class="token operator">-&gt;</span>ep <span class="token operator">=</span> ep<span class="token punctuation">;</span><span class="token function">ep_set_ffd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>epi<span class="token operator">-&gt;</span>ffd<span class="token punctuation">,</span> tfile<span class="token punctuation">,</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>epi<span class="token operator">-&gt;</span>event <span class="token operator">=</span> <span class="token operator">*</span>event<span class="token punctuation">;</span>epi<span class="token operator">-&gt;</span>nwait <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>epi<span class="token operator">-&gt;</span>next <span class="token operator">=</span> EP_UNACTIVE_PTR<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 将 <code>epitem</code> 对象和目标文件 <code>tfile</code> 关联起来，并把 <code>epitem</code> 对象添加到 <code>eventpoll</code> 对象里的红黑树中。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Add the current item to the list of active epoll hook for this file */</span><span class="token function">spin_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tfile<span class="token operator">-&gt;</span>f_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">list_add_tail_rcu</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>epi<span class="token operator">-&gt;</span>fllink<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tfile<span class="token operator">-&gt;</span>f_ep_links<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tfile<span class="token operator">-&gt;</span>f_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* * Add the current item to the RB tree. All RB tree operations are * protected by "mtx", and ep_insert() is called with "mtx" held. */</span><span class="token function">ep_rbtree_insert</span><span class="token punctuation">(</span>ep<span class="token punctuation">,</span> epi<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>为加入的文件描述符设置回调函数 <code>ep_poll_callback</code>。如果对应的文件描述符上有事件发生，就会调用这个回调函数，比如套接字缓冲区有数据时，就会回调这个函数。而 <code>ep_poll_callback</code> 这个回调函数的设置是通过回调函数 <code>ep_ptable_queue_proc</code> 来完成的。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">ep_pqueue</span> epq<span class="token punctuation">;</span><span class="token comment">/* Initialize the poll table using the queue callback */</span>epq<span class="token punctuation">.</span>epi <span class="token operator">=</span> epi<span class="token punctuation">;</span><span class="token function">init_poll_funcptr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>epq<span class="token punctuation">.</span>pt<span class="token punctuation">,</span> ep_ptable_queue_proc<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <code>init_poll_funcptr</code> 函数的定义如下：</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">init_poll_funcptr</span><span class="token punctuation">(</span>poll_table <span class="token operator">*</span>pt<span class="token punctuation">,</span> poll_queue_proc qproc<span class="token punctuation">)</span><span class="token punctuation">{</span>    pt<span class="token operator">-&gt;</span>_qproc <span class="token operator">=</span> qproc<span class="token punctuation">;</span>    pt<span class="token operator">-&gt;</span>_key   <span class="token operator">=</span> <span class="token operator">~</span><span class="token punctuation">(</span>__poll_t<span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">/* all events enabled */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 需要注意的是，<code>init_poll_funcptr</code> 注册了所有的事件。</p><p> <code>ep_ptable_queue_proc</code> 函数的定义如下：</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/** This is the callback that is used to add our wait queue to the* target file wakeup lists.*/</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">ep_ptable_queue_proc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> wait_queue_head_t <span class="token operator">*</span>whead<span class="token punctuation">,</span>                poll_table <span class="token operator">*</span>pt<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">epitem</span> <span class="token operator">*</span>epi <span class="token operator">=</span> <span class="token function">ep_item_from_epqueue</span><span class="token punctuation">(</span>pt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">eppoll_entry</span> <span class="token operator">*</span>pwq<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>epi<span class="token operator">-&gt;</span>nwait <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>pwq <span class="token operator">=</span> <span class="token function">kmem_cache_alloc</span><span class="token punctuation">(</span>pwq_cache<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">init_waitqueue_func_entry</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pwq<span class="token operator">-&gt;</span>wait<span class="token punctuation">,</span> ep_poll_callback<span class="token punctuation">)</span><span class="token punctuation">;</span>        pwq<span class="token operator">-&gt;</span>whead <span class="token operator">=</span> whead<span class="token punctuation">;</span>        pwq<span class="token operator">-&gt;</span>base <span class="token operator">=</span> epi<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>epi<span class="token operator">-&gt;</span>event<span class="token punctuation">.</span>events <span class="token operator">&amp;</span> EPOLLEXCLUSIVE<span class="token punctuation">)</span>            <span class="token function">add_wait_queue_exclusive</span><span class="token punctuation">(</span>whead<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pwq<span class="token operator">-&gt;</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token function">add_wait_queue</span><span class="token punctuation">(</span>whead<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pwq<span class="token operator">-&gt;</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">list_add_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pwq<span class="token operator">-&gt;</span>llink<span class="token punctuation">,</span> <span class="token operator">&amp;</span>epi<span class="token operator">-&gt;</span>pwqlist<span class="token punctuation">)</span><span class="token punctuation">;</span>        epi<span class="token operator">-&gt;</span>nwait<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment">/* We have to signal that an error occurred */</span>        epi<span class="token operator">-&gt;</span>nwait <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="2-2-ep-poll-callback-函数"><a href="#2-2-ep-poll-callback-函数" class="headerlink" title="2.2 ep_poll_callback 函数"></a>2.2 ep_poll_callback 函数</h3><ol><li><p>函数 <code>ep_poll_callback</code> 的定义位于 <code>fs/eventpoll.c</code> 文件中 1118 行。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/** This is the callback that is passed to the wait queue wakeup* mechanism. It is called by the stored file descriptors when they* have events to report.*/</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ep_poll_callback</span><span class="token punctuation">(</span>wait_queue_entry_t <span class="token operator">*</span>wait<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> mode<span class="token punctuation">,</span> <span class="token keyword">int</span> sync<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 这个函数的作用非常重要，它将内核时间真正的和 <code>epoll</code> 对象联系了起来。</p></li><li><p>首先，通过这个文件的 <code>wait_queue_entry_t</code> 实例找到对应的 <code>epitem</code> 实例。一旦获得了 <code>epitem</code> 实例 就可以获得对应的 <code>eventpoll</code> 实例了。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">epitem</span> <span class="token operator">*</span>epi <span class="token operator">=</span> <span class="token function">ep_item_from_wait</span><span class="token punctuation">(</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token operator">*</span>ep <span class="token operator">=</span> epi<span class="token operator">-&gt;</span>ep<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> <code>ep_item_from_wait</code> 函数的定义为：</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Get the "struct epitem" from a wait queue pointer */</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">epitem</span> <span class="token operator">*</span><span class="token function">ep_item_from_wait</span><span class="token punctuation">(</span>wait_queue_entry_t <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">container_of</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">eppoll_entry</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token operator">-&gt;</span>base<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>然后，对发生的事件进行过滤。为什么需要过滤呢？为了性能考虑，<code>ep_insert</code> 在注册回调时，使用 <code>init_poll_funcptr</code> 函数注册被监控文件的所有事件，而实际用户关心的事件不一定和内核发送的事件匹配。比如，用户向内核订阅了一个套接字可读的时间，但是在某个时刻套接字可写的事件发生时，就并不需要想用户空间传递这个事件。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* * Check the events coming with the callback. At this stage, not * every device reports the events in the "key" parameter of the * callback. We need to be able to handle both cases here, hence the * test for "key" != NULL before the event match test. */</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pollflags <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>pollflags <span class="token operator">&amp;</span> epi<span class="token operator">-&gt;</span>event<span class="token punctuation">.</span>events<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">goto</span> out_unlock<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>接下来，判断是否需要把该事件传递给用户空间。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* * If we are transferring events to userspace, we can hold no locks * (because we're accessing user memory, and because of linux f_op-&gt;poll() * semantics). All the events that happen during that period of time are * chained in ep-&gt;ovflist and requeued later on. */</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ep<span class="token operator">-&gt;</span>ovflist <span class="token operator">!=</span> EP_UNACTIVE_PTR<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>epi<span class="token operator">-&gt;</span>next <span class="token operator">==</span> EP_UNACTIVE_PTR<span class="token punctuation">)</span> <span class="token punctuation">{</span>        epi<span class="token operator">-&gt;</span>next <span class="token operator">=</span> ep<span class="token operator">-&gt;</span>ovflist<span class="token punctuation">;</span>        ep<span class="token operator">-&gt;</span>ovflist <span class="token operator">=</span> epi<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>epi<span class="token operator">-&gt;</span>ws<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">/*             * Activate ep-&gt;ws since epi-&gt;ws may get             * deactivated at any time.             */</span>            <span class="token function">__pm_stay_awake</span><span class="token punctuation">(</span>ep<span class="token operator">-&gt;</span>ws<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">goto</span> out_unlock<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果需要，而且该事件对应的 <code>event_item</code> 不在 <code>eventpoll</code> 对应的已完成队列中，就把它放入该队列，以便将该事件传递给用户空间。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* If this file is already in the ready list we exit soon */</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">ep_is_linked</span><span class="token punctuation">(</span>epi<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">list_add_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>epi<span class="token operator">-&gt;</span>rdllink<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ep<span class="token operator">-&gt;</span>rdllist<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ep_pm_stay_awake_rcu</span><span class="token punctuation">(</span>epi<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>我们知道，当我们调用 <code>epoll_wait</code> 时，调用的进程会被挂起，在内核看来调用进程陷入了休眠。如果该 <code>epoll</code> 实例上对应描述符有事件发生，这个休眠的进程应该被唤醒来处理事件。下面的代码就是这个作用。 <code>wake_up_locked</code> 函数唤醒当前 <code>eventpoll</code> 上等待的进程。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* * Wake up ( if active ) both the eventpoll wait list and the -&gt;poll() * wait list. */</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">waitqueue_active</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-&gt;</span>wq<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>epi<span class="token operator">-&gt;</span>event<span class="token punctuation">.</span>events <span class="token operator">&amp;</span> EPOLLEXCLUSIVE<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token operator">!</span><span class="token punctuation">(</span>pollflags <span class="token operator">&amp;</span> POLLFREE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>pollflags <span class="token operator">&amp;</span> EPOLLINOUT_BITS<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> EPOLLIN<span class="token operator">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>epi<span class="token operator">-&gt;</span>event<span class="token punctuation">.</span>events <span class="token operator">&amp;</span> EPOLLIN<span class="token punctuation">)</span>                ewake <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> EPOLLOUT<span class="token operator">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>epi<span class="token operator">-&gt;</span>event<span class="token punctuation">.</span>events <span class="token operator">&amp;</span> EPOLLOUT<span class="token punctuation">)</span>                ewake <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span>            ewake <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">wake_up_locked</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-&gt;</span>wq<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="三、epoll-wait-系统调用"><a href="#三、epoll-wait-系统调用" class="headerlink" title="三、epoll_wait 系统调用"></a>三、epoll_wait 系统调用</h2><ol><li><p>系统调用 <code>epoll_wait</code> 的定义位于 <code>fs/eventpoll.c</code> 文件中的 2197 行。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE4</span><span class="token punctuation">(</span>epoll_wait<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> epfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> events<span class="token punctuation">,</span>        <span class="token keyword">int</span><span class="token punctuation">,</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">do_epoll_wait</span><span class="token punctuation">(</span>epfd<span class="token punctuation">,</span> events<span class="token punctuation">,</span> maxevents<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>主要工作就是调用 <code>do_epoll_wait</code> 函数。</li></ol><h3 id="3-1-do-epoll-wait-函数"><a href="#3-1-do-epoll-wait-函数" class="headerlink" title="3.1 do_epoll_wait 函数"></a>3.1 do_epoll_wait 函数</h3><ol><li><p>函数 <code>do_epoll_wait</code> 的定义位于 <code>fs/eventpoll.c</code> 文件中的 2155 行。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/** Implement the event wait interface for the eventpoll file. It is the kernel* part of the user space epoll_wait(2).*/</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">do_epoll_wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> __user <span class="token operator">*</span>events<span class="token punctuation">,</span>            <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>首先进行一系列的检查，比如传入的 <code>maxevents</code> 应该大于 0。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* The maximum number of event must be greater than zero */</span><span class="token keyword">if</span> <span class="token punctuation">(</span>maxevents <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> maxevents <span class="token operator">&gt;</span> EP_MAX_EVENTS<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span><span class="token comment">/* Verify that the area passed by the user is writeable */</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">access_ok</span><span class="token punctuation">(</span>VERIFY_WRITE<span class="token punctuation">,</span> events<span class="token punctuation">,</span> maxevents <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">epoll_event</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">-</span>EFAULT<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>与 <code>epoll_ctl</code> 类似，通过 <code>epoll</code> 实例找到对应的匿名文件和描述字，并进行检查。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Get the "struct file *" for the eventpoll file */</span>f <span class="token operator">=</span> <span class="token function">fdget</span><span class="token punctuation">(</span>epfd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>f<span class="token punctuation">.</span>file<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">-</span>EBADF<span class="token punctuation">;</span><span class="token comment">/* * We have to check that the file structure underneath the fd * the user passed to us _is_ an eventpoll file. */</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">is_file_epoll</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">goto</span> error_fput<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>获取 <code>eventpoll</code> 实例。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* * At this point it is safe to assume that the "private_data" contains * our own data structure. */</span>ep <span class="token operator">=</span> f<span class="token punctuation">.</span>file<span class="token operator">-&gt;</span>private_data<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>调用 <code>ep_poll</code> 完成事件的收集并传递到用户空间。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Time to fish for events ... */</span>error <span class="token operator">=</span> <span class="token function">ep_poll</span><span class="token punctuation">(</span>ep<span class="token punctuation">,</span> events<span class="token punctuation">,</span> maxevents<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h3 id="3-2-ep-poll-函数"><a href="#3-2-ep-poll-函数" class="headerlink" title="3.2 ep_poll 函数"></a>3.2 ep_poll 函数</h3><ol><li><p>函数 <code>ep_poll</code> 的定义位于 <code>fs/eventpoll.c</code> 文件中的 1743 行。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/** * ep_poll - Retrieves ready events, and delivers them to the caller supplied*           event buffer.** @ep: Pointer to the eventpoll context.* @events: Pointer to the userspace buffer where the ready events should be*          stored.* @maxevents: Size (in terms of number of events) of the caller event buffer.* @timeout: Maximum timeout for the ready events fetch operation, in*           milliseconds. If the @timeout is zero, the function will not block,*           while if the @timeout is less than zero, the function will block*           until at least one event has been retrieved (or an error*           occurred).** Returns: Returns the number of ready events which have been fetched, or an*          error code, in case of error.*/</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ep_poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token operator">*</span>ep<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> __user <span class="token operator">*</span>events<span class="token punctuation">,</span>        <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">long</span> timeout<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>首先，根据不同的超时时间做不同的处理。如果大于 0 就计算超时时间，如果等于 0 就立即检查是否有事件发生。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>timeout <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">timespec64</span> end_time <span class="token operator">=</span> <span class="token function">ep_set_mstimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>    slack <span class="token operator">=</span> <span class="token function">select_estimate_accuracy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>end_time<span class="token punctuation">)</span><span class="token punctuation">;</span>    to <span class="token operator">=</span> <span class="token operator">&amp;</span>expires<span class="token punctuation">;</span>    <span class="token operator">*</span>to <span class="token operator">=</span> <span class="token function">timespec64_to_ktime</span><span class="token punctuation">(</span>end_time<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">/*     * Avoid the unnecessary trip to the wait queue loop, if the     * caller specified a non blocking operation.     */</span>    timed_out <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">spin_lock_irq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-&gt;</span>wq<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">goto</span> check_events<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>检查当前是否有事件发生，如果没有，就把当前进程加入到 <code>eventpoll</code> 的等待队列 <code>wq</code> 中，这样做的目的是当有事件发生时， <code>ep_poll_callback</code> 函数可以把该等待进程唤醒。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">ep_events_available</span><span class="token punctuation">(</span>ep<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">/*     * Busy poll timed out.  Drop NAPI ID for now, we can add     * it back in when we have moved a socket with a valid NAPI     * ID onto the ready list.     */</span>    <span class="token function">ep_reset_busy_poll_napi_id</span><span class="token punctuation">(</span>ep<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*     * We don't have any available event to return to the caller.     * We need to sleep here, and we will be wake up by     * ep_poll_callback() when events will become available.     */</span>    <span class="token function">init_waitqueue_entry</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wait<span class="token punctuation">,</span> current<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">__add_wait_queue_exclusive</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-&gt;</span>wq<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>接下来是一个无限循环，循环中通过调用 <code>schedule_hrtimeout_range</code> ，将当前进程陷入休眠，CPU 时间被调度器调度给其他进程使用，当然，当前进程可能会被唤醒，唤醒的条件包括下面四种：</p><ol><li>当前进程超时；</li><li>当前进程收到一个 signal 信号；</li><li>某个描述符上有事件发生；</li><li><p>当前进程被 CPU 重新调度，进入 <code>for</code> 循环重新判断，如果没有满足前三个条件，就又重新进入休眠。</p><p>对应的 1、2、3 都会通过 <code>break</code> 跳出循环，直接返回。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">/*     * We don't want to sleep if the ep_poll_callback() sends us     * a wakeup in between. That's why we set the task state     * to TASK_INTERRUPTIBLE before doing the checks.     */</span>    <span class="token function">set_current_state</span><span class="token punctuation">(</span>TASK_INTERRUPTIBLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*     * Always short-circuit for fatal signals to allow     * threads to make a timely exit without the chance of     * finding more events available and fetching     * repeatedly.     */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fatal_signal_pending</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        res <span class="token operator">=</span> <span class="token operator">-</span>EINTR<span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ep_events_available</span><span class="token punctuation">(</span>ep<span class="token punctuation">)</span> <span class="token operator">||</span> timed_out<span class="token punctuation">)</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">signal_pending</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        res <span class="token operator">=</span> <span class="token operator">-</span>EINTR<span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">spin_unlock_irq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-&gt;</span>wq<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">schedule_hrtimeout_range</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> slack<span class="token punctuation">,</span> HRTIMER_MODE_ABS<span class="token punctuation">)</span><span class="token punctuation">)</span>        timed_out <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">spin_lock_irq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-&gt;</span>wq<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol></li><li><p>如果进程从休眠中返回，则将当前进程从 <code>eventpoll</code> 的等待队列中删除，并且设置当前进程为 <code>TASK_RUNNING</code> 状态。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c">    <span class="token function">__remove_wait_queue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ep<span class="token operator">-&gt;</span>wq<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">__set_current_state</span><span class="token punctuation">(</span>TASK_RUNNING<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>最后，调用 <code>ep_send_events</code> 函数将事件拷贝到用户空间。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* * Try to transfer events to user space. In case we get 0 events and * there's still timeout left over, we go trying again in search of * more luck. */</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>res <span class="token operator">&amp;&amp;</span> eavail <span class="token operator">&amp;&amp;</span>    <span class="token operator">!</span><span class="token punctuation">(</span>res <span class="token operator">=</span> <span class="token function">ep_send_events</span><span class="token punctuation">(</span>ep<span class="token punctuation">,</span> events<span class="token punctuation">,</span> maxevents<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>timed_out<span class="token punctuation">)</span>    <span class="token keyword">goto</span> fetch_events<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="3-3-ep-send-events-函数"><a href="#3-3-ep-send-events-函数" class="headerlink" title="3.3 ep_send_events 函数"></a>3.3 ep_send_events 函数</h3><p><code>ep_send_events</code> 函数会将 <code>ep_send_events_proc</code> 函数作为回调函数来调用 <code>ep_scan_ready_list</code> 函数。 <code>ep_scan_ready_list</code> 函数循环调用 <code>ep_send_events_proc</code> 函数对每个已经就绪的事件进行处理。<code>ep_send_events_proc</code> 函数处理就绪事件时，会再次调用每个文件描述符的 <code>poll</code> 函数，这个是为了确认注册的事件在这个时刻还是有效的。</p><p>可以看到，虽然 <code>ep_send_events_proc</code> 已经尽可能的保证用户空间获得的事件通知都是真实有效的，但是依然有一定的概率，当 <code>ep_send_events_proc</code> 再次调用文件上的 <code>poll</code> 函数后，用户空间处理该事件之前，对应的事件失效了。这也就是为什么 <strong>推荐使用非阻塞套接字配合 <code>epoll</code> 使用</strong> 的原因。</p><p>在进行简单的事件掩码校验之后，<code>ep_send_events_proc</code> 通过使用函数 <code>__put_user</code> 将事件结构体拷贝到用户空间需要的数据结构中。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> __poll_t <span class="token function">ep_send_events_proc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token operator">*</span>ep<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">list_head</span> <span class="token operator">*</span>head<span class="token punctuation">,</span>                   <span class="token keyword">void</span> <span class="token operator">*</span>priv<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">ep_send_events_data</span> <span class="token operator">*</span>esed <span class="token operator">=</span> priv<span class="token punctuation">;</span>    __poll_t revents<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">epitem</span> <span class="token operator">*</span>epi<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> __user <span class="token operator">*</span>uevent<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">wakeup_source</span> <span class="token operator">*</span>ws<span class="token punctuation">;</span>    poll_table pt<span class="token punctuation">;</span>    <span class="token function">init_poll_funcptr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pt<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*     * We can loop without lock because we are passed a task private list.     * Items cannot vanish during the loop because ep_scan_ready_list() is     * holding "mtx" during this call.     */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>esed<span class="token operator">-&gt;</span>res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> uevent <span class="token operator">=</span> esed<span class="token operator">-&gt;</span>events<span class="token punctuation">;</span>         <span class="token operator">!</span><span class="token function">list_empty</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> esed<span class="token operator">-&gt;</span>res <span class="token operator">&lt;</span> esed<span class="token operator">-&gt;</span>maxevents<span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        epi <span class="token operator">=</span> <span class="token function">list_first_entry</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epitem</span><span class="token punctuation">,</span> rdllink<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/*         * Activate ep-&gt;ws before deactivating epi-&gt;ws to prevent         * triggering auto-suspend here (in case we reactive epi-&gt;ws         * below).         *         * This could be rearranged to delay the deactivation of epi-&gt;ws         * instead, but then epi-&gt;ws would temporarily be out of sync         * with ep_is_linked().         */</span>        ws <span class="token operator">=</span> <span class="token function">ep_wakeup_source</span><span class="token punctuation">(</span>epi<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ws<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ws<span class="token operator">-&gt;</span>active<span class="token punctuation">)</span>                <span class="token function">__pm_stay_awake</span><span class="token punctuation">(</span>ep<span class="token operator">-&gt;</span>ws<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">__pm_relax</span><span class="token punctuation">(</span>ws<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">list_del_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>epi<span class="token operator">-&gt;</span>rdllink<span class="token punctuation">)</span><span class="token punctuation">;</span>        revents <span class="token operator">=</span> <span class="token function">ep_item_poll</span><span class="token punctuation">(</span>epi<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pt<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/*         * If the event mask intersect the caller-requested one,         * deliver the event to userspace. Again, ep_scan_ready_list()         * is holding "mtx", so no operations coming from userspace         * can change the item.         */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>revents<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__put_user</span><span class="token punctuation">(</span>revents<span class="token punctuation">,</span> <span class="token operator">&amp;</span>uevent<span class="token operator">-&gt;</span>events<span class="token punctuation">)</span> <span class="token operator">||</span>                <span class="token function">__put_user</span><span class="token punctuation">(</span>epi<span class="token operator">-&gt;</span>event<span class="token punctuation">.</span>data<span class="token punctuation">,</span> <span class="token operator">&amp;</span>uevent<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">list_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>epi<span class="token operator">-&gt;</span>rdllink<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">ep_pm_stay_awake</span><span class="token punctuation">(</span>epi<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>esed<span class="token operator">-&gt;</span>res<span class="token punctuation">)</span>                    esed<span class="token operator">-&gt;</span>res <span class="token operator">=</span> <span class="token operator">-</span>EFAULT<span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            esed<span class="token operator">-&gt;</span>res<span class="token operator">++</span><span class="token punctuation">;</span>            uevent<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>epi<span class="token operator">-&gt;</span>event<span class="token punctuation">.</span>events <span class="token operator">&amp;</span> EPOLLONESHOT<span class="token punctuation">)</span>                epi<span class="token operator">-&gt;</span>event<span class="token punctuation">.</span>events <span class="token operator">&amp;=</span> EP_PRIVATE_BITS<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>epi<span class="token operator">-&gt;</span>event<span class="token punctuation">.</span>events <span class="token operator">&amp;</span> EPOLLET<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">/*                 * If this file has been added with Level                 * Trigger mode, we need to insert back inside                 * the ready list, so that the next call to                 * epoll_wait() will check again the events                 * availability. At this point, no one can insert                 * into ep-&gt;rdllist besides us. The epoll_ctl()                 * callers are locked out by                 * ep_scan_ready_list() holding "mtx" and the                 * poll callback will queue them in ep-&gt;ovflist.                 */</span>                <span class="token function">list_add_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>epi<span class="token operator">-&gt;</span>rdllink<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ep<span class="token operator">-&gt;</span>rdllist<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">ep_pm_stay_awake</span><span class="token punctuation">(</span>epi<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>ep_send_events_proc</code> 函数的最后，针对 <code>Level Trigger</code> 模式，当前的 <code>epoll_item</code> 对象被重新加到 <code>eventpoll</code> 的就绪列表中，这样在下一次调用 <code>epoll_wait</code> 时，这些 <code>epoll_item</code> 对象就会被重新处理。</p><h2 id="四、select-系统调用"><a href="#四、select-系统调用" class="headerlink" title="四、select 系统调用"></a>四、select 系统调用</h2><p>系统调用 <code>select</code> 的定义位于 <code>fs/select.c</code> 文件中的 697 行。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE5</span><span class="token punctuation">(</span>select<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> fd_set __user <span class="token operator">*</span><span class="token punctuation">,</span> inp<span class="token punctuation">,</span> fd_set __user <span class="token operator">*</span><span class="token punctuation">,</span> outp<span class="token punctuation">,</span>    fd_set __user <span class="token operator">*</span><span class="token punctuation">,</span> exp<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timeval</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> tvp<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">kern_select</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> inp<span class="token punctuation">,</span> outp<span class="token punctuation">,</span> exp<span class="token punctuation">,</span> tvp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要工作就是调用 <code>kern_select</code> 函数。</p><h3 id="4-1-kern-select-函数"><a href="#4-1-kern-select-函数" class="headerlink" title="4.1 kern_select 函数"></a>4.1 kern_select 函数</h3><p>函数 <code>kern_select</code> 的定义位于 <code>fs/select.c</code> 文件中的 673 行。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">kern_select</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> fd_set __user <span class="token operator">*</span>inp<span class="token punctuation">,</span> fd_set __user <span class="token operator">*</span>outp<span class="token punctuation">,</span>               fd_set __user <span class="token operator">*</span>exp<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timeval</span> __user <span class="token operator">*</span>tvp<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">timespec64</span> end_time<span class="token punctuation">,</span> <span class="token operator">*</span>to <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">timeval</span> tv<span class="token punctuation">;</span>    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tvp<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_from_user</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tv<span class="token punctuation">,</span> tvp<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>tv<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token operator">-</span>EFAULT<span class="token punctuation">;</span>        to <span class="token operator">=</span> <span class="token operator">&amp;</span>end_time<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">poll_select_set_timeout</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span>                tv<span class="token punctuation">.</span>tv_sec <span class="token operator">+</span> <span class="token punctuation">(</span>tv<span class="token punctuation">.</span>tv_usec <span class="token operator">/</span> USEC_PER_SEC<span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token punctuation">(</span>tv<span class="token punctuation">.</span>tv_usec <span class="token operator">%</span> USEC_PER_SEC<span class="token punctuation">)</span> <span class="token operator">*</span> NSEC_PER_USEC<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ret <span class="token operator">=</span> <span class="token function">core_sys_select</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> inp<span class="token punctuation">,</span> outp<span class="token punctuation">,</span> exp<span class="token punctuation">,</span> to<span class="token punctuation">)</span><span class="token punctuation">;</span>    ret <span class="token operator">=</span> <span class="token function">poll_select_copy_remaining</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>end_time<span class="token punctuation">,</span> tvp<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>kern_select</code> 函数的主要作用是转换超时时间到内核空间，执行 <code>core_sys_select</code> 函数，并更新剩余的时间。</p><h3 id="4-2-core-sys-select-函数"><a href="#4-2-core-sys-select-函数" class="headerlink" title="4.2 core_sys_select 函数"></a>4.2 core_sys_select 函数</h3><p><code>core_sys_select</code> 函数定义位于 <code>fs/select.c</code> 文件中的 594 行。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* * We can actually return ERESTARTSYS instead of EINTR, but I'd * like to be certain this leads to no problems. So I return * EINTR just for safety. * * Update: ERESTARTSYS breaks at least the xview clock binary, so * I'm trying ERESTARTNOHAND which restart only when you want to. */</span><span class="token keyword">int</span> <span class="token function">core_sys_select</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> fd_set __user <span class="token operator">*</span>inp<span class="token punctuation">,</span> fd_set __user <span class="token operator">*</span>outp<span class="token punctuation">,</span>               fd_set __user <span class="token operator">*</span>exp<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timespec64</span> <span class="token operator">*</span>end_time<span class="token punctuation">)</span><span class="token punctuation">{</span>    fd_set_bits fds<span class="token punctuation">;</span>    <span class="token comment">//...</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ret <span class="token operator">=</span> <span class="token function">get_fd_set</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> inp<span class="token punctuation">,</span> fds<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span>        <span class="token punctuation">(</span>ret <span class="token operator">=</span> <span class="token function">get_fd_set</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> outp<span class="token punctuation">,</span> fds<span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span>        <span class="token punctuation">(</span>ret <span class="token operator">=</span> <span class="token function">get_fd_set</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> exp<span class="token punctuation">,</span> fds<span class="token punctuation">.</span>ex<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">goto</span> out<span class="token punctuation">;</span>    <span class="token function">zero_fd_set</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> fds<span class="token punctuation">.</span>res_in<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">zero_fd_set</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> fds<span class="token punctuation">.</span>res_out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">zero_fd_set</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> fds<span class="token punctuation">.</span>res_ex<span class="token punctuation">)</span><span class="token punctuation">;</span>    ret <span class="token operator">=</span> <span class="token function">do_select</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fds<span class="token punctuation">,</span> end_time<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">set_fd_set</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> inp<span class="token punctuation">,</span> fds<span class="token punctuation">.</span>res_in<span class="token punctuation">)</span> <span class="token operator">||</span>        <span class="token function">set_fd_set</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> outp<span class="token punctuation">,</span> fds<span class="token punctuation">.</span>res_out<span class="token punctuation">)</span> <span class="token operator">||</span>        <span class="token function">set_fd_set</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> exp<span class="token punctuation">,</span> fds<span class="token punctuation">.</span>res_ex<span class="token punctuation">)</span><span class="token punctuation">)</span>        ret <span class="token operator">=</span> <span class="token operator">-</span>EFAULT<span class="token punctuation">;</span>    <span class="token comment">//...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>core_sys_select</code> 函数的主要作用是准备调用 <code>do_select</code> 所需的参数，并更新结果。</p><h3 id="4-3-do-select-函数"><a href="#4-3-do-select-函数" class="headerlink" title="4.3 do_select 函数"></a>4.3 do_select 函数</h3><p><code>do_select</code> 函数定义位于 <code>fs/select.c</code> 文件中的 449 行。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">do_select</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> fd_set_bits <span class="token operator">*</span>fds<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timespec64</span> <span class="token operator">*</span>end_time<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//...</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span>rinp<span class="token punctuation">,</span> <span class="token operator">*</span>routp<span class="token punctuation">,</span> <span class="token operator">*</span>rexp<span class="token punctuation">,</span> <span class="token operator">*</span>inp<span class="token punctuation">,</span> <span class="token operator">*</span>outp<span class="token punctuation">,</span> <span class="token operator">*</span>exp<span class="token punctuation">;</span>        inp <span class="token operator">=</span> fds<span class="token operator">-&gt;</span>in<span class="token punctuation">;</span> outp <span class="token operator">=</span> fds<span class="token operator">-&gt;</span>out<span class="token punctuation">;</span> exp <span class="token operator">=</span> fds<span class="token operator">-&gt;</span>ex<span class="token punctuation">;</span>        rinp <span class="token operator">=</span> fds<span class="token operator">-&gt;</span>res_in<span class="token punctuation">;</span> routp <span class="token operator">=</span> fds<span class="token operator">-&gt;</span>res_out<span class="token punctuation">;</span> rexp <span class="token operator">=</span> fds<span class="token operator">-&gt;</span>res_ex<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>rinp<span class="token punctuation">,</span> <span class="token operator">++</span>routp<span class="token punctuation">,</span> <span class="token operator">++</span>rexp<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">unsigned</span> <span class="token keyword">long</span> in<span class="token punctuation">,</span> out<span class="token punctuation">,</span> ex<span class="token punctuation">,</span> all_bits<span class="token punctuation">,</span> bit <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">;</span>            <span class="token keyword">unsigned</span> <span class="token keyword">long</span> res_in <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> res_out <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> res_ex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            in <span class="token operator">=</span> <span class="token operator">*</span>inp<span class="token operator">++</span><span class="token punctuation">;</span> out <span class="token operator">=</span> <span class="token operator">*</span>outp<span class="token operator">++</span><span class="token punctuation">;</span> ex <span class="token operator">=</span> <span class="token operator">*</span>exp<span class="token operator">++</span><span class="token punctuation">;</span>            all_bits <span class="token operator">=</span> in <span class="token operator">|</span> out <span class="token operator">|</span> ex<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>all_bits <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                i <span class="token operator">+=</span> BITS_PER_LONG<span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> BITS_PER_LONG<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">,</span> <span class="token operator">++</span>i<span class="token punctuation">,</span> bit <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">struct</span> <span class="token class-name">fd</span> f<span class="token punctuation">;</span>                f <span class="token operator">=</span> <span class="token function">fdget</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>f<span class="token punctuation">.</span>file<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment">//...</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">poll_schedule_timeout</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>table<span class="token punctuation">,</span> TASK_INTERRUPTIBLE<span class="token punctuation">,</span>                       to<span class="token punctuation">,</span> slack<span class="token punctuation">)</span><span class="token punctuation">)</span>            timed_out <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>do_select</code> 函数的主要逻辑是监听多个 <code>fd</code> ，只要这些 <code>fd</code> 中有一个 <code>fd</code> 有事件发生，进程就会从休眠中被唤醒。并依次遍历所有的 <code>fd</code> 来判断到底是哪个 <code>fd</code> 有事件发生。 这也是 <code>select</code> 相比于 <code>epoll</code> 效率低的主要原因。</p><h2 id="五、poll-系统调用"><a href="#五、poll-系统调用" class="headerlink" title="五、poll 系统调用"></a>五、poll 系统调用</h2><p>系统调用 <code>poll</code> 的定义位于 <code>fs/select.c</code> 文件中的 1012 行。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>poll<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">pollfd</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> ufds<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> nfds<span class="token punctuation">,</span>        <span class="token keyword">int</span><span class="token punctuation">,</span> timeout_msecs<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">timespec64</span> end_time<span class="token punctuation">,</span> <span class="token operator">*</span>to <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout_msecs <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        to <span class="token operator">=</span> <span class="token operator">&amp;</span>end_time<span class="token punctuation">;</span>        <span class="token function">poll_select_set_timeout</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> timeout_msecs <span class="token operator">/</span> MSEC_PER_SEC<span class="token punctuation">,</span>            NSEC_PER_MSEC <span class="token operator">*</span> <span class="token punctuation">(</span>timeout_msecs <span class="token operator">%</span> MSEC_PER_SEC<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ret <span class="token operator">=</span> <span class="token function">do_sys_poll</span><span class="token punctuation">(</span>ufds<span class="token punctuation">,</span> nfds<span class="token punctuation">,</span> to<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要作用与 <code>select</code> 实现中的 <code>kern_select</code> 函数作用类似，转换时间并调用 <code>do_sys_poll</code> 函数。</p><h3 id="5-1-do-sys-poll-函数"><a href="#5-1-do-sys-poll-函数" class="headerlink" title="5.1 do_sys_poll 函数"></a>5.1 do_sys_poll 函数</h3><p>函数 <code>do_sys_poll</code> 的定义位于 <code>fs/select.c</code> 文件中的 926 行。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">do_sys_poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pollfd</span> __user <span class="token operator">*</span>ufds<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nfds<span class="token punctuation">,</span>        <span class="token keyword">struct</span> <span class="token class-name">timespec64</span> <span class="token operator">*</span>end_time<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//...</span>    len <span class="token operator">=</span> <span class="token function">min_t</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> nfds<span class="token punctuation">,</span> N_STACK_PPS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//...</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_from_user</span><span class="token punctuation">(</span>walk<span class="token operator">-&gt;</span>entries<span class="token punctuation">,</span> ufds <span class="token operator">+</span> nfds<span class="token operator">-</span>todo<span class="token punctuation">,</span>                    <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pollfd</span><span class="token punctuation">)</span> <span class="token operator">*</span> walk<span class="token operator">-&gt;</span>len<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">goto</span> out_fds<span class="token punctuation">;</span>        todo <span class="token operator">-=</span> walk<span class="token operator">-&gt;</span>len<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>todo<span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token comment">//...</span>    <span class="token punctuation">}</span>    <span class="token function">poll_initwait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>table<span class="token punctuation">)</span><span class="token punctuation">;</span>    fdcount <span class="token operator">=</span> <span class="token function">do_poll</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> <span class="token operator">&amp;</span>table<span class="token punctuation">,</span> end_time<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">poll_freewait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>table<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>walk <span class="token operator">=</span> head<span class="token punctuation">;</span> walk<span class="token punctuation">;</span> walk <span class="token operator">=</span> walk<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token operator">*</span>fds <span class="token operator">=</span> walk<span class="token operator">-&gt;</span>entries<span class="token punctuation">;</span>        <span class="token keyword">int</span> j<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> walk<span class="token operator">-&gt;</span>len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">,</span> ufds<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__put_user</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>revents<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ufds<span class="token operator">-&gt;</span>revents<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">goto</span> out_fds<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token comment">//...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>do_sys_poll</code> 函数的主要作用与 <code>select</code> 实现中的 <code>core_sys_select</code> 函数作用类似，准备调用 <code>do_poll</code> 所需的参数，并更新结果。</p><h3 id="5-2-do-poll-函数"><a href="#5-2-do-poll-函数" class="headerlink" title="5.2 do_poll 函数"></a>5.2 do_poll 函数</h3><p>函数 <code>do_poll</code> 的定义位于 <code>fs/select.c</code> 文件中的 837 行。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">do_poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">poll_list</span> <span class="token operator">*</span>list<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">poll_wqueues</span> <span class="token operator">*</span>wait<span class="token punctuation">,</span>           <span class="token keyword">struct</span> <span class="token class-name">timespec64</span> <span class="token operator">*</span>end_time<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//...</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">struct</span> <span class="token class-name">poll_list</span> <span class="token operator">*</span>walk<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>walk <span class="token operator">=</span> list<span class="token punctuation">;</span> walk <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> walk <span class="token operator">=</span> walk<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token operator">*</span> pfd<span class="token punctuation">,</span> <span class="token operator">*</span> pfd_end<span class="token punctuation">;</span>            pfd <span class="token operator">=</span> walk<span class="token operator">-&gt;</span>entries<span class="token punctuation">;</span>            pfd_end <span class="token operator">=</span> pfd <span class="token operator">+</span> walk<span class="token operator">-&gt;</span>len<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> pfd <span class="token operator">!=</span> pfd_end<span class="token punctuation">;</span> pfd<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">/*                 * Fish for events. If we found one, record it                 * and kill poll_table-&gt;_qproc, so we don't                 * needlessly register any other waiters after                 * this. They'll get immediately deregistered                 * when we break out and return.                 */</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">do_pollfd</span><span class="token punctuation">(</span>pfd<span class="token punctuation">,</span> pt<span class="token punctuation">,</span> <span class="token operator">&amp;</span>can_busy_loop<span class="token punctuation">,</span>                          busy_flag<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment">//...</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">//...</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">poll_schedule_timeout</span><span class="token punctuation">(</span>wait<span class="token punctuation">,</span> TASK_INTERRUPTIBLE<span class="token punctuation">,</span> to<span class="token punctuation">,</span> slack<span class="token punctuation">)</span><span class="token punctuation">)</span>            timed_out <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> count<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样与 <code>select</code> 实现中的 <code>do_select</code> 类似，<code>do_poll</code> 函数的主要逻辑是监听多个 <code>fd</code> ，只要这些 <code>fd</code> 中有一个 <code>fd</code> 有事件发生，进程就会从休眠中被唤醒。并依次遍历所有的 <code>fd</code> 来判断到底是哪个 <code>fd</code> 有事件发生。 所以 <code>poll</code> 与 <code>select</code> 一样的效率低。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> epoll </tag>
            
            <tag> select </tag>
            
            <tag> poll </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解TCP中的数据传输</title>
      <link href="li-jie-tcp-zhong-de-shu-ju-chuan-shu/"/>
      <url>li-jie-tcp-zhong-de-shu-ju-chuan-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="一、TCP-协议：物流公司"><a href="#一、TCP-协议：物流公司" class="headerlink" title="一、TCP 协议：物流公司"></a>一、TCP 协议：物流公司</h2><p>TCP 协议提供了一种 <strong>面向连接的</strong> 、<strong>可靠的</strong> 、<strong>基于字节流的</strong> 传输层通信协议。</p><p>可以把 TCP 协议理解成一个物流公司，把货物从一个仓库运送到另一个仓库：</p><ul><li>TCP 是 <strong>基于字节流的</strong> 协议，所以运用的货物就是字节；</li><li>货物是有保质期的（TTL）；</li><li>货车就是 TCP 数据包；</li><li>发送仓库的容量大小是固定的，里面还存放了一堆带运送的字节，这就是发送缓冲区；</li><li>接收仓库的容量大小也是固定的，里面可以存放字节，这就是接收缓冲区；</li><li>TCP 是 <strong>面向连接的</strong> 协议，所以物流公司是一一对应的；</li><li>TCP 是 <strong>可靠的</strong> 协议，所以在接收方确认收到货物前，发送方都要保存已发送的货物以备重发。</li></ul><h2 id="二、3-次握手：成立物流公司"><a href="#二、3-次握手：成立物流公司" class="headerlink" title="二、3 次握手：成立物流公司"></a>二、3 次握手：成立物流公司</h2><p>TCP 协议是 <strong>面向连接的</strong> 协议。所以即使同一个服务端，不同的客户端，都是应该是不同的连接，亦即对应者不同的“物流公司”。</p><p>可以把一个操作系统理解为一个写字楼：</p><ul><li>IP 地址对应者写字楼的地址；</li><li>端口对应着写字楼不同的大门，写字楼一共有 65535 个大门；</li><li>服务端应用对着写字楼中不同的公司。</li></ul><p>一个服务端应用首先需要向操作系统申请在某个端口上监听（<code>listen</code>），等同于某个公司向写字楼申请占用某个大门来办事。</p><p>服务端应用在某个端口监听成功后，3 次握手就可以理解为：</p><div class="table-container"><table><thead><tr><th>序号</th><th>方向</th><th>内容</th><th>标记</th><th>客户端状态变化</th><th>服务端状态变化</th></tr></thead><tbody><tr><td>1</td><td>C -&gt; S</td><td>可以给你发送货物吗，我的仓库空闲大小是a？</td><td>SYN,Win=a</td><td>CLOSED -&gt; SYN-SENT</td><td></td></tr><tr><td>2</td><td>S -&gt; C</td><td>你可以给我发送货物；那我可以给你发送货物吗，我的仓库空闲大小是b？</td><td>ACK,SYN,Win=b</td><td>SYN-SENT -&gt; ESTABLISHED</td><td>LISTEN -&gt; SYN-RECEIVED</td></tr><tr><td>3</td><td>C -&gt; S</td><td>可以的，我的仓库新的空闲大小是c</td><td>ACK,Win=c</td><td></td><td>SYN-RECEIVED -&gt; ESTABLISHED</td></tr></tbody></table></div><blockquote><p>注意：TCP 并不允许建立单向的数据传输，连接必须都是双向传输的。这与断开连接时不同。</p></blockquote><p>握手的过程中除了建立连接本身外，还在不停的向对方更新自己仓库空闲空间的大小等信息，这些信息对于后续的数据运输是很重要的。</p><p>经过 3 次握手后，一对一的物流公司就建立起来了。现在双方可以开始发送数据给对方了。</p><h2 id="三、滑动窗口：接收仓库的空闲空间大小"><a href="#三、滑动窗口：接收仓库的空闲空间大小" class="headerlink" title="三、滑动窗口：接收仓库的空闲空间大小"></a>三、滑动窗口：接收仓库的空闲空间大小</h2><p>但是发送货物之前，发送方需要先考虑两个问题：</p><ol><li>发送方需要时刻知道接收方还能接收多少的货物。因为如果发送的货物总量超出了接收方，多余的货物会被丢弃掉。</li><li>TCP 协议是 <strong>可靠的</strong> 的协议，所以发送方还需要记录发出的货物，接收方是否确认收到了等状态信息。</li></ol><p><strong>滑动窗口（Sliding Window）</strong>，也叫 <strong>发送窗口（Send Window）</strong>，就是这两个问题的解决方案。滑动窗口的大小等于 <strong>接收方</strong> 接收仓库空闲空间的大小，这个数据在 3 次握手的过程中初始化，并在随后的通信的过程中不断的更新。</p><p>滑动窗口的内部状态如下：</p><p><img src="/images/理解TCP中的数据传输/滑动窗口的内部状态.png" alt="滑动窗口的内部状态"></p><ol><li><strong>字节 1-31</strong>：已经发送并且接收方确认收到的数据；</li><li><strong>字节 32-45</strong>：已经发送但是接收方还未确认收到的数据；</li><li><strong>字节 46-51</strong>：还未发送但是接收方还有足够空间可以容纳的数据；</li><li><strong>字节 52 及以上</strong>：还未发送并且接收方没有足够空间可以容纳的数据。</li></ol><blockquote><p>图片来源：<a href="http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo-6.htm">TCP Sliding Window Acknowledgment System For Data Transport, Reliability and Flow Control 6</a></p></blockquote><p>当上图中所有滑动窗口内的数据都发送出后，滑动窗口内的状态变成了下图的状态：</p><p><img src="/images/理解TCP中的数据传输/滑动窗口内的数据都已被发送但未被确认.png" alt="滑动窗口内的数据都已被发送但未被确认"></p><blockquote><p>图片来源：<a href="http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo-7.htm">TCP Sliding Window Acknowledgment System For Data Transport, Reliability and Flow Control 7</a></p></blockquote><ol><li><strong>字节 1-31</strong>：已经发送并且接收方确认收到的数据；</li><li><strong>字节 32-51</strong>：已经发送但是接收方还未确认收到的数据；</li><li><strong>字节 52 及以上</strong>：还未发送并且接收方没有足够空间可以容纳的数据。</li></ol><p>当收到了 <strong>32-36 字节</strong> 的 ACK 确认消息，那么滑动窗口就会向后面滑动，并可以发送 <strong>字节 52-56</strong> 。如下图：</p><p><img src="/images/理解TCP中的数据传输/滑动窗口收到确认后向后滑动.png" alt="滑动窗口收到确认后向后滑动"></p><blockquote><p>图片来源：<a href="http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo-8.htm">TCP Sliding Window Acknowledgment System For Data Transport, Reliability and Flow Control 8</a></p></blockquote><ol><li><strong>字节 1-36</strong>：已经发送并且接收方确认收到的数据；</li><li><strong>字节 37-51</strong>：已经发送但是接收方还未确认收到的数据；</li><li><strong>字节 52-56</strong>：还未发送但是接收方还有足够空间可以容纳的数据；</li><li><strong>字节 57 及以上</strong>：还未发送并且接收方没有足够空间可以容纳的数据。</li></ol><p>循环上面的步骤就能够一直发送数据了。如下图（下图中滑动窗口没有向后滑动，所以最后滑动窗口的大小会变成 0）：</p><p><img src="/images/理解TCP中的数据传输/滑动窗口完整工作流程.png" alt="滑动窗口完整工作流程"></p><blockquote><p>图片来源：<a href="http://www.tcpipguide.com/free/t_TCPWindowSizeAdjustmentandFlowControl-2.htm">TCP Window Size Adjustment and Flow Control 2</a></p></blockquote><h2 id="三、拥塞处理：各物流公司之间如何协调上路"><a href="#三、拥塞处理：各物流公司之间如何协调上路" class="headerlink" title="三、拥塞处理：各物流公司之间如何协调上路"></a>三、拥塞处理：各物流公司之间如何协调上路</h2><p>物流公司都是一对一的，一个连接就是一个物流公司。各个物流公司之间没有沟通，也就没有协调。大家想发货时就发车，那么路上肯定会堵起来，而货物是有有效期的，不能无限制的堵下去。同样的，对于网络也是，网速也是有限的，数据包也是有超时（TTL），不能无休止发送数据。</p><p>但是，与现实世界中有一个全局统一交通系统来控制各个路口的红绿灯，网络世界中没有这个一个系统。所以就需要各个物流公司根据货物发送出去并且对方确认收到的时间差来估算网络是否拥堵等情况。</p><p>各个物流公司可以应用不同的算法来估算网络是否拥堵等情况，并根据估算的结果来控制货车发车的频率，这就是 <strong>拥塞处理（Congestion Handling）</strong>。</p><p>在 Linux 中可以使用下面的命令来查看系统支持的拥塞处理算法和当前使用的拥塞处理算法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ sysctl net.ipv4.tcp_available_congestion_controlnet.ipv4.tcp_available_congestion_control <span class="token operator">=</span> reno cubic$ sysctl net.ipv4.tcp_congestion_controlnet.ipv4.tcp_congestion_control <span class="token operator">=</span> cubic<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、糊涂窗口综合症：运输效率太低了怎么办"><a href="#四、糊涂窗口综合症：运输效率太低了怎么办" class="headerlink" title="四、糊涂窗口综合症：运输效率太低了怎么办"></a>四、糊涂窗口综合症：运输效率太低了怎么办</h2><p>每辆货车的最大载货量是 <strong>MSS（Maximum Segment Size，最大分段大小）</strong>，但是如果在运输时货车里面实际的载货量常常很小，造成这种情况的原因可能是：</p><ul><li>发送方的发送仓库中每次只有一点货物要发送；</li><li>接收方的接收仓库中每次只能腾出一点空间出来接收货物；</li><li>上面两种原因都有。</li></ul><p>这种情况会导致运输效率低，而且还容易造成网络拥堵，所以需要避免出现这种情况。</p><ol><li><p>如果是发送方导致这种情况出现，那么可以通过在发送方使用 <a href="https://en.wikipedia.org/wiki/Nagle%27s_algorithm">纳格算法，Nagle’s algorithm</a> 来避免。算法的原理和实现可以参考 Linux 源码中 <code>linux-4.19.194/net/ipv4/tcp_output.c</code> 文件中 <code>tcp_nagle_check</code> 函数的实现：</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Return false, if packet can be sent now without violation Nagle's rules:* 1. It is full sized. (provided by caller in %partial bool)* 2. Or it contains FIN. (already checked by caller)* 3. Or TCP_CORK is not set, and TCP_NODELAY is set.* 4. Or TCP_CORK is not set, and all sent packets are ACKed.*    With Minshall's modification: all sent small packets are ACKed.*/</span><span class="token keyword">static</span> bool <span class="token function">tcp_nagle_check</span><span class="token punctuation">(</span>bool partial<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">tcp_sock</span> <span class="token operator">*</span>tp<span class="token punctuation">,</span>                <span class="token keyword">int</span> nonagle<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> partial <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>nonagle <span class="token operator">&amp;</span> TCP_NAGLE_CORK<span class="token punctuation">)</span> <span class="token operator">||</span>        <span class="token punctuation">(</span><span class="token operator">!</span>nonagle <span class="token operator">&amp;&amp;</span> tp<span class="token operator">-&gt;</span>packets_out <span class="token operator">&amp;&amp;</span> <span class="token function">tcp_minshall_check</span><span class="token punctuation">(</span>tp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>如果包长度达到 MSS ，则允许发送；</li><li>如果该包含有 FIN，则允许发送；</li><li>未设置 <code>TCP_CORK</code> 选项，但设置了 <code>TCP_NODELAY</code> 选项，则允许发送；</li><li><p>未设置 <code>TCP_CORK</code> 选项时，若所有发出去的包均被确认，或所有发出去的小数据包（包长度小于MSS）均被确认，则允许发送。</p><blockquote><p><code>TCP_CORK</code> 开启时，内核将不会马上发送长度小于 MSS 的数据包。</p><p><code>TCP_CORK</code> 对应 FreeBSD 中的 <code>TCP_NOPUSH</code> 选项。</p><p>nginx 的配置文件中 <code>tcp_nopush</code> 选项控制的就是套接字的 <code>TCP_CORK</code> / <code>TCP_NOPUSH</code> 选项。</p></blockquote></li></ol></li><li><p>如果是接收方导致这种情况出现，那么可以通过在接收方使用 <strong>David D Clark 算法</strong> 来避免。</p><p> 算法原理是：如果 <strong>接收方接收缓存区空闲空间的大小</strong> 小于 <strong>MSS</strong> 或者 <strong>接收方接收缓存区完整空间大小的一半</strong> 中的较小值时，通知发送方 接收方接收缓冲区空闲空间大小为 0 ，以禁止发送数据。</p><p> 需要注意的是，当发送方收到接收方将滑动窗口的大小减少到 0 后，就不能再发送数据给对方了。此时可以发送 <code>Zero Window Probe</code> 包给对方，这样在对方回复此包的 ACK 的同时，可以更新滑动窗口的大小，来恢复发送数据。</p></li><li><p>接收方还可以使用 <a href="https://en.wikipedia.org/wiki/TCP_delayed_acknowledgment">TCP 延迟确认</a> 技术</p><p> TCP 延迟确认技术在收到数据后并不马上回复对应的 ACK ，而是累计需要发送的 ACK 数据，等到有数据要发送给对方时一起发送给对方。如果一直没有数据发送给对方，在等到一段时间后也会把累计的 ACK 发送给对方。</p><blockquote><p>在 Linux 下，套接字选项 <code>TCP_QUICKACK</code> 用于关闭 TCP 延迟确认技术（需要每次发送都设置一次，参考 <a href="https://man7.org/linux/man-pages/man7/tcp.7.html"><code>man 7 tcp</code></a>）</p></blockquote><p> 参考：<a href="https://blog.csdn.net/sctq8888/article/details/7398967">Linux下TCP延迟确认(Delayed Ack)机制导致的时延问题分析</a></p></li></ol><h2 id="五、4-次挥手：注销物流公司"><a href="#五、4-次挥手：注销物流公司" class="headerlink" title="五、4 次挥手：注销物流公司"></a>五、4 次挥手：注销物流公司</h2><p>当有 A 不再需要发送数据给 B 时，可以单向的关闭连接。流程如下：</p><div class="table-container"><table><thead><tr><th>序号</th><th>方向</th><th>内容</th><th>标记</th><th>A 状态变化</th><th>B 状态变化</th></tr></thead><tbody><tr><td>1</td><td>A -&gt; B</td><td>我发送完数据了</td><td>FIN</td><td>ESTABLISHED -&gt; FIN-WAIT-1</td><td></td></tr><tr><td>2</td><td>B -&gt; A</td><td>好的，我知道了</td><td>ACK</td><td>FIN-WAIT-1 -&gt; FIN-WAIT-2</td><td>ESTABLISHED -&gt; CLOSE-WAIT</td></tr></tbody></table></div><p>当 B 也不再需要发送数据时，可以继续关闭连接。流程如下：</p><div class="table-container"><table><thead><tr><th>序号</th><th>方向</th><th>内容</th><th>标记</th><th>A 状态变化</th><th>B 状态变化</th></tr></thead><tbody><tr><td>3</td><td>B -&gt; A</td><td>我也发送完数据了</td><td>FIN</td><td></td><td>CLOSE-WAIT -&gt; LAST-ACK</td></tr><tr><td>4</td><td>A -&gt; B</td><td>好的，我知道了</td><td>ACK</td><td>FIN-WAIT-2 -&gt; TIME-WAIT</td><td>LAST-ACK -&gt; CLOSED</td></tr></tbody></table></div><h2 id="六、TCP-协议抓包"><a href="#六、TCP-协议抓包" class="headerlink" title="六、TCP 协议抓包"></a>六、TCP 协议抓包</h2><ol><li><p>两台机器分别是：</p><ul><li>A: 192.168.81.88（Windows 10）</li><li>B: 192.168.20.122（CentOS 7.7）</li></ul></li><li><p>操作步骤：</p><ol><li>B 在 9999 端口监听 TCP 连接；</li><li>A 连接 B的9999 端口；</li><li>A 向 B 发送 4 个字节的数据；</li><li>B 向 A 发送 4 个字节的数据；</li><li>B 主动断开连接。</li></ol></li><li><p>Wireshark 截图</p><p> <img src="/images/理解TCP中的数据传输/TCP连接发送数据断开的Wireshark截图.png" alt="TCP连接发送数据断开的Wireshark截图"></p><ul><li><p>让 Wireshark 显示绝对的 sequence numbers</p><p>  在菜单栏依次点击 <code>编辑</code> -&gt; <code>首选项</code> -&gt; <code>Protocols</code> -&gt; <code>TCP</code> 中，取消选项 <code>Relative sequence numbers</code> 前的复选框。</p></li><li><p>如何显示截图的界面</p><p>  在菜单栏依次点击 <code>统计</code> -&gt; <code>流量图</code>，然后点击右键，在弹出的选项中选择<code>放大</code>/<code>缩小</code>调整图形。</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IP </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCPIP常见问题</title>
      <link href="tcpip-chang-jian-wen-ti/"/>
      <url>tcpip-chang-jian-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="1-TIME-WAIT-会在什么情况下出现"><a href="#1-TIME-WAIT-会在什么情况下出现" class="headerlink" title="1. TIME_WAIT 会在什么情况下出现"></a>1. TIME_WAIT 会在什么情况下出现</h2><p>如果处于 TIMEWAIT 状态，说明双方建立成功过连接，而且已经发送了最后的 ACK 之后，才会处于这个状态，而且是主动发起关闭的一方处于这个状态。</p><p>其次，当断开TCP的主动方收到了被动方发来的FIN包并回复对应的ACK包给被动方后，主动方就进入了TIME_WAIT状态。然后等待 <code>2 * MSL</code> 时间（此时间段内如果再次收到被动方发来的FIN消息，说明之前回复的ACK包丢失，需要重新发送给被动方，并重新开始计时）后，再进入CLOSED状态，此时才能完成的释放相关的资源。</p><p>如果存在大量的 TIMEWAIT，往往是因为短连接太多，不断的创建连接，然后释放连接，从而导致很多连接在这个状态，可能会导致无法发起新的连接。解决的方式往往是：</p><ul><li>打开 tcp_tw_recycle 和 tcp_timestamps 选项；</li><li>打开 tcp_tw_reuse 和 tcp_timestamps 选项；</li><li>程序中使用 SO_LINGER，应用强制使用 rst 关闭。</li></ul><p>当客户端收到 Connection Reset，往往是收到了 TCP 的 RST 消息，RST 消息一般在下面的情况下发送：</p><ul><li>试图连接一个未被监听的服务端；</li><li>对方处于 TIMEWAIT 状态，或者连接已经关闭处于 CLOSED 状态，或者重新监听 seq num 不匹配；</li><li>发起连接时超时，重传超时，keepalive 超时；</li><li>在程序中使用 SO_LINGER，关闭连接时，放弃缓存中的数据，给对方发送 RST。</li></ul><h2 id="2-什么是-MSL"><a href="#2-什么是-MSL" class="headerlink" title="2. 什么是 MSL"></a>2. 什么是 MSL</h2><p><a href="https://en.wikipedia.org/wiki/Maximum_segment_lifetime">MSL, Maximum Segment Lifetime</a>，TCP Segment 在网络上的最长存活时间。</p><p><a href="www.rfc-editor.org/rfc/rfc793.txt">RFC793</a> 将 MSL 定义为 2 分钟。Linux 下 MSL 默认是 30 秒，Windows 下 MSL 默认是 240 秒。Linux 下可以通过下面的命令查看实际的 MSL 值。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sysctl net.ipv4.tcp_fin_timeout<span class="token function">cat</span> /proc/sys/net/ipv4/tcp_fin_timeout<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="3-为什么不直接进入-CLOSED-状态，还需要等待-2-MSL-时间"><a href="#3-为什么不直接进入-CLOSED-状态，还需要等待-2-MSL-时间" class="headerlink" title="3. 为什么不直接进入 CLOSED 状态，还需要等待 2 * MSL 时间"></a>3. 为什么不直接进入 CLOSED 状态，还需要等待 <code>2 * MSL</code> 时间</h2><p>主要原因有两个：</p><ol><li><p>进入TIME_WAIT状态并等待 <code>2 * MSL</code>，保证了如果被动方没有收到主动方回复的 ACK，被动方至少有时间能重发一次之前 FIN 包。一回一重发，正好 <code>2 * MSL</code>。</p><blockquote><p>如果主动方回的 ACK 包丢失，被动方重发的 FIN 包也丢失，那么就不管了。</p></blockquote></li><li><p>避免断开的 TCP 连接不影响后面新建立的 TCP 连接。</p><blockquote><p>如果主动方不等待 <code>2*MSL</code> 直接进入 CLOSED 状态，然后再重新建立 TCP 连接，如果此时收到了之前关闭的被动方重发 FIN 消息，那么重新建立的 TCP 连接就会被断开。</p></blockquote></li></ol><h2 id="4-MTU-1500-的具体含义是什么"><a href="#4-MTU-1500-的具体含义是什么" class="headerlink" title="4. MTU 1500 的具体含义是什么"></a>4. MTU 1500 的具体含义是什么</h2><p>MTU（Maximum Transmission Unit，最大传输单元）是二层的一个定义。以以太网为例，MTU 为 1500 个 Byte，前面有 6 个 Byte 的目标 MAC 地址，6 个 Byte 的源 MAC 地址，2 个 Byte 的类型，后面有 4 个 Byte 的 CRC 校验，共 1518 个 Byte。</p><p>在 IP 层，一个 IP 数据报在以太网中传输，如果它的长度大于该 MTU 值，就要进行分片传输。如果不允许分片 DF，就会发送 ICMP 包，</p><p>在 TCP 层有个 MSS（Maximum Segment Size，最大分段大小），它等于 MTU 减去 IP 头，再减去 TCP 头。即在不分片的情况下，TCP 里面放的最大内容。</p><h2 id="5-HTTPS-的双向认证流程"><a href="#5-HTTPS-的双向认证流程" class="headerlink" title="5. HTTPS 的双向认证流程"></a>5. HTTPS 的双向认证流程</h2><p><img src="/images/TCPIP常见问题/HTTPS的双向认证流程.jpg" alt="HTTPS的双向认证流程"></p><p>其中，随机数和 premaster 的含义是：</p><p><img src="/images/TCPIP常见问题/HTTPS中的随机数和premaster.jpg" alt="HTTPS中的随机数和premaster"></p><h2 id="6-RTMP-连接建立的过程"><a href="#6-RTMP-连接建立的过程" class="headerlink" title="6. RTMP 连接建立的过程"></a>6. RTMP 连接建立的过程</h2><ol><li>首先，客户端发送 C0 表明自己的版本号，不必等对方的回复，然后发送 C1 表明自己的时间戳。</li><li>服务器只有在收到 C0 的时候，才能返回 S0，表明自己的版本号。如果版本不匹配，可以断开连接。</li><li>服务器发送完 S0 后，也不用等什么，就直接发送自己的时间戳 S1。客户端收到 S1 的时候，发一个知道了对方时间戳的 ACK C2。同理服务器收到 C1 的时候，发一个知道了对方时间戳的 ACK S2。</li><li>握手完成。</li></ol><p><img src="/images/TCPIP常见问题/RTMP连接建立的过程.jpg" alt="RTMP连接建立的过程"></p><h2 id="7-SO-RCVBUF-和-SO-SNDBUF-值设置的问题"><a href="#7-SO-RCVBUF-和-SO-SNDBUF-值设置的问题" class="headerlink" title="7. SO_RCVBUF 和 SO_SNDBUF 值设置的问题"></a>7. SO_RCVBUF 和 SO_SNDBUF 值设置的问题</h2><p>在 Windows 和 MacOS 下，套接字选项 SO_RCVBUF 和 SO_SNDBUF <strong>设置后的值</strong> 和 <strong>设置的值</strong> 相同。</p><p>但是在 Linux 下，<strong>设置后的值</strong> 是 <strong>设置值</strong> 的两倍。具体可以参考 <a href="https://man7.org/linux/man-pages/man7/socket.7.html"><code>man 7 socket</code></a>：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">SO_RCVBUF    Sets or gets the maximum socket receive buffer in bytes.    The kernel doubles this value (to allow space for    bookkeeping overhead) when it is set using setsockopt(2),    and this doubled value is returned by getsockopt(2).  The    default value is set by the    /proc/sys/net/core/rmem_default file, and the maximum    allowed value is set by the /proc/sys/net/core/rmem_max    file.  The minimum (doubled) value for this option is 256.SO_SNDBUF    Sets or gets the maximum socket send buffer in bytes.  The    kernel doubles this value (to allow space for bookkeeping    overhead) when it is set using setsockopt(2), and this    doubled value is returned by getsockopt(2).  The default    value is set by the /proc/sys/net/core/wmem_default file    and the maximum allowed value is set by the    /proc/sys/net/core/wmem_max file.  The minimum (doubled)    value for this option is 2048.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-SO-REUSEADDR-和-SO-REUSEPORT-的区别"><a href="#8-SO-REUSEADDR-和-SO-REUSEPORT-的区别" class="headerlink" title="8. SO_REUSEADDR 和 SO_REUSEPORT 的区别"></a>8. SO_REUSEADDR 和 SO_REUSEPORT 的区别</h2><p>参考 <a href="https://man7.org/linux/man-pages/man7/socket.7.html"><code>man 7 socket</code> 的说明</a>：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">SO_REUSEADDR    Indicates that the rules used in validating addresses    supplied in a bind(2) call should allow reuse of local    addresses.  For AF_INET sockets this means that a socket    may bind, except when there is an active listening socket    bound to the address.  When the listening socket is bound    to INADDR_ANY with a specific port then it is not possible    to bind to this port for any local address.  Argument is    an integer boolean flag.SO_REUSEPORT (since Linux 3.9)    Permits multiple AF_INET or AF_INET6 sockets to be bound    to an identical socket address.  This option must be set    on each socket (including the first socket) prior to    calling bind(2) on the socket.  To prevent port hijacking,    all of the processes binding to the same address must have    the same effective UID.  This option can be employed with    both TCP and UDP sockets.    For TCP sockets, this option allows accept(2) load    distribution in a multi-threaded server to be improved by    using a distinct listener socket for each thread.  This    provides improved load distribution as compared to    traditional techniques such using a single accept(2)ing    thread that distributes connections, or having multiple    threads that compete to accept(2) from the same socket.    For UDP sockets, the use of this option can provide better    distribution of incoming datagrams to multiple processes    (or threads) as compared to the traditional technique of    having multiple processes compete to receive datagrams on    the same socket.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-SO-LINGER-选项的使用"><a href="#9-SO-LINGER-选项的使用" class="headerlink" title="9. SO_LINGER 选项的使用"></a>9. SO_LINGER 选项的使用</h2><p>SO_LINGER 选项用于控制在函数 <code>close</code> 关闭面向连接的套接字时，操作系统应该如何处理发送缓存中未发送完的数据？</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">linger</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> l_onoff<span class="token punctuation">;</span>    <span class="token comment">/* linger active */</span>    <span class="token keyword">int</span> l_linger<span class="token punctuation">;</span>   <span class="token comment">/* how many seconds to linger for */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>设置 <code>l_onoff</code> 为 0，<code>l_linger</code> 值将被忽略。此时 <code>close</code> 调用会立即返回。操作系统将尽可能（并不保证）发送完任何未发送的数据。 <strong>这也是操作系统的默认处理方式。</strong></p></li><li><p>设置 <code>l_onoff</code> 为非 0，<code>l_linger</code> 为 0。此时 <code>close</code> 调用会立即返回。操作系统将会丢弃任何未发送完的数据，并发送一个 RST 给对方强制关闭连接。这种情况不会出现 <code>TIME_WAIT</code> 状态 。</p></li><li><p>设置 <code>l_onoff</code> 为非 0，同时 <code>l_linger</code> 也为非 0。此时 <code>close</code> 调用可能会阻塞一段时间。阻塞直到：</p><ul><li>所有未发送的数据都被发送完且被对方确认，之后进行正常的套接字断开流程。</li><li><p><code>l_linger</code> 指定的时间到了。</p><p>如果在数据发送完且被确认前 <code>l_linger</code> 指定时间到了，Windows、Linux、MacOS 都会在后台继续发送剩余的数据。套接字的状态变化为：<code>FIN-WAIT-1</code> -&gt; <code>FIN-WAIT-2</code> -&gt; <code>TIME-WAIT</code>。</p><blockquote><p>实际上在 <code>close</code> 返回后但数据还未发送完时套接字状态就已经变成了 <code>FIN-WAIT-1</code> ，在剩余数据发送完和 FIN 发出后收到对于的 ACK 之前，套接字都是 <code>FIN-WAIT-1</code> 状态。</p><p>分析 Linux 的源码可以看出，之所以出现这种情况是因为，发出 FIN 包也是排队发送的，而发送队列的前面还有那些缓存中未发送完成的数据包。</p></blockquote><p>但是在 Windows 和 MacOS 下， <code>close</code> 调用一般不会阻塞，而在 Linux 下， <code>close</code> 会阻塞指定的时间（即使是非阻塞的套接字也会阻塞指定的时间）。</p><blockquote><p>参考 Linux 源码中 <code>tcp_close</code> 函数的实现。</p></blockquote></li></ul></li></ol><h2 id="10-tcp-tw-reuse-选项"><a href="#10-tcp-tw-reuse-选项" class="headerlink" title="10. tcp_tw_reuse 选项"></a>10. tcp_tw_reuse 选项</h2><p>首先看内核源码 (4.19.194) <code>ip-sysctl.txt</code> 文件中关于这两个选项的说明：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">tcp_tw_reuse - INTEGER    Enable reuse of TIME-WAIT sockets for new connections when it is    safe from protocol viewpoint.    0 - disable    1 - global enable    2 - enable for loopback traffic only    It should not be changed without advice/request of technical    experts.    Default: 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=4396e46187ca5070219b81773c4e65088dac50cc">tcp_tw_recycle 在 4.12 内核选项被移除。</a></p></blockquote><p>tcp_tw_reuse 设置的是内核变量 sysctl_tcp_tw_reuse ，而这个变量仅在 <code>tcp_twsk_unique</code> 函数中使用。而这个函数的调用路径有且仅有一个：</p><ol><li><code>net/ipv4/tcp_ipv4.c</code> 文件中的 <code>tcp_v4_connect</code> 函数。</li><li><code>net/ipv4/inet_hashtables.c</code> 文件中的 <code>inet_hash_connect</code> 函数。</li><li><code>net/ipv4/inet_hashtables.c</code> 文件中的 <code>__inet_check_established</code> 函数。</li><li><code>include/net/timewait_sock.h</code> 文件中的 <code>twsk_unique</code> 函数。</li><li><code>net/ipv4/tcp_ipv4.c</code> 文件中的 <code>tcp_twsk_unique</code> 函数。</li></ol><p><code>tcp_twsk_unique</code> 函数的主要实现如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_twsk_unique</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sktw<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>twp<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">/* With PAWS, it is safe from the viewpoint       of data integrity. Even without PAWS it is safe provided sequence       spaces do not overlap i.e. at data rates &lt;= 80Mbit/sec.       Actually, the idea is close to VJ's one, only timestamp cache is       held not per host, but per port pair and TW bucket is used as state       holder.       If TW bucket has been already destroyed we fall back to VJ's scheme       and use initial timestamp retrieved from peer table.     */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tcptw<span class="token operator">-&gt;</span>tw_ts_recent_stamp <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span><span class="token operator">!</span>twp <span class="token operator">||</span> <span class="token punctuation">(</span>reuse <span class="token operator">&amp;&amp;</span> <span class="token function">time_after32</span><span class="token punctuation">(</span><span class="token function">ktime_get_seconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                        tcptw<span class="token operator">-&gt;</span>tw_ts_recent_stamp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">/* In case of repair and re-using TIME-WAIT sockets we still         * want to be sure that it is safe as above but honor the         * sequence numbers and time stamps set as part of the repair         * process.         *         * Without this check re-using a TIME-WAIT socket with TCP         * repair would accumulate a -1 on the repair assigned         * sequence number. The first time it is reused the sequence         * is -1, the second time -2, etc. This fixes that issue         * without appearing to create any others.         */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token operator">!</span>tp<span class="token operator">-&gt;</span>repair<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            u32 seq <span class="token operator">=</span> tcptw<span class="token operator">-&gt;</span>tw_snd_nxt <span class="token operator">+</span> <span class="token number">65535</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>seq<span class="token punctuation">)</span>                seq <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token function">WRITE_ONCE</span><span class="token punctuation">(</span>tp<span class="token operator">-&gt;</span>write_seq<span class="token punctuation">,</span> seq<span class="token punctuation">)</span><span class="token punctuation">;</span>            tp<span class="token operator">-&gt;</span>rx_opt<span class="token punctuation">.</span>ts_recent       <span class="token operator">=</span> tcptw<span class="token operator">-&gt;</span>tw_ts_recent<span class="token punctuation">;</span>            tp<span class="token operator">-&gt;</span>rx_opt<span class="token punctuation">.</span>ts_recent_stamp <span class="token operator">=</span> tcptw<span class="token operator">-&gt;</span>tw_ts_recent_stamp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">sock_hold</span><span class="token punctuation">(</span>sktw<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从源码实现中可以看出：</p><ol><li><p>因为 <code>tcp_twsk_unique</code> 函数最初只能由 <code>tcp_v4_connect</code> 函数调用，所以 <code>tcp_tw_reuse</code> 仅在 TCP 套接字作为客户端时起作用。</p></li><li><p>因为 <code>tcptw-&gt;tw_ts_recent_stamp</code> 的值要不为 0 ， 所以服务端发回的包中要包含 timestamp 数据才有效，这个功能可以通过设置 <code>net.ipv4.tcp_timestamps = 1</code>（默认为 1） 来开启。</p><blockquote><p><a href="https://datatracker.ietf.org/doc/html/rfc1323#section-3">RFC 1323</a> 引入了新的 TCP 选项：两个 4 字节的时间戳字段，用于记录 TCP 发送方的当前时间戳和从对端接收到的最新时间戳。此选项对应的解析代码在 <code>net/ipv4/tcp_input.c</code> 文件 <code>tcp_parse_options</code> 函数中的 <code>case TCPOPT_TIMESTAMP:</code> 下。</p></blockquote></li><li><p>因为 <code>time_after32(ktime_get_seconds(), tcptw-&gt;tw_ts_recent_stamp)</code> ，所以套接字必须要处于 <code>TIME-WAIT</code> 状态 1 秒及以上才行。</p></li></ol><h2 id="11-close-和-shutdown-SHUT-RDWR-的区别"><a href="#11-close-和-shutdown-SHUT-RDWR-的区别" class="headerlink" title="11. close() 和 shutdown(SHUT_RDWR) 的区别"></a>11. close() 和 shutdown(SHUT_RDWR) 的区别</h2><ol><li><p><code>close</code> 函数</p><ol><li>把套接字的引用计数减 1，如果引用计数达到 0 时才进行后面的步骤。</li><li>在输入方向上，系统内核会将改套接字设置为不可读，任何读操作都会返回异常；</li><li>在输出方向上，系统内核尝试将发送缓冲区的数据发送给对端，并最后向对端发送一个 FIN 报文，接下来如果再对该套接字进行写操作就会返回异常；</li><li>如果对端没有检测到套接字已关闭，还继续发送报文，就会收到一个 RST 报文。</li></ol></li><li><p><code>shutdown</code> 函数</p><ol><li><code>SHUT_RD</code> ：关闭连接的“读”，对改套接字进行读操作直接返回 EOF 。套接字上接收缓冲区已有的数据将会丢弃，如果还要新的数据流到达，会对数据进行 ACK ，然后悄悄地丢弃。</li><li><code>SHUT_WR</code> ：关闭连接的“写”，这常被称为“半关闭”的连接。不管套接字引用计数的值是多少，都会直接关闭连接的写方向。套接字上发送缓冲区已有的数据将被立即发送出去，并发送一个 FIN 报文给对端。应用程序如果再对该套接字进行写操作会出错。</li><li><code>SHUT_RDWR</code> ： 相当于 <code>SHUT_RD</code> 和 <code>SHUT_WR</code> 都操作一次。</li></ol></li><li><p><code>close()</code> 和 <code>shutdown(SHUT_RDWR)</code> 的区别</p><ol><li><code>close</code> 会关闭连接，并释放连接所对应的资源；而 <code>shutdown</code> 仅关闭连接，但不会释放连接所对应的资源。</li><li><code>close</code> 存在引用计数的概念，并不一定导致该套接字不可用； <code>shutdown</code> 则不管引用计数，直接使套接字不可用，如果有别的进程使用该套接字，将会受影响。</li><li><code>close</code> 的引用计数导致不一定会发出 FIN 结束报文； <code>shutdown</code> 总是会发送 FIN 结束报文。</li></ol></li></ol><h2 id="12-不会导致产生-ICMP-差错报文情况"><a href="#12-不会导致产生-ICMP-差错报文情况" class="headerlink" title="12. 不会导致产生 ICMP 差错报文情况"></a>12. 不会导致产生 ICMP 差错报文情况</h2><ol><li>ICMP 差错报文（ICMP 查询报文可能会产生 ICMP 差错报文）；</li><li>目的地址是广播地址或多播地址的 IP 数据报；</li><li>作为链路层广播的数据报；</li><li>不是 IP 分片的第一片；</li><li>源地址不是单个主机的数据报。这就是说，源地址不能为零地址、环回地址、广播地址或多播地址。</li></ol><h2 id="13-UDP-connect-的作用"><a href="#13-UDP-connect-的作用" class="headerlink" title="13. UDP connect 的作用"></a>13. UDP connect 的作用</h2><p>对 UDP 套接字进行 <code>connect</code> 操作的意义在于将该套接字和服务端的地址和端口绑定，如果操作系统收到了与该地址和端口匹配的网络错误（如 ICMP 不可达），后续在该套接字上的操作就能获取到这些错误。</p><h2 id="14-为什么推荐将监听套接字设置为非阻塞"><a href="#14-为什么推荐将监听套接字设置为非阻塞" class="headerlink" title="14. 为什么推荐将监听套接字设置为非阻塞"></a>14. 为什么推荐将监听套接字设置为非阻塞</h2><p>因为当 <code>accept</code> 和 I/O 多路复用 <code>select</code> 、 <code>poll</code> 等一起配合使用时，如果在监听套接字上触发了事件，说明有连接建立完成。但是在调用 <code>accept</code> 获取已连接的套接字之前，该连接被关闭了（如客户端发送了 RST），那么再调用 <code>accept</code> 将会阻塞程序。</p><h2 id="15-Reactor-和-Proactor-网络编程模式"><a href="#15-Reactor-和-Proactor-网络编程模式" class="headerlink" title="15. Reactor 和 Proactor 网络编程模式"></a>15. Reactor 和 Proactor 网络编程模式</h2><p><strong>Reactor 模式</strong> 基于待完成的 I/O 事件。每次感知到事件后再调用 <code>read</code> 、 <code>write</code> 方法完成数据的读写。如 <code>epoll</code>。</p><p><strong>Proactor 模式</strong> 基于已完成的 I/O 事件。它只负责感知事件完成，并由对应的 handler 发起异步读写请求, I/O 读写操作本身由操作系统内核完成。如：<code>IOCP</code>。</p><p>无论是 <strong>Reactor 模式</strong> 还是 <strong>Proactor 模式</strong> ，都是一种基于事件分发的网络编程模式。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IP </tag>
            
            <tag> TCP </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《动手学深度学习（第二版）》读书笔记</title>
      <link href="dong-shou-xue-shen-du-xue-xi-di-er-ban-du-shu-bi-ji/"/>
      <url>dong-shou-xue-shen-du-xue-xi-di-er-ban-du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="1-K折交叉验证"><a href="#1-K折交叉验证" class="headerlink" title="1. K折交叉验证"></a>1. <a href="https://zh-v2.d2l.ai/chapter_multilayer-perceptrons/underfit-overfit.html#k">K折交叉验证</a></h2><h3 id="1-1-K折交叉验证的原理"><a href="#1-1-K折交叉验证的原理" class="headerlink" title="1.1 K折交叉验证的原理"></a>1.1 K折交叉验证的原理</h3><p>原始训练数据被分成 $𝐾$ 个不重叠的子集。然后执行 $𝐾$ 次模型训练和验证，每次在 $𝐾−1$ 个子集上进行训练，并在剩余的一个子集（在该轮中没有用于训练的子集）上进行验证。最后，通过对 $𝐾$ 次实验的结果取平均来估计训练和验证误差。</p><h3 id="1-2-K折交叉验证的使用"><a href="#1-2-K折交叉验证的使用" class="headerlink" title="1.2 K折交叉验证的使用"></a>1.2 K折交叉验证的使用</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> torch<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> KFold<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data <span class="token keyword">import</span> DataLoader<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data<span class="token punctuation">.</span>dataset <span class="token keyword">import</span> Subset<span class="token keyword">def</span> <span class="token function">cross_valid</span><span class="token punctuation">(</span>k_fold<span class="token punctuation">,</span> model<span class="token punctuation">,</span> criterion<span class="token punctuation">,</span> optimizer<span class="token punctuation">,</span> dataset<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> num_epochs<span class="token punctuation">)</span><span class="token punctuation">:</span>    kf <span class="token operator">=</span> KFold<span class="token punctuation">(</span>n_splits<span class="token operator">=</span>k_fold<span class="token punctuation">,</span> shuffle<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> train_indices<span class="token punctuation">,</span> test_indices <span class="token keyword">in</span> kf<span class="token punctuation">.</span>split<span class="token punctuation">(</span>dataset<span class="token punctuation">)</span><span class="token punctuation">:</span>        train_dataset <span class="token operator">=</span> Subset<span class="token punctuation">(</span>dataset<span class="token punctuation">,</span> train_indices<span class="token punctuation">)</span>        test_dataset <span class="token operator">=</span> Subset<span class="token punctuation">(</span>dataset<span class="token punctuation">,</span> test_indices<span class="token punctuation">)</span>        train_losses<span class="token punctuation">,</span> test_losses <span class="token operator">=</span> train<span class="token punctuation">(</span>            model<span class="token punctuation">,</span> criterion<span class="token punctuation">,</span> optimizer<span class="token punctuation">,</span> train_dataset<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> num_epochs<span class="token punctuation">,</span> test_dataset<span class="token operator">=</span>test_dataset        <span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"train loss"</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>train_losses<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"test loss"</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>test_losses<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">train</span><span class="token punctuation">(</span>model<span class="token punctuation">,</span> criterion<span class="token punctuation">,</span> optimizer<span class="token punctuation">,</span> dataset<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> num_epochs<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">,</span> test_dataset<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    train_losses<span class="token punctuation">,</span> test_losses <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    dataloader <span class="token operator">=</span> DataLoader<span class="token punctuation">(</span>dataset<span class="token punctuation">,</span> batch_size<span class="token operator">=</span>batch_size<span class="token punctuation">,</span> shuffle<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> drop_last<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_epochs<span class="token punctuation">)</span><span class="token punctuation">:</span>        model<span class="token punctuation">.</span>train<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> features<span class="token punctuation">,</span> labels <span class="token keyword">in</span> dataloader<span class="token punctuation">:</span>            optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>            loss <span class="token operator">=</span> criterion<span class="token punctuation">(</span>model<span class="token punctuation">(</span>features<span class="token punctuation">)</span><span class="token punctuation">,</span> labels<span class="token punctuation">)</span>            loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>            optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>        model<span class="token punctuation">.</span>train<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>        <span class="token keyword">with</span> torch<span class="token punctuation">.</span>no_grad<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            train_loss <span class="token operator">=</span> criterion<span class="token punctuation">(</span>model<span class="token punctuation">(</span>dataset<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dataset<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            train_losses<span class="token punctuation">.</span>append<span class="token punctuation">(</span>train_loss<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> test_dataset<span class="token punctuation">:</span>                test_loss <span class="token operator">=</span> criterion<span class="token punctuation">(</span>model<span class="token punctuation">(</span>test_dataset<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> test_dataset<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                test_losses<span class="token punctuation">.</span>append<span class="token punctuation">(</span>test_loss<span class="token punctuation">)</span>    <span class="token keyword">return</span> train_losses<span class="token punctuation">,</span> test_losses<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完整代码：<a href="/images/《动手学深度学习（第二版）》读书笔记/kaggle_house_pred.py">kaggle_house_pred.py</a></p><h2 id="2-Dropout"><a href="#2-Dropout" class="headerlink" title="2. Dropout"></a>2. <a href="https://zh-v2.d2l.ai/chapter_multilayer-perceptrons/dropout.html">Dropout</a></h2><h3 id="2-1-Dropout的原理"><a href="#2-1-Dropout的原理" class="headerlink" title="2.1 Dropout的原理"></a>2.1 Dropout的原理</h3><p>在训练过程的每一次迭代中，dropout 在计算下一层之前将当前层中的一些节点置零。</p><p>dropout 的作者认为，神经网络过拟合的特征是每一层都依赖于前一层激活值的特定模式，称这种情况为“共适应性”。dropout 会破坏共适应性。</p><p>关键的挑战就是如何注入这种噪声。一种想法是以一种无偏的方式注入噪声。这样在固定住其他层时，每一层的期望值等于没有噪音时的值。</p><p>在毕晓普的工作中，他将高斯噪声添加到线性模型的输入中。在每次训练迭代中，他将从均值为零的分布 $\epsilon \sim \mathcal{N}(0,\sigma^2)$ 采样噪声添加到输入 $\mathbf{x}$ ，从而产生扰动点 $\mathbf{x}’ = \mathbf{x} + \epsilon$ 。预期是 $E[\mathbf{x}’] = \mathbf{x}$ 。</p><p>在标准 dropout 正则化中，通过按保留（未丢弃）的节点的分数进行归一化来消除每一层的偏差。换言之，每个中间激活值 $h$ 以 <em>丢弃概率</em> $p$ 由随机变量 $h’$ 替换，如下所示：</p><script type="math/tex; mode=display">\begin{aligned}h' =\begin{cases}    0 & \text{ 概率为 } p \\    \frac{h}{1-p} & \text{ 其他情况}\end{cases}\end{aligned}</script><p>根据设计，期望值保持不变，即 $E[h’] = h$ 。</p><h3 id="2-2-Dropout的实现"><a href="#2-2-Dropout的实现" class="headerlink" title="2.2 Dropout的实现"></a>2.2 Dropout的实现</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">dropout_layer</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> dropout<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">assert</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> dropout <span class="token operator">&lt;=</span> <span class="token number">1</span>    <span class="token comment"># 在本情况中，所有元素都被丢弃。</span>    <span class="token keyword">if</span> dropout <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> torch<span class="token punctuation">.</span>zeros_like<span class="token punctuation">(</span>X<span class="token punctuation">)</span>    <span class="token comment"># 在本情况中，所有元素都被保留。</span>    <span class="token keyword">if</span> dropout <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> X    mask <span class="token operator">=</span> <span class="token punctuation">(</span>torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">(</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token punctuation">.</span>uniform_<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> dropout<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> mask <span class="token operator">*</span> X <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">-</span> dropout<span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Net</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num_inputs<span class="token punctuation">,</span> num_outputs<span class="token punctuation">,</span> num_hiddens<span class="token punctuation">,</span> dropout<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fc1 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>num_inputs<span class="token punctuation">,</span> num_hiddens<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fc2 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>num_hiddens<span class="token punctuation">,</span> num_outputs<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>dropout <span class="token operator">=</span> dropout    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">:</span>        H1 <span class="token operator">=</span> torch<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>fc1<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>training<span class="token punctuation">:</span>            H1 <span class="token operator">=</span> dropout_layer<span class="token punctuation">(</span>H1<span class="token punctuation">,</span> self<span class="token punctuation">.</span>dropout<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>fc2<span class="token punctuation">(</span>H1<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-Xavier初始化"><a href="#3-Xavier初始化" class="headerlink" title="3. Xavier初始化"></a>3. <a href="https://zh-v2.d2l.ai/chapter_multilayer-perceptrons/numerical-stability-and-init.html#xavier">Xavier初始化</a></h2><h3 id="3-1-Xavier的原理"><a href="#3-1-Xavier的原理" class="headerlink" title="3.1 Xavier的原理"></a>3.1 Xavier的原理</h3><p>对于 <em>没有非线性</em> 的全连接层输出，该层 $n_\mathrm{in}$ 输入 $x_j$ 及其相关权重 $w_{ij}$ ，其输出由下式给出</p><script type="math/tex; mode=display">o_{i} = \sum_{j=1}^{n_\mathrm{in}} w_{ij} x_j</script><p>权重 $w_{ij}$ 都是从同一分布中独立抽取的。假设该分布具有零均值和方差 $\sigma^2$ 。注意，这并不意味着分布必须是高斯的，只是均值和方差需要存在。</p><p>同时，假设层 $x_j$ 的输入也具有零均值和方差 $\gamma^2$ （<strong>因为对于训练数据，我们常常会做归一化</strong>），并且它们独立于 $w_{ij}$ 并且彼此独立。</p><p>在这种情况下，可以按如下方式计算 $o_i$ 的平均值和方差：</p><script type="math/tex; mode=display">\begin{aligned}E[o_i]& = \sum_{j=1}^{n_\mathrm{in}} E[w_{ij} x_j] \\& = \sum_{j=1}^{n_\mathrm{in}} E[w_{ij}] E[x_j] \\& = 0 \\\\\mathrm{Var}[o_i]& = E[o_i^2] - (E[o_i])^2 \\& = \sum_{j=1}^{n_\mathrm{in}} E[w^2_{ij} x^2_j] - 0 \\& = \sum_{j=1}^{n_\mathrm{in}} E[w^2_{ij}] E[x^2_j] \\& = n_\mathrm{in} \sigma^2 \gamma^2\end{aligned}</script><p>为了避免梯度爆炸，所以需要保持输出方差 $n_\mathrm{in} \sigma^2 \gamma^2$ 与输入方差 $\gamma^2$ 不变，一种方法是设置 $n_\mathrm{in} \sigma^2 = 1$ 。在反向传播过程，有类似的问题，尽管梯度是从更靠近输出的层传播的。与正向传播类似，除非 $n_\mathrm{out} \sigma^2 = 1$ ，否则梯度的方差可能会增大，其中 $n_\mathrm{out}$ 是该层的输出的数量。</p><p>我们不可能同时满足 $n_\mathrm{in} \sigma^2 = 1$ 和 $n_\mathrm{out} \sigma^2 = 1$ 这两个条件。相反，可以选择一个折中的方案：</p><script type="math/tex; mode=display">\begin{aligned}\frac{1}{2} (n_\mathrm{in} + n_\mathrm{out}) \sigma^2 = 1 \text{ 或等价于 }\sigma = \sqrt{\frac{2}{n_\mathrm{in} + n_\mathrm{out}}}\end{aligned}</script><p>这就是 <em>Xavier初始化</em> 的基础，通常，Xavier 初始化从均值为零，方差 $\sigma^2 = \frac{2}{n_\mathrm{in} + n_\mathrm{out}}$ 的高斯分布中采样权重。</p><p>也可以利用 Xavier 的直觉来选择从均匀分布中抽取权重时的方差。注意，公式有对于均匀分布 $U(-a, a)$ 其方差为 $\frac{a^2}{3}$ 。将 $\frac{a^2}{3}$ 代入到 $\sigma^2$ 的条件中，得到：</p><script type="math/tex; mode=display">U\left(-\sqrt{\frac{6}{n_\mathrm{in} + n_\mathrm{out}}}, \sqrt{\frac{6}{n_\mathrm{in} + n_\mathrm{out}}}\right)</script><p>尽管上述数学推理中，不存在非线性的假设在神经网络中很容易被违反，但 Xavier 初始化方法在实践中被证明是有效的。</p><h3 id="3-2-应用到线性激活函数"><a href="#3-2-应用到线性激活函数" class="headerlink" title="3.2 应用到线性激活函数"></a>3.2 应用到线性激活函数</h3><p><a href="https://www.bilibili.com/video/BV1u64y1i75a?p=2">数值稳定性 + 模型初始化和激活函数【动手学深度学习v2】</a></p><p>对于 <strong>线性激活函数</strong> $\sigma(x) = \alpha x + \beta$ ，假设其输入 $x$ 具有零均值和方差 $\alpha^2$。</p><p>激活函数输出 $o_i$ 的均值：</p><script type="math/tex; mode=display">E[o_i] = E[\alpha x_i + \beta] = \beta</script><p>为了保持输出均值不变，则 $\beta$ 应当等于 0，即 $\beta = 0$ 。</p><p>激活函数输出 $o_i$ 的方差：</p><script type="math/tex; mode=display">\begin{aligned}\mathrm{Var}[o_i]& = E[o_i^2] - E[o_i]^2 \\& = E[(\alpha x_i + \beta)^2] - \beta^2 \\& = E[\alpha^2 x_i^2 + 2 \alpha \beta x_i + \beta^2] - \beta^2 \\& = \alpha^2 \mathrm{Var}[x_i]\end{aligned}</script><p>为了保持输出方差依然为 $\alpha^2$ ，则 $\alpha^2 \mathrm{Var}[x_i]$ 应当等于 $\mathrm{Var}[x_i]$ ，即 $\alpha = 1$ 。</p><p>在反向传播过程，结论依然是一样的，即 $\beta = 0$ 和 $\alpha = 1$ 。</p><p>综上，如果想要让激活函数不改变输入输出数据的均值和方差的话，需要 $\beta = 0$ 和 $\alpha = 1$ ，即激活函数需要让输出数据等于输入数据 $f(x) = x$。</p><h3 id="3-3-常用激活函数的性质"><a href="#3-3-常用激活函数的性质" class="headerlink" title="3.3 常用激活函数的性质"></a>3.3 常用激活函数的性质</h3><p><img src="/images/《动手学深度学习（第二版）》读书笔记/常用激活函数的曲线.png" alt="常用激活函数的曲线"></p><p>对于常用的激活函数使用泰勒展开：</p><script type="math/tex; mode=display">\begin{aligned}\mathrm{sigmoid}(x) &= \frac{1}{2} + \frac{x}{4} - \frac{x^3}{48} + O(x^5) \\\mathrm{tanh}(x) &= 0 + x - \frac{x^3}{3} + O(x^5) \\\mathrm{relu}(x) &= 0 + x \text{ for } \ge 0 \\\end{aligned}</script><p>可以发现，在零点附近（神经网络的值通常也在零点附近）， $\mathrm{tanh}(x)$ 和 $\mathrm{relu}(x)$ 都是近似于 $f(x) = x$ 这样的函数。但是 $\mathrm{sigmoid}(x)$ 却不是的。所以可以调整 sigmoid 函数来满足需求：</p><script type="math/tex; mode=display">4 \times \mathrm{sigmoid}(x) - 2</script><h2 id="4-卷积神经网络"><a href="#4-卷积神经网络" class="headerlink" title="4. 卷积神经网络"></a>4. 卷积神经网络</h2><h3 id="4-1-基本的卷积运算"><a href="#4-1-基本的卷积运算" class="headerlink" title="4.1 基本的卷积运算"></a>4.1 基本的卷积运算</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">corr2d</span><span class="token punctuation">(</span>X<span class="token punctuation">:</span> torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">,</span> K<span class="token punctuation">:</span> torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    &gt;&gt;&gt; X = torch.tensor([[0.0, 1.0, 2.0],    ...                   [3.0, 4.0, 5.0],    ...                   [6.0, 7.0, 8.0]])    &gt;&gt;&gt; K = torch.tensor([[0.0, 1.0],    ...                   [2.0, 3.0]])    &gt;&gt;&gt; corr2d(X, K)    tensor([[19., 25.],            [37., 43.]])    """</span>    h<span class="token punctuation">,</span> w <span class="token operator">=</span> K<span class="token punctuation">.</span>shape    Y <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> h <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> w <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>Y<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>Y<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            Y<span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>X<span class="token punctuation">[</span>i <span class="token punctuation">:</span> i <span class="token operator">+</span> h<span class="token punctuation">,</span> j <span class="token punctuation">:</span> j <span class="token operator">+</span> w<span class="token punctuation">]</span> <span class="token operator">*</span> K<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> Y<span class="token keyword">class</span> <span class="token class-name">Conv2D</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> kernel_size<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>weight <span class="token operator">=</span> nn<span class="token punctuation">.</span>Parameter<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span>kernel_size<span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>bias <span class="token operator">=</span> nn<span class="token punctuation">.</span>Parameter<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> corr2d<span class="token punctuation">(</span>x<span class="token punctuation">,</span> self<span class="token punctuation">.</span>weight<span class="token punctuation">)</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>bias<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-多通道输入的卷积运算"><a href="#4-2-多通道输入的卷积运算" class="headerlink" title="4.2 多通道输入的卷积运算"></a>4.2 多通道输入的卷积运算</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">corr2d_multi_in</span><span class="token punctuation">(</span>X<span class="token punctuation">:</span> torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">,</span> K<span class="token punctuation">:</span> torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    &gt;&gt;&gt; X = torch.tensor([[[0.0, 1.0, 2.0],    ...                    [3.0, 4.0, 5.0],    ...                    [6.0, 7.0, 8.0]],    ...                   [[1.0, 2.0, 3.0],    ...                    [4.0, 5.0, 6.0],    ...                    [7.0, 8.0, 9.0]]])    &gt;&gt;&gt; K = torch.tensor([[[0.0, 1.0],    ...                    [2.0, 3.0]],    ...                   [[1.0, 2.0],    ...                    [3.0, 4.0]]])    &gt;&gt;&gt; corr2d_multi_in(X, K)    tensor([[ 56.,  72.],            [104., 120.]])    """</span>    <span class="token keyword">return</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>corr2d<span class="token punctuation">(</span>x<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token keyword">for</span> x<span class="token punctuation">,</span> k <span class="token keyword">in</span> <span class="token builtin">zip</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> K<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3-多通道输入输出的卷积运算"><a href="#4-3-多通道输入输出的卷积运算" class="headerlink" title="4.3 多通道输入输出的卷积运算"></a>4.3 多通道输入输出的卷积运算</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">corr2d_multi_in_out</span><span class="token punctuation">(</span>X<span class="token punctuation">:</span> torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">,</span> K<span class="token punctuation">:</span> torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    &gt;&gt;&gt; X = torch.tensor([[[0.0, 1.0, 2.0],    ...                    [3.0, 4.0, 5.0],    ...                    [6.0, 7.0, 8.0]],    ...                   [[1.0, 2.0, 3.0],    ...                    [4.0, 5.0, 6.0],    ...                    [7.0, 8.0, 9.0]]])    &gt;&gt;&gt; K = torch.tensor([[[0.0, 1.0],    ...                    [2.0, 3.0]],    ...                   [[1.0, 2.0],    ...                    [3.0, 4.0]]])    &gt;&gt;&gt; K = torch.stack((K, K + 1, K + 2), 0)    &gt;&gt;&gt; K.shape    torch.Size([3, 2, 2, 2])    &gt;&gt;&gt; corr2d_multi_in_out(X, K)    tensor([[[ 56.,  72.],             [104., 120.]],    &lt;BLANKLINE&gt;            [[ 76., 100.],             [148., 172.]],    &lt;BLANKLINE&gt;            [[ 96., 128.],             [192., 224.]]])    """</span>    <span class="token keyword">return</span> torch<span class="token punctuation">.</span>stack<span class="token punctuation">(</span><span class="token punctuation">[</span>corr2d_multi_in<span class="token punctuation">(</span>X<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token keyword">for</span> k <span class="token keyword">in</span> K<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-批量归一化"><a href="#5-批量归一化" class="headerlink" title="5. 批量归一化"></a>5. <a href="https://zh-v2.d2l.ai/chapter_convolutional-modern/batch-norm.html">批量归一化</a></h2><h3 id="5-1-批量归一化的原理"><a href="#5-1-批量归一化的原理" class="headerlink" title="5.1 批量归一化的原理"></a>5.1 批量归一化的原理</h3><p>批量归一化应用于单个可选层（也可以应用到所有层），其原理是：在每次训练迭代中，归一化输入，即通过减去其均值并除以其标准差，其中两者均基于当前小批量处理。</p><p>注意，不能使用大小为 1 的批量应用批量归一化。因为在减去均值之后，每个隐藏单元将为 0。在应用批量归一化时，批量大小的选择可能比没有批量归一化时更重要。</p><p>用 $\mathbf{x} \in \mathcal{B}$ 表示一个来自小批量 $\mathcal{B}$ 的输入，批量归一化 $\mathrm{BN}$ 表达式为：</p><script type="math/tex; mode=display">\begin{aligned}\mathrm{BN}(\mathbf{x}) &= \boldsymbol{\gamma} \odot \frac{\mathbf{x} - \hat{\boldsymbol{\mu}}_\mathcal{B}}{\hat{\boldsymbol{\sigma}}_\mathcal{B}} + \boldsymbol{\beta} \\\\\hat{\boldsymbol{\mu}}_\mathcal{B} &= \frac{1}{|\mathcal{B}|} \sum_{\mathbf{x} \in \mathcal{B}} \mathbf{x}\\\hat{\boldsymbol{\sigma}}_\mathcal{B}^2 &= \frac{1}{|\mathcal{B}|} \sum_{\mathbf{x} \in \mathcal{B}} (\mathbf{x} - \hat{\boldsymbol{\mu}}_{\mathcal{B}})^2 + \epsilon\end{aligned}</script><p>其中，$\hat{\boldsymbol{\mu}}_\mathcal{B}$ 是样本均值，$\hat{\boldsymbol{\sigma}}_\mathcal{B}$ 是小批量 $\mathcal{B}$ 的样本标准差。小常量 $\epsilon &gt; 0$ 确保不会除以零。</p><p>应用标准化后，生成的小批量的平均值为 0 和单位方差为 1。由于单位方差（与其他一些魔法数）是一个任意的选择，因此通常包含 <em>拉伸参数</em>（scale） $\boldsymbol{\gamma}$ 和 <em>偏移参数</em>（shift） $\boldsymbol{\beta}$，它们的形状与 $\mathbf{x}$ 相同。注意，$\boldsymbol{\gamma}$ 和 $\boldsymbol{\beta}$ 也是需要与其他模型参数一起学习的参数。</p><h3 id="5-2-批量归一化层的应用"><a href="#5-2-批量归一化层的应用" class="headerlink" title="5.2 批量归一化层的应用"></a>5.2 批量归一化层的应用</h3><ol><li><p>全连接层</p><p> 通常将批量归一化层置于全连接层中的仿射变换和激活函数之间。</p></li><li><p>卷积层</p><p> 通常在卷积层之后和非线性激活函数之前应用批量归一化。</p><p> 当卷积有多个输出通道时，需要对这些通道的“每个”输出执行批量归一化，每个通道都有自己的拉伸（scale）和偏移（shift）参数，这两个参数都是标量。</p></li><li><p>预测过程中的批量归一化</p><p> 一种常用的方法是通过移动平均估算整个训练数据集的样本均值和方差，并在预测时使用它们得到确定的输出。</p></li></ol><h3 id="5-3-批量归一化的实现"><a href="#5-3-批量归一化的实现" class="headerlink" title="5.3 批量归一化的实现"></a>5.3 批量归一化的实现</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">batch_norm</span><span class="token punctuation">(</span>    X<span class="token punctuation">:</span> torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">,</span>    gamma<span class="token punctuation">:</span> torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">,</span>    beta<span class="token punctuation">:</span> torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">,</span>    moving_mean<span class="token punctuation">:</span> torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">,</span>    moving_var<span class="token punctuation">:</span> torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">,</span>    eps<span class="token punctuation">:</span> <span class="token builtin">float</span><span class="token punctuation">,</span>    momentum<span class="token punctuation">:</span> <span class="token builtin">float</span><span class="token punctuation">,</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Tuple<span class="token punctuation">[</span>torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">,</span> torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">,</span> torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">]</span><span class="token punctuation">:</span>    <span class="token comment"># 通过 `is_grad_enabled` 来判断当前模式是训练模式还是预测模式</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> torch<span class="token punctuation">.</span>is_grad_enabled<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 如果是在预测模式下，直接使用传入的移动平均所得的均值和方差</span>        X_hat <span class="token operator">=</span> <span class="token punctuation">(</span>X <span class="token operator">-</span> moving_mean<span class="token punctuation">)</span> <span class="token operator">/</span> torch<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>moving_var <span class="token operator">+</span> eps<span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">assert</span> <span class="token builtin">len</span><span class="token punctuation">(</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token comment"># 使用全连接层的情况，计算特征维上的均值和方差</span>            mean <span class="token operator">=</span> X<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>            var <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>X <span class="token operator">-</span> mean<span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># 使用二维卷积层的情况，计算通道维上（axis=1）的均值和方差。</span>            <span class="token comment"># 这里我们需要保持X的形状以便后面可以做广播运算</span>            mean <span class="token operator">=</span> X<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> keepdim<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>            var <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>X <span class="token operator">-</span> mean<span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> keepdim<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>        <span class="token comment"># 训练模式下，用当前的均值和方差做标准化</span>        X_hat <span class="token operator">=</span> <span class="token punctuation">(</span>X <span class="token operator">-</span> mean<span class="token punctuation">)</span> <span class="token operator">/</span> torch<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>var <span class="token operator">+</span> eps<span class="token punctuation">)</span>        <span class="token comment"># 更新移动平均的均值和方差</span>        moving_mean <span class="token operator">=</span> momentum <span class="token operator">*</span> moving_mean <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">-</span> momentum<span class="token punctuation">)</span> <span class="token operator">*</span> mean        moving_var <span class="token operator">=</span> momentum <span class="token operator">*</span> moving_var <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">-</span> momentum<span class="token punctuation">)</span> <span class="token operator">*</span> var    Y <span class="token operator">=</span> gamma <span class="token operator">*</span> X_hat <span class="token operator">+</span> beta  <span class="token comment"># 缩放和移位</span>    <span class="token keyword">return</span> Y<span class="token punctuation">,</span> moving_mean<span class="token punctuation">.</span>data<span class="token punctuation">,</span> moving_var<span class="token punctuation">.</span>data<span class="token keyword">class</span> <span class="token class-name">BatchNorm</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># `num_features`：完全连接层的输出数量或卷积层的输出通道数</span>    <span class="token comment"># `num_dims`：2表示完全连接层，4表示卷积层</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num_features<span class="token punctuation">,</span> num_dims<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> num_dims <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>            shape <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> num_features<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            shape <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> num_features<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment"># 参与求梯度和迭代的拉伸和偏移参数，分别初始化成1和0</span>        self<span class="token punctuation">.</span>gamma <span class="token operator">=</span> nn<span class="token punctuation">.</span>Parameter<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>ones<span class="token punctuation">(</span>shape<span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>beta <span class="token operator">=</span> nn<span class="token punctuation">.</span>Parameter<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>shape<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># 非模型参数的变量初始化为0和1</span>        self<span class="token punctuation">.</span>moving_mean <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>shape<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>moving_var <span class="token operator">=</span> torch<span class="token punctuation">.</span>ones<span class="token punctuation">(</span>shape<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 如果 `X` 不在内存上，将 `moving_mean` 和 `moving_var`</span>        <span class="token comment"># 复制到 `X` 所在显存上</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>moving_mean<span class="token punctuation">.</span>device <span class="token operator">!=</span> X<span class="token punctuation">.</span>device<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>moving_mean <span class="token operator">=</span> self<span class="token punctuation">.</span>moving_mean<span class="token punctuation">.</span>to<span class="token punctuation">(</span>X<span class="token punctuation">.</span>device<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>moving_var <span class="token operator">=</span> self<span class="token punctuation">.</span>moving_var<span class="token punctuation">.</span>to<span class="token punctuation">(</span>X<span class="token punctuation">.</span>device<span class="token punctuation">)</span>        <span class="token comment"># 保存更新过的 `moving_mean` 和 `moving_var`</span>        Y<span class="token punctuation">,</span> self<span class="token punctuation">.</span>moving_mean<span class="token punctuation">,</span> self<span class="token punctuation">.</span>moving_var <span class="token operator">=</span> batch_norm<span class="token punctuation">(</span>            X<span class="token punctuation">,</span> self<span class="token punctuation">.</span>gamma<span class="token punctuation">,</span> self<span class="token punctuation">.</span>beta<span class="token punctuation">,</span> self<span class="token punctuation">.</span>moving_mean<span class="token punctuation">,</span> self<span class="token punctuation">.</span>moving_var<span class="token punctuation">,</span> eps<span class="token operator">=</span><span class="token number">1e</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span> momentum<span class="token operator">=</span><span class="token number">0.9</span>        <span class="token punctuation">)</span>        <span class="token keyword">return</span> Y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-残差网络（ResNet）"><a href="#6-残差网络（ResNet）" class="headerlink" title="6. 残差网络（ResNet）"></a>6. <a href="https://zh-v2.d2l.ai/chapter_convolutional-modern/resnet.html">残差网络（ResNet）</a></h2><h3 id="6-1-函数类"><a href="#6-1-函数类" class="headerlink" title="6.1 函数类"></a>6.1 函数类</h3><p>对于神经网络结构 $\mathcal{F}$ ，它能表达出来的所有 $f \in \mathcal{F}$ 。假设 $f^*$ 是想找的函数，</p><ol><li><p>如果是 $f^* \in \mathcal{F}$，可以通过训练直接得到它，但很多时候要找的最优函数不在神经网络能表达出来的函数集中。</p></li><li><p>对于要找的最优函数不在神经网络能表达出来的函数集中情况，可以在 $\mathcal{F}$ 中找一个尽可能接近 <script type="math/tex">f^*</script> 函数的函数 <script type="math/tex">f^*_\mathcal{F}</script> 。</p><p> 如何得到更近似真正 $f^*$ 函数的函数呢？</p><p> 可以设计一个更强大的结构 $\mathcal{F}’$ ，它所能表达的函数应当严格的比 $\mathcal{F}$ 所能表达的函数更多，并且$\mathcal{F}$ 所能表达的函数，$\mathcal{F}’$ 应当都能表示。</p><p> 对于非嵌套函数（non-nested function）类，并不一定满足上述的需求（复杂度由 $\mathcal{F}_1$ 向 $\mathcal{F}_6$ 递增）。而对于嵌套函数（nested function）类 $\mathcal{F}_1 \subseteq \ldots \subseteq \mathcal{F}_6$，则能满足上述的需求。</p><p> <img src="/images/《动手学深度学习（第二版）》读书笔记/函数类.svg" alt="函数类"></p><p> 因此，只有当较复杂的函数类包含较简单的函数类时，才能确保复杂的函数类中能找到更近似真正 $f^*$ 函数的函数。</p><p> 对于深度神经网络，如果能将新添加的层训练成 <strong>恒等映射</strong>（identity function） $f(\mathbf{x}) = \mathbf{x}$ ，新模型和原模型将同样有效。同时，由于新模型可能得出更优的解来拟合训练数据集，因此添加层似乎更容易降低训练误差。这也是 <strong>残差网络的核心思想：每个附加层都应该更容易地包含原始函数作为其元素之一。</strong></p></li></ol><h3 id="6-2-残差块"><a href="#6-2-残差块" class="headerlink" title="6.2 残差块"></a>6.2 残差块</h3><p>残差网络由残差块构成。对于每个残差块，假设输入为 $x$ ，希望学出的理想映射为 $f(\mathbf{x})$ 。</p><p><img src="/images/《动手学深度学习（第二版）》读书笔记/正常块和残差块.svg" alt="正常块和残差块"></p><p>对于上图左边的正常块虚线框中的部分需要直接拟合出该映射 $f(\mathbf{x})$ ， 而上图中右边的残差块虚线框中的部分则需要拟合出残差映射 $f(\mathbf{x}) - \mathbf{x}$ 。</p><p>残差映射在现实中往往更容易优化。假如希望学出的理想映射 $f(\mathbf{x})$ 是一个恒等映射 $f(\mathbf{x}) = \mathbf{x}$ ，只需将上图中右边的残差块虚线框上方的加权运算（如仿射）的权重和偏置参数设成 0， $f(\mathbf{x})$ 即为恒等映射。</p><p>实际中，当理想映射 $f(\mathbf{x})$ 极接近于恒等映射时，残差映射也易于捕捉恒等映射的细微波动。在残差块中，输入可通过跨层数据线路更快地向前传播。</p><h3 id="6-3-实现残差块"><a href="#6-3-实现残差块" class="headerlink" title="6.3 实现残差块"></a>6.3 实现残差块</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Residual</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> input_channels<span class="token punctuation">,</span> num_channels<span class="token punctuation">,</span> use_1x1conv<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> strides<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>conv1 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>input_channels<span class="token punctuation">,</span> num_channels<span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> stride<span class="token operator">=</span>strides<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>conv2 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>num_channels<span class="token punctuation">,</span> num_channels<span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> use_1x1conv<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>conv3 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>input_channels<span class="token punctuation">,</span> num_channels<span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> stride<span class="token operator">=</span>strides<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>conv3 <span class="token operator">=</span> <span class="token boolean">None</span>        self<span class="token punctuation">.</span>bn1 <span class="token operator">=</span> nn<span class="token punctuation">.</span>BatchNorm2d<span class="token punctuation">(</span>num_channels<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>bn2 <span class="token operator">=</span> nn<span class="token punctuation">.</span>BatchNorm2d<span class="token punctuation">(</span>num_channels<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>relu <span class="token operator">=</span> nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span>inplace<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">:</span>        Y <span class="token operator">=</span> F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>bn1<span class="token punctuation">(</span>self<span class="token punctuation">.</span>conv1<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        Y <span class="token operator">=</span> self<span class="token punctuation">.</span>bn2<span class="token punctuation">(</span>self<span class="token punctuation">.</span>conv2<span class="token punctuation">(</span>Y<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>conv3<span class="token punctuation">:</span>            X <span class="token operator">=</span> self<span class="token punctuation">.</span>conv3<span class="token punctuation">(</span>X<span class="token punctuation">)</span>        Y <span class="token operator">+=</span> X        <span class="token keyword">return</span> F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>Y<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码生成两种类型的网络：</p><ul><li>一种是在 <code>use_1x1conv=False</code> 、应用 ReLU 非线性函数之前，将输入添加到输出。</li><li>另一种是在 <code>use_1x1conv=True</code> 时，添加通过 $1 \times 1$ 卷积调整通道和分辨率。</li></ul><p><img src="/images/《动手学深度学习（第二版）》读书笔记/包含以及不包含1x1卷积层的残差块.svg" alt="包含以及不包含1x1卷积层的残差块"></p><h2 id="7-梯度裁剪"><a href="#7-梯度裁剪" class="headerlink" title="7. 梯度裁剪"></a>7. <a href="https://zh-v2.d2l.ai/chapter_recurrent-neural-networks/rnn-scratch.html">梯度裁剪</a></h2><h3 id="7-1-梯度裁剪的原理"><a href="#7-1-梯度裁剪的原理" class="headerlink" title="7.1 梯度裁剪的原理"></a>7.1 梯度裁剪的原理</h3><p>训练的过程中，有时梯度可能很大，从而导致算法无法收敛。虽然可以降低学习率来缓解这个问题，但是如果训练过程中很少得到大的梯度时就不可行了。</p><p>一个流行的方案是通过将梯度 $\mathbf{g}$ 投影回给定半径（例如 $\theta$ ）的球来裁剪梯度 $\mathbf{g}$ 。如下式：</p><script type="math/tex; mode=display">\mathbf{g} \leftarrow \min\left(1, \frac{\theta}{\|\mathbf{g}\|}\right) \mathbf{g}</script><p>裁剪后的梯度范数不会超过 $\theta$ ，方向与 $\mathbf{g}$ 的原始方向对齐。它还有一个好处是限制任何给定的小批量数据（以及其中任何给定的样本）对参数向量的影响，让模型的训练更加稳定。</p><p>梯度裁剪提供了一个快速修复梯度爆炸的方法。</p><h3 id="7-2-梯度裁剪的实现"><a href="#7-2-梯度裁剪的实现" class="headerlink" title="7.2 梯度裁剪的实现"></a>7.2 梯度裁剪的实现</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">grad_clipping</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> theta<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>        params <span class="token operator">=</span> <span class="token punctuation">[</span>p <span class="token keyword">for</span> p <span class="token keyword">in</span> net<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">if</span> p<span class="token punctuation">.</span>requires_grad<span class="token punctuation">]</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        params <span class="token operator">=</span> net<span class="token punctuation">.</span>params    norm <span class="token operator">=</span> torch<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span><span class="token builtin">sum</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>grad <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">for</span> p <span class="token keyword">in</span> params<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> norm <span class="token operator">&gt;</span> theta<span class="token punctuation">:</span>        <span class="token keyword">for</span> param <span class="token keyword">in</span> params<span class="token punctuation">:</span>            param<span class="token punctuation">.</span>grad<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">*=</span> theta <span class="token operator">/</span> norm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-语言模型"><a href="#8-语言模型" class="headerlink" title="8. 语言模型"></a>8. <a href="https://zh-v2.d2l.ai/chapter_recurrent-neural-networks/language-models-and-dataset.html#sec-language-model">语言模型</a></h2><h3 id="8-1-语言模型的定义"><a href="#8-1-语言模型的定义" class="headerlink" title="8.1 语言模型的定义"></a>8.1 语言模型的定义</h3><p>语言模型的本质是一个模型（可以理解为一个函数）。对于一段长度为 $T$ 的文本序列，其词元依次为 $x_1, x_2, \ldots, x_T$ ，通过这个模型可以计算出该序列出现的概率，即：</p><script type="math/tex; mode=display">P(x_1, x_2, \ldots, x_T)</script><h3 id="8-2-学习语言模型"><a href="#8-2-学习语言模型" class="headerlink" title="8.2 学习语言模型"></a>8.2 学习语言模型</h3><p>学习语言模型的过程就是用一个神经网络去拟合真实的语言模型的过程。</p><p>基本的概率规则：</p><script type="math/tex; mode=display">P(x_1, x_2, \ldots, x_T) = \prod_{t=1}^T P(x_t  \mid  x_1, \ldots, x_{t-1})</script><p>例如，包含了四个单词的一个文本序列的概率是：</p><script type="math/tex; mode=display">P(\text{deep}, \text{learning}, \text{is}, \text{fun}) =  P(\text{deep}) P(\text{learning}  \mid  \text{deep}) P(\text{is}  \mid  \text{deep}, \text{learning}) P(\text{fun}  \mid  \text{deep}, \text{learning}, \text{is})</script><p>为了计算语言模型，我们需要计算单词的概率和给定前面几个单词后出现某个单词的条件概率。这些概率本质上就是语言模型的参数。</p><h2 id="9-困惑度（Perplexity）"><a href="#9-困惑度（Perplexity）" class="headerlink" title="9. 困惑度（Perplexity）"></a>9. <a href="https://zh-v2.d2l.ai/chapter_recurrent-neural-networks/rnn.html#perplexity">困惑度（Perplexity）</a></h2><p>如果想要压缩文本（在循环神经网络中，会把一段文本都压缩进隐状态中），可以询问根据当前词元集预测的下一个词元。一个更好的语言模型应该能更准确地预测下一个词元。</p><p>所以可以通过一个序列中所有的 $n$ 个词元的交叉熵损失的平均值来衡量：</p><script type="math/tex; mode=display">\frac{1}{n} \sum_{t=1}^n -\log P(x_t \mid x_{t-1}, \ldots, x_1)</script><p>其中 $P$ 由语言模型给出， $x_t$ 是在时间步 $t$ 从该序列中观察到的实际词元。由于历史原因，自然语言处理的科学家更喜欢使用一个叫做 <em>困惑度</em>（perplexity）的量。它是上面公式的指数：</p><script type="math/tex; mode=display">\exp\left(-\frac{1}{n} \sum_{t=1}^n \log P(x_t \mid x_{t-1}, \ldots, x_1)\right)</script><p>当需要决定下一个词元是哪个时，困惑度最好的理解是下一个词元的实际选择数的调和平均数。比如：</p><ul><li>在最好的情况下，模型总是完美地估计标签词元的概率为1。在这种情况下，模型的困惑度为1。</li><li>在最坏的情况下，模型总是预测标签词元的概率为0。在这种情况下，困惑度是正无穷大。</li><li>在基线上，该模型的预测是词汇表的所有可用词元上的均匀分布。在这种情况下，困惑度等于词汇表中唯一词元的数量。事实上，如果我们在没有任何压缩的情况下存储序列，这将是我们能做的最好的编码方式。因此，这种方式提供了一个重要的上限，而任何实际的语言模型都必须超越这个上限。</li></ul><h2 id="10-循环神经网络"><a href="#10-循环神经网络" class="headerlink" title="10. 循环神经网络"></a>10. <a href="https://zh-v2.d2l.ai/chapter_recurrent-neural-networks/index.html">循环神经网络</a></h2><p>完整的代码：<a href="/images/《动手学深度学习（第二版）》读书笔记/time_machine.py">time_machine.py</a></p><h3 id="10-1-使用循环神经网络进行预测"><a href="#10-1-使用循环神经网络进行预测" class="headerlink" title="10.1 使用循环神经网络进行预测"></a>10.1 <a href="https://zh-v2.d2l.ai/chapter_recurrent-neural-networks/rnn-scratch.html">使用循环神经网络进行预测</a></h3><p>prefix 是用于预测的字符串。循环遍历 prefix 中的字符，不断地将隐藏状态传递到下一个时间步，但不生成任何输出。这被称为“预热”（warm-up）期，因为在此期间模型会自我更新（例如，更新隐藏状态），但不会进行预测。预热期结束后，隐藏状态的值通常比刚开始的初始值更适合预测，从而预测字符并输出它们。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">predict_ch8</span><span class="token punctuation">(</span>prefix<span class="token punctuation">,</span> num_preds<span class="token punctuation">,</span> net<span class="token punctuation">,</span> vocab<span class="token punctuation">,</span> device<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""在`prefix`后面生成新字符。"""</span>    state <span class="token operator">=</span> net<span class="token punctuation">.</span>begin_state<span class="token punctuation">(</span>batch_size<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> device<span class="token operator">=</span>device<span class="token punctuation">)</span>    outputs <span class="token operator">=</span> <span class="token punctuation">[</span>vocab<span class="token punctuation">[</span>prefix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">get_input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span>outputs<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> device<span class="token operator">=</span>device<span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> y <span class="token keyword">in</span> prefix<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span>  <span class="token comment"># 预热期</span>        _<span class="token punctuation">,</span> state <span class="token operator">=</span> net<span class="token punctuation">(</span>get_input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> state<span class="token punctuation">)</span>        outputs<span class="token punctuation">.</span>append<span class="token punctuation">(</span>vocab<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_preds<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 预测`num_preds`步</span>        y<span class="token punctuation">,</span> state <span class="token operator">=</span> net<span class="token punctuation">(</span>get_input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> state<span class="token punctuation">)</span>        outputs<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>y<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span>vocab<span class="token punctuation">.</span>idx_to_token<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> outputs<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-2-使用循环神经网络进行训练"><a href="#10-2-使用循环神经网络进行训练" class="headerlink" title="10.2 使用循环神经网络进行训练"></a>10.2 <a href="https://zh-v2.d2l.ai/chapter_recurrent-neural-networks/rnn-scratch.html">使用循环神经网络进行训练</a></h3><p>在训练模型之前，让我们定义一个函数在一个迭代周期内训练模型。</p><ol><li><p>序列数据的不同采样方法（<a href="https://zh-v2.d2l.ai/chapter_recurrent-neural-networks/language-models-and-dataset.html">随机采样和顺序分区</a>）将导致隐藏状态初始化的差异。</p><blockquote><p>随机采样和顺序分区这两种采样的主要区别就是，顺序分区采样出来的数据两个相邻的小批量中的子序列在原始序列上也是相邻的，而随机采样不是。</p></blockquote></li><li><p>在更新模型参数之前裁剪梯度。这样的操作即使训练过程中某个点上发生了梯度爆炸，也能保证模型不会发散。</p></li><li><p>用困惑度来评价模型。这样的度量确保了不同长度的序列具有可比性。</p></li></ol><p>具体来说，当使用顺序分区时，只在每个迭代周期的开始位置初始化隐藏状态。由于下一个小批量数据中的第 $i$ 个子序列样本与当前第 $i$ 个子序列样本相邻，因此当前小批量数据最后一个样本的隐藏状态，将用于初始化下一个小批量数据第一个样本的隐藏状态。这样，存储在隐藏状态中的序列的历史信息可以在一个迭代周期内流经相邻的子序列。然而，在任何一点隐藏状态的计算，都依赖于同一迭代周期中前面所有的小批量数据，这使得梯度计算变得复杂。为了降低计算量，我们在处理任何一个小批量数据之前先分离梯度，使得隐藏状态的梯度计算总是限制在一个小批量数据的时间步内。</p><p>当使用随机抽样时，因为每个样本都是在一个随机位置抽样的，因此需要为每个迭代周期重新初始化隐藏状态。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">train_epoch_ch8</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> train_iter<span class="token punctuation">,</span> loss<span class="token punctuation">,</span> updater<span class="token punctuation">,</span> device<span class="token punctuation">,</span> use_random_iter<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""训练模型一个迭代周期（定义见第8章）。"""</span>    state <span class="token operator">=</span> <span class="token boolean">None</span>    metrics <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">]</span>  <span class="token comment"># 训练损失之和, 词元数量</span>    <span class="token keyword">for</span> X<span class="token punctuation">,</span> Y <span class="token keyword">in</span> train_iter<span class="token punctuation">:</span>        <span class="token keyword">if</span> state <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">or</span> use_random_iter<span class="token punctuation">:</span>            <span class="token comment"># 在第一次迭代或使用随机抽样时初始化`state`</span>            state <span class="token operator">=</span> net<span class="token punctuation">.</span>begin_state<span class="token punctuation">(</span>batch_size<span class="token operator">=</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> device<span class="token operator">=</span>device<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># `state`我们从零开始实现的模型是个张量</span>            <span class="token keyword">for</span> s <span class="token keyword">in</span> state<span class="token punctuation">:</span>                s<span class="token punctuation">.</span>detach_<span class="token punctuation">(</span><span class="token punctuation">)</span>        y <span class="token operator">=</span> Y<span class="token punctuation">.</span>T<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        X<span class="token punctuation">,</span> y <span class="token operator">=</span> X<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>        y_hat<span class="token punctuation">,</span> state <span class="token operator">=</span> net<span class="token punctuation">(</span>X<span class="token punctuation">,</span> state<span class="token punctuation">)</span>        l <span class="token operator">=</span> loss<span class="token punctuation">(</span>y_hat<span class="token punctuation">,</span> y<span class="token punctuation">.</span><span class="token builtin">long</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span>        l<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>        grad_clipping<span class="token punctuation">(</span>net<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment"># 因为已经调用了`mean`函数</span>        updater<span class="token punctuation">(</span>batch_size<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>        metrics<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> metrics<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> l <span class="token operator">*</span> y<span class="token punctuation">.</span>numel<span class="token punctuation">(</span><span class="token punctuation">)</span>        metrics<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> metrics<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> y<span class="token punctuation">.</span>numel<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> math<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>metrics<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">/</span> metrics<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 困惑度</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-机器翻译"><a href="#11-机器翻译" class="headerlink" title="11. 机器翻译"></a>11. <a href="https://zh-v2.d2l.ai/chapter_recurrent-modern/machine-translation-and-dataset.html">机器翻译</a></h2><h3 id="11-1-编码器-解码器结构"><a href="#11-1-编码器-解码器结构" class="headerlink" title="11.1 编码器-解码器结构"></a>11.1 <a href="https://zh-v2.d2l.ai/chapter_recurrent-modern/encoder-decoder.html">编码器-解码器结构</a></h3><p>编码器-解码器（encoder-decoder）结构常用于处理将输入序列转换成输出序列这类 <strong>序列转换模型（sequence transduction）</strong> 问题。</p><p><img src="/images/《动手学深度学习（第二版）》读书笔记/编码器-解码器结构.svg" alt="编码器-解码器结构"></p><ol><li><p>编码器（encoder）接受一个长度可变的序列作为输入，并将其转换为具有固定形状的编码状态。</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Encoder</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""编码器-解码器结构的基本编码器接口。"""</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>Encoder<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">raise</span> NotImplementedError<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>解码器（decoder）将固定形状的编码状态映射到长度可变的序列。</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Decoder</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token triple-quoted-string string">"""编码器-解码器结构的基本解码器接口。"""</span><span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token builtin">super</span><span class="token punctuation">(</span>Decoder<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">init_state</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> enc_outputs<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">raise</span> NotImplementedError<span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">raise</span> NotImplementedError<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>编码器-解码器组合</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">EncoderDecoder</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token triple-quoted-string string">"""编码器-解码器结构的基类。"""</span><span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> encoder<span class="token punctuation">,</span> decoder<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token builtin">super</span><span class="token punctuation">(</span>EncoderDecoder<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span>    self<span class="token punctuation">.</span>encoder <span class="token operator">=</span> encoder    self<span class="token punctuation">.</span>decoder <span class="token operator">=</span> decoder<span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> enc_X<span class="token punctuation">,</span> dec_X<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>    enc_outputs <span class="token operator">=</span> self<span class="token punctuation">.</span>encoder<span class="token punctuation">(</span>enc_X<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">)</span>    dec_state <span class="token operator">=</span> self<span class="token punctuation">.</span>decoder<span class="token punctuation">.</span>init_state<span class="token punctuation">(</span>enc_outputs<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">)</span>    <span class="token keyword">return</span> self<span class="token punctuation">.</span>decoder<span class="token punctuation">(</span>dec_X<span class="token punctuation">,</span> dec_state<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="11-2-序列到序列学习（seq2seq）"><a href="#11-2-序列到序列学习（seq2seq）" class="headerlink" title="11.2 序列到序列学习（seq2seq）"></a>11.2 <a href="https://zh-v2.d2l.ai/chapter_recurrent-modern/seq2seq.html">序列到序列学习（seq2seq）</a></h3><p>完整的代码：<a href="/images/《动手学深度学习（第二版）》读书笔记/machine_translation.py">machine_translation.py</a></p><p>机器翻译是一种典型的序列转换模型的问题，所以也可以遵循“编码器－解码器”结构的设计原则，来进行序列到序列（sequence to sequence，seq2seq）的学习。</p><p>在数据预处理时，需要注意：</p><ol><li><p>机器翻译中常做单词级词元化，而不是字符级的词元化。</p></li><li><p>单词级词元化后，词汇量可能会很大，可以将出现次数较少的次元（比如少于2次的低频次元）视为未知（<code>"&lt;unk&gt;"</code>）词元。另外，一般还会添加一些额外的词元。比如：在小批量时用于将序列填充到相同长度的填充词元（<code>"&lt;pad&gt;"</code>），以及序列的开始词元（<code>"&lt;bos&gt;"</code>）和结束词元（<code>"&lt;eos&gt;"</code>）。</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">src_vocab <span class="token operator">=</span> Vocab<span class="token punctuation">(</span>source<span class="token punctuation">,</span> min_freq<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> reserved_tokens<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'&lt;pad&gt;'</span><span class="token punctuation">,</span> <span class="token string">'&lt;bos&gt;'</span><span class="token punctuation">,</span> <span class="token string">'&lt;eos&gt;'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>为了提高计算效率，一般会将一个小批量的文本序列截断（truncation）和 填充（padding）到相同的长度。</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">truncate_pad</span><span class="token punctuation">(</span>line<span class="token punctuation">,</span> num_steps<span class="token punctuation">,</span> padding_token<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""截断或填充文本序列。"""</span>    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span> <span class="token operator">&gt;</span> num_steps<span class="token punctuation">:</span>        <span class="token keyword">return</span> line<span class="token punctuation">[</span><span class="token punctuation">:</span>num_steps<span class="token punctuation">]</span>  <span class="token comment"># 截断</span>    <span class="token keyword">return</span> line <span class="token operator">+</span> <span class="token punctuation">[</span>padding_token<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>num_steps <span class="token operator">-</span> <span class="token builtin">len</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 填充</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在训练的过程中，需要注意：</p></li><li><p>在每个时间步，解码器预测了输出词元的概率分布。类似于语言模型，可以使用 softmax 来获得分布，并通过计算交叉熵损失函数来进行优化。但是因为在数据预处理时，填充了一些词元到序列的末尾，所以在计算损失时，需要排除这些词元。</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sequence_mask</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> valid_len<span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""在序列中屏蔽不相关的项。"""</span>    maxlen <span class="token operator">=</span> X<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    mask <span class="token operator">=</span> torch<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token punctuation">(</span>maxlen<span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span>float32<span class="token punctuation">,</span> device<span class="token operator">=</span>X<span class="token punctuation">.</span>device<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> valid_len<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span>    X<span class="token punctuation">[</span><span class="token operator">~</span>mask<span class="token punctuation">]</span> <span class="token operator">=</span> value    <span class="token keyword">return</span> X<span class="token keyword">class</span> <span class="token class-name">MaskedSoftmaxCELoss</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>CrossEntropyLoss<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""带遮蔽的softmax交叉熵损失函数"""</span>    <span class="token comment"># `pred` 的形状：(`batch_size`, `num_steps`, `vocab_size`)</span>    <span class="token comment"># `label` 的形状：(`batch_size`, `num_steps`)</span>    <span class="token comment"># `valid_len` 的形状：(`batch_size`,)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> pred<span class="token punctuation">,</span> label<span class="token punctuation">,</span> valid_len<span class="token punctuation">)</span><span class="token punctuation">:</span>        weights <span class="token operator">=</span> torch<span class="token punctuation">.</span>ones_like<span class="token punctuation">(</span>label<span class="token punctuation">)</span>        weights <span class="token operator">=</span> sequence_mask<span class="token punctuation">(</span>weights<span class="token punctuation">,</span> valid_len<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>reduction <span class="token operator">=</span> <span class="token string">"none"</span>        unweighted_loss <span class="token operator">=</span> <span class="token builtin">super</span><span class="token punctuation">(</span>MaskedSoftmaxCELoss<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>forward<span class="token punctuation">(</span>pred<span class="token punctuation">.</span>permute<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> label<span class="token punctuation">)</span>        weighted_loss <span class="token operator">=</span> <span class="token punctuation">(</span>unweighted_loss <span class="token operator">*</span> weights<span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> weighted_loss<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在训练的过程中，特定的序列开始词元（<code>"&lt;bos&gt;"</code>）和原始的输出序列（不包括序列结束词元 <code>"&lt;eos&gt;"</code>）拼接在一起作为解码器的输入。这被称为教师强制（teacher forcing）。</p><p> <img src="/images/《动手学深度学习（第二版）》读书笔记/序列到序列学习的细节.svg" alt="序列到序列学习的细节"></p><p> 比如，假如想要训练翻译 “谢谢你。” 为 “thank you.” 且预处理时序列长度为8，在进入网络之前，上图中的 Sources 和 Targets 会被处理为：</p> <pre class="line-numbers language-python" data-language="python"><code class="language-python">sources <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"谢"</span><span class="token punctuation">,</span> <span class="token string">"谢"</span><span class="token punctuation">,</span> <span class="token string">"你"</span><span class="token punctuation">,</span> <span class="token string">"。"</span><span class="token punctuation">,</span> <span class="token string">"&lt;eos&gt;"</span><span class="token punctuation">,</span> <span class="token string">"&lt;pad&gt;"</span><span class="token punctuation">,</span> <span class="token string">"&lt;pad&gt;"</span><span class="token punctuation">,</span> <span class="token string">"&lt;pad&gt;"</span><span class="token punctuation">]</span><span class="token punctuation">]</span>targets <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"&lt;bos&gt;"</span><span class="token punctuation">,</span> <span class="token string">"thank"</span><span class="token punctuation">,</span> <span class="token string">"you"</span><span class="token punctuation">,</span> <span class="token string">"."</span><span class="token punctuation">,</span> <span class="token string">"&lt;eos&gt;"</span><span class="token punctuation">,</span> <span class="token string">"&lt;pad&gt;"</span><span class="token punctuation">,</span> <span class="token string">"&lt;pad&gt;"</span><span class="token punctuation">,</span> <span class="token string">"&lt;pad&gt;"</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h3 id="11-3-束搜索"><a href="#11-3-束搜索" class="headerlink" title="11.3 束搜索"></a>11.3 <a href="https://zh-v2.d2l.ai/chapter_recurrent-modern/beam-search.html">束搜索</a></h3><p>在进行机器翻译预测时，输入数据后，会得到各个单词的概率，如何根据各个单词的概率来确定下一个是哪个单词呢？</p><ol><li><p>贪心搜索</p><p> 最简单常用的方法是贪心搜索，即每次都选择概率最大的那个单词最为下一个单词。</p><p> 事实上，翻译最好的结果应该是，翻译后的句子中，各个单词对应概率的乘积的最大值，对应那个句子才是最好的翻译结果，即最优序列（optimal sequence）。但是，贪心搜索的策略并不能保证得到最优序列。</p></li><li><p>穷举搜索</p><p> 穷举搜索（exhaustive search）：穷举地列举所有可能的输出序列及其条件概率，然后输出条件概率最高的一个。这样肯定能得到最优序列，但是计算量过大。</p></li><li><p>束搜索</p><p> 束搜索（beam search）是贪心搜索的一个改进版本。在每次选择单词时，选择最高条件概率的 $k$ 个单词来进行计算。束宽（beam size） $k$ 是一个超参数。</p></li></ol><h2 id="12-注意力提示"><a href="#12-注意力提示" class="headerlink" title="12. 注意力提示"></a>12. <a href="https://zh-v2.d2l.ai/chapter_attention-mechanisms/attention-cues.html">注意力提示</a></h2><h3 id="12-1-非自主性提示"><a href="#12-1-非自主性提示" class="headerlink" title="12.1 非自主性提示"></a>12.1 非自主性提示</h3><p>非自主性提示是基于环境中物体的突出性和易见性。比如在一堆白色的物品中，有一个红色的物品，你会不由自主的先注意到红色的物品。</p><p>在注意力机制的背景下，感官输入的非自主提示称为 <strong>键（Keys）</strong> 。</p><h3 id="12-2-自主性提示"><a href="#12-2-自主性提示" class="headerlink" title="12.2 自主性提示"></a>12.2 自主性提示</h3><p>自主性提示指注意力受到了认知和意识的控制。比如在困倦的时候，你会有意识找可以休息的地方。可以简单的理解自主性提示为想干什么，需求。</p><p>在注意力机制的背景下，自主性提示称为 <strong>查询（Queries）</strong> 。</p><h3 id="12-3-感官输入"><a href="#12-3-感官输入" class="headerlink" title="12.3 感官输入"></a>12.3 感官输入</h3><p>在注意力机制的背景下，感官输入（sensory inputs，例如中间特征表示）被称为 <strong>值（Values）</strong> 。</p><p>举个例子帮助理解，比如在沙漠中：</p><ul><li>自主性提示、查询：想喝水或者想乘凉。</li><li>非自主性提示、键：看到了一口井，一个树，还有沙子。</li><li>感官输入、值：井在东边，树在西边，到处都是沙子。</li></ul><p>根据需求的不同，我们会把注意力关注到不同的地方：</p><ul><li>想喝水时主要关注井的信息。</li><li>想乘凉时主要关注树的信息。</li></ul><p>类比到机器翻译中把“谢谢你。”翻译为“thank you.”时，我们希望神经网络在翻译原文“你”时，更多的关注译文中的“you”，而不是其他的词。</p><h3 id="12-4-注意力汇聚"><a href="#12-4-注意力汇聚" class="headerlink" title="12.4 注意力汇聚"></a>12.4 <a href="https://zh-v2.d2l.ai/chapter_attention-mechanisms/nadaraya-waston.html">注意力汇聚</a></h3><p>查询（自主提示）和键（非自主提示）之间的交互形成了 <strong>注意力汇聚（attention pooling）</strong>。注意力汇聚有选择地聚合了值（感官输入）以生成最终的输出。</p><p>注意力机制通过注意力汇聚将查询（自主性提示）和键（非自主性提示）结合在一起，实现对 值（感官输入）的选择倾向。</p><p><img src="/images/《动手学深度学习（第二版）》读书笔记/查询、键和值.svg" alt="查询、键和值"></p><h4 id="12-4-1-非参数注意力汇聚"><a href="#12-4-1-非参数注意力汇聚" class="headerlink" title="12.4.1 非参数注意力汇聚"></a>12.4.1 非参数注意力汇聚</h4><p>根据输入的位置对输出 $y_i$ 进行加权：</p><script type="math/tex; mode=display">f(x) = \sum_{i=1}^n \frac{K(x - x_i)}{\sum_{j=1}^n K(x - x_j)} y_i \tag{12.4.1.1}</script><p>其中 $K$ 是 <strong>核（kernel）</strong> ，上面的公式称为 <strong>Nadaraya-Watson 核回归（Nadaraya-Watson kernel regression）</strong> 。可以从注意力机制的角度重写该公式为一个更加通用的 <strong>注意力汇聚（attention pooling）</strong> 公式：</p><script type="math/tex; mode=display">f(x) = \sum_{i=1}^n \alpha(x, x_i) y_i \tag{12.4.1.2}</script><p>其中 $x$ 是查询，$(x_i, y_i)$ 是键值对。注意力汇聚是 $y_i$ 的加权平均。将查询 $x$ 和键 $x_i$ 之间的关系建模为 <strong>注意力权重（attention weight）</strong> $\alpha(x, x_i)$，如上公式所示，这个权重将被分配给每一个对应值 $y_i$。对于任何查询，模型在所有键值对上的注意力权重都是一个有效的概率分布：它们是非负数的，并且总和为1。</p><p>为了更好地理解注意力汇聚，仅考虑一个 <strong>高斯核（Gaussian kernel）</strong> ，其定义为：</p><script type="math/tex; mode=display">K(u) = \frac{1}{\sqrt{2\pi}} \exp(-\frac{u^2}{2}) \tag{12.4.1.3}</script><p>将高斯核代入改写后的注意力汇聚公式可以得到：</p><script type="math/tex; mode=display">\begin{aligned}f(x)&=\sum_{i=1}^n \alpha(x, x_i) y_i\\&= \sum_{i=1}^n \frac{\exp\left(-\frac{1}{2}(x - x_i)^2\right)}{\sum_{j=1}^n \exp\left(-\frac{1}{2}(x - x_j)^2\right)} y_i \\&= \sum_{i=1}^n \mathrm{softmax}\left(-\frac{1}{2}(x - x_i)^2\right) y_i \tag{12.4.1.4}\\\end{aligned}</script><p>在上面的公式中，如果一个键 $x_i$ 越是接近给定的查询 $x$, 那么分配给这个键对应值 $y_i$ 的注意力权重就会越大, 也就是“获得了更多的注意力”。</p><p>非参数的 Nadaraya-Watson 核回归具有 <strong>一致性（consistency）</strong> 的优点：如果有足够的数据，此模型会收敛到最优结果。</p><h4 id="12-4-2-带参数注意力汇聚"><a href="#12-4-2-带参数注意力汇聚" class="headerlink" title="12.4.2 带参数注意力汇聚"></a>12.4.2 带参数注意力汇聚</h4><p>可以将可学习的参数集成到非参数注意力汇聚中。比如，在查询 $x$ 和键 $x_i$ 之间的距离乘以可学习参数 $w$：</p><script type="math/tex; mode=display">\begin{aligned}f(x)&= \sum_{i=1}^n \alpha(x, x_i) y_i \\&= \sum_{i=1}^n \frac{\exp\left(-\frac{1}{2}((x - x_i)w)^2\right)}{\sum_{j=1}^n \exp\left(-\frac{1}{2}((x - x_i)w)^2\right)} y_i \\&= \sum_{i=1}^n \mathrm{softmax}\left(-\frac{1}{2}((x - x_i)w)^2\right) y_i \tag{12.4.2}\end{aligned}</script><h2 id="13-注意力评分函数"><a href="#13-注意力评分函数" class="headerlink" title="13. 注意力评分函数"></a>13. <a href="https://zh-v2.d2l.ai/chapter_attention-mechanisms/attention-scoring-functions.html">注意力评分函数</a></h2><p>在 <a href="#1241-非参数注意力汇聚">非参数注意力汇聚</a> 的最后，使用高斯核来对查询和键之间的关系建模。可以将公式 <code>12.4.1.4</code> 中高斯核的指数部分 $-\frac{1}{2}((x - x_i)w)^2$ 视为 <strong>注意力评分函数（attention scoring function）</strong> ，简称 <strong>评分函数（scoring function）</strong> ，然后把这个函数的输出结果输入到 softmax 函数中进行运算。通过上述步骤，将得到与键对应的值的概率分布（即注意力权重）。最后，注意力汇聚的输出就是基于这些注意力权重的值的加权和。</p><p>从宏观来看，可以使用上述算法来实现注意力机制框架。如下图，将注意力汇聚的输出计算成为值的加权和，其中 $a$ 表示注意力评分函数。由于注意力权重是概率分布，因此加权和其本质上是加权平均值。</p><p><img src="/images/《动手学深度学习（第二版）》读书笔记/注意力机制框架.svg" alt="注意力机制框架"></p><p>用数学语言描述，假设有一个查询 $\mathbf{q} \in \mathbb{R}^q$ 和 $m$ 个“键－值”对 $(\mathbf{k}_1, \mathbf{v}_1), \ldots, (\mathbf{k}_m, \mathbf{v}_m)$，其中 $\mathbf{k}_i \in \mathbb{R}^k$，$\mathbf{v}_i \in \mathbb{R}^v$。注意力汇聚函数 $f$ 就被表示成值的加权和：</p><script type="math/tex; mode=display">f(\mathbf{q}, (\mathbf{k}_1, \mathbf{v}_1), \ldots, (\mathbf{k}_m, \mathbf{v}_m)) = \sum_{i=1}^m \alpha(\mathbf{q}, \mathbf{k}_i) \mathbf{v}_i \in \mathbb{R}^v</script><p>其中查询 $\mathbf{q}$ 和键 $\mathbf{k}_i$ 的注意力权重（标量）是通过注意力评分函数 $a$ 将两个向量映射成标量，再经过 softmax 运算得到的：</p><script type="math/tex; mode=display">\alpha(\mathbf{q}, \mathbf{k}_i) = \mathrm{softmax}(a(\mathbf{q}, \mathbf{k}_i)) = \frac{\exp(a(\mathbf{q}, \mathbf{k}_i))}{\sum_{j=1}^m \exp(a(\mathbf{q}, \mathbf{k}_j))} \in \mathbb{R}</script><h3 id="13-1-遮蔽softmax操作"><a href="#13-1-遮蔽softmax操作" class="headerlink" title="13.1 遮蔽softmax操作"></a>13.1 <a href="https://zh-v2.d2l.ai/chapter_attention-mechanisms/attention-scoring-functions.html#softmax">遮蔽softmax操作</a></h3><p>softmax 运算用于输出一个概率分布作为注意力权重。在某些情况下，并非所有的值都应该被纳入到注意力汇聚中。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">masked_softmax</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> valid_lens<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""通过在最后一个轴上遮蔽元素来执行 softmax 操作"""</span>    <span class="token comment"># `X`: 3D张量, `valid_lens`: 1D或2D 张量</span>    <span class="token keyword">if</span> valid_lens <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> nn<span class="token punctuation">.</span>functional<span class="token punctuation">.</span>softmax<span class="token punctuation">(</span>X<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        shape <span class="token operator">=</span> X<span class="token punctuation">.</span>shape        <span class="token keyword">if</span> valid_lens<span class="token punctuation">.</span>dim<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            valid_lens <span class="token operator">=</span> torch<span class="token punctuation">.</span>repeat_interleave<span class="token punctuation">(</span>valid_lens<span class="token punctuation">,</span> shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            valid_lens <span class="token operator">=</span> valid_lens<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment"># 在最后的轴上，被遮蔽的元素使用一个非常大的负值替换，从而其 softmax (指数)输出为 0</span>        X <span class="token operator">=</span> sequence_mask<span class="token punctuation">(</span>X<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> shape<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> valid_lens<span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1e6</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> nn<span class="token punctuation">.</span>functional<span class="token punctuation">.</span>softmax<span class="token punctuation">(</span>X<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>shape<span class="token punctuation">)</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="13-2-加性注意力"><a href="#13-2-加性注意力" class="headerlink" title="13.2 加性注意力"></a>13.2 <a href="https://zh-v2.d2l.ai/chapter_attention-mechanisms/attention-scoring-functions.html#subsec-additive-attention">加性注意力</a></h3><p>一般来说，当查询和键是不同长度的矢量时，可以使用加性注意力作为评分函数。给定查询 $\mathbf{q} \in \mathbb{R}^q$ 和键 $\mathbf{k} \in \mathbb{R}^k$ ，<strong>加性注意力（additive attention）</strong> 的评分函数为</p><script type="math/tex; mode=display">a(\mathbf q, \mathbf k) = \mathbf w_v^\top \text{tanh}(\mathbf W_q\mathbf q + \mathbf W_k \mathbf k) \in \mathbb{R}</script><p>其中可学习的参数是 $\mathbf W_q\in\mathbb R^{h\times q}$ 、 $\mathbf W_k\in\mathbb R^{h\times k}$ 和 $\mathbf w_v\in\mathbb R^{h}$ 。在上面的公式中，将查询和键连接起来后输入到一个多层感知机（MLP）中，感知机包含一个隐藏层，其隐藏单元数是一个超参数 $h$ 。通过使用 $\tanh$ 作为激活函数，并且禁用偏置项。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">AdditiveAttention</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""加性注意力"""</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key_size<span class="token punctuation">,</span> query_size<span class="token punctuation">,</span> num_hiddens<span class="token punctuation">,</span> dropout<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>AdditiveAttention<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>W_k <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>key_size<span class="token punctuation">,</span> num_hiddens<span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>W_q <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>query_size<span class="token punctuation">,</span> num_hiddens<span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>w_v <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>num_hiddens<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>dropout <span class="token operator">=</span> nn<span class="token punctuation">.</span>Dropout<span class="token punctuation">(</span>dropout<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> queries<span class="token punctuation">,</span> keys<span class="token punctuation">,</span> values<span class="token punctuation">,</span> valid_lens<span class="token punctuation">)</span><span class="token punctuation">:</span>        queries<span class="token punctuation">,</span> keys <span class="token operator">=</span> self<span class="token punctuation">.</span>W_q<span class="token punctuation">(</span>queries<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>W_k<span class="token punctuation">(</span>keys<span class="token punctuation">)</span>        <span class="token comment"># 在维度扩展后，</span>        <span class="token comment"># `queries` 的形状：(`batch_size`, 查询的个数, 1, `num_hidden`)</span>        <span class="token comment"># `key` 的形状：(`batch_size`, 1, “键－值”对的个数, `num_hiddens`)</span>        <span class="token comment"># 使用广播方式进行求和</span>        features <span class="token operator">=</span> queries<span class="token punctuation">.</span>unsqueeze<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> keys<span class="token punctuation">.</span>unsqueeze<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        features <span class="token operator">=</span> torch<span class="token punctuation">.</span>tanh<span class="token punctuation">(</span>features<span class="token punctuation">)</span>        <span class="token comment"># `self.w_v` 仅有一个输出，因此从形状中移除最后那个维度。</span>        <span class="token comment"># `scores` 的形状：(`batch_size`, 查询的个数, “键-值”对的个数)</span>        scores <span class="token operator">=</span> self<span class="token punctuation">.</span>w_v<span class="token punctuation">(</span>features<span class="token punctuation">)</span><span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>attention_weights <span class="token operator">=</span> masked_softmax<span class="token punctuation">(</span>scores<span class="token punctuation">,</span> valid_lens<span class="token punctuation">)</span>        <span class="token comment"># `values` 的形状：(`batch_size`, “键－值”对的个数, 值的维度)</span>        <span class="token keyword">return</span> torch<span class="token punctuation">.</span>bmm<span class="token punctuation">(</span>self<span class="token punctuation">.</span>dropout<span class="token punctuation">(</span>self<span class="token punctuation">.</span>attention_weights<span class="token punctuation">)</span><span class="token punctuation">,</span> values<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="13-3-缩放点积注意力"><a href="#13-3-缩放点积注意力" class="headerlink" title="13.3 缩放点积注意力"></a>13.3 缩放点积注意力</h3><p>使用点积可以得到计算效率更高的评分函数。但是点积操作要求查询和键具有相同的长度 $d$。假设查询和键的所有元素都是独立的随机变量，并且都满足均值为 $0$ 和方差为 $1$。那么两个向量的点积的均值为 $0$，方差为 $d$。为确保无论向量长度如何，点积的方差在不考虑向量长度的情况下仍然是 $1$，则可以使用 <strong>缩放点积注意力（scaled dot-product attention）</strong> 评分函数：</p><script type="math/tex; mode=display">a(\mathbf q, \mathbf k) = \mathbf{q}^\top \mathbf{k} / \sqrt{d}</script><p>将点积除以 $\sqrt{d}$。在实践中，我们通常从小批量的角度来考虑提高效率，例如基于 $n$ 个查询和 $m$ 个键－值对计算注意力，其中查询和键的长度为 $d$，值的长度为 $v$。查询 $\mathbf Q\in\mathbb R^{n\times d}$、键 $\mathbf K\in\mathbb R^{m\times d}$ 和值 $\mathbf V\in\mathbb R^{m\times v}$ 的缩放点积注意力是</p><script type="math/tex; mode=display">\mathrm{softmax}\left(\frac{\mathbf Q \mathbf K^\top }{\sqrt{d}}\right) \mathbf V \in \mathbb{R}^{n\times v}</script><p>在下面的缩放点积注意力的实现中，我们使用了 dropout 进行模型正则化。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">DotProductAttention</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""缩放点积注意力"""</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> dropout<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>DotProductAttention<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>dropout <span class="token operator">=</span> nn<span class="token punctuation">.</span>Dropout<span class="token punctuation">(</span>dropout<span class="token punctuation">)</span>    <span class="token comment"># `queries` 的形状：(`batch_size`, 查询的个数, `d`)</span>    <span class="token comment"># `keys` 的形状：(`batch_size`, “键－值”对的个数, `d`)</span>    <span class="token comment"># `values` 的形状：(`batch_size`, “键－值”对的个数, 值的维度)</span>    <span class="token comment"># `valid_lens` 的形状: (`batch_size`,) 或者 (`batch_size`, 查询的个数)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> queries<span class="token punctuation">,</span> keys<span class="token punctuation">,</span> values<span class="token punctuation">,</span> valid_lens<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        d <span class="token operator">=</span> queries<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token comment"># 设置 `transpose_b=True` 为了交换 `keys` 的最后两个维度</span>        scores <span class="token operator">=</span> torch<span class="token punctuation">.</span>bmm<span class="token punctuation">(</span>queries<span class="token punctuation">,</span> keys<span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>d<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>attention_weights <span class="token operator">=</span> masked_softmax<span class="token punctuation">(</span>scores<span class="token punctuation">,</span> valid_lens<span class="token punctuation">)</span>        <span class="token keyword">return</span> torch<span class="token punctuation">.</span>bmm<span class="token punctuation">(</span>self<span class="token punctuation">.</span>dropout<span class="token punctuation">(</span>self<span class="token punctuation">.</span>attention_weights<span class="token punctuation">)</span><span class="token punctuation">,</span> values<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="14-包含注意力机制的序列到序列学习"><a href="#14-包含注意力机制的序列到序列学习" class="headerlink" title="14. 包含注意力机制的序列到序列学习"></a>14. 包含注意力机制的序列到序列学习</h2><p><a href="https://zhuanlan.zhihu.com/p/56431190?hmsr=toutiao.io&amp;utm_campaign=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io">图解谷歌神经机器翻译核心部分：注意力机制</a></p><p>将注意力机制应用到序列到序列学习的经典方法有两种：<a href="https://lena-voita.github.io/nlp_course/seq2seq_and_attention.html#attention_bahdanau_luong">Bahdanau 和 Luong</a>。</p><ol><li><p><a href="https://zh-v2.d2l.ai/chapter_attention-mechanisms/bahdanau-attention.html">Bahdanau注意力</a> 的实现： <a href="/images/《动手学深度学习（第二版）》读书笔记/machine_translation_with_bahdanau_attention.py">machine_translation_with_bahdanau_attention.py</a></p></li><li><p>Luong注意力。</p></li></ol><h2 id="15-多头注意力"><a href="#15-多头注意力" class="headerlink" title="15. 多头注意力"></a>15. <a href="https://zh-v2.d2l.ai/chapter_attention-mechanisms/multihead-attention.html">多头注意力</a></h2><h3 id="15-1-多头注意力的本质"><a href="#15-1-多头注意力的本质" class="headerlink" title="15.1 多头注意力的本质"></a>15.1 多头注意力的本质</h3><p>在实践中，当给定相同的查询、键和值的集合时，我们希望模型可以基于相同的注意力机制学习到不同的行为，然后将不同的行为作为知识组合起来，例如捕获序列内各种范围的依赖关系（例如，短距离依赖和长距离依赖）。因此，允许注意力机制组合使用查询、键和值的不同 <strong>子空间表示（representation subspaces）</strong> 可能是有益的。</p><p>为此，与使用单独一个注意力汇聚不同，我们可以用独立学习得到的 $h$ 组不同的 <strong>线性投影（linear projections）</strong> 来变换查询、键和值。然后，这 $h$ 组变换后的查询、键和值将并行地送到注意力汇聚中。最后，将这 $h$ 个注意力汇聚的输出拼接在一起，并且通过另一个可以学习的线性投影进行变换，以产生最终输出。这种设计被称为 <strong>多头注意力</strong> ，其中 $h$ 个注意力汇聚输出中的每一个输出都被称作一个 <strong>头（head）</strong> 。下图展示了使用全连接层来实现可学习的线性变换的多头注意力。</p><p><img src="/images/《动手学深度学习（第二版）》读书笔记/多头注意力.svg" alt="多头注意力"></p><h3 id="15-2-多头注意力的数学描述"><a href="#15-2-多头注意力的数学描述" class="headerlink" title="15.2 多头注意力的数学描述"></a>15.2 多头注意力的数学描述</h3><p>给定查询 $\mathbf{q} \in \mathbb{R}^{d_q}$、键 $\mathbf{k} \in \mathbb{R}^{d_k}$ 和值 $\mathbf{v} \in \mathbb{R}^{d_v}$，每个注意力头 $\mathbf{h}_i$ ($i = 1, \ldots, h$) 的计算方法为：</p><script type="math/tex; mode=display">\mathbf{h}_i = f(\mathbf W_i^{(q)}\mathbf q, \mathbf W_i^{(k)}\mathbf k,\mathbf W_i^{(v)}\mathbf v) \in \mathbb R^{p_v}</script><p>其中，可学习的参数包括 $\mathbf W_i^{(q)}\in\mathbb R^{p_q\times d_q}$、$\mathbf W_i^{(k)}\in\mathbb R^{p_k\times d_k}$ 和 $\mathbf W_i^{(v)}\in\mathbb R^{p_v\times d_v}$ ，以及代表注意力汇聚的函数 $f$ 。$f$ 可以<a href="#132-加性注意力">加性注意力</a>和<a href="#133-缩放点积注意力">缩放点积注意力</a>。多头注意力的输出需要经过另一个线性转换，它对应着 $h$ 个头连结后的结果，因此其可学习参数是 $\mathbf W_o\in\mathbb R^{p_o\times h p_v}$：</p><script type="math/tex; mode=display">\mathbf W_o \begin{bmatrix}\mathbf h_1\\\vdots\\\mathbf h_h\end{bmatrix} \in \mathbb{R}^{p_o}</script><h3 id="15-3-多头注意力的实现"><a href="#15-3-多头注意力的实现" class="headerlink" title="15.3 多头注意力的实现"></a>15.3 多头注意力的实现</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MultiHeadAttention</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key_size<span class="token punctuation">,</span> query_size<span class="token punctuation">,</span> value_size<span class="token punctuation">,</span> num_hiddens<span class="token punctuation">,</span> num_heads<span class="token punctuation">,</span> dropout<span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>MultiHeadAttention<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>num_heads <span class="token operator">=</span> num_heads        self<span class="token punctuation">.</span>attention <span class="token operator">=</span> DotProductAttention<span class="token punctuation">(</span>dropout<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>W_q <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>query_size<span class="token punctuation">,</span> num_hiddens<span class="token punctuation">,</span> bias<span class="token operator">=</span>bias<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>W_k <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>key_size<span class="token punctuation">,</span> num_hiddens<span class="token punctuation">,</span> bias<span class="token operator">=</span>bias<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>W_v <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>value_size<span class="token punctuation">,</span> num_hiddens<span class="token punctuation">,</span> bias<span class="token operator">=</span>bias<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>W_o <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>num_hiddens<span class="token punctuation">,</span> num_hiddens<span class="token punctuation">,</span> bias<span class="token operator">=</span>bias<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> queries<span class="token punctuation">,</span> keys<span class="token punctuation">,</span> values<span class="token punctuation">,</span> valid_lens<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># `queries`, `keys`, or `values` 的形状:</span>        <span class="token comment"># (`batch_size`, 查询或者“键－值”对的个数, `num_hiddens`)</span>        <span class="token comment"># `valid_lens`　的形状:</span>        <span class="token comment"># (`batch_size`,) or (`batch_size`, 查询的个数)</span>        <span class="token comment"># 经过变换后，输出的 `queries`, `keys`, or `values`　的形状:</span>        <span class="token comment"># (`batch_size` * `num_heads`, 查询或者“键－值”对的个数,</span>        <span class="token comment"># `num_hiddens` / `num_heads`)</span>        queries <span class="token operator">=</span> transpose_qkv<span class="token punctuation">(</span>self<span class="token punctuation">.</span>W_q<span class="token punctuation">(</span>queries<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>num_heads<span class="token punctuation">)</span>        keys <span class="token operator">=</span> transpose_qkv<span class="token punctuation">(</span>self<span class="token punctuation">.</span>W_k<span class="token punctuation">(</span>keys<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>num_heads<span class="token punctuation">)</span>        values <span class="token operator">=</span> transpose_qkv<span class="token punctuation">(</span>self<span class="token punctuation">.</span>W_v<span class="token punctuation">(</span>values<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>num_heads<span class="token punctuation">)</span>        <span class="token keyword">if</span> valid_lens <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token comment"># 在轴 0，将第一项（标量或者矢量）复制 `num_heads` 次，</span>            <span class="token comment"># 然后如此复制第二项，然后诸如此类。</span>            valid_lens <span class="token operator">=</span> torch<span class="token punctuation">.</span>repeat_interleave<span class="token punctuation">(</span>valid_lens<span class="token punctuation">,</span> repeats<span class="token operator">=</span>self<span class="token punctuation">.</span>num_heads<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment"># `output` 的形状: (`batch_size` * `num_heads`, 查询的个数,</span>        <span class="token comment"># `num_hiddens` / `num_heads`)</span>        output <span class="token operator">=</span> self<span class="token punctuation">.</span>attention<span class="token punctuation">(</span>queries<span class="token punctuation">,</span> keys<span class="token punctuation">,</span> values<span class="token punctuation">,</span> valid_lens<span class="token punctuation">)</span>        <span class="token comment"># `output_concat` 的形状: (`batch_size`, 查询的个数, `num_hiddens`)</span>        output_concat <span class="token operator">=</span> transpose_output<span class="token punctuation">(</span>output<span class="token punctuation">,</span> self<span class="token punctuation">.</span>num_heads<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>W_o<span class="token punctuation">(</span>output_concat<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">transpose_qkv</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> num_heads<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 输入 `X` 的形状: (`batch_size`, 查询或者“键－值”对的个数, `num_hiddens`).</span>    <span class="token comment"># 输出 `X` 的形状: (`batch_size`, 查询或者“键－值”对的个数, `num_heads`,</span>    <span class="token comment"># `num_hiddens` / `num_heads`)</span>    X <span class="token operator">=</span> X<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> num_heads<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment"># 输出 `X` 的形状: (`batch_size`, `num_heads`, 查询或者“键－值”对的个数,</span>    <span class="token comment"># `num_hiddens` / `num_heads`)</span>    X <span class="token operator">=</span> X<span class="token punctuation">.</span>permute<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>    <span class="token comment"># `output` 的形状: (`batch_size` * `num_heads`, 查询或者“键－值”对的个数,</span>    <span class="token comment"># `num_hiddens` / `num_heads`)</span>    <span class="token keyword">return</span> X<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">transpose_output</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> num_heads<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""逆转 `transpose_qkv` 函数的操作"""</span>    X <span class="token operator">=</span> X<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> num_heads<span class="token punctuation">,</span> X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    X <span class="token operator">=</span> X<span class="token punctuation">.</span>permute<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> X<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="16-自注意力"><a href="#16-自注意力" class="headerlink" title="16. 自注意力"></a>16. <a href="https://zh-v2.d2l.ai/chapter_attention-mechanisms/self-attention-and-positional-encoding.html">自注意力</a></h2><h3 id="16-1-自注意力的原理"><a href="#16-1-自注意力的原理" class="headerlink" title="16.1 自注意力的原理"></a>16.1 自注意力的原理</h3><p>在<a href="#14-包含注意力机制的序列到序列学习">包含注意力机制的序列到序列学习</a>中，如果把输入数据同时作为查询、键和值，就是自注意力，也称为 <strong>内部注意力（intra-attention）</strong> 。</p><h3 id="16-2-自注意力的数学描述"><a href="#16-2-自注意力的数学描述" class="headerlink" title="16.2 自注意力的数学描述"></a>16.2 自注意力的数学描述</h3><p>给定一个由词元组成的输入序列 $\mathbf{x}_1, \ldots, \mathbf{x}_n$，其中任意 $\mathbf{x}_i \in \mathbb{R}^d$ ($1 \leq i \leq n$)。该序列的自注意力输出为一个长度相同的序列 $\mathbf{y}_1, \ldots, \mathbf{y}_n$，其中：</p><script type="math/tex; mode=display">\mathbf{y}_i = f(\mathbf{x}_i, (\mathbf{x}_1, \mathbf{x}_1), \ldots, (\mathbf{x}_n, \mathbf{x}_n)) \in \mathbb{R}^d</script><h2 id="17-自注意力对比CNN和RNN"><a href="#17-自注意力对比CNN和RNN" class="headerlink" title="17. 自注意力对比CNN和RNN"></a>17. <a href="https://zh-v2.d2l.ai/chapter_attention-mechanisms/self-attention-and-positional-encoding.html#subsec-cnn-rnn-self-attention">自注意力对比CNN和RNN</a></h2><p><img src="/images/《动手学深度学习（第二版）》读书笔记/自注意力对比CNN和RNN.png" alt="自注意力对比CNN和RNN"></p><div class="table-container"><table><thead><tr><th></th><th>CNN</th><th>RNN</th><th>自注意力</th></tr></thead><tbody><tr><td>计算复杂度</td><td>O( <script type="math/tex">knd^2</script> )</td><td>O( <script type="math/tex">nd^2</script> )</td><td>O( <script type="math/tex">n^2d</script> )</td></tr><tr><td>并⾏度</td><td>O( <script type="math/tex">n</script> )</td><td>O( <script type="math/tex">1</script> )</td><td>O( <script type="math/tex">n</script> )</td></tr><tr><td>最⻓路径</td><td>O( <script type="math/tex">\frac{n}{k}</script> )</td><td>O( <script type="math/tex">n</script> )</td><td>O( <script type="math/tex">1</script> )</td></tr></tbody></table></div><p>说明：</p><ul><li>k 为卷积层卷积核的大小。</li><li>n 为序列长度。</li><li>d 为输入和输出的通道数量。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《C++语言导学（第二版）》读书笔记</title>
      <link href="c-yu-yan-dao-xue-di-er-ban-du-shu-bi-ji/"/>
      <url>c-yu-yan-dao-xue-di-er-ban-du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="第1章-基础知识"><a href="#第1章-基础知识" class="headerlink" title="第1章 基础知识"></a>第1章 基础知识</h2><ol><li><p>为了使长字面常量更易读，可以使用单引号（’）作为数字分隔符。</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">123'456'789</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>对于带初始化的 <code>if</code> 语句，如果条件是检验变量是否为 0（或者 nullptr），可以省略条件的显示描述。</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span><span class="token comment">// 下面两个if语句意义相同</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> n <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">0</span> <span class="token operator">!=</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> n <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="第2章-用户自定义类型"><a href="#第2章-用户自定义类型" class="headerlink" title="第2章 用户自定义类型"></a>第2章 用户自定义类型</h2><ol><li><p>使用 <code>variant</code> 代替 <code>union</code> 。</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>variant<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">&gt;&gt;</span> vv <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"kibazen.cn"</span><span class="token punctuation">,</span> <span class="token number">8888</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> v <span class="token operator">:</span> vv<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>holds_alternative<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"int value with: "</span> <span class="token operator">&lt;&lt;</span> get<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>holds_alternative<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"string value with: "</span> <span class="token operator">&lt;&lt;</span> get<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>默认情况下，<code>enum</code> 只定义了赋值、初始化和比较（如 == 和 &lt;）操作。但是枚举类型是一种用户自定义类型，所以可以为枚举类型定义别的运算符。</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// enum 和 enum class 都可以</span><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Color</span> <span class="token punctuation">{</span>    red<span class="token punctuation">,</span>    green<span class="token punctuation">,</span>    blue<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Color<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span>Color<span class="token operator">&amp;</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> Color<span class="token operator">::</span>red<span class="token operator">:</span>        <span class="token keyword">return</span> c <span class="token operator">=</span> Color<span class="token operator">::</span>green<span class="token punctuation">;</span>    <span class="token keyword">case</span> Color<span class="token operator">::</span>green<span class="token operator">:</span>        <span class="token keyword">return</span> c <span class="token operator">=</span> Color<span class="token operator">::</span>blue<span class="token punctuation">;</span>    <span class="token keyword">case</span> Color<span class="token operator">::</span>blue<span class="token operator">:</span>        <span class="token keyword">return</span> c <span class="token operator">=</span> Color<span class="token operator">::</span>red<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="第3章-模块化"><a href="#第3章-模块化" class="headerlink" title="第3章 模块化"></a>第3章 模块化</h2><ol><li><p>一个单独编译的 <code>.cpp</code> 文件（包括它使用 <code>#include</code> 包含的 <code>.h</code> 文件）称为一个 <strong>编译单元（translation unit）</strong> 。</p></li><li><p>头文件 <code>include</code> 和模块 <code>module</code> 的差异不仅是语言上的。</p><ul><li>一个模块只会编译一遍（而不是像头文件一样在使用它的每个编译单元中都编译一遍）。</li><li>两个模块可以按任意顺序导入（import）而不会改变它们的含义。</li><li>如果你讲一些东西导入一个模块中，则模块的使用者不会隐式获得这些东西的访问权（但也不会被它们所困扰）：import 无传递性。</li></ul></li><li><p>声明为 <code>noexcept</code> 的函数抛出异常时，程序会自动调用 <code>teminate()</code> 函数来终止整个程序。</p></li><li><p>结构化绑定。</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Info</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> key<span class="token punctuation">;</span>    string value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Info <span class="token function">get_info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> Info <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"k"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">auto</span> <span class="token punctuation">[</span>k<span class="token punctuation">,</span> v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">get_info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">&gt;</span> m <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"k"</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> <span class="token punctuation">[</span>k<span class="token punctuation">,</span> v<span class="token punctuation">]</span> <span class="token operator">:</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="第4章-类"><a href="#第4章-类" class="headerlink" title="第4章 类"></a>第4章 类</h2><h2 id="第5章-基本操作"><a href="#第5章-基本操作" class="headerlink" title="第5章 基本操作"></a>第5章 基本操作</h2><ol><li>右值引用的含义是，引用一个别人无法赋值的内容，所以我们可以安全地“窃取”它的值。</li></ol><h2 id="第6章-模板"><a href="#第6章-模板" class="headerlink" title="第6章 模板"></a>第6章 模板</h2><ol><li><p>C++17中允许从构造函数参数中推断模板参数。</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">pair p <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5.2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// pair&lt;int, double&gt;</span>tuple t <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token string">"a"</span>s <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// tuple&lt;int, double, string&gt;</span>vector vi <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// vector&lt;int&gt;</span>vector vc <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// vector&lt;const char*&gt;</span>vector vs <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"a"</span>s<span class="token punctuation">,</span> <span class="token string">"b"</span>s<span class="token punctuation">,</span> <span class="token string">"c"</span>s <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// vector&lt;string&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">Vector</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> value_type <span class="token operator">=</span> T<span class="token punctuation">;</span>    <span class="token function">Vector</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> l<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Iter</span><span class="token operator">&gt;</span>    <span class="token function">Vector</span><span class="token punctuation">(</span>Iter begin<span class="token punctuation">,</span> Iter end<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>    T<span class="token operator">*</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    T<span class="token operator">*</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Iter</span><span class="token operator">&gt;</span><span class="token function">Vector</span><span class="token punctuation">(</span>Iter<span class="token punctuation">,</span> Iter<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Vector<span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">iterator_traits</span><span class="token operator">&lt;</span>Iter<span class="token operator">&gt;</span><span class="token operator">::</span>value_type<span class="token operator">&gt;</span><span class="token punctuation">;</span>Vector v1 <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// Vector&lt;int&gt;</span>Vector <span class="token function">v2</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Vector&lt;int&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><a href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction">Class template argument deduction (CTAD) (since C++17)</a></p></blockquote></li></ol><h2 id="第7章-概念和泛型编程"><a href="#第7章-概念和泛型编程" class="headerlink" title="第7章 概念和泛型编程"></a>第7章 概念和泛型编程</h2><ol><li><p>可变参数模板</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">print0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Tail<span class="token operator">&gt;</span><span class="token keyword">void</span> <span class="token function">print0</span><span class="token punctuation">(</span>T head<span class="token punctuation">,</span> Tail<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> tail<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> head<span class="token punctuation">;</span>    <span class="token function">print0</span><span class="token punctuation">(</span>tail<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Tail<span class="token operator">&gt;</span><span class="token keyword">void</span> <span class="token function">print1</span><span class="token punctuation">(</span>T head<span class="token punctuation">,</span> Tail<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> tail<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> head<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">print1</span><span class="token punctuation">(</span>tail<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">print0</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"char"</span><span class="token punctuation">,</span> <span class="token string">"string"</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">print1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"char"</span><span class="token punctuation">,</span> <span class="token string">"string"</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>表达式折叠</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>T<span class="token operator">&gt;</span><span class="token keyword">void</span> <span class="token function">print2</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">(</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">&lt;&lt;</span> args<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// (((cout &lt;&lt; 1) &lt;&lt; "char") &lt;&lt; "string"s) &lt;&lt; endl;</span><span class="token function">print2</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"char"</span><span class="token punctuation">,</span> <span class="token string">"string"</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> T<span class="token operator">&gt;</span><span class="token keyword">auto</span> <span class="token function">sum0</span><span class="token punctuation">(</span>T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>v <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 右折叠：(1 + (2 + (3 + 0)))</span><span class="token function">sum0</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> T<span class="token operator">&gt;</span><span class="token keyword">auto</span> <span class="token function">sum1</span><span class="token punctuation">(</span>T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">+</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 左折叠：(((0 + 1) + 2) + 3)</span><span class="token function">sum1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="第8章-标准库概览"><a href="#第8章-标准库概览" class="headerlink" title="第8章 标准库概览"></a>第8章 标准库概览</h2><h2 id="第9章-字符串和正则表达式"><a href="#第9章-字符串和正则表达式" class="headerlink" title="第9章 字符串和正则表达式"></a>第9章 字符串和正则表达式</h2><h2 id="第10章-输入输出"><a href="#第10章-输入输出" class="headerlink" title="第10章 输入输出"></a>第10章 输入输出</h2><h2 id="第11章-容器"><a href="#第11章-容器" class="headerlink" title="第11章 容器"></a>第11章 容器</h2><ol><li><p>为 <code>vector</code> 的下标运算符增加范围检查功能。</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">Vec</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> std<span class="token operator">::</span><span class="token class-name">vector</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">::</span>vector<span class="token punctuation">;</span> <span class="token comment">// 使用 vector 的构造函数（但名字是 Vec）</span>    T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">vector</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">at</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">vector</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">at</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="第12章-算法"><a href="#第12章-算法" class="headerlink" title="第12章 算法"></a>第12章 算法</h2><h2 id="第13章-实用功能"><a href="#第13章-实用功能" class="headerlink" title="第13章 实用功能"></a>第13章 实用功能</h2><ol><li><p><code>span</code> 的使用</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">use</span><span class="token punctuation">(</span>span<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> vi<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">:</span> vi<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> v <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">use</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>vector vi <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">{</span>vi<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vi<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果一个 <code>tuple</code> 中的某个元素的类型在 <code>tuple</code> 中是唯一的，可以通过其类型来获取它。</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">tuple<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">&gt;</span> t <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"k"</span>s <span class="token punctuation">}</span><span class="token punctuation">;</span>get<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"m"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>与 <code>pair</code> 类似，只要 <code>tuple</code> 的元素支持赋值操作和比较操作，整个 <code>tuple</code> 就能进行赋值和比较。</p></li><li><p>标准库提供了三种类型来表达选择：</p><ul><li><code>variant</code> 用来表达一组指定选择中的一个。</li><li><code>optional</code> 用来表达一个指定类型的值或者没有值。</li><li><code>any</code> 用来表达一组不限数量的可选类型中的一个。</li></ul></li><li><p>有状态的内存分配系列工具 pmr(polymorphic memory resources) 。</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">pmr<span class="token operator">::</span>synchronized_pool_resource pool<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Event</span> <span class="token punctuation">{</span>    pmr<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> data <span class="token operator">=</span> pmr<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token number">512</span><span class="token punctuation">,</span>  <span class="token operator">&amp;</span>pool <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>pmr<span class="token operator">::</span>list<span class="token operator">&lt;</span>shared_ptr<span class="token operator">&lt;</span>Event<span class="token operator">&gt;&gt;</span> q <span class="token punctuation">{</span> <span class="token operator">&amp;</span>pool <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">!=</span> INT_MAX<span class="token punctuation">;</span> <span class="token operator">++</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        q<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>allocate_shared<span class="token operator">&lt;</span>Event<span class="token punctuation">,</span> pmr<span class="token operator">::</span>polymorphic_allocator<span class="token operator">&lt;</span>Event<span class="token operator">&gt;&gt;</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pool<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="第14章-数值"><a href="#第14章-数值" class="headerlink" title="第14章 数值"></a>第14章 数值</h2><ol><li><p>标准库中数学函数报告错误的方式由头文件 <code>#include &lt;cmath&gt;</code> 中宏 <code>math_errhandling</code> 的值决定，其值等于 <code>MATH_ERRNO</code> ，或 <code>MATH_ERREXCEPT</code> ， 或 <code>MATH_ERRNO | MATH_ERREXCEPT</code> 。</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"MATH_ERRNO is "</span>          <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>math_errhandling <span class="token operator">&amp;</span> MATH_ERRNO <span class="token operator">?</span> <span class="token string">"set"</span> <span class="token operator">:</span> <span class="token string">"not set"</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span>          <span class="token operator">&lt;&lt;</span> <span class="token string">"MATH_ERREXCEPT is "</span>          <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>math_errhandling <span class="token operator">&amp;</span> MATH_ERREXCEPT <span class="token operator">?</span> <span class="token string">"set"</span> <span class="token operator">:</span> <span class="token string">"not set"</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>std<span class="token operator">::</span><span class="token function">feclearexcept</span><span class="token punctuation">(</span>FE_ALL_EXCEPT<span class="token punctuation">)</span><span class="token punctuation">;</span>errno <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span>  <span class="token string">"log(0) = "</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>errno <span class="token operator">==</span> ERANGE<span class="token punctuation">)</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"errno = ERANGE ("</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span><span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">")\n"</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">fetestexcept</span><span class="token punctuation">(</span>FE_DIVBYZERO<span class="token punctuation">)</span><span class="token punctuation">)</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"FE_DIVBYZERO (pole error) reported\n"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><a href="https://en.cppreference.com/w/cpp/numeric/math/math_errhandling">https://en.cppreference.com/w/cpp/numeric/math/math_errhandling</a></p></blockquote></li></ol><h2 id="第15章-并发"><a href="#第15章-并发" class="headerlink" title="第15章 并发"></a>第15章 并发</h2><ol><li><p><code>scoped_lock</code> 允许同时获取多个锁。</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">scoped_lock lck <span class="token punctuation">{</span> mutex1<span class="token punctuation">,</span> mutex2<span class="token punctuation">,</span> mutex3 <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>shared_mutex</code> 支持读写锁机制。</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">shared_mutex mx<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    shared_lock lck <span class="token punctuation">{</span> mx <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    unique_lock lck <span class="token punctuation">{</span> mx <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="第16章-历史和兼容性"><a href="#第16章-历史和兼容性" class="headerlink" title="第16章 历史和兼容性"></a>第16章 历史和兼容性</h2>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见排序算法C++实现</title>
      <link href="chang-jian-pai-xu-suan-fa-c-shi-xian/"/>
      <url>chang-jian-pai-xu-suan-fa-c-shi-xian/</url>
      
        <content type="html"><![CDATA[<h2 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        a <span class="token operator">^=</span> b<span class="token punctuation">;</span>        b <span class="token operator">^=</span> a<span class="token punctuation">;</span>        a <span class="token operator">^=</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">get_minmax</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> mi<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> ma<span class="token punctuation">)</span><span class="token punctuation">{</span>    mi <span class="token operator">=</span> ma <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> mi<span class="token punctuation">)</span> <span class="token punctuation">{</span>            mi <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> ma<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ma <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// https://www.bigocheatsheet.com/</span><span class="token comment">// unstable, time: O(n^2) &lt;= O(n^2) &lt;= O(n^2), space: O(1)</span><span class="token keyword">void</span> <span class="token function">selection_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> p <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                p <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// stable, time: O(n) &lt;= O(n^2) &lt;= O(n^2), space: O(1)</span><span class="token keyword">void</span> <span class="token function">bubble_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> n <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">--</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">bool</span> swapped <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                swapped <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>swapped<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// stable, time: O(n) &lt;= O(n^2) &lt;= O(n^2), space: O(1)</span><span class="token keyword">void</span> <span class="token function">insertion_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> j <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> tmp<span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// unstable, time: O(nlogn) &lt;= O((nlogn)^2) &lt;= O((nlogn)^2), space: O(1)</span><span class="token keyword">void</span> <span class="token function">shell_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> k <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> i <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> tmp<span class="token punctuation">;</span> j <span class="token operator">-=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// unstable, time: O(nlogn) &lt;= O(nlogn) &lt;= O(n^2), space: O(logn)</span><span class="token keyword">void</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">helper</span> <span class="token punctuation">{</span>        <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> low <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> low<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> high<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token operator">++</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token operator">++</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> pi <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">quick_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> pi <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">quick_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> pi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    helper<span class="token operator">::</span><span class="token function">quick_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// stable, time: O(nlogn) &lt;= O(nlogn) &lt;= O(nlogn), space: O(n)</span><span class="token keyword">void</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">helper</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token operator">*</span> buf<span class="token punctuation">;</span>        <span class="token function">helper</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span> buf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token operator">~</span><span class="token function">helper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buf<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">void</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>                <span class="token function">merge_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">merge_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> low<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> high<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">,</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                buf<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> left <span class="token operator">=</span> mid <span class="token operator">-</span> low <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right <span class="token operator">=</span> high <span class="token operator">-</span> low <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> left<span class="token punctuation">,</span> k <span class="token operator">=</span> low<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> left <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> right<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>buf<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> buf<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> buf<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> buf<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> left<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">,</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> buf<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> right<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">,</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> buf<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    helper <span class="token function">h</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    h<span class="token punctuation">.</span><span class="token function">merge_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// unstable, time: O(nlogn) &lt;= O(nlogn) &lt;= O(nlogn), space: O(1)</span><span class="token keyword">void</span> <span class="token function">heap_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">helper</span> <span class="token punctuation">{</span>        <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> root<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> largest <span class="token operator">=</span> root<span class="token punctuation">,</span> l <span class="token operator">=</span> root <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r <span class="token operator">=</span> root <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                largest <span class="token operator">=</span> l<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                largest <span class="token operator">=</span> r<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>largest <span class="token operator">!=</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> largest<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        helper<span class="token operator">::</span><span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        helper<span class="token operator">::</span><span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// stable, time: O(n+1) &lt;= O(n+k) &lt;= O(n+k), space: O(n+k)</span><span class="token keyword">void</span> <span class="token function">counting_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> mi <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> ma <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">get_minmax</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> mi<span class="token punctuation">,</span> ma<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> range <span class="token operator">=</span> ma <span class="token operator">-</span> mi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>range<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">++</span>count<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> mi<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> range<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> count<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span><span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        tmp<span class="token punctuation">[</span><span class="token operator">--</span>count<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> mi<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> count<span class="token punctuation">;</span>    <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tmp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// stable, time: O(nk) &lt;= O(nk) &lt;= O(nk), space: O(n+k)</span><span class="token keyword">void</span> <span class="token function">radix_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">helper</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token operator">*</span> buf<span class="token punctuation">;</span>        <span class="token function">helper</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span> buf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token operator">~</span><span class="token function">helper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buf<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">void</span> <span class="token function">counting_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> mi<span class="token punctuation">,</span> <span class="token keyword">int</span> exp<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> count<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token operator">++</span>count<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> mi<span class="token punctuation">)</span> <span class="token operator">/</span> exp<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> count<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                buf<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                buf<span class="token punctuation">[</span><span class="token operator">--</span>count<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> mi<span class="token punctuation">)</span> <span class="token operator">/</span> exp<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> buf<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> mi <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> ma <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">get_minmax</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> mi<span class="token punctuation">,</span> ma<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> range <span class="token operator">=</span> ma <span class="token operator">-</span> mi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    helper <span class="token function">h</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> exp <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> range <span class="token operator">/</span> exp <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> exp <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        h<span class="token punctuation">.</span><span class="token function">counting_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> mi<span class="token punctuation">,</span> exp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// stable, time: O(n+k) &lt;= O(n+k) &lt;= O(n^2), space: O(n)</span><span class="token keyword">void</span> <span class="token function">bucket_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n_bucket <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">*</span> buckets <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">[</span>n_bucket<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> nums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n_bucket<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n_bucket<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> mi <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> ma <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">get_minmax</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> mi<span class="token punctuation">,</span> ma<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> range <span class="token operator">=</span> ma <span class="token operator">-</span> mi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">float</span> v <span class="token operator">=</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> mi<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1.0f</span> <span class="token operator">/</span> range<span class="token punctuation">;</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> v <span class="token operator">*</span> n_bucket<span class="token punctuation">;</span>        buckets<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span>nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n_bucket<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">quick_sort</span><span class="token punctuation">(</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n_bucket<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>p<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n_bucket<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">;</span>    <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buckets<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"sort.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cassert&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;numeric&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;random&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">test_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>f<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">v</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">iota</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">-</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">shuffle</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mt19937<span class="token punctuation">{</span> random_device<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">copy</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ostream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>cout<span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token function">f</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">copy</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ostream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>cout<span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token function">is_sorted</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">test_sort</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> selection_sort<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">test_sort</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> insertion_sort<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">test_sort</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> bubble_sort<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">test_sort</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> shell_sort<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">test_sort</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> quick_sort<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">test_sort</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> merge_sort<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">test_sort</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> heap_sort<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">test_sort</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> counting_sort<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">test_sort</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> radix_sort<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">test_sort</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> bucket_sort<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><p><a href="https://www.bigocheatsheet.com/">https://www.bigocheatsheet.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AVL树C++实现</title>
      <link href="avl-shu-c-shi-xian/"/>
      <url>avl-shu-c-shi-xian/</url>
      
        <content type="html"><![CDATA[<h2 id="一、AVL-树"><a href="#一、AVL-树" class="headerlink" title="一、AVL 树"></a>一、AVL 树</h2><p>AVL 树是一种平衡二叉树，得名于其发明者的名字（Adelson-Velskii 和 Landis）。</p><p>特点：</p><ol><li>平衡二叉搜索树</li><li>每个结点存 balance factor = {-1, 0, 1}，即左右子树的高度差</li><li>四种旋转操作</li></ol><p>缺点：</p><ol><li>结点需要存储额外的信息，而且调整的次数频繁（因为左右子树高度差不能超过1）。</li></ol><h2 id="二、红黑树"><a href="#二、红黑树" class="headerlink" title="二、红黑树"></a>二、红黑树</h2><p>红黑树（Red-Black Tree）是一种 <strong>近似平衡</strong> 的二叉搜索树，它能确保任何一个结点的左右子树的 <strong>高度差小于两倍</strong>。</p><p>特点：</p><ol><li>每个节点要么是红色，要么是黑色；</li><li>根节点是黑色；</li><li>每个叶子节点（ NULL 结点，空节点）是黑色；</li><li>不能有相邻的两个红色节点；</li><li>从任一结点到其每个叶子的所有路径都包含相同数目的黑色节点。</li></ol><p>红黑树的对子树高度差的要求比 AVL 树低，但是依然维持了不错平衡，所以红黑树的维护频率比 AVL 树低，但是效率差不多的高。</p><h2 id="三、AVL-树-C-实现"><a href="#三、AVL-树-C-实现" class="headerlink" title="三、AVL 树 C++ 实现"></a>三、AVL 树 C++ 实现</h2><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>    T <span class="token operator">*</span>left_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> <span class="token operator">*</span>right_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    <span class="token comment">/* left left case: left rotate     *     A          (B)     *    / \        /   \     *  (B)  C      D     A     *  / \     =&gt;       / \     * D   E            E   C     **/</span>    <span class="token keyword">static</span> T<span class="token operator">*</span> <span class="token function">r_rotate</span><span class="token punctuation">(</span>T<span class="token operator">*</span> node<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        T<span class="token operator">*</span> root <span class="token operator">=</span> node<span class="token operator">-&gt;</span>left_<span class="token punctuation">;</span>        node<span class="token operator">-&gt;</span>left_ <span class="token operator">=</span> root<span class="token operator">-&gt;</span>right_<span class="token punctuation">;</span>        root<span class="token operator">-&gt;</span>right_ <span class="token operator">=</span> node<span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/* right right case: left rotate     *   A              (C)     *  / \            /   \     * B  (C)         A     E     *    / \   =&gt;   / \     *   D   E      B   D     **/</span>    <span class="token keyword">static</span> T<span class="token operator">*</span> <span class="token function">l_rotate</span><span class="token punctuation">(</span>T<span class="token operator">*</span> node<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        T<span class="token operator">*</span> root <span class="token operator">=</span> node<span class="token operator">-&gt;</span>right_<span class="token punctuation">;</span>        node<span class="token operator">-&gt;</span>right_ <span class="token operator">=</span> root<span class="token operator">-&gt;</span>left_<span class="token punctuation">;</span>        root<span class="token operator">-&gt;</span>left_ <span class="token operator">=</span> node<span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/* left right case: left rotate, right rotate     *     A              A     *    / \            / \         (E)     *   B   C         (E)  C       /   \     *  / \     =&gt;     / \     =&gt;  B     A     * D  (E)         B   G       / \   / \     *    / \        / \         D   F G   C     *   F   G      D   F     **/</span>    <span class="token keyword">static</span> T<span class="token operator">*</span> <span class="token function">lr_rotate</span><span class="token punctuation">(</span>T<span class="token operator">*</span> node<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        node<span class="token operator">-&gt;</span>left_ <span class="token operator">=</span> <span class="token function">l_rotate</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left_<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">r_rotate</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/* right left case: right rotate, left rotate     *     A            A     *    / \          / \               (D)     *   B   C        B  (D)            /   \     *      / \   =&gt;     / \     =&gt;    A     C     *    (D)  E        F   C         / \   / \     *    / \              / \       B   F G   E     *   F   G            G   E     **/</span>    <span class="token keyword">static</span> T<span class="token operator">*</span> <span class="token function">rl_rotate</span><span class="token punctuation">(</span>T<span class="token operator">*</span> node<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        node<span class="token operator">-&gt;</span>right_ <span class="token operator">=</span> <span class="token function">r_rotate</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right_<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">l_rotate</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">struct</span> <span class="token class-name">HeightNode</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">TreeNode</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> height_ <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">height</span><span class="token punctuation">(</span>T<span class="token operator">*</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> node <span class="token operator">?</span> node<span class="token operator">-&gt;</span>height_ <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">update_height</span><span class="token punctuation">(</span>T<span class="token operator">*</span> node<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">const</span> <span class="token keyword">auto</span> left <span class="token operator">=</span> <span class="token function">height</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left_<span class="token punctuation">)</span><span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token function">height</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right_<span class="token punctuation">)</span><span class="token punctuation">;</span>        node<span class="token operator">-&gt;</span>height_ <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;</span> right <span class="token operator">?</span> left <span class="token operator">:</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> T<span class="token operator">*</span> <span class="token function">r_rotate</span><span class="token punctuation">(</span>T<span class="token operator">*</span> node<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        node <span class="token operator">=</span> <span class="token class-name">TreeNode</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">r_rotate</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">update_height</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right_<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">update_height</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> T<span class="token operator">*</span> <span class="token function">l_rotate</span><span class="token punctuation">(</span>T<span class="token operator">*</span> node<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        node <span class="token operator">=</span> <span class="token class-name">TreeNode</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">l_rotate</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">update_height</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left_<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">update_height</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> T<span class="token operator">*</span> <span class="token function">lr_rotate</span><span class="token punctuation">(</span>T<span class="token operator">*</span> node<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        node<span class="token operator">-&gt;</span>left_ <span class="token operator">=</span> <span class="token function">l_rotate</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left_<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">r_rotate</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> T<span class="token operator">*</span> <span class="token function">rl_rotate</span><span class="token punctuation">(</span>T<span class="token operator">*</span> node<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        node<span class="token operator">-&gt;</span>right_ <span class="token operator">=</span> <span class="token function">r_rotate</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right_<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">l_rotate</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">AVLTree</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">HeightNode</span><span class="token operator">&lt;</span><span class="token class-name">Node</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>        T data_<span class="token punctuation">;</span>        <span class="token function">Node</span><span class="token punctuation">(</span>T data<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">data_</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">V</span><span class="token operator">&gt;</span>    <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span>V<span class="token operator">&amp;</span> visitor<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        visitor<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        visitor<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span>root_<span class="token punctuation">)</span><span class="token punctuation">;</span>        visitor<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>T data<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">exist</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> root_ <span class="token operator">=</span> <span class="token function">insert_</span><span class="token punctuation">(</span>root_<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>T data<span class="token punctuation">)</span> <span class="token punctuation">{</span> root_ <span class="token operator">=</span> <span class="token function">remove_</span><span class="token punctuation">(</span>root_<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">exist</span><span class="token punctuation">(</span>T data<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">find_</span><span class="token punctuation">(</span>root_<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    Node<span class="token operator">*</span> <span class="token function">balance_</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> node<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">const</span> <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token class-name">Node</span><span class="token operator">::</span><span class="token function">height</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left_<span class="token punctuation">)</span><span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token class-name">Node</span><span class="token operator">::</span><span class="token function">height</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right_<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> right <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token operator">::</span><span class="token function">height</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left_<span class="token operator">-&gt;</span>left_<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token class-name">Node</span><span class="token operator">::</span><span class="token function">height</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left_<span class="token operator">-&gt;</span>right_<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                node <span class="token operator">=</span> <span class="token class-name">Node</span><span class="token operator">::</span><span class="token function">lr_rotate</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// left right case</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                node <span class="token operator">=</span> <span class="token class-name">Node</span><span class="token operator">::</span><span class="token function">r_rotate</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// left left case</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">==</span> left <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token operator">::</span><span class="token function">height</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right_<span class="token operator">-&gt;</span>left_<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token class-name">Node</span><span class="token operator">::</span><span class="token function">height</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right_<span class="token operator">-&gt;</span>right_<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                node <span class="token operator">=</span> <span class="token class-name">Node</span><span class="token operator">::</span><span class="token function">l_rotate</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// right left case</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                node <span class="token operator">=</span> <span class="token class-name">Node</span><span class="token operator">::</span><span class="token function">rl_rotate</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// right left case</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Node<span class="token operator">*</span> <span class="token function">insert_</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> node<span class="token punctuation">,</span> T data<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">&lt;</span> node<span class="token operator">-&gt;</span>data_<span class="token punctuation">)</span> <span class="token punctuation">{</span>            node<span class="token operator">-&gt;</span>left_ <span class="token operator">=</span> <span class="token function">insert_</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left_<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            node<span class="token operator">-&gt;</span>right_ <span class="token operator">=</span> <span class="token function">insert_</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right_<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        node <span class="token operator">=</span> <span class="token function">balance_</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Node</span><span class="token operator">::</span><span class="token function">update_height</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Node<span class="token operator">*</span> <span class="token function">remove_</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> node<span class="token punctuation">,</span> T data<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> node<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">==</span> node<span class="token operator">-&gt;</span>data_<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left_ <span class="token operator">&amp;&amp;</span> node<span class="token operator">-&gt;</span>right_<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token operator">::</span><span class="token function">height</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left_<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token class-name">Node</span><span class="token operator">::</span><span class="token function">height</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right_<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Node<span class="token operator">*</span> minimum <span class="token operator">=</span> node<span class="token operator">-&gt;</span>right_<span class="token punctuation">;</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span>minimum<span class="token operator">-&gt;</span>left_<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        minimum <span class="token operator">=</span> minimum<span class="token operator">-&gt;</span>left_<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    node<span class="token operator">-&gt;</span>data_ <span class="token operator">=</span> minimum<span class="token operator">-&gt;</span>data_<span class="token punctuation">;</span>                    node<span class="token operator">-&gt;</span>right_ <span class="token operator">=</span> <span class="token function">remove_</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right_<span class="token punctuation">,</span> minimum<span class="token operator">-&gt;</span>data_<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    Node<span class="token operator">*</span> maximum <span class="token operator">=</span> node<span class="token operator">-&gt;</span>left_<span class="token punctuation">;</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span>maximum<span class="token operator">-&gt;</span>right_<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        maximum <span class="token operator">=</span> maximum<span class="token operator">-&gt;</span>right_<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    node<span class="token operator">-&gt;</span>data_ <span class="token operator">=</span> maximum<span class="token operator">-&gt;</span>data_<span class="token punctuation">;</span>                    node<span class="token operator">-&gt;</span>left_ <span class="token operator">=</span> <span class="token function">remove_</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left_<span class="token punctuation">,</span> maximum<span class="token operator">-&gt;</span>data_<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                Node<span class="token operator">*</span> tmp <span class="token operator">=</span> node<span class="token punctuation">;</span>                node <span class="token operator">=</span> node<span class="token operator">-&gt;</span>left_ <span class="token operator">?</span> node<span class="token operator">-&gt;</span>left_ <span class="token operator">:</span> node<span class="token operator">-&gt;</span>right_<span class="token punctuation">;</span>                <span class="token keyword">delete</span> tmp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">&lt;</span> node<span class="token operator">-&gt;</span>data_<span class="token punctuation">)</span> <span class="token punctuation">{</span>            node<span class="token operator">-&gt;</span>left_ <span class="token operator">=</span> <span class="token function">remove_</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left_<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>            node <span class="token operator">=</span> <span class="token function">balance_</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            node<span class="token operator">-&gt;</span>right_ <span class="token operator">=</span> <span class="token function">remove_</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right_<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>            node <span class="token operator">=</span> <span class="token function">balance_</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Node<span class="token operator">*</span> <span class="token function">find_</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> node<span class="token punctuation">,</span> T data<span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>node <span class="token operator">&amp;&amp;</span> data <span class="token operator">!=</span> node<span class="token operator">-&gt;</span>data_<span class="token punctuation">)</span> <span class="token punctuation">{</span>            node <span class="token operator">=</span> data <span class="token operator">&lt;</span> node<span class="token operator">-&gt;</span>data_ <span class="token operator">?</span> node<span class="token operator">-&gt;</span>left_ <span class="token operator">:</span> node<span class="token operator">-&gt;</span>right_<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    Node<span class="token operator">*</span> root_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"avl.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">struct</span> <span class="token class-name">InOrderVisitor</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"in-order: "</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> data <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">::</span>Node<span class="token operator">*</span> node<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">visit</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left_<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">visit</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>data_<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">visit</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right_<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">void</span> <span class="token function">test_tree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    T tree<span class="token punctuation">;</span>    InOrderVisitor<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> visitor<span class="token punctuation">;</span>    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> v <span class="token operator">:</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        tree<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> v <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> tree<span class="token punctuation">.</span><span class="token function">exist</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        tree<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>visitor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> v <span class="token operator">:</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        tree<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> v <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> tree<span class="token punctuation">.</span><span class="token function">exist</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        tree<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>visitor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    test_tree<span class="token operator">&lt;</span>AVLTree<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AStar算法C++实现</title>
      <link href="astar-suan-fa-c-shi-xian/"/>
      <url>astar-suan-fa-c-shi-xian/</url>
      
        <content type="html"><![CDATA[<h2 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional&gt;</span> <span class="token comment">// function</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue&gt;</span> <span class="token comment">// priority_queue</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;tuple&gt;</span> <span class="token comment">// tuple</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unordered_map&gt;</span> <span class="token comment">// unordered_map</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span> <span class="token comment">// vector</span></span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">grid_t</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">cost_t</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">pos_t</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">hash_t</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">equal_t</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">AStar</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> pos_cost_t <span class="token operator">=</span> std<span class="token operator">::</span>tuple<span class="token operator">&lt;</span>pos_t<span class="token punctuation">,</span> cost_t<span class="token operator">&gt;</span><span class="token punctuation">;</span>    <span class="token keyword">using</span> heuristic_f <span class="token operator">=</span> std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token function">cost_t</span><span class="token punctuation">(</span><span class="token keyword">const</span> pos_t<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> pos_t<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>    <span class="token keyword">using</span> neighbor_f <span class="token operator">=</span> std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">const</span> pos_t<span class="token operator">&amp;</span><span class="token punctuation">,</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>pos_cost_t<span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>    <span class="token function">AStar</span><span class="token punctuation">(</span><span class="token keyword">const</span> grid_t<span class="token operator">&amp;</span> grid<span class="token punctuation">,</span> <span class="token keyword">const</span> heuristic_f heuristic<span class="token punctuation">,</span> <span class="token keyword">const</span> neighbor_f neighbor<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">grid_</span><span class="token punctuation">(</span>grid<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">heuristic_</span><span class="token punctuation">(</span>heuristic<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">neighbor_</span><span class="token punctuation">(</span>neighbor<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">find_path</span><span class="token punctuation">(</span><span class="token keyword">const</span> pos_t<span class="token operator">&amp;</span> from<span class="token punctuation">,</span> <span class="token keyword">const</span> pos_t<span class="token operator">&amp;</span> to<span class="token punctuation">,</span> cost_t<span class="token operator">*</span> cost<span class="token punctuation">,</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>pos_t<span class="token operator">&gt;</span><span class="token operator">*</span> path<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">const</span> <span class="token keyword">auto</span> comp_f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> pos_cost_t<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> pos_cost_t<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> std<span class="token operator">::</span>get<span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">&gt;</span> std<span class="token operator">::</span>get<span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        std<span class="token operator">::</span>priority_queue<span class="token operator">&lt;</span>pos_cost_t<span class="token punctuation">,</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>pos_cost_t<span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>comp_f<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token function">q</span><span class="token punctuation">(</span>comp_f<span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>pos_cost_t<span class="token operator">&gt;</span> neighbors<span class="token punctuation">;</span>        std<span class="token operator">::</span>unordered_map<span class="token operator">&lt;</span>pos_t<span class="token punctuation">,</span> cost_t<span class="token punctuation">,</span> hash_t<span class="token punctuation">,</span> equal_t<span class="token operator">&gt;</span> g<span class="token punctuation">;</span>        std<span class="token operator">::</span>unordered_map<span class="token operator">&lt;</span>pos_t<span class="token punctuation">,</span> pos_t<span class="token punctuation">,</span> hash_t<span class="token punctuation">,</span> equal_t<span class="token operator">&gt;</span> came_from<span class="token punctuation">;</span>        g<span class="token punctuation">[</span>from<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">cost_t</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>from<span class="token punctuation">,</span> <span class="token function">cost_t</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">auto</span> cur <span class="token operator">=</span> std<span class="token operator">::</span>get<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">equal_t</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> to<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>cost<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token operator">*</span>cost <span class="token operator">=</span> g<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span>came_from<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        path<span class="token operator">-&gt;</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>                        cur <span class="token operator">=</span> came_from<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    path<span class="token operator">-&gt;</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span>                    std<span class="token operator">::</span><span class="token function">reverse</span><span class="token punctuation">(</span>path<span class="token operator">-&gt;</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> path<span class="token operator">-&gt;</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">const</span> <span class="token keyword">auto</span> g_cur <span class="token operator">=</span> g<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token function">neighbor_</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> neighbors<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> <span class="token punctuation">[</span>next<span class="token punctuation">,</span> cost<span class="token punctuation">]</span> <span class="token operator">:</span> neighbors<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">const</span> <span class="token keyword">auto</span> new_cost <span class="token operator">=</span> g_cur <span class="token operator">+</span> cost<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>g<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span> <span class="token operator">||</span> new_cost <span class="token operator">&lt;</span> g<span class="token punctuation">[</span>next<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    came_from<span class="token punctuation">[</span>next<span class="token punctuation">]</span> <span class="token operator">=</span> cur<span class="token punctuation">;</span>                    g<span class="token punctuation">[</span>next<span class="token punctuation">]</span> <span class="token operator">=</span> new_cost<span class="token punctuation">;</span>                    q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> new_cost <span class="token operator">+</span> <span class="token function">heuristic_</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> to<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            neighbors<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">const</span> grid_t<span class="token operator">&amp;</span> grid_<span class="token punctuation">;</span>    <span class="token keyword">const</span> heuristic_f heuristic_<span class="token punctuation">;</span>    <span class="token keyword">const</span> neighbor_f neighbor_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"astar.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iomanip&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">namespace</span> std <span class="token punctuation">{</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T2</span><span class="token operator">&gt;</span><span class="token keyword">struct</span> <span class="token class-name">hash</span><span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token operator">&gt;&gt;</span> <span class="token punctuation">{</span>    size_t <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> pair<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token operator">&gt;</span><span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> hash<span class="token operator">&lt;</span>T1<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>first<span class="token punctuation">)</span> <span class="token operator">^</span> hash<span class="token operator">&lt;</span>T2<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment">// namespace std</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">void</span> <span class="token function">dump2d</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> grid<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> row <span class="token operator">:</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> v <span class="token operator">:</span> row<span class="token punctuation">)</span> <span class="token punctuation">{</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> left <span class="token operator">&lt;&lt;</span> v <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/</span><span class="token keyword">int</span> <span class="token function">shortestPathBinaryMatrix</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">using</span> pos <span class="token operator">=</span> pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">auto</span> heuristic <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> pos<span class="token operator">&amp;</span> from<span class="token punctuation">,</span> <span class="token keyword">const</span> pos<span class="token operator">&amp;</span> to<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span>to<span class="token punctuation">.</span>first <span class="token operator">-</span> from<span class="token punctuation">.</span>first<span class="token punctuation">,</span> to<span class="token punctuation">.</span>second <span class="token operator">-</span> from<span class="token punctuation">.</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">auto</span> neighbor <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>grid<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> pos<span class="token operator">&amp;</span> p<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>tuple<span class="token operator">&lt;</span>pos<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;&gt;</span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">constexpr</span> pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> dirs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>            <span class="token punctuation">{</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>grid<span class="token punctuation">[</span>p<span class="token punctuation">.</span>first<span class="token punctuation">]</span><span class="token punctuation">[</span>p<span class="token punctuation">.</span>second<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> dir <span class="token operator">:</span> dirs<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">const</span> <span class="token keyword">auto</span> x <span class="token operator">=</span> dir<span class="token punctuation">.</span>first <span class="token operator">+</span> p<span class="token punctuation">.</span>first<span class="token punctuation">,</span> y <span class="token operator">=</span> dir<span class="token punctuation">.</span>second <span class="token operator">+</span> p<span class="token punctuation">.</span>second<span class="token punctuation">;</span>                <span class="token keyword">const</span> <span class="token keyword">auto</span> n <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">(</span>grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> x <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> y <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> y <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>grid<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    AStar<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>grid<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> pos<span class="token punctuation">,</span> hash<span class="token operator">&lt;</span>pos<span class="token operator">&gt;</span><span class="token punctuation">,</span> equal_to<span class="token operator">&lt;</span>pos<span class="token operator">&gt;&gt;</span> <span class="token function">astar</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> heuristic<span class="token punctuation">,</span> neighbor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">(</span>grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> pos from<span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> to<span class="token punctuation">{</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> cost<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span>pos<span class="token operator">&gt;</span> path<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>astar<span class="token punctuation">.</span><span class="token function">find_path</span><span class="token punctuation">(</span>from<span class="token punctuation">,</span> to<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cost<span class="token punctuation">,</span> <span class="token operator">&amp;</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">++</span>cost<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"cost: "</span> <span class="token operator">&lt;&lt;</span> cost <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"path: \n"</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">int</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        grid<span class="token punctuation">[</span>path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>first<span class="token punctuation">]</span><span class="token punctuation">[</span>path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>second<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">dump2d</span><span class="token punctuation">(</span>grid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> cost<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> grid <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">shortestPathBinaryMatrix</span><span class="token punctuation">(</span>grid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Seq2Seq与Attention</title>
      <link href="seq2seq-yu-attention/"/>
      <url>seq2seq-yu-attention/</url>
      
        <content type="html"><![CDATA[<h2 id="一、循环神经网络"><a href="#一、循环神经网络" class="headerlink" title="一、循环神经网络"></a>一、循环神经网络</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C">循环神经网络（Recurrent neural network，RNN）</a> 和前馈神经网络（Feedforward Neural Network）的主要区别是：</p><div class="table-container"><table><thead><tr><th>网络</th><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>前馈神经网络</td><td>训练数据</td><td>训练后的数据</td></tr><tr><td>循环神经网络</td><td>训练数据 + 上一层输出的隐状态</td><td>训练后的数据 + 新的隐状态</td></tr></tbody></table></div><p><img src="/images/Seq2Seq与Attention/fnn_vs_rnn.jpg" alt="前馈神经网络对比循环神经网络"></p><blockquote><p>图片来源：<a href="https://wiki.tum.de/display/lfdv/Recurrent+Neural+Networks+-+Combination+of+RNN+and+CNN">Recurrent Neural Networks - Combination of RNN and CNN</a></p></blockquote><p>将上图的循环神经网络展开可以得到：</p><p><img src="/images/Seq2Seq与Attention/rnn.jpg" alt="RNN网络展开图"></p><blockquote><p>图片来源：<a href="http://www.wildml.com/2015/09/recurrent-neural-networks-tutorial-part-1-introduction-to-rnns/">Recurrent Neural Networks Tutorial, Part 1 – Introduction to RNNs</a></p></blockquote><p>其中：</p><ul><li>$x_t$ 是 $t$ 时刻的输入。比如 $x_1$ 可以是一段话中与第 2 个单词对应的 one-hot 向量；</li><li>$s_t$ 是 $t$ 时刻输出的隐状态，它是网络的“记忆”。 $s_t$ 根据前一个隐状态和当前时刻的输入计算得出：$s_t = f(U x_t + W s_{t-1})$，其中函数 $f$ 通常是非线性的，比如：$tanh$ 或 $ReLU$ 。当计算第一个隐状态时， $s_{-1}$ 通常初始化为全零；</li><li>$o_t$ 是 $t$ 时刻的输出。比如，如果是预测一个句子的下一个单词，它就是词汇表中各个单词的概率向量： $o_t = softmax(V s_t)$ 。</li></ul><p>注意：</p><ul><li>隐状态 $s_t$ 可以看做是网络的记忆，它收集了 $t$ 时刻及之前所有输入的信息。</li><li>每一步中的神经网络参数 $U$ 、 $V$ 和 $W$ 都是相同的。</li><li>每一步的输出 $o_t$ 不是必须需要使用的。比如，在预测一段话是积极的还是消极的时，只需要最后一步的输出即可。</li><li>每一步的输入 $x_t$ 也不是必须的，一个网络可以只需要另一个网络最后输出的隐状态作为该网络的初始隐状态即可产生一系列的输出。</li></ul><p>理论上，不管输入的序列 $\{x_0, x_1, x_2, \cdots, x_t \}$ 多长，最后网络输出的隐状态 $s_t$ 应该都是包含了所有输入信息的。但是实际在使用时发现，循环神经网络对于比较长的输入序列来说，效果更差，这称之为长期依赖（Long-Term Dependencies）问题。</p><p>比如在一个根据之前的词预测下一个词的任务中，如果文本是 “I grew up in France… I speak fluent French”，如果第一句话与最后一句话隔得越远，循环神经网络就越难预测出最后的 “French”。</p><h2 id="二、双向循环神经网络"><a href="#二、双向循环神经网络" class="headerlink" title="二、双向循环神经网络"></a>二、双向循环神经网络</h2><p>标准的循环神经网络只考虑的过去输入，没有考虑未来的输入，而双向循环神经网络（Bi-directional Recurrent Neural Network，BRNN）则是都考虑了，其网络结构如下：</p><p><img src="/images/Seq2Seq与Attention/brnn.jpg" alt="双向循环神经网络"></p><blockquote><p>图片来源：<a href="https://blog.csdn.net/jojozhangju/article/details/51982254">双向长短时记忆循环神经网络详解（Bi-directional LSTM RNN）</a></p></blockquote><p>其中输出的值 $o_t$ 由下面的公式得到：</p><script type="math/tex; mode=display">h_t = f(w_1 x_t + w_2 h_{t-1})</script><script type="math/tex; mode=display">{h_t}\prime = f(w_3 x_t + w_5 {h_{t+1}}\prime)</script><script type="math/tex; mode=display">o_t = g(w_4 h_t + w_6 {h_t}\prime)</script><h2 id="三、长短时记忆网络"><a href="#三、长短时记忆网络" class="headerlink" title="三、长短时记忆网络"></a>三、长短时记忆网络</h2><p><a href="https://zh.wikipedia.org/wiki/%E9%95%B7%E7%9F%AD%E6%9C%9F%E8%A8%98%E6%86%B6">长短时记忆（Long Short Term Memory，LSTM）</a> 网络也属于循环神经网络，它较好的解决了循环神经网络有的长期依赖问题。其网络结构如下：</p><p><img src="/images/Seq2Seq与Attention/lstm.png" alt="LSTM"></p><blockquote><p>图片来源：<a href="https://stackoverflow.com/questions/44273249/in-keras-what-exactly-am-i-configuring-when-i-create-a-stateful-lstm-layer-wi">In Keras, what exactly am I configuring when I create a stateful LSTM layer with N units?</a></p></blockquote><p>长短时记忆网络的一个流行的变体是 <a href="https://en.wikipedia.org/wiki/Gated_recurrent_unit">GRU（Gated Recurrent Unit）</a> ，其网络结构如下：</p><p><img src="/images/Seq2Seq与Attention/gru.png" alt="GRU"></p><blockquote><p>图片来源：<a href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/">Understanding LSTM Networks</a></p></blockquote><h2 id="四、Seq2Seq"><a href="#四、Seq2Seq" class="headerlink" title="四、Seq2Seq"></a>四、Seq2Seq</h2><p>Seq2Seq 其实是指从一个序列生成另外一个序列的结构，这种结构由 Encoder 和 Decoder 组成。其中在 Encoder 和 Decoder 之间传递的只有输入序列最后一步得到的隐状态，如下图：</p><p><img src="/images/Seq2Seq与Attention/seq2seq.png" alt="Seq2Seq"></p><blockquote><p>图片来源：<a href="https://www.guru99.com/seq2seq-model.html">Seq2seq (Sequence to Sequence) Model with PyTorch</a></p></blockquote><h2 id="五、Attention"><a href="#五、Attention" class="headerlink" title="五、Attention"></a>五、Attention</h2><p>Attention 机制就是对输入的每个元素考虑不同的权重参数，从而更加关注与输入的元素相似的部分，而抑制其它无用的信息。</p><p><img src="/images/Seq2Seq与Attention/attention_1.png" alt="Attention的整体流程"><br><img src="/images/Seq2Seq与Attention/attention_2.png" alt="Attention的计算过程"></p><blockquote><p>图片来源：<a href="https://lena-voita.github.io/nlp_course.html">Sequence to Sequence (seq2seq) and Attention</a></p></blockquote><h2 id="六、参考资料"><a href="#六、参考资料" class="headerlink" title="六、参考资料"></a>六、参考资料</h2><ol><li><a href="https://lena-voita.github.io/nlp_course/seq2seq_and_attention.html">Sequence to Sequence (seq2seq) and Attention</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rnn </tag>
            
            <tag> brnn </tag>
            
            <tag> lstm </tag>
            
            <tag> gru </tag>
            
            <tag> seq2seq </tag>
            
            <tag> attention </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP中的Embedding和Padding</title>
      <link href="nlp-zhong-de-embedding-he-padding/"/>
      <url>nlp-zhong-de-embedding-he-padding/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Embedding"><a href="#1-Embedding" class="headerlink" title="1. Embedding"></a>1. Embedding</h2><p>在 <a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86">自然语言处理（Natural Language Processing，NLP）</a> 过程中，神经网络的输入一般是一段句子，句子有一个一个的字组成。</p><p>在输入神经网络之前，需要将这些字进行编码，常规的编码方式比如 <a href="https://zh.wikipedia.org/wiki/One-hot">One-hot</a> 是有多少种字，编码出来的向量就有多长，这会导致编码后的数据特别的大，从而导致对应的神经网络接收的输入也特别多的大，不便于训练。除了编码后的数据大这个缺点外，one-hot 编码还有一个更重要的缺点就是没法表达词与词关系，比如猫和狗之间的关系，显然要比猫和电脑之间的关系近，这点 one-hot 无法表达出来。</p><p>所以在 NLP 中常用的编码方式是 <a href="https://zh.wikipedia.org/wiki/%E8%AF%8D%E5%B5%8C%E5%85%A5">Embedding</a>，其本质是把一个数用几个不同的数字来表示，而不是像 One-hot 那样，只用一个 1 来表示。</p><p>比如，我们有 <code>50000</code> 个数字范围在 <code>[0-1000)</code> 之间的数字，需要编码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npnums <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">50000</span><span class="token punctuation">)</span>nums<span class="token punctuation">.</span>shape  <span class="token comment"># (50000, )</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用 One-hot 编码后的大小为：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">one_hot <span class="token operator">=</span> np<span class="token punctuation">.</span>eye<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">[</span>nums<span class="token punctuation">]</span>one_hot<span class="token punctuation">.</span>shape  <span class="token comment"># (50000, 1000)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>而使用 Embedding 编码后的大小为（假设 embedding 的长度为 10）后的：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">data <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">50000</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>embedding <span class="token operator">=</span> data<span class="token punctuation">[</span>nums<span class="token punctuation">]</span>embedding<span class="token punctuation">.</span>shape  <span class="token comment"># (50000, 10)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="2-Padding"><a href="#2-Padding" class="headerlink" title="2. Padding"></a>2. Padding</h2><p>在 NLP 中，Embedding 只是解决了编码后向量特别大的问题，依然没有解决句子长度不同的问题。这是就需要 Padding。</p><p>Padding 的本质就是定一个句子长度 <code>N</code> ，然后把待训练的数据中句子长于 N 的句子截断到 N 长度，把短于 N 的句子使用一个特殊的字填充到长度 N 。</p><h2 id="3-Embedding-和-Padding-简单的实现"><a href="#3-Embedding-和-Padding-简单的实现" class="headerlink" title="3. Embedding 和 Padding 简单的实现"></a>3. Embedding 和 Padding 简单的实现</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> torch<span class="token keyword">from</span> tensorflow <span class="token keyword">import</span> convert_to_tensor<span class="token punctuation">,</span> keras<span class="token comment"># 待处理的文本</span>text <span class="token operator">=</span> <span class="token punctuation">(</span>    <span class="token triple-quoted-string string">"""The clock is running.Make the most of today.Time waits for no man.Yesterday is history.Tomorrow is a mystery.Today is a gift.That's why it is called the present."""</span><span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token string">"\n "</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"'s"</span><span class="token punctuation">,</span> <span class="token string">" is"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">make_word_index</span><span class="token punctuation">(</span>text<span class="token punctuation">,</span> base<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""把一段文本中的单词以空格为分隔符分开，生成一个{单词,ID}的字段对应表    Args:        text (str): 待处理的文本        base (int): 起始ID    Returns:        dict: {单词,ID}对应表    """</span>    words <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">set</span><span class="token punctuation">(</span>text<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    words<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>    word2id <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token builtin">id</span><span class="token punctuation">,</span> word <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>words<span class="token punctuation">,</span> base<span class="token punctuation">)</span><span class="token punctuation">:</span>        word2id<span class="token punctuation">[</span>word<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">id</span>    <span class="token keyword">return</span> word2id<span class="token keyword">def</span> <span class="token function">pad_or_truncate</span><span class="token punctuation">(</span>some_list<span class="token punctuation">,</span> target_len<span class="token punctuation">,</span> pad_value<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""把列表截断或补齐到指定的长度，如果长度不足，则以指定的补齐    Args:        some_list (list[int])): 待处理的列表        target_len (int): 指定的长度        pad_value (int): 补齐时用到的值    Returns:        list[int]: 处理后的列表    """</span>    <span class="token keyword">return</span> some_list<span class="token punctuation">[</span><span class="token punctuation">:</span>target_len<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">[</span>pad_value<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>target_len <span class="token operator">-</span> <span class="token builtin">len</span><span class="token punctuation">(</span>some_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">process_text</span><span class="token punctuation">(</span>word2id<span class="token punctuation">,</span> seq_len<span class="token punctuation">,</span> pad_value<span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""预处理文本，将文本以行为单位分成句子，每个句子中的单词根据字典替换成ID，并将句子截断或补齐到指定的长度    Args:        word2id (dict[str, int]): {单词,ID}字典        seq_len (int): 句子的长度        pad_value (int): 补齐时用到的值        text (str)): 待处理的问题    Returns:        list[list[int]]: 处理后的包含句子的列表    """</span>    sentences <span class="token operator">=</span> <span class="token punctuation">[</span>sentence<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span> <span class="token keyword">for</span> sentence <span class="token keyword">in</span> text<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    sentences_ids <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>word2id<span class="token punctuation">[</span>word<span class="token punctuation">]</span> <span class="token keyword">for</span> word <span class="token keyword">in</span> sentence<span class="token punctuation">]</span> <span class="token keyword">for</span> sentence <span class="token keyword">in</span> sentences<span class="token punctuation">]</span>    sentences_ids <span class="token operator">=</span> <span class="token punctuation">[</span>pad_or_truncate<span class="token punctuation">(</span>sentence_ids<span class="token punctuation">,</span> seq_len<span class="token punctuation">,</span> pad_value<span class="token punctuation">)</span> <span class="token keyword">for</span> sentence_ids <span class="token keyword">in</span> sentences_ids<span class="token punctuation">]</span>    <span class="token keyword">return</span> sentences_ids<span class="token keyword">def</span> <span class="token function">embedding_sentences_ids</span><span class="token punctuation">(</span>word_num<span class="token punctuation">,</span> embedding_len<span class="token punctuation">,</span> sentences_ids<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""embedding句子    Args:        word_num (int): 单词类型的总数        embedding_len (int): embedding的长度        sentences_ids (list[list[int]]): 包含句子的列表    Returns:        np.ndarray: embedding的矩阵        np.ndarray: 句子embedding后的值    """</span>    embeddings <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span>word_num<span class="token punctuation">,</span> embedding_len<span class="token punctuation">)</span>    <span class="token keyword">return</span> embeddings<span class="token punctuation">,</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span>embeddings<span class="token punctuation">[</span>sentence_ids<span class="token punctuation">]</span> <span class="token keyword">for</span> sentence_ids <span class="token keyword">in</span> sentences_ids<span class="token punctuation">]</span><span class="token punctuation">)</span>PAD_TEXT <span class="token operator">=</span> <span class="token string">"&lt;PAD&gt;"</span>  <span class="token comment"># 补齐时使用的单词</span>PAD_INDEX <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># 补齐时使用的值</span>SENTENCE_LEN <span class="token operator">=</span> <span class="token number">6</span>  <span class="token comment"># 处理后句子的长度（更长的截断，更短的补齐）</span><span class="token comment"># 根据文本生成，单词=&gt;ID的表，其中ID有一个偏移，用于存放补齐单词</span>word2id <span class="token operator">=</span> make_word_index<span class="token punctuation">(</span>text<span class="token operator">=</span>text<span class="token punctuation">,</span> base<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment"># 放入把补齐的单词</span>word2id<span class="token punctuation">[</span>PAD_TEXT<span class="token punctuation">]</span> <span class="token operator">=</span> PAD_INDEX<span class="token comment"># 生成句子</span>sentences_ids <span class="token operator">=</span> process_text<span class="token punctuation">(</span>word2id<span class="token punctuation">,</span> SENTENCE_LEN<span class="token punctuation">,</span> PAD_INDEX<span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token comment"># 总的单词种类</span>word_num <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>word2id<span class="token punctuation">)</span><span class="token comment"># embedding的长度</span>embedding_len <span class="token operator">=</span> <span class="token number">10</span><span class="token comment"># 使用自己实现的函数embedding句子</span>embeddings<span class="token punctuation">,</span> embedding_sentences <span class="token operator">=</span> embedding_sentences_ids<span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>word2id<span class="token punctuation">)</span><span class="token punctuation">,</span> embedding_len<span class="token punctuation">,</span> sentences_ids<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>embedding_sentences<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>  <span class="token comment"># (7, 6, 10)</span><span class="token comment"># 使用pytorch内置的Embedding来embedding句子</span>torch_embedding <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Embedding<span class="token punctuation">.</span>from_pretrained<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>embeddings<span class="token punctuation">)</span><span class="token punctuation">)</span>torch_embedding_sentences <span class="token operator">=</span> torch_embedding<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>sentences_ids<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>torch_embedding_sentences<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>  <span class="token comment"># torch.Size([7, 6, 10])</span><span class="token comment"># 确保两种方式生成的结果是相同的</span><span class="token keyword">assert</span> np<span class="token punctuation">.</span>allclose<span class="token punctuation">(</span>embedding_sentences<span class="token punctuation">,</span> torch_embedding_sentences<span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 使用keras内置的Embedding来embedding句子</span>keras_embedding <span class="token operator">=</span> keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Embedding<span class="token punctuation">(</span>    word_num<span class="token punctuation">,</span> embedding_len<span class="token punctuation">,</span> embeddings_initializer<span class="token operator">=</span>keras<span class="token punctuation">.</span>initializers<span class="token punctuation">.</span>Constant<span class="token punctuation">(</span>embeddings<span class="token punctuation">)</span><span class="token punctuation">)</span>keras_embedding_sentences <span class="token operator">=</span> keras_embedding<span class="token punctuation">(</span>convert_to_tensor<span class="token punctuation">(</span>sentences_ids<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>keras_embedding_sentences<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token comment"># 确保两种方式生成的结果是相同的</span><span class="token keyword">assert</span> np<span class="token punctuation">.</span>allclose<span class="token punctuation">(</span>embedding_sentences<span class="token punctuation">,</span> keras_embedding_sentences<span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-使用-Keras-中的-Embedding-来训练-IMDB-预测模型"><a href="#4-使用-Keras-中的-Embedding-来训练-IMDB-预测模型" class="headerlink" title="4. 使用 Keras 中的 Embedding 来训练 IMDB 预测模型"></a>4. 使用 Keras 中的 Embedding 来训练 IMDB 预测模型</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> tensorflow<span class="token punctuation">.</span>keras <span class="token keyword">import</span> layers<span class="token punctuation">,</span> models<span class="token keyword">from</span> tensorflow<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> imdb<span class="token keyword">from</span> tensorflow<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>preprocessing <span class="token keyword">import</span> sequencenum_words <span class="token operator">=</span> <span class="token number">1000</span>embedding_dim <span class="token operator">=</span> <span class="token number">16</span>maxlen <span class="token operator">=</span> <span class="token number">80</span>batch_size <span class="token operator">=</span> <span class="token number">32</span><span class="token punctuation">(</span>x_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>x_test<span class="token punctuation">,</span> y_test<span class="token punctuation">)</span> <span class="token operator">=</span> imdb<span class="token punctuation">.</span>load_data<span class="token punctuation">(</span>num_words<span class="token operator">=</span>num_words<span class="token punctuation">)</span>x_train <span class="token operator">=</span> sequence<span class="token punctuation">.</span>pad_sequences<span class="token punctuation">(</span>x_train<span class="token punctuation">,</span> maxlen<span class="token operator">=</span>maxlen<span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token string">"post"</span><span class="token punctuation">)</span>x_test <span class="token operator">=</span> sequence<span class="token punctuation">.</span>pad_sequences<span class="token punctuation">(</span>x_test<span class="token punctuation">,</span> maxlen<span class="token operator">=</span>maxlen<span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token string">"post"</span><span class="token punctuation">)</span>model <span class="token operator">=</span> models<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>    <span class="token punctuation">[</span>        layers<span class="token punctuation">.</span>Embedding<span class="token punctuation">(</span>num_words<span class="token punctuation">,</span> embedding_dim<span class="token punctuation">,</span> input_length<span class="token operator">=</span>maxlen<span class="token punctuation">)</span><span class="token punctuation">,</span>        layers<span class="token punctuation">.</span>GlobalAveragePooling1D<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">"relu"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">"sigmoid"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>summary<span class="token punctuation">(</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span><span class="token builtin">compile</span><span class="token punctuation">(</span>optimizer<span class="token operator">=</span><span class="token string">"adam"</span><span class="token punctuation">,</span> loss<span class="token operator">=</span><span class="token string">"binary_crossentropy"</span><span class="token punctuation">,</span> metrics<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"accuracy"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>x_train<span class="token punctuation">,</span> y_train<span class="token punctuation">,</span> epochs<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">,</span> batch_size<span class="token operator">=</span>batch_size<span class="token punctuation">,</span> validation_split<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">)</span>score<span class="token punctuation">,</span> acc <span class="token operator">=</span> model<span class="token punctuation">.</span>evaluate<span class="token punctuation">(</span>x_test<span class="token punctuation">,</span> y_test<span class="token punctuation">,</span> batch_size<span class="token operator">=</span>batch_size<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Test score:"</span><span class="token punctuation">,</span> score<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Test accuracy:"</span><span class="token punctuation">,</span> acc<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytorch </tag>
            
            <tag> keras </tag>
            
            <tag> embedding </tag>
            
            <tag> padding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iptables简介</title>
      <link href="iptables-jian-jie/"/>
      <url>iptables-jian-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="一、netfilter-项目"><a href="#一、netfilter-项目" class="headerlink" title="一、netfilter 项目"></a>一、netfilter 项目</h2><p><a href="https://www.netfilter.org/">netfilter 项目</a>是 <a href="https://www.kernel.org/">Linux</a> 内核中用于数据包过滤的框架。</p><p>netfilter 项目有两个常用的子项目：iptables 和 nftables。</p><p><a href="https://www.nftables.org/projects/iptables/index.html">iptables 项目</a>中包含了一系列用于配置 Linux 内核中包过滤规则集命令行工具：iptables，ip6tables，arptables，ebtables。</p><p><a href="https://www.nftables.org/projects/nftables/index.html">nftables 项目</a>则是 iptables 项目的继承者，它允许更灵活、可扩展和性能更高的数据包分类。</p><p><strong>本文只介绍使用 iptables 命令行工具管理 ip 协议时所需的相关内容。</strong></p><h2 id="二、iptables-中的基本概念"><a href="#二、iptables-中的基本概念" class="headerlink" title="二、iptables 中的基本概念"></a>二、iptables 中的基本概念</h2><p>netfilter 框架的核心是在 Linux 内核处理数据包过程中的几个关键地方调用 <code>NF_HOOK</code> 函数，拦截数据包来进行处理。</p><p><img src="/images/iptables简介/nf-hooks.png" alt="nf-hooks"></p><blockquote><p>图片来源：<a href="https://wiki.nftables.org/wiki-nftables/index.php/Netfilter_hooks">Netfilter hooks</a></p></blockquote><p>利用 netfilter 框架可实现的功能包括检查、修改、转发、重定向和/或丢弃数据包。</p><ol><li>根据用途的不同，将内核中处理数据包的代码组织成了几个不同的表（table）。</li><li>表由一组的链（chain）组成。</li><li>链中包含一系列规则（rule）。</li><li>规则由匹配条件和相应的执行动作组成（如果条件匹配成功，则执行相应的动作）。</li><li>链中的规则会按顺序的逐一执行，直到某个匹配的动作处理的结果是终止处理或<a href="#预定义的链">预定义的链</a>内的规则都执行完。</li></ol><h3 id="2-1-表"><a href="#2-1-表" class="headerlink" title="2.1 表"></a>2.1 表</h3><p>netfilter 中总共包含五个表：</p><ol><li><strong>raw</strong>：用于标记数据包，让它不被连接跟踪系统跟踪；</li><li><strong>filter</strong>：用于过滤数据包；</li><li><strong>nat</strong>：用来完成<a href="https://en.wikipedia.org/wiki/Network_address_translation">网络地址转换（NAT）</a>功能；</li><li><strong>mangle</strong>：用于修改数据包；</li><li><strong>security</strong>：用于<a href="https://en.wikipedia.org/wiki/Mandatory_access_control">强制访问控制（MAC）</a>网络规则（比如SELinux，<a href="https://lwn.net/Articles/267140/">更多相关信息</a>）。</li></ol><h3 id="2-2-预定义的链"><a href="#2-2-预定义的链" class="headerlink" title="2.2 预定义的链"></a>2.2 预定义的链</h3><p>链的本质其实是 Linux 内核处理数据包的过程中，netfilter 框架嵌入 HOOK 函数的地方。</p><p>netfilter 框架在 Linux 内核处理很多协议（比如：ip，ip6，arp等）的过程中都嵌入了 HOOK 函数，本文只关注 iptables 处理 ip 协议用到的。</p><p>iptables 在每一个嵌入了 HOOK 函数的地方都预定义了一些链：</p><ol><li><strong>PREROUTING</strong>：接收到数据包但是还未判断其目的地是否是本机。</li><li><strong>INPUT</strong>：数据包的目的地是本机但是还未交给协议栈的上层处理。</li><li><strong>OUTPUT</strong>：数据包是由本机发出的。</li><li><strong>FORWARD</strong>：数据包的目的地不是本机的。</li><li><strong>POSTROUTING</strong>：数据包在离开本机之前。</li></ol><p><img src="/images/iptables简介/iptables预定义的链.jpg" alt="iptables预定义的链"></p><p>预定义的链支持设置默认的数据包处理策略。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 将 INPUT 链的默认数据包处理策略设置为 ACCEPT（允许包通过）</span><span class="token function">sudo</span> iptables -P INPUT ACCEPT<span class="token comment"># 将 FORWARD 链的默认数据包处理策略设置为 DROP（丢弃所有的包）</span><span class="token function">sudo</span> iptables -P FORWARD DROP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-表和预定义的链"><a href="#2-3-表和预定义的链" class="headerlink" title="2.3 表和预定义的链"></a>2.3 表和预定义的链</h3><p>根据表的功能和链所在的位置，并不是每个表都需要所有的链。</p><ol><li><p>raw 表</p><p> raw 表用于就是标记数据包，让它不被连接跟踪系统跟踪。</p><ul><li><strong>PREROUTING</strong>：标记收到的所有数据包；</li><li><strong>OUTPUT</strong>：标记本机发出的所有数据包。</li></ul></li><li><p>filter 表</p><p> filter 表用于过滤数据包。</p><ul><li><strong>INPUT</strong>：过滤发给本机的包；</li><li><strong>OUTPUT</strong>：过滤本机发出的包；</li><li><strong>FORWARD</strong>：过滤从本机经过的但不是发给本机的包。</li></ul></li><li><p>nat 表</p><p> nat 表用于完成 NAT 功能。</p><ul><li><strong>PREROUTING</strong>：修改数据包的目的地址，完成 DNAT 功能；</li><li><strong>INPUT</strong>：修改发给本机数据包的源地址，完成 SNAT 功能；</li><li><strong>OUTPUT</strong>：修改本机发出数据包的目的地址，完成 DNAT 功能；</li><li><strong>POSTROUTING</strong>：修改数据包的源地址，完成 SNAT 功能。</li></ul></li><li><p>mangle 表</p><p> mangle 表用于修改数据包。</p><ul><li><strong>PREROUTING</strong>；</li><li><strong>INPUT</strong>；</li><li><strong>OUTPUT</strong>；</li><li><strong>FORWARD</strong>；</li><li><strong>POSTROUTING</strong>。</li></ul></li><li><p>security 表</p><p> security 表用于完成与安全相关的标记功能。</p><ul><li><strong>INPUT</strong>；</li><li><strong>OUTPUT</strong>；</li><li><strong>FORWARD</strong>。</li></ul></li></ol><p><img src="/images/iptables简介/iptables的表和预定义的链.png" alt="iptables的表和预定义的链"></p><h3 id="2-4-自定义的链"><a href="#2-4-自定义的链" class="headerlink" title="2.4 自定义的链"></a>2.4 自定义的链</h3><p>除了使用预定的链外，iptables还支持自定义链。数据包在处理的过程中能够通过 jump 动作跳转到同一个表的另一个链（这个链必须是自定义的，不能是预定于的）上继续处理。</p><p>同时，自定义的链不支持设置默认数据包处理策略，其默认的处理策略是返回父链中继续进行处理。</p><p>在下面的图中，在链 1 中的 规则 3 时匹配成功，跳到链 2 从头开始执行，最后通过链 2 返回到链 1 的规则 4 继续执行。</p><p><img src="/images/iptables简介/iptables自定义的链.jpg" alt="iptables自定义的链"></p><blockquote><p>图片来源：<a href="https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html#USERTABLES">User specified chains</a></p></blockquote><h3 id="2-5-连接状态"><a href="#2-5-连接状态" class="headerlink" title="2.5 连接状态"></a>2.5 连接状态</h3><p>Linux 内核中一个名为 <code>conntrack</code> 的模块提供了连接状态的跟踪功能，可以跟踪各种协议的连接并标记状态。<strong>需要注意的是，连接跟踪中的连接与 TCP/IP 中 TCP 的连接不是同一个概念。</strong></p><p>连接主要有五种状态：</p><ol><li><p><strong>NEW</strong></p><p> 此状态表示数据包是系统看到的某个连接上的第一个数据包。比如，对于 TCP 来说，三次握手收到的一个包的状态就是这个状态。</p><blockquote><p>不管是收到的第一个数据包，还是发出的第一个数据包都都算是第一个。</p><p>不管数据包是否是正常的，只要是第一个数据包都算。比如，对于 TCP 的三次握手来说，正常握手的第一个包中仅包括 SYN 标记，但是如果第一个包中包含了错误的标记（如：SYN，RST），也会算是第一个数据包。</p></blockquote></li><li><p><strong>ESTABLISHED</strong></p><p> 此状态表示系统在通信的双向都看到了流量通信，并且后续的数据包都会是这个状态。只需要一个机器发送一个数据包，并收到想要的应答数据包后，连接就会进入此状态（即使收到的是一个 ICMP 的错误报告）。</p></li><li><p><strong>RELATED</strong></p><p> 此状态表明一个连接和另一个已经处于 <strong>ESTABLISHED</strong> 状态的连接有关时，就会被认为是这个状态。</p><p> 连接进入此状态的前提是已有一个处于 <strong>ESTABLISHED</strong> 状态，<strong>并且 Linux 内核能够理解这个连接</strong>，同时这个连接另外再产生了一个新的连接，这个新的连接的状态就是 <strong>RELATED</strong> 。比如 FTP 的 Data 连接就是根据 FTP 的 Control 连接产生的，所以 FTP 的 Control 连接是 <strong>ESTABLISHED</strong> 状态，FTP 的 Data 连接是 <strong>RELATED</strong> 状态。</p></li><li><p><strong>INVALID</strong></p><p> 此状态表明数据包不能被识别或者它没有任何状态。导致的原因可能是系统内存不足或是 ICMP 的错误报告不能匹配上本地的任何连接。一般而言，推荐丢弃此状态的数据包。</p></li><li><p><strong>UNTRACKED</strong></p><p> 此状态表明数据包被标记为了不跟踪，同时与此连接相关的原本是 <strong>RELATED</strong> 状态的连接也会是此状态。</p></li></ol><p>内核对于每一种网络包，都设置了两个记录点：</p><ol><li>对于发给本机的包，在 <strong>PREROUTING</strong> 调用 <code>ipv4_conntrack_in</code>，创建连接跟踪记录；在 <strong>INPUT</strong> 调用 <code>ipv4_confirm</code>，将这个连接跟踪记录挂在内核的连接跟踪表里面。</li><li>对于本地发出的包，在 <strong>OUTPUT</strong> 调用 <code>ipv4_conntrack_local</code>，创建连接跟踪记录；在 <strong>POSTROUTING</strong> 调用 <code>ipv4_confirm</code>，将这个连接跟踪记录挂在内核的连接跟踪表里面。</li><li><p>对于经过本机的包，在 <strong>PREROUTING</strong> 调用 <code>ipv4_conntrack_in</code>，创建连接跟踪记录；在 <strong>POSTROUTING</strong> 调用 <code>ipv4_confirm</code>，将这个连接跟踪记录挂在内核的连接跟踪表里面。</p><blockquote><p>对于经过本机的 NAT 包，在 <strong>PREROUTING</strong> 调用 <code>ipv4_conntrack_in</code>，创建连接跟踪记录，并调用 <code>nf_nat_ipv4_in</code> 进行地址转换；在 <strong>POSTROUTING</strong> 调用 <code>nf_nat_ipv4_out</code> 进行地址转换，并调用 <code>ipv4_confirm</code>，将这个连接跟踪记录挂在内核的连接跟踪表里面。</p></blockquote></li></ol><blockquote><p>因为有 <strong>filter</strong> 表可能会把包过滤掉，也就是丢弃了，所以才需要两个记录点。</p></blockquote><h2 id="三、iptables-规则的匹配条件"><a href="#三、iptables-规则的匹配条件" class="headerlink" title="三、iptables 规则的匹配条件"></a>三、iptables 规则的匹配条件</h2><p>参考：<a href="https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html#MATCHES">Iptables matches</a>。</p><h2 id="四、iptables-规则的执行动作"><a href="#四、iptables-规则的执行动作" class="headerlink" title="四、iptables 规则的执行动作"></a>四、iptables 规则的执行动作</h2><p>参考：<a href="https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html#TARGETS">Iptables targets and jumps</a>。</p><h2 id="五、常见问题"><a href="#五、常见问题" class="headerlink" title="五、常见问题"></a>五、常见问题</h2><h3 id="1-NAT-能建立多少连接"><a href="#1-NAT-能建立多少连接" class="headerlink" title="1. NAT 能建立多少连接"></a>1. NAT 能建立多少连接</h3><p>DNAT 即外网访问内网的某个服务，是没有端口数目限制的。</p><p>SNAT 即内网访问外网的场景，鉴于 conntrack 是由 <strong>{源 IP，源端口，目标 IP，目标端口}</strong>，hash 后确定的。所以如果内网机器很多，但是访问的是不同的外网，也即目标 IP 和目标端口很多，这样内网可承载的数量就非常大，可不止 65535 个。</p><p>但是如果内网所有的机器，都一定要访问同一个目标 IP 和目标端口，这样源 IP 如果只有一个，这样的情况下，才受 65535 的端口数目限制，根据原理，一种方法就是多个源 IP，另外的方法就是多个 NAT 网关，来分摊不同的内网机器访问。</p><h2 id="六、参考资料"><a href="#六、参考资料" class="headerlink" title="六、参考资料"></a>六、参考资料</h2><ol><li><a href="https://wiki.archlinux.org/title/Iptables">iptables</a></li><li><a href="https://wiki.nftables.org/wiki-nftables/index.php/Configuring_chains">Configuring chains</a></li><li><a href="https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html">Iptables Tutorial 1.2.2</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netfilter </tag>
            
            <tag> iptables </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP中的keepalive机制</title>
      <link href="tcp-zhong-de-keepalive-ji-zhi/"/>
      <url>tcp-zhong-de-keepalive-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、RFC1122"><a href="#一、RFC1122" class="headerlink" title="一、RFC1122"></a>一、RFC1122</h2><p>关于 TCP 中 keepalive 机制的描述在 <a href="https://datatracker.ietf.org/doc/html/rfc1122#page-101">RFC1122 中的 4.2.3.6 小结</a> ，内容不多，总结一下有下面几点：</p><ol><li>TCP 实现中 <strong>可以</strong> 包含 keepalive 这个功能，也可以不包含。</li><li>如果实现了 keepalive 这个功能，那么 <strong>必须</strong> 能为每个 TCP 连接开启或者关闭 keepalive 功能。同时，此功能默认 <strong>必须</strong> 是关闭的。</li><li><strong>必须</strong> 在规定的时间间隔内，既没有收到包含数据包，也没有收到包含 ACK 标记的包时，才能发送 keepalive 的包。这个时间间隔 <strong>必须</strong> 是可配置的，并且默认 <strong>必须</strong> 不能小于两个小时。</li><li>TCP 不能保证没有数据仅有 ACK 标记的包一定会被对端接收到。所以，如果实现了 keepalive 机制，<strong>必须</strong> 不能把任何特定探测失败的连接标记为死链接。</li><li>keepalive 的实现 <strong>应该</strong> 是发送一个不包含数据的 keepalive 包。但是为了与不规范的 TCP 实现兼容，<strong>可以</strong> 配置在 keepalive 包中包含一个垃圾的字节，来避免第 4 点的情况。</li><li>一些 TCP 实现 keepalive 的方式是：发送一个 Seq 编号为 Next-1 （如果是正常的数据发送 Seq 的值应为 Next ），并且可能包含或者不包含一个垃圾字节的包给对端。因为 keepalive 包中的 Seq 值在对端 TCP 的滑动窗口之外（因为已经确认收到了），所以对端会回应一个包含有 ACK 标记的包，并据此来判断对端是否存活。如果对端网络故障或者崩溃，则会回应一个带有 RST 标记的包来重置连接。</li><li>一些不够完善的 TCP 实现可能不能正确的响应 Seq 编号为 Next-1 且不带数据的 keepalive 包，但是却可以响应带有一个字节垃圾信息的包。所以在实现 keepalive 机制时，需要判断这种情况，并据此决定在发送 keepalive 包时，是否要带上一字节的垃圾数据。</li><li>TCP 的 keepalive 机制应该仅用在服务器的程序中，因为如果客户端崩溃，服务器就能及时的释放资源。</li></ol><h2 id="二、相关设置"><a href="#二、相关设置" class="headerlink" title="二、相关设置"></a>二、相关设置</h2><h3 id="1-SO-KEEPALIVE"><a href="#1-SO-KEEPALIVE" class="headerlink" title="1. SO_KEEPALIVE"></a>1. SO_KEEPALIVE</h3><p>默认情况下，新创建出来的套接字的 keepalive 功能都是关闭的。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> keepalive <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token function">setsockopt</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> SOL_SOCKET<span class="token punctuation">,</span> SO_KEEPALIVE<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>keepalive<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>keepalive<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-TCP-KEEPIDLE"><a href="#2-TCP-KEEPIDLE" class="headerlink" title="2. TCP_KEEPIDLE"></a>2. TCP_KEEPIDLE</h3><p>这个选项用于控制经过多久后，既没有收到包含数据包，也没有收到包含 ACK 标记的包时，就发送 keepalive 的包。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> keepidle <span class="token operator">=</span> <span class="token number">7200</span><span class="token punctuation">;</span><span class="token function">setsockopt</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> SOL_TCP<span class="token punctuation">,</span> TCP_KEEPIDLE<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>keepidle<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>keepidle<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>Windows下，代码中的 <code>SOL_TCP</code> 要替换成 <code>IPPROTO_TCP</code>，下同。</p></blockquote><h3 id="3-TCP-KEEPINTVL"><a href="#3-TCP-KEEPINTVL" class="headerlink" title="3. TCP_KEEPINTVL"></a>3. TCP_KEEPINTVL</h3><p>这个选项用于控制一旦开始发送了 keepalive 后，经过多久时间后再发送下一个包。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> keepintvl <span class="token operator">=</span> <span class="token number">75</span><span class="token punctuation">;</span><span class="token function">setsockopt</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> SOL_TCP<span class="token punctuation">,</span> TCP_KEEPINTVL<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>keepintvl<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>keepintvl<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="4-TCP-KEEPCNT"><a href="#4-TCP-KEEPCNT" class="headerlink" title="4. TCP_KEEPCNT"></a>4. TCP_KEEPCNT</h3><p>这个选项用于控制在经过发送了多少个 keepalive 包但是都没有收到回复后，可以认为连接已经断开了。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> keepcnt <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span><span class="token function">setsockopt</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> SOL_TCP<span class="token punctuation">,</span> TCP_KEEPCNT<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>keepcnt<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>keepcnt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="5-默认值"><a href="#5-默认值" class="headerlink" title="5. 默认值"></a>5. 默认值</h3><p>Linux下，系统的默认值可以通过命令来查看：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /proc/sys/net/ipv4/tcp_keepalive_time <span class="token comment">#7200</span><span class="token function">cat</span> /proc/sys/net/ipv4/tcp_keepalive_intvl <span class="token comment">#75</span><span class="token function">cat</span> /proc/sys/net/ipv4/tcp_keepalive_probes <span class="token comment">#9</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>上面参数的意义是：在未收到包含数据或 ACK 标志的包 7200 秒后，开始发送 keepalive 包，并每隔 75 秒重发一次，如果连发 9 次都没有响应，就认为网络已断开。但是如果 9 次内的某次收到了 keepalive 包对应的 ACK 包，则又会在未收到包含数据或ACK 标志的包 7200 秒后重新开始发 keepalive 包。</p></blockquote><p>Windows下，不同系统版本默认值不同，一般是7200秒，1秒，10次。具体的可以参考：<a href="https://docs.microsoft.com/en-us/windows/win32/winsock/sio-keepalive-vals#remarks">https://docs.microsoft.com/en-us/windows/win32/winsock/sio-keepalive-vals#remarks</a>。</p><h2 id="三、平台实现"><a href="#三、平台实现" class="headerlink" title="三、平台实现"></a>三、平台实现</h2><h3 id="1-测试代码"><a href="#1-测试代码" class="headerlink" title="1. 测试代码"></a>1. 测试代码</h3><p>写一段代码简单的测试一下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// file: keepalive.c</span><span class="token comment">// gcc -o keepalive keepalive.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">_WIN32</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;WinSock2.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;Ws2tcpip.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">comment</span><span class="token punctuation">(</span>lib<span class="token punctuation">,</span> </span><span class="token string">"ws2_32.lib"</span><span class="token expression"><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">socklen_t <span class="token keyword">int</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">SOL_TCP IPPROTO_TCP</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netinet/in.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netinet/tcp.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">SOCKET <span class="token keyword">int</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">IP </span><span class="token string">"192.168.104.106"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">PORT <span class="token number">9876</span></span></span><span class="token keyword">void</span> <span class="token function">print_sock_opt</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">,</span> SOCKET sockfd<span class="token punctuation">,</span> <span class="token keyword">int</span> level<span class="token punctuation">,</span> <span class="token keyword">int</span> optname<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> optval <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    socklen_t optlen <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>optval<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getsockopt</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> level<span class="token punctuation">,</span> optname<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>optval<span class="token punctuation">,</span> <span class="token operator">&amp;</span>optlen<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"getsockopt failed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s: %d\n"</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> optval<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">print_sock_keepalive</span><span class="token punctuation">(</span>SOCKET sockfd<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">print_sock_opt</span><span class="token punctuation">(</span><span class="token string">"keepalive"</span><span class="token punctuation">,</span> sockfd<span class="token punctuation">,</span> SOL_SOCKET<span class="token punctuation">,</span> SO_KEEPALIVE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print_sock_opt</span><span class="token punctuation">(</span><span class="token string">"keepidle"</span><span class="token punctuation">,</span> sockfd<span class="token punctuation">,</span> SOL_TCP<span class="token punctuation">,</span> TCP_KEEPIDLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print_sock_opt</span><span class="token punctuation">(</span><span class="token string">"keepintvl"</span><span class="token punctuation">,</span> sockfd<span class="token punctuation">,</span> SOL_TCP<span class="token punctuation">,</span> TCP_KEEPINTVL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print_sock_opt</span><span class="token punctuation">(</span><span class="token string">"keepcnt"</span><span class="token punctuation">,</span> sockfd<span class="token punctuation">,</span> SOL_TCP<span class="token punctuation">,</span> TCP_KEEPCNT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">set_sock_opt</span><span class="token punctuation">(</span>SOCKET sockfd<span class="token punctuation">,</span> <span class="token keyword">int</span> level<span class="token punctuation">,</span> <span class="token keyword">int</span> optname<span class="token punctuation">,</span> <span class="token keyword">int</span> optval<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">setsockopt</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> level<span class="token punctuation">,</span> optname<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>optval<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>optval<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"setsockopt failed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">set_sock_keepalive</span><span class="token punctuation">(</span>SOCKET sockfd<span class="token punctuation">,</span> <span class="token keyword">int</span> keepalive<span class="token punctuation">,</span> <span class="token keyword">int</span> idle<span class="token punctuation">,</span> <span class="token keyword">int</span> intvl<span class="token punctuation">,</span> <span class="token keyword">int</span> cnt<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">set_sock_opt</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> SOL_SOCKET<span class="token punctuation">,</span> SO_KEEPALIVE<span class="token punctuation">,</span> keepalive<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">set_sock_opt</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> SOL_TCP<span class="token punctuation">,</span> TCP_KEEPIDLE<span class="token punctuation">,</span> idle<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">set_sock_opt</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> SOL_TCP<span class="token punctuation">,</span> TCP_KEEPINTVL<span class="token punctuation">,</span> intvl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">set_sock_opt</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> SOL_TCP<span class="token punctuation">,</span> TCP_KEEPCNT<span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">_WIN32</span></span>    WSADATA wsaData<span class="token punctuation">;</span>    <span class="token function">WSAStartup</span><span class="token punctuation">(</span><span class="token function">MAKEWORD</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>wsaData<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    SOCKET sockfd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> addr<span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>addr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    addr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>    addr<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>PORT<span class="token punctuation">)</span><span class="token punctuation">;</span>    addr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">inet_addr</span><span class="token punctuation">(</span>IP<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">connect</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>addr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"connect failed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">print_sock_keepalive</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">set_sock_keepalive</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print_sock_keepalive</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">recv</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        buf<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"receive: %s\n"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">send</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-服务器"><a href="#2-服务器" class="headerlink" title="2. 服务器"></a>2. 服务器</h3><p>在 Linux 上安装软件 <code>socat</code>，并运行下面的命令来监听端口9876：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">socat tcp-listen:9876,reuseaddr -<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>服务器的 IP 地址为：192.168.104.106。</p></blockquote><h3 id="3-Linux-下-keepalive-的实现"><a href="#3-Linux-下-keepalive-的实现" class="headerlink" title="3. Linux 下 keepalive 的实现"></a>3. Linux 下 keepalive 的实现</h3><blockquote><p>Linux 的 IP 地址为：192.168.102.63<br>Linux 的内核为：4.15.0-147-generic</p></blockquote><p>首先安装 tcpdump 并运行下面的命令来抓包：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> tcpdump -pni enp0s31f6 -vvv -S <span class="token string">"tcp port 9876"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>其中 <code>enp0s31f6</code> 是网卡的名字，<code>9876</code> 为端口号。</p></blockquote><p>然后运行测试代码编译出来的程序，tcpdump 输出（删除了一些不必要的信息）：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">14:21:17.008786 192.168.102.63.34882 &gt; 192.168.104.106.9876: Flags [S],  seq 3365757301, length 014:21:17.009112 192.168.104.106.9876 &gt; 192.168.102.63.34882: Flags [S.], seq 3674364464, ack 3365757302, length 014:21:17.009152 192.168.102.63.34882 &gt; 192.168.104.106.9876: Flags [.],  seq 3365757302, ack 3674364465, length 014:21:27.142639 192.168.102.63.34882 &gt; 192.168.104.106.9876: Flags [.],  seq 3365757301, ack 3674364465, length 014:21:27.142904 192.168.104.106.9876 &gt; 192.168.102.63.34882: Flags [.],  seq 3674364465, ack 3365757302, length 014:21:37.382671 192.168.102.63.34882 &gt; 192.168.104.106.9876: Flags [.],  seq 3365757301, ack 3674364465, length 014:21:37.383214 192.168.104.106.9876 &gt; 192.168.102.63.34882: Flags [.],  seq 3674364465, ack 3365757302, length 014:21:47.622639 192.168.102.63.34882 &gt; 192.168.104.106.9876: Flags [.],  seq 3365757301, ack 3674364465, length 014:21:47.623224 192.168.104.106.9876 &gt; 192.168.102.63.34882: Flags [.],  seq 3674364465, ack 3365757302, length 014:21:50.787206 192.168.102.63.34882 &gt; 192.168.104.106.9876: Flags [F.], seq 3365757302, ack 3674364465, length 014:21:50.791349 192.168.104.106.9876 &gt; 192.168.102.63.34882: Flags [.],  seq 3674364465, ack 3365757303, length 014:21:51.288252 192.168.104.106.9876 &gt; 192.168.102.63.34882: Flags [F.], seq 3674364465, ack 3365757303, length 014:21:51.288293 192.168.102.63.34882 &gt; 192.168.104.106.9876: Flags [.],  seq 3365757303, ack 3674364466, length 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从输出中可以看出：</p><ol><li>在 TCP 三次握手成功后的 10 秒后，开始发送 keepalive 包。</li><li>Linux 发出的 keepalive 包中，Seq 的值确实是 Next-1 ，且 keepalive 包中并未包含有一个字节的垃圾数据。</li></ol><h3 id="4-Windows"><a href="#4-Windows" class="headerlink" title="4. Windows"></a>4. Windows</h3><blockquote><p>Windows 的 IP 地址为：192.168.104.134<br>Windows 的版本为：Version 21H2(OS Build 22000.51)</p></blockquote><p>首先安装 <a href="https://www.wireshark.org/">wireshark</a> 并使用下面的条件来嗅探网络包：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">tcp.port == 9876<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后使用 VS2017 编译并运行测试代码， wireshark 捕获到：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">10.902771 192.168.104.134 192.168.104.106 2389 → 9876 [SYN]      Seq=0 Len=010.903375 192.168.104.106 192.168.104.134 9876 → 2389 [SYN, ACK] Seq=0 Ack=1 Len=010.903458 192.168.104.134 192.168.104.106 2389 → 9876 [ACK]      Seq=1 Ack=1 Len=020.906729 192.168.104.134 192.168.104.106 2389 → 9876 [ACK]      Seq=0 Ack=1 Len=120.907444 192.168.104.106 192.168.104.134 9876 → 2389 [ACK]      Seq=1 Ack=1 Len=030.907197 192.168.104.134 192.168.104.106 2389 → 9876 [ACK]      Seq=0 Ack=1 Len=130.907740 192.168.104.106 192.168.104.134 9876 → 2389 [ACK]      Seq=1 Ack=1 Len=040.914386 192.168.104.134 192.168.104.106 2389 → 9876 [ACK]      Seq=0 Ack=1 Len=140.915088 192.168.104.106 192.168.104.134 9876 → 2389 [ACK]      Seq=1 Ack=1 Len=042.105023 192.168.104.134 192.168.104.106 2389 → 9876 [RST, ACK] Seq=1 Ack=1 Len=0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从输出中可以看出：</p><ol><li>在 TCP 三次握手成功后的 10 秒后，开始发送 keepalive 包。</li><li>Windows 发出的 keepalive 包中，Seq 的值确实是 Next-1 ，但 keepalive 包中包含有一个字节的垃圾数据。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> keepalive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结合Linux内核源码分析TCP协议状态机</title>
      <link href="jie-he-linux-nei-he-yuan-ma-fen-xi-tcp-xie-yi-zhuang-tai-ji/"/>
      <url>jie-he-linux-nei-he-yuan-ma-fen-xi-tcp-xie-yi-zhuang-tai-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="一、准备环境"><a href="#一、准备环境" class="headerlink" title="一、准备环境"></a>一、准备环境</h2><blockquote><p>环境：Ubuntu18.04</p><p>编辑器：VSCode</p><p>内核版本：<a href="https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.19.194.tar.xz">linux-4.19.194</a></p></blockquote><h3 id="1-下载编译内核源码"><a href="#1-下载编译内核源码" class="headerlink" title="1. 下载编译内核源码"></a>1. 下载编译内核源码</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.19.194.tar.xz<span class="token function">tar</span> xf linux-4.19.194.tar.xz<span class="token builtin class-name">cd</span> linux-4.19.194<span class="token comment"># 想要编译什么架构就指定什么值，所有合法的值在源码的arch文件夹下必须存在同名的文件夹</span><span class="token builtin class-name">export</span> <span class="token assign-left variable">ARCH</span><span class="token operator">=</span>x86 <span class="token comment">#x86架构</span><span class="token comment"># make命令的参数可以通过 make help 获取</span><span class="token function">make</span> x86_64_defconfig <span class="token comment"># 生成64位平台的默认配置</span><span class="token function">make</span> <span class="token comment"># 编译内核</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>如果想要下载与当前正在运行的 Ubuntu 内核对应的源代码，可以使用命令 <code>apt-get source linux-image-unsigned-$(uname -r)</code> 来获取。</p><p><a href="https://wiki.ubuntu.com/Kernel/BuildYourOwnKernel">BuildYourOwnKernel</a></p></blockquote><h3 id="2-分析编译时的宏定义"><a href="#2-分析编译时的宏定义" class="headerlink" title="2. 分析编译时的宏定义"></a>2. 分析编译时的宏定义</h3><p>在第一步 <a href="#1-下载编译内核源码">下载编译内核源码</a> 成功后，源代码目录下会生成一个名为 <code>.config</code> 的文件，该文件指明了编译内核时所用到的设置。可以使用下面的命令来生成编译内核代码时使用的宏定义列表：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">grep</span> <span class="token string">"^CONFIG_.*"</span> .config <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">"s/=y/=1/g"</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">"s/=m/_MODULE=1/g"</span> <span class="token operator">|</span> <span class="token function">cat</span> - <span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token builtin class-name">echo</span> __KERNEL__<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>如果想要生成与当前正在运行的 Ubuntu 内核对应的配置，使用下面的命令：</p><p><code>cat /boot/config-$(uname -r) | grep "^CONFIG_.*" | sed "s/=y/=1/g" | sed "s/=m/_MODULE=1/g" | cat - &lt;(echo __KERNEL__)</code></p><p>最后添加的宏 <code>__KERNEL__</code> 来自源代码根目录下 <code>Makefile</code> 文件的443行。</p></blockquote><p>将上面命令生成的结果配置到vscode中，可以更加方面有效的查看内核代码。</p><h2 id="二、确定套接字调用对应的内核实现函数"><a href="#二、确定套接字调用对应的内核实现函数" class="headerlink" title="二、确定套接字调用对应的内核实现函数"></a>二、确定套接字调用对应的内核实现函数</h2><blockquote><p>下面以创建套接字的函数 <code>socket</code> 为例。</p></blockquote><h3 id="1-确定socket调用的syscall号"><a href="#1-确定socket调用的syscall号" class="headerlink" title="1. 确定socket调用的syscall号"></a>1. 确定socket调用的syscall号</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// file: main.c</span><span class="token comment">// compile: gcc -ggdb main.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> s<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>GDB反汇编调试socket调用</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">0x7ffff7b04d50 &lt;socket&gt;         mov    $0x29,%eax0x7ffff7b04d55 &lt;socket+5&gt;       syscall<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以发现socket调用的syscall号为0x29（即41）。</p><blockquote><p>命令 <code>man syscall</code> 可以获取更多关于 syscall 调用的信息。</p></blockquote><h3 id="2-确定socket对应的内核实现"><a href="#2-确定socket对应的内核实现" class="headerlink" title="2. 确定socket对应的内核实现"></a>2. 确定socket对应的内核实现</h3><p>系统调用表定义在 <code>arch/x86/entry/syscall_64.c</code> 文件中：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// file: arch/x86/entry/syscall_64.c</span>asmlinkage <span class="token keyword">const</span> sys_call_ptr_t sys_call_table<span class="token punctuation">[</span>__NR_syscall_max<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token comment">/*     * Smells like a compiler bug -- it doesn't work     * when the &amp; below is removed.     */</span>    <span class="token punctuation">[</span><span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> __NR_syscall_max<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>sys_ni_syscall<span class="token punctuation">,</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;asm/syscalls_64.h&gt;</span></span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码中 <code>#include &lt;asm/syscalls_64.h&gt;</code> 对应的文件是 <code>arch/x86/include/generated/asm/syscalls_64.h</code> ：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// file: arch/x86/include/generated/asm/syscalls_64.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_X86</span></span><span class="token function">__SYSCALL_64</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">,</span> __x64_sys_socket<span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span> <span class="token comment">/* CONFIG_UML */</span></span><span class="token function">__SYSCALL_64</span><span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">,</span> sys_socket<span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>arch/x86/include/generated/asm/syscalls_64.h</code> 文件由 <code>arch/x86/entry/syscalls/syscall_64.tbl</code> 文件生成而来。</p></blockquote><p>根据 <a href="#2-分析编译时的宏定义">分析编译时的宏定义</a> 的结果，可以确定宏 <code>CONFIG_X86</code> 是定义了的，所以调用号41对应的实现为 <code>__x64_sys_socket</code> 。</p><p>在源码中却找不到 <code>__x64_sys_socket</code> 的定义，但能在文件 <code>net/socket.c</code> 中找到 <code>__sys_socket</code> 函数的定义：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// file: net/socket.c</span><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>socket<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> family<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> protocol<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">__sys_socket</span><span class="token punctuation">(</span>family<span class="token punctuation">,</span> type<span class="token punctuation">,</span> protocol<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分析宏 <code>SYSCALL_DEFINE3</code> 的定义：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// file: include/linux/syscalls.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">SYSCALL_DEFINEx</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> _</span><span class="token punctuation">##</span><span class="token expression">name<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">SYSCALL_DEFINEx</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> sname<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>              </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token function">SYSCALL_METADATA</span><span class="token punctuation">(</span>sname<span class="token punctuation">,</span> x<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span>         </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token function">__SYSCALL_DEFINEx</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> sname<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着分析宏 <code>__SYSCALL_DEFINEx</code> 的定义：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// file: arch/x86/include/asm/syscall_wrapper.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">__SYSCALL_DEFINEx</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>                 </span><span class="token punctuation">\</span>    <span class="token expression">asmlinkage <span class="token keyword">long</span> __x64_sys</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span>regs<span class="token punctuation">)</span><span class="token punctuation">;</span>    </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token function">ALLOW_ERROR_INJECTION</span><span class="token punctuation">(</span>__x64_sys</span><span class="token punctuation">##</span><span class="token expression">name<span class="token punctuation">,</span> ERRNO<span class="token punctuation">)</span><span class="token punctuation">;</span>          </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">static</span> <span class="token keyword">long</span> __se_sys</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_LONG<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">long</span> __do_sys</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_DECL<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token punctuation">\</span>    <span class="token expression">asmlinkage <span class="token keyword">long</span> __x64_sys</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span>regs<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">{</span>                               </span><span class="token punctuation">\</span>        <span class="token expression"><span class="token keyword">return</span> __se_sys</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">SC_X86_64_REGS_TO_ARGS</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">}</span>                               </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token function">__IA32_SYS_STUBx</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> name<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span>              </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">static</span> <span class="token keyword">long</span> __se_sys</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_LONG<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span>  </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">{</span>                               </span><span class="token punctuation">\</span>        <span class="token expression"><span class="token keyword">long</span> ret <span class="token operator">=</span> __do_sys</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_CAST<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token punctuation">\</span>        <span class="token expression"><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_TEST<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">;</span>             </span><span class="token punctuation">\</span>        <span class="token expression"><span class="token function">__PROTECT</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> ret<span class="token punctuation">,</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_ARGS<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   </span><span class="token punctuation">\</span>        <span class="token expression"><span class="token keyword">return</span> ret<span class="token punctuation">;</span>                     </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">}</span>                               </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">long</span> __do_sys</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_DECL<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以确定，宏 <code>SYSCALL_DEFINE3(socket, int, family, int, type, int, protocol)</code> 展开后，定义了 <code>__x64_sys_socket</code>。</p><p>即 <code>__x64_sys_socket</code> 函数的本体就是 <code>net/socket.c</code> 文件中的 <code>__sys_socket</code> 函数。</p><h2 id="三、分析TCP协议状态机"><a href="#三、分析TCP协议状态机" class="headerlink" title="三、分析TCP协议状态机"></a>三、分析TCP协议状态机</h2><h3 id="1-socket"><a href="#1-socket" class="headerlink" title="1. socket"></a>1. socket</h3><p>调用流程如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">__sys_socket                // net/socket.c:1355    |- sock_create          // net/socket.c:1346        |- __sock_create    // net/socket.c:1316<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>socket</code> 函数最后会调用函数 <code>__sock_create</code> ，其主要代码如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">__sock_create</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">net</span> <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">int</span> family<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span> protocol<span class="token punctuation">,</span>            <span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span><span class="token operator">*</span>res<span class="token punctuation">,</span> <span class="token keyword">int</span> kern<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span>sock<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">net_proto_family</span> <span class="token operator">*</span>pf<span class="token punctuation">;</span>    sock <span class="token operator">=</span> <span class="token function">sock_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pf <span class="token operator">=</span> <span class="token function">rcu_dereference</span><span class="token punctuation">(</span>net_families<span class="token punctuation">[</span>family<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pf<span class="token operator">-&gt;</span><span class="token function">create</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> sock<span class="token punctuation">,</span> protocol<span class="token punctuation">,</span> kern<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>sock_alloc()</code> 函数分配套接字的一些资源后，再从 <code>net_families</code> 取出网络协议簇对应的处理函数，最后创建对应网络协议簇的套接字。</p><p><code>net_families</code> 是一个数组，里面存放了不同的协议簇对应的处理函数。通过函数 <code>sock_register</code> 可以注册到此数组中。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// file: net/ipv4/af_inet.c</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">net_proto_family</span> inet_family_ops <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span>family <span class="token operator">=</span> PF_INET<span class="token punctuation">,</span>    <span class="token punctuation">.</span>create <span class="token operator">=</span> inet_create<span class="token punctuation">,</span>    <span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">inet_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token function">sock_register</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>inet_family_ops<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于 TCP/IPv4 来说，上面代码中的 <code>err = pf-&gt;create(net, sock, protocol, kern)</code> 调用的其实是 <code>inet_create(net, sock, protocol, kern)</code> 。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">inet_create                             // net/ipv4/af_inet.c:1075    |- sock_init_data                   // net/core/sock.c:347        |- sk-&gt;sk_state = TCP_CLOSE     // net/core/sock.c:2790<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>综上，调用 <code>socket()</code> 函数后，套接字的默认状态为 <code>TCP_CLOSE</code> 。</p><h3 id="2-listen"><a href="#2-listen" class="headerlink" title="2. listen"></a>2. listen</h3><p>调用流程如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">__sys_listen                    // net/socket.c:1525    |- sock-&gt;ops-&gt;listen()      // net/socket.c:1516<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对于 TCP/IPv4 来说，上面代码中的 <code>sock-&gt;ops-&gt;listen()</code> 调用的其实是 <code>net/ipv4/af_inet.c</code> 文件中的 <code>inet_listen</code> 函数。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">inet_listen                                     // net/ipv4/af_inet.c:991    |- inet_csk_listen_start                    // net/ipv4/af_inet.c:229        |- inet_sk_state_store(sk, TCP_LISTEN)  // net/ipv4/inet_connection_sock.c:923<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>综上，调用 <code>listen()</code> 函数后，套接字的状态由 <code>TCP_CLOSE</code> 变为 <code>TCP_LISTEN</code> 。</p><h3 id="3-connect"><a href="#3-connect" class="headerlink" title="3. connect"></a>3. connect</h3><p>调用流程如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">__sys_connect                // net/socket.c:1674    |- sock-&gt;ops-&gt;connect()  // net/socket.c:1663<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>同理，对于 TCP/IPv4 来说，上面代码中的 <code>sock-&gt;ops-&gt;connect()</code> 调用的其实是 <code>net/ipv4/af_inet.c</code> 文件中的 <code>inet_stream_connect</code> 函数。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">inet_stream_connect                 // net/ipv4/af_inet.c:985    |- __inet_stream_connect        // net/ipv4/af_inet.c:719        |- sk-&gt;sk_prot-&gt;connect()   // net/ipv4/af_inet.c:655<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面代码中的 <code>sk-&gt;sk_prot-&gt;connect()</code> 调用的其实是 <code>net/ipv4/tcp_ipv4.c</code> 文件中的 <code>tcp_v4_connect</code> 函数。</p><h4 id="1-发送SYN"><a href="#1-发送SYN" class="headerlink" title="1. 发送SYN"></a>1. 发送SYN</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">tcp_v4_connect                                      // net/ipv4/tcp_ipv4.c:2460    |- tcp_set_state(sk, TCP_SYN_SENT)              // net/ipv4/tcp_ipv4.c:280    |- tcp_connect                                  // net/ipv4/tcp_ipv4.c:318        |- tcp_transmit_skb                         // net/ipv4/tcp_output.c:3529            |- __tcp_transmit_skb                   // net/ipv4/tcp_output.c:1164                |- icsk-&gt;icsk_af_ops-&gt;queue_xmit()  // net/ipv4/tcp_output.c:1148<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>tcp_v4_connect</code> 函数先将套接字的状态设置为 <code>TCP_SYN_SENT</code> ，然后再调用 <code>tcp_connect</code> 发送实际的SYN包。</p><p>在函数 <code>__tcp_transmit_skb</code> 中构建网络包的TCP头。构建好后，调用 <code>icsk-&gt;icsk_af_ops-&gt;queue_xmit()</code> 发送TCP包，而函数 <code>icsk-&gt;icsk_af_ops-&gt;queue_xmit()</code> 实际就是 <code>include/net/ip.h</code> 文件中的 <code>ip_queue_xmit</code> 函数。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">ip_queue_xmit                                   // net/ipv4/tcp_ipv4.c:1931    |- __ip_queue_xmit                          // include/net/ip.h:197        |- skb_dst_set_noref(skb, &amp;rt-&gt;dst)     // net/ipv4/ip_output.c:473        |- ip_local_out                         // net/ipv4/ip_output.c:506<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>首先在函数 <code>__ip_queue_xmit</code> 中调用 <code>skb_dst_set_noref(skb, &amp;rt-&gt;dst)</code> 设置发送的目标，然后构建 IP 头并调用函数 <code>ip_local_out</code> 将包含有 SYN 标志的 TCP 包发送出去。</p><h4 id="2-接收到SYN和ACK，并回复ACK"><a href="#2-接收到SYN和ACK，并回复ACK" class="headerlink" title="2. 接收到SYN和ACK，并回复ACK"></a>2. 接收到SYN和ACK，并回复ACK</h4><p>当 IP 层接收到 TCPv4 的包时，会调用函数 <code>tcp_v4_rcv</code> 来处理。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">tcp_v4_rcv                                                  // net/ipv4/af_inet.c:1684    |- tcp_v4_do_rcv                                        // net/ipv4/tcp_ipv4.c:1832        |- tcp_rcv_state_process                            // net/ipv4/tcp_ipv4.c:1569            |- tcp_rcv_synsent_state_process                // net/ipv4/tcp_input.c:6065                |- tcp_finish_connect                       // net/ipv4/tcp_input.c:5898                    |- tcp_set_state(sk, TCP_ESTABLISHED)   // net/ipv4/tcp_input.c:5695                |- tcp_send_ack                             // net/ipv4/tcp_input.c:5928<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>tcp_rcv_synsent_state_process</code> 中，先将套接字的状态设置为 <code>TCP_ESTABLISHED</code> ，然后再调用 <code>tcp_send_ack</code> 发送 ACK 完成 TCP 的三次握手。</p><p>综上，调用 <code>connect()</code> 函数后，套接字的状态由 <code>TCP_CLOSE</code> 变为 <code>TCP_SYN_SENT</code> ，在成功收到 ACK 后，状态再变为 <code>TCP_ESTABLISHED</code> 。</p><h3 id="4-accept"><a href="#4-accept" class="headerlink" title="4. accept"></a>4. accept</h3><p>调用流程如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">__sys_accept4                               // net/socket.c:1630    |- sock-&gt;ops-&gt;accept(sock, newsock)     // net/socket.c:1589<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对于 TCP/IPv4 来说， <code>sock-&gt;ops-&gt;accept()</code> 实际调用的是 <code>net/ipv4/af_inet.c</code> 文件中的 <code>inet_accept</code> 。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">inet_accept                     // net/ipv4/af_inet.c:987    |- sk1-&gt;sk_prot-&gt;accept()   // net/ipv4/af_inet.c:734<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对于 TCP/IPv4 来说， <code>sk1-&gt;sk_prot-&gt;accept()</code> 实际调用的是 <code>net/ipv4/inet_connection_sock.c</code> 文件中的 <code>inet_csk_accept</code> 。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span><span class="token function">inet_csk_accept</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>err<span class="token punctuation">,</span> bool kern<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">reqsk_queue_empty</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> timeo <span class="token operator">=</span> <span class="token function">sock_rcvtimeo</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> flags <span class="token operator">&amp;</span> O_NONBLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* If this is a non blocking socket don't sleep */</span>        error <span class="token operator">=</span> <span class="token operator">-</span>EAGAIN<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timeo<span class="token punctuation">)</span>            <span class="token keyword">goto</span> out_err<span class="token punctuation">;</span>        <span class="token function">inet_csk_wait_for_connect</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> timeo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    req <span class="token operator">=</span> <span class="token function">reqsk_queue_remove</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> sk<span class="token punctuation">)</span><span class="token punctuation">;</span>    newsk <span class="token operator">=</span> req<span class="token operator">-&gt;</span>sk<span class="token punctuation">;</span>    <span class="token keyword">return</span> newsk<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>inet_csk_accept</code> 首先检查监听套接字上的连接队列是否为空，为空且设置了 <code>O_NONBLOCK</code> 标志的话就返回错误 <code>EAGAIN</code> ，否则就等待直到有连接到来。</p><h4 id="1-接收到SYN，发送SYN和ACK"><a href="#1-接收到SYN，发送SYN和ACK" class="headerlink" title="1. 接收到SYN，发送SYN和ACK"></a>1. 接收到SYN，发送SYN和ACK</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">tcp_v4_rcv                                          // net/ipv4/af_inet.c:1684    |- tcp_v4_do_rcv                                // net/ipv4/tcp_ipv4.c:1822        |- tcp_rcv_state_process                    // net/ipv4/tcp_ipv4.c:1569            |- icsk-&gt;icsk_af_ops-&gt;conn_request()    // net/ipv4/tcp_input.c:6051<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>对于 TCP/IPv4 来说，调用 <code>icsk-&gt;icsk_af_ops-&gt;conn_request()</code> 其实是调用 <code>net/ipv4/tcp_ipv4.c</code> 文件中的 <code>tcp_v4_conn_request</code>：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">tcp_v4_conn_request                                 // net/ipv4/tcp_ipv4.c:1935    |- tcp_conn_request                             // net/ipv4/tcp_ipv4.c:1397        |- inet_reqsk_alloc                         // net/ipv4/tcp_input.c:6461            |- ireq-&gt;ireq_state = TCP_NEW_SYN_RECV  // net/ipv4/tcp_input.c:6374        |- af_ops-&gt;send_synack()                    // net/ipv4/tcp_input.c:6556<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在连接请求处理函数 <code>tcp_conn_request</code> 中，首先把新分配的套接字的 <code>request_sock</code> 设置为 <code>TCP_NEW_SYN_RECV</code> 状态。然后调用 <code>af_ops-&gt;send_synack()</code> 来发送 SYN 和 ACK 。对于 TCP/IPv4 来说，调用 <code>af_ops-&gt;send_synack()</code> 其实是调用 <code>net/ipv4/tcp_ipv4.c</code> 文件中的 <code>tcp_v4_send_synack</code> 。而函数 <code>tcp_v4_send_synack</code> 做的也确实是发送一个带有 SYN 和 ACK 标志的包。</p><h4 id="2-接收到ACK"><a href="#2-接收到ACK" class="headerlink" title="2. 接收到ACK"></a>2. 接收到ACK</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">tcp_v4_rcv                                              // net/ipv4/af_inet.c:1684    |- tcp_check_req                                    // net/ipv4/tcp_ipv4.c:1773        |- inet_csk(sk)-&gt;icsk_af_ops-&gt;syn_recv_sock()   // net/ipv4/tcp_minisocks.c:789        |- inet_csk_complete_hashdance                  // net/ipv4/tcp_minisocks.c:797    |- tcp_child_process                                // net/ipv4/tcp_ipv4.c:1792<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>对于 TCP/IPv4 来说，调用 <code>inet_csk(sk)-&gt;icsk_af_ops-&gt;syn_recv_sock()</code> 其实是调用 <code>net/ipv4/tcp_ipv4.c</code> 文件中的 <code>tcp_v4_syn_recv_sock</code>：</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">tcp_v4_syn_recv_sock                                    // net/ipv4/tcp_ipv4.c:1936    |- tcp_create_openreq_child                         // net/ipv4/tcp_ipv4.c:1429        |- inet_csk_clone_lock                          // net/ipv4/tcp_minisocks.c:452            |- inet_sk_set_state(newsk, TCP_SYN_RECV)   // net/ipv4/inet_connection_sock.c:829<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 需要注意的是，新创建的套接字的状态为 <code>TCP_SYN_RECV</code> 。</p></li><li><p>函数 <code>inet_csk_complete_hashdance</code> 主要做的是将请求控制块从未完成连接队列中删除，加入到已完成连接队列中：</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">inet_csk_complete_hashdance                 // net/ipv4/tcp_minisocks.c:797    |- inet_csk_reqsk_queue_drop            // net/ipv4/inet_connection_sock.c:992        |- reqsk_queue_unlink               // net/ipv4/inet_connection_sock.c:703    |- inet_csk_reqsk_queue_add             // net/ipv4/inet_connection_sock.c:994<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>函数 <code>tcp_child_process</code> 进一步对新创建的套接字进行处理并把状态更新为 <code>TCP_ESTABLISHED</code> ：</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">tcp_child_process                               // net/ipv4/tcp_ipv4.c:1792    |- tcp_rcv_state_process                    // net/ipv4/tcp_minisocks.c:851        |- tcp_set_state(sk, TCP_ESTABLISHED)   // net/ipv4/tcp_input.c:6132<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="5-close"><a href="#5-close" class="headerlink" title="5. close"></a>5. close</h3><h4 id="1-发送FIN"><a href="#1-发送FIN" class="headerlink" title="1. 发送FIN"></a>1. 发送FIN</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">tcp_close                                               // net/ipv4/tcp_ipv4.c:2458    |- tcp_close_state                                  // net/ipv4/tcp.c:2393        |- tcp_set_state(sk, ns)                        // net/ipv4/tcp.c:2294    |- tcp_send_fin                                     // net/ipv4/tcp.c:2423        |- TCP_SKB_CB(tskb)-&gt;tcp_flags |= TCPHDR_FIN    // net/ipv4/tcp_output.c:3087    |- sk_stream_wait_close                             // net/ipv4/tcp.c:2426<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于状态是 <code>TCP_ESTABLISHED</code> 的套接字，函数 <code>tcp_close_state</code> 会把套接字的状态更新为 <code>TCP_FIN_WAIT1</code> 。 <code>tcp_send_fin</code> 函数则发送带有 FIN 标记的包给对方。</p><h4 id="2-接收ACK"><a href="#2-接收ACK" class="headerlink" title="2. 接收ACK"></a>2. 接收ACK</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">tcp_v4_rcv                                              // net/ipv4/af_inet.c:1684    |- tcp_v4_do_rcv                                    // net/ipv4/tcp_ipv4.c:1832        |- tcp_rcv_state_process                        // net/ipv4/tcp_ipv4.c:1569            |- tcp_set_state(sk, TCP_FIN_WAIT2)         // net/ipv4/tcp_input.c:6175<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-等待FIN并发送ACK"><a href="#3-等待FIN并发送ACK" class="headerlink" title="3. 等待FIN并发送ACK"></a>3. 等待FIN并发送ACK</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">tcp_v4_rcv                                                      // net/ipv4/af_inet.c:1684    |- tcp_v4_do_rcv                                            // net/ipv4/tcp_ipv4.c:1832        |- tcp_rcv_state_process                                // net/ipv4/tcp_ipv4.c:1569            |- tcp_data_queue                                   // net/ipv4/tcp_input.c:6262                |- tcp_fin                                      // net/ipv4/tcp_input.c:4756                    |- tcp_send_ack(sk)                         // net/ipv4/tcp_input.c:4139                    |- tcp_time_wait(TCP_TIME_WAIT)             // net/ipv4/tcp_input.c:4140                        |- inet_twsk_alloc                      // net/ipv4/tcp_minisocks.c:259                            |- tw-&gt;tw_state = TCP_TIME_WAIT     // net/ipv4/inet_timewait_sock.c:175                            |- timer_setup(tw_timer_handler)    // net/ipv4/inet_timewait_sock.c:188                        |- inet_twsk_schedule()                 // net/ipv4/tcp_minisocks.c:319<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在函数 <code>tcp_fin</code> 中，发送了 ACK 后，并进入 <code>TCP_TIME_WAIT</code> 状态。同时注册一个超时的定时器。</p><blockquote><p>注意，虽然在 <code>inet_twsk_alloc</code> 函数中，修改的是 <code>tw-&gt;tw_state</code> 字段为 <code>TCP_TIME_WAIT</code> 状态。但是查看宏 <code>tw_state</code> 的定义可以知道，<code>tw_state</code> 指向的依旧是结构体 <code>sock_common</code> 中的字段 <code>skc_state</code> 。</p></blockquote><h3 id="6-shutdown"><a href="#6-shutdown" class="headerlink" title="6. shutdown"></a>6. shutdown</h3><p>调用流程如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">__sys_shutdown                                  // net/socket.c:1973    |- sock-&gt;ops-&gt;shutdown()                    // net/socket.c:1965<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对于 TCP/IPv4 来说，调用 <code>sock-&gt;ops-&gt;shutdown()</code> 其实是调用 <code>net/ipv4/tcp_ipv4.c</code> 文件中的 <code>tcp_shutdown</code>：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">tcp_shutdown</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">int</span> how<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>how <span class="token operator">&amp;</span> SEND_SHUTDOWN<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment">/* If we've already sent a FIN, or it's a closed state, skip this. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> sk<span class="token operator">-&gt;</span>sk_state<span class="token punctuation">)</span> <span class="token operator">&amp;</span>        <span class="token punctuation">(</span>TCPF_ESTABLISHED <span class="token operator">|</span> TCPF_SYN_SENT <span class="token operator">|</span>            TCPF_SYN_RECV <span class="token operator">|</span> TCPF_CLOSE_WAIT<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">/* Clear out any half completed packets.  FIN if needed. */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tcp_close_state</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">tcp_send_fin</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与调用 <code>close</code> 类似，</p><h2 id="四、IP层及以下层的工作"><a href="#四、IP层及以下层的工作" class="headerlink" title="四、IP层及以下层的工作"></a>四、IP层及以下层的工作</h2><h3 id="1-IP层发送包"><a href="#1-IP层发送包" class="headerlink" title="1. IP层发送包"></a>1. IP层发送包</h3><p>上层想要发送 IP 包，都会调用函数 <code>ip_local_out</code> 来发送。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">ip_local_out                            // include/net/ip.h:165    |- dst_output                       // net/ipv4/ip_output.c:125        |- skb_dst(skb)-&gt;output()       // include/net/dst.h:455<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对 IP 协议来说， <code>skb_dst(skb)-&gt;output()</code> 实际调用的是 <code>net/ipv4/ip_output.c</code> 文件中的 <code>ip_output</code> 函数。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">ip_output                               // net/ipv4/route.c:1636    |- ip_finish_output                 // net/ipv4/ip_output.c:408        |- ip_finish_output2            // net/ipv4/ip_output.c:318            |- neigh_output             // net/ipv4/ip_output.c:230                |- neigh_hh_output      // include/net/neighbour.h:499                    |- dev_queue_xmit   // include/net/neighbour.h:491<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用 <code>dev_queue_xmit</code> 是将 IP 包交给网络设备子系统来发送，而 <code>dev_queue_xmit</code> 直接调用的函数 <code>__dev_queue_xmit</code> 。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">dev_queue_xmit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">__dev_queue_xmit</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">__dev_queue_xmit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>sb_dev<span class="token punctuation">)</span><span class="token punctuation">{</span>    txq <span class="token operator">=</span> <span class="token function">netdev_pick_tx</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> sb_dev<span class="token punctuation">)</span><span class="token punctuation">;</span>    q <span class="token operator">=</span> <span class="token function">rcu_dereference_bh</span><span class="token punctuation">(</span>txq<span class="token operator">-&gt;</span>qdisc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token operator">-&gt;</span>enqueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">__dev_xmit_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> q<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> txq<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">goto</span> out<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/* The device has no queue. Common case for software devices:     * loopback, all the sorts of tunnels...     */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dev<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> IFF_UP<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">dev_hard_start_xmit</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> txq<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在函数 <code>__dev_queue_xmit</code> 内部：</p><ol><li><p>针对有发送队列的设备</p><p> 首先调用 <code>netdev_pick_tx</code> 选择一个发送队列（现在的网卡一般都支持多个发送队列），然后再调用 <code>__dev_xmit_skb</code> 进行发送。在经过层层调用后，最后会调用的函数 <code>dev_hard_start_xmit</code> 发送包。</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">|- __dev_xmit_skb                               // net/core/dev.c:3807    |- q-&gt;enqueue(skb, q, &amp;to_free)             // net/core/dev.c:3450    |- qdisc_run                                // net/core/dev.c:3451        |- __qdisc_run                          // include/net/pkt_sched.h:120            |- qdisc_restart                    // net/sched/sch_generic.c:403                |- sch_direct_xmit              // net/sched/sch_generic.c:395                    |- dev_hard_start_xmit      // net/sched/sch_generic.c:332<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 需要注意函数 <code>__qdisc_run</code> 的实现：</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">__qdisc_run</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Qdisc</span> <span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> quota <span class="token operator">=</span> dev_tx_weight<span class="token punctuation">;</span>    <span class="token keyword">int</span> packets<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">qdisc_restart</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> <span class="token operator">&amp;</span>packets<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">/*        * Ordered by possible occurrence: Postpone processing if        * 1. we've exceeded packet quota        * 2. another process needs the CPU;        */</span>        quota <span class="token operator">-=</span> packets<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>quota <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">need_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">__netif_schedule</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 如果系统态 CPU 发送网络包不够用的时候，会调用函数 <code>__netif_schedule</code> 进而调用函数 <code>__netif_reschedule</code> 触发一个软中断 <code>NET_TX_SOFTIRQ</code> 。而对应的中断处理函数 <code>net_tx_action</code> 会重新调用 <code>qdisc_run</code> 继续发送剩余的网络包。</p></li><li><p>针对没有发送队列的设备</p><p> 如注释里说的回环地址，隧道网络等，就直接调用 <code>dev_hard_start_xmit</code> 发送包。</p></li></ol><p>所以，不管设备有无发送队列，最后都会调用函数 <code>dev_hard_start_xmit</code> ：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">|- dev_hard_start_xmit                      // net/core/dev.c:3262    |- xmit_one                             // net/core/dev.c:3272        |- netdev_start_xmit                // net/core/dev.c:3256            |- __netdev_start_xmit          // include/linux/netdevice.h:4359                |- ops-&gt;ndo_start_xmit      // include/linux/netdevice.h:4345<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在经过层层调用后，最后调用的 <code>ops-&gt;ndo_start_xmit()</code> 其实是各个网卡驱动的实现了。</p><h3 id="2-Intel的igb网卡驱动的发送流程"><a href="#2-Intel的igb网卡驱动的发送流程" class="headerlink" title="2. Intel的igb网卡驱动的发送流程"></a>2. Intel的igb网卡驱动的发送流程</h3><p>对网卡驱动 <code>drivers/net/ethernet/intel/igb</code> 来说， 函数 <code>ops-&gt;ndo_start_xmit</code> 调用的其实就是 <code>igb_netdev_ops</code> 中的 <code>ndo_start_xmit</code> 的值，即 <code>drivers/net/ethernet/intel/igb/igb_main.c</code> 文件中的 <code>igb_xmit_frame</code> 函数。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">igb_xmit_frame              // drivers/net/ethernet/intel/igb/igb_main.c:2865    |- igb_xmit_frame_ring  // drivers/net/ethernet/intel/igb/igb_main.c:6201        |- igb_tx_map       // drivers/net/ethernet/intel/igb/igb_main.c:6157<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>函数 <code>igb_tx_map</code> 做的主要的工作就是把网络包数据映射到 RAM 的 DMA 区域，然后唤醒设备发送数据。</p><h3 id="3-Intel的igb网卡驱动的初始化"><a href="#3-Intel的igb网卡驱动的初始化" class="headerlink" title="3. Intel的igb网卡驱动的初始化"></a>3. Intel的igb网卡驱动的初始化</h3><ol><li><p>模块加载</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">igb_init_module                                         // drivers/net/ethernet/intel/igb/igb_main.c:680    |- pci_register_driver(&amp;igb_driver)                 // drivers/net/ethernet/intel/igb/igb_main.c:676        |- __pci_register_driver                        // include/linux/pci.h:1289            |- driver_register                          // drivers/pci/pci-driver.c:1409                |- bus_add_driver                       // drivers/base/driver.c:170                    |- driver_attach                    // drivers/base/bus.c:672                        |- __driver_attach              // drivers/base/dd.c:922                            |- driver_probe_device      // drivers/base/dd.c:903                                |- really_probe         // drivers/base/dd.c:667                                    |- drv-&gt;probe(dev)  // drivers/base/dd.c:510<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 最后调用的 <code>drv-&gt;probe(dev)</code> 其实就是 <code>igb_driver</code> 中的 <code>probe</code> 的值，即 <code>drivers/net/ethernet/intel/igb/igb_main.c</code> 文件中的 <code>igb_probe</code> 函数。</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">igb_probe                                       // drivers/net/ethernet/intel/igb/igb_main.c:230    |- netdev-&gt;netdev_ops = &amp;igb_netdev_ops     // drivers/net/ethernet/intel/igb/igb_main.c:3095    |- igb_sw_init                              // drivers/net/ethernet/intel/igb/igb_main.c:3121        |- igb_init_interrupt_scheme            // drivers/net/ethernet/intel/igb/igb_main.c:3888            |- igb_alloc_q_vectors              // drivers/net/ethernet/intel/igb/igb_main.c:1387                |- igb_alloc_q_vector           // drivers/net/ethernet/intel/igb/igb_main.c:1331                    |- netif_napi_add(igb_poll) // drivers/net/ethernet/intel/igb/igb_main.c:1216                        |- napi-&gt;poll = poll    // net/core/dev.c:6194<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 对 Intel 的 igb 网卡来说，模块加载函数 <code>igb_probe</code> 做了：</p><ul><li>初始化了设备相关的操作回调函数信息 <code>igb_netdev_ops</code> 。</li><li>注册了 napi 的轮询回调函数 <code>igb_poll</code> 。</li></ul></li><li><p>启动设备</p><p> 在函数 <code>igb_probe</code> 中，通过语句 <code>netdev-&gt;netdev_ops = &amp;igb_netdev_ops</code> 初始化了网卡相关的操作回调。在网卡启用时，比如执行命令 <code>ifconfig eth0 up</code> 时，系统会依次调用：</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">dev_open                        // net/core/dev.c:1430    |- __dev_open               // net/core/dev.c:1437        |- ops-&gt;ndo_open(dev)   // net/core/dev.c:1402<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 对于网卡驱动 <code>drivers/net/ethernet/intel/igb</code> 来说，函数 <code>ops-&gt;ndo_open(dev)</code> 调用的就是函数 <code>igb_open</code> 。</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">igb_open                                        // drivers/net/ethernet/intel/igb/igb_main.c:2863    |- __igb_open                               // drivers/net/ethernet/intel/igb/igb_main.c:4017        |- igb_request_irq                      // drivers/net/ethernet/intel/igb/igb_main.c:3953            |- igb_request_msix                 // drivers/net/ethernet/intel/igb/igb_main.c:1416                |- request_irq(igb_msix_ring)   // drivers/net/ethernet/intel/igb/igb_main.c:968        |- igb_irq_enable(adapter)              // drivers/net/ethernet/intel/igb/igb_main.c:3978<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 在 <code>igb_open</code> 函数调用的深处，对于多队列网卡，通过 <code>request_irq(igb_msix_ring)</code> 为每个队列都注册了中断处理函数 <code>igb_msix_ring</code> 。设置好中断处理程序后，再调用 <code>igb_irq_enable(adapter)</code> 来开启中断。</p></li></ol><h3 id="4-Intel的igb网卡驱动的接收流程"><a href="#4-Intel的igb网卡驱动的接收流程" class="headerlink" title="4. Intel的igb网卡驱动的接收流程"></a>4. Intel的igb网卡驱动的接收流程</h3><p>当网卡的某个队列中收到网络数据后，会触发一个中断，这个中断的处理函数就是在启动设备时设置的 <code>igb_msix_ring</code> 函数：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">igb_msix_ring                                   // drivers/net/ethernet/intel/igb/igb_main.c:6621    |- napi_schedule                            // drivers/net/ethernet/intel/igb/igb_main.c:6628        |- __napi_schedule                      // include/linux/netdevice.h:445            |- ____napi_schedule                // net/core/dev.c:5892<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>网卡队列中断处理函数最深处的调用 <code>____napi_schedule</code> 主要做两件事：</p><ul><li>保存待处理的数据。</li><li>触发中断 <code>NET_RX_SOFTIRQ</code> 。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">____napi_schedule</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">softnet_data</span> <span class="token operator">*</span>sd<span class="token punctuation">,</span>                    <span class="token keyword">struct</span> <span class="token class-name">napi_struct</span> <span class="token operator">*</span>napi<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">list_add_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>napi<span class="token operator">-&gt;</span>poll_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sd<span class="token operator">-&gt;</span>poll_list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">__raise_softirq_irqoff</span><span class="token punctuation">(</span>NET_RX_SOFTIRQ<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而中断 <code>NET_RX_SOFTIRQ</code> 的处理函数是 <code>net_rx_action</code> ：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">net_rx_action           // net/core/dev.c:9874    |- napi_poll        // net/core/dev.c:6338        |- n-&gt;poll()    // net/core/dev.c:6272<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>中断处理函数 <code>net_rx_action</code> ，最终的会调用函数 <code>n-&gt;poll()</code> 。这函数就是网卡驱动模块加载时注册的处理回调函数 <code>igb_poll</code> ：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">igb_poll                                                // drivers/net/ethernet/intel/igb/igb_main.c:1216    |- igb_clean_rx_irq                                 // drivers/net/ethernet/intel/igb/igb_main.c:7759        |- napi_gro_receive                             // drivers/net/ethernet/intel/igb/igb_main.c:8408            |- napi_skb_finish                          // net/core/dev.c:5631                |- netif_receive_skb_internal           // net/core/dev.c:5600                    |- __netif_receive_skb              // net/core/dev.c:5156                        |- __netif_receive_skb_one_core // net/core/dev.c:5066                            |- __netif_receive_skb_core // net/core/dev.c:4952<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在函数 <code>__netif_receive_skb_core</code> 中：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">__netif_receive_skb_core</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span><span class="token operator">*</span>pskb<span class="token punctuation">,</span> bool pfmemalloc<span class="token punctuation">,</span>                    <span class="token keyword">struct</span> <span class="token class-name">packet_type</span> <span class="token operator">*</span><span class="token operator">*</span>ppt_prev<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">list_for_each_entry_rcu</span><span class="token punctuation">(</span>ptype<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ptype_all<span class="token punctuation">,</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pt_prev<span class="token punctuation">)</span>            ret <span class="token operator">=</span> <span class="token function">deliver_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> pt_prev<span class="token punctuation">,</span> orig_dev<span class="token punctuation">)</span><span class="token punctuation">;</span>        pt_prev <span class="token operator">=</span> ptype<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">list_for_each_entry_rcu</span><span class="token punctuation">(</span>ptype<span class="token punctuation">,</span> <span class="token operator">&amp;</span>skb<span class="token operator">-&gt;</span>dev<span class="token operator">-&gt;</span>ptype_all<span class="token punctuation">,</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pt_prev<span class="token punctuation">)</span>            ret <span class="token operator">=</span> <span class="token function">deliver_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> pt_prev<span class="token punctuation">,</span> orig_dev<span class="token punctuation">)</span><span class="token punctuation">;</span>        pt_prev <span class="token operator">=</span> ptype<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">deliver_ptype_list_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pt_prev<span class="token punctuation">,</span> orig_dev<span class="token punctuation">,</span> type<span class="token punctuation">,</span>                    <span class="token operator">&amp;</span>ptype_base<span class="token punctuation">[</span><span class="token function">ntohs</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token operator">&amp;</span>                        PTYPE_HASH_MASK<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一个循环 <code>list_for_each_entry_rcu(ptype, &amp;ptype_all, list)</code> 中的 <code>ptype_all</code> 是一个设备无关的保存有所有协议处理回调的地方，而第二个循环 <code>list_for_each_entry_rcu(ptype, &amp;skb-&gt;dev-&gt;ptype_all, list)</code> 中的 <code>skb-&gt;dev-&gt;ptype_all</code> 是一个设备有关的保存有所有协议处理回调的地方。这两个循环就能让像 tcpdump 这样的程序监听处理到收到的所有的网络包。</p><p>后面代码 <code>deliver_ptype_list_skb</code> 中的 <code>ptype_base</code> 是保存所有支持的3层协议处理函数的地方。才是将包转发给对应L3处理函数。函数 <code>deliver_ptype_list_skb</code> 的调用流程如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">deliver_ptype_list_skb      // net/core/dev.c:4905    |- deliver_skb          // net/core/dev.c:1971        |- pt_prev-&gt;func()  // net/core/dev.c:1956<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对于 IP 协议来说，其注册到 <code>ptype_base</code> 的流程如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">inet_init                               // net/ipv4/af_inet.c:1890    |- dev_add_pack(&amp;ip_packet_type)    // net/core/dev.c:408<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>dev_add_pack(&amp;ip_packet_type)</code> 函数内部就是把 <code>ip_packet_type</code> 添加到处理 <code>ETH_P_IP</code> 的协议链中。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">packet_type</span> ip_packet_type __read_mostly <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token function">cpu_to_be16</span><span class="token punctuation">(</span>ETH_P_IP<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span>func <span class="token operator">=</span> ip_rcv<span class="token punctuation">,</span>    <span class="token punctuation">.</span>list_func <span class="token operator">=</span> ip_list_rcv<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-接收IP包"><a href="#5-接收IP包" class="headerlink" title="5. 接收IP包"></a>5. 接收IP包</h3><p>所以对 IP 来说 <code>pt_prev-&gt;func()</code> 实际调用的是 <code>ip_rcv</code> 函数。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">ip_rcv                                  // ip_packet_type:1886    |- ip_rcv_finish                    // net/ipv4/ip_input.c:526        |- dst_input                    // net/ipv4/ip_input.c:414            |- skb_dst(skb)-&gt;input(skb) // include/net/dst.h:461<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>对 TCP/IPv4 来说 <code>skb_dst(skb)-&gt;input(skb)</code> 调用的其实是 <code>net/ipv4/ip_input.c</code> 文件中的 <code>ip_local_deliver</code> 。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">ip_local_deliver                // net/ipv4/route.c:1638    |- ip_local_deliver_finish  // net/ipv4/ip_input.c:258        |- ipprot-&gt;handler(skb) // net/ipv4/ip_input.c:215<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里调用的 <code>ipprot-&gt;handler(skb)</code> 就是传输层的处理回调了。 在文件 <code>net/ipv4/af_inet.c</code> 中的函数 <code>inet_init</code> 内初始化：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">inet_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">inet_add_protocol</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>icmp_protocol<span class="token punctuation">,</span> IPPROTO_ICMP<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">inet_add_protocol</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>udp_protocol<span class="token punctuation">,</span> IPPROTO_UDP<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">inet_add_protocol</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tcp_protocol<span class="token punctuation">,</span> IPPROTO_TCP<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">inet_add_protocol</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>igmp_protocol<span class="token punctuation">,</span> IPPROTO_IGMP<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="https://cloud.tencent.com/developer/article/1492374">Linux syscall过程分析（万字长文）</a><br><a href="https://xinqiu.gitbooks.io/linux-insides-cn/content/SysCall/linux-syscall-2.html">Linux 内核如何处理系统调用</a><br><a href="https://blog.packagecloud.io/eng/2017/02/06/monitoring-tuning-linux-networking-stack-sending-data/">Monitoring and Tuning the Linux Networking Stack: Sending Data</a><br><a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/">Monitoring and Tuning the Linux Networking Stack: Receiving Data</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内核分析 </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《设计模式之美》学习笔记</title>
      <link href="she-ji-mo-shi-zhi-mei-xue-xi-bi-ji/"/>
      <url>she-ji-mo-shi-zhi-mei-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/《设计模式之美》学习笔记/编写高质量代码.png" alt="编写高质量代码"></p><h2 id="设计原则与思想"><a href="#设计原则与思想" class="headerlink" title="设计原则与思想"></a>设计原则与思想</h2><h3 id="一、代码质量评判标准"><a href="#一、代码质量评判标准" class="headerlink" title="一、代码质量评判标准"></a>一、代码质量评判标准</h3><h4 id="如何评价代码质量的高低？"><a href="#如何评价代码质量的高低？" class="headerlink" title="如何评价代码质量的高低？"></a>如何评价代码质量的高低？</h4><p>代码质量的评价有很强的主观性，描述代码质量的词汇也有很多，比如可读性、可维护性、灵活、优雅、简洁。这些词汇是从不同的维度去评价代码质量的。它们之间有互相作用，并不是独立的，比如，代码的可读性好、可扩展性好就意味着代码的可维护性好。代码质量高低是一个综合各种因素得到的结论。我们并不能通过单一维度去评价一段代码的好坏。</p><h4 id="最常用的评价标准有哪几个？"><a href="#最常用的评价标准有哪几个？" class="headerlink" title="最常用的评价标准有哪几个？"></a>最常用的评价标准有哪几个？</h4><p>最常用到几个评判代码质量的标准有：可维护性、可读性、可扩展性、灵活性、简洁性、可复用性、可测试性。其中，可维护性、可读性、可扩展性又是提到最多的、最重要的三个评价标准。</p><h4 id="如何才能写出高质量的代码？"><a href="#如何才能写出高质量的代码？" class="headerlink" title="如何才能写出高质量的代码？"></a>如何才能写出高质量的代码？</h4><p>要写出高质量代码，我们就需要掌握一些更加细化、更加能落地的编程方法论，这就包含面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等。</p><p><img src="/images/《设计模式之美》学习笔记/代码质量评判标准.jpg" alt="代码质量评判标准"></p><h3 id="二、面向对象"><a href="#二、面向对象" class="headerlink" title="二、面向对象"></a>二、面向对象</h3><h4 id="1-面向对象概述"><a href="#1-面向对象概述" class="headerlink" title="1. 面向对象概述"></a>1. 面向对象概述</h4><p>现在，主流的编程范式或者编程风格有三种，它们分别是面向过程、面向对象和函数式编程。面向对象这种编程风格又是这其中最主流的。现在比较流行的编程语言大部分都是面向对象编程语言。大部分项目也都是基于面向对象编程风格开发的。面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式编码实现的基础。</p><h4 id="2-面向对象四大特性"><a href="#2-面向对象四大特性" class="headerlink" title="2. 面向对象四大特性"></a>2. 面向对象四大特性</h4><p>封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方法来访问内部信息或者数据。它需要编程语言提供权限访问控制语法来支持，例如 Java 中的 private、protected、public 关键字。封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。</p><p>如果说封装主要讲如何隐藏信息、保护数据，那抽象就是讲如何隐藏方法的具体实现，让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。抽象可以通过接口类或者抽象类来实现。抽象存在的意义，一方面是修改实现不需要改变定义；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。</p><p>继承用来表示类之间的 is-a 关系，分为两种模式：单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类。为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持。继承主要是用来解决代码复用的问题。</p><p>多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类、duck-typing。多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。</p><h4 id="3-面向对象-VS-面向过程"><a href="#3-面向对象-VS-面向过程" class="headerlink" title="3. 面向对象 VS 面向过程"></a>3. 面向对象 VS 面向过程</h4><p>面向对象编程相比面向过程编程的优势主要有三个。</p><ul><li>对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。</li><li>面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利用这些特性编写出来的代码，更加易扩展、易复用、易维护。</li><li>从编程语言跟机器打交道方式的演进规律中，我们可以总结出：面向对象编程语言比起面向过程编程语言，更加人性化、更加高级、更加智能。</li></ul><p>面向对象编程一般使用面向对象编程语言来进行，但是，不用面向对象编程语言，我们照样可以进行面向对象编程。反过来讲，即便我们使用面向对象编程语言，写出来的代码也不一定是面向对象编程风格的，也有可能是面向过程编程风格的。</p><p>面向对象和面向过程两种编程风格并不是非黑即白、完全对立的。在用面向对象编程语言开发的软件中，面向过程风格的代码并不少见，甚至在一些标准的开发库（比如 JDK、Apache Commons、Google Guava）中，也有很多面向过程风格的代码。</p><p>不管使用面向过程还是面向对象哪种风格来写代码，我们最终的目的还是写出易维护、易读、易复用、易扩展的高质量代码。只要我们能避免面向过程编程风格的一些弊端，控制好它的副作用，在掌控范围内为我们所用，我们就大可不用避讳在面向对象编程中写面向过程风格的代码。</p><h4 id="4-面向对象分析、设计与编程"><a href="#4-面向对象分析、设计与编程" class="headerlink" title="4. 面向对象分析、设计与编程"></a>4. 面向对象分析、设计与编程</h4><p>面向对象分析（OOA）、面向对象设计（OOD）、面向对象编程（OOP），是面向对象开发的三个主要环节。简单点讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做，面向对象编程就是将分析和设计的的结果翻译成代码的过程。</p><p>需求分析的过程实际上是一个不断迭代优化的过程。我们不要试图一下就给出一个完美的解决方案，而是先给出一个粗糙的、基础的方案，有一个迭代的基础，然后再慢慢优化。这样一个思考过程能让我们摆脱无从下手的窘境。</p><p>面向对象设计和实现要做的事情就是把合适的代码放到合适的类中。至于到底选择哪种划分方法，判定的标准是让代码尽量地满足“松耦合、高内聚”、单一职责、对扩展开放对修改关闭等我们之前讲到的各种设计原则和思想，尽量地做到代码可复用、易读、易扩展、易维护。</p><p>面向对象分析的产出是详细的需求描述。面向对象设计的产出是类。在面向对象设计这一环节中，我们将需求描述转化为具体的类的设计。这个环节的工作可以拆分为下面四个部分。</p><ul><li><p>划分职责进而识别出有哪些类</p><p>  根据需求描述，我们把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否归为同一个类。</p></li><li><p>定义类及其属性和方法</p><p>  我们识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选出真正的方法，把功能点中涉及的名词，作为候选属性，然后同样再进行过滤筛选。</p></li><li><p>定义类与类之间的交互关系</p><p>  UML 统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。我们从更加贴近编程的角度，对类与类之间的关系做了调整，保留了四个关系：泛化、实现、组合、依赖。</p></li><li><p>将类组装起来并提供执行入口</p><p>  我们要将所有的类组装在一起，提供一个执行入口。这个入口可能是一个 main() 函数，也可能是一组给外部用的 API 接口。通过这个入口，我们能触发整个代码跑起来。</p></li></ul><h4 id="5-接口-VS-抽象类"><a href="#5-接口-VS-抽象类" class="headerlink" title="5. 接口 VS 抽象类"></a>5. 接口 VS 抽象类</h4><p>抽象类不允许被实例化，只能被继承。它可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法。接口不能包含属性（Java 可以定义静态常量），只能声明方法，方法不能包含代码实现（Java8 以后可以有默认实现）。类实现接口的时候，必须实现接口中声明的所有方法。</p><p>抽象类是对成员变量和方法的抽象，是一种 is-a 关系，是为了解决代码复用问题。接口仅仅是对方法的抽象，是一种 has-a 关系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。</p><p>什么时候该用抽象类？什么时候该用接口？实际上，判断的标准很简单。如果要表示一种 is-a 的关系，并且是为了解决代码复用问题，我们就用抽象类；如果要表示一种 has-a 关系，并且是为了解决抽象而非代码复用问题，那我们就用接口。</p><h4 id="6-基于接口而非实现编程"><a href="#6-基于接口而非实现编程" class="headerlink" title="6. 基于接口而非实现编程"></a>6. 基于接口而非实现编程</h4><p>应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。</p><p>实际上，“基于接口而非实现编程”这条原则的另一个表述方式是，“基于抽象而非实现编程”。后者的表述方式其实更能体现这条原则的设计初衷。在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。</p><p>越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。</p><h4 id="7-多用组合少用继承"><a href="#7-多用组合少用继承" class="headerlink" title="7. 多用组合少用继承"></a>7. 多用组合少用继承</h4><ul><li><p>为什么不推荐使用继承？</p><p>  继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。在这种情况下，我们应该尽量少用，甚至不用继承。</p></li><li><p>组合相比继承有哪些优势？</p><p>  继承主要有三个作用：表示 is-a 关系、支持多态特性、代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。</p></li><li><p>如何判断该用组合还是继承？</p><p>  尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。在实际的项目开发中，我们还是要根据具体的情况，来选择该用继承还是组合。如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。</p></li></ul><h4 id="8-贫血模型-VS-充血模型"><a href="#8-贫血模型-VS-充血模型" class="headerlink" title="8. 贫血模型 VS 充血模型"></a>8. 贫血模型 VS 充血模型</h4><p>我们平时做 Web 项目的业务开发，大部分都是基于贫血模型的 MVC 三层架构，在专栏中我把它称为传统的开发模式。之所以称之为“传统”，是相对于新兴的基于充血模型的 DDD 开发模式来说的。基于贫血模型的传统开发模式，是典型的面向过程的编程风格。相反，基于充血模型的 DDD 开发模式，是典型的面向对象的编程风格。</p><p>不过，DDD 也并非银弹。对于业务不复杂的系统开发来说，基于贫血模型的传统开发模式简单够用，基于充血模型的 DDD 开发模式有点大材小用，无法发挥作用。相反，对于业务复杂的系统开发来说，基于充血模型的 DDD 开发模式，因为前期需要在设计上投入更多时间和精力，来提高代码的复用性和可维护性，所以相比基于贫血模型的开发模式，更加有优势。</p><p>基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，主要区别在 Service 层。在基于充血模型的开发模式下，我们将部分原来在 Service 类中的业务逻辑移动到了一个充血的 Domain 领域模型中，让 Service 类的实现依赖这个 Domain 类。不过，Service 类并不会完全移除，而是负责一些不适合放在 Domain 类中的功能。比如，负责与 Repository 层打交道、跨领域模型的业务聚合功能、幂等事务等非功能性的工作。</p><p>基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，Controller 层和 Repository 层的代码基本上相同。这是因为，Repository 层的 Entity 生命周期有限，Controller 层的 VO 只是单纯作为一种 DTO。两部分的业务逻辑都不会太复杂。业务逻辑主要集中在 Service 层。所以，Repository 层和 Controller 层继续沿用贫血模型的设计思路是没有问题的。</p><p><img src="/images/《设计模式之美》学习笔记/面向对象.jpg" alt="面向对象"></p><h3 id="三、设计原则"><a href="#三、设计原则" class="headerlink" title="三、设计原则"></a>三、设计原则</h3><h4 id="1-SOLID-原则：SRP-单一职责原则"><a href="#1-SOLID-原则：SRP-单一职责原则" class="headerlink" title="1. SOLID 原则：SRP 单一职责原则"></a>1. SOLID 原则：SRP 单一职责原则</h4><p>一个类只负责完成一个职责或者功能。单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、松耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。</p><p>不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。实际上，一些侧面的判断指标更具有指导意义和可执行性，比如，出现下面这些情况就有可能说明这类的设计不满足单一职责原则：</p><ul><li>类中的代码行数、函数或者属性过多；</li><li>类依赖的其他类过多或者依赖类的其他类过多；</li><li>私有方法过多；</li><li>比较难给类起一个合适的名字；</li><li>类中大量的方法都是集中操作类中的某几个属性。</li></ul><h4 id="2-SOLID-原则：OCP-开闭原则"><a href="#2-SOLID-原则：OCP-开闭原则" class="headerlink" title="2. SOLID 原则：OCP 开闭原则"></a>2. SOLID 原则：OCP 开闭原则</h4><ul><li><p>如何理解“对扩展开放、修改关闭”？</p><p>  添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。关于定义，我们有两点要注意。第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。</p></li><li><p>如何做到“对扩展开放、修改关闭”？</p><p>  我们要时刻具备扩展意识、抽象意识、封装意识。在写代码的时候，我们要多花点时间思考一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活地插入到扩展点上。</p><p>  很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是 23 种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。</p></li></ul><h4 id="3-SOLID-原则：LSP-里式替换原则"><a href="#3-SOLID-原则：LSP-里式替换原则" class="headerlink" title="3. SOLID 原则：LSP 里式替换原则"></a>3. SOLID 原则：LSP 里式替换原则</h4><p>子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</p><p>里式替换原则是用来指导继承关系中子类该如何设计的一个原则。理解里式替换原则，最核心的就是理解“design by contract，按照协议来设计”这几个字。父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数的原有“约定”。这里的“约定”包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。</p><p>理解这个原则，我们还要弄明白，里式替换原则跟多态的区别。虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。</p><h4 id="4-SOLID-原则：ISP-接口隔离原则"><a href="#4-SOLID-原则：ISP-接口隔离原则" class="headerlink" title="4. SOLID 原则：ISP 接口隔离原则"></a>4. SOLID 原则：ISP 接口隔离原则</h4><p>接口隔离原则的描述是：客户端不应该强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。理解“接口隔离原则”的重点是理解其中的“接口”二字。这里有三种不同的理解。</p><p>如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。</p><p>如果把“接口”理解为单个 API 接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。</p><p>如果把“接口”理解为 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。</p><p>单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考的角度也是不同的。接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p><h4 id="5-SOLID-原则：DIP-依赖倒置原则"><a href="#5-SOLID-原则：DIP-依赖倒置原则" class="headerlink" title="5. SOLID 原则：DIP 依赖倒置原则"></a>5. SOLID 原则：DIP 依赖倒置原则</h4><p><strong>控制反转：</strong>实际上，控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计。这里所说的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。</p><p><strong>依赖注入：</strong>依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或“注入”）给类来使用。</p><p><strong>依赖注入框架：</strong>我们通过依赖注入框架提供的扩展点，简单配置一下所有需要的类及其类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。</p><p><strong>依赖反转原则：</strong>依赖反转原则也叫作依赖倒置原则。这条原则跟控制反转有点类似，主要用来指导框架层面的设计。高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不需要依赖具体实现细节，具体实现细节依赖抽象。</p><h4 id="6-KISS、YAGNI-原则"><a href="#6-KISS、YAGNI-原则" class="headerlink" title="6. KISS、YAGNI 原则"></a>6. KISS、YAGNI 原则</h4><p>KISS 原则的中文描述是：尽量保持简单。KISS 原则是保持代码可读和可维护的重要手段。KISS 原则中的“简单“”并不是以代码行数来考量的。代码行数越少并不代表代码越简单，我们还要考虑逻辑复杂度、实现难度、代码的可读性等。而且，本身就复杂的问题，用复杂的方法解决，也并不违背 KISS 原则。除此之外，同样的代码，在某个业务场景下满足 KISS 原则，换一个应用场景可能就不满足了。</p><p>对于如何写出满足 KISS 原则的代码，我总结了下面几条指导原则：</p><ul><li>不要使用同事可能不懂的技术来实现代码；</li><li>不要重复造轮子，善于使用已经有的工具类库；</li><li>不要过度优化。</li></ul><p>YAGNI 原则的英文全称是：You Ain’t Gonna Need It。直译就是：你不会需要它。这条原则也算是万金油了。当用在软件开发中的时候，它的意思是：不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。</p><p>YAGNI 原则跟 KISS 原则并非一回事儿。KISS 原则讲的是“如何做”的问题（尽量保持简单），而 YAGNI 原则说的是“要不要做”的问题（当前不需要的就不要做）。</p><h4 id="7-DRY-原则"><a href="#7-DRY-原则" class="headerlink" title="7. DRY 原则"></a>7. DRY 原则</h4><p>DRY 原则中文描述是：不要重复自己，将它应用在编程中，可以理解为：不要写重复的代码。</p><p>专栏中讲到了三种代码重复的情况：实现逻辑重复、功能语义重复、代码执行重复。实现逻辑重复，但功能语义不重复的代码，并不违反 DRY 原则。实现逻辑不重复，但功能语义重复的代码，也算是违反 DRY 原则。而代码执行重复也算是违反 DRY 原则。</p><p>除此之外，我们还讲到了提高代码复用性的一些手段，包括：减少代码耦合、满足单一职责原则、模块化、业务与非业务逻辑分离、通用代码下沉、继承、多态、抽象、封装、应用模板等设计模式。复用意识也非常重要。在设计每个模块、类、函数的时候，要像设计一个外部 API 一样去思考它的复用性。</p><p>我们在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，那我们就不需要考虑代码的复用性。在之后开发新的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码，让其变得更加可复用。</p><p>相比于代码的可复用性，DRY 原则适用性更强些。我们可以不写可复用的代码，但一定不能写重复的代码。</p><h4 id="8-LOD-原则"><a href="#8-LOD-原则" class="headerlink" title="8. LOD 原则"></a>8. LOD 原则</h4><ul><li><p>如何理解“高内聚、松耦合”？</p><p>  “高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。所谓“松耦合”指的是，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动。</p></li><li><p>如何理解“迪米特法则”？</p><p>  迪米特法则的描述为：不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。</p></li></ul><p><img src="/images/《设计模式之美》学习笔记/设计原则.jpg" alt="设计原则"></p><h3 id="四、规范与重构"><a href="#四、规范与重构" class="headerlink" title="四、规范与重构"></a>四、规范与重构</h3><h4 id="1-重构概述"><a href="#1-重构概述" class="headerlink" title="1. 重构概述"></a>1. 重构概述</h4><ul><li><p>重构的目的：为什么重构（why）？</p><p>  对于项目来言，重构可以保持代码质量持续处于一个可控状态，不至于腐化到无可救药的地步。对于个人而言，重构非常锻炼一个人的代码能力，并且是一件非常有成就感的事情。它是我们学习的经典设计思想、原则、模式、编程规范等理论知识的练兵场。</p></li><li><p>重构的对象：重构什么（what）？</p><p>  按照重构的规模，我们可以将重构大致分为大规模高层次的重构和小规模低层次的重构。大规模高层次重构包括对代码分层、模块化、解耦、梳理类之间的交互关系、抽象复用组件等等。这部分工作利用的更多的是比较抽象、比较顶层的设计思想、原则、模式。小规模低层次的重构包括规范命名、注释、修正函数参数过多、消除超大类、提取重复代码等编程细节问题，主要是针对类、函数级别的重构。小规模低层次的重构更多的是利用编码规范这一理论知识。</p></li><li><p>重构的时机：什么时候重构（when）？</p><p>  我反复强调，我们一定要建立持续重构意识，把重构作为开发必不可少的部分融入到开发中，而不是等到代码出现很大问题的时候，再大刀阔斧地重构。</p></li><li><p>重构的方法：如何重构（how）？</p><p>  大规模高层次的重构难度比较大，需要有组织、有计划地进行，分阶段地小步快跑，时刻保持代码处于一个可运行的状态。而小规模低层次的重构，因为影响范围小，改动耗时短，所以，只要你愿意并且有时间，随时随地都可以去做。</p></li></ul><h4 id="2-单元测试"><a href="#2-单元测试" class="headerlink" title="2. 单元测试"></a>2. 单元测试</h4><ul><li><p>什么是单元测试？</p><p>  单元测试是代码层面的测试，用于测试“自己”编写的代码的逻辑正确性。单元测试顾名思义是测试一个“单元”，这个“单元”一般是类或函数，而不是模块或者系统。</p></li><li><p>为什么要写单元测试？</p><p>  单元测试能有效地发现代码中的 Bug、代码设计上的问题。写单元测试的过程本身就是代码重构的过程。单元测试是对集成测试的有力补充，能帮助我们快速熟悉代码，是 TDD 可落地执行的折中方案。</p></li><li><p>如何编写单元测试？</p><p>  写单元测试就是针对代码设计覆盖各种输入、异常、边界条件的测试用例，并将其翻译成代码的过程。我们可以利用一些测试框架来简化测试代码的编写。对于单元测试，我们需要建立以下正确的认知：</p><ol><li>编写单元测试尽管繁琐，但并不是太耗时；</li><li>我们可以稍微放低单元测试的质量要求；</li><li>覆盖率作为衡量单元测试好坏的唯一标准是不合理的；</li><li>写单元测试一般不需要了解代码的实现逻辑；</li><li>单元测试框架无法测试多半是代码的可测试性不好。</li></ol></li><li><p>单元测试为何难落地执行？</p><p>  一方面，写单元测试本身比较繁琐，技术挑战不大，很多程序员不愿意去写。另一方面，国内研发比较偏向“快糙猛”，容易因为开发进度紧，导致单元测试的执行虎头蛇尾，最后，没有建立对单元测试的正确认识，觉得可有可无，单靠督促很难执行得很好。</p></li></ul><h4 id="3-代码的可测试性"><a href="#3-代码的可测试性" class="headerlink" title="3. 代码的可测试性"></a>3. 代码的可测试性</h4><ul><li><p>什么是代码的可测试性？</p><p>  粗略地讲，所谓代码的可测试性，就是针对代码编写单元测试的难易程度。对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很费劲，需要依靠单元测试框架很高级的特性，那往往就意味着代码设计得不够合理，代码的可测试性不好。</p></li><li><p>编写可测试性代码的最有效手段</p><p>  依赖注入是编写可测试性代码的最有效手段。通过依赖注入，我们在编写单元测试代码的时候，可以通过 mock 的方法将不可控的依赖变得可控，这也是我们在编写单元测试的过程中最有技术挑战的地方。除了 mock 方式，我们还可以利用二次封装来解决某些代码行为不可控的情况。</p></li><li><p>常见的 Anti-Patterns典型的、常见的测试不友好的代码有下面这 5 种：</p><ol><li>代码中包含未决行为逻辑；</li><li>滥用可变全局变量；</li><li>滥用静态方法；</li><li>使用复杂的继承关系；</li><li>高度耦合的代码。</li></ol></li></ul><h4 id="4-大型重构：解耦"><a href="#4-大型重构：解耦" class="headerlink" title="4. 大型重构：解耦"></a>4. 大型重构：解耦</h4><ul><li><p>“解耦”为何如此重要？</p><p>  过于复杂的代码往往在可读性、可维护性上都不友好。解耦，保证代码松耦合、高内聚，是控制代码复杂度的有效手段。如果代码高内聚、松耦合，也就是意味着，代码结构清晰、分层、模块化合理、依赖关系简单、模块或类之间的耦合小，那代码整体的质量就不会差。</p></li><li><p>代码是否需要“解耦”？</p><p>  间接的衡量标准有很多，比如：改动一个模块或类的代码受影响的模块或类是否有很多、改动一个模块或者类的代码依赖的模块或者类是否需要改动、代码的可测试性是否好等等。直接的衡量标准是把模块与模块之间及其类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构。</p></li><li><p>如何给代码“解耦”？</p><p>  给代码解耦的方法有：封装与抽象、中间层、模块化，以及一些其他的设计思想与原则，比如：单一职责原则、基于接口而非实现编程、依赖注入、多用组合少用继承、迪米特法则。当然，还有一些设计模式，比如观察者模式。</p></li></ul><h4 id="5-小型重构：编码规范"><a href="#5-小型重构：编码规范" class="headerlink" title="5. 小型重构：编码规范"></a>5. 小型重构：编码规范</h4><p>前面我们讲了很多设计原则，后面还会讲到很多设计模式，利用好它们都可以有效地改善代码的质量。但是，这些知识的合理应用非常依赖个人经验，有时候用不好会适得其反。但是编码规范正好相反，大部分都简单明了，在代码的细节方面，能立竿见影地改善质量。除此之外，我们前面也讲到，持续低层次小规模重构依赖的基本上都是这些编码规范，也是改善代码可读性的有效手段。</p><p>根据我自己的开发经验，我总结罗列了 20 条我认为最应该关注、最好用的编码规范，分为三个大的方面：命名与注释（Naming and Comments）、代码风格（Code Style）、编程技巧（Coding Tips）。</p><ul><li><p>命名与注释</p><ol><li>命名的关键是能准确的达意。对于不同作用域的命名，我们可以适当的选择不同的长度，作用域小的命名，比如临时变量等，可以适当的选择短一些的命名方式。除此之外，命名中个也可以使用一些耳熟能详的缩写。</li><li>我们借助类的信息来简化属性、函数的命名，利用函数的信息来简化函数参数的命名。</li><li>命名要可读、可搜索。不要使用生僻的、不好读的英文单词来命名。除此之外，命名要符合项目的统一规范，也不要用些反直觉的命名。</li><li>接口有两种命名方式。一种是在接口中带前缀”I”，另一种是在接口的实现类中带后缀“Impl”。两种命名方式都可以，关键是要在项目中统一。对于抽象类的命名，我们更倾向于带有前缀“Abstract”。</li><li>注释的目的就是让代码更容易看懂，只要符合这个要求，你就可以写。总结一下的话，注释主要包含这样三个方面的内容：做什么、为什么、怎么做。对于一些复杂的类和接口，我们可能还需要写明“如何用”。</li><li>注释本身有一定的维护成本，所以并非越多越好。类和函数一定要写注释，而且要写的尽可能全面详细些，而函数内部的注释会相对少一些，一般都是靠好的命名和提炼函数、解释性变量、总结性注释来做到代码易读。</li></ol></li><li><p>代码风格</p><p>  代码风格都没有对错和优劣之分，不同的编程语言风格都不太一样，只要能在团队、项目中统一即可，不过，最好能跟业内推荐的风格、开源项目的代码风格相一致。所以，这里就不展开罗列了，你可以对照着自己熟悉的编程语言的代码风格，自己复习一下。</p></li><li><p>编程技巧</p><ol><li>将复杂的逻辑提炼拆分成函数和类；</li><li>通过拆分成多个函数的方式来处理参数过多的情况；</li><li>通过将参数封装为对象来处理参数过多的情况；</li><li>函数中不要使用参数来做代码执行逻辑的控制；</li><li>移除过深的嵌套层次，方法包括：去掉多余的 if 或 else 语句，使用 continue、break、return 关键字提前退出嵌套，调整执行顺序来减少嵌套，将部分嵌套逻辑抽象成函数；</li><li>用字面常量取代魔法数；</li><li>利用解释性变量来解释复杂表达式。</li></ol></li><li><p>统一编码规范</p><p>  除了细节的知识点之外，最后，还有一条非常重要的，那就是，项目、团队，甚至公司，一定要制定统一的编码规范，并且通过 Code Review 督促执行，这对提高代码质量有立竿见影的效果。</p></li></ul><p><img src="/images/《设计模式之美》学习笔记/规范与重构.jpg" alt="规范与重构"></p><h2 id="设计模式与范式"><a href="#设计模式与范式" class="headerlink" title="设计模式与范式"></a>设计模式与范式</h2><h3 id="一、创建型设计模式"><a href="#一、创建型设计模式" class="headerlink" title="一、创建型设计模式"></a>一、创建型设计模式</h3><p>创建型设计模式包括：单例模式、工厂模式、建造者模式、原型模式。它主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。</p><h4 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1. 单例模式"></a>1. 单例模式</h4><p>单例模式用来创建全局唯一的对象。一个类只允许创建一个对象（或者叫实例），那这个类就是一个单例类，这种设计模式就叫作单例模式。单例有几种经典的实现方式，它们分别是：饿汉式、懒汉式、双重检测、静态内部类、枚举。</p><p>尽管单例是一个很常用的设计模式，在实际的开发中，我们也确实经常用到它，但是，有些人认为单例是一种反模式（anti-pattern），并不推荐使用，主要的理由有以下几点：</p><ul><li>单例对 OOP 特性的支持不友好</li><li>单例会隐藏类之间的依赖关系</li><li>单例对代码的扩展性不友好</li><li>单例对代码的可测试性不友好</li><li>单例不支持有参数的构造函数</li></ul><p>那有什么替代单例的解决方案呢？如果要完全解决这些问题，我们可能要从根上寻找其他方式来实现全局唯一类。比如，通过工厂模式、IOC 容器来保证全局唯一性。</p><p>有人把单例当作反模式，主张杜绝在项目中使用。我个人觉得这有点极端。模式本身没有对错，关键看你怎么用。如果单例类并没有后续扩展的需求，并且不依赖外部系统，那设计成单例类就没有太大问题。对于一些全局类，我们在其他地方 new 的话，还要在类之间传来传去，不如直接做成单例类，使用起来简洁方便。</p><p>除此之外，我们还讲到了进程唯一单例、线程唯一单例、集群唯一单例、多例等扩展知识点，这一部分在实际的开发中并不会被用到，但是可以扩展你的思路、锻炼你的逻辑思维。这里我就不带你回顾了，你可以自己回忆一下。</p><h4 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2. 工厂模式"></a>2. 工厂模式</h4><p>工厂模式包括简单工厂、工厂方法、抽象工厂这 3 种细分模式。其中，简单工厂和工厂方法比较常用，抽象工厂的应用场景比较特殊，所以很少用到，不是我们学习的重点。</p><p>工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。实际上，如果创建对象的逻辑并不复杂，那我们直接通过 new 来创建对象就可以了，不需要使用工厂模式。当创建逻辑比较复杂，是一个“大工程”的时候，我们就考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离。</p><p>当每个对象的创建逻辑都比较简单的时候，我推荐使用简单工厂模式，将多个对象的创建逻辑放到一个工厂类中。当每个对象的创建逻辑都比较复杂的时候，为了避免设计一个过于庞大的工厂类，我们推荐使用工厂方法模式，将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中。</p><p>详细点说，工厂模式的作用有下面 4 个，这也是判断要不要使用工厂模式最本质的参考标准。</p><ul><li>封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。</li><li>代码复用：创建代码抽离到独立的工厂类之后可以复用。</li><li>隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。</li><li>控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。</li></ul><p>除此之外，我们还讲了工厂模式一个非常经典的应用场景：依赖注入框架，比如 Spring IOC、Google Guice，它用来集中创建、组装、管理对象，跟具体业务代码解耦，让程序员聚焦在业务代码的开发上。DI 框架已经成为了我们平时开发的必备框架，在专栏中，我还带你实现了一个简单的 DI 框架，你可以再回过头去看看。</p><h4 id="3-建造者模式"><a href="#3-建造者模式" class="headerlink" title="3. 建造者模式"></a>3. 建造者模式</h4><p>建造者模式用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。建造者模式的原理和实现比较简单，重点是掌握应用场景，避免过度使用。</p><p>如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，我们可以通过构造函数配合 set() 方法来解决。但是，如果存在下面情况中的任意一种，我们就要考虑使用建造者模式了。</p><ul><li>我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填属性通过 set() 方法设置，那校验这些必填属性是否已经填写的逻辑就无处安放了。</li><li>如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合 set() 方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。</li><li>如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露 set() 方法。构造函数配合 set() 方法来设置属性值的方式就不适用了。</li></ul><h4 id="4-原型模式"><a href="#4-原型模式" class="headerlink" title="4. 原型模式"></a>4. 原型模式</h4><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式，来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型模式。</p><p>原型模式有两种实现方法，深拷贝和浅拷贝。浅拷贝只会复制对象中基本数据类型数据和引用对象的内存地址，不会递归地复制引用对象，以及引用对象的引用对象……而深拷贝得到的是一份完完全全独立的对象。所以，深拷贝比起浅拷贝来说，更加耗时，更加耗内存空间。</p><p>如果要拷贝的对象是不可变对象，浅拷贝共享不可变对象是没问题的，但对于可变对象来说，浅拷贝得到的对象和原始对象会共享部分数据，就有可能出现数据被修改的风险，也就变得复杂多了。操作非常耗时的情况下，我们比较推荐使用浅拷贝，否则，没有充分的理由，不要为了一点点的性能提升而使用浅拷贝。</p><h3 id="二、结构型设计模式"><a href="#二、结构型设计模式" class="headerlink" title="二、结构型设计模式"></a>二、结构型设计模式</h3><p>结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。结构型模式包括：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。</p><h4 id="1-代理模式"><a href="#1-代理模式" class="headerlink" title="1. 代理模式"></a>1. 代理模式</h4><p>代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。一般情况下，我们让代理类和原始类实现同样的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式。</p><p>静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板式的“重复”代码，增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动态代理来解决。我们不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。</p><p>代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。除此之外，代理模式还可以用在 RPC、缓存等应用场景中。</p><h4 id="2-桥接模式"><a href="#2-桥接模式" class="headerlink" title="2. 桥接模式"></a>2. 桥接模式</h4><p>桥接模式的代码实现非常简单，但是理解起来稍微有点难度，并且应用场景也比较局限，所以，相对来说，桥接模式在实际的项目中并没有那么常用，你只需要简单了解，见到能认识就可以了，并不是我们学习的重点。</p><p>桥接模式有两种理解方式。第一种理解方式是“将抽象和实现解耦，让它们能独立开发”。这种理解方式比较特别，应用场景也不多。另一种理解方式更加简单，等同于“组合优于继承”设计原则，这种理解方式更加通用，应用场景比较多。不管是哪种理解方式，它们的代码结构都是相同的，都是一种类之间的组合关系。</p><p>对于第一种理解方式，弄懂定义中“抽象”和“实现”两个概念，是理解它的关键。定义中的“抽象”，指的并非“抽象类”或“接口”，而是被抽象出来的一套“类库”，它只包含骨架代码，真正的业务逻辑需要委派给定义中的“实现”来完成。而定义中的“实现”，也并非“接口的实现类”，而是的一套独立的“类库”。“抽象”和“实现”独立开发，通过对象之间的组合关系组装在一起。</p><h4 id="3-装饰器模式"><a href="#3-装饰器模式" class="headerlink" title="3. 装饰器模式"></a>3. 装饰器模式</h4><p>装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承，给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据。除此之外，装饰器模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。为了满足这样的需求，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。</p><h4 id="4-适配器模式"><a href="#4-适配器模式" class="headerlink" title="4. 适配器模式"></a>4. 适配器模式</h4><p>代理模式、装饰器模式提供的都是跟原始类相同的接口，而适配器提供跟原始类不同的接口。适配器模式是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</p><p>适配器模式是一种事后的补救策略，用来补救设计上的缺陷。应用这种模式算是“无奈之举”。如果在设计初期，我们就能规避接口不兼容的问题，那这种模式就无用武之地了。在实际的开发中，什么情况下才会出现接口不兼容呢？我总结下了下面这 5 种场景：</p><ul><li>封装有缺陷的接口设计</li><li>统一多个类的接口设计</li><li>替换依赖的外部系统</li><li>兼容老版本接口</li><li>适配不同格式的数据</li></ul><h4 id="5-门面模式"><a href="#5-门面模式" class="headerlink" title="5. 门面模式"></a>5. 门面模式</h4><p>门面模式原理、实现都非常简单，应用场景比较明确。它通过封装细粒度的接口，提供组合各个细粒度接口的高层次接口，来提高接口的易用性，或者解决性能、分布式事务等问题。</p><h4 id="6-组合模式"><a href="#6-组合模式" class="headerlink" title="6. 组合模式"></a>6. 组合模式</h4><p>组合模式跟我们之前讲的面向对象设计中的“组合关系（通过组合来组装两个类）”，完全是两码事。这里讲的“组合模式”，主要是用来处理树形结构数据。正因为其应用场景的特殊性，数据必须能表示成树形结构，这也导致了这种模式在实际的项目开发中并不那么常用。但是，一旦数据满足树形结构，应用这种模式就能发挥很大的作用，能让代码变得非常简洁。</p><p>组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。组合模式，将一组对象组织成树形结构，将单个对象和组合对象都看作树中的节点，以统一处理逻辑，并且它利用树形结构的特点，递归地处理每个子树，依次简化代码实现。</p><h4 id="7-享元模式"><a href="#7-享元模式" class="headerlink" title="7. 享元模式"></a>7. 享元模式</h4><p>所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。</p><p>具体来讲，当一个系统中存在大量重复对象的时候，我们就可以利用享元模式，将对象设计成享元，在内存中只保留一份实例，供多处代码引用，这样可以减少内存中对象的数量，以起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段），提取出来设计成享元，让这些大量相似对象引用这些享元。</p><h3 id="三、行为型设计模式"><a href="#三、行为型设计模式" class="headerlink" title="三、行为型设计模式"></a>三、行为型设计模式</h3><p>我们知道，创建型设计模式主要解决“对象的创建”问题，结构型设计模式主要解决“类或对象的组合”问题，那行为型设计模式主要解决的就是“类或对象之间的交互”问题。行为型模式比较多，有 11 种，它们分别是：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式、访问者模式、备忘录模式、命令模式、解释器模式、中介模式。</p><h4 id="1-观察者模式"><a href="#1-观察者模式" class="headerlink" title="1. 观察者模式"></a>1. 观察者模式</h4><p>观察者模式将观察者和被观察者代码解耦。观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观察者模式。</p><p>不同的应用场景和需求下，这个模式也有截然不同的实现方式：有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。同步阻塞是最经典的实现方式，主要是为了代码解耦；异步非阻塞除了能实现代码解耦之外，还能提高代码的执行效率；进程间的观察者模式解耦更加彻底，一般是基于消息队列来实现，用来实现不同进程间的被观察者和观察者之间的交互。</p><p>框架的作用有隐藏实现细节，降低开发难度，实现代码复用，解耦业务与非业务代码，让程序员聚焦业务开发。针对异步非阻塞观察者模式，我们也可以将它抽象成 EventBus 框架来达到这样的效果。EventBus 翻译为“事件总线”，它提供了实现观察者模式的骨架代码。我们可以基于此框架非常容易地在自己的业务场景中实现观察者模式，不需要从零开始开发。</p><h4 id="2-模板模式"><a href="#2-模板模式" class="headerlink" title="2. 模板模式"></a>2. 模板模式</h4><p>模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。这里的“算法”，我们可以理解为广义上的“业务逻辑”，并不特指数据结构和算法中的“算法”。这里的算法骨架就是“模板”，包含算法骨架的方法就是“模板方法”，这也是模板方法模式名字的由来。</p><p>模板模式有两大作用：复用和扩展。其中复用指的是，所有的子类可以复用父类中提供的模板方法的代码。扩展指的是，框架通过模板模式提供功能扩展点，让框架用户可以在不修改框架源码的情况下，基于扩展点定制化框架的功能。</p><p>除此之外，我们还讲到回调。它跟模板模式具有相同的作用：代码复用和扩展。在一些框架、类库、组件等的设计中经常会用到，比如 JdbcTemplate 就是用了回调。</p><p>相对于普通的函数调用，回调是一种双向调用关系。A 类事先注册某个函数 F 到 B 类，A 类在调用 B 类的 P 函数的时候，B 类反过来调用 A 类注册给它的 F 函数。这里的 F 函数就是“回调函数”。A 调用 B，B 反过来又调用 A，这种调用机制就叫作“回调”。</p><p>回调可以细分为同步回调和异步回调。从应用场景上来看，同步回调看起来更像模板模式，异步回调看起来更像观察者模式。回调跟模板模式的区别，更多的是在代码实现上，而非应用场景上。回调基于组合关系来实现，模板模式基于继承关系来实现。回调比模板模式更加灵活。</p><h4 id="3-策略模式"><a href="#3-策略模式" class="headerlink" title="3. 策略模式"></a>3. 策略模式</h4><p>策略模式定义一组算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。策略模式用来解耦策略的定义、创建、使用。实际上，一个完整的策略模式就是由这三个部分组成的。</p><p>策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。策略的创建由工厂类来完成，封装策略创建的细节。策略模式包含一组策略可选，客户端代码选择使用哪个策略，有两种确定方法：编译时静态确定和运行时动态确定。其中，“运行时动态确定”才是策略模式最典型的应用场景。</p><p>在实际的项目开发中，策略模式也比较常用。最常见的应用场景是，利用它来避免冗长的 if-else 或 switch 分支判断。不过，它的作用还不止如此。它也可以像模板模式那样，提供框架的扩展点等等。实际上，策略模式主要的作用还是解耦策略的定义、创建和使用，控制代码的复杂度，让每个部分都不至于过于复杂、代码量过多。除此之外，对于复杂代码来说，策略模式还能让其满足开闭原则，添加新策略的时候，最小化、集中化代码改动，减少引入 bug 的风险。</p><h4 id="4-职责链模式"><a href="#4-职责链模式" class="headerlink" title="4. 职责链模式"></a>4. 职责链模式</h4><p>在职责链模式中，多个处理器依次处理同一个请求。一个请求先经过 A 处理器处理，然后再把请求传递给 B 处理器，B 处理器处理完后再传递给 C 处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式。</p><p>在 GoF 的定义中，一旦某个处理器能处理这个请求，就不会继续将请求传递给后续的处理器了。当然，在实际的开发中，也存在对这个模式的变体，那就是请求不会中途终止传递，而是会被所有的处理器都处理一遍。</p><p>职责链模式常用在框架开发中，用来实现过滤器、拦截器功能，让框架的使用者在不需要修改框架源码的情况下，添加新的过滤、拦截功能。这也体现了之前讲到的对扩展开放、对修改关闭的设计原则。</p><h4 id="5-迭代器模式"><a href="#5-迭代器模式" class="headerlink" title="5. 迭代器模式"></a>5. 迭代器模式</h4><p>迭代器模式也叫游标模式，它用来遍历集合对象。这里说的“集合对象”，我们也可以叫“容器”“聚合对象”，实际上就是包含一组对象的对象，比如，数组、链表、树、图、跳表。迭代器模式主要作用是解耦容器代码和遍历代码。大部分编程语言都提供了现成的迭代器可以使用，我们不需要从零开始开发。</p><p>遍历集合一般有三种方式：for 循环、foreach 循环、迭代器遍历。后两种本质上属于一种，都可以看作迭代器遍历。相对于 for 循环遍历，利用迭代器来遍历有 3 个优势：</p><ul><li>迭代器模式封装集合内部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器提供的迭代器即可；</li><li>迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一；</li><li>迭代器模式让添加新的遍历算法更加容易，更符合开闭原则。除此之外，因为迭代器都实现自相同的接口，在开发中，基于接口而非实现编程，替换迭代器也变得更加容易。</li></ul><p>在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。针对这个问题，有两种比较干脆利索的解决方案，来避免出现这种不可预期的运行结果。一种是遍历的时候不允许增删元素，另一种是增删元素之后让遍历报错。第一种解决方案比较难实现，因为很难确定迭代器使用结束的时间点。第二种解决方案更加合理，Java 语言就是采用的这种解决方案。增删元素之后，我们选择 fail-fast 解决方式，让遍历操作直接抛出运行时异常。</p><h4 id="6-状态模式"><a href="#6-状态模式" class="headerlink" title="6. 状态模式"></a>6. 状态模式</h4><p>状态模式一般用来实现状态机，而状态机常用在游戏、工作流引擎等系统开发中。状态机又叫有限状态机，它由 3 个部分组成：状态、事件、动作。其中，事件也称为转移条件。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作。</p><p>针对状态机，我们总结了三种实现方式。</p><ul><li>第一种实现方式叫分支逻辑法。利用 if-else 或者 switch-case 分支逻辑，参照状态转移图，将每一个状态转移原模原样地直译成代码。对于简单的状态机来说，这种实现方式最简单、最直接，是首选。</li><li>第二种实现方式叫查表法。对于状态很多、状态转移比较复杂的状态机来说，查表法比较合适。通过二维数组来表示状态转移图，能极大地提高代码的可读性和可维护性。</li><li>第三种实现方式就是利用状态模式。对于状态并不多、状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能比较复杂的状态机来说，我们首选这种实现方式。</li></ul><h4 id="7-访问者模式"><a href="#7-访问者模式" class="headerlink" title="7. 访问者模式"></a>7. 访问者模式</h4><p>访问者模式允许一个或者多个操作应用到一组对象上，设计意图是解耦操作和对象本身，保持类职责单一、满足开闭原则以及应对代码的复杂性。</p><p>对于访问者模式，学习的主要难点在代码实现。而代码实现比较复杂的主要原因是，函数重载在大部分面向对象编程语言中是静态绑定的。也就是说，调用类的哪个重载函数，是在编译期间，由参数的声明类型决定的，而非运行时，根据参数的实际类型决定的。除此之外，我们还讲到 Double Disptach。如果某种语言支持 Double Dispatch，那就不需要访问者模式了。</p><p>正是因为代码实现难理解，所以，在项目中应用这种模式，会导致代码的可读性比较差。如果你的同事不了解这种设计模式，可能就会读不懂、维护不了你写的代码。所以，除非不得已，不要使用这种模式。</p><h4 id="8-备忘录模式"><a href="#8-备忘录模式" class="headerlink" title="8. 备忘录模式"></a>8. 备忘录模式</h4><p>备忘录模式也叫快照模式，具体来说，就是在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。这个模式的定义表达了两部分内容：一部分是，存储副本以便后期恢复；另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复。</p><p>备忘录模式的应用场景也比较明确和有限，主要用来防丢失、撤销、恢复等。它跟平时我们常说的“备份”很相似。两者的主要区别在于，备忘录模式更侧重于代码的设计和实现，备份更侧重架构设计或产品设计。</p><p>对于大对象的备份来说，备份占用的存储空间会比较大，备份和恢复的耗时会比较长。针对这个问题，不同的业务场景有不同的处理方式。比如，只备份必要的恢复信息，结合最新的数据来恢复；再比如，全量备份和增量备份相结合，低频全量备份，高频增量备份，两者结合来做恢复。</p><h4 id="9-命令模式"><a href="#9-命令模式" class="headerlink" title="9. 命令模式"></a>9. 命令模式</h4><p>命令模式在平时工作中并不常用，你稍微了解一下就可以。</p><p>落实到编码实现，命令模式用到最核心的实现手段，就是将函数封装成对象。我们知道，在大部分编程语言中，函数是没法作为参数传递给其他函数的，也没法赋值给变量。借助命令模式，我们将函数封装成对象，这样就可以实现把函数像对象一样使用。</p><p>命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等，这才是命令模式能发挥独一无二作用的地方。</p><h4 id="10-解释器模式"><a href="#10-解释器模式" class="headerlink" title="10. 解释器模式"></a>10. 解释器模式</h4><p>解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。实际上，这里的“语言”不仅仅指我们平时说的中、英、日、法等各种语言。从广义上来讲，只要是能承载信息的载体，我们都可以称之为“语言”，比如，古代的结绳记事、盲文、哑语、摩斯密码等。</p><p>要想了解“语言”要表达的信息，我们就必须定义相应的语法规则。这样，书写者就可以根据语法规则来书写“句子”（专业点的叫法应该是“表达式”），阅读者根据语法规则来阅读“句子”，这样才能做到信息的正确传递。而我们要讲的解释器模式，其实就是用来实现根据语法规则解读“句子”的解释器。</p><p>解释器模式的代码实现比较灵活，没有固定的模板。我们前面说过，应用设计模式主要是应对代码的复杂性，解释器模式也不例外。它的代码实现的核心思想，就是将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆分一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。</p><h4 id="11-中介模式"><a href="#11-中介模式" class="headerlink" title="11. 中介模式"></a>11. 中介模式</h4><p>中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者说依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要跟 n 个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性。</p><p>观察者模式和中介模式都是为了实现参与者之间的解耦，简化交互关系。两者的不同在于应用场景上。在观察者模式的应用场景中，参与者之间的交互比较有条理，一般都是单向的，一个参与者只有一个身份，要么是观察者，要么是被观察者。而在中介模式的应用场景中，参与者之间的交互关系错综复杂，既可以是消息的发送者、也可以同时是消息的接收者。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客时间 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《一线数据库工程师带你深入理解MySQL》学习笔记</title>
      <link href="yi-xian-shu-ju-ku-gong-cheng-shi-dai-ni-shen-ru-li-jie-mysql-xue-xi-bi-ji/"/>
      <url>yi-xian-shu-ju-ku-gong-cheng-shi-dai-ni-shen-ru-li-jie-mysql-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<hr><p>第1章 SQL优化</p><h2 id="01-开篇词"><a href="#01-开篇词" class="headerlink" title="01 开篇词"></a><strong>01 开篇词</strong></h2><h3 id="3-提升-MySQL-水平的方式"><a href="#3-提升-MySQL-水平的方式" class="headerlink" title="3 提升 MySQL 水平的方式"></a>3 提升 MySQL 水平的方式</h3><p>如果你没有 MySQL 的基础，建议可以看下面两本书籍，看完之后，可以简单处理一些优化：</p><ul><li>《MySQL 必知必会》：主要讲 SQL 的写法；</li><li>《深入浅出 MySQL》：比较全面的讲解了 MySQL 的基础知识，也涉及了一些优化。</li></ul><p>如果已经对 MySQL 比较熟悉了，可以看下面的书籍，你会对索引和锁以及事务等有全新的看法：</p><ul><li>《高性能 MySQL》：里面讲了很多 MySQL 优化技巧；</li><li>《MySQL 技术内幕》：讲解了很多 MySQL 原理，强力推荐给想深入学习 MySQL 的同学；</li><li>《MySQL 内核：InnoDB 存储引擎》：想深入研究 MySQL 内核及原理的可以看看；</li><li>《MySQL 运维内参》：对 MySQL 源码感兴趣，可以入手；</li><li>《MySQL Internals Manual》<a href="https://dev.mysql.com/doc/internals/en/">https://dev.mysql.com/doc/internals/en/</a> ；</li><li>《MySQL 5.7 Reference Manual》<a href="https://dev.mysql.com/doc/refman/5.7/en/">https://dev.mysql.com/doc/refman/5.7/en/</a> 。</li></ul><h3 id="4-学习本专栏前的提醒"><a href="#4-学习本专栏前的提醒" class="headerlink" title="4 学习本专栏前的提醒"></a>4 学习本专栏前的提醒</h3><p><strong>本专栏默认使用的 MySQL 版本为 5.7.21，事务隔离级别为 RR，表的存储引擎为 InnoDB。</strong></p><h2 id="02-快速学会分析SQL执行效率（上）"><a href="#02-快速学会分析SQL执行效率（上）" class="headerlink" title="02 快速学会分析SQL执行效率（上）"></a><strong>02 快速学会分析SQL执行效率（上）</strong></h2><h3 id="1-定位慢-SQL"><a href="#1-定位慢-SQL" class="headerlink" title="1 定位慢 SQL"></a>1 定位慢 SQL</h3><h4 id="1-1-通过慢查询日志"><a href="#1-1-通过慢查询日志" class="headerlink" title="1.1 通过慢查询日志"></a>1.1 通过慢查询日志</h4><p>MySQL 的慢查询日志用来记录在 MySQL 中响应时间超过参数 long_query_time（单位秒，默认值 10）设置的值并且扫描记录数不小于 min_examined_row_limit（默认值0）的语句。</p><blockquote><p>默认情况下，慢查询日志中不会记录管理语句，可通过设置 log_slow_admin_statements = on 让管理语句中的慢查询也会记录到慢查询日志中。</p><p>默认情况下，也不会记录查询时间不超过 long_query_time 但是不使用索引的语句，可通过配置log_queries_not_using_indexes = on 让不使用索引的 SQL 都被记录到慢查询日志中（即使查询时间没超过 long_query_time 配置的值）。</p></blockquote><p>使用慢查询日志，一般分为三步：</p><ol><li><p>开启慢查询日志</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">set</span> <span class="token keyword">global</span> slow_query_log <span class="token operator">=</span> <span class="token keyword">on</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>设置慢查询阀值</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">set</span> <span class="token keyword">global</span> long_query_time <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>确定慢查询日志路径</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">global</span> variables <span class="token operator">like</span> <span class="token string">"datadir"</span><span class="token punctuation">;</span> <span class="token comment">/* 慢查询日志的目录 */</span><span class="token keyword">show</span> <span class="token keyword">global</span> variables <span class="token operator">like</span> <span class="token string">"slow_query_log_file"</span><span class="token punctuation">;</span>  <span class="token comment">/* 慢查询日志的文件名 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h4 id="1-2-通过-show-processlist"><a href="#1-2-通过-show-processlist" class="headerlink" title="1.2 通过 show processlist"></a>1.2 通过 show processlist</h4><p>有时慢查询正在执行，已经导致数据库负载偏高了，而由于慢查询还没执行完，因此慢查询日志还看不到任何语句。此时可以使用 <code>show processlist</code> 命令判断正在执行的慢查询。 <code>show processlist</code> 显示哪些线程正在运行。如果有 PROCESS 权限，则可以看到所有线程。否则，只能看到当前会话的线程。</p><blockquote><p>如果不使用 FULL 关键字，在 info 字段中只显示每个语句的前 100 个字符，如果想看语句的全部内容可以使用 full 修饰（<code>show full processlist</code>）。</p></blockquote><h3 id="2-使用-explain-分析慢查询"><a href="#2-使用-explain-分析慢查询" class="headerlink" title="2 使用 explain 分析慢查询"></a>2 使用 explain 分析慢查询</h3><p>为了便于理解，先创建两张测试表</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> muke<span class="token punctuation">;</span>           <span class="token comment">/* 创建测试使用的database，名为muke */</span><span class="token keyword">use</span> muke<span class="token punctuation">;</span>                       <span class="token comment">/* 使用muke这个database */</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t1<span class="token punctuation">;</span>        <span class="token comment">/* 如果表t1存在则删除表t1 */</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t1<span class="token punctuation">`</span> <span class="token punctuation">(</span>             <span class="token comment">/* 创建表t1 */</span>    <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">auto_increment</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>create_time<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'记录创建时间'</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>update_time<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'记录更新时间'</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_a<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_b<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>b<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">procedure</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> insert_t1<span class="token punctuation">;</span> <span class="token comment">/* 如果存在存储过程insert_t1，则删除 */</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">procedure</span> insert_t1<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">/* 创建存储过程insert_t1 */</span><span class="token keyword">begin</span>    <span class="token keyword">declare</span> i <span class="token keyword">int</span><span class="token punctuation">;</span>                    <span class="token comment">/* 声明变量i */</span>    <span class="token keyword">set</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>                          <span class="token comment">/* 设置i的初始值为1 */</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token keyword">do</span>                  <span class="token comment">/* 对满足i&lt;=1000的值进行while循环 */</span>        <span class="token keyword">insert</span> <span class="token keyword">into</span> t1<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 写入表t1中a、b两个字段，值都为i当前的值 */</span>        <span class="token keyword">set</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                      <span class="token comment">/* 将i加1 */</span>    <span class="token keyword">end</span> <span class="token keyword">while</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span>                 <span class="token comment">/* 创建批量写入1000条数据到表t1的存储过程insert_t1 */</span><span class="token keyword">call</span> insert_t1<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">/* 运行存储过程insert_t1 */</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t2<span class="token punctuation">;</span>    <span class="token comment">/* 如果表t2存在则删除表t2 */</span><span class="token keyword">create</span> <span class="token keyword">table</span> t2 <span class="token operator">like</span> t1<span class="token punctuation">;</span>    <span class="token comment">/* 创建表t2，表结构与t1一致 */</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t2 <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1<span class="token punctuation">;</span>   <span class="token comment">/* 将表t1的数据导入到t2 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面尝试使用 explain 分析一条 SQL，例子如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> b<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>得到</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref   | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+|  1 | SIMPLE      | t1    | NULL       | ref  | idx_b         | idx_b | 5       | const |    1 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Explain 的结果各字段解释如下（加粗的列为需要重点关注的项）：</p><div class="table-container"><table><thead><tr><th style="text-align:left">列名</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">id</td><td style="text-align:left">查询编号</td></tr><tr><td style="text-align:left"><strong>select_type</strong></td><td style="text-align:left">查询类型：显示本行是简单还是复杂查询</td></tr><tr><td style="text-align:left">table</td><td style="text-align:left">涉及到的表</td></tr><tr><td style="text-align:left">partitions</td><td style="text-align:left">匹配的分区：查询将匹配记录所在的分区。仅当使用 partition 关键字时才显示该列。对于非分区表，该值为 NULL。</td></tr><tr><td style="text-align:left"><strong>type</strong></td><td style="text-align:left">本次查询的表连接类型</td></tr><tr><td style="text-align:left">possible_keys</td><td style="text-align:left">可能选择的索引</td></tr><tr><td style="text-align:left"><strong>key</strong></td><td style="text-align:left">实际选择的索引</td></tr><tr><td style="text-align:left">key_len</td><td style="text-align:left">被选择的索引长度：一般用于判断联合索引有多少列被选择了</td></tr><tr><td style="text-align:left">ref</td><td style="text-align:left">与索引比较的列</td></tr><tr><td style="text-align:left"><strong>rows</strong></td><td style="text-align:left">预计需要扫描的行数，对 InnoDB 来说，这个值是估值，并不一定准确</td></tr><tr><td style="text-align:left">filtered</td><td style="text-align:left">按条件筛选的行的百分比</td></tr><tr><td style="text-align:left"><strong>Extra</strong></td><td style="text-align:left">附加信息</td></tr></tbody></table></div><p>这里介绍几个比较重要列常包含的值：</p><h4 id="2-1-select-type"><a href="#2-1-select-type" class="headerlink" title="2.1 select_type"></a>2.1 select_type</h4><div class="table-container"><table><thead><tr><th style="text-align:left">select_type 的值</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">SIMPLE</td><td style="text-align:left">简单查询(不使用关联查询或子查询)</td></tr><tr><td style="text-align:left">PRIMARY</td><td style="text-align:left">如果包含关联查询或者子查询，则最外层的查询部分标记为primary</td></tr><tr><td style="text-align:left">UNION</td><td style="text-align:left">联合查询中第二个及后面的查询</td></tr><tr><td style="text-align:left">DEPENDENT UNION</td><td style="text-align:left">满足依赖外部的关联查询中第二个及以后的查询</td></tr><tr><td style="text-align:left">UNION RESULT</td><td style="text-align:left">联合查询的结果</td></tr><tr><td style="text-align:left">SUBQUERY</td><td style="text-align:left">子查询中的第一个查询</td></tr><tr><td style="text-align:left">DEPENDENT SUBQUERY</td><td style="text-align:left">子查询中的第一个查询，并且依赖外部查询</td></tr><tr><td style="text-align:left">DERIVED</td><td style="text-align:left">用到派生表的查询</td></tr><tr><td style="text-align:left">MATERIALIZED</td><td style="text-align:left">被物化的子查询</td></tr><tr><td style="text-align:left">UNCACHEABLE SUBQUERY</td><td style="text-align:left">一个子查询的结果不能被缓存，必须重新评估外层查询的每一行</td></tr><tr><td style="text-align:left">UNCACHEABLE UNION</td><td style="text-align:left">关联查询第二个或后面的语句属于不可缓存的子查询</td></tr></tbody></table></div><h4 id="2-2-type"><a href="#2-2-type" class="headerlink" title="2.2 type"></a>2.2 type</h4><div class="table-container"><table><thead><tr><th style="text-align:left">type的值</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">system</td><td style="text-align:left">查询对象表只有一行数据,且只能用于 MyISAM 和 Memory 引擎的表，这是最好的情况</td></tr><tr><td style="text-align:left">const</td><td style="text-align:left">基于主键或唯一索引查询，最多返回一条结果</td></tr><tr><td style="text-align:left">eq_ref</td><td style="text-align:left">表连接时基于主键或非 NULL 的唯一索引完成扫描</td></tr><tr><td style="text-align:left">ref</td><td style="text-align:left">基于普通索引的等值查询，或者表间等值连接</td></tr><tr><td style="text-align:left">fulltext</td><td style="text-align:left">全文检索</td></tr><tr><td style="text-align:left">ref_or_null</td><td style="text-align:left">表连接类型是 ref，但进行扫描的索引列中可能包含 NULL 值</td></tr><tr><td style="text-align:left">index_merge</td><td style="text-align:left">利用多个索引</td></tr><tr><td style="text-align:left">unique_subquery</td><td style="text-align:left">子查询中使用唯一索引</td></tr><tr><td style="text-align:left">index_subquery</td><td style="text-align:left">子查询中使用普通索引</td></tr><tr><td style="text-align:left">range</td><td style="text-align:left">利用索引进行范围查询</td></tr><tr><td style="text-align:left">index</td><td style="text-align:left">全索引扫描</td></tr><tr><td style="text-align:left">ALL</td><td style="text-align:left">全表扫描</td></tr></tbody></table></div><blockquote><p><strong>上表的这些情况，查询性能从上到下依次是最好到最差。</strong></p></blockquote><h4 id="2-3-Extra"><a href="#2-3-Extra" class="headerlink" title="2.3 Extra"></a>2.3 Extra</h4><div class="table-container"><table><thead><tr><th style="text-align:left">Extra 常见的值</th><th style="text-align:left">解释</th><th style="text-align:left">例子</th></tr></thead><tbody><tr><td style="text-align:left">Using filesort</td><td style="text-align:left">将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序</td><td style="text-align:left">explain select * from t1 order by create_time;</td></tr><tr><td style="text-align:left">Using temporary</td><td style="text-align:left">需要创建一个临时表来存储结构，通常发生对没有索引的列进行 GROUP BY 时</td><td style="text-align:left">explain select * from t1 group by create_time;</td></tr><tr><td style="text-align:left">Using index</td><td style="text-align:left">使用覆盖索引</td><td style="text-align:left">explain select a from t1 where a=111;</td></tr><tr><td style="text-align:left">Using where</td><td style="text-align:left">使用 where 语句来处理结果</td><td style="text-align:left">explain select * from t1 where create_time=’2019-06-18 14:38:24’;</td></tr><tr><td style="text-align:left">Impossible WHERE</td><td style="text-align:left">对 where 子句判断的结果总是 false 而不能选择任何数据</td><td style="text-align:left">explain select * from t1 where 1&lt;0;</td></tr><tr><td style="text-align:left">Using join buffer (Block Nested Loop)</td><td style="text-align:left">关联查询中，被驱动表的关联字段没索引</td><td style="text-align:left">explain select * from t1 straight_join t2 on (t1.create_time=t2.create_time);</td></tr><tr><td style="text-align:left">Using index condition</td><td style="text-align:left">先条件过滤索引，再查数据</td><td style="text-align:left">explain select * from t1 where a &gt;900 and a like “%9”;</td></tr><tr><td style="text-align:left">Select tables optimized away</td><td style="text-align:left">使用某些聚合函数（比如 max、min）来访问存在索引的某个字段是</td><td style="text-align:left">explain select max(a) from t1;</td></tr></tbody></table></div><h2 id="03-快速学会分析SQL执行效率（下）"><a href="#03-快速学会分析SQL执行效率（下）" class="headerlink" title="03 快速学会分析SQL执行效率（下）"></a><strong>03 快速学会分析SQL执行效率（下）</strong></h2><h3 id="1-show-profile-分析慢查询"><a href="#1-show-profile-分析慢查询" class="headerlink" title="1 show profile 分析慢查询"></a>1 show profile 分析慢查询</h3><p>有时需要确定 SQL 到底慢在哪个环节，此时 explain 可能不好确定。在 MySQL 数据库中，通过 profile，能够更清楚地了解 SQL 执行过程的资源使用情况，能让我们知道到底慢在哪个环节。</p><blockquote><p>可以通过配置参数 profiling = 1 来启用 SQL 分析。该参数可以在全局和 session 级别来设置。</p></blockquote><p>使用 profile 分析慢查询的大致步骤如下：</p><h4 id="1-1-确定是否支持-profile"><a href="#1-1-确定是否支持-profile" class="headerlink" title="1.1 确定是否支持 profile"></a>1.1 确定是否支持 profile</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> @<span class="token variable">@have_profiling</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="1-2-查看-profiling-是否关闭的"><a href="#1-2-查看-profiling-是否关闭的" class="headerlink" title="1.2 查看 profiling 是否关闭的"></a>1.2 查看 profiling 是否关闭的</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> @<span class="token variable">@profiling</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="1-3-通过-set-开启-profile"><a href="#1-3-通过-set-开启-profile" class="headerlink" title="1.3 通过 set 开启 profile"></a>1.3 通过 set 开启 profile</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">set</span> profiling<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="1-4-执行-SQL-语句"><a href="#1-4-执行-SQL-语句" class="headerlink" title="1.4 执行 SQL 语句"></a>1.4 执行 SQL 语句</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> b<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="1-5-确定-SQL-的-query-id"><a href="#1-5-确定-SQL-的-query-id" class="headerlink" title="1.5 确定 SQL 的 query id"></a>1.5 确定 SQL 的 query id</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> profiles<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----------+------------+-------------------------------+| Query_ID | Duration   | Query                         |+----------+------------+-------------------------------+|        1 | 0.00982500 | select * from t1 where b=1000 |+----------+------------+-------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-6-查询-SQL-执行详情"><a href="#1-6-查询-SQL-执行详情" class="headerlink" title="1.6 查询 SQL 执行详情"></a>1.6 查询 SQL 执行详情</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> profile <span class="token keyword">for</span> query <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+--------------------------------+----------+| Status                         | Duration |+--------------------------------+----------+| starting                       | 0.001746 || Executing hook on transaction  | 0.000089 || starting                       | 0.000107 || checking permissions           | 0.000120 || Opening tables                 | 0.001553 || init                           | 0.000254 || System lock                    | 0.000276 || optimizing                     | 0.000291 || statistics                     | 0.002640 || preparing                      | 0.000235 || executing                      | 0.001847 || end                            | 0.000133 || query end                      | 0.000031 || waiting for handler commit     | 0.000090 || closing tables                 | 0.000110 || freeing items                  | 0.000242 || cleaning up                    | 0.000062 |+--------------------------------+----------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-trace-分析-SQL-优化器"><a href="#2-trace-分析-SQL-优化器" class="headerlink" title="2 trace 分析 SQL 优化器"></a>2 trace 分析 SQL 优化器</h3><p>从前面学到了 explain 可以查看 SQL 执行计划，但是无法知道它为什么做这个决策，如果想确定多种索引方案之间是如何选择的或者排序时选择的是哪种排序模式，可以使用 trace 查看优化器如何选择执行计划。</p><p>如果需要使用，先开启 trace，设置格式为 JSON，再执行需要分析的 SQL，最后查看 trace 分析结果（在 information_schema.OPTIMIZER_TRACE 中）。</p><p>开启该功能，会对 MySQL 性能有所影响，因此只建议分析问题时临时开启。</p><p>下面一起来看下 trace 的使用方法。使用讲解 explain 时创建的表t1做实验。</p><p>首先构造如下 SQL (表示取出表 t1 中 a 的值大于 900 并且 b 的值大于 910 的数据，然后按照 a 字段排序)：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> a <span class="token operator">&gt;</span><span class="token number">900</span> <span class="token operator">and</span> b <span class="token operator">&gt;</span> <span class="token number">910</span> <span class="token keyword">order</span>  <span class="token keyword">by</span> a<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们首先用 explain 分析下执行计划：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> a <span class="token operator">&gt;</span><span class="token number">900</span> <span class="token operator">and</span> b <span class="token operator">&gt;</span> <span class="token number">910</span> <span class="token keyword">order</span>  <span class="token keyword">by</span> a<span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+----------------------------------------------------+</span><span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span>  <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>   <span class="token operator">|</span> key_len <span class="token operator">|</span> ref  <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra                                              <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+----------------------------------------------------+</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> t1    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> range <span class="token operator">|</span> idx_a<span class="token punctuation">,</span>idx_b   <span class="token operator">|</span> idx_b <span class="token operator">|</span> <span class="token number">5</span>       <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span>   <span class="token number">90</span> <span class="token operator">|</span>    <span class="token number">10.00</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">index</span> condition<span class="token punctuation">;</span> <span class="token keyword">Using</span> <span class="token keyword">where</span><span class="token punctuation">;</span> <span class="token keyword">Using</span> filesort <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+----------------------------------------------------+</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上面执行计划中 key 这个字段可以看出，该语句使用的是 b 字段的索引 idx_b。实际表 t1 中，a、b 两个字段都有索引，为什么条件中有这两个索引字段却偏偏选了 b 字段的索引呢？这时就可以使用 trace 进行分析。大致步骤如下：</p><ol><li><p>开启 trace</p>  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">/* optimizer_trace="enabled=on" 表示开启 trace；end_markers_in_json=on 表示 JSON 输出开启结束标记 */</span><span class="token keyword">set</span> <span class="token keyword">session</span> optimizer_trace<span class="token operator">=</span><span class="token string">"enabled=on"</span><span class="token punctuation">,</span>end_markers_in_json<span class="token operator">=</span><span class="token keyword">on</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>执行需要分析的 SQL</p>  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> a <span class="token operator">&gt;</span><span class="token number">900</span> <span class="token operator">and</span> b <span class="token operator">&gt;</span> <span class="token number">910</span> <span class="token keyword">order</span>  <span class="token keyword">by</span> a<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查看 trace 分析结果</p>  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> information_schema<span class="token punctuation">.</span>OPTIMIZER_TRACE\G<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  结果如下：</p>  <pre class="line-numbers language-text" data-language="text"><code class="language-text">*************************** 1. row ***************************QUERY: select * from t1 where a &gt;900 and b &gt; 910 order  by a    --SQL语句TRACE: {    "steps": [        {           "join_preparation": {--SQL准备阶段               "select#": 1,               "steps": [                   {                       "expanded_query": "/* select#1 */ select `t1`.`id` AS `id`,`t1`.`a` AS `a`,`t1`.`b` AS `b`,`t1`.`create_time` AS `create_time`,`t1`.`update_time` AS `update_time` from `t1` where ((`t1`.`a` &gt; 900) and (`t1`.`b` &gt; 910)) order by `t1`.`a`"                   }               ] /* steps */           } /* join_preparation */       },        {            "join_optimization": {--SQL优化阶段                "select#": 1,                "steps": [                    {                        "condition_processing": {    --条件处理                            "condition": "WHERE",                            "original_condition": "((`t1`.`a` &gt; 900) and (`t1`.`b` &gt; 910))",        --原始条件                            "steps": [                                {                                    "transformation": "equality_propagation",                                    "resulting_condition": "((`t1`.`a` &gt; 900) and (`t1`.`b` &gt; 910))" --等值传递转换                                },                                {                                    "transformation": "constant_propagation",                                    "resulting_condition": "((`t1`.`a` &gt; 900) and (`t1`.`b` &gt; 910))"       --常量传递转换                                },                                {                                    "transformation": "trivial_condition_removal",                                    "resulting_condition": "((`t1`.`a` &gt; 900) and (`t1`.`b` &gt; 910))"        --去除没有的条件后的结构                                }                            ] /* steps */                        } /* condition_processing */                    },                    {                        "substitute_generated_columns": {                        } /* substitute_generated_columns */   --替换虚拟生成列                    },                    {                        "table_dependencies": [--表依赖详情                            {                                "table": "`t1`",                                "row_may_be_null": false,                                "map_bit": 0,                                "depends_on_map_bits": [                                ] /* depends_on_map_bits */                            }                        ] /* table_dependencies */                    },                    {                        "ref_optimizer_key_uses": [                        ] /* ref_optimizer_key_uses */                    },                    {                        "rows_estimation": [--预估表的访问成本                            {                                "table": "`t1`",                                "range_analysis": {                                    "table_scan": {                                        "rows": 1000,       --扫描行数                                        "cost": 207.1       --成本                                    } /* table_scan */,                                    "potential_range_indexes": [    --分析可能使用的索引                                        {                                            "index": "PRIMARY",                                            "usable": false,       --为false，说明主键索引不可用                                            "cause": "not_applicable"                                        },                                        {                                            "index": "idx_a",      --可能使用索引idx_a                                            "usable": true,                                            "key_parts": [                                                "a",                                                "id"                                            ] /* key_parts */                                        },                                        {                                            "index": "idx_b",      --可能使用索引idx_b                                            "usable": true,                                            "key_parts": [                                                "b",                                                "id"                                            ] /* key_parts */                                        }                                    ] /* potential_range_indexes */,                                    "setup_range_conditions": [                                    ] /* setup_range_conditions */,                                    "group_index_range": {                                        "chosen": false,                                        "cause": "not_group_by_or_distinct"                                    } /* group_index_range */,                                    "analyzing_range_alternatives": { --分析各索引的成本                                        "range_scan_alternatives": [                                            {                                                "index": "idx_a",--使用索引idx_a的成本                                                "ranges": [                                                    "900 &lt; a"--使用索引idx_a的范围                                                ] /* ranges */,                                                "index_dives_for_eq_ranges": true, --是否使用index dive（详细描述请看下方的知识扩展）                                                "rowid_ordered": false, --使用该索引获取的记录是否按照主键排序                                                "using_mrr": false,  --是否使用mrr                                                "index_only": false,    --是否使用覆盖索引                                                "rows": 100,            --使用该索引获取的记录数                                                "cost": 121.01,         --使用该索引的成本                                                "chosen": true          --可能选择该索引                                            },                                            {                                                "index": "idx_b",       --使用索引idx_b的成本                                                "ranges": [                                                    "910 &lt; b"                                                ] /* ranges */,                                                "index_dives_for_eq_ranges": true,                                                "rowid_ordered": false,                                                "using_mrr": false,                                                "index_only": false,                                                "rows": 90,                                                "cost": 109.01,                                                "chosen": true             --也可能选择该索引                                            }                                        ] /* range_scan_alternatives */,                                        "analyzing_roworder_intersect": { --分析使用索引合并的成本                                            "usable": false,                                            "cause": "too_few_roworder_scans"                                        } /* analyzing_roworder_intersect */                                    } /* analyzing_range_alternatives */,                                    "chosen_range_access_summary": {  --确认最优方法                                        "range_access_plan": {                                            "type": "range_scan",                                            "index": "idx_b",                                            "rows": 90,                                            "ranges": [                                                "910 &lt; b"                                            ] /* ranges */                                        } /* range_access_plan */,                                        "rows_for_plan": 90,                                        "cost_for_plan": 109.01,                                        "chosen": true                                    } /* chosen_range_access_summary */                                } /* range_analysis */                            }                        ] /* rows_estimation */                    },                    {                        "considered_execution_plans": [  --考虑的执行计划                            {                                "plan_prefix": [                                ] /* plan_prefix */,                                "table": "`t1`",                                "best_access_path": {          --最优的访问路径                                    "considered_access_paths": [ --决定的访问路径                                        {                                            "rows_to_scan": 90,      --扫描的行数                                            "access_type": "range",  --访问类型：为range                                            "range_details": {                                                "used_index": "idx_b"  --使用的索引为：idx_b                                            } /* range_details */,                                            "resulting_rows": 90,    --结果行数                                            "cost": 127.01,          --成本                                            "chosen": true,   --确定选择                                            "use_tmp_table": true                                        }                                    ] /* considered_access_paths */                                } /* best_access_path */,                                "condition_filtering_pct": 100,                                "rows_for_plan": 90,                                "cost_for_plan": 127.01,                                "sort_cost": 90,                                "new_cost_for_plan": 217.01,                                "chosen": true                            }                        ] /* considered_execution_plans */                    },                    {                        "attaching_conditions_to_tables": {  --尝试添加一些其他的查询条件                            "original_condition": "((`t1`.`a` &gt; 900) and (`t1`.`b` &gt; 910))",                            "attached_conditions_computation": [                            ] /* attached_conditions_computation */,                            "attached_conditions_summary": [                                {                                    "table": "`t1`",                                    "attached": "((`t1`.`a` &gt; 900) and (`t1`.`b` &gt; 910))"                                }                            ] /* attached_conditions_summary */                        } /* attaching_conditions_to_tables */                    },                    {                        "clause_processing": {                            "clause": "ORDER BY",                            "original_clause": "`t1`.`a`",                            "items": [                                {                                    "item": "`t1`.`a`"                                }                            ] /* items */,                            "resulting_clause_is_simple": true,                            "resulting_clause": "`t1`.`a`"                        } /* clause_processing */                    },                    {                        "reconsidering_access_paths_for_index_ordering": {                            "clause": "ORDER BY",                            "index_order_summary": {                                "table": "`t1`",                                "index_provides_order": false,                                "order_direction": "undefined",                                "index": "idx_b",                                "plan_changed": false                            } /* index_order_summary */                        } /* reconsidering_access_paths_for_index_ordering */                    },                    {                        "refine_plan": [          --改进的执行计划                            {                                "table": "`t1`",                                "pushed_index_condition": "(`t1`.`b` &gt; 910)",                                "table_condition_attached": "(`t1`.`a` &gt; 900)"                            }                        ] /* refine_plan */                    }                ] /* steps */            } /* join_optimization */        },        {            "join_execution": {             --SQL执行阶段                "select#": 1,                "steps": [                    {                        "filesort_information": [                            {                                "direction": "asc",                                "table": "`t1`",                                "field": "a"                            }                        ] /* filesort_information */,                        "filesort_priority_queue_optimization": {                            "usable": false,             --未使用优先队列优化排序                            "cause": "not applicable (no LIMIT)"     --未使用优先队列排序的原因是没有limit                        } /* filesort_priority_queue_optimization */,                        "filesort_execution": [                        ] /* filesort_execution */,                        "filesort_summary": {           --排序详情                            "rows": 90,                   --预计扫描的行数                            "examined_rows": 90,          --参与排序的行数                            "number_of_tmp_files": 0,     --排序过程中使用的临时文件数                            "sort_buffer_size": 115056,   --sort_buffer 的大小                            "sort_mode": "&lt;sort_key, additional_fields&gt;"   --排序模式（详解请看下方知识扩展）                        } /* filesort_summary */                    }                ] /* steps */            } /* join_execution */        }    ] /* steps */}MISSING_BYTES_BEYOND_MAX_MEM_SIZE: 0--该字段表示分析过程丢弃的文本字节大小，本例为0，说明没丢弃任何文本                    INSUFFICIENT_PRIVILEGES: 0    --查看trace的权限是否不足，0表示有权限查看trace详情1 row in set (0.00 sec)------------------------------------------------<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>关闭trace</p>  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">set</span> <span class="token keyword">session</span> optimizer_trace<span class="token operator">=</span><span class="token string">"enabled=off"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>TRACE 字段中整个文本大致分为三个过程。</p></li></ol><ul><li>准备阶段：对应文本中的 join_preparation</li><li>优化阶段：对应文本中的 join_optimization</li><li>执行阶段：对应文本中的 join_execution</li></ul><p>使用时，重点关注优化阶段和执行阶段。</p><p>由此例可以看出：</p><ul><li>在 trace 结果的 analyzing_range_alternatives 这一项可以看到：使用索引 idx_a 的成本为 121.01，使用索引 idx_b 的成本为 109.01，显然使用索引 idx_b 的成本要低些，因此优化器选择了 idx_b 索引；</li><li>在 trace 结果的 filesort_summary 这一项可以看到：排序模式为 <code>&lt;sort_key, additional_fields&gt;</code> ，表示使用的是单路排序，即一次性取出满足条件行的所有字段，然后在 sort buffer 中进行排序。</li></ul><blockquote><p>知识扩展：</p><p><strong>知识点一：MySQL 常见排序模式：</strong></p><ul><li>&lt; sort_key, rowid &gt;双路排序（又叫回表排序模式）：是首先根据相应的条件取出相应的排序字段和可以直接定位行数据的行 ID，然后在 sort buffer 中进行排序，排序完后需要再次取回其它需要的字段；</li><li>&lt; sort_key, additional_fields &gt;单路排序：是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序；</li><li>&lt; sort_key, packed_additional_fields &gt;打包数据排序模式：将 char 和 varchar 字段存到 sort buffer 中时，更加紧缩。</li></ul><p>三种排序模式比较：</p><p>第二种模式相对第一种模式，避免了二次回表，可以理解为用空间换时间。由于 sort buffer 有限，如果需要查询的数据比较大的话，会增加磁盘排序时间，效率可能比第一种方式更低。</p><p>MySQL 提供了一个参数：max_length_for_sort_data，当“排序的键值对大小” &gt; max_length_for_sort_data 时，MySQL 认为磁盘外部排序的 IO 效率不如回表的效率，会选择第一种排序模式；否则，会选择第二种模式。</p><p>第三种模式主要解决变长字符数据存储空间浪费的问题。</p><p><strong>知识点二：优化器在估计符合条件的行数时有两个选择：</strong></p><ul><li>index diver：dive 到 index 中利用索引完成元组数的估算；特点是速度慢，但可以得到精确的值；</li><li>index statistics：使用索引的统计数值，进行估算；特点是速度快，但是值不一定准确。</li></ul></blockquote><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h3><p>对比一下三种分析 SQL 方法的特点：</p><ul><li>explain：获取 MySQL 中 SQL 语句的执行计划，比如语句是否使用了关联查询、是否使用了索引、扫描行数等；</li><li>profile：可以清楚了解到SQL到底慢在哪个环节；</li><li>trace：查看优化器如何选择执行计划，获取每个可能的索引选择的代价。</li></ul><h2 id="04-条件字段有索引，为什么查询也这么慢"><a href="#04-条件字段有索引，为什么查询也这么慢" class="headerlink" title="04 条件字段有索引，为什么查询也这么慢?"></a><strong>04 条件字段有索引，为什么查询也这么慢?</strong></h2><p>下面会讲解几种有索引但是查询不走索引导致查询慢的场景。</p><h3 id="1-函数操作"><a href="#1-函数操作" class="headerlink" title="1 函数操作"></a>1 函数操作</h3><h4 id="1-1-验证对条件字段做函数操作是否能走索引"><a href="#1-1-验证对条件字段做函数操作是否能走索引" class="headerlink" title="1.1 验证对条件字段做函数操作是否能走索引"></a>1.1 验证对条件字段做函数操作是否能走索引</h4><p>首先创建测试表，建表及数据写入语句如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">use</span> muke<span class="token punctuation">;</span>                       <span class="token comment">/* 使用muke这个database */</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t1<span class="token punctuation">;</span>        <span class="token comment">/* 如果表t1存在则删除表t1 */</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t1<span class="token punctuation">`</span> <span class="token punctuation">(</span>             <span class="token comment">/* 创建表t1 */</span>    <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>c<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_a<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_b<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>b<span class="token punctuation">`</span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_c<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>c<span class="token punctuation">`</span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span>  <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">procedure</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> insert_t1<span class="token punctuation">;</span> <span class="token comment">/* 如果存在存储过程insert_t1，则删除 */</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">procedure</span> insert_t1<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">/* 创建存储过程insert_t1 */</span><span class="token keyword">begin</span>    <span class="token keyword">declare</span> i <span class="token keyword">int</span><span class="token punctuation">;</span>                    <span class="token comment">/* 声明变量i */</span>    <span class="token keyword">set</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>                          <span class="token comment">/* 设置i的初始值为1 */</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token keyword">do</span>                 <span class="token comment">/* 对满足i&lt;=10000的值进行while循环 */</span>        <span class="token keyword">insert</span> <span class="token keyword">into</span> t1<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* 写入表t1中a、b两个字段，值都为i当前的值 */</span>        <span class="token keyword">set</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                        <span class="token comment">/* 将i加1 */</span>    <span class="token keyword">end</span> <span class="token keyword">while</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span><span class="token keyword">call</span> insert_t1<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">/* 运行存储过程insert_t1 */</span><span class="token keyword">update</span> t1 <span class="token keyword">set</span> c <span class="token operator">=</span> <span class="token string">'2019-05-22 00:00:00'</span><span class="token punctuation">;</span>  <span class="token comment">/* 更新表t1的c字段，值都为'2019-05-22 00:00:00' */</span><span class="token keyword">update</span> t1 <span class="token keyword">set</span> c <span class="token operator">=</span> <span class="token string">'2019-05-21 00:00:00'</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">10000</span><span class="token punctuation">;</span> <span class="token comment">/* 将id为10000的行的c字段改为与其它行都不一样的数据，以便后面实验使用 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于上面创建的测试表，比如要查询测试表 t1 单独某一天的所有数据，SQL如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> <span class="token keyword">date</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token string">'2019-05-21'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以使用第 2 节学习的 explain 来分析这条SQL的执行计划，分析结果如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra       |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10302 |   100.00 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看图中的执行计划，type 为 ALL，key 字段结果为 NULL，因此知道该 SQL 是没走索引的全表扫描。</p><p>原因：对条件字段做函数操作走不了索引。</p><h4 id="1-2-对条件字段做函数操作不走索引的原因"><a href="#1-2-对条件字段做函数操作不走索引的原因" class="headerlink" title="1.2 对条件字段做函数操作不走索引的原因"></a>1.2 对条件字段做函数操作不走索引的原因</h4><p>该例中 c 字段普通索引的 B+ 索引树如下：</p><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/c字段普通索引的B+索引树.png" alt="c字段普通索引的B+索引树"></p><p>根据上面结构可以看到，索引树中存储的是列的实际值和主键值。如果拿 ‘2019-05-21’ 去匹配，将无法定位到索引树中的值。因此放弃走索引，而选择全表扫描。</p><h4 id="1-3-函数操作的-SQL-优化"><a href="#1-3-函数操作的-SQL-优化" class="headerlink" title="1.3 函数操作的 SQL 优化"></a>1.3 函数操作的 SQL 优化</h4><p>因此如果需要优化的话，改成 c 字段实际值相匹配的形式。因为 SQL 的目的是查询 2019-05-21 当天所有的记录，因此可以改成范围查询，如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> c<span class="token operator">&gt;=</span><span class="token string">'2019-05-21 00:00:00'</span> <span class="token operator">and</span> c<span class="token operator">&lt;=</span><span class="token string">'2019-05-21 23:59:59'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再用 explain 分析下执行计划的结果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type  | possible_keys | key   | key_len | ref  | rows | filtered | Extra                 |+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+|  1 | SIMPLE      | t1    | NULL       | range | idx_c         | idx_c | 5       | NULL |    1 |   100.00 | Using index condition |+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-隐式转换"><a href="#2-隐式转换" class="headerlink" title="2 隐式转换"></a><strong>2 隐式转换</strong></h3><blockquote><p>什么时隐式转换？</p><p>当操作符与不同类型的操作对象一起使用时，就会发生类型转换以使操作兼容。某些转换是隐式的。</p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/type-conversion.html">关于隐式转换详情请参考MySQL官方手册</a></p></blockquote><p>隐式转换估计是很多 MySQL 使用者踩过的坑，比如联系方式字段。由于有时电话号码带加、减等特殊字符，有时需要以 0 开头，因此一般设计表时会使用 varchar 类型存储，并且会经常做为条件来查询数据，所以会添加索引。</p><p>而有时遇到需要按照手机号码条件（比如 11111111111）去查询数据时，因为查询者看到条件是一串数字，而忽视表中对应手机号字段是 varchar 类型，因此写出了如下不合理的SQL：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> user_name<span class="token punctuation">,</span>tele_phone <span class="token keyword">from</span> user_info <span class="token keyword">where</span> tele_phone <span class="token operator">=</span><span class="token number">11111111111</span><span class="token punctuation">;</span> <span class="token comment">/* SQL 1 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-2-验证隐式转换是否能走索引"><a href="#2-2-验证隐式转换是否能走索引" class="headerlink" title="2.2 验证隐式转换是否能走索引"></a>2.2 验证隐式转换是否能走索引</h4><p>实验过程分为：先创建测试表并写入数据；测试隐式转换的查询并查看执行计划；测试正常查询，再查看执行计划。</p><p>比如我们要查询 a 字段等于 1000 的值，SQL如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>看下 explain 结果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra       |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+|  1 | SIMPLE      | t1    | NULL       | ALL  | idx_a         | NULL | NULL    | NULL | 10302 |    10.00 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 type 这列可以看到是最差的情况 ALL（全表扫描）， 通过 key 这列可以看到没走 a 字段的索引，通过 rows 这列可以看到进行了全表扫描。</p><h4 id="2-3-不走索引的原因"><a href="#2-3-不走索引的原因" class="headerlink" title="2.3 不走索引的原因"></a>2.3 不走索引的原因</h4><p>a 字段类型是 varchar(20)，而语句中 a 字段条件值没加单引号，导致 MySQL 内部会先把a转换成int型，再去做判断，相当于实际执行的 SQL 语句如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> cast<span class="token punctuation">(</span>a <span class="token keyword">as</span> signed <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因此又回到上面说的：<strong>对索引字段做函数操作时，优化器会放弃使用索引</strong>。</p><h4 id="2-4-隐式转换的-SQL-优化"><a href="#2-4-隐式转换的-SQL-优化" class="headerlink" title="2.4 隐式转换的 SQL 优化"></a>2.4 隐式转换的 SQL 优化</h4><p>索引字符串列条件添加单引号，查看执行计划：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token string">'1000'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref   | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+|  1 | SIMPLE      | t1    | NULL       | ref  | idx_a         | idx_a | 83      | const |    1 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 type 这列，可以看到是 ref（基于普通索引的等值查询，比 ALL 性能好很多），通过key这列，可以看到已经走了 a 字段的索引，通过rows这列可以看到通过索引查询后就扫描了一行。</p><h3 id="3-模糊查询"><a href="#3-模糊查询" class="headerlink" title="3 模糊查询"></a><strong>3 模糊查询</strong></h3><h4 id="3-1-分析模糊查询"><a href="#3-1-分析模糊查询" class="headerlink" title="3.1 分析模糊查询"></a>3.1 分析模糊查询</h4><p>很多时候我们想根据某个字段的某几个关键字查询数据，比如会有如下 SQL：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> a <span class="token operator">like</span> <span class="token string">'%1111%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>实际这种情况无法走索引，看下执行计划：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra       |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10302 |    11.11 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重点留意type、key、rows、Extra，发现是全表扫描。</p><h4 id="3-2-模糊查询优化建议"><a href="#3-2-模糊查询优化建议" class="headerlink" title="3.2 模糊查询优化建议"></a>3.2 模糊查询优化建议</h4><p>修改业务，让模糊查询必须包含条件字段前面的值，然后落到数据库的查询为：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> a <span class="token operator">like</span> <span class="token string">'1111%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这种写法是可以用到索引的，explain分析如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type  | possible_keys | key   | key_len | ref  | rows | filtered | Extra                 |+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+|  1 | SIMPLE      | t1    | NULL       | range | idx_a         | idx_a | 83      | NULL |    1 |   100.00 | Using index condition |+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>如果条件只知道中间的值，需要模糊查询去查，那就建议使用ElasticSearch或其它搜索服务器。</p></blockquote><h3 id="4-范围查询"><a href="#4-范围查询" class="headerlink" title="4 范围查询"></a><strong>4 范围查询</strong></h3><h4 id="4-1-构造不能使用索引的范围查询"><a href="#4-1-构造不能使用索引的范围查询" class="headerlink" title="4.1 构造不能使用索引的范围查询"></a>4.1 构造不能使用索引的范围查询</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> b<span class="token operator">&gt;=</span><span class="token number">1</span> <span class="token operator">and</span> b <span class="token operator">&lt;=</span><span class="token number">100000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>看下这条 SQL 的执行计划：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra       |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+|  1 | SIMPLE      | t1    | NULL       | ALL  | idx_b         | NULL | NULL    | NULL | 10302 |    97.07 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发现并不能走b字段的索引。</p><p>原因：优化器会根据检索比例、表大小、I/O块大小等进行评估是否使用索引。比如单次查询的数据量过大，优化器将不走索引。</p><h4 id="4-2-优化范围查询"><a href="#4-2-优化范围查询" class="headerlink" title="4.2 优化范围查询"></a>4.2 优化范围查询</h4><p>降低单次查询范围，分多次查询：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> b<span class="token operator">&gt;=</span><span class="token number">1</span> <span class="token operator">and</span> b <span class="token operator">&lt;=</span><span class="token number">1000</span><span class="token punctuation">;</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> b<span class="token operator">&gt;=</span><span class="token number">1001</span> <span class="token operator">and</span> b <span class="token operator">&lt;=</span><span class="token number">2000</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>查看执行计划（就只看第一条的，第二条同理）：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type  | possible_keys | key   | key_len | ref  | rows | filtered | Extra                 |+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+|  1 | SIMPLE      | t1    | NULL       | range | idx_b         | idx_b | 5       | NULL | 1000 |   100.00 | Using index condition |+----+-------------+-------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，降低查询范围后，能正常使用索引。</p><blockquote><p>经验分享：</p><p>实际这种范围查询而导致使用不了索引的场景经常出现，比如按照时间段抽取全量数据，每条SQL抽取一个月的；或者某张业务表历史数据的删除。遇到此类操作时，<strong>应该在执行之前对SQL做explain分析，确定能走索引，再进行操作</strong>，否则不但可能导致操作缓慢，在做更新或者删除时，甚至会导致表所有记录锁住，十分危险。</p></blockquote><h3 id="5-计算操作"><a href="#5-计算操作" class="headerlink" title="5 计算操作"></a>5 计算操作</h3><h4 id="5-1-查询条件进行计算操作的-SQL-执行效率"><a href="#5-1-查询条件进行计算操作的-SQL-执行效率" class="headerlink" title="5.1 查询条件进行计算操作的 SQL 执行效率"></a>5.1 查询条件进行计算操作的 SQL 执行效率</h4><p>有时我们与有对条件字段做计算操作的需求，在使用 SQL 查询时，就应该小心了。先看下例：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> b<span class="token operator">-</span><span class="token number">1</span> <span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看执行计划：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra       |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10302 |   100.00 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>原因：对索引字段做运算将使用不了索引。</p></blockquote><h4 id="5-2-计算操作的-SQL-优化"><a href="#5-2-计算操作的-SQL-优化" class="headerlink" title="5.2 计算操作的 SQL 优化"></a>5.2 计算操作的 SQL 优化</h4><p>将计算操作放在等号后面：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> b <span class="token operator">=</span><span class="token number">1000</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看执行计划：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref   | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+|  1 | SIMPLE      | t1    | NULL       | ref  | idx_b         | idx_b | 5       | const |    1 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发现将计算操作放在等号后，能正常使用索引。</p><blockquote><p>经验分享：</p><p><strong>一般需要对条件字段做计算时，建议通过程序代码实现，而不是通过MySQL实现。如果在MySQL中计算的情况避免不了，那必须把计算放在等号后面。</strong></p></blockquote><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h3><p>在写 SQL 时应该注意这些点：</p><ul><li>应该避免隐式转换</li><li>like查询不能以%开头</li><li>范围查询时，包含的数据比例不能太大</li><li>不建议对条件字段做运算及函数操作</li></ul><p>本节涉及到的一些SQL优化如下图：</p><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/MySQL条件字段有索引但是不走索引的场景.png" alt="MySQL条件字段有索引但是不走索引的场景"></p><h2 id="05-如何优化数据导入？"><a href="#05-如何优化数据导入？" class="headerlink" title="05 如何优化数据导入？"></a><strong>05 如何优化数据导入？</strong></h2><h3 id="1-一次插入多行的值"><a href="#1-一次插入多行的值" class="headerlink" title="1 一次插入多行的值"></a>1 一次插入多行的值</h3><p>插入行所需的时间由以下因素决定（参考MySQL 5.7参考手册：<a href="https://dev.mysql.com/doc/refman/5.7/en/insert-optimization.html">8.2.4.1优化INSERT语句</a>）</p><ul><li>连接：30%</li><li>向服务器发送查询：20%</li><li>解析查询：20%</li><li>插入行：10% * 行的大小</li><li>插入索引：10% * 索引数</li><li>结束：10%</li></ul><p>可发现大部分时间耗费在客户端与服务端通信的时间，因此可以使用 insert 包含多个值来减少客户端和服务器之间的通信。</p><h3 id="2-关闭自动提交"><a href="#2-关闭自动提交" class="headerlink" title="2 关闭自动提交"></a>2 关闭自动提交</h3><p>Autocommit 开启时会为每个插入执行提交。可以在InnoDB导入数据时，关闭自动提交。</p><h3 id="3-参数调整"><a href="#3-参数调整" class="headerlink" title="3 参数调整"></a>3 参数调整</h3><p>影响MySQL写入速度的主要两个参数：innodb_flush_log_at_trx_commit、sync_binlog。</p><h4 id="3-1-参数解释"><a href="#3-1-参数解释" class="headerlink" title="3.1 参数解释"></a>3.1 参数解释</h4><p>innodb_flush_log_at_trx_commit：控制重做日志刷新到磁盘的策略，有0 、1和2三种值。</p><ul><li>0：master线程每秒把redo log buffer写到操作系统缓存，再刷到磁盘；</li><li>1：每次提交事务都将redo log buffer写到操作系统缓存，再刷到磁盘；</li><li>2：每次事务提交都将redo log buffer写到操作系统缓存，由操作系统来管理刷盘。</li></ul><p>sync_binlog：控制binlog的刷盘时机，可配置0、1或者大于1的数字。</p><ul><li>0：二进制日志从不同步到磁盘，依赖OS刷盘机制；</li><li>1：二进制日志每次提交都会刷盘；</li><li>n(n&gt;1) : 每n次提交落盘一次。</li></ul><h2 id="06-让order-by、group-by查询更快"><a href="#06-让order-by、group-by查询更快" class="headerlink" title="06 让order by、group by查询更快"></a><strong>06 让order by、group by查询更快</strong></h2><h3 id="1-order-by-原理"><a href="#1-order-by-原理" class="headerlink" title="1 order by 原理"></a>1 order by 原理</h3><p>在优化 order by 语句之前，需要先了解 MySQL 中排序的相关知识点和原理，为了方便讲解过程举例说明，首先创建一张测试表，建表及数据写入语句如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">use</span> muke<span class="token punctuation">;</span>                 <span class="token comment">/* 使用muke这个database */</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t1<span class="token punctuation">;</span>  <span class="token comment">/* 如果表t1存在则删除表t1 */</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t1<span class="token punctuation">`</span> <span class="token punctuation">(</span>      <span class="token comment">/* 创建表t1 */</span>    <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>c<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>d<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_a_b<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>b<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_c<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>c<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4 <span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">procedure</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> insert_t1<span class="token punctuation">;</span> <span class="token comment">/* 如果存在存储过程insert_t1，则删除 */</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">procedure</span> insert_t1<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">/* 创建存储过程insert_t1 */</span><span class="token keyword">begin</span>    <span class="token keyword">declare</span> i <span class="token keyword">int</span><span class="token punctuation">;</span>                  <span class="token comment">/* 声明变量i */</span>    <span class="token keyword">set</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>                        <span class="token comment">/* 设置i的初始值为1 */</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token keyword">do</span>      <span class="token comment">/* 对满足i&lt;=10000的值进行while循环 */</span>        <span class="token keyword">insert</span> <span class="token keyword">into</span> t1<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 写入表t1中a、b两个字段，值都为i当前的值 */</span>        <span class="token keyword">set</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                       <span class="token comment">/* 将i加1 */</span>    <span class="token keyword">end</span> <span class="token keyword">while</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span><span class="token keyword">call</span> insert_t1<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">/* 运行存储过程insert_t1 */</span><span class="token keyword">update</span> t1 <span class="token keyword">set</span> a<span class="token operator">=</span><span class="token number">1000</span> <span class="token keyword">where</span> id <span class="token operator">&gt;</span><span class="token number">9000</span><span class="token punctuation">;</span>    <span class="token comment">/* 将id大于9000的行的a字段更新为1000 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-1-MySQL-的排序方式"><a href="#1-1-MySQL-的排序方式" class="headerlink" title="1.1 MySQL 的排序方式"></a>1.1 MySQL 的排序方式</h4><p>按照排序原理分，MySQL 排序方式分两种：</p><ul><li>通过有序索引直接返回有序数据</li><li>通过 Filesort 进行的排序</li></ul><blockquote><p><strong>怎么确定某条排序的 SQL 所使用的排序方式？</strong></p><p>使用 explain 来查看该排序 SQL 的执行计划，重点关注 Extra 字段：</p><p>如果该字段里显示是 Using index，则表示是通过有序索引直接返回有序数据。</p><p>如果该字段里显示是 Using filesort，则表示该 SQL 是通过 Filesort 进行的排序。</p></blockquote><h4 id="1-2-Filesort-是在内存中还是在磁盘中完成排序的？"><a href="#1-2-Filesort-是在内存中还是在磁盘中完成排序的？" class="headerlink" title="1.2 Filesort 是在内存中还是在磁盘中完成排序的？"></a>1.2 Filesort 是在内存中还是在磁盘中完成排序的？</h4><p>MySQL 中的 Filesort 并不一定是在磁盘文件中进行排序的，也有可能在内存中排序，内存排序还是磁盘排序取决于排序的数据大小和 sort_buffer_size 配置的大小。</p><ul><li>如果 “排序的数据大小” &lt; sort_buffer_size: 内存排序</li><li>如果 “排序的数据大小” &gt; sort_buffer_size: 磁盘排序</li></ul><blockquote><p><strong>怎么确定使用 Filesort 排序的 SQL 是在内存还是在磁盘中进行的排序操作？</strong></p><p>此时就可以使用 trace 进行分析，重点关注 number_of_tmp_files，如果等于 0，则表示排序过程没使用临时文件，在内存中就能完成排序；如果大于0，则表示排序过程中使用了临时文件。</p></blockquote><h4 id="1-3-Filesort-下的排序模式"><a href="#1-3-Filesort-下的排序模式" class="headerlink" title="1.3 Filesort 下的排序模式"></a>1.3 Filesort 下的排序模式</h4><p>Filesort 下的排序模式有三种，具体介绍如下：（参考<a href="https://dev.mysql.com/doc/refman/5.7/en/order-by-optimization.html">《MySQL 5.7 Reference Manual》8.2.1.14 ORDER BY Optimization</a>）</p><ul><li>&lt; sort_key, rowid &gt;双路排序（又叫回表排序模式）：是首先根据相应的条件取出相应的排序字段和可以直接定位行数据的行 ID，然后在 sort buffer 中进行排序，排序完后需要再次取回其它需要的字段；</li><li>&lt; sort_key, additional_fields &gt;单路排序：是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序；</li><li>&lt; sort_key, packed_additional_fields &gt;打包数据排序模式：与单路排序相似，区别是将 char 和 varchar 字段存到 sort buffer 中时，更加紧缩。</li></ul><p>因为打包数据排序模式是单路排序的一种升级模式，因此重点探讨双路排序和单路排序的区别。MySQL 通过比较系统变量 max_length_for_sort_data 的大小和需要查询的字段总大小来判断使用哪种排序模式。</p><ul><li>如果 max_length_for_sort_data 比查询字段的总长度大，那么使用 &lt; sort_key, additional_fields &gt;排序模式；</li><li>如果 max_length_for_sort_data 比查询字段的总长度小，那么使用 <sort_key, rowid=""> 排序模式。</sort_key,></li></ul><p>为什么要添加 max_length_for_sort_data 这个参数让排序使用不同的排序模式呢？</p><p>接下来，我们一起分析下 max_length_for_sort_data 的重要性。比如下面这条 SQL：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> a<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d <span class="token keyword">from</span> t1 <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">1000</span> <span class="token keyword">order</span> <span class="token keyword">by</span> d<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们先看<strong>单路排序</strong>的详细过程：</p><ol><li>从索引 a 找到第一个满足 a = 1000 条件的主键 id</li><li>根据主键 id 取出整行，<strong>取出 a、c、d 三个字段的值，存入 sort_buffer 中</strong></li><li>从索引 a 找到下一个满足 a = 1000 条件的主键 id</li><li>重复步骤 2、3 直到不满足 a = 1000</li><li>对 sort_buffer 中的数据按照字段 d 进行排序</li><li>返回结果给客户端</li></ol><p>我们再看下<strong>双路排序</strong>的详细过程：</p><ol><li>从索引 a 找到第一个满足 a = 1000 的主键 id</li><li>根据主键 id 取出整行，<strong>把排序字段 d 和主键 id 这两个字段放到 sort buffer 中</strong></li><li>从索引 a 取下一个满足 a = 1000 记录的主键 id</li><li>重复 3、4 直到不满足 a = 1000</li><li>对 sort_buffer 中的字段 d 和主键 id 按照字段 d 进行排序</li><li>遍历排序好的 id 和字段 d，按照 id 的值回到原表中取出 a、c、d 三个字段的值返回给客户端</li></ol><p>其实对比两个排序模式，单路排序会把所有需要查询的字段都放到 sort buffer 中，而双路排序只会把主键和需要排序的字段放到 sort buffer 中进行排序，然后再通过主键回到原表查询需要的字段。</p><h3 id="2-order-by-优化"><a href="#2-order-by-优化" class="headerlink" title="2 order by 优化"></a>2 order by 优化</h3><h4 id="2-1-添加合适索引"><a href="#2-1-添加合适索引" class="headerlink" title="2.1 添加合适索引"></a>2.1 添加合适索引</h4><h5 id="2-1-1-排序字段添加索引"><a href="#2-1-1-排序字段添加索引" class="headerlink" title="2.1.1 排序字段添加索引"></a>2.1.1 排序字段添加索引</h5><p>首先我们看下对 d 字段（没有索引）进行排序的执行计划：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> d<span class="token punctuation">,</span>id <span class="token keyword">from</span> t1 <span class="token keyword">order</span> <span class="token keyword">by</span> d<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra          |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10236 |   100.00 | Using filesort |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发现使用的是 filesort（关注 Extra 字段）。</p><p>再看些对 c 字段（有索引）进行排序的执行计划：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> c<span class="token punctuation">,</span>id <span class="token keyword">from</span> t1 <span class="token keyword">order</span> <span class="token keyword">by</span> c<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+| id | select_type | table | partitions | type  | possible_keys | key   | key_len | ref  | rows  | filtered | Extra       |+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+|  1 | SIMPLE      | t1    | NULL       | index | NULL          | idx_c | 5       | NULL | 10236 |   100.00 | Using index |+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，根据有索引的字段排序，在 Extra 中显示的就为 Using index，表示使用的是索引排序。</p><p><strong>因此可以在排序字段上添加索引来优化排序语句。</strong></p><h5 id="2-1-2-多个字段排序优化"><a href="#2-1-2-多个字段排序优化" class="headerlink" title="2.1.2 多个字段排序优化"></a>2.1.2 多个字段排序优化</h5><p>有时面对的需求是要对多个字段进行排序，而这种情况应该怎么优化或者设计索引呢？首先看下面例子：</p><p>对 a、c 两个字段进行排序的执行计划：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>a<span class="token punctuation">,</span>c <span class="token keyword">from</span> t1 <span class="token keyword">order</span> <span class="token keyword">by</span> a<span class="token punctuation">,</span>c<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra          |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10236 |   100.00 | Using filesort |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>观察 Extra 字段，发现使用的是 filesort。</p><p>再看对 a、b（a、b 两个字段有联合索引）两个字段进行排序：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b <span class="token keyword">from</span> t1 <span class="token keyword">order</span> <span class="token keyword">by</span> a<span class="token punctuation">,</span>b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows  | filtered | Extra       |+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+|  1 | SIMPLE      | t1    | NULL       | index | NULL          | idx_a_b | 10      | NULL | 10236 |   100.00 | Using index |+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发现使用的是索引排序。</p><p>多个字段排序的情况，如果要通过添加索引优化，得注意排序字段的顺序与联合索引中列的顺序要一致。</p><p>因此，<strong>如果多个字段排序，可以在多个排序字段上添加联合索引来优化排序语句。</strong></p><h5 id="2-1-3-先等值查询再排序的优化"><a href="#2-1-3-先等值查询再排序的优化" class="headerlink" title="2.1.3 先等值查询再排序的优化"></a>2.1.3 先等值查询再排序的优化</h5><p>我们更多的情况是会先根据某个字段条件查出一部分数据，然后再排序，而这类 SQL 应该如果优化呢？看下面的实验：</p><p>表 t1中，根据 a=1000 过滤数据再根据 d 字段排序的执行计划如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>a<span class="token punctuation">,</span>d <span class="token keyword">from</span> t1 <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">1000</span> <span class="token keyword">order</span> <span class="token keyword">by</span> d<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+---------+---------+-------+------+----------+----------------+| id | select_type | table | partitions | type | possible_keys | key     | key_len | ref   | rows | filtered | Extra          |+----+-------------+-------+------------+------+---------------+---------+---------+-------+------+----------+----------------+|  1 | SIMPLE      | t1    | NULL       | ref  | idx_a_b       | idx_a_b | 5       | const | 1001 |   100.00 | Using filesort |+----+-------------+-------+------------+------+---------------+---------+---------+-------+------+----------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以在 Extra 字段中看到 “Using filesort”，说明使用的是 filesort 排序。</p><p>再看下根据 a=1000 过滤数据在根据 b 字段排序的执行计划（a、b 两个字段有联合索引）：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b <span class="token keyword">from</span> t1 <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">1000</span> <span class="token keyword">order</span> <span class="token keyword">by</span> b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+---------+---------+-------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key     | key_len | ref   | rows | filtered | Extra       |+----+-------------+-------+------------+------+---------------+---------+---------+-------+------+----------+-------------+|  1 | SIMPLE      | t1    | NULL       | ref  | idx_a_b       | idx_a_b | 5       | const | 1001 |   100.00 | Using index |+----+-------------+-------+------------+------+---------------+---------+---------+-------+------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以在 Extra 字段中看到“Using index”，说明使用的是索引排序。</p><p>因此，对于先等值查询再排序的语句，可以通过在条件字段和排序字段添加联合索引来优化此类排序语句。</p><h4 id="2-2-去掉不必要的返回字段"><a href="#2-2-去掉不必要的返回字段" class="headerlink" title="2.2 去掉不必要的返回字段"></a>2.2 去掉不必要的返回字段</h4><p>有时，我们其实并不需要查询出所有字段，但是可能因为习惯问题，就写成查所有字段的数据了。我们看下下面两条 SQL 的执行计划：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">order</span> <span class="token keyword">by</span> a<span class="token punctuation">,</span>b<span class="token punctuation">;</span>           <span class="token comment">/* 根据a和b字段排序查出所有字段的值 */</span><span class="token keyword">select</span> id<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b <span class="token keyword">from</span> t1 <span class="token keyword">order</span> <span class="token keyword">by</span> a<span class="token punctuation">,</span>b<span class="token punctuation">;</span>      <span class="token comment">/* 根据a和b字段排序查出id,a,b字段的值 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">mysql&gt; explain select * from t1 order by a,b;+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra          |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10236 |   100.00 | Using filesort |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+----------------+1 row in set, 1 warning (0.00 sec)mysql&gt; explain select id,a,b from t1 order by a,b;+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows  | filtered | Extra       |+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+|  1 | SIMPLE      | t1    | NULL       | index | NULL          | idx_a_b | 10      | NULL | 10236 |   100.00 | Using index |+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+1 row in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个例子中，查询所有字段不走索引的原因是：扫描整个索引并查找到没索引的行的成本比扫描全表的成本更高，所以优化器放弃使用索引。</p><h4 id="2-3-修改参数"><a href="#2-3-修改参数" class="headerlink" title="2.3 修改参数"></a>2.3 修改参数</h4><p>在本节一开始讲 order by 原理的时候，接触到两个跟排序有关的参数：max_length_for_sort_data、sort_buffer_size。</p><ul><li>max_length_for_sort_data：如果觉得排序效率比较低，可以适当加大 max_length_for_sort_data 的值，让优化器优先选择全字段排序。当然不能设置过大，可能会导致 CPU 利用率过低或者磁盘 I/O 过高；</li><li>sort_buffer_size：适当加大 sort_buffer_size 的值，尽可能让排序在内存中完成。但不能设置过大，可能导致数据库服务器 SWAP。</li></ul><h4 id="2-4-几种无法利用索引排序的情况"><a href="#2-4-几种无法利用索引排序的情况" class="headerlink" title="2.4 几种无法利用索引排序的情况"></a>2.4 几种无法利用索引排序的情况</h4><h5 id="2-4-1-使用范围查询再排序"><a href="#2-4-1-使用范围查询再排序" class="headerlink" title="2.4.1 使用范围查询再排序"></a>2.4.1 使用范围查询再排序</h5><p>在本节 2.1.3 中介绍过，对于先等值过滤再排序的语句，可以通过在条件字段和排序字段添加联合索引来优化；但是如果联合索引中前面的字段使用了范围查询，对后面的字段排序是否能用到索引排序呢？下面我们通过实验验证一下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b <span class="token keyword">from</span> t1 <span class="token keyword">where</span> a<span class="token operator">&gt;</span><span class="token number">9000</span> <span class="token keyword">order</span> <span class="token keyword">by</span> b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+------------------------------------------+| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                                    |+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+------------------------------------------+|  1 | SIMPLE      | t1    | NULL       | range | idx_a_b       | idx_a_b | 5       | NULL |    1 |   100.00 | Using where; Using index; Using filesort |+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+------------------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里对上面执行计划做下解释：首先条件 a&gt;9000 使用了索引（关注 key 字段对应的值为 idx_a_b）；在 Extra 中，看到了“Using filesort”，表示使用了 filesort 排序，并没有使用索引排序。所以联合索引中前面的字段使用了范围查询，对后面的字段排序使用不了索引排序。</p><p>原因是：a、b 两个字段的联合索引，对于单个 a 的值，b 是有序的。而对于 a 字段的范围查询，也就是 a 字段会有多个值，取到 a，b 的值 b 就不一定有序了，因此要额外进行排序。联合索引结果如下图（为了便于理解，该图的值与上面所创建的表 t1 数据不一样）：</p><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/使用范围查询再排序.png" alt="使用范围查询再排序"></p><p>如上图所示，对于有 a、b 两个字段联合索引的表，如果对 a 字段范围查询，b 字段整体来看是无序的（如上图 b 的值为：1，2，3，1，2，3······）。</p><h5 id="2-4-2-ASC-和-DESC-混合使用将无法使用索引"><a href="#2-4-2-ASC-和-DESC-混合使用将无法使用索引" class="headerlink" title="2.4.2 ASC 和 DESC 混合使用将无法使用索引"></a>2.4.2 ASC 和 DESC 混合使用将无法使用索引</h5><p>对联合索引多个字段同时排序时，如果一个是顺序，一个是倒序，则使用不了索引，如下例：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b <span class="token keyword">from</span> t1 <span class="token keyword">order</span> <span class="token keyword">by</span> a <span class="token keyword">asc</span><span class="token punctuation">,</span>b <span class="token keyword">desc</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-----------------------------+| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows  | filtered | Extra                       |+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-----------------------------+|  1 | SIMPLE      | t1    | NULL       | index | NULL          | idx_a_b | 10      | NULL | 10236 |   100.00 | Using index; Using filesort |+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-----------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-group-by-优化"><a href="#3-group-by-优化" class="headerlink" title="3 group by 优化"></a>3 group by 优化</h3><p>默认情况，会对 group by 字段排序，因此优化方式与 order by 基本一致，如果目的只是分组而不用排序，可以指定 order by null 禁止排序。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h3><p>首先说到 MySQL 的两种排序方式：</p><ul><li>通过有序索引直接返回有序数据</li><li>通过 Filesort 进行排序</li></ul><p>建议优先考虑索引排序。</p><p>而Filesort又分为两种：</p><ul><li>内存排序</li><li>磁盘文件排序</li></ul><p>优先考虑内存排序。</p><p>Filesort 有三种排序模式：</p><ul><li>&lt; sort_key, rowid &gt;</li><li>&lt; sort_key, additional_fields &gt;</li><li>&lt; sort_key, packed_additional_fields &gt;</li></ul><p><strong>order by 语句的优化，这个是本节的重点：</strong></p><ul><li>通过添加合适索引</li><li>去掉不必要的返回字段</li><li>调整参数：主要是 max_length_for_sort_data 和 sort_buffer_size</li><li>避免几种无法利用索引排序的情况</li></ul><p>最后说到 group by 语句的优化，如果只要分组，没有排序需求的话，可以加 order by null 禁止排序。</p><h2 id="07-换种思路写分页查询"><a href="#07-换种思路写分页查询" class="headerlink" title="07 换种思路写分页查询"></a><strong>07 换种思路写分页查询</strong></h2><p>很多时候，业务上会有分页操作的需求，对应的 SQL 类似下面这条：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c <span class="token keyword">from</span> t1 <span class="token keyword">limit</span> <span class="token number">10000</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表示从表 t1 中取出从 10001 行开始的 10 行记录。看似只查询了 10 条记录，实际这条 SQL 是先读取 10010 条记录，然后抛弃前 10000 条记录，然后读到后面 10 条想要的数据。因此要查询一张大表比较靠后的数据，执行效率是非常低的。本节内容就一起研究下，是否有办法去优化分页查询。</p><p>为了方便验证，首先创建测试表并写入数据：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">use</span> muke<span class="token punctuation">;</span>                       <span class="token comment">/* 使用muke这个database */</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t1<span class="token punctuation">;</span>        <span class="token comment">/* 如果表t1存在则删除表t1 */</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t1<span class="token punctuation">`</span> <span class="token punctuation">(</span>             <span class="token comment">/* 创建表t1 */</span>    <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">auto_increment</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>create_time<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'记录创建时间'</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>update_time<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'记录更新时间'</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_a<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_b<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>b<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">procedure</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> insert_t1<span class="token punctuation">;</span> <span class="token comment">/* 如果存在存储过程insert_t1，则删除 */</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">procedure</span> insert_t1<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">/* 创建存储过程insert_t1 */</span><span class="token keyword">begin</span>    <span class="token keyword">declare</span> i <span class="token keyword">int</span><span class="token punctuation">;</span>                    <span class="token comment">/* 声明变量i */</span>    <span class="token keyword">set</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>                          <span class="token comment">/* 设置i的初始值为1 */</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token keyword">do</span>                  <span class="token comment">/* 对满足i&lt;=100000的值进行while循环 */</span>        <span class="token keyword">insert</span> <span class="token keyword">into</span> t1<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 写入表t1中a、b两个字段，值都为i当前的值 */</span>        <span class="token keyword">set</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                      <span class="token comment">/* 将i加1 */</span>    <span class="token keyword">end</span> <span class="token keyword">while</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span>                 <span class="token comment">/* 创建批量写入10000条数据到表t1的存储过程insert_t1 */</span><span class="token keyword">call</span> insert_t1<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">/* 运行存储过程insert_t1 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-根据自增且连续主键排序的分页查询"><a href="#1-根据自增且连续主键排序的分页查询" class="headerlink" title="1 根据自增且连续主键排序的分页查询"></a>1 根据自增且连续主键排序的分页查询</h3><p>首先来看一个根据自增且连续主键排序的分页查询的例子：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">limit</span> <span class="token number">9000</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该 SQL 表示查询从第 9001 开始的两行数据，没添加单独 order by，表示通过主键排序。我们再看表 t1，因为主键是自增并且连续的，所以可以改写成按照主键去查询从第 9001开始的两行数据，如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> id <span class="token operator">&gt;</span><span class="token number">9000</span> <span class="token keyword">limit</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询的结果是一致的。我们再对比一下执行计划：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">mysql&gt; explain select * from t1 limit 9000,2;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9963 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+1 row in set, 1 warning (0.00 sec)mysql&gt; explain select * from t1 where id &gt;9000 limit 2;+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+|  1 | SIMPLE      | t1    | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL | 1000 |   100.00 | Using where |+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+1 row in set, 1 warning (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原 SQL 中 key 字段为 NULL，表示未走索引，rows 显示 9963，表示扫描的行数 9963行；</p><p>改写后的 SQL key 字段为 PRIMARY，表示走了主键索引，扫描了1000行。</p><p>显然改写后的 SQL 执行效率更高。</p><p>另外如果原 SQL 是 order by 非主键的字段，按照上面说的方法改写会导致两条 SQL 的结果不一致。所以这种改写得满足以下两个条件：</p><ul><li>主键自增且连续</li><li>结果是按照主键排序的</li></ul><h3 id="2-查询根据非主键字段排序的分页查询"><a href="#2-查询根据非主键字段排序的分页查询" class="headerlink" title="2 查询根据非主键字段排序的分页查询"></a>2 查询根据非主键字段排序的分页查询</h3><p>再看一个根据非主键字段排序的分页查询，SQL 如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">order</span> <span class="token keyword">by</span> a <span class="token keyword">limit</span> <span class="token number">9000</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>看下这条 SQL 的执行计划：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9963 |   100.00 | Using filesort |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发现并没有使用 a 字段的索引（key 字段对应的值为 null），具体原因：<strong>扫描整个索引并查找到没索引的行的成本比扫描全表的成本更高，所以优化器放弃使用索引</strong>。</p><p>知道不走索引的原因，那么怎么优化呢？</p><p>其实关键是<strong>让排序时返回的字段尽可能少</strong>，所以可以让排序和分页操作先查出主键，然后根据主键查到对应的记录，SQL 改写如下（这里参考了《深入浅出 MySQL》18.4.7 优化分页查询）：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 f <span class="token keyword">inner</span> <span class="token keyword">join</span> <span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> t1 <span class="token keyword">order</span> <span class="token keyword">by</span> a <span class="token keyword">limit</span> <span class="token number">9000</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>g <span class="token keyword">on</span> f<span class="token punctuation">.</span>id <span class="token operator">=</span> g<span class="token punctuation">.</span>id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>看下这条 SQL 的执行计划：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+------------+------------+--------+---------------+---------+---------+------+------+----------+-------------+| id | select_type | table      | partitions | type   | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |+----+-------------+------------+------------+--------+---------------+---------+---------+------+------+----------+-------------+|  1 | PRIMARY     | &lt;derived2&gt; | NULL       | ALL    | NULL          | NULL    | NULL    | NULL | 9002 |   100.00 | NULL        ||  1 | PRIMARY     | f          | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | g.id |    1 |   100.00 | NULL        ||  2 | DERIVED     | t1         | NULL       | index  | NULL          | idx_a   | 5       | NULL | 9002 |   100.00 | Using index |+----+-------------+------------+------------+--------+---------------+---------+---------+------+------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原 SQL 使用的是 filesort 排序，而优化后的 SQL 使用的是索引排序。</p><h2 id="08-Join语句可以这样优化"><a href="#08-Join语句可以这样优化" class="headerlink" title="08 Join语句可以这样优化"></a><strong>08 Join语句可以这样优化</strong></h2><p>为了方便理解，首先创建测试表并写入测试数据，语句如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> muke<span class="token punctuation">;</span> <span class="token comment">/* 创建测试使用的database，名为muke */</span><span class="token keyword">use</span> muke<span class="token punctuation">;</span> <span class="token comment">/* 使用muke这个database */</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t1<span class="token punctuation">;</span> <span class="token comment">/* 如果表t1存在则删除表t1 */</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t1<span class="token punctuation">`</span> <span class="token punctuation">(</span> <span class="token comment">/* 创建表t1 */</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">auto_increment</span><span class="token punctuation">,</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>create_time<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'记录创建时间'</span><span class="token punctuation">,</span><span class="token punctuation">`</span>update_time<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token keyword">COMMENT</span> <span class="token string">'记录更新时间'</span><span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_a<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">procedure</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> insert_t1<span class="token punctuation">;</span> <span class="token comment">/* 如果存在存储过程insert_t1，则删除 */</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">procedure</span> insert_t1<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">/* 创建存储过程insert_t1 */</span><span class="token keyword">begin</span><span class="token keyword">declare</span> i <span class="token keyword">int</span><span class="token punctuation">;</span> <span class="token comment">/* 声明变量i */</span><span class="token keyword">set</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* 设置i的初始值为1 */</span><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token keyword">do</span> <span class="token comment">/* 对满足i&lt;=10000的值进行while循环 */</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t1<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 写入表t1中a、b两个字段，值都为i当前的值 */</span><span class="token keyword">set</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* 将i加1 */</span><span class="token keyword">end</span> <span class="token keyword">while</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span> <span class="token comment">/* 创建批量写入10000条数据到表t1的存储过程insert_t1 */</span><span class="token keyword">call</span> insert_t1<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 运行存储过程insert_t1 */</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t2<span class="token punctuation">;</span> <span class="token comment">/* 如果表t2存在则删除表t2 */</span><span class="token keyword">create</span> <span class="token keyword">table</span> t2 <span class="token operator">like</span> t1<span class="token punctuation">;</span> <span class="token comment">/* 创建表t2，表结构与t1一致 */</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t2 <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">limit</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">/* 将表t1的前100行数据导入到t2 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-关联查询的算法"><a href="#1-关联查询的算法" class="headerlink" title="1 关联查询的算法"></a>1 关联查询的算法</h3><p>MySQL 使用以下两种嵌套循环算法或它们的变体在表之间执行连接（参考 《<a href="https://dev.mysql.com/doc/refman/5.7/en/nested-loop-joins.html">MySQL 5.7 Reference Manual》8.2.1.6 Nested-Loop Join Algorithms</a>）：</p><ul><li>Nested-Loop Join 算法</li><li>Block Nested-Loop Join 算法</li></ul><p>另外还有一种算法 Batched Key Access，其实算对 Nested-Loop Join 算法的一种优化。</p><h4 id="1-1-Nested-Loop-Join-算法"><a href="#1-1-Nested-Loop-Join-算法" class="headerlink" title="1.1 Nested-Loop Join 算法"></a>1.1 Nested-Loop Join 算法</h4><p>一个简单的 Nested-Loop Join(NLJ) 算法一次一行循环地从第一张表（称为驱动表）中读取行，在这行数据中取到关联字段，根据关联字段在另一张表（被驱动表）里取出满足条件的行，然后取出两张表的结果合集。</p><p>我们试想一下，如果在被驱动表中这个关联字段没有索引，那么每次取出驱动表的关联字段在被驱动表查找对应的数据时，都会对被驱动表做一次全表扫描，成本是非常高的（比如驱动表数据量是 m，被驱动表数据量是 n，则扫描行数为 m * n ）。</p><p>好在 MySQL 在关联字段有索引时，才会使用 NLJ，如果没索引，就会使用 Block Nested-Loop Join，等下会细说这个算法。我们先来看下在有索引情况的情况下，使用 Nested-Loop Join 的场景（称为：Index Nested-Loop Join）。</p><p>因为 MySQL 在关联字段有索引时，才会使用 NLJ，因此本节后面的内容所用到的 NLJ 都表示 Index Nested-Loop Join。</p><p>如下例：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">inner</span> <span class="token keyword">join</span> t2 <span class="token keyword">on</span> t1<span class="token punctuation">.</span>a <span class="token operator">=</span> t2<span class="token punctuation">.</span>a<span class="token punctuation">;</span>       <span class="token comment">/* sql1 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>表 t1 和表 t2 中的 a 字段都有索引。</p></blockquote><p>怎么确定这条 SQL 使用的是 NLJ 算法？</p><p>我们先来看下 sql1 的执行计划：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+-------+---------+-----------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref       | rows | filtered | Extra       |+----+-------------+-------+------------+------+---------------+-------+---------+-----------+------+----------+-------------+|  1 | SIMPLE      | t2    | NULL       | ALL  | idx_a         | NULL  | NULL    | NULL      |  100 |   100.00 | Using where ||  1 | SIMPLE      | t1    | NULL       | ref  | idx_a         | idx_a | 5       | muke.t2.a |    1 |   100.00 | NULL        |+----+-------------+-------+------------+------+---------------+-------+---------+-----------+------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从执行计划中可以看到这些信息：</p><ul><li>驱动表是 t2，被驱动表是 t1。原因是：explain 分析 join 语句时，在第一行的就是驱动表；选择 t2 做驱动表的原因：如果没固定连接方式（比如没加 straight_join）优化器会优先选择小表做驱动表。<strong>所以使用 inner join 时，前面的表并不一定就是驱动表。</strong></li><li>使用了 NLJ。原因是：一般 join 语句中，如果执行计划 Extra 中未出现 Using join buffer （<em>*</em>）；则表示使用的 join 算法是 NLJ。</li></ul><p>在这个过程中会读取 t2 表的所有数据，因此这里扫描了 100 行，然后遍历这 100 行数据中字段 a 的值，根据 t2 表中 a 的值索引扫描 t1 表中的对应行，这里也扫描了 100 行。因此整个过程扫描了 200 行。</p><p>在前面，我们有说到：如果被驱动表的关联字段没索引，就会使用 Block Nested-Loop Join(简称：BNL)，为什么会选择使用 BNL 算法而不继续使用 Nested-Loop Join呢？下面就一起分析下：</p><h4 id="1-2-Block-Nested-Loop-Join-算法"><a href="#1-2-Block-Nested-Loop-Join-算法" class="headerlink" title="1.2 Block Nested-Loop Join 算法"></a>1.2 Block Nested-Loop Join 算法</h4><p>Block Nested-Loop Join(BNL) 算法的思想是：把驱动表的数据读入到 join_buffer 中，然后扫描被驱动表，把被驱动表每一行取出来跟 join_buffer 中的数据做对比，如果满足 join 条件，则返回结果给客户端。</p><p>我们一起看看下面这条 SQL 语句：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">inner</span> <span class="token keyword">join</span> t2 <span class="token keyword">on</span> t1<span class="token punctuation">.</span>b <span class="token operator">=</span> t2<span class="token punctuation">.</span>b<span class="token punctuation">;</span>       <span class="token comment">/* sql2 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>表 t1 和表 t2 中的 b 字段都没有索引</p></blockquote><p>看下执行计划：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+--------------------------------------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra                                      |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+--------------------------------------------+|  1 | SIMPLE      | t2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   100 |   100.00 | NULL                                       ||  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10225 |    10.00 | Using where; Using join buffer (hash join) |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+--------------------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Extra 发现 Using join buffer (Block Nested Loop)，这个就说明该关联查询使用的是 BNL 算法。</p><p>我们再看下 sql2 的执行流程：</p><ol><li>把 t2 的所有数据放入到 join_buffer 中</li><li>把表 t1 中每一行取出来，跟 join_buffer 中的数据做对比</li><li>返回满足 join 条件的数据</li></ol><p>在这个过程中，对表 t1 和 t2 都做了一次全表扫描，因此扫描的总行数为10000(表 t1 的数据总量) + 100(表 t2 的数据总量) = 10100。并且 join_buffer 里的数据是无序的，因此对表 t1 中的每一行，都要做 100 次判断，所以内存中的判断次数是 100 * 10000= 100 万次。</p><p>下面我们来回答上面提出的一个问题：</p><p>如果被驱动表的关联字段没索引，为什么会选择使用 BNL 算法而不继续使用 Nested-Loop Join 呢？</p><p>在被驱动表的关联字段没索引的情况下，比如 sql2：</p><p>如果使用 Nested-Loop Join，那么扫描行数为 100 * 10000 = 100万次，这个是磁盘扫描。</p><p>如果使用 BNL，那么磁盘扫描是 100 + 10000=10100 次，在内存中判断 100 * 10000 = 100万次。</p><p>显然后者磁盘扫描的次数少很多，因此是更优的选择。因此对于 MySQL 的关联查询，如果被驱动表的关联字段没索引，会使用 BNL 算法。</p><h4 id="1-3-Batched-Key-Access-算法"><a href="#1-3-Batched-Key-Access-算法" class="headerlink" title="1.3 Batched Key Access 算法"></a>1.3 Batched Key Access 算法</h4><p>NLJ 的关键思想是：被驱动表的关联字段有索引。</p><p>BNL 的关键思想是：把驱动表的数据批量提交一部分放到 join_buffer 中。</p><p>从 MySQL 5.6 开始，确实出现了这种集 NLJ 和 BNL 两种算法优点于一体的新算法：<a href="https://dev.mysql.com/doc/refman/5.7/en/bnl-bka-optimization.html">Batched Key Access(BKA)</a>。</p><p>其原理是：</p><ol><li>将驱动表中相关列放入 join_buffer 中</li><li>批量将关联字段的值发送到 Multi-Range Read(MRR) 接口</li><li>MRR 通过接收到的值，根据其对应的主键 ID 进行排序，然后再进行数据的读取和操作</li><li>返回结果给客户端</li></ol><blockquote><p><strong>这里补充下 MRR 相关知识：</strong></p><p>当表很大并且没有存储在缓存中时，使用辅助索引上的范围扫描读取行可能导致对表有很多随机访问。</p><p>而 Multi-Range Read 优化的设计思路是：查询辅助索引时，对查询结果先按照主键进行排序，并按照主键排序后的顺序，进行顺序查找，从而减少随机访问磁盘的次数。</p><p>使用 MRR 时，explain 输出的 Extra 列显示的是 Using MRR。</p><p>optimizer_switch 中 mrr_cost_based 参数的值会影响 MRR。</p><p>如果 mrr_cost_based=on，表示优化器尝试在使用和不使用 MRR 之间进行基于成本的选择。</p><p>如果 mrr_cost_based=off，表示一直使用 MRR。</p><p>更多 MRR 信息请参考官方手册：<a href="https://dev.mysql.com/doc/refman/5.7/en/mrr-optimization.html。">https://dev.mysql.com/doc/refman/5.7/en/mrr-optimization.html。</a></p></blockquote><p>下面尝试开启 BKA ：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">set</span> optimizer_switch<span class="token operator">=</span><span class="token string">'mrr=on,mrr_cost_based=off,batched_key_access=on'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里对上面几个参数做下解释：</p><ul><li>mrr=on 开启 mrr</li><li>mrr_cost_based=off 不需要优化器基于成本考虑使用还是不使用 MRR，也就是一直使用 MRR</li><li>batched_key_access=on 开启 BKA</li></ul><p>然后再看 sql1 的执行计划：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">inner</span> <span class="token keyword">join</span> t2 <span class="token keyword">on</span> t1<span class="token punctuation">.</span>a <span class="token operator">=</span> t2<span class="token punctuation">.</span>a<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+-------+---------+-----------+------+----------+----------------------------------------+| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref       | rows | filtered | Extra                                  |+----+-------------+-------+------------+------+---------------+-------+---------+-----------+------+----------+----------------------------------------+|  1 | SIMPLE      | t2    | NULL       | ALL  | idx_a         | NULL  | NULL    | NULL      |  100 |   100.00 | Using where                            ||  1 | SIMPLE      | t1    | NULL       | ref  | idx_a         | idx_a | 5       | muke.t2.a |    1 |   100.00 | Using join buffer (Batched Key Access) |+----+-------------+-------+------------+------+---------------+-------+---------+-----------+------+----------+----------------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Extra 字段中发现有 Using join buffer (Batched Key Access)，表示确实变成了 BKA 算法。</p><h3 id="2-优化关联查询"><a href="#2-优化关联查询" class="headerlink" title="2 优化关联查询"></a>2 优化关联查询</h3><p>通过上面的知识点，我们知道了关联查询的一些算法，下面一起来讨论下关联查询的优化：</p><h4 id="2-1-关联字段添加索引"><a href="#2-1-关联字段添加索引" class="headerlink" title="2.1 关联字段添加索引"></a>2.1 关联字段添加索引</h4><p>通过上面的内容，我们知道了 BNL、NLJ 和 BKA 的原理，<strong>因此建议在被驱动表的关联字段上添加索引，让 BNL变成 NLJ 或者 BKA ，可明显优化关联查询。</strong></p><h4 id="2-2-小表做驱动表"><a href="#2-2-小表做驱动表" class="headerlink" title="2.2 小表做驱动表"></a>2.2 小表做驱动表</h4><p>前面说到，Index Nested-Loop Join 算法会读取驱动表的所有数据，首先扫描的行数是驱动表的总行数（假设为 n），然后遍历这 n 行数据中关联字段的值，根据驱动表中关联字段的值索引扫描被驱动表中的对应行，这里又会扫描 n 行，因此整个过程扫描了 2n 行。当使用 Index Nested-Loop Join 算法时，扫描行数跟驱动表的数据量成正比。所以<strong>在写 SQL 时，如果确定被关联字段有索引的情况下，建议用小表做驱动表。</strong></p><p>我们来看下以 t2 为驱动表的 SQL：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t2 straight_join t1 <span class="token keyword">on</span> t2<span class="token punctuation">.</span>a <span class="token operator">=</span> t1<span class="token punctuation">.</span>a<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里使用 straight_join 可以固定连接方式，让前面的表为驱动表。</p><h4 id="2-3-临时表"><a href="#2-3-临时表" class="headerlink" title="2.3 临时表"></a>2.3 临时表</h4><p>多数情况我们可以通过在被驱动表的关联字段上加索引来让 join 使用 NLJ 或者 BKA，但有时因为某条关联查询只是临时查一次，如果再去添加索引可能会浪费资源，那么有什么办法优化呢？</p><p>这里提供一种创建临时表的方法。比如下面这条关联查询：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">join</span> t2 <span class="token keyword">on</span> t1<span class="token punctuation">.</span>b<span class="token operator">=</span> t2<span class="token punctuation">.</span>b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>看下执行计划：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+--------------------------------------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra                                      |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+--------------------------------------------+|  1 | SIMPLE      | t2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   100 |   100.00 | NULL                                       ||  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10225 |    10.00 | Using where; Using join buffer (hash join) |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+--------------------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于表 t1 和表 t2 的字段 b都没索引，因此使用的是效率比较低的 BNL 算法。</p><p>现在用临时表的方法对这条 SQL 进行优化：</p><p>首先创建临时表 t1_tmp，表结构与表 t1 一致，只是在关联字段 b 上添加了索引。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TEMPORARY</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t1_tmp<span class="token punctuation">`</span> <span class="token punctuation">(</span>    <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>create_time<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'记录创建时间'</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>update_time<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'记录更新时间'</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_a<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_b<span class="token punctuation">`</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把 t1 表中的数据写入临时表 t1_tmp 中：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">insert</span> <span class="token keyword">into</span> t1_tmp <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行 join 语句：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1_tmp <span class="token keyword">join</span> t2 <span class="token keyword">on</span> t1_tmp<span class="token punctuation">.</span>b<span class="token operator">=</span> t2<span class="token punctuation">.</span>b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们再看下执行计划：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+--------+------------+------+---------------+-------+---------+-----------+------+----------+-------------+| id | select_type | table  | partitions | type | possible_keys | key   | key_len | ref       | rows | filtered | Extra       |+----+-------------+--------+------------+------+---------------+-------+---------+-----------+------+----------+-------------+|  1 | SIMPLE      | t2     | NULL       | ALL  | NULL          | NULL  | NULL    | NULL      |  100 |   100.00 | Using where ||  1 | SIMPLE      | t1_tmp | NULL       | ref  | idx_b         | idx_b | 5       | muke.t2.b |    1 |   100.00 | NULL        |+----+-------------+--------+------------+------+---------------+-------+---------+-----------+------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Extra 没出现 “Block Nested Loop”，说明使用的是 Index Nested-Loop Join，并且扫描行数也大大降低了。</p><p><strong>所以当遇到 BNL 的 join 语句，如果不方便在关联字段上添加索引，不妨尝试创建临时表，然后在临时表中的关联字段上添加索引，然后通过临时表来做关联查询。</strong></p><h2 id="09-为何count-这么慢"><a href="#09-为何count-这么慢" class="headerlink" title="09 为何count(*)这么慢?"></a><strong>09 为何count(*)这么慢?</strong></h2><p>老规矩，先创建测试表并写入数据。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">use</span> muke<span class="token punctuation">;</span> <span class="token comment">/* 使用muke这个database */</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t1<span class="token punctuation">;</span> <span class="token comment">/* 如果表t1存在则删除表t1 */</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t1<span class="token punctuation">`</span> <span class="token punctuation">(</span>    <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>c<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>d<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_a<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_b<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>b<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token operator">=</span><span class="token number">4</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">procedure</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> insert_t1<span class="token punctuation">;</span> <span class="token comment">/* 如果存在存储过程insert_t1，则删除 */</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">procedure</span> insert_t1<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">/* 创建存储过程insert_t1 */</span><span class="token keyword">begin</span><span class="token keyword">declare</span> i <span class="token keyword">int</span><span class="token punctuation">;</span> <span class="token comment">/* 声明变量i */</span><span class="token keyword">set</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* 设置i的初始值为1 */</span><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token keyword">do</span> <span class="token comment">/* 对满足i&lt;=10000的值进行while循环 */</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t1<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 写入表t1中a、b两个字段，值都为i当前的值 */</span><span class="token keyword">set</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* 将i加1 */</span><span class="token keyword">end</span> <span class="token keyword">while</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span> <span class="token comment">/* 创建批量写入10000条数据到表t1的存储过程insert_t1 */</span><span class="token keyword">call</span> insert_t1<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 运行存储过程insert_t1 */</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t1<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token boolean">null</span><span class="token punctuation">,</span><span class="token number">10001</span><span class="token punctuation">,</span><span class="token number">10001</span><span class="token punctuation">,</span><span class="token number">10001</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">10002</span><span class="token punctuation">,</span><span class="token number">10002</span><span class="token punctuation">,</span><span class="token number">10002</span><span class="token punctuation">,</span><span class="token number">10002</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t2<span class="token punctuation">;</span> <span class="token comment">/* 如果表t2存在则删除表t2 */</span><span class="token keyword">create</span> <span class="token keyword">table</span> t2 <span class="token operator">like</span> t1<span class="token punctuation">;</span> <span class="token comment">/* 创建表t2，表结构与t1一致 */</span><span class="token keyword">alter</span> <span class="token keyword">table</span> t2 <span class="token keyword">engine</span> <span class="token operator">=</span>myisam<span class="token punctuation">;</span> <span class="token comment">/* 把t2表改为MyISAM存储引擎 */</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t2 <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1<span class="token punctuation">;</span>  <span class="token comment">/* 把t1表的数据转到t2表 */</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t3<span class="token punctuation">`</span> <span class="token punctuation">(</span>    <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>c<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>d<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span>  <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t3 <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1<span class="token punctuation">;</span>  <span class="token comment">/* 把t1表的数据转到t3表 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-重新认识-count"><a href="#1-重新认识-count" class="headerlink" title="1 重新认识 count()"></a>1 重新认识 count()</h3><h4 id="1-1-count-a-和-count-的区别"><a href="#1-1-count-a-和-count-的区别" class="headerlink" title="1.1 count(a) 和 count(*) 的区别"></a>1.1 count(a) 和 count(*) 的区别</h4><p>当 count() 统计某一列时，比如 count(a)，a 表示列名，是不统计 null 的。</p><p>而 <code>count(*)</code> 无论是否包含空值，都会统计。</p><h4 id="1-2-MyISAM-引擎和-InnoDB-引擎-count-的区别"><a href="#1-2-MyISAM-引擎和-InnoDB-引擎-count-的区别" class="headerlink" title="1.2 MyISAM 引擎和 InnoDB 引擎 count(*) 的区别"></a>1.2 MyISAM 引擎和 InnoDB 引擎 count(*) 的区别</h4><p>对于 MyISAM 引擎，如果没有 where 子句，也没检索其它列，那么 <code>count(*)</code> 将会非常快。因为 MyISAM 引擎会把表的总行数存在磁盘上。</p><p>首先我们看下对 t2 表（存储引擎为 MyISAM）不带 where 子句做 <code>count(*)</code> 的执行计划：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> t2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                        |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | Select tables optimized away |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Extra 字段发现 “Select tables optimized away” 关键字，表示是从 MyISAM 引擎维护的准确行数上获取到的统计值。</p><p>而 InnoDB 并不会保留表中的行数，<strong>因为并发事务可能同时读取到不同的行数</strong>。所以执行 <code>count(*)</code> 时都是临时去计算的，会比 MyISAM 引擎慢很多。</p><p>我们看下对 t1 表（存储引擎为 InnoDB）执行 <code>count(*)</code> 的执行计划：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">mysql&gt; explain select count(*) from t1;+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+| id | select_type | table | partitions | type  | possible_keys | key   | key_len | ref  | rows  | filtered | Extra       |+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+|  1 | SIMPLE      | t1    | NULL       | index | NULL          | idx_b | 4       | NULL | 10147 |   100.00 | Using index |+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发现使用的是 b 字段的索引 idx_b，并且扫描行数是10109，表示会遍历 b 字段的索引树去计算表的总量。</p><p>对比 MyISAM 引擎和 InnoDB 引擎 <code>count(*)</code> 的区别，可以知道：</p><ul><li>MyISAM 会维护表的总行数，放在磁盘中，如果有 <code>count(*)</code> 的需求，直接返回这个数据</li><li>但是 InnoDB 就会去遍历普通索引树，计算表数据总量</li></ul><p>在上面这个例子，InnoDB 表 t1 在执行 <code>count(*)</code> 时，为什么会走 b 字段的索引而不是走主键索引呢？下面我们分析下：</p><h4 id="1-3-MySQL-5-7-18-前后-count-的区别"><a href="#1-3-MySQL-5-7-18-前后-count-的区别" class="headerlink" title="1.3 MySQL 5.7.18 前后 count(*) 的区别"></a>1.3 MySQL 5.7.18 前后 count(*) 的区别</h4><p>在 MySQL 5.7.18 之前，InnoDB 通过扫描聚簇索引来处理 <code>count(*)</code> 语句。</p><p>从 MySQL 5.7.18 开始，通过遍历最小的可用二级索引来处理 <code>count(*)</code> 语句。如果不存在二级索引，则扫描聚簇索引。但是，如果索引记录不完全在缓存池中的话，处理 <code>count(*)</code> 也是比较久的。</p><p>新版本为什么会使用二级索引来处理 <code>count(*)</code> 语句呢？</p><p>原因是 InnoDB 二级索引树的叶子节点上存放的是主键，而主键索引树的叶子节点上存放的是整行数据，所以二级索引树比主键索引树小。因此优化器基于成本的考虑，优先选择的是二级索引。所以 count(主键) 其实没 <code>count (*)</code> 快。</p><h4 id="1-4-count-1-比-count-快吗？"><a href="#1-4-count-1-比-count-快吗？" class="headerlink" title="1.4 count(1) 比 count(*) 快吗？"></a>1.4 count(1) 比 count(*) 快吗？</h4><p>在前面我们知道 <code>count(*)</code> 无论是否包含空值，所有结果都会统计。</p><p>而 count(1)中的 1 是恒真表达式，因此也会统计所有结果。</p><p>所以 count(1) 和 <code>count(*)</code> 统计结果没差别。</p><p>我们来对比 count(1) 和 count(* ) 的执行计划：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">mysql&gt; explain select count(1) from t1;+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+| id | select_type | table | partitions | type  | possible_keys | key   | key_len | ref  | rows  | filtered | Extra       |+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+|  1 | SIMPLE      | t1    | NULL       | index | NULL          | idx_b | 4       | NULL | 10147 |   100.00 | Using index |+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+mysql&gt; explain select count(*) from t1;+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+| id | select_type | table | partitions | type  | possible_keys | key   | key_len | ref  | rows  | filtered | Extra       |+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+|  1 | SIMPLE      | t1    | NULL       | index | NULL          | idx_b | 4       | NULL | 10147 |   100.00 | Using index |+----+-------------+-------+------------+-------+---------------+-------+---------+------+-------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行计划一样，所以 count(1) 并不比 count(*) 快。</p><h3 id="2-哪些方法可以加快-count"><a href="#2-哪些方法可以加快-count" class="headerlink" title="2 哪些方法可以加快 count()"></a>2 哪些方法可以加快 count()</h3><h4 id="2-1-show-table-status"><a href="#2-1-show-table-status" class="headerlink" title="2.1 show table status"></a>2.1 show table status</h4><p>有时，我们只需要知道某张表的大概数据量，这种情况就可以使用 show table status，具体用法如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">table</span> <span class="token keyword">status</span> <span class="token operator">like</span> <span class="token string">'t1'</span>\G<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">...Rows: 10147...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Rows 这列就表示这张表的行数。这种方式获取 InnoDB 表的行数非常快。</p><p><strong>但是，这个值是个估算值，可能与实际值相差 40% 到 50%</strong>。（对于 Rows 这个字段更详细的解释，可以参考官方手册：<a href="https://dev.mysql.com/doc/refman/5.7/en/show-table-status.html）">https://dev.mysql.com/doc/refman/5.7/en/show-table-status.html）</a></p><h4 id="2-2-用-Redis-做计数器"><a href="#2-2-用-Redis-做计数器" class="headerlink" title="2.2 用 Redis 做计数器"></a>2.2 用 Redis 做计数器</h4><h4 id="2-3-增加计数表"><a href="#2-3-增加计数表" class="headerlink" title="2.3 增加计数表"></a>2.3 增加计数表</h4><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/增加计数表.png" alt="增加计数表"></p><hr><p>第2章 MySQL索引</p><h2 id="10-为什么添加索引能提高查询速度"><a href="#10-为什么添加索引能提高查询速度" class="headerlink" title="10 为什么添加索引能提高查询速度?"></a><strong>10 为什么添加索引能提高查询速度?</strong></h2><p>为了便于理解 MySQL 的索引，我们先了解一些与索引相关的算法。</p><h3 id="1-跟索引相关的一些算法"><a href="#1-跟索引相关的一些算法" class="headerlink" title="1 跟索引相关的一些算法"></a>1 跟索引相关的一些算法</h3><p>对于 MySQL 而言，使用最频繁的就是 B+ 树索引，所以我们必须要知道 B+ 树的结构，而 B+ 树是借鉴了二分查找法、二叉查找树、平衡二叉树、B 树的一些思想构建的。因此我们首先通过了解这些算法，来一层一层拨开 B+ 树的神秘面纱。</p><h4 id="1-1-二分查找法"><a href="#1-1-二分查找法" class="headerlink" title="1.1 二分查找法"></a>1.1 二分查找法</h4><p>二分查找法的查找过程是：将记录按顺序排列，查找时先以有序列的中点位置为比较对象，如果要找的元素值小于该中点元素，则将查询范围缩小为左半部分；如果要找的元素值大于该中点元素，则将查询范围缩小为右半部分。以此类推，直到查到需要的值。<br><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/二分查找法.png" alt="二分查找法"></p><h4 id="1-2-二叉查找树"><a href="#1-2-二叉查找树" class="headerlink" title="1.2 二叉查找树"></a>1.2 二叉查找树</h4><p>二叉查找树中，左子树的键值总是小于根的键值，右子树的键值总是大于根的键值，并且每个节点最多只有两颗子树。<br><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/二叉查找树.png" alt="二叉查找树"></p><h4 id="1-3-平衡二叉树"><a href="#1-3-平衡二叉树" class="headerlink" title="1.3 平衡二叉树"></a>1.3 平衡二叉树</h4><p>平衡二叉树的定义：满足二叉查找树的定义，另外必须满足任何节点的两个子树的高度差最大为 1。<br><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/平衡二叉树.png" alt="平衡二叉树"></p><h4 id="1-4-B-树"><a href="#1-4-B-树" class="headerlink" title="1.4 B 树"></a>1.4 B 树</h4><p>B 树可以理解为一个节点可以拥有多于 2 个子节点的平衡多叉查找树。</p><p>B 树中同一键值不会出现多次，要么在叶子节点，要么在内节点上。</p><p>比如用 1、2、3、5、6、7、9 这些数字构建一个 B 树结构，其图形如下：<br><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/B树.png" alt="B树"></p><p>与平衡二叉树相比，B 树利用多个分支（平衡二叉树只有两个分支）节点，减少获取记录时所经历的节点数。</p><p>B 树也是有缺点的，因为每个节点都包含 key 值和 data 值，因此如果 data 比较大时，每一页存储的 key 会比较少；当数据比较多时，同样会有：“要经历多层节点才能查询在叶子节点的数据”的问题。这时，B+ 树站了出来。</p><h4 id="1-5-B-树"><a href="#1-5-B-树" class="headerlink" title="1.5 B+ 树"></a>1.5 B+ 树</h4><p>B+ 树是 B 树的变体，定义基本与 B 树一致，与 B 树的不同点：</p><ul><li>所有叶子节点中包含了全部关键字的信息</li><li>各叶子节点用指针进行连接</li><li>非叶子节点上只存储 key 的信息，这样相对 B 树，可以增加每一页中存储 key 的数量。</li><li>B 树是纵向扩展，最终变成一个“瘦高个”，而 B+ 树是横向扩展的，最终会变成一个“矮胖子”（这里参考了《MySQL 运维内参》第 8 节 B+ 树及 B 树的区别中的比喻）。</li></ul><p>在 B+ 树中，所有记录节点都是按键值的大小顺序存放在同一层的叶子节点上。B+ 树中的 B 不是代表二叉(binary) 而是代表（balance），B+ 树并不是一个二叉树。</p><p>还是根据前面提到的这组数字（1、2、3、5、6、7、9）举例，它的结构如下：</p><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/Bplus树.png" alt="Bplus树"></p><p>与 1.4 中 B 树的结构最大的区别就是：</p><p>它的键一定会出现在叶子节点上，同时也有可能在非叶子节点中重复出现。而 B 树中同一键值不会出现多次。</p><h3 id="2-B-树索引"><a href="#2-B-树索引" class="headerlink" title="2 B+ 树索引"></a>2 B+ 树索引</h3><p>B+ 树索引就是基于本节前面介绍的 B+ 树发展而来的。在数据库中，B+ 树的高度一般都在 2 ~ 4 层，所以<strong>查找某一行数据最多只需要 2 到 4 次 IO。而没索引的情况，需要逐行扫描，明显效率低很多，这也就是为什么添加索引能提高查询速度。</strong></p><p>B+ 树索引并不能找到一个给定键值的具体行，B+ 树索引能找到的只是被查找数据行所在的页。然后数据库通过把页读入到缓冲池（buffer pool）中，在内存中通过二分查找法进行查找，得到需要的数据。</p><p>InnoDB 中 B+ 树索引分为聚集索引和辅助索引，我们再继续了解这两种索引的特点。</p><p>为了方便理解，我们先创建一张测试表并写入数据：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">use</span> muke<span class="token punctuation">;</span> <span class="token comment">/* 使用muke这个database */</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t8<span class="token punctuation">;</span> <span class="token comment">/* 如果表t1存在则删除表t1 */</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t8<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_a<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span>  <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t8<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">'e'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token string">'f'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token string">'g'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token string">'i'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-聚集索引"><a href="#2-1-聚集索引" class="headerlink" title="2.1 聚集索引"></a>2.1 聚集索引</h4><p>InnoDB 的数据是按照主键顺序存放的，而聚集索引就是按照每张表的主键构造一颗 B+ 树，它的叶子节点存放的是整行数据。</p><p>InnoDB 的主键一定是聚集索引。如果没有定义主键，聚集索引可能是第一个不允许为 null 的唯一索引，也有可能是 row id。</p><p>由于实际的数据页只能按照一颗 B+ 树进行排序，因此每张表只能有一个聚集索引（TokuDB 引擎除外）。查询优化器倾向于采用聚集索引，因为聚集索引能够在 B+ 树索引的叶子节点上直接找到数据。</p><p>聚集索引对于主键的排序查找和范围查找速度非常快。</p><p>对于刚刚创建好的测试表 t8的聚集索引的大致结构如下：</p><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/表t8的聚集索引的大致结构.png" alt="表t8的聚集索引的大致结构"></p><p>两点关键信息：</p><ul><li>根据主键值创建了 B+ 树结构</li><li>每个叶子节点包含了整行数据</li></ul><h4 id="2-2-辅助索引"><a href="#2-2-辅助索引" class="headerlink" title="2.2 辅助索引"></a>2.2 辅助索引</h4><p>我们现在知道了聚集索引的叶子节点存放了整行数据，而 InnoDB 存储引擎辅助索引的叶子节点并不会放整行数据，而存放的是键值和主键 ID。</p><p>当通过辅助索引来寻找数据时，InnoDB 存储引擎会遍历辅助索引树查找到对应记录的主键，然后通过主键索引来找到对应的行数据。</p><p>比如一颗高度为 3 的辅助索引树中查找数据，那需要对这颗辅助索引树遍历 3 次找到指定主键，如果聚集索引树的高度也为 3，那么还需要对聚集索引树进行 3 次查找，最终找到一个完整的行数据所在的页，因此获取数据一共需要6次逻辑 IO 访问。</p><p>我们继续拿表 t8 分析，它的辅助索引 idx_a 结构如下：</p><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/表t8的辅助索引idx_a的大致结构.png" alt="表t8的辅助索引idx_a的大致结构"></p><p>上图中两点关键点需要注意：</p><ul><li>根据 a 字段的值创建了 B+ 树结构</li><li>每个叶子节点保存的是 a 字段自己的键值和主键 ID</li></ul><p>对于表 t8，比如有下面这条查询语句：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t8 <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它先通过 a 字段上的索引树，得到主键 id 为 3，再到 id 的聚集索引树上找到对应的行数据。</p><p>而下面这条 SQL:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t8 <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询到的结果是一样的，而执行过程则只需要搜索 id 的聚集索引树。我们能看出辅助索引的查询比主键查询多扫描一颗索引树，所以，我们应该<strong>尽量使用主键做为条件进行查询</strong>。</p><h2 id="11-哪些情况需要添加索引？"><a href="#11-哪些情况需要添加索引？" class="headerlink" title="11 哪些情况需要添加索引？"></a><strong>11 哪些情况需要添加索引？</strong></h2><p>首先创建测试表并写入数据：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">use</span> muke<span class="token punctuation">;</span> <span class="token comment">/* 使用muke这个database */</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t9_1<span class="token punctuation">;</span> <span class="token comment">/* 如果表t9_1存在则删除表t9_1 */</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t9_1<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>c<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>d<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_a<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_b_c<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>b<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>c<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span>  <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">procedure</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> insert_t9_1<span class="token punctuation">;</span> <span class="token comment">/* 如果存在存储过程insert_t9_1，则删除 */</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">procedure</span> insert_t9_1<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">/* 创建存储过程insert_t9_1 */</span><span class="token keyword">begin</span><span class="token keyword">declare</span> i <span class="token keyword">int</span><span class="token punctuation">;</span> <span class="token comment">/* 声明变量i */</span><span class="token keyword">set</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* 设置i的初始值为1 */</span><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token number">100000</span><span class="token punctuation">)</span><span class="token keyword">do</span> <span class="token comment">/* 对满足i&lt;=100000的值进行while循环 */</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t9_1<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 写入表t9_1中a、b两个字段，值都为i当前的值 */</span><span class="token keyword">set</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* 将i加1 */</span><span class="token keyword">end</span> <span class="token keyword">while</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span> <span class="token comment">/* 创建批量写入100000条数据到表t9_1的存储过程insert_t9_1 */</span><span class="token keyword">call</span> insert_t9_1<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 运行存储过程insert_t9_1 */</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t9_1<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span> <span class="token keyword">select</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d <span class="token keyword">from</span> t9_1<span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t9_1<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span> <span class="token keyword">select</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d <span class="token keyword">from</span> t9_1<span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t9_1<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span> <span class="token keyword">select</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d <span class="token keyword">from</span> t9_1<span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t9_1<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span> <span class="token keyword">select</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d <span class="token keyword">from</span> t9_1<span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t9_1<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span> <span class="token keyword">select</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d <span class="token keyword">from</span> t9_1<span class="token punctuation">;</span><span class="token comment">/*  把t9_1的数据量扩大到160万 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>目前比较常见需要创建索引的场景有：数据检索时在条件字段添加索引、聚合函数对聚合字段添加索引、对排序字段添加索引、为了防止回表添加索引、关联查询在关联字段添加索引等。我们就一一分析这些需要创建索引的场景：</p><h3 id="1-数据检索"><a href="#1-数据检索" class="headerlink" title="1 数据检索"></a>1 数据检索</h3><p>用上面的表 t9_1 做测试，首先把没有索引的字段 d 作为条件进行查询：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t9_1 <span class="token keyword">where</span> d <span class="token operator">=</span> <span class="token number">90000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>发现查询时间需要0.44 秒</p><p>再把有索引的字段 a 作为条件进行查询</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t9_1 <span class="token keyword">where</span> a <span class="token operator">=</span> <span class="token number">90000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>发现查询时间为 0.00 sec，表示执行时间不超过 10 毫秒，非常快。</p><p>我们再对比两条 SQL 的执行计划：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">mysql&gt; explain select * from t9_1 where d = 90000;+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows    | filtered | Extra       |+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+|  1 | SIMPLE      | t9_1  | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 3192096 |    10.00 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+mysql&gt; explain select * from t9_1 where a = 90000;+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref   | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+|  1 | SIMPLE      | t9_1  | NULL       | ref  | idx_a         | idx_a | 5       | const |   32 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>前者 type 字段为 ALL，后者 type 字段为 ref，显然后者性能更好</p><p>rows 这个字段前者是 3192096，而后者是 32，有索引的情况扫描行数大大降低。</p><p>因此建议数据检索时，在条件字段添加索引。</p><h3 id="2-聚合函数"><a href="#2-聚合函数" class="headerlink" title="2 聚合函数"></a>2 聚合函数</h3><p>在测试表 t9_1 中，如果要求出无索引字段 d 的最大值，SQL 如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token function">max</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token keyword">from</span> t9_1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行时间为 0.33 秒。</p><p>再看下求有索引的字段 a 的最大值：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token function">max</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token keyword">from</span> t9_1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行时间为 0.00 秒，表示执行时间不超过 10 毫秒。</p><p>相比对没有索引的字段 d 求最大值（花费330毫秒），<strong>显然索引能提升 max() 函数的效率，同理也能提升 min() 函数的效率</strong>。</p><p>在第 7 节中的 1.3 小节中有介绍 MySQL 5.7.18 之后版本的 <code>count(*)</code> 特点：从 MySQL 5.7.18 开始，通过遍历最小的可用二级索引来处理 <code>count(*)</code> 语句，如果不存在二级索引，则扫描聚簇索引。原因是：InnoDB 二级索引树的叶子节点上存放的是主键，而主键索引树的叶子节点上存放的是整行数据，所以二级索引树比主键索引树小。因此优化器基于成本的考虑，优先选择的是二级索引。</p><p><strong>因此索引对聚合函数 count(*) 也有优化作用。</strong></p><h3 id="3-排序"><a href="#3-排序" class="headerlink" title="3 排序"></a>3 排序</h3><p>在第 4 节 2.1 小节，我们列出了几种通过添加合适索引优化 order by 的方法，这里再做一次总结（如果对下面的总结不是很理解，可以复习第 4 节的内容，有对每种情况举例说明）：</p><ul><li>如果对单个字段排序，则可以在这个排序字段上添加索引来优化排序语句；</li><li>如果是多个字段排序，可以在多个排序字段上添加联合索引来优化排序语句；</li><li>如果是先等值查询再排序，可以通过在条件字段和排序字段添加联合索引来优化排序语句。</li></ul><h3 id="4-避免回表"><a href="#4-避免回表" class="headerlink" title="4 避免回表"></a>4 避免回表</h3><p>比如下面这条 SQL：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> a<span class="token punctuation">,</span>d <span class="token keyword">from</span> t9_1 <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">90000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以走 a 字段的索引，但是在学了第 8 节后，我们知道了辅助索引的结构，如果通过辅助索引来寻找数据，InnoDB 存储引擎会遍历辅助索引树查找到对应记录的主键，然后通过主键索引回表去找对应的行数据。</p><p>但是，如果条件字段和需要查询的字段有联合索引的话，其实回表这一步就省了，因为联合索引中包含了这两个字段的值。像这种索引就已经覆盖了我们的查询需求的场景，我们称为：覆盖索引。比如下面这条 SQL：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> b<span class="token punctuation">,</span>c <span class="token keyword">from</span> t9_1 <span class="token keyword">where</span> b<span class="token operator">=</span><span class="token number">90000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可直接通过联合索引 idx_b_c 找到 b、c 的值（联合索引详细讲解将放在第 11 节）。</p><p><strong>所以可以通过添加覆盖索引让 SQL 不需要回表，从而减少树的搜索次数，让查询更快地返回结果。</strong></p><h3 id="5-关联查询"><a href="#5-关联查询" class="headerlink" title="5 关联查询"></a>5 关联查询</h3><p>在第 6 节中，我们讲到了关联查询的一些优化技巧，其中一个优化方式就是：通过在关联字段添加索引，让 BNL变成 NLJ 或者 BKA。</p><h3 id="6-总结-1"><a href="#6-总结-1" class="headerlink" title="6 总结"></a>6 总结</h3><p>本节讲解了常见需要添加索引的场景：</p><ul><li>数据检索时在条件字段添加索引</li><li>聚合函数对聚合字段添加索引</li><li>对排序字段添加索引</li><li>为了防止回表添加索引</li><li>关联查询在关联字段添加索引</li></ul><h2 id="12-普通索引和唯一索引有哪些区别？"><a href="#12-普通索引和唯一索引有哪些区别？" class="headerlink" title="12 普通索引和唯一索引有哪些区别？"></a><strong>12 普通索引和唯一索引有哪些区别？</strong></h2><p>对于普通索引和唯一索引的区别，也许你已经知道：有普通索引的字段可以写入重复的值，而有唯一索引的字段不可以写入重复的值。其实对于 MySQL 来说，不止这一种区别。今天我们就再深入探究一下普通索引和唯一索引的区别。</p><p>在讨论两者的区别前，我们首先学习一下 Insert Buffer 和 Change Buffer。</p><h3 id="1-Insert-Buffer"><a href="#1-Insert-Buffer" class="headerlink" title="1 Insert Buffer"></a>1 Insert Buffer</h3><p>对于非聚集索引的插入时，先判断插入的非聚集索引页是否在缓冲池中。如果在，则直接插入；如果不在，则先放入 Insert Buffer 中，然后再以一定频率和情况进行 Insert Buffer 和辅助索引页子节点的 merge 操作。这时通常能将多个插入合并到一个操作中（因为在一个索引页中），就大大提高了非聚集索引的插入性能。</p><blockquote><p>增加 Insert Buffer 有两个好处：</p><ul><li>减少磁盘的离散读取</li><li>将多次插入合并为一次操作</li></ul></blockquote><p>但是得注意的是，使用 Insert Buffer 得满足两个条件：</p><ul><li>索引是辅助索引</li><li>索引不是唯一</li></ul><h3 id="2-Change-Buffer"><a href="#2-Change-Buffer" class="headerlink" title="2 Change Buffer"></a>2 Change Buffer</h3><p>InnoDB 从 1.0.x 版本开始引入了 Change Buffer，可以算是对 Insert Buffer 的升级。从这个版本开始，InnoDB 存储引擎可以对 insert、delete、update 都进行缓存。</p><p>影响参数有两个：</p><ul><li>innodb_change_buffering：确定哪些场景使用 Change Buffer，它的值包含：none、inserts、deletes、changes、purges、all。默认为 all，表示启用所有。</li><li>innodb_change_buffer_max_size：控制 Change Buffer 最大使用内存占总 buffer pool 的百分比。默认25，表示最多可以使用 buffer pool 的 25%，最大值50。</li></ul><p>跟 Insert Buffer 一样，Change Buffer 也得满足这两个条件：</p><ul><li>索引是辅助索引</li><li>索引不是唯一</li></ul><p>为什么唯一索引的更新不使用 Change Buffer ?</p><p>原因：唯一索引<strong>必须要将数据页读入内存才能判断是否违反唯一性约束</strong>。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 Change Buffer 了。</p><h3 id="3-普通索引和唯一索引的区别"><a href="#3-普通索引和唯一索引的区别" class="headerlink" title="3 普通索引和唯一索引的区别"></a>3 普通索引和唯一索引的区别</h3><p>通过上面对 Insert Buffer 和 Change Buffer 的了解，也许你已经知道了普通索引和唯一索引的另外一种区别：<strong>如果对数据有修改操作，则普通索引可以用 Change Buffer，而唯一索引不行。</strong></p><p>在上面讲解 Change Buffer 时，也提到了修改唯一索引必须判断是否违反唯一性约束，其实在 RR 隔离级别（事务隔离级别将在第 4 章重点讲解）下，可能会出现一个比较严重的问题：死锁。</p><p>那么查询过程两者的区别呢？</p><p>对于普通索引，查找到满足条件的第一个记录，还需要查找下一个记录，直到不满足条件。</p><p>对于唯一索引来说，查找到第一个记录返回结果就结束了。</p><p>但是 InnoDB 是按页从磁盘读取的，所以很大可能根据该普通索引查询的数据都在一个数据页里，因此如果通过普通索引查找到第一条满足条件所在的数据页，再查找后面的记录很大概率都在之前的数据页里，也就是多了几次内存扫描，实际这种消耗可以忽略不计。</p><p>这里总结一下普通索引和唯一索引的隐藏区别：</p><ul><li>数据修改时，普通索引可以用 Change Buffer，而唯一索引不行。</li><li>数据修改时，唯一索引在 RR 隔离级别下，更容易出现死锁。</li><li>查询数据时，普通索引查到满足条件的第一条记录还需要继续查找下一个记录，而唯一索引查找到第一个记录就可以直接返回结果了，但是普通索引多出的查找次数所消耗的资源多数情况可以忽略不计。</li></ul><h3 id="4-普通索引和唯一索引如何选择"><a href="#4-普通索引和唯一索引如何选择" class="headerlink" title="4 普通索引和唯一索引如何选择"></a>4 普通索引和唯一索引如何选择</h3><p>上面说了普通索引和唯一索引的区别，那么两者应该如何选择呢？</p><p>如果业务要求某个字段唯一，但是代码不能完全保证写入唯一值，则添加唯一索引，让这个字段唯一，该字段新增重复数据时，将报类似如下的错：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">ERROR 1062 (23000): Duplicate entry '1' for key 'f1'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果代码确定某个字段不会有重复的数据写入，则可以选择添加普通索引。 因为普通索引可以使用 Change Buffer，并且出现死锁的概率比唯一索引低。</p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h3><p>普通索引和唯一索引的区别：</p><ul><li>有普通索引的字段可以写入重复的值，而有唯一索引的字段不可以写入重复的值。</li><li>数据修改时，普通索引优于唯一索引，因为普通索引可以用 Change Buffer，并且 RR 隔离级别下，出现死锁的概率比唯一索引低。</li><li>查询数据时，两者性能差别不大。</li></ul><h2 id="13-联合索引有哪些讲究"><a href="#13-联合索引有哪些讲究" class="headerlink" title="13 联合索引有哪些讲究?"></a><strong>13 联合索引有哪些讲究?</strong></h2><h3 id="1-认识联合索引"><a href="#1-认识联合索引" class="headerlink" title="1 认识联合索引"></a>1 认识联合索引</h3><p>联合索引：是指对表上的多个列进行索引。适合 where 条件中的多列组合，在某些场景可以避免回表。</p><p>我们拿讲解 order by 时使用的联合索引 B+ 树图进行理解，如下图：</p><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/使用范围查询再排序.png" alt="使用范围查询再排序"></p><p>联合索引的键值数量大于 1（比如上图中有 a 和 b 两个键值），与单个键值的 B+ 树一样，也是按照键值排序的。<strong>对于 a、b 两个字段都做为条件时，查询是可以走索引的；对于单独 a 字段查询也是可以走索引的。但是对于 b 字段单独查询就走不了索引了。</strong></p><p>联合索引的建议：</p><ul><li>where 条件中，经常同时出现的列放在联合索引中。</li><li>把选择性最大的列放在联合索引的最左边。</li></ul><p>老规矩，创建测试表并写入数据：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">use</span> muke<span class="token punctuation">;</span> <span class="token comment">/* 使用muke这个database */</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t11<span class="token punctuation">;</span> <span class="token comment">/* 如果表t11存在则删除表t11 */</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t11<span class="token punctuation">`</span> <span class="token punctuation">(</span> <span class="token comment">/* 创建表t11 */</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>c<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>d<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_a_b_c<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>b<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>c<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4 <span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t11<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 写入一些数据 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-联合索引使用分析"><a href="#2-联合索引使用分析" class="headerlink" title="2 联合索引使用分析"></a>2 联合索引使用分析</h3><h4 id="2-1-可以完整用到联合索引的情况"><a href="#2-1-可以完整用到联合索引的情况" class="headerlink" title="2 .1 可以完整用到联合索引的情况"></a>2 .1 可以完整用到联合索引的情况</h4><p>下面我们列出几种可以完整用到联合索引的情况，并查看其执行计划，然后进行简短的分析：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t11 <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">and</span> b<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">and</span> c<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* sql1 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref               | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+-----------+---------+-------------------+------+----------+-------+|  1 | SIMPLE      | t11   | NULL       | ref  | idx_a_b_c     | idx_a_b_c | 15      | const,const,const |    1 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+-----------+---------+-------------------+------+----------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>explain 中的 key_len 列用于表示这次查询中，所选择的索引长度有多少字节，常用于判断联合索引有多少列被选择了。下表总结了常用字段类型的 key_len：</p><div class="table-container"><table><thead><tr><th style="text-align:left">列类型</th><th style="text-align:left">KEY_LEN</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">int</td><td style="text-align:left">key_len = 4+1</td><td style="text-align:left">int 为 4 bytes，允许为 NULL，加 1 byte</td></tr><tr><td style="text-align:left">int not null</td><td style="text-align:left">key_len = 4</td><td style="text-align:left">不允许为 NULL</td></tr><tr><td style="text-align:left">bigint</td><td style="text-align:left">key_len=8+1</td><td style="text-align:left">bigint 为 8 bytes，允许为 NULL 加 1 byte</td></tr><tr><td style="text-align:left">bigint not null</td><td style="text-align:left">key_len=8</td><td style="text-align:left">bigint 为 8 bytes</td></tr><tr><td style="text-align:left">char(30) utf8</td><td style="text-align:left">key_len=30*3+1</td><td style="text-align:left">char(n)为：n * 3 ，允许为 NULL 加 1 byte</td></tr><tr><td style="text-align:left">char(30) not null utf8</td><td style="text-align:left">key_len=30*3</td><td style="text-align:left">不允许为 NULL</td></tr><tr><td style="text-align:left">varchar(30) not null utf8</td><td style="text-align:left">key_len=30*3+2</td><td style="text-align:left">utf8 每个字符为 3 bytes，变长数据类型,加 2 bytes</td></tr><tr><td style="text-align:left">varchar(30) utf8</td><td style="text-align:left">key_len=30*3+2+1</td><td style="text-align:left">utf8 每个字符为 3 bytes，允许为 NULL,加 1 byte,变长数据类型，加 2 bytes</td></tr><tr><td style="text-align:left">datetime</td><td style="text-align:left">key_len=8+1 (MySQL 5.6.4之前的版本)；key_len=5+1(MySQL 5.6.4及之后的版本)</td><td style="text-align:left">允许为 NULL，加 1 byte</td></tr></tbody></table></div><p>因为 a、b、c 三个字段都是可以为 NULL 的 int 型。可以知道三个字段的 key_len 都是 5，所以如果完整使用索引 idx_a_b_c，则 key_len 对应的值为 15。再回到上面 sql1 的执行计划中：key_len 显示是 15，而 key 列对应的是 idx_a_b_c，所以 sql1 完整用到了联合索引 idx_a_b_c。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t11 <span class="token keyword">where</span> c<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">and</span> b<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">and</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">/* sql2 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref               | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+-----------+---------+-------------------+------+----------+-------+|  1 | SIMPLE      | t11   | NULL       | ref  | idx_a_b_c     | idx_a_b_c | 15      | const,const,const |    1 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+-----------+---------+-------------------+------+----------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>跟 sql1 的执行计划一样，因此联合索引各字段都做为条件时，各字段的位置不会影响联合索引的使用。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t11 <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">2</span> <span class="token operator">and</span> b <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">and</span> c<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">/* sql3 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type  | possible_keys | key       | key_len | ref  | rows | filtered | Extra                 |+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------+|  1 | SIMPLE      | t11   | NULL       | range | idx_a_b_c     | idx_a_b_c | 15      | NULL |    2 |   100.00 | Using index condition |+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当联合索引前面的字段使用了范围查询，后面的字段做为条件时仍然可以使用完整的联合索引。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t11 <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">and</span> b<span class="token operator">=</span><span class="token number">2</span> <span class="token keyword">order</span> <span class="token keyword">by</span> c<span class="token punctuation">;</span>  <span class="token comment">/* sql4 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref         | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------+|  1 | SIMPLE      | t11   | NULL       | ref  | idx_a_b_c     | idx_a_b_c | 10      | const,const |    4 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>联合索引前面的字段做为条件时，对后面的字段做排序可以使用完整的联合索引。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t11 <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">order</span> <span class="token keyword">by</span> b<span class="token punctuation">,</span>c<span class="token punctuation">;</span>  <span class="token comment">/* sql5 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref   | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-------+|  1 | SIMPLE      | t11   | NULL       | ref  | idx_a_b_c     | idx_a_b_c | 5       | const |    5 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与 sql4 相似，对联合索引第一个字段做条件筛选时，对后面两个字段做排序可以使用完整的联合索引。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c <span class="token keyword">from</span> t11 <span class="token keyword">order</span> <span class="token keyword">by</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">;</span>  <span class="token comment">/* sql6 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type  | possible_keys | key       | key_len | ref  | rows | filtered | Extra       |+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-------------+|  1 | SIMPLE      | t11   | NULL       | index | NULL          | idx_a_b_c | 15      | NULL |   15 |   100.00 | Using index |+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对联合索引的字段同时做排序时（但是排序的三个字段顺序要跟联合索引中三个字段的顺序一致），可以完整用到联合索引。</p><h4 id="2-2-只能使用部分联合索引的情况"><a href="#2-2-只能使用部分联合索引的情况" class="headerlink" title="2.2 只能使用部分联合索引的情况"></a>2.2 只能使用部分联合索引的情况</h4><p>有些场景只能用到部分联合索引，这里就列出几种情况。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t11 <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">and</span> b<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* sql11 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref         | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------+|  1 | SIMPLE      | t11   | NULL       | ref  | idx_a_b_c     | idx_a_b_c | 10      | const,const |    1 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当条件只包含联合索引的前面部分字段时，可以用到部分联合索引。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t11 <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">and</span> c<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* sql12 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-----------------------+| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref   | rows | filtered | Extra                 |+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-----------------------+|  1 | SIMPLE      | t11   | NULL       | ref  | idx_a_b_c     | idx_a_b_c | 5       | const |    5 |    10.00 | Using index condition |+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-----------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于联合索引 idx_a_b_c（a,b,c） ，如果条件中只包含 a 和 c，则只能用到联合索引中 a 的索引。c 这里是用不了索引的。<strong>联合索引 idx_a_b_c(a,b,c) 相当于 (a) 、(a,b) 、(a,b,c) 三种索引，称为联合索引的最左原则。</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t11 <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">2</span>  <span class="token operator">and</span> b <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">order</span> <span class="token keyword">by</span> c<span class="token punctuation">;</span> <span class="token comment">/* sql13 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+---------------------------------------+| id | select_type | table | partitions | type  | possible_keys | key       | key_len | ref  | rows | filtered | Extra                                 |+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+---------------------------------------+|  1 | SIMPLE      | t11   | NULL       | range | idx_a_b_c     | idx_a_b_c | 10      | NULL |    2 |   100.00 | Using index condition; Using filesort |+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+---------------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里可以复习第 4 节 2.4，<strong>当联合索引前面的字段使用了范围查询，对后面的字段排序使用不了索引排序</strong>，也就是只能用到联合索引前面两个字段 a 和 b 的索引。</p><h4 id="2-3-可以用到覆盖索引的情况"><a href="#2-3-可以用到覆盖索引的情况" class="headerlink" title="2.3 可以用到覆盖索引的情况"></a>2.3 可以用到覆盖索引的情况</h4><p>什么是覆盖索引？</p><p>从辅助索引中就可以查询到结果，不需要回表查询聚集索引中的记录。</p><p>使用覆盖索引的优势：因为不需要扫描聚集索引，因此可以减少 SQL 执行过程的 IO 次数。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> b<span class="token punctuation">,</span>c <span class="token keyword">from</span> t11 <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">/* sql21 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref   | rows | filtered | Extra       |+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-------------+|  1 | SIMPLE      | t11   | NULL       | ref  | idx_a_b_c     | idx_a_b_c | 5       | const |    1 |   100.00 | Using index |+----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 a 字段上的条件，去联合索引 idx_a_b_c 的索引树上可以直接查找到 b 字段和 c 字段的值，不需要回表，因此 sql21 使用到了覆盖索引。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> c <span class="token keyword">from</span> t11 <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">and</span> b<span class="token operator">=</span><span class="token number">1</span> <span class="token punctuation">;</span> <span class="token comment">/* sql22 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref         | rows | filtered | Extra       |+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------------+|  1 | SIMPLE      | t11   | NULL       | ref  | idx_a_b_c     | idx_a_b_c | 10      | const,const |    1 |   100.00 | Using index |+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>跟 sql21 类似，在联合索引 idx_a_b_c 的索引树上，通过 a 和 b 的值可以直接找到 c 的值，因此 sql22 使用的也是覆盖索引。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> id <span class="token keyword">from</span> t11 <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">and</span> b<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">and</span> c<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* sql23 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+-----------+---------+-------------------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref               | rows | filtered | Extra       |+----+-------------+-------+------------+------+---------------+-----------+---------+-------------------+------+----------+-------------+|  1 | SIMPLE      | t11   | NULL       | ref  | idx_a_b_c     | idx_a_b_c | 15      | const,const,const |    1 |   100.00 | Using index |+----+-------------+-------+------------+------+---------------+-----------+---------+-------------------+------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 a、b、c 三个字段的值，去联合索引树的叶子节点找到主键 id，不需要回表，因此 sql23 也使用了覆盖索引。</p><h4 id="2-4-不能使用联合索引的情况"><a href="#2-4-不能使用联合索引的情况" class="headerlink" title="2.4 不能使用联合索引的情况"></a>2.4 不能使用联合索引的情况</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t11 <span class="token keyword">where</span> b<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* sql31 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+|  1 | SIMPLE      | t11   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   15 |    10.00 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果只使用联合索引后面的字段做为条件查询，则使用不了联合索引（联合索引最左匹配）。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t11 <span class="token keyword">order</span> <span class="token keyword">by</span> b<span class="token punctuation">;</span> <span class="token comment">/* sql32 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+|  1 | SIMPLE      | t11   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   15 |   100.00 | Using filesort |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与 sql31 相似，对联合索引后面的字段做排序操作，也使用不了联合索引。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t11 <span class="token keyword">where</span> c<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* sql33 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+|  1 | SIMPLE      | t11   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   15 |    10.00 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与 sql31 类似。c 字段单独做条件使用不了索引。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t11 <span class="token keyword">where</span> b<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">and</span> c<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* sql34 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+|  1 | SIMPLE      | t11   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   15 |     6.67 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>联合索引中，如果第一个字段在条件中没有出现，那么联合索引的后面所有字段作为条件都无法使用这个联合索引。</p><h2 id="14-为什么MySQL会选错索引？"><a href="#14-为什么MySQL会选错索引？" class="headerlink" title="14 为什么MySQL会选错索引？"></a><strong>14 为什么MySQL会选错索引？</strong></h2><p>在工作中，也许我们有时会遇到这种场景：某条 SQL 明明可以走 a 索引，却走了更慢的 b 索引。 今天我们就来讨论这种现象。</p><p>为了方便实验，首先创建测试表并写入测试数据，语句如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">use</span> muke<span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t13<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t13<span class="token punctuation">`</span> <span class="token punctuation">(</span>    <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_a<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_b<span class="token punctuation">`</span><span class="token punctuation">(</span><span class="token punctuation">`</span>b<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">procedure</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> insert_t13<span class="token punctuation">;</span> <span class="token comment">/* 如果存在存储过程insert_t13，则删除 */</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">procedure</span> insert_t13<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">/* 创建存储过程insert_t13 */</span><span class="token keyword">begin</span>    <span class="token keyword">declare</span> i <span class="token keyword">int</span><span class="token punctuation">;</span> <span class="token comment">/* 声明变量i */</span>    <span class="token keyword">set</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* 设置i的初始值为1 */</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token keyword">do</span> <span class="token comment">/* 对满足i&lt;=10000的值进行while循环 */</span>        <span class="token keyword">insert</span> <span class="token keyword">into</span> t13<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 写入表t13中a字段，值为i当前的值 */</span>        <span class="token keyword">set</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* 将i加1 */</span>    <span class="token keyword">end</span> <span class="token keyword">while</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span> <span class="token comment">/* 创建批量写入10000条数据到表t13的存储过程insert_t13 */</span><span class="token keyword">call</span> insert_t13<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 运行存储过程insert_t13 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在分析 MySQL 选错索引的情况之前，先讲 show index 的使用，因为后面会用到。</p><h3 id="1、show-index-的使用"><a href="#1、show-index-的使用" class="headerlink" title="1、show index 的使用"></a>1、show index 的使用</h3><p>当你需要查看某张表的索引详情时，可以使用命令：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">index</span> <span class="token keyword">from</span> t13<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+| t13   |          0 | PRIMARY  |            1 | id          | A         |        9192 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       || t13   |          1 | idx_a    |            1 | a           | A         |        9212 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       || t13   |          1 | idx_b    |            1 | b           | A         |        9212 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对上面几个重要的字段做一下解释：</p><ul><li>Non_unique：如果是唯一索引，则值为 0，如果可以有重复值，则值为 1</li><li>Key_name：索引名字</li><li>Seq_in_index：索引中的列序号，比如联合索引 idx_a_b_c(a,b,c) ，那么三个字段分别对应 1,2,3</li><li>Column_name：字段名</li><li>Collation：字段在索引中的排序方式，A 表示升序，NULL 表示未排序</li><li>Cardinality：索引中不重复记录数量的预估值，该值等会儿会详细讲解</li><li>Sub_part：如果是前缀索引，则会显示索引字符的数量；如果是对整列进行索引，则该字段值为 NULL</li><li>Null：如果列可能包含空值，则该字段为 YES；如果不包含空值，则该字段值为 ‘ ‘</li><li>Index_type：索引类型，包括 BTREE、FULLTEXT、HASH、RTREE 等</li></ul><p>show index 各字段的详细描述可以参考官方文档：<a href="https://dev.mysql.com/doc/refman/5.7/en/show-index.html。">https://dev.mysql.com/doc/refman/5.7/en/show-index.html。</a></p><h3 id="2、Cardinality-取值"><a href="#2、Cardinality-取值" class="headerlink" title="2、Cardinality 取值"></a>2、Cardinality 取值</h3><p>Cardinality 表示该索引不重复记录数量的预估值。如果该值比较小，那就应该考虑是否还有必要创建这个索引。比如性别这种类型的字段，即使加了索引，Cardinality 值比较小，使用性别做条件查询数据时，可能根本用不到已经添加的索引（可以参考第 3 节的第 4 部分：范围查询）。</p><p>Cardinality 统计信息的更新发生在两个操作中：INSERT 和 UPDATE。当然也不是每次 INSERT 或 UPDATE 就更新的，其更新时机为：</p><ul><li>表中 1/16 的数据已经发生过变化</li><li>表中数据发生变化次数超过 2000000000</li></ul><p>Cardinality 值是怎样统计和更新的呢？</p><p>InnoDB 表取出 B+ 树索引中叶子节点的数量，记为 a；随机取出 B+ 树索引中的 8 个（这个数量有参数 innodb_stats_transient_sample_pages 控制，默认为 8）叶子节点，统计每个页中不同记录的个数（假设为 b1，b2，b3，…，b8）。则 Cardinality 的预估值为：</p><p>（b1 + b2 + b3 + … b8）* a/8</p><p>所以 Cardinality 的值是对 8 个叶子节点进行采样获取的，显然这个值并不准确，只供参考。</p><p>下面我们来看下统计 Cardinality 涉及到的几个参数：</p><ul><li>innodb_stats_transient_sample_pages：设置统计 Cardinality 值时每次采样页的数量，默认值为 8。</li><li>innodb_stats_method：用来判断如果对待索引中出现的 NULL 值记录，默认为 nulls_equal，表示将 NULL 值记录视为相等的记录。另外还有 nulls_unequal 和 nulls_ignored。nulls_unequal 表示将 NULL 视为不同的记录，nulls_ignored 表示忽略 NULL 值记录。</li><li>innodb_stats_persistent：是否将 Cardinality 持久化到磁盘。好处是：比如数据库重启，不需要再计算 Cardinality 的值。</li><li>innodb_stats_on_metadata：当通过命令 show table status、show index 及访问 information_chema 库下的 tables 表和 statistics 表时，是否需要重新计算索引的 Cardinality。目的是考虑有些表数据量大，并且辅助索引多时，执行这些操作可能会比较慢，而使用者可能并不需要更新 Cardinality。</li></ul><h3 id="3、统计信息不准确导致选错索引"><a href="#3、统计信息不准确导致选错索引" class="headerlink" title="3、统计信息不准确导致选错索引"></a>3、统计信息不准确导致选错索引</h3><p>在 MySQL 中，<strong>优化器控制着索引的选择。一般情况下，优化器会考虑扫描行数、是否使用临时表、是否排序等因素，然后选择一个最优方案去执行 SQL 语句</strong>。</p><p>而 MySQL 中扫描行数并不会每次执行语句都去计算一次，因为每次都去计算，数据库压力太大了。实际情况是通过统计信息来预估扫描行数。这个统计信息就可以看成 show index 中的 Cardinality。</p><p>而从上面说到 Cardinality 的更新原理可以看出，它的值不一定准确的，因此有时可能就是因为它的值不精准导致选错了索引。这种情况可以使用下面的命令重新统计信息：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">analyze</span> <span class="token keyword">table</span> t13<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4、单次选取的数据量过大导致选错索引"><a href="#4、单次选取的数据量过大导致选错索引" class="headerlink" title="4、单次选取的数据量过大导致选错索引"></a>4、单次选取的数据量过大导致选错索引</h3><p>有时，我们也会遇到这种情况，如果单次选取的数据量过大，可能也会导致“选错”索引。</p><hr><p>第3章 MySQL锁</p><h2 id="15-全局锁和表锁什么场景会用到"><a href="#15-全局锁和表锁什么场景会用到" class="headerlink" title="15 全局锁和表锁什么场景会用到"></a><strong>15 全局锁和表锁什么场景会用到</strong></h2><p>根据加锁的范围，MySQL 中的锁可分为三类：</p><ul><li>全局锁</li><li>表级锁</li><li>行锁</li></ul><p>本节来重点讲解一下全局锁和表锁。</p><h3 id="1-全局锁"><a href="#1-全局锁" class="headerlink" title="1 全局锁"></a><strong>1 全局锁</strong></h3><p>MySQL 全局锁会关闭所有打开的表，并使用全局读锁锁定所有表。其命令为：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">FLUSH <span class="token keyword">TABLES</span> <span class="token keyword">WITH</span> <span class="token keyword">READ</span> <span class="token keyword">LOCK</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>简称：FTWRL，可以使用下面命令解锁：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UNLOCK</span> <span class="token keyword">TABLES</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们来通过实验理解一下全局锁：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">use</span> muke<span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t14<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t14<span class="token punctuation">`</span> <span class="token punctuation">(</span>    <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_a<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t14<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进行 FTWRL 实验：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">FLUSH TABLES WITH READ LOCK;<br>Query OK, 0 rows affected (0.00 sec)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">select <em> from t14 limit 1;<br>… <br>1 row in set (0.00 sec) <br> <em>*（能正常返回结果）</em></em></td><td style="text-align:left">select <em> from t14 limit 1;<br>…<br>1 row in set (0.00 sec) <br> <em>*（能正常返回结果）</em></em></td></tr><tr><td style="text-align:left">insert into t14(a,b) values(2,2);<br>ERROR 1223 (HY000): Can’t execute the query because you have a conflicting read lock <br> <strong>（报错）</strong></td><td style="text-align:left">insert into t14(a,b) values(2,2);/<em> sql1 </em>/ <br> <strong>（等待）</strong></td></tr><tr><td style="text-align:left">UNLOCK TABLES;</td><td style="text-align:left">insert into t14(a,b) values(2,2);/<em> sql1 </em>/<br>Query OK, 1 row affected (5.73 sec) <br> <strong>（session1 解锁后，在等待的 sql1 马上执行成功）</strong></td></tr></tbody></table></div><p>上面的实验中，当 session1 执行 FTWRL 后，本线程 session1 和其它线程 session2 都可以查询，本线程和其它线程都不能更新。</p><p>原因是：<strong>当执行 FTWRL 后，所有的表都变成只读状态，数据更新或者字段更新将会被阻塞。</strong></p><p>那么全局锁一般什么时候会用到呢？</p><p>全局锁一般用在整个库（包含非事务引擎表）做备份（mysqldump 或者 xtrabackup）时。也就是说，在整个备份过程中，整个库都是只读的，其实这样风险挺大的。如果是在主库备份，会导致业务不能修改数据；而如果是在从库备份，就会导致主从延迟。</p><p>好在 mysqldump 包含一个参数 —single-transaction，可以在一个事务中创建一致性快照，然后进行所有表的备份。因此增加这个参数的情况下，备份期间可以进行数据修改。但是需要所有表都是事务引擎表。所以这也是建议使用 InnoDB 存储引擎的原因之一。</p><p>而对于 xtrabackup，可以分开备份 InnoDB 和 MyISAM，或者不执行 —master-data，可以避免使用全局锁。</p><h3 id="2-表级锁"><a href="#2-表级锁" class="headerlink" title="2 表级锁"></a>2 表级锁</h3><p>表级锁有两种：表锁和元数据锁。</p><h4 id="2-1-表锁"><a href="#2-1-表锁" class="headerlink" title="2.1 表锁"></a>2.1 表锁</h4><p>表锁使用场景：</p><ol><li>事务需要更新某张大表的大部分或全部数据。如果使用默认的行锁，不仅事务执行效率低，而且可能造成其它事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高事务执行速度；</li><li>事务涉及多个表，比较复杂，可能会引起死锁，导致大量事务回滚，可以考虑表锁避免死锁。</li></ol><p>其中表锁又分为表读锁和表写锁，命令分别是：</p><p>表读锁：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">lock</span> <span class="token keyword">tables</span> t14 <span class="token keyword">read</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表写锁：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">lock</span> <span class="token keyword">tables</span> t14  <span class="token keyword">write</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面我们分别用实验验证表读锁和表写锁。</p><p>表读锁实验：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">lock tables t14 read; <br>Query OK, 0 rows affected (0.00 sec)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">select id,a,b from t14 limit 1; <br>… <br>1 row in set (0.00 sec) <br> <strong>（能正常返回结果）</strong></td><td style="text-align:left">select id,a,b from t14 limit 1; <br>… <br>1 row in set (0.00 sec) <br> <strong>（能正常返回结果）</strong></td></tr><tr><td style="text-align:left">insert into t14(a,b) values(3,3); <br>ERROR 1099 (HY000): Table ‘t14’ was locked with a READ lock and can’t be updated <br> <strong>（报错）</strong></td><td style="text-align:left">insert into t14(a,b) values(3,3);/<em> sql2 </em>/ <br> <strong>（等待）</strong></td></tr><tr><td style="text-align:left">unlock tables; <br>Query OK, 0 rows affected (0.00 sec)</td><td style="text-align:left">insert into t14(a,b) values(3,3);/<em> sql2 </em>/ <br>Query OK, 1 row affected (10.97 sec) <br> <strong>（session1 解锁后，sql2 立马写入成功）</strong></td></tr></tbody></table></div><p>从上面的实验我们可以看出，在 session1 中对表 t14 加表读锁，session1 和 session2 都可以查询表 t14 的数据；而 session1 执行更新会报错，session2 执行更新会等待（直到 session1 解锁后才更新成功）。</p><p>总结：<strong>对表执行 lock tables xxx read （表读锁）时，本线程和其它线程可以读，本线程写会报错，其它线程写会等待。</strong></p><p>我们再来看一下表写锁实验：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">lock tables t14 write; <br>Query OK, 0 rows affected (0.00 sec)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">select id,a,b from t14 limit 1; <br>… <br>1 row in set (0.00 sec) <br> <strong>（能正常返回结果）</strong></td><td style="text-align:left">select id,a,b from t14 limit 1;/<em> sql3 </em>/ <br> <strong>（等待）</strong></td></tr><tr><td style="text-align:left">unlock tables; <br>Query OK, 0 rows affected (0.01 sec)</td><td style="text-align:left">select id,a,b from t14 limit 1;/<em> sql3 </em>/ <br>… <br>1 row in set (7.16 sec) <br> <strong>（session1 解锁后，sql3 马上返回查询结果）</strong></td></tr><tr><td style="text-align:left">lock tables t14 write; <br>Query OK, 0 rows affected (0.00 sec)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">delete from t14 limit 1; <br>Query OK, 1 row affected, 1 warning (0.00 sec) <br> <strong>（能正常执行删除语句）</strong></td><td style="text-align:left">delete from t14 limit 1;/<em> sql4 </em>/ <br> <strong>（等待）</strong></td></tr><tr><td style="text-align:left">unlock tables; <br>Query OK, 0 rows affected (0.00 sec)</td><td style="text-align:left">delete from t14 limit 1;/<em> sql4 </em>/ <br>Query OK, 1 row affected, 1 warning (14.94 sec) <br> <strong>（session1 解锁后，sql4 立马执行成功）</strong></td></tr></tbody></table></div><p>总结：<strong>对表执行 lock tables xxx write （表写锁）时，本线程可以读写，其它线程读写都会阻塞。</strong></p><h4 id="2-2-元数据锁"><a href="#2-2-元数据锁" class="headerlink" title="2.2 元数据锁"></a>2.2 元数据锁</h4><p>在 MySQL 中，DDL 是不属于事务范畴的。如果事务和 DDL 并行执行同一张表时，可能会出现事务特性被破坏、binlog 顺序错乱等 bug（比如 <a href="https://bugs.mysql.com/bug.php?id=989">bug#989</a>）。为了解决这类问题，从 MySQL 5.5.3 开始，引入了元数据锁（Metadata Locking，简称：MDL 锁）（这段内容参考《淘宝数据库内核月报》<a href="http://mysql.taobao.org/monthly/2015/11/04/">MySQL · 特性分析 · MDL 实现分析</a>）。</p><p>从上面我们知道，MDL 锁的出现解决了同一张表上事务和 DDL 并行执行时可能导致数据不一致的问题。</p><p>但是，我们在工作中，很多情况需要考虑 MDL 的存在，否则可能导致长时间锁等待甚至连接被打满的情况。如下例：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th><th style="text-align:left">session3</th></tr></thead><tbody><tr><td style="text-align:left">select id,a,b,sleep(100) from t14 limit 1;/<em> sql5 </em>/</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">alter table t14 add column c int;/<em> sql6 </em>/ <br> <strong>（等待）</strong></td><td style="text-align:left">select id,a,b from t14 limit 1;/<em> sql7 </em>/ <br> <strong>（等待）</strong></td></tr><tr><td style="text-align:left">select id,a,b,sleep(100) from t14 limit 1;/<em> sql5 </em>/ <br>… <br>1 row in set (1 min 40.00 sec) <br> <strong>（100秒后 sql5 返回结果）</strong></td><td style="text-align:left">alter table t14 add column c int;/<em> sql6 </em>/ <br>Query OK, 0 rows affected (1 min 33.98 sec) Records: 0 Duplicates: 0 Warnings: 0 <br> <strong>（session1 的查询语句执行完成后，sql6 立马执行完毕）</strong></td><td style="text-align:left">select id,a,b from t14 limit 1;/<em> sql7 </em>/ <br>… <br>1 row in set (1 min 26.65 sec) <br> <strong>（session1 的查询语句执行完成后，sql7 立马执行完毕）</strong></td></tr></tbody></table></div><p>上面的实验中，我们在 session1 查询了表 t14 的数据，其中使用了 sleep(100) ，表示在 100 秒后才会返回结果；然后在 session2 执行 DDL 操作时会等待（原因是 session1 执行期间会对表 t14 加一个 MDL，而 session2 又会跟 session1 争抢 MDL）；而 session3 执行查询时也会继续等待。因此如果 session1 的语句一直没结束，其它所有的查询都会等待。这种情况下，如果这张表查询比较频繁，很可能短时间把数据库的连接数打满，导致新的连接无法建立而报错，如果是正式业务，影响是非常恐怖的。</p><p>当然如果出现这种情况，假如你还有 session 连着数据库，可以 kill 掉 session1 中的语句或者终止 session2 中的 DDL 操作，可以让业务恢复。但是出现这种情况的根源其实是：session1 中有长时间未提交的事务。<strong>因此对于开发来说，在工作中应该尽量避免慢查询、尽量保证事务及时提交、避免大事务等，当然对于 DBA 来说，也应该尽量避免在业务高峰执行 DDL 操作。</strong></p><h2 id="16-行锁：InnoDB替代MyISAM的重要原因"><a href="#16-行锁：InnoDB替代MyISAM的重要原因" class="headerlink" title="16 行锁：InnoDB替代MyISAM的重要原因"></a><strong>16 行锁：InnoDB替代MyISAM的重要原因</strong></h2><p>MySQL 5.5 之前的默认存储引擎是 MyISAM，5.5 之后改成了 InnoDB。InnoDB 后来居上最主要的原因就是：</p><ul><li>InnoDB 支持事务：适合在并发条件下要求数据一致的场景。</li><li>InnoDB 支持行锁：有效降低由于删除或者更新导致的锁定。</li></ul><p>在讲解行锁之前，我们首先来看一下两阶段锁协议。</p><h3 id="1-两阶段锁"><a href="#1-两阶段锁" class="headerlink" title="1 两阶段锁"></a>1 两阶段锁</h3><p>传统的关系型数据库加锁的一个原则是：两阶段锁原则。</p><p>两阶段锁：锁操作分为两个阶段，加锁阶段和解锁阶段，并且保证加锁阶段和解锁阶段不相交。</p><p>我们可以通过下面这张表理解两阶段锁：</p><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">MySQL 操作</th><th style="text-align:left">解释</th><th style="text-align:left">锁阶段</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">begin;</td><td style="text-align:left">事务开始</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">insert into …;</td><td style="text-align:left">加 insert 对应的锁</td><td style="text-align:left">加锁阶段</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">update table …;</td><td style="text-align:left">加 update 对应的锁</td><td style="text-align:left">加锁阶段</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">delete from …;</td><td style="text-align:left">加 delete 对应的锁</td><td style="text-align:left">加锁阶段</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">commit;</td><td style="text-align:left">事务结束，同时释放 2、3、4 步骤中加的锁</td><td style="text-align:left">解锁阶段</td></tr></tbody></table></div><h3 id="2-InnoDB-行锁模式"><a href="#2-InnoDB-行锁模式" class="headerlink" title="2 InnoDB 行锁模式"></a>2 InnoDB 行锁模式</h3><p>InnoDB 实现了以下两种类型的行锁：</p><ul><li>共享锁（S）：允许一个事务去读一行，阻止其它事务获得相同数据集的排他锁；</li><li>排他锁（X）：允许获得排他锁的事务更新数据，阻止其它事务取得相同数据集的共享读锁和排他写锁。</li></ul><p>对于普通 select 语句，InnoDB 不会加任何锁，事务可以通过以下语句显式给记录集加共享锁或排他锁：</p><ul><li>共享锁（S）：select * from table_name where … lock in share mode;</li><li>排他锁（X）：select * from table_name where … for update。</li></ul><h3 id="3-InnoDB-行锁算法"><a href="#3-InnoDB-行锁算法" class="headerlink" title="3 InnoDB 行锁算法"></a>3 InnoDB 行锁算法</h3><p>InnoDB 行锁的三种算法：</p><ul><li>Record Lock：单个记录上的索引加锁。</li><li>Gap Lock：间隙锁，对索引项之间的间隙加锁，但不包括记录本身。</li><li>Next-Key Lock：Gap Lock + Record Lock，锁定一个范围，并且锁定记录本身。</li></ul><p>InnoDB 行锁实现特点意味着：如果不通过索引条件检索数据，那么 InnoDB 将对表中所有记录加锁，实际效果跟表锁一样。</p><h3 id="4-事务隔离级别"><a href="#4-事务隔离级别" class="headerlink" title="4 事务隔离级别"></a>4 事务隔离级别</h3><p>不同事务隔离级别对应的行锁也是不一样的，因此在讲解行锁的锁定范围之前，先简单聊聊事务隔离级别。事务隔离级别的详细介绍放在下一章。</p><p>MySQL 的 4 种隔离级别：</p><ul><li>Read uncommitted（读未提交）: 在该隔离级别，所有事务都可以看到其它未提交事务的执行结果。可能会出现脏读。</li><li>Read Committed（读已提交，简称： RC）：一个事务只能看见已经提交事务所做的改变。因为同一事务的其它实例在该实例处理期间可能会有新的 commit，所以可能出现幻读。</li><li>Repeatable Read（可重复读，简称：RR）：这是 MySQL 的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。消除了脏读、不可重复读，默认也不会出现幻读。</li><li>Serializable（串行）：这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。</li></ul><blockquote><ul><li>脏读：读取未提交的事务。</li><li>幻读：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据。</li></ul></blockquote><h3 id="5-RC-隔离级别下的行锁实验"><a href="#5-RC-隔离级别下的行锁实验" class="headerlink" title="5 RC 隔离级别下的行锁实验"></a>5 RC 隔离级别下的行锁实验</h3><p>有时我们可能会思考，某条语句（类似 select * from table_name where a=… for update;）是怎么加锁的？</p><p>要想分析某条 SQL 是怎么加锁的，如果其他信息都不知道，那就得分几种情况了，不同情况加锁的方式也各不一样，比较常见的一些情况如下：</p><ul><li>RC 隔离级别，a 字段没索引。</li><li>RC 隔离级别，a 字段有唯一索引。</li><li>RC 隔离级别，a 字段有非唯一索引。</li><li>RR 隔离级别，a 字段没索引。</li><li>RR 隔离级别，a 字段有唯一索引。</li><li>RR 隔离级别，a 字段有非唯一索引。</li></ul><blockquote><p>Read uncommitted 和 Serializable 这两种隔离级别在生产环境基本不用，就不做分析了。</p></blockquote><p>我们先验证 RC 隔离级别下的几种情况，RR 隔离级别的实验放在下节：</p><p>首先创建测试表及写入数据:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">use</span> muke<span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t16<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t16<span class="token punctuation">`</span> <span class="token punctuation">(</span>    <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>c<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">`</span>uniq_a<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_c<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>c<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span>  <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t16<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>让我们开始实验吧！</p><h4 id="5-1-通过非索引字段查询"><a href="#5-1-通过非索引字段查询" class="headerlink" title="5.1 通过非索引字段查询"></a>5.1 通过非索引字段查询</h4><p>我们首先来看一下条件字段不使用索引的例子：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">set session transaction_isolation=’READ-COMMITTED’;/<em> 设置会话隔离级别为 RC</em>/</td><td style="text-align:left">set session transaction_isolation=’READ-COMMITTED’;/<em> 设置会话隔离级别为 RC</em>/</td></tr><tr><td style="text-align:left">begin;</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">use muke; <br>select * from t16 where b=1 for update; <br>… <br>1 row in set (0.00 sec)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">use muke; <br>select <em> from t16 where b=2 for update; <br> <em>*（等待）</em></em></td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left">select <em> from t16 where b=2 for update; <br>… <br>1 row in set (6.81 sec) <br> <em>*（session1 执行 commit 后立马返回结果）</em></em></td></tr></tbody></table></div><blockquote><p><strong>这里解释一下为什么要用 for update？</strong></p><p>我们常使用的查询语句，比如 select * from t16 where b=1 属于快照读，是不会看到别的事务插入的数据的。</p><p>而在查询语句后面加了 for update 显式给记录集加了排他锁，也就让查询变成了当前读。插入、更新、删除操作，都属于当前读。其实也就可以理解 select … for update 是为了让普通查询获得插入、更新、删除操作时所获得的锁。</p></blockquote><p>表面看起来 session1 只给了 b=1 这一行加了排他锁，但 session2 在请求其它行的排他锁时，却出现了锁等待。看下图：</p><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/RC隔离级别和条件字段无索引.png" alt="RC隔离级别和条件字段无索引"></p><p>由于 b 字段没有索引，因此只能走聚簇索引，进行全表扫描。从上图中可以看到，满足条件的记录有一条，但是聚簇索引上的所有记录，都被加上了 X 锁。</p><p>为什么不是只在满足条件的记录上加锁呢？</p><p>这是因为在 MySQL 中，如果一个条件无法通过索引快速过滤，那么存储引擎层面就会将所有记录加锁后返回，然后由 server 层进行过滤。因此也就把所有记录都锁上了。</p><blockquote><p>当然 MySQL 在这里有一些改进的，在 server 层过滤掉不满足条件的数据后，会把不满足条件的记录放锁。保证了最后只会持有满足条件的锁，但是每条记录的加锁操作还是不会省略。</p></blockquote><p>总结：<strong>没有索引的情况下，InnoDB 的当前读会对所有记录都加锁。所以在工作中应该特别注意 InnoDB 这一特性，否则可能会产生大量的锁冲突。</strong></p><h4 id="5-2-通过唯一索引查询"><a href="#5-2-通过唯一索引查询" class="headerlink" title="5.2 通过唯一索引查询"></a>5.2 通过唯一索引查询</h4><p>我们再来看一下条件字段有唯一索引的例子：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">set session transaction_isolation=’READ-COMMITTED’;/<em> 设置会话隔离级别为 RC</em>/</td><td style="text-align:left">set session transaction_isolation=’READ-COMMITTED’;/<em> 设置会话隔离级别为 RC </em>/</td></tr><tr><td style="text-align:left">begin; <br>use muke; <br>select * from t16 where a=1 for update; <br>… <br>1 row in set (0.00 sec)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">use muke; <br>select * from t16 where a=2 for update; <br>… <br>1 row in set (0.00 sec)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">select <em> from t16 where a=1 for update; <br> <em>*（等待）</em></em></td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left">select <em> from t16 where a=1 for update; <br>… <br>1 row in set (4.70 sec) <br> <em>*（session1 提交后，马上返回结果）</em></em></td></tr></tbody></table></div><p>session1 给了 a=1 这一行加了排他锁，在 session2 中请求其他行的排他锁时，不会发生等待；但是在 session2 中请求 a=1 这一行的排他锁时，会发生等待。看下图：</p><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/RC隔离级别和条件字段有唯一索引.png" alt="RC隔离级别和条件字段有唯一索引"></p><p>由于 a 是唯一索引，因此 select * from t16 where a=1 for update；(后面称为 SQL2) 语句会选择走 a 列的索引进行条件过滤，在找到 a=1 的记录后，会将唯一索引上 a=1 索引记录上加 X 锁，同时，会根据读取到的 id 列，回到聚簇索引，然后将 id=1 对应的聚簇索引项加 X 锁。</p><p>为什么聚簇索引上的记录也要加锁呢？</p><p>比如，并发的一条 SQL，是通过主键索引来更新：update t16 set b=10 where id =1; 如果 SQL2 没有将主键索引上的记录加锁，那么并发的 update 并不知道 SQL2 在执行，所以如果 update 执行了，就违背了同一记录上的更新或者删除需要串行执行的约束。</p><p>总结：<strong>如果查询的条件是唯一索引，那么 SQL 需要在满足条件的唯一索引上加锁，并且会在对应的聚簇索引上加锁。</strong></p><h4 id="5-3-通过非唯一索引查询"><a href="#5-3-通过非唯一索引查询" class="headerlink" title="5.3 通过非唯一索引查询"></a>5.3 通过非唯一索引查询</h4><p>我们再来看一下条件字段有非唯一索引的例子：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th><th style="text-align:left">session3</th></tr></thead><tbody><tr><td style="text-align:left">set session transaction_isolation=’READ-COMMITTED’;/<em> 设置会话隔离级别为 RC</em>/</td><td style="text-align:left">set session transaction_isolation=’READ-COMMITTED’;/<em> 设置会话隔离级别为 RC</em>/</td><td style="text-align:left">set session transaction_isolation=’READ-COMMITTED’;/<em> 设置会话隔离级别为 RC</em>/</td></tr><tr><td style="text-align:left">begin;</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">use muke; <br>select * from t16 where c=3 for update; <br>… <br>2 rows in set (0.00 sec)</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">use muke; <br>select * from t16 where a=1 for update; <br>… <br>1 row in set (0.00 sec)</td><td style="text-align:left">use muke; select * from t16 where a=2 for update; <br>… <br>1 row in set (0.00 sec)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">select <em> from t16 where a=3 for update; <br> <em>*(等待)</em></em></td><td style="text-align:left">select <em> from t16 where a=4 for update; <br> <em>*(等待)</em></em></td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left">select <em> from t16 where a=3 for update; <br>… <br> <em>*(session1 提交后，马上返回结果)</em></em></td><td style="text-align:left">select <em> from t16 where a=4 for update; <br>… <br> <em>*(session1 提交后，马上返回结果)</em></em></td></tr></tbody></table></div><p>我们在满足条件 c=3 的数据上加了排他锁，如上面结果，就是第 3、4 行。因此第 1、2 行的数据没被锁，而 3、4 行的数据被锁了。如下图：</p><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/RC隔离级别和条件字段有非唯一索引.png" alt="RC隔离级别和条件字段有非唯一索引"></p><p>通过上图可以看到，在 a 字段的非唯一索引上，满足 c=3 的所有记录，都被加了锁。同时，对应的主键索引上的记录也都加上了锁。与通过唯一索引查询的情况相比，唯一索引查询最多有一行记录被锁，而非唯一索引将会把满足条件的所有记录都加上锁。</p><p>总结：<strong>如果查询的条件是非唯一索引，那么 SQL 需要在满足条件的非唯一索引上都加上锁，并且会在它们对应的聚簇索引上加锁。</strong></p><h2 id="17-间隙锁的意义"><a href="#17-间隙锁的意义" class="headerlink" title="17 间隙锁的意义"></a><strong>17 间隙锁的意义</strong></h2><h3 id="1-揭晓上一节课后问题的答案"><a href="#1-揭晓上一节课后问题的答案" class="headerlink" title="1 揭晓上一节课后问题的答案"></a>1 揭晓上一节课后问题的答案</h3><p>拿上节的测试表 t16，进行如下实验：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">set session transaction_isolation=’READ-COMMITTED’;/<em> 设置会话隔离级别为 RC</em>/</td><td style="text-align:left">set session transaction_isolation=’READ-COMMITTED’;/<em> 设置会话隔离级别为 RC</em>/</td></tr><tr><td style="text-align:left">begin;</td><td style="text-align:left">begin;</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">use muke; <br>select <em> from t16 where c=3 for update; <br> <em>*Result1</em></em></td></tr><tr><td style="text-align:left">use muke; insert into t16(a,b,c) values (5,5,3);</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">select <em> from t16 where c=3 for update; <br> <em>*Result2</em></em></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">commit;</td></tr></tbody></table></div><p>我们看一下上面的实验结果：Result 1 和 Result 2 结果是不同的。在 session2 中，同一个事务中，按相同的查询条件重新读取以前检索过的数据，却发现了 session1 插入的满足查询条件的新数据，这也就是上一节讲到的幻读情况。</p><p>为什么上面的实验中会出现幻读呢？</p><p>我们来看看下面这张图：</p><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/RC隔离级别和条件字段有非唯一索引（幻读）.png" alt="RC隔离级别和条件字段有非唯一索引（幻读）"></p><p>从图中可以看出，RC 隔离级别下，只锁住了满足 c=3 的当前行，而不会对后面的位置（或者说间隙）加锁，因此导致 session1 的写入语句能正常执行并提交。</p><p>那么应该怎样降低幻读出现的概率呢？</p><p>从上面的分析我们可以知道，产生幻读的原因是：行锁只能锁住当前行，但是新插入的记录，是在被锁住记录之前的间隙。因此，为了降低幻读出现的概率，InnoDB 在 RR 隔离级别下配置了间隙锁（Gap Lock）。</p><h3 id="2-RR-隔离级别下的非唯一索引查询"><a href="#2-RR-隔离级别下的非唯一索引查询" class="headerlink" title="2 RR 隔离级别下的非唯一索引查询"></a>2 RR 隔离级别下的非唯一索引查询</h3><p>我们继续看上面的实验，这里不同点是我们把隔离级别设置成 RR。</p><p>我们再单独建一张表，表结构与上节的表结构一致，为了方便后面分析，数据稍微有改动，语句如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">use</span> muke<span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t17<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t17<span class="token punctuation">`</span> <span class="token punctuation">(</span>    <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>c<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">`</span>uniq_a<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_c<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>c<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span>  <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t17<span class="token punctuation">(</span>id<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>开始RR隔离级别下的实验：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">set session transaction_isolation=’REPEATABLE-READ’;/<em> 设置会话隔离级别为 RR</em>/</td><td style="text-align:left">set session transaction_isolation=’REPEATABLE-READ’;/<em> 设置会话隔离级别为 RR</em>/</td></tr><tr><td style="text-align:left">begin;</td><td style="text-align:left">begin;</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">use muke; <br>select <em> from t17 where c=4 for update; <br> <em>*Result1</em></em></td></tr><tr><td style="text-align:left">use muke; <br>insert into t17(a,b,c) values (7,7,4); /<em> SQL 1 </em>/</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">select <em> from t17 where c=4 for update; <br> <em>*Result2</em></em></td></tr><tr><td style="text-align:left">insert intot17(a,b,c) values (7,7,4); /<em> SQL 1 </em>/<br>Query  OK, 1 row affected (20.73 sec)<br>（等session2 执行commit; 后，SQL1马上返回结果）</td><td style="text-align:left">commit;</td></tr><tr><td style="text-align:left">commit;</td></tr></tbody></table></div><p>根据实验情况，我们在 session2 中，对满足条件 c=4 的数据加上了排他锁，然后在 session1 写入一条 c=4 的记录，此时会出现等待，直到 session2 对事务进行提交后，session1 才会执行成功。这是为什么呢？我们来看下图：</p><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/RR隔离级别和条件字段有非唯一索引.png" alt="RR隔离级别和条件字段有非唯一索引"></p><p>与 RC 隔离级别下的图相似，但是有个比较大的区别是：RR 隔离级别多了 GAP 锁。</p><p>如上图，首先需要考虑哪些位置可以插入新的满足条件 c=4 的项：</p><ul><li>由于 B+ 树索引是有序的，因此 [2,2]（代表 c 和 id 的值，后面就不一一说明了）前面的记录，不可能插入 c=4 的记录了；</li><li>[2,2] 与 [4,4] 之间可以插入 [4,3]；</li><li>[4,4] 与 [4,6] 之间可以插入 [4,5]；</li><li>[4,6] 之后，可以插入的值就很多了：[4,n] (其中 n&gt;6) ；</li></ul><p>为了保证这几个区间不会插入新的满足条件 c=4 的记录，MySQL RR 隔离级别选择了 GAP 锁，将这几个区间锁起来。</p><p>而上面实验中，语句 insert into t17 (a,b,c) values (7,7,4) 其对应插入 c 和 id 的值为 [4,7]，是在最后这个被 GAP Lock 锁住的区间，因此如上面实验，insert 操作会等待。</p><h3 id="3-RR-隔离级别下的非索引字段查询"><a href="#3-RR-隔离级别下的非索引字段查询" class="headerlink" title="3 RR 隔离级别下的非索引字段查询"></a>3 RR 隔离级别下的非索引字段查询</h3><p>上一节中，我们测试了 RC 隔离级别下，非索引字段做条件的当前读会对所有记录都加锁。</p><p>这一节，我们测试一下 RR 隔离级别下，非索引字段做条件的当前读加锁情况。</p><p>首先对 t17 表中的数据做初始化：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">use</span> muke<span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t17<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t17<span class="token punctuation">`</span> <span class="token punctuation">(</span>    <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>c<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">`</span>uniq_a<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_c<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>c<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span>  <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t17<span class="token punctuation">(</span>id<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th><th style="text-align:left">session3</th></tr></thead><tbody><tr><td style="text-align:left">set session transaction_isolation=’REPEATABLE-READ’;/<em> 设置会话隔离级别为 RR</em>/</td><td style="text-align:left">set session transaction_isolation=’REPEATABLE-READ’;/<em> 设置会话隔离级别为 RR</em>/</td><td style="text-align:left">set session transaction_isolation=’REPEATABLE-READ’;/<em> 设置会话隔离级别为 RR</em>/</td></tr><tr><td style="text-align:left">begin;</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">use muke; <br>select * from t17 where b=1 for update; <br>… <br>1 rows in set (0.00 sec)</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">use muke; <br>select <em> from t17 where b=2 for update; <br> <em>*(等待)</em></em></td><td style="text-align:left">insert into t17(a,b,c) values(10,10,10); <br> <strong>(等待)</strong></td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left">select <em> from t17 where b=2 for update; <br>… <br> <em>*(session1 提交后，马上返回结果)</em></em></td><td style="text-align:left">insert into t17(a,b,c) values(10,10,10); <br>… <br> <strong>(session1 提交后，马上写入)</strong></td></tr></tbody></table></div><p>可能你会问？为什么 session3 的 insert 会出现等待？</p><p>我们看看下图：</p><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/RR隔离级别和条件字段无索引.png" alt="RR隔离级别和条件字段无索引"></p><p>如图，所有记录都有 X 锁，除此之外，每个 GAP 也被加上了 GAP 锁。因此这张表在执行完 select * from t17 where b=1 for update; 到 commit 之前，除了不加锁的快照读，其它任何加锁的 SQL，都会等待，如果这是线上业务表，那就是件非常恐怖的事情了。</p><p>总结：RR 隔离级别下，非索引字段做条件的当前读不但会把每条记录都加上 X 锁，还会把每个 GAP 加上 GAP 锁。再次说明，条件字段加索引的重要性。</p><h3 id="4-RR-隔离级别下的唯一索引当前读是否会用到-GAP-锁"><a href="#4-RR-隔离级别下的唯一索引当前读是否会用到-GAP-锁" class="headerlink" title="4 RR 隔离级别下的唯一索引当前读是否会用到 GAP 锁"></a>4 RR 隔离级别下的唯一索引当前读是否会用到 GAP 锁</h3><p>GAP 锁的目的是：为了防止同一事务两次当前读，出现幻读的情况。如果能确保索引字段唯一，那其实一个等值查询，最多就返回一条记录，而且相同索引记录的值，一定不会再新增，因此不会出现 GAP 锁。</p><p>因此以唯一索引为条件的当前读，不会有 GAP 锁。所以 RR 隔离级别下的唯一索引当前读加锁情况与 RC 隔离级别下的唯一索引当前读加锁情况一致。这里就不再实验了。</p><h2 id="18-为什么会出现死锁？"><a href="#18-为什么会出现死锁？" class="headerlink" title="18 为什么会出现死锁？"></a>18 为什么会出现死锁？</h2><h3 id="1-认识死锁"><a href="#1-认识死锁" class="headerlink" title="1 认识死锁"></a>1 认识死锁</h3><p>死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。</p><p>InnoDB 中解决死锁问题有两种方式：</p><ol><li>检测到死锁的循环依赖，立即返回一个错误（这个报错内容请看下面的实验），将参数 innodb_deadlock_detect 设置为 on 表示开启这个逻辑；</li><li>等查询的时间达到锁等待超时的设定后放弃锁请求。这个超时时间由 innodb_lock_wait_timeout 来控制。默认是 50 秒。</li></ol><blockquote><p>一般线上业务都建议使用的第 1 种策略，因为第 2 种策略锁等待时间是 50 秒，对于高并发的线上业务是不能接受的。<br>但是第 1 种策略，也会有死锁检测时的额外 CPU 开销的，比如电商中的秒杀场景。这种情况就可以根据业务开发商量优化程序，如果可以确保业务一定不会出现死锁，可以临时把死锁检测关掉，以提高并发效率。</p></blockquote><h3 id="2-为什么会产生死锁"><a href="#2-为什么会产生死锁" class="headerlink" title="2 为什么会产生死锁"></a>2 为什么会产生死锁</h3><h4 id="2-1-同一张表中"><a href="#2-1-同一张表中" class="headerlink" title="2.1 同一张表中"></a>2.1 同一张表中</h4><p>不同线程并发访问同一张表的多行数据，未按顺序访问导致死锁。</p><h4 id="2-2-不同表之间"><a href="#2-2-不同表之间" class="headerlink" title="2.2 不同表之间"></a>2.2 不同表之间</h4><p>不同线程并发访问多个表时，未按顺序访问导致死锁。</p><h4 id="2-3-事务隔离级别"><a href="#2-3-事务隔离级别" class="headerlink" title="2.3 事务隔离级别"></a>2.3 事务隔离级别</h4><p>RR隔离级别下，由于间隙锁导致死锁。</p><h3 id="3-如何降低死锁概率"><a href="#3-如何降低死锁概率" class="headerlink" title="3 如何降低死锁概率"></a>3 如何降低死锁概率</h3><p>那么应该怎样降低出现死锁的概率呢？这里总结了如下一些经验：</p><ol><li>更新 SQL 的 where 条件尽量用索引；</li><li>基于 primary 或 unique key 更新数据；</li><li>减少范围更新，尤其非主键、非唯一索引上的范围更新；</li><li>加锁顺序一致，尽可能一次性锁定所有需要行；</li><li>将 RR 隔离级别调整为 RC 隔离级别。</li></ol><h3 id="4-分析死锁的方法"><a href="#4-分析死锁的方法" class="headerlink" title="4 分析死锁的方法"></a>4 分析死锁的方法</h3><p>尽管在上面介绍了降低死锁概率的方法，但是在实际工作中，死锁很难完全避免。因此，捕获并处理死锁也是一个好的编程习惯。</p><p>InnoDB 中，可以使用 SHOW INNODB STATUS 命令来查看最后一个死锁的信息。我们可以尝试用下这个命令获取一些死锁信息，如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">engine</span> <span class="token keyword">innodb</span> <span class="token keyword">status</span>\G<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>另外设置 innodb_print_all_deadlocks = on 可以在 err log 中记录全部死锁信息。</p><hr><p>第4章 事务</p><h2 id="19-数据库忽然断电会丢失数据吗？"><a href="#19-数据库忽然断电会丢失数据吗？" class="headerlink" title="19 数据库忽然断电会丢失数据吗？"></a>19 数据库忽然断电会丢失数据吗？</h2><h3 id="1-什么是事务？"><a href="#1-什么是事务？" class="headerlink" title="1 什么是事务？"></a>1 什么是事务？</h3><p>根据《高性能 MySQL》第 3 版 1.3 事务一节中定义：</p><blockquote><p>事务就是一组原子性的 SQL 查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。</p></blockquote><p>一个良好的事务处理系统，必须具备 ACID 特性：</p><ul><li>atomicity（原子性） ：要么全执行，要么全都不执行；</li><li>consistency（一致性）：在事务开始和完成时，数据都必须保持一致状态；</li><li>isolation（隔离性） ：事务处理过程中的中间状态对外部是不可见的；</li><li>durability（持久性） ：事务完成之后，它对于数据的修改是永久性的。</li></ul><p>InnoDB 采用 redo log 机制来保证事务更新的一致性和持久性。</p><h3 id="2-Redo-log"><a href="#2-Redo-log" class="headerlink" title="2 Redo log"></a>2 Redo log</h3><p>Redo log 称为重做日志，用于记录事务操作变化，记录的是数据被修改之后的值。</p><p>Redo log 由两部分组成：</p><ul><li>内存中的重做日志缓冲（redo log buffer）</li><li>重做日志文件（redo log file）</li></ul><p>每次数据更新会先更新 redo log buffer，然后根据 innodb_flush_log_at_trx_commit 来控制 redo log buffer 更新到 redo log file 的时机。innodb_flush_log_at_trx_commit 有三个值可选：</p><p>0：事务提交时，每秒触发一次 redo log buffer 写磁盘操作，并调用操作系统 fsync 刷新 IO 缓存。</p><p>1：事务提交时，InnoDB 立即将缓存中的 redo 日志写到日志文件中，并调用操作系统 fsync 刷新 IO 缓存；</p><p>2：事务提交时，InnoDB 立即将缓存中的 redo 日志写到日志文件中，但不是马上调用 fsync 刷新 IO 缓存，而是每秒只做一次磁盘 IO 缓存刷新操作。</p><p>innodb_flush_log_at_trx_commit 参数的默认值是 1，也就是每个事务提交的时候都会从 log buffer 写更新记录到日志文件，而且会刷新磁盘缓存，这完全满足事务持久化的要求，是最安全的，但是这样会有比较大的性能损失。</p><p>将参数设置为 0 时，如果数据库崩溃，最后 1秒钟的 redo log 可能会由于未及时写入磁盘文件而丢失，这种方式尽管效率最高，但是最不安全。</p><p>将参数设置为 2 时，如果数据库崩溃，由于已经执行了重做日志写入磁盘的操作，只是没有做磁盘 IO 刷新操作，因此，只要不发生操作系统奔溃，数据就不会丢失，这种方式是对性能和安全的一种折中处理。</p><h3 id="3-Binlog"><a href="#3-Binlog" class="headerlink" title="3 Binlog"></a>3 Binlog</h3><p>二进制日志（binlog）记录了所有的 DDL（数据定义语句）和 DML（数据操纵语句），但是不包括 select 和 show 这类操作。Binlog 有以下几个作用：</p><ul><li>恢复：数据恢复时可以使用二进制日志</li><li>复制：通过传输二进制日志到从库，然后进行恢复，以实现主从同步</li><li>审计：可以通过二进制日志进行审计数据的变更操作</li></ul><p>可以通过参数 sync_binlog 来控制累积多少个事务后才将二进制日志 fsync 到磁盘。</p><ul><li>sync_binlog=0，表示每次提交事务都只write，不fsync</li><li>sync_binlog=1，表示每次提交事务都会执行fsync</li><li>sync_binlog=N(N&gt;1)，表示每次提交事务都write，累积N个事务后才fsync</li></ul><p>比如要加快写入数据的速度或者机器磁盘 IO 瓶颈时，可以将 sync_binlog 设置成大于 1 的值，但是如果设置为 N(N&gt;1)时，如果数据库崩溃，可能会丢失最近 N 个事务的 binlog。</p><h3 id="4-怎样确保数据库突然断电不丢数据？"><a href="#4-怎样确保数据库突然断电不丢数据？" class="headerlink" title="4 怎样确保数据库突然断电不丢数据？"></a>4 怎样确保数据库突然断电不丢数据？</h3><p>通过上面的讲解，只要 innodb_flush_log_at_trx_commit 和 sync_binlog 都为 1（通常称为：双一），就能确保 MySQL 机器断电重启后，数据不丢失。</p><p>因此建议在比较重要的库，比如涉及到钱的库，设置为双一，而你的测试环境或者正式业务不那么重要的库（比如日志库）可以将 innodb_flush_log_at_trx_commit 设置为0，sync_binlog 设置成大于100 的数值，提高更新效率。</p><h2 id="20-MVCC怎么实现的"><a href="#20-MVCC怎么实现的" class="headerlink" title="20 MVCC怎么实现的?"></a>20 MVCC怎么实现的?</h2><p>本节跟大家一起聊聊 MVCC（Multi-Version Concurrency Control，多版本并发控制）。为了方便理解，在讲解 MVCC 之前，我们先来聊聊隐藏列、Undo log 和 Read View。</p><h3 id="1-隐藏列"><a href="#1-隐藏列" class="headerlink" title="1 隐藏列"></a>1 隐藏列</h3><p>对于 InnoDB ，每行记录除了我们创建的字段外，其实还包含 3 个隐藏的列：</p><ul><li>ROW ID：隐藏的自增 ID，如果表没有主键，InnoDB 会自动以 ROW ID 产生一个聚集索引树。</li><li>事务 ID：记录最后一次修改该记录的事务 ID。</li><li>回滚指针：指向这条记录的上一个版本。</li></ul><h3 id="2-Undo-log"><a href="#2-Undo-log" class="headerlink" title="2 Undo log"></a>2 Undo log</h3><p>上节我们讲到了 redo log，它记录了事务操作变化。但是事务有时是需要回滚的，这时，Undo log 就发挥了作用。Undo log 是逻辑日志，将数据库逻辑地恢复到原来的样子，所有修改都被逻辑的取消了。</p><ul><li>如果是 insert 操作，其对应的回滚操作就是 delete；</li><li>如果是 delete，则对应的回滚操作是 insert；</li><li>如果是 update，则对应的回滚操作是一个反向的 update 操作。</li></ul><p>Undo log 的作用除了回滚操作，Undo log 的另一个作用是 MVCC，InnoDB 存储引擎中 MVCC 的实现是通过 Undo log 来完成的。当用户读取一行记录时，若该记录已经被其它事务占用，当前事务可以通过 Undo log 读取之前的行版本信息，因为没有事务需要对历史的数据进行修改操作，所以也不需要加锁，以此来实现非锁定读取。</p><h3 id="3-Read-View"><a href="#3-Read-View" class="headerlink" title="3 Read View"></a>3 Read View</h3><p>Read View 是指事务进行快照读操作的那一刻，产生数据库系统当前活跃事务列表的一个快照。</p><p>Read View 中大致包含以下内容：</p><ul><li>trx_ids：数据库系统当前活跃事务 ID 集合；</li><li>low_limit_id：活跃事务中最大的事务 ID +1；</li><li>up_limt_id：活跃事务总最小的事务 ID；</li><li>creator_trx_id：创建这个 Read View 的事务 ID。</li></ul><p>比如某个事务，创建了 Read View，那么它的 creator_trx_id 就为这个事务的 ID，假如需要访问某一行，假设这一行记录的隐藏事务 ID 为 t_id，那么可能出现的情况如下：</p><ul><li>如果 t_id &lt; up_limt_id，说明这行记录在这些活跃的事务创建之前就已经提交了，那么这一行记录对该事务是可见的。</li><li>如果 t_id &gt;= low_limt_id，说明这行记录在这些活跃的事务开始之后创建的，那么这一行记录对该事物是不可见的。</li><li>如果 up_limit_id &lt;= t_id &lt; low_limit_id，说明这行记录可能是在这些活跃的事务中创建的，如果 t_id 也同时在 trx_ids 中，则说明 t_id 还未提交，那么这一行记录对该事物是不可见的；如果 t_id 不在 trx_ids 中，则说明事务 t_id 已经提交了，那么这一行记录对该事物是可见的。</li></ul><p>对于不可见的记录，都是通过查询 Undo log 来查询老的记录。</p><p>了解了上面的原理，我们知道了，Read View 规则帮我们判断当前版本的数据是否可见。下面，我们分析下当查询一条记录时，大致的步骤：</p><ul><li>获取事务本身的事务 ID；</li><li>获取 Read View；</li><li>查询得到的数据，然后与 Read View 中的事务版本号进行比较；</li><li>如果能查询，则直接查询对应的记录；如果不能直接查询，则通过 Undo Log 中获取历史快照；</li><li>最终返回结果。</li></ul><p>另外需要补充的一点就是，在 RR 和 RC 隔离级别下，获取 Read View 的时机也是不一样的：</p><ul><li>在可重复读隔离级别（RR）下，同一个事务中，查询语句只是在第一个读请求发起时获取 Read View，而后面相同的查询语句都会使用这个 Read View。</li><li>在读已提交隔离级别（RC）下，同一个事务中，同样的查询语句在每次读请求发起时都会获得 Read View。</li></ul><h3 id="4-什么是-MVCC？"><a href="#4-什么是-MVCC？" class="headerlink" title="4 什么是 MVCC？"></a>4 什么是 MVCC？</h3><p>在说 MVCC 之前，大家先看看下面这个例子。</p><p>首先创建表并写入测试数据：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">use</span> muke<span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t20<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t20<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_c<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t20<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进行实验：</p><div class="table-container"><table><thead><tr><th></th><th>session1</th><th>session2</th></tr></thead><tbody><tr><td>1</td><td>set session transaction_isolation=’READ-COMMITTED’;/<em> 设置会话隔离级别为 RC</em>/</td><td>set session transaction_isolation=’READ-COMMITTED’;/<em> 设置会话隔离级别为 RC</em>/</td></tr><tr><td>2</td><td>select <em> from t20;<br> <em>*Result1</em></em></td><td></td></tr><tr><td>3</td><td>begin;</td><td></td></tr><tr><td>4</td><td>update t20 set b=666 where a=1;</td><td></td></tr><tr><td>5</td><td></td><td>begin;</td></tr><tr><td>6</td><td></td><td>select <em> from t20;<br> <em>*Result2</em></em></td></tr><tr><td>7</td><td>commit;</td><td></td></tr><tr><td>8</td><td></td><td>select <em> from t20;<br> <em>*Result3</em></em></td></tr><tr><td>9</td><td></td><td>commit;</td></tr></tbody></table></div><p>其中</p><p><strong>Result1</strong>：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----+---+---+| id | a | b |+----+---+---+|  1 | 1 | 1 ||  2 | 2 | 2 |+----+---+---+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Result2</strong>：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">mysql&gt; select * from t20;+----+---+---+| id | a | b |+----+---+---+|  1 | 1 | 1 ||  2 | 2 | 2 |+----+---+---+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Result3</strong>：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">mysql&gt; select * from t20;+----+---+-----+| id | a | b   |+----+---+-----+|  1 | 1 | 666 ||  2 | 2 |   2 |+----+---+-----+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 session1 更新了 a=1 这行记录，但还没提交的情况下，在 session2 中，满足 a=1 这条记录，b 的值还是原始值 1，而不是 session 1 更新之后的 666，那么在数据库层面，这是怎么实现的呢？</p><p>其实 InnoDB 就是通过 MVCC 和 Undo log 来实现的。</p><p>什么是 MVCC 呢？</p><p>MVCC， 即多版本并发控制。MVCC 的实现，是通过保存数据在某个时间点的快照来实现的，也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。</p><p>也就是上面实验第 6 步中，为什么 session2 查询的结果还是 session1 修改之前的记录。</p><h3 id="5-MVCC-的实现原理"><a href="#5-MVCC-的实现原理" class="headerlink" title="5 MVCC 的实现原理"></a>5 MVCC 的实现原理</h3><p>我们拿上面的例子，对应解释下 MVCC 的实现原理，如下图：</p><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/MVCC实现原理.png" alt="MVCC实现原理"></p><p>如图，首先 insert 语句向表 t20 中插入了一条数据，a 字段为 1，b 字段为 1， ROW ID 也为 1 ，事务 ID 假设为 1，回滚指针假设为 null。当执行 update t20 set b=666 where a=1 时，大致步骤如下：</p><ul><li>数据库会先对满足 a=1 的行加排他锁；</li><li>然后将原记录复制到 undo 表空间中；</li><li>修改 b 字段的值为 666，修改事务 ID 为 2；</li><li>并通过隐藏的回滚指针指向 Undo log 中的历史记录；</li><li>事务提交，释放前面对满足 a=1 的行所加的排他锁。</li></ul><p>在前面实验的第 6 步中，session2 查询的结果是 session1 修改之前的记录，也就是那个点的 Read View，根据上面将的 Read View 原理，被查询行的隐藏事务 ID 就在当前活跃事务 ID 集合中。因此，这一行记录对该事物（session2 中的事务）是不可见的，可以知道 session2 查询的 a=1 这行记录实际就是来自 Undo log 中。我们看到的现象就是同一条记录在系统中存在了多个版本，这就是 MySQL 的多版本并发控制（MVCC）。</p><p>需要注意的是，MVCC 只在 RC 和 RR 两个隔离级别下工作。因此在上面的实验中，改成 RR 隔离级别，第 6 步中，得到的结果还是 session1 修改之前的记录（但是在第 8 步，结果不一样哦，感兴趣的可以把上面操作放在 RR 隔离级别下实验一下）</p><h3 id="6-MVCC-的优势"><a href="#6-MVCC-的优势" class="headerlink" title="6 MVCC 的优势"></a>6 MVCC 的优势</h3><p>MVCC 最大的好处是读不加锁，读写不冲突，极大地增加了 MySQL 的并发性。</p><p>通过 MVCC，保证了事务 ACID 中的 I（隔离性）特性。</p><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h3><p>我们知道了，MySQL 是通过 Read View 判断是否能直接查询到对应的记录，如果需要查询一些被其它事务正在更新的行，则要取出 Undo log 中历史版本的记录。</p><p>MVCC 实现的原理大致是：</p><p>InnoDB 每一行数据都有一个隐藏的回滚指针，用于指向该行修改前的最后一个历史版本，这个历史版本存放在 Undo log 中。如果要执行更新操作，会将原记录放入 Undo log 中，并通过隐藏的回滚指针指向 Undo log 中的原记录。其它事务此时需要查询时，就是查询 Undo log 中这行数据的最后一个历史版本。</p><p>MVCC 最大的好处是读不加锁，读写不冲突，极大的增加了 MySQL 的并发性，通过 MVCC，也保证了事务 ACID 中的 I（隔离性）特性。</p><h3 id="8-问题"><a href="#8-问题" class="headerlink" title="8 问题"></a>8 问题</h3><p>MVCC 为什么只在 RC 和 RR 两个隔离级别下工作？</p><p>解答：</p><p>从查询方面看，MVCC是解决在并发条件下，同时可能会产生多个值，如何从多个值中选择一个值的技术。</p><p>但在RU和串行的隔离级别下，只会存在一个值。</p><ul><li>RU：每次只取最新的值，不存在多个值的情况。</li><li>串行：每次查询都会加读锁，当有更新时会阻塞住，只有等到查询完锁释放后，才会做更新操作。所以也不存在多个值的情况。</li></ul><h2 id="21-不同事务隔离级别有哪些区别？"><a href="#21-不同事务隔离级别有哪些区别？" class="headerlink" title="21 不同事务隔离级别有哪些区别？"></a>21 不同事务隔离级别有哪些区别？</h2><h3 id="1-通过基本定义认识事务隔离级别"><a href="#1-通过基本定义认识事务隔离级别" class="headerlink" title="1 通过基本定义认识事务隔离级别"></a>1 通过基本定义认识事务隔离级别</h3><p>MySQL 有四种隔离级别，我们来看一下这四种隔离级别的基本定义：</p><ul><li>Read uncommitted（读未提交，简称：RU）: 在该隔离级别，所有事务都可以看到其它未提交的事务的执行结果。可能会出现脏读。</li><li>Read Committed（读已提交，简称： RC）：一个事务只能看见已经提交事务所做的改变。因为同一事务的其它实例在该实例处理期间可能会有新的 commit，所以可能出现幻读。</li><li>Repeatable Read（可重复读，简称：RR）：这是 MySQL 的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。消除了脏读、不可重复读，默认也不会出现幻读。</li><li>Serializable（串行）：这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问<br>题。</li></ul><h3 id="4-如何选择合适的事务隔离级别"><a href="#4-如何选择合适的事务隔离级别" class="headerlink" title="4 如何选择合适的事务隔离级别"></a>4 如何选择合适的事务隔离级别</h3><p>在上面的内容中，我们认识了事务隔离级别，那么应该怎样选择合适的事务隔离级别呢？</p><p>对于 RU 隔离级别，会导致脏读，从性能上看，也不会比其它隔离级别好太多，因此生产环境不建议使用。</p><p>对于 RC 隔离级别，相比 RU 隔离级别，不会出现脏读；但是会出现幻读，一个事务中的两次执行同样的查询，可能得到不一样的结果。</p><p>对于 RR 隔离级别，相比 RC 隔离级别，解决了部分幻读（这个在第 17 节详细讲了，RR 隔离级别通过间隙锁解决了部分幻读），但是相对于 RC，锁的范围可能更大了。</p><p>对于 Serializable 隔离级别，因为它强制事务串行执行，会在读取的每一行数据上都加锁，因此可能会导致大量的超时和锁争用的问题。生成环境很少使用。</p><p>因此总的来说，建议在 RC 和 RR 两个隔离级别中选一种，如果能接受幻读，需要并发高点，就可以配置成 RC，如果不能接受幻读的情况，就设置成 RR 隔离级别。</p><h3 id="22-养成好的事务习惯"><a href="#22-养成好的事务习惯" class="headerlink" title="22 养成好的事务习惯"></a>22 养成好的事务习惯</h3><h3 id="1-不好的事务习惯"><a href="#1-不好的事务习惯" class="headerlink" title="1 不好的事务习惯"></a>1 不好的事务习惯</h3><h4 id="1-1-在循环中提交"><a href="#1-1-在循环中提交" class="headerlink" title="1.1 在循环中提交"></a>1.1 在循环中提交</h4><p>在大多数情况下，MySQL 都是开启自动提交的，如果遇到循环执行 SQL，则相当于每个循环中都会进行一次提交，实际这算一个不好的事务习惯了。下面我创建一张测试表，并定义两个循环写入数据的存储过程：一个是自动提交，另一个是在循环前开启一个事务，在循环后一次性提交。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">use</span> muke<span class="token punctuation">;</span> <span class="token comment">/* 使用muke这个database */</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t22<span class="token punctuation">;</span> <span class="token comment">/* 如果表t22存在则删除表t22 */</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t22<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>c<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token punctuation">`</span>d<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_a<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_b<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>b<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span>  <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">procedure</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> insert_t22_1<span class="token punctuation">;</span> <span class="token comment">/* 如果存在存储过程insert_t22_1，则删除 */</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">procedure</span> insert_t22_1<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">/* 创建存储过程insert_t22_1 */</span><span class="token keyword">begin</span><span class="token keyword">declare</span> i <span class="token keyword">int</span><span class="token punctuation">;</span> <span class="token comment">/* 声明变量i */</span><span class="token keyword">set</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* 设置i的初始值为1 */</span><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token keyword">do</span> <span class="token comment">/* 对满足i&lt;=10000的值进行while循环 */</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t22<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 写入表t22中a、b两个字段，值都为i当前的值 */</span><span class="token keyword">set</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* 将i加1 */</span><span class="token keyword">end</span> <span class="token keyword">while</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span> <span class="token comment">/* 创建批量写入10000条数据到表t22的存储过程insert_t22_1 */</span><span class="token keyword">drop</span> <span class="token keyword">procedure</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> insert_t22_2<span class="token punctuation">;</span> <span class="token comment">/* 如果存在存储过程insert_t22_2，则删除 */</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">procedure</span> insert_t22_2<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">/* 创建存储过程insert_t22_2 */</span><span class="token keyword">begin</span><span class="token keyword">declare</span> i <span class="token keyword">int</span><span class="token punctuation">;</span> <span class="token comment">/* 声明变量i */</span><span class="token keyword">set</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* 设置i的初始值为1 */</span><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token keyword">do</span> <span class="token comment">/* 对满足i&lt;=10000的值进行while循环 */</span><span class="token keyword">insert</span> <span class="token keyword">into</span> t22<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 写入表t22中a、b两个字段，值都为i当前的值 */</span><span class="token keyword">set</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* 将i加1 */</span><span class="token keyword">end</span> <span class="token keyword">while</span><span class="token punctuation">;</span><span class="token keyword">commit</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">delimiter</span> <span class="token punctuation">;</span> <span class="token comment">/* 创建批量写入10000条数据到表t22的存储过程insert_t22_2 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们来对比两个存储过程的速度：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">mysql&gt; call insert_t22_1(); /* insert_t22_1 */Query OK, 1 row affected (28.36 sec)mysql&gt; call insert_t22_2(); /* insert_t22_2 */Query OK, 0 rows affected (0.37 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>明显第二种方式快的多。因为 insert_t22_1 每一次提交都要写一次重做日志，实际写了 10000 次重做日志，而存储过程 insert_t22_2 只写了 1 次重做日志。</p><p>因此，在类似这种循环写入的情况，如果循环次数不是太多，建议在循环前开启一个事务，循环结束后统一提交。</p><h3 id="1-2-不关注同一个事务里语句顺序"><a href="#1-2-不关注同一个事务里语句顺序" class="headerlink" title="1.2 不关注同一个事务里语句顺序"></a>1.2 不关注同一个事务里语句顺序</h3><p>比如 A 在超市购买 100 元的商品，付款操作可以简化为：</p><div class="table-container"><table><thead><tr><th>序号</th><th>操作</th></tr></thead><tbody><tr><td>1</td><td>A 的账户中扣除 100</td></tr><tr><td>2</td><td>超市的账户增加 100</td></tr><tr><td>3</td><td>在超市系统中记录一条日志</td></tr></tbody></table></div><p>很多时候我们会按上面的 SQL 步骤放入一个事务里执行，不关注里面语句的顺序。实际可以优化的。</p><p>根据两阶段锁，整个事务里面涉及的锁，需要等到事务提交时才会释放。因此我们在同一个事务中，可以把没锁或者锁范围小的语句放在事务前面执行，而锁定范围大的语句放在后面执行。</p><blockquote><p>这里来回顾一下第 16 节中提到的两阶段锁：锁操作分为两个阶段，加锁阶段和解锁阶段，并且保证加锁阶段和解锁阶段不相交。在执行语句的时候加上锁，但并不是语句执行完就立刻释放锁，而是要等到事务结束时才释放。</p></blockquote><p>因此上面 A 购买商品的例子中，可能很多人同时在超市付款，那么存在锁竞争的最可能是超市账户增加 100 元的操作。</p><p>那么付款操作可以这么优化：</p><div class="table-container"><table><thead><tr><th>序号</th><th>操作</th></tr></thead><tbody><tr><td>1</td><td>在超市系统中记录一条日志</td></tr><tr><td>2</td><td>A 的账户中扣除 100</td></tr><tr><td>3</td><td>超市的账户增加 100</td></tr></tbody></table></div><p>把可能存在锁竞争的操作放在最后执行，从而优化整个事务。</p><p>因此在写程序时，应该去关注事务里的语句顺序。</p><h3 id="1-3-不关注不同事务访问资源的顺序"><a href="#1-3-不关注不同事务访问资源的顺序" class="headerlink" title="1.3 不关注不同事务访问资源的顺序"></a>1.3 不关注不同事务访问资源的顺序</h3><p>各位是否还记得，在第 18 节中，讲到了几种产生死锁的原因，其中有两条就跟不同事务访问资源顺序有关，我们来回顾一下：</p><ul><li>不同线程并发访问同一张表的多行数据，未按顺序访问导致死锁。</li><li>不同线程并发访问多个表时，未按顺序访问导致死锁。</li></ul><p>如果不关注并发访问的不同事务中访问资源的顺序，就会增大出现死锁的概率。</p><p>因此，为了降低死锁，我们需要去关注不同事务访问资源的顺序。</p><h4 id="1-4-不关注事务隔离级别"><a href="#1-4-不关注事务隔离级别" class="headerlink" title="1.4 不关注事务隔离级别"></a>1.4 不关注事务隔离级别</h4><p>在上一节中，我们详细聊到了事务隔离级别，因此也知道，不同事务隔离级别加锁的情况也是不同的。</p><p>如果完全不关注自己业务使用的 MySQL 是什么隔离级别，可能会降低程序的并发能力或者导致死锁。</p><p>比如业务场景完全能接受幻读，如果要求更高的 QPS，使用 RR 隔离级别显然不是最好的选择，因此可以改为 RC 隔离级别。</p><p>而如果业务使用的是 RR 隔离级别，可能由于间隙锁导致死锁（可参考第 18 节 2.3 中的例子），因此也应该在程序编写时关注 RR 隔离级别下是否会有间隙锁。</p><p>因此，为了更高的并发和降低死锁概率，在创建事务前，也应该去关注自己业务的数据库是什么事务隔离级别。</p><h4 id="1-5-在事务中混合使用存储引擎"><a href="#1-5-在事务中混合使用存储引擎" class="headerlink" title="1.5 在事务中混合使用存储引擎"></a>1.5 在事务中混合使用存储引擎</h4><p>在事务中混合使用事务型（比如 InnoDB）和非事务型（比如 MyISAM）表，如果是正常提交，到没什么问题。</p><p>但是，如果该事务回滚了，事务型的表可以正常回滚，而非事务型的表的变更就无法回滚了。这种情况就会导致数据不正常，并且事务最终的结果也难以确定。</p><p>因此，在事务中混合使用存储引擎也是一个不好的事务习惯。</p><blockquote><p>值得一提的是：如果开启 GTID，那么当同一个事务中使用不同存储引擎的表时，会出现如下报错：<br>ERROR 1785 (HY000): Statement violates GTID consistency: Updates to non-transactional tables can only be done in either autocommitted statements or single-statement transactions, and never in the same statement as updates to transactional tables.<br>因此，开启 GTID 的情况，可以避免同一个事务中混合使用存储引擎的情况。</p></blockquote><h3 id="2-总结一下好的事务习惯"><a href="#2-总结一下好的事务习惯" class="headerlink" title="2 总结一下好的事务习惯"></a>2 总结一下好的事务习惯</h3><p>在本节中，我们列举了几种不好的事务习惯，这里总结一下好的事务习惯：</p><ul><li>循环写入的情况，如果循环次数不是太多，建议在循环前开启一个事务，循环结束后统一提交。</li><li>优化事务里的语句顺序，减少锁时间。</li><li>关注不同事务访问资源的顺序。</li><li>创建事务之前，关注事务隔离级别。</li><li>不在事务中混合使用存储引擎。</li></ul><h2 id="23-细聊分布式事务"><a href="#23-细聊分布式事务" class="headerlink" title="23 细聊分布式事务"></a>23 细聊分布式事务</h2><p>比如你在网上买了一本书，可以简化为在订单库增加订单，在库存库减掉这本书的 1 个库存。这里订单库和库存库是在不同的机器上，如果这两步放在两个事务里，增加订单这一步成功了，但是减库存这里失败了。那岂不是就乱了。</p><p>这里就要引出分布式事务了。什么是分布式事务？</p><h3 id="1-认识分布式事务"><a href="#1-认识分布式事务" class="headerlink" title="1 认识分布式事务"></a>1 认识分布式事务</h3><p>分布式事务是指一个大的事务由很多小操作组成，小操作分布在不同的服务器上或者不同的应用程序上。分布式事务需要保证这些小操作要么全部成功，要么全部失败。MySQL 从 5.0.3 开始支持分布式事务。</p><p>分布式事务使用两阶段提交协议：</p><ul><li>第一阶段：所有分支事务都开始准备，告诉事务管理器自己已经准备好了；</li><li>第二阶段：确定是 rollback 还是 commit，如果有一个节点不能提交，则所有节点都要回滚。</li></ul><p>与本地事务不同点在于：分布式事务需要多一次 prepare 操作，等收到所有节点的确定信息后，再进行 commit 或者 rollback。</p><p>MySQL 中分布式事务按实现方式可以分为两种：MySQL 自带的分布式事务和结合中间件实现分布式事务。下面来详细介绍一下这两种分布式事务。</p><h3 id="2-MySQL-自带的分布式事务"><a href="#2-MySQL-自带的分布式事务" class="headerlink" title="2 MySQL 自带的分布式事务"></a>2 MySQL 自带的分布式事务</h3><p>MySQL 有自带的分布式事务实现方法，具体语法如下：</p><p>启动分支事务：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">xa <span class="token keyword">start</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'a_1'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>‘a’,’a_1’ 表示 xid，<br>a 表示 gtrid，为分布式事务标识符，相同的分布式事务使用相同的 gtrid。<br>a_1 表示 bqual，为分支限定符，分布式事务中的每一个分支事务的 bqual 必须不同。</p></blockquote><p>结束分支事务：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">xa <span class="token keyword">end</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'a_1'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进入准备状态：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">xa <span class="token keyword">prepare</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'a_1'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>提交分支事务：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">xa <span class="token keyword">commit</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'a_1'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>回滚分支事务：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">xa <span class="token keyword">rollback</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'a_1'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回当前数据库中处于prepare状态的分支事务的详细信息：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">xa recover<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们来看一个例子：</p><div class="table-container"><table><thead><tr><th>session1</th><th>session2</th></tr></thead><tbody><tr><td>use muke1;</td><td>use muke2;</td></tr><tr><td>create table t23_1(id int);</td><td>create table t23_2(id int);</td></tr><tr><td>xa start ‘test’,’muke1’;</td><td>xa start ‘test’,’muke2’;</td></tr><tr><td>insert into t23_1 select 1;</td><td>insert into t23_2 select 1;</td></tr><tr><td>xa end ‘test’,’muke1’;</td><td>xa end ‘test’,’muke2’;</td></tr><tr><td>xa prepare ‘test’,’muke1’;</td><td>xa prepare ‘test’,’muke2’;</td></tr><tr><td>xa recover \G</td><td>xa recover \G</td></tr><tr><td>xa commit ‘test’,’muke1’;</td><td>xa commit ‘test’,’muke2’;</td></tr></tbody></table></div><p>上面的例子就演示了一个分布式事务，事务在 muke1 库中的 t23_1 表中插入一条记录，同时在 muke2 库中的 t23_2 表中插入一条记录，两个操作作为同一个事务提交。在进入准备状态之前，如果 session2 中某一步没执行成功而回滚了，则 session1 和 session2 整个分布式事务的操作都会回滚。</p><p>但是 MySQL 5.7 之前的版本，自带的分布式事务存在以下问题：</p><p>比如某个分支事务到达 prepare 状态时，此时数据库断电，重启后，可以继续对分支事务进行提交或者回滚，但是提交的事务不会写 binlog，如果有从库，会导致主从数据不一致的情况。</p><p>如果分支事务的客户端连接异常中止，那么数据库会自动回滚当前分支未完成的事务，如果此时分支事务已经到 prepare 状态，那么这个分布式事务的其他分支可能已经成功提交，如果这个分支回滚，可能导致分布式事务的不完整，丢失部分分支事务的内容。</p><p>还有一种情况，如果分支事务在执行到 prepare 状态时，数据库出现故障，并且无法启动，需要使用全备和 binlog 来恢复数据，那么这些在 prepare 状态的分支事务因为没有记录到 binlog，所以也不能通过binlog 进行恢复，在数据库恢复后，将丢失这部分数据。</p><p>所以，MySQL 5.7 之前的版本自带的分布式事务还存在比较严重的缺陷，在有些场景下，会导致数据丢失。如果业务对数据完整性要求不改，可以考虑使用，如果对数据完整性要求比较高，需要考虑先升级到 5.7 版本。</p><h3 id="3-结合中间件实现分布式"><a href="#3-结合中间件实现分布式" class="headerlink" title="3 结合中间件实现分布式"></a>3 结合中间件实现分布式</h3><p>上面说了 MySQL 自带的分布式事务，这里再介绍一下借助中间件实现分布式的情况。</p><p>具体实现方式可以拿上面网上购书的例子来说：</p><p>订单业务程序处理完增加订单的操作后，将减库存操作发送到消息队列中间件中（比如：Rocketmq），订单业务程序完成提交。然后库存业务程序检查到消息队列有减对应商品库存的信息，就开始执行减库存操作。库存业务执行完减库存操作，再发送一条消息给消息队列中间件：内容是已经减掉库存。具体步骤如下：</p><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/MQ实现增加订单和减库存操作.png" alt="MQ实现增加订单和减库存操作"></p><p>当然，为了确定最终已经完成减库存操作，还可以加一步对数据库中该商品库存的判断。</p><hr><p>第5章 MySQL的一些其他经验</p><h2 id="27-使用读写分离需要注意哪些？"><a href="#27-使用读写分离需要注意哪些？" class="headerlink" title="27 使用读写分离需要注意哪些？"></a>27 使用读写分离需要注意哪些？</h2><p>对于高访问量的业务场景，MySQL 读写分离显得格外重要。</p><p>通常我们说的 MySQL 读写分离是指：对于修改操作在主库上执行，而对于查询操作，在从库上执行。主要目的是分担主库的压力。</p><p>但是读写分离有时也会存在问题，比如：主从延迟时，读取的从库数据不是最新的，对应的业务场景比如：</p><p>你网购的一个商品，付完款之后，因为主从延迟，第一时间还查询不到订单（查询的从库），即使等一段时间能看到订单，但是相信这种情况很多用户是不能接受的。</p><p>本节就一起来讨论一下：读写分离需要注意哪些问题。</p><p>通常情况下，读写分离都是依赖主从复制，因此，我们先来看看主从复制的原理，也能方便我们理解为什么会出现主从延迟的现象。</p><h3 id="1-主从复制的原理"><a href="#1-主从复制的原理" class="headerlink" title="1 主从复制的原理"></a>1 主从复制的原理</h3><h4 id="1-1-MySQL-异步复制"><a href="#1-1-MySQL-异步复制" class="headerlink" title="1.1 MySQL 异步复制"></a>1.1 MySQL 异步复制</h4><p>传统的 MySQL 主从复制是异步的，因此也称为异步复制，MySQL 异步复制的原理如下：</p><ul><li>在主库开启 binlog 的情况下</li><li>如果主库有增删改的语句，会记录到 binlog 中</li><li>主库通过 IO 线程把 binlog 里面的内容传给从库的中继日志（relay log）中</li><li>主库给客户端返回 commit 成功（这里不会管从库是否已经收到了事务的 binlog）</li><li>从库的 SQL 线程负责读取它的 relay log 里的信息并应用到从库数据库中</li></ul><p>实现原理如下图：</p><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/MySQL异步复制.png" alt="MySQL异步复制"></p><p>在上图中，有一个地方不能忽视：</p><p>在主库上并行运行的更新 SQL，由于从库只有单个 SQL 线程去消化 relay log，因此更新的 SQL 在从库只能串行执行。这也是很多情况下，会出现主从延迟的原因。</p><p>当然，从 5.6 开始，MySQL 支持了每个库可以配置单独的 SQL 线程来消化 relay log，在 5.7 又增加了基于组提交的并行复制，大大改善了主从延迟的问题。</p><h4 id="1-2-MySQL-半同步复制"><a href="#1-2-MySQL-半同步复制" class="headerlink" title="1.2 MySQL 半同步复制"></a>1.2 MySQL 半同步复制</h4><p>在 MySQL 异步复制的基础上，又出现了一种改进的复制方式，称为：半同步复制。其原理如下：</p><ul><li>在主库开启 binlog 的情况下</li><li>如果主库有增删改的语句，会记录到 binlog 中</li><li>主库通过 IO 线程把 binlog 里面的内容传给从库的中继日志（relay log）中</li><li>从库收到 binlog 后，发送给主库一个 ACK，表示收到了</li><li>主库收到这个 ACK 以后，才能给客户端返回 commit 成功</li><li>从库的 SQL 线程负责读取它的 relay log 里的信息并应用到从库数据库中</li></ul><p>实现原理如下图：</p><p><img src="/images/《一线数据库工程师带你深入理解MySQL》学习笔记/MySQL半同步复制.png" alt="MySQL半同步复制"></p><p>跟传统的异步复制相比，半同步复制保证了所有给客户端发送过确认提交的事务，从库都已经收到这个日志了。</p><h3 id="2-常见的读写分离方式"><a href="#2-常见的读写分离方式" class="headerlink" title="2 常见的读写分离方式"></a>2 常见的读写分离方式</h3><h4 id="2-1、通过程序"><a href="#2-1、通过程序" class="headerlink" title="2.1、通过程序"></a>2.1、通过程序</h4><p>开发通过配置程序来决定修改操作走主库，查询操作走从库。这种方式直连数据库，优点是性能会好点，缺点是配置麻烦。</p><p>但是需要注意的是：从库需要设置为 read_only，防止配置错误在从库写入了数据。</p><blockquote><p>这里提醒一点：<br>程序连接的用户建议不要给 super 权限，因为 super 权限的用户，即使整个库设置了 read_only ，也能写入数据。</p></blockquote><h4 id="2-2、通过中间件"><a href="#2-2、通过中间件" class="headerlink" title="2.2、通过中间件"></a>2.2、通过中间件</h4><p>通过中间件实现读写分离，目前算是一种主流的方式。拿 MyCAT 举例：</p><p>在 schema.xml 文件中，dataHost 标签 balance 属性的值，决定了是否启用读写分离。</p><p>balance 各个值及对应的读写方法如下：</p><ul><li>0：不开启读写分离，读操作发送到 writehost</li><li>1：全部的 readhost 与 stand by writehost 参与 select 语句的负载均衡</li><li>2：所有读操作都随机在 writehost、readhost上分发</li><li>3：所有读请求随机分发到 writerhost 对应的 readhost 执行，writehost 不负担读压力</li></ul><p>因此可以根据实际情况选择上面合适的读写分离策略。</p><h3 id="3-什么情况下会出现主从延迟"><a href="#3-什么情况下会出现主从延迟" class="headerlink" title="3 什么情况下会出现主从延迟"></a>3 什么情况下会出现主从延迟</h3><p>在本节的开始，我们说到，对于读写分离场景，最大的问题就是：主从延迟。那么在哪些情况下会出现主从延迟呢？这里大致总结一下可能导致主从延迟的场景：</p><ul><li>大表 DDL</li><li>大事务</li><li>主库 DML 并发大</li><li>从库配置差</li><li>表上无主键</li><li>等等</li></ul><p>因此，如果存在读写分离的情况，应尽量避免上诉情况在业务高峰出现。</p><p>当然，我们不能完全杜绝主从延迟。因此再介绍几种读写分离场景下应对延迟的方法。</p><h3 id="4-读写分离怎样应对主从延迟"><a href="#4-读写分离怎样应对主从延迟" class="headerlink" title="4 读写分离怎样应对主从延迟"></a>4 读写分离怎样应对主从延迟</h3><p>读写分离场景应该怎样应对主从延迟呢？这里来讨论一下几种常见的应对主从延迟的方法：</p><h4 id="4-1-判断主从是否延迟"><a href="#4-1-判断主从是否延迟" class="headerlink" title="4.1 判断主从是否延迟"></a>4.1 判断主从是否延迟</h4><p>有些业务场景，如果所有请求都落在主库，主库压力会很大，但是在读写分离的情况，又不希望主从存在延迟的时候去读取从库。这种情况，就可以考虑查询时，先判断主从是否存在延迟，如果存在延迟，则查询落在主库，如果没延迟，则查询语句落在从库。</p><p>这里介绍几种判断主从延迟的方法：</p><p>第一种方法：判断 Seconds_Behind_Master 是否等于 0。</p><p>如果 Seconds_Behind_Master =0，则查询从库，如果大于 0，则查询主库。</p><blockquote><p>这里补充一下 Seconds_Behind_Master。<br>Seconds_Behind_Master 是在从库上执行 show slave status 时返回的其中一项，表示从库延迟的秒数。<br>其计算方法是：<br>从库服务器当前的时间戳与二进制日志中的事件的时间戳（在主库上的写入时间）相对比得到的。</p></blockquote><p>但是某些情况下，Seconds_Behind_Master 并不一定准确。比如网络中断时，Seconds_Behind_Master = 0 ，并不能代表主从无延迟。因此，有比这个更准确的一种方法：对比位点或 GTID。</p><p>第二种方法：对比位点或 GTID</p><p>如果 Master_Log_File 跟 Relay_Master_Log_File 相等，</p><p>并且 Read_Master_Log_Pos 跟 Exec_Master_Log_Pos 相等，</p><p>则可以把读请求放到从库，否则读请求放到主库。</p><blockquote><p>补充一下上面几个参数的意义：<br>几个参数均是通过 show slave status 返回的参数，用来查询主从复制的状态。<br>Master_Log_File：IO 线程正在读取的主库 binlog 文件名<br>Relay_Master_Log_File：SQL 线程最近执行的事务对应的主库 binlog 文件名<br>Read_Master_Log_Pos ：IO 线程正在读取的主库 binlog 文件中的位点<br>Exec_Master_Log_Pos ：SQL 线程最近读取和执行的事务对应的主库 binlog 文件中的位点</p></blockquote><p>如果开启了 GTID 复制，则可以对比 Retrieved_Gtid_Set 和 Executed_Gtid_Set 是否相等，相等则把读请求放到从库，有差异则读请求放到主库。</p><blockquote><p>同样补充下两个参数的意义：<br>前提是需要开启 GTID 两个参数才会有值，解释如下：<br>Retrieved_Gtid_Set：从库收到的所有日志的 GTID 集合<br>Executed_Gtid_Set：从库已经执行完的 GTID 集合</p></blockquote><h4 id="4-2-采用半同步复制"><a href="#4-2-采用半同步复制" class="headerlink" title="4.2 采用半同步复制"></a>4.2 采用半同步复制</h4><p>在本节的前面，我们讲解了半同步复制的原理，跟传统的异步复制相比，半同步复制保证了所有给客户端发送过确认提交的事务，从库都已经收到这个日志了。因此出现延迟的概率会小很多，当然实际生产应用时，建议结合上面讲的位点或 GTID 判断。</p><h4 id="4-3-等待同步完成"><a href="#4-3-等待同步完成" class="headerlink" title="4.3 等待同步完成"></a>4.3 等待同步完成</h4><p>依然采用 4.1 中介绍的几种判断是否有延迟的方法，只是应对方式不一样，比如存在延迟，则将情况反馈给程序，在前端页面提醒用户数据未完全同步，如果没有延迟，则查询从库。</p><p>有人可能会觉得：这种方式谁会用啊？实际可以应用在内部人员看的报表业务上。因为报表可能涉及的 SQL 都比较复杂，存在延迟就考虑去查询主库，可能会对其它线上业务有影响，因此可以等待从库同步完成，再查询从库。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 职业规划 </tag>
            
            <tag> 慕课专栏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《MySQL必知必会》读书笔记</title>
      <link href="mysql-bi-zhi-bi-hui-du-shu-bi-ji/"/>
      <url>mysql-bi-zhi-bi-hui-du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="第1章-了解SQL"><a href="#第1章-了解SQL" class="headerlink" title="第1章 了解SQL"></a>第1章 了解SQL</h2><ol><li><p><strong>数据库（database）</strong> 保存有组织的数据的容器（通常是一个文件或一组文件）。</p></li><li><p><strong>表（table）</strong> 某种特定类型数据的结构化清单。</p></li><li><p><strong>模式（schema）</strong> 关于数据库和表的布局及特性的信息。</p></li><li><p><strong>列（column）</strong> 表中的一个字段。所有表都是由一个或多个列组成的。</p></li><li><p><strong>数据类型（datatype）</strong> 所容许的数据的类型。每个表列都有相应的数据类型，它限制（或容许）该列中存储的数据。</p></li><li><p><strong>行（row）</strong> 表中的一个记录。</p></li><li><p><strong>主键（primary key）</strong> 一列（或一组列），其值能够唯一区分表中每个行。</p><p> 表中的任何列都可以作为主键，只要它满足以下条件：</p><blockquote><ol><li>任意两行都不具有相同的主键值；</li><li>每个行都必须具有一个主键值（主键列不允许NULL值）。</li></ol></blockquote><p> 主键的最好习惯：</p><blockquote><ol><li>不更新主键列中的值；</li><li>不重用主键列的值；</li><li>不在主键列中使用可能会更改的值。</li></ol></blockquote></li></ol><h2 id="第2章-MySQL简介"><a href="#第2章-MySQL简介" class="headerlink" title="第2章 MySQL简介"></a>第2章 MySQL简介</h2><ol><li>DBMS（数据库管理系统）分两类：<ol><li>基于共享文件系统的DBMS，如Microsoft Access和FileMaker；</li><li>基于客户机—服务器的DBMS，如MySQL、Oracle以及Microsoft SQL Server。</li></ol></li></ol><h2 id="第3章-使用MySQL"><a href="#第3章-使用MySQL" class="headerlink" title="第3章 使用MySQL"></a>第3章 使用MySQL</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SHOW</span> <span class="token keyword">DATABASES</span><span class="token punctuation">;</span> <span class="token comment">/* 显示所有数据库 */</span><span class="token keyword">USE</span> mysql<span class="token punctuation">;</span> <span class="token comment">/* 选择数据库mysql */</span><span class="token keyword">SHOW</span> <span class="token keyword">TABLES</span><span class="token punctuation">;</span> <span class="token comment">/* 显示所有表 */</span><span class="token keyword">SHOW</span> <span class="token keyword">COLUMNS</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span> <span class="token comment">/* 显示user表中的列信息 */</span><span class="token keyword">DESCRIBE</span> <span class="token keyword">user</span><span class="token punctuation">;</span> <span class="token comment">/* 同上 */</span><span class="token keyword">SHOW</span> <span class="token keyword">STATUS</span><span class="token punctuation">;</span> <span class="token comment">/* 显示服务器状态信息 */</span><span class="token keyword">SHOW</span> <span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> mysql<span class="token punctuation">;</span> <span class="token comment">/* 显示创建数据库mysql的SQL语句 */</span><span class="token keyword">SHOW</span> <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span><span class="token punctuation">;</span> <span class="token comment">/* 显示创建表user的SQL语句 */</span><span class="token keyword">show</span> grants<span class="token punctuation">;</span> <span class="token comment">/* 显示用户的授权信息 */</span><span class="token keyword">SHOW</span> <span class="token keyword">ERRORS</span><span class="token punctuation">;</span> <span class="token comment">/* 显示服务器中的错误信息 */</span><span class="token keyword">SHOW</span> <span class="token keyword">WARNINGS</span><span class="token punctuation">;</span> <span class="token comment">/* 显示服务器中的警告信息 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>可以使用<code>help show</code> 来查看帮助信息。</p></blockquote><h2 id="第4章-检索数据"><a href="#第4章-检索数据" class="headerlink" title="第4章 检索数据"></a>第4章 检索数据</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token keyword">user</span><span class="token punctuation">.</span><span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span> <span class="token comment">/* 同上 */</span><span class="token keyword">SELECT</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> mysql<span class="token punctuation">.</span><span class="token keyword">user</span><span class="token punctuation">;</span> <span class="token comment">/* 同上 */</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span><span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span> <span class="token comment">/* 去除重复 */</span><span class="token keyword">SELECT</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">LIMIT</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">/* 只显示查询结果的前3条记录 */</span><span class="token keyword">SELECT</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">LIMIT</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">/* 只显示查询结果的第2条开始（下标从0开始）后面的3条记录 */</span><span class="token keyword">SELECT</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">LIMIT</span> <span class="token number">3</span> <span class="token keyword">OFFSET</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">/* 同上 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>SQL不区分大小写，也忽略空格。</p><p>DISTINCT关键字应用于所有列而不仅是前置它的列。</p></blockquote><h2 id="第5章-排序检索数据"><a href="#第5章-排序检索数据" class="headerlink" title="第5章 排序检索数据"></a>第5章 排序检索数据</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token keyword">User</span><span class="token punctuation">;</span> <span class="token comment">/* 升序排序 */</span><span class="token keyword">SELECT</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token keyword">User</span> <span class="token keyword">ASC</span><span class="token punctuation">;</span> <span class="token comment">/* 同上 */</span><span class="token keyword">SELECT</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token keyword">User</span> <span class="token keyword">DESC</span><span class="token punctuation">;</span> <span class="token comment">/* 降序排序 */</span><span class="token keyword">SELECT</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token keyword">User</span><span class="token punctuation">,</span> Host<span class="token punctuation">;</span> <span class="token comment">/* 先按User升序排序，再按Host升序排序 */</span><span class="token keyword">SELECT</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token keyword">User</span> <span class="token keyword">DESC</span><span class="token punctuation">,</span> Host<span class="token punctuation">;</span> <span class="token comment">/* 先按User降序排序，再按Host升序排序 */</span><span class="token keyword">SELECT</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token keyword">User</span> <span class="token keyword">DESC</span><span class="token punctuation">,</span> Host <span class="token keyword">ASC</span><span class="token punctuation">;</span> <span class="token comment">/* 同上 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>DESC关键字只应用到直接位于其前面的列名。</p></blockquote><h2 id="第6章-过滤数据"><a href="#第6章-过滤数据" class="headerlink" title="第6章 过滤数据"></a>第6章 过滤数据</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> <span class="token keyword">User</span><span class="token operator">=</span><span class="token string">'root'</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span><span class="token punctuation">,</span> max_connections <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> max_connections <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span><span class="token punctuation">,</span> max_connections <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> max_connections <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span><span class="token punctuation">,</span> max_connections <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> max_connections <span class="token operator">&lt;&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">/* 同上 */</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span><span class="token punctuation">,</span> max_connections <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> max_connections <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span><span class="token punctuation">,</span> max_connections <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> max_connections <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span><span class="token punctuation">,</span> max_connections <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> max_connections <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span><span class="token punctuation">,</span> max_connections <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> max_connections <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span><span class="token punctuation">,</span> max_connections <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> max_connections <span class="token operator">BETWEEN</span> <span class="token number">0</span> <span class="token operator">AND</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span><span class="token punctuation">,</span> max_connections <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> ssl_cipher <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span> <span class="token comment">/* ssl_cipher字段为NULL */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第7章-数据过滤"><a href="#第7章-数据过滤" class="headerlink" title="第7章 数据过滤"></a>第7章 数据过滤</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> Host<span class="token operator">=</span><span class="token string">'localhost'</span> <span class="token operator">AND</span> <span class="token keyword">User</span><span class="token operator">=</span><span class="token string">'root'</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> Host<span class="token operator">=</span><span class="token string">'localhost'</span> <span class="token operator">OR</span> <span class="token keyword">User</span><span class="token operator">=</span><span class="token string">'root'</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> <span class="token punctuation">(</span>Host<span class="token operator">=</span><span class="token string">'localhost'</span> <span class="token operator">OR</span> <span class="token keyword">User</span><span class="token operator">=</span><span class="token string">'root'</span><span class="token punctuation">)</span> <span class="token operator">AND</span> max_connections <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> Host <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token string">'%'</span><span class="token punctuation">,</span> <span class="token string">'localhost'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> Host <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token string">'%'</span><span class="token punctuation">,</span> <span class="token string">'localhost'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>AND的优先级比OR高。</p><p>IN操作符完成与OR相同的功能，但是更快。</p></blockquote><h2 id="第8章-用通配符进行过滤"><a href="#第8章-用通配符进行过滤" class="headerlink" title="第8章 用通配符进行过滤"></a>第8章 用通配符进行过滤</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> Host <span class="token operator">LIKE</span> <span class="token string">'local%'</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> <span class="token keyword">User</span> <span class="token operator">LIKE</span> <span class="token string">'r__t'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>百分号（%）表示任何字符出现任意次数。%不能匹配NULL值。</p><p>下划线（_）只匹配单个字符。</p></blockquote><h2 id="第9章-用正则表达式进行搜索"><a href="#第9章-用正则表达式进行搜索" class="headerlink" title="第9章 用正则表达式进行搜索"></a>第9章 用正则表达式进行搜索</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> <span class="token keyword">User</span> <span class="token operator">REGEXP</span> <span class="token string">'r..t'</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> Host <span class="token operator">REGEXP</span> <span class="token string">'%|localhost'</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> <span class="token keyword">User</span> <span class="token operator">REGEXP</span> <span class="token string">'r[a-z]{2}t'</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> Host<span class="token punctuation">,</span> <span class="token keyword">User</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> <span class="token keyword">User</span> <span class="token operator">REGEXP</span> <span class="token string">'mysql\\.sys'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>可以使用类似<code>SELECT 'hello' REGEXP '[0-9]'</code>这样的SQL来测试正常表达式，匹配成功返回1，否则返回0。</p></blockquote><h2 id="第10章-创建计算字段"><a href="#第10章-创建计算字段" class="headerlink" title="第10章 创建计算字段"></a>第10章 创建计算字段</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> CONCAT<span class="token punctuation">(</span><span class="token keyword">User</span><span class="token punctuation">,</span> <span class="token string">'('</span><span class="token punctuation">,</span> Host<span class="token punctuation">,</span> <span class="token string">')'</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> CONCAT<span class="token punctuation">(</span><span class="token keyword">User</span><span class="token punctuation">,</span> <span class="token string">'('</span><span class="token punctuation">,</span> Host<span class="token punctuation">,</span> <span class="token string">')'</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> UserHost <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="第11章-使用数据处理函数"><a href="#第11章-使用数据处理函数" class="headerlink" title="第11章 使用数据处理函数"></a>第11章 使用数据处理函数</h2><div class="table-container"><table><thead><tr><th><strong>函数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Left()</td><td>返回串左边的字符</td></tr><tr><td>Length()</td><td>返回串的长度</td></tr><tr><td>Locate()</td><td>找出串的一个子串</td></tr><tr><td>Lower()</td><td>将串转换为小写</td></tr><tr><td>LTrim()</td><td>去掉串左边的空格返</td></tr><tr><td>Right()</td><td>返回串右边的字符</td></tr><tr><td>RTrim()</td><td>去掉串右边的空格</td></tr><tr><td>Soundex()</td><td>返回串的SOUNDEX值</td></tr><tr><td>SubString()</td><td>返回子串的字符</td></tr><tr><td>Upper()</td><td>将串转换为大写</td></tr><tr><td>AddDate()</td><td>增加一个日期（天、周等）</td></tr><tr><td>AddTime()</td><td>增加一个时间（时、分等）</td></tr><tr><td>CurDate()</td><td>返回当前日期</td></tr><tr><td>CurTime()</td><td>返回当前时间</td></tr><tr><td>Date()</td><td>返回日期时间的日期部分</td></tr><tr><td>DateDiff()</td><td>计算两个日期之差</td></tr><tr><td>Date_Add()</td><td>高度灵活的日期运算函数</td></tr><tr><td>Date_Format()</td><td>返回一个格式化的日期或时间串</td></tr><tr><td>Day()</td><td>返回一个日期的天数部分</td></tr><tr><td>DayOfWeek()</td><td>对于一个日期，返回对应的星期几</td></tr><tr><td>Hour()</td><td>返回一个时间的小时部分</td></tr><tr><td>Minute()</td><td>返回一个时间的分钟部分</td></tr><tr><td>Month()</td><td>返回一个日期的月份部分</td></tr><tr><td>Now()</td><td>返回当前日期和时间</td></tr><tr><td>Second()</td><td>返回一个时间的秒部分</td></tr><tr><td>Time()</td><td>返回一个日期时间的时间部分</td></tr><tr><td>Year()</td><td>返回一个日期的年份部分</td></tr><tr><td>Abs()</td><td>返回一个数的绝对值</td></tr><tr><td>Cos()</td><td>返回一个角度的余弦</td></tr><tr><td>Exp()</td><td>返回一个数的指数值</td></tr><tr><td>Mod()</td><td>返回除操作的余数</td></tr><tr><td>Pi()</td><td>返回圆周率</td></tr><tr><td>Rand()</td><td>返回一个随机数</td></tr><tr><td>Sin()</td><td>返回一个角度的正弦</td></tr><tr><td>Sqrt()</td><td>返回一个数的平方根</td></tr><tr><td>Tan()</td><td>返回一个角度的正切</td></tr></tbody></table></div><blockquote><p>不管是插入或更新表值还是用WHERE子句进行过滤，日期必须为格式yyyy-mm-dd。并且总是应该使用4位数字的年份。</p></blockquote><h2 id="第12章-汇总数据"><a href="#第12章-汇总数据" class="headerlink" title="第12章 汇总数据"></a>第12章 汇总数据</h2><ol><li><p><strong>聚集函数（aggregate function）</strong> 运行在行组上，计算和返回单个值的函数。</p></li><li><p><strong>AVG()函数</strong> 计算单列的平均值。</p><blockquote><p>AVG()函数忽略列值为NULL的行。</p></blockquote></li><li><p><strong>COUNT()函数</strong> 进行计数。</p><blockquote><p>使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值（NULL）还是非空值。</p><p>使用COUNT(column)对特定列中具有值的行进行计数，忽略NULL值。</p></blockquote></li><li><p><strong>MAX()函数</strong> 返回指定列中的最大值。</p><blockquote><p>MAX()函数忽略列值为NULL的行。</p></blockquote></li><li><p><strong>MAX()函数</strong> 返回指定列中的最小值。</p><blockquote><p>MIN()函数忽略列值为NULL的行。</p></blockquote></li><li><p><strong>SUM()函数</strong> 用来返回指定列值的和（总计）。</p><blockquote><p>SUM()函数忽略列值为NULL的行。</p></blockquote></li><li><p>以上5个聚集函数都可以如下使用：</p><ol><li>对所有的行执行计算，指定ALL参数或不给参数（因为ALL是默认行为）；</li><li><p>只包含不同的值，指定DISTINCT参数。</p><blockquote><p>如果指定列名，则DISTINCT只能用于COUNT()。DISTINCT不能用于COUNT(*)，因此不允许使用COUNT（DISTINCT），否则会产生错误。类似地，DISTINCT必须使用列名，不能用于计算或表达式。</p><p><strong>将DISTINCT用于MIN()和MAX()</strong> 。虽然DISTINCT从技术上可用于MIN()和MAX()，但这样做实际上没有价值。一个列中的最小值和最大值不管是否包含不同值都是相同的。</p></blockquote></li></ol></li></ol><h2 id="第13章-分组数据"><a href="#第13章-分组数据" class="headerlink" title="第13章 分组数据"></a>第13章 分组数据</h2><ol><li><p>使用GROUP BY创建分组时需要注意：</p><ol><li>GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套，为数据分组提供更细致的控制。</li><li>如果在GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。</li><li>GROUP BY子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。</li><li>除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出。</li><li>如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。</li><li><p>GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。</p><blockquote><p>使用WITH ROLLUP关键字，可以得到每个分组以及每个分组汇总级别（针对每个分组）的值。</p></blockquote></li></ol></li><li><p>分组过滤操作HAVING支持所有WHERE操作符。</p><blockquote><p>WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤。</p></blockquote></li><li><p>一般在使用GROUP BY子句时，应该也给出ORDER BY子句。这是保证数据正确排序的唯一方法。</p></li><li><p>SELECT子句顺序</p></li></ol><div class="table-container"><table><thead><tr><th><strong>子句</strong></th><th><strong>说明</strong></th><th><strong>是否必须使用</strong></th></tr></thead><tbody><tr><td>SELECT</td><td>要返回的列或表达式</td><td>是</td></tr><tr><td>FROM</td><td>从中检索数据的表</td><td>仅在从表选择数据时使用</td></tr><tr><td>WHERE</td><td>行级过滤</td><td>否</td></tr><tr><td>GROUP BY</td><td>分组说明</td><td>仅在按组计算聚集时使用</td></tr><tr><td>HAVING</td><td>组级过滤</td><td>否</td></tr><tr><td>ORDER BY</td><td>输出排序顺序</td><td>否</td></tr><tr><td>LIMIT</td><td>要检索的行数</td><td>否</td></tr></tbody></table></div><h2 id="第14章-使用子查询"><a href="#第14章-使用子查询" class="headerlink" title="第14章 使用子查询"></a>第14章 使用子查询</h2><ol><li><p>子查询就是可以把一条SELECT语句返回的结果用于另一条SELECT语句的WHERE子句。</p></li><li><p>在WHERE子句中使用子查询，应该保证SELECT语句具有与WHERE子句中相同数目的列。通常，子查询将返回单个列并且与单个列匹配，但如果需要也可以使用多个列。</p></li></ol><h2 id="第15章-连结表"><a href="#第15章-连结表" class="headerlink" title="第15章 连结表"></a>第15章 连结表</h2><ol><li><p><strong>外键（foreign key）</strong> 为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。</p></li><li><p>由没有联结条件的表关系返回的结果为 <strong>笛卡儿积（cartesian product）</strong> 。如下：</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> vend_name<span class="token punctuation">,</span> prod_name<span class="token punctuation">,</span> prod_price<span class="token keyword">FROM</span> vendors<span class="token punctuation">,</span> products<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> vend_name<span class="token punctuation">,</span> prod_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>有时我们会听到返回称为 <strong>叉联结（cross join）</strong> 的笛卡儿积的联结类型。</p></blockquote></li><li><p><strong>等值联结（equijoin）</strong> 基于两个表之间的相等测试。这种联结也称为 <strong>内部联结</strong> 。下面的SQL都是等值联结：</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> vend_name<span class="token punctuation">,</span> prod_name<span class="token punctuation">,</span> prod_price<span class="token keyword">FROM</span> vendors<span class="token punctuation">,</span> products<span class="token keyword">WHERE</span> vendors<span class="token punctuation">.</span>vend_id <span class="token operator">=</span> products<span class="token punctuation">.</span>vend_id<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> vend_name<span class="token punctuation">,</span> prod_name<span class="token punctuation">;</span><span class="token keyword">SELECT</span> vend_name<span class="token punctuation">,</span> prod_name<span class="token punctuation">,</span> prod_price<span class="token keyword">FROM</span> vendors<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> products<span class="token keyword">ON</span> vendors<span class="token punctuation">.</span>vend_id <span class="token operator">=</span> products<span class="token punctuation">.</span>vend_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="第16章-创建高级联结"><a href="#第16章-创建高级联结" class="headerlink" title="第16章 创建高级联结"></a>第16章 创建高级联结</h2><ol><li><p>表别名只在查询执行中使用。</p></li><li><p>自联结</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> p1<span class="token punctuation">.</span>prod_id<span class="token punctuation">,</span> p1<span class="token punctuation">.</span>prod_name<span class="token keyword">FROM</span> products <span class="token keyword">AS</span> p1<span class="token punctuation">,</span> products <span class="token keyword">AS</span> p2<span class="token keyword">WHERE</span> p1<span class="token punctuation">.</span>vend_id <span class="token operator">=</span> p2<span class="token punctuation">.</span>vend_id  <span class="token operator">AND</span> p2<span class="token punctuation">.</span>prod_id <span class="token operator">=</span> <span class="token string">'DTNTR'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>自联结远比处理子查询快得多。</p></blockquote></li><li><p>无论何时对表进行联结，应该至少有一个列出现在不止一个表中（被联结的列）。标准的联结（前一章中介绍的内部联结）返回所有数据，甚至相同的列多次出现。 <strong>自然联结</strong> 排除多次出现，使每个列只返回一次。这一般是通过对表使用通配符（SELECT*），对所有其他表的列使用明确的子集来完成的。</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> c<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">,</span> o<span class="token punctuation">.</span>order_num<span class="token punctuation">,</span> o<span class="token punctuation">.</span>order_data<span class="token punctuation">,</span> io<span class="token punctuation">.</span>prod_id<span class="token punctuation">,</span> io<span class="token punctuation">.</span>quantity<span class="token punctuation">,</span> io<span class="token punctuation">.</span>item_price<span class="token keyword">FROM</span> customers <span class="token keyword">AS</span> c<span class="token punctuation">,</span> orders <span class="token keyword">AS</span> o<span class="token punctuation">,</span> orderitems <span class="token keyword">AS</span> io<span class="token keyword">WHERE</span> c<span class="token punctuation">.</span>cust_id <span class="token operator">=</span> o<span class="token punctuation">.</span>cust_id  <span class="token operator">AND</span> io<span class="token punctuation">.</span>order_num <span class="token operator">=</span> o<span class="token punctuation">.</span>order_num  <span class="token operator">AND</span> prod_id <span class="token operator">=</span> <span class="token string">'FB'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>外部联结在结果中包含了那些在另一个表中没有关联行的行。</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> customers<span class="token punctuation">.</span>cust_id<span class="token punctuation">,</span> orders<span class="token punctuation">.</span>order_num<span class="token keyword">FROM</span> customers<span class="token keyword">LEFT</span> <span class="token keyword">OUTER</span> <span class="token keyword">JOIN</span> orders<span class="token keyword">ON</span> customers<span class="token punctuation">.</span>cust_id <span class="token operator">=</span> orders<span class="token punctuation">.</span>cust_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表）。上面的例子使用LEFT OUTER JOIN从FROM子句的左边表（customers表）中选择所有行。为了从右边的表中选择所有行，应该使用RIGHT OUTER JOIN。</li></ol><h2 id="第17章-组合查询"><a href="#第17章-组合查询" class="headerlink" title="第17章 组合查询"></a>第17章 组合查询</h2><ol><li><p>MySQL允许执行多个查询（多条SELECT语句），并将结果作为单个查询结果集返回。这些组合查询通常称为 <strong>并（union）</strong> 或 <strong>复合查询（compound query）</strong> 。</p></li><li><p>使用UNION规则时需要遵循的规则：</p><ol><li>UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔（因此，如果组合4条SELECT语句，将要使用3个UNION关键字）。</li><li>UNION中的每个查询必须包含相同的列、表达式或聚集函数（不过各个列不需要以相同的次序列出）。</li><li>列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型（例如，不同的数值类型或不同的日期类型）。</li></ol></li><li><p>UNION从查询结果集中自动去除了重复的行（换句话说，它的行为与单条SELECT语句中使用多个WHERE子句条件一样）。这是UNION的默认行为，如果想返回所有匹配行，可使用UNION ALL而不是UNION。</p></li><li><p>在用UNION组合查询时，只能使用一条ORDER BY子句，它必须出现在最后一条SELECT语句之后。</p></li></ol><h2 id="第18章-全文本搜索"><a href="#第18章-全文本搜索" class="headerlink" title="第18章 全文本搜索"></a>第18章 全文本搜索</h2><ol><li><p>MyISAM支持全文本搜索，InnoDB不支持。</p></li><li><p>为了进行全文本搜索，必须索引被搜索的列。一般在创建表时使用FULLTEXT启用全文本搜索。</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> productnotes<span class="token punctuation">(</span>    note_id     <span class="token keyword">INT</span>         <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    prod_id     <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>    <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    note_date   <span class="token keyword">DATETIME</span>    <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    note_text   <span class="token keyword">TEXT</span>        <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>note_id<span class="token punctuation">)</span><span class="token punctuation">,</span>    FULLTEXT<span class="token punctuation">(</span>note_text<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span>MyISAM<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>不要在导入数据时使用FULLTEXT。应该首先导入所有数据，然后再修改表，定义FULLTEXT。</p></blockquote></li><li><p>使用两个函数Match()和Against()执行全文本搜索，其中Match()指定被搜索的列，Against()指定要使用的搜索表达式。</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> note_text<span class="token keyword">FROM</span> productnotes<span class="token keyword">WHERE</span> <span class="token keyword">MATCH</span><span class="token punctuation">(</span>note_text<span class="token punctuation">)</span> AGAINST<span class="token punctuation">(</span><span class="token string">'rabbit'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>传递给Match()的值必须与FULLTEXT()定义中的相同。如果指定多个列，则必须列出它们（而且次序正确）。</p><p>搜索不区分大小写，除非使用BINARY方式，否则全文本搜索不区分大小写。</p></blockquote></li><li><p>也是使用LIKE子句进行搜索。</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> note_text<span class="token keyword">FROM</span> productnotes<span class="token keyword">WHERE</span> note_text <span class="token operator">LIKE</span> <span class="token string">'%rabbit%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>使用LIKE子句进行搜索时，不会对结果进行排序。而使用函数Match()和Against()执行全文本搜索时，会对结果进行排序，具有较高等级的行先返回。等级可以通过下面的方式获取：</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> note_text<span class="token punctuation">,</span> <span class="token keyword">MATCH</span><span class="token punctuation">(</span>note_text<span class="token punctuation">)</span> AGAINST<span class="token punctuation">(</span><span class="token string">'rabbit'</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token string">'rank'</span><span class="token keyword">FROM</span> productnotes<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>在使用 <strong>查询扩展</strong> 时，MySQL对数据和索引进行两遍扫描来完成搜索：</p><ol><li>进行一个基本的全文本搜索，找出与搜索条件匹配的所有行；</li><li>MySQL检查这些匹配行并选择所有有用的词；</li><li><p>MySQL再次进行全文本搜索，这次不仅使用原来的条件，而且还使用所有有用的词。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> note_text<span class="token keyword">FROM</span> productnotes<span class="token keyword">WHERE</span> <span class="token keyword">MATCH</span><span class="token punctuation">(</span>note_text<span class="token punctuation">)</span> AGAINST<span class="token punctuation">(</span><span class="token string">'anvils'</span> <span class="token keyword">WITH</span> QUERY EXPANSION<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol></li><li><p>即使没有FULLTEXT索引也可以使用 <strong>布尔文本搜索</strong> ，但这是一种非常缓慢的操作。</p><blockquote><p><strong>排列而不排序</strong> 在布尔方式中，不按等级值降序排序返回的</p></blockquote></li><li><p>全文本搜索的使用说明</p><ol><li>在索引全文本数据时，短词被忽略且从索引中排除。短词定义为那些具有3个或3个以下字符的词（如果需要，这个数目可以更改）。</li><li>MySQL带有一个内建的非用词（stopword）列表，这些词在索引全文本数据时总是被忽略。如果需要，可以覆盖这个列表。</li><li>许多词出现的频率很高，搜索它们没有用处（返回太多的结果）。因此，MySQL规定了一条50%规则，如果一个词出现在50%以上的行中，则将它作为一个非用词忽略。50%规则不用于IN BOOLEANMODE。</li><li>如果表中的行数少于3行，则全文本搜索不返回结果（因为每个词或者不出现，或者至少出现在50%的行中）。</li><li>忽略词中的单引号。例如，don’t索引为dont。</li><li>不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文本搜索结果。</li><li><p>如前所述，仅在MyISAM数据库引擎中支持全文本搜索。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'ft%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol></li><li><p>一些例子</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> note_text<span class="token keyword">FROM</span> productnotes<span class="token keyword">WHERE</span> <span class="token keyword">MATCH</span><span class="token punctuation">(</span>note_text<span class="token punctuation">)</span> AGAINST<span class="token punctuation">(</span><span class="token string">'+rabbit +bait'</span> <span class="token operator">IN</span> <span class="token keyword">BOOLEAN</span> <span class="token keyword">MODE</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 匹配词rabbit和bait */</span><span class="token keyword">SELECT</span> note_text<span class="token keyword">FROM</span> productnotes<span class="token keyword">WHERE</span> <span class="token keyword">MATCH</span><span class="token punctuation">(</span>note_text<span class="token punctuation">)</span> AGAINST<span class="token punctuation">(</span><span class="token string">'rabbit bait'</span> <span class="token operator">IN</span> <span class="token keyword">BOOLEAN</span> <span class="token keyword">MODE</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 匹配词rabbit或bait */</span><span class="token keyword">SELECT</span> note_text<span class="token keyword">FROM</span> productnotes<span class="token keyword">WHERE</span> <span class="token keyword">MATCH</span><span class="token punctuation">(</span>note_text<span class="token punctuation">)</span> AGAINST<span class="token punctuation">(</span><span class="token string">'"rabbit bait"'</span> <span class="token operator">IN</span> <span class="token keyword">BOOLEAN</span> <span class="token keyword">MODE</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 匹配短语"rabbit bait" */</span><span class="token keyword">SELECT</span> note_text<span class="token keyword">FROM</span> productnotes<span class="token keyword">WHERE</span> <span class="token keyword">MATCH</span><span class="token punctuation">(</span>note_text<span class="token punctuation">)</span> AGAINST<span class="token punctuation">(</span><span class="token string">'&gt;rabbit &lt;bait'</span> <span class="token operator">IN</span> <span class="token keyword">BOOLEAN</span> <span class="token keyword">MODE</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 匹配词rabbit和bait，增加前者的等级，降低后者的等级 */</span><span class="token keyword">SELECT</span> note_text<span class="token keyword">FROM</span> productnotes<span class="token keyword">WHERE</span> <span class="token keyword">MATCH</span><span class="token punctuation">(</span>note_text<span class="token punctuation">)</span> AGAINST<span class="token punctuation">(</span><span class="token string">'+rabbit +(&lt;bait)'</span> <span class="token operator">IN</span> <span class="token keyword">BOOLEAN</span> <span class="token keyword">MODE</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 匹配词rabbit和bait，降低后者的等级 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>全文本布尔操作符</li></ol><div class="table-container"><table><thead><tr><th><strong>布尔操作符</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>+</td><td>包含，词必须存在</td></tr><tr><td>-</td><td>排除，词必须不出现</td></tr><tr><td>&gt;</td><td>包含，而且增加等级值</td></tr><tr><td>&lt;</td><td>包含，且减少等级值</td></tr><tr><td>()</td><td>把词组成子表达式（允许这些子表达式作为一个组被包含、排除、排列等）</td></tr><tr><td>~</td><td>取消一个词的排序值</td></tr><tr><td>*</td><td>词尾的通配符</td></tr><tr><td>“”</td><td>定义一个短语（与单个词的列表不一样，它匹配整个短语以便包含或排除这个短语）</td></tr></tbody></table></div><h2 id="第19章-插入数据"><a href="#第19章-插入数据" class="headerlink" title="第19章 插入数据"></a>第19章 插入数据</h2><ol><li><p>如果表的定义允许，则可以在INSERT操作中省略某些列：</p><ol><li>该列定义为允许NULL值（无值或空值）。</li><li>在表定义中给出默认值。这表示如果不给出值，将使用默认值。</li></ol></li><li><p>可以通过在INSERT和INTO之间添加关键字LOW_PRIORITY，指示MySQL降低INSERT语句的优先级：</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> LOW_PRIORITY <span class="token keyword">INTO</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>同样适用于UPDATE和DELETE。</p></blockquote></li><li><p>一些例子：</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">/* 一次插入一条记录 */</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> customers <span class="token punctuation">(</span>cust_name<span class="token punctuation">,</span> cust_address<span class="token punctuation">)</span><span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 一次插入多条记录 */</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> customers <span class="token punctuation">(</span>cust_name<span class="token punctuation">,</span> cust_address<span class="token punctuation">)</span><span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">)</span><span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 插入检索出的数据 */</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> customers <span class="token punctuation">(</span>cust_name<span class="token punctuation">,</span> cust_address<span class="token punctuation">)</span><span class="token keyword">SELECT</span> cust_name<span class="token punctuation">,</span> cust_address<span class="token keyword">FROM</span> customers_new<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>INSERT SELECT中不要求列名匹配。MySQL使用的是列的位置，因此SELECT中的第一列（不管其列名）将用来填充表列中指定的第一个列，第二列将用来填充表列中指定的第二个列，如此等等。</p></blockquote></li></ol><h2 id="第20章-更新和删除数据"><a href="#第20章-更新和删除数据" class="headerlink" title="第20章 更新和删除数据"></a>第20章 更新和删除数据</h2><ol><li><p>如果用UPDATE语句更新多行，并且在更新这些行中的一行或多行时出一个现错误，则整个UPDATE操作被取消（错误发生前更新的所有行被恢复到它们原来的值）。为即使是发生错误，也继续进行更新，可使用IGNORE关键字，如下所示：</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> <span class="token keyword">IGNORE</span> customers<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>如果想从表中删除所有行，不要使用DELETE。可使用TRUNCATE TABLE语句，它完成相同的工作，但速度更快（TRUNCATE实际是删除原来的表并重新创建一个表，而不是逐行删除表中的数据）。</li></ol><h2 id="第21章-创建和操纵表"><a href="#第21章-创建和操纵表" class="headerlink" title="第21章 创建和操纵表"></a>第21章 创建和操纵表</h2><ol><li><p>主键值必须唯一。即，表中的每个行必须具有唯一的主键值。如果主键使用单个列，则它的值必须唯一。如果使用多个列，则这些列的组合值必须唯一。</p></li><li><p><strong>函数last_insert_id()</strong> 返回最后一个AUTO_INCREMENT值。</p></li><li><p>外键不能跨引擎。</p></li><li><p>一些例子：</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> productnotes<span class="token punctuation">(</span>    note_id     <span class="token keyword">INT</span>         <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    prod_id     <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>    <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    note_date   <span class="token keyword">DATETIME</span>    <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    note_text   <span class="token keyword">TEXT</span>        <span class="token boolean">NULL</span><span class="token punctuation">,</span>    update_cnt  <span class="token keyword">INT</span>         <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>note_id<span class="token punctuation">,</span> prod_id<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span>MyISAM<span class="token punctuation">;</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> Vendors<span class="token keyword">DROP</span> <span class="token keyword">COLUMN</span> vend_phone<span class="token punctuation">;</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> orderitems<span class="token keyword">ADD</span> <span class="token keyword">CONSTRAINT</span> fk_orderitems_orders<span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>order_num<span class="token punctuation">)</span><span class="token keyword">REFERENCES</span> orders <span class="token punctuation">(</span>order_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> customers2<span class="token punctuation">;</span><span class="token keyword">RENAME</span> <span class="token keyword">TABLE</span> customers2 <span class="token keyword">TO</span> customers<span class="token punctuation">;</span><span class="token keyword">RENAME</span> <span class="token keyword">TABLE</span> customers <span class="token keyword">TO</span> customers_backup<span class="token punctuation">,</span> vendors <span class="token keyword">TO</span> vendors_backup<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="第22章-使用视图"><a href="#第22章-使用视图" class="headerlink" title="第22章 使用视图"></a>第22章 使用视图</h2><ol><li><p>视图仅仅是用来查看存储在别处的数据的一种设施。视图本身不包含数据，因此它们返回的数据是从其他表中检索出来的。</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> customeremaillist <span class="token keyword">AS</span><span class="token keyword">SELECT</span> cust_id<span class="token punctuation">,</span> cust_name<span class="token punctuation">,</span> cust_email<span class="token keyword">FROM</span> customers<span class="token keyword">WHERE</span> cust_email <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>视图的规则和限制</p><ol><li>与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字）。</li><li>对于可以创建的视图数目没有限制。</li><li>为了创建视图，必须具有足够的访问权限。</li><li>视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图。</li><li>ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖。</li><li>视图不能索引，也不能有关联的触发器或默认值。</li><li>视图可以和表一起使用。</li></ol></li><li><p>使用视图</p><ol><li>视图用CREATE VIEW语句来创建。</li><li>使用SHOW CREATE VIEW viewname；来查看创建视图的语句。</li><li>用DROP删除视图，其语法为DROP VIEW viewname。</li><li>更新视图时，可以先用DROP再用CREATE，也可以直接用CREATE OR REPLACE VIEW。如果要更新的视图不存在，则第2条更新语句会创建一个视图；如果要更新的视图存在，则第2条更新语句会替换原有视图。</li></ol></li><li><p>视图是可更新的（即，可以对它们使用INSERT、UPDATE和DELETE）。更新一个视图将更新其基表（可以回忆一下，视图本身没有数据）。如果你对视图增加或删除行，实际上是对其基表增加或删除行。</p></li><li><p>并非所有视图都是可更新的。基本上可以说，如果MySQL不能正确地确定被更新的基数据，则不允许更新（包括插入和删除）。这实际上意味着，如果视图定义中有以下操作，则不能进行视图的更新：</p><ol><li>分组（使用GROUP BY和HAVING）；</li><li>联结；</li><li>子查询；</li><li>并；</li><li>聚集函数（Min()、Count()、Sum()等）；</li><li>DISTINCT；</li><li>导出（计算）列。</li></ol></li></ol><h2 id="第23章-使用存储过程"><a href="#第23章-使用存储过程" class="headerlink" title="第23章 使用存储过程"></a>第23章 使用存储过程</h2><ol><li><p>执行存储过程</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CALL</span> productpricing<span class="token punctuation">(</span><span class="token variable">@pricelow</span><span class="token punctuation">,</span> <span class="token variable">@pricehigh</span><span class="token punctuation">,</span> <span class="token variable">@priceaverage</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>创建存储过程</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- Name: ordertotal</span><span class="token comment">-- Parameters: onumber = order number</span><span class="token comment">--             taxable = 0 if not taxable, 1 if taxable</span><span class="token comment">--             ototal  = order total variable</span><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> ordertotal<span class="token punctuation">(</span>    <span class="token operator">IN</span>  onumber <span class="token keyword">INT</span><span class="token punctuation">,</span>    <span class="token operator">IN</span>  taxable <span class="token keyword">BOOLEAN</span><span class="token punctuation">,</span>    <span class="token keyword">OUT</span> ototal <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">COMMENT</span> <span class="token string">'Obtain order total, optionally adding tax'</span><span class="token keyword">BEGIN</span>    <span class="token comment">--Declare variable for total</span>    <span class="token keyword">DECLARE</span> total <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">--Declare tax percentage</span>    <span class="token keyword">DECLARE</span> taxrate <span class="token keyword">INT</span> <span class="token keyword">DEFAULT</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token comment">--GET the order total</span>    <span class="token keyword">SELECT</span> <span class="token function">Sum</span><span class="token punctuation">(</span>item_price<span class="token operator">*</span>quantity<span class="token punctuation">)</span>    <span class="token keyword">FROM</span> orderitems    <span class="token keyword">WHERE</span> order_num <span class="token operator">=</span> onumber    <span class="token keyword">INTO</span> total<span class="token punctuation">;</span>    <span class="token comment">--Is this taxable</span>    <span class="token keyword">IF</span> taxable <span class="token keyword">THEN</span>        <span class="token keyword">SELECT</span> total<span class="token operator">+</span><span class="token punctuation">(</span>total<span class="token operator">/</span><span class="token number">100</span><span class="token operator">*</span>taxrate<span class="token punctuation">)</span> <span class="token keyword">INTO</span> total<span class="token punctuation">;</span>    <span class="token keyword">END</span> <span class="token keyword">IF</span><span class="token punctuation">;</span>    <span class="token keyword">SELECT</span> total <span class="token keyword">INTO</span> ototal<span class="token punctuation">;</span><span class="token keyword">END</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>COMMENT的值会在<code>SHOW PROCEDURE STATUS</code>时显示出来。</p></blockquote></li><li><p>删除存储过程</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">PROCEDURE</span> ordertotal<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>检查存储过程</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SHOW</span> <span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> ordertotal<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>为了获得包括何时、由谁创建等详细信息的存储过程列表，使用<code>SHOW PROCEDURE STATUS</code> 或<code>SHOW PROCEDURE STATUS LIKE 'ordertotal'</code>。</p></blockquote></li><li><p>使用mysql命令行实用程序时需要注意：</p><p> 默认的MySQL语句分隔符为<code>;</code> mysql命令行实用程序也使用<code>;</code>作为语句分隔符。如果命令行实用程序要解释存储过程自身内的;字符，则它们最终不会成为存储过程的成分，这会使存储过程中的SQL出现句法错误。<br> 解决办法是临时更改命令行实用程序的语句分隔符，如下所示：</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DELIMITER</span> <span class="token comment">//</span><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> productpricing<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">BEGIN</span>    <span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>prod_price<span class="token punctuation">)</span> <span class="token keyword">AS</span> priceaverage    <span class="token keyword">FROM</span> products<span class="token punctuation">;</span><span class="token keyword">END</span> <span class="token comment">//</span><span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>除<code>\</code>符号外，任何字符都可以用作语句分隔符。</p></blockquote></li></ol><h2 id="第24章-使用游标"><a href="#第24章-使用游标" class="headerlink" title="第24章 使用游标"></a>第24章 使用游标</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> processorders <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">BEGIN</span>    <span class="token comment">-- Declare local variables</span>    <span class="token keyword">DECLARE</span> done <span class="token keyword">TINYINT</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">DECLARE</span> o <span class="token keyword">INT</span><span class="token punctuation">;</span>    <span class="token keyword">DECLARE</span> t <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">-- Declare the cursor</span>    <span class="token keyword">DECLARE</span> ordernumbers <span class="token keyword">CURSOR</span> <span class="token keyword">FOR</span>    <span class="token keyword">SELECT</span> order_num <span class="token keyword">FROM</span> orders<span class="token punctuation">;</span>    <span class="token comment">-- Declare continue handler</span>    <span class="token keyword">DECLARE</span> <span class="token keyword">CONTINUE</span> <span class="token keyword">HANDLER</span> <span class="token keyword">FOR</span> SQLSTATE <span class="token string">'02000'</span> <span class="token keyword">SET</span> done<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">-- Create a table to store the results</span>    <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> ordertotals<span class="token punctuation">(</span>        order_num <span class="token keyword">INT</span><span class="token punctuation">,</span>        total <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">-- Open the cursor</span>    <span class="token keyword">OPEN</span> ordernumbers<span class="token punctuation">;</span>    <span class="token comment">-- Loop through all rows</span>    <span class="token keyword">REPEAT</span>        <span class="token comment">-- Get order number</span>        <span class="token keyword">FETCH</span> ordernumbers <span class="token keyword">INTO</span> o<span class="token punctuation">;</span>        <span class="token comment">-- Get the total for this order</span>        <span class="token keyword">CALL</span> ordertotalmye<span class="token punctuation">(</span>o<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">-- Insert order and total into ordertotals</span>        <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> ordertotals<span class="token punctuation">(</span>order_num<span class="token punctuation">,</span>total<span class="token punctuation">)</span>        <span class="token keyword">VALUES</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">-- End of loop</span>    UNTIL done <span class="token keyword">END</span> <span class="token keyword">REPEAT</span><span class="token punctuation">;</span>    <span class="token comment">-- Close the cursor</span>    <span class="token keyword">CLOSE</span> ordernumbers<span class="token punctuation">;</span><span class="token keyword">END</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第25章-使用触发器"><a href="#第25章-使用触发器" class="headerlink" title="第25章 使用触发器"></a>第25章 使用触发器</h2><ol><li><p>触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（或位于 BEGIN 和 END 语句之间的一组语 句）：</p><ol><li>DELETE；</li><li>INSERT；</li><li>UPDATE。</li></ol></li><li><p>在创建触发器时，需要给出4条信息：</p><ol><li>唯一的触发器名；</li><li>触发器关联的表；</li><li>触发器应该响应的活动（DELETE、INSERT或UPDATE）；</li><li><p>触发器何时执行（处理之前或之后）。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> newproduct<span class="token keyword">AFTER</span> <span class="token keyword">INSERT</span> <span class="token keyword">ON</span> products<span class="token keyword">FOR EACH ROW</span> <span class="token keyword">SELECT</span> <span class="token string">'Product added'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>只有表才支持触发器，视图不支持（临时表也不支持）。</p></blockquote></li></ol></li><li><p>触发器按每个表每个事件每次地定义，每个表每个事件每次只允许一个触发器。因此，每个表最多支持6个触发器（每条INSERT、UPDATE 和DELETE的之前和之后）。</p><blockquote><p>如果BEFORE触发器失败，则MySQL将不执行请求的操作。此外，如果BEFORE触发器或语句本身失败，MySQL 将不执行AFTER触发器（如果有的话）。</p></blockquote></li><li><p>删除触发器</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TRIGGER</span> newproduct<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>触发器不能更新或覆盖。为了修改一个触发器，必须先删除它， 然后再重新创建。</p></blockquote></li><li><p>INSERT触发器在INSERT语句执行之前或之后执行。需要知道以下几点：</p><ol><li>在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被插入的行；</li><li>在BEFORE INSERT触发器中，NEW中的值也可以被更新（允许更改被插入的值）；</li><li><p>对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT执行之后包含新的自动生成值。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> neworder<span class="token keyword">AFTER</span> <span class="token keyword">INSERT</span> <span class="token keyword">ON</span> orders<span class="token keyword">FOR EACH ROW</span> <span class="token keyword">SELECT</span> NEW<span class="token punctuation">.</span>order_new<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol></li><li><p>DELETE触发器在DELETE语句执行之前或之后执行。需要知道以下两点：</p><ol><li>在DELETE触发器代码内，你可以引用一个名为OLD的虚拟表，访问被删除的行；</li><li><p>OLD中的值全都是只读的，不能更新。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> deleteorderBEFORE <span class="token keyword">DELETE</span> <span class="token keyword">ON</span> orders<span class="token keyword">FOR EACH ROW</span><span class="token keyword">BEGIN</span>    <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> archive_orders<span class="token punctuation">(</span>order_num<span class="token punctuation">,</span> order_date<span class="token punctuation">,</span> cust_id<span class="token punctuation">)</span>    <span class="token keyword">VALUE</span><span class="token punctuation">(</span>OLD<span class="token punctuation">.</span>order_num<span class="token punctuation">,</span> OLD<span class="token punctuation">.</span>order_date<span class="token punctuation">,</span> OLD<span class="token punctuation">.</span>cust_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">END</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol></li><li><p>UPDATE触发器在UPDATE语句执行之前或之后执行。需要知道以下几点：</p><ol><li>在UPDATE触发器代码中，你可以引用一个名为OLD的虚拟表访问以前（UPDATE语句前）的值，引用一个名为NEW的虚拟表访问新更新的值；</li><li>在BEFORE UPDATE触发器中，NEW中的值可能也被更新（允许更改将要用于UPDATE语句中的值）；</li><li><p>OLD中的值全都是只读的，不能更新。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> updatevendorBEFORE <span class="token keyword">UPDATE</span> <span class="token keyword">ON</span> vendors<span class="token keyword">FOR EACH ROW</span> <span class="token keyword">SET</span> NEW<span class="token punctuation">.</span>vend_state <span class="token operator">=</span> UPPER<span class="token punctuation">(</span>NEW<span class="token punctuation">.</span>vend_state<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol></li><li>MySQL触发器中不支持CALL语句。这表示不能从触发器内调用存储过程。</li></ol><h2 id="第26章-管理事务处理"><a href="#第26章-管理事务处理" class="headerlink" title="第26章 管理事务处理"></a>第26章 管理事务处理</h2><ol><li><p>事务处理（transaction processing）可以用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行。</p><blockquote><p> MyISAM和InnoDB是两种最常使用的引擎。前者不支持明确的事务处理管理，而后者支持。</p></blockquote></li><li><p>相关术语：</p><ol><li><strong>事务（transaction）</strong> 指一组SQL语句；</li><li><strong>回退（rollback）</strong> 指撤销指定SQL语句的过程；</li><li><strong>提交（commit）</strong> 指将未存储的SQL语句结果写入数据库表；</li><li><strong>保留点（ savepoint ）</strong> 指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。</li></ol></li><li><p>开始事务</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>回退事务</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> ordertotals<span class="token punctuation">;</span><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> ordertotals<span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> ordertotals<span class="token punctuation">;</span><span class="token keyword">ROLLBACK</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> ordertotals<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>事务处理用来管理INSERT、UPDATE和DELETE语句。你不能回退SELECT语句，也 <strong>不能回退CREATE或DROP操作</strong> 。事务处理块中可以使用这两条语句，但如果你执行回退，它们不会被撤销。</p></blockquote></li><li><p>提交事务</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> orderitems <span class="token keyword">WHERE</span> order_num <span class="token operator">=</span> <span class="token number">20010</span><span class="token punctuation">;</span><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> orders <span class="token keyword">WHERE</span> order_num <span class="token operator">=</span> <span class="token number">20010</span><span class="token punctuation">;</span><span class="token keyword">COMMIT</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>当COMMIT或ROLLBACK语句执行后，事务会自动关闭（将来的更改会隐含提交）。</p></blockquote></li><li><p>为了支持回退部分事务处理，必须能在事务处理块中合适的位置放 置保留点。这样，如果需要回退，可以回退到某个保留点。</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SAVEPOINT</span> delete1<span class="token punctuation">;</span> <span class="token comment">/* 创建保留点 */</span><span class="token keyword">ROLLBACK</span> <span class="token keyword">TO</span> delete1<span class="token punctuation">;</span> <span class="token comment">/* 回退到保留点 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>保留点越多，就越能按自己的意愿灵活地进行回退，所以保留点越多越好。</p><p>保留点在事务处理完成（执行一条ROLLBACK或 COMMIT）后自动释放。也可以用RELEASE SAVEPOINT明确地释放保留点。</p></blockquote></li><li><p>默认的MySQL行为是自动提交所有更改。可以关闭：</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SET</span> AUTOCOMMIT<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>autocommit标志决定是否自动提交更改，不管有没有COMMIT 语句。设置autocommit为0（假）指示MySQL不自动提交更改 （直到autocommit被设置为真为止）。</p><p>autocommit标志是针对每个连接而不是服务器的。</p></blockquote></li></ol><h2 id="第27章-全球化和本地化"><a href="#第27章-全球化和本地化" class="headerlink" title="第27章 全球化和本地化"></a>第27章 全球化和本地化</h2><ol><li><p>重要术语：</p><ol><li><strong>字符集</strong> 为字母和符号的集合；</li><li><strong>编码</strong> 为某个字符集成员的内部表示；</li><li><strong>校对</strong> 为规定字符如何比较的指令。</li></ol></li><li><p>查看所支持的字符集完整列表</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SHOW</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查看所支持校对的完整列表</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SHOW</span> COLLATION<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>许多校对出现两次，一次区分大小写（由_cs表一次不区分大小写（由_ci表示）。</p></blockquote></li><li><p>通常系统管理在安装时定义一个默认的字符集和校对。</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'character%'</span><span class="token punctuation">;</span><span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'collation%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>可以在创建数据库时，指定默认的字符集和校对。</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> mytable<span class="token punctuation">(</span>    c1 <span class="token keyword">INT</span><span class="token punctuation">,</span>    c2 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> hebrew  <span class="token keyword">COLLATE</span> hebrew_general_ci<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>一般，MySQL如下确定使用什么样的字符集和校对：</p><ol><li>如果指定CHARACTER SET和COLLATE两者，则使用这些值。</li><li>如果只指定CHARACTER SET，则使用此字符集及其默认的校对（如SHOW CHARACTER SET的结果中所示）。</li><li>如果既不指定CHARACTER SET，也不指定COLLATE，则使用数据库默认。</li></ol></li><li><p>MySQL还允许对每个列设置：</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> mytable<span class="token punctuation">(</span>    c1 <span class="token keyword">INT</span><span class="token punctuation">,</span>    c2 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> latin1 <span class="token keyword">COLLATE</span> latin1_general_ci<span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> hebrew  <span class="token keyword">COLLATE</span> hebrew_general_ci<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>校对在对用ORDER BY子句检索出来的数据排序时起重要的作用。如果你需要用与创建表时不同的校对顺序排序特定的SELECT语句，可以在SELECT语句自身中进行：</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> customers<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> lastname<span class="token punctuation">,</span> firstname <span class="token keyword">COLLATE</span> latin1_general_cs<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>除了ORDER BY子句，COLLATE还可以用于GROUP BY、HAVING、聚集函数、别名等。</p></blockquote></li><li><p>如果绝对需要，串可以在字符集之间进行转换。为此，使用Cast()或Convert()函数。</p></li></ol><h2 id="第28章-安全管理"><a href="#第28章-安全管理" class="headerlink" title="第28章 安全管理"></a>第28章 安全管理</h2><ol><li><p>创建用户账号</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">USER</span> ben IDENTIFIED <span class="token keyword">BY</span> <span class="token string">'123'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>重命名用户账号</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">RENAME</span> <span class="token keyword">USER</span> ben <span class="token keyword">TO</span> kom<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>删除用户账号</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">USER</span> kom<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>在创建用户账号后，必须接着分配访问权限。新创建的用户账号没有访问权限。它们能登录MySQL，但不能看到数据，不能执行任何数据库操作。查看用户账号权限：</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SHOW</span> GRANTS <span class="token keyword">FOR</span> kom<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><strong>用户定义为user@host。</strong> MySQL的权限用用户名和主机名结合定义。如果不指定主机名，则使用默认的主机名%（授予用户访问权限而不管主机名）。</p></blockquote></li><li><p>为设置权限，使用GRANT语句。GRANT要求你至少给出以下信息：</p><ol><li>要授予的权限；</li><li>被授予访问权限的数据库或表；</li><li><p>用户名。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">GRANT</span> <span class="token keyword">SELECT</span> <span class="token keyword">ON</span> crashcourse<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">TO</span> kom<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol></li><li><p>撤销特定的权限使用REVOKE：</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">REVOKE</span> <span class="token keyword">SELECT</span> <span class="token keyword">ON</span> crashcourse<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">FROM</span> kom<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>GRANT和REVOKE可在几个层次上控制访问权限：</p><ol><li>整个服务器，使用GRANT ALL和REVOKE ALL；</li><li>整个数据库，使用ON database.*；</li><li>特定的表，使用ON database.table；</li><li>特定的列；</li><li>特定的存储过程。</li></ol></li><li><p>更改密码</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SET</span> PASSWORD <span class="token keyword">FOR</span> kom <span class="token operator">=</span> PASSWORD<span class="token punctuation">(</span><span class="token string">'456'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>不指定用户名时，SET PASSWORD更新当前登录用户的口令。<code>SET PASSWORD = PASSWORD('789')</code></p></blockquote></li><li><p>在使用GRANT和REVOKE时，用户账号必须存在，但对所涉及的对象没有这个要求。这允许管理员在创建数据库和表之前设计和实现安全措施。这样做的副作用是，当某个数据库或表被删除时（用DROP语句），相关的访问权限仍然存在。而且，如果将来重新创建该数据库或表，这些权限仍然起作用。</p></li><li><p>可通过列出各权限并用逗号分隔， 将多条GRANT语句串在一起。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">GRANT SELECT, INSERT ON crashcourse.* TO kom<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>权限列表</li></ol><div class="table-container"><table><thead><tr><th><strong>权限</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>ALL</td><td>除GRANT OPTION外的所有权限</td></tr><tr><td>ALTER</td><td>使用ALTER TABLE</td></tr><tr><td>ALTER ROUTINE</td><td>使用ALTER PROCEDURE和DROP PROCEDURE</td></tr><tr><td>CREATE</td><td>使用CREATE TABLE</td></tr><tr><td>CREATE ROUTINE</td><td>使用CREATE PROCEDURE</td></tr><tr><td>CREATE TEMPORARY TABLES</td><td>使用CREATE TEMPORARY TABLE</td></tr><tr><td>CREATE USER</td><td>使用CREATE USER、DROP USER、RENAME USER和REVOKE ALL PRIVILEGES</td></tr><tr><td>CREATE VIEW</td><td>使用CREATE VIEW</td></tr><tr><td>DELETE</td><td>使用DELETE</td></tr><tr><td>DROP</td><td>使用DROP TABLE</td></tr><tr><td>EXECUTE</td><td>使用CALL和存储过程</td></tr><tr><td>FILE</td><td>使用SELECT INTO OUTFILE和LOAD DATA INFILE</td></tr><tr><td>GRANT OPTION</td><td>使用GRANT和REVOKE</td></tr><tr><td>INDEX</td><td>使用CREATE INDEX和DROP INDEX</td></tr><tr><td>INSERT</td><td>使用INSERT</td></tr><tr><td>LOCK TABLES</td><td>使用LOCK TABLES</td></tr><tr><td>PROCESS</td><td>使用SHOW FULL PROCESSLIST</td></tr><tr><td>RELOAD</td><td>使用FLUSH</td></tr><tr><td>REPLICATION CLIENT</td><td>服务器位置的访问</td></tr><tr><td>REPLICATION SLAVE</td><td>由复制从属使用</td></tr><tr><td>SELECT</td><td>使用SELECT</td></tr><tr><td>SHOW DATABASES</td><td>使用SHOW DATABASES</td></tr><tr><td>SHOW VIEW</td><td>使用SHOW CREATE VIEW</td></tr><tr><td>SHUTDOWN</td><td>使用mysqladmin shutdown（用来关闭MySQL）</td></tr><tr><td>SUPER</td><td>使用CHANGE MASTER、KILL、LOGS、PURGE、MASTER 和SET GLOBAL。还允许mysqladmin调试登录</td></tr><tr><td>UPDATE</td><td>使用UPDATE</td></tr><tr><td>USAGE</td><td>无访问权限</td></tr></tbody></table></div><h2 id="第29章-数据库维护"><a href="#第29章-数据库维护" class="headerlink" title="第29章 数据库维护"></a>第29章 数据库维护</h2><ol><li><p>备份数据</p><ol><li>使用命令行实用程序mysqldump转储所有数据库内容到某个外部文件。在进行常规备份前这个实用程序应该正常运行，以便能正确地备份转储文件。</li><li>可用命令行实用程序 mysqlhotcopy 从一个数据库复制所有数据 （并非所有数据库引擎都支持这个实用程序）。</li><li><p>可以使用MySQL的BACKUP TABLE或SELECT INTO OUTFILE转储所有数据到某个外部文件。这两条语句都接受将要创建的系统文件名，此系统文件必须不存在，否则会出错。数据可以用RESTORE TABLE来复原。</p><blockquote><p>为了保证所有数据被写到磁盘（包括索引数据）可能需要在进行备份前使用FLUSH TABLES语句。</p></blockquote></li></ol></li><li><p>进行数据库维护</p><ol><li><p>检查表键是否正确</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ANALYZE</span> <span class="token keyword">TABLE</span> orders<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>CHECK TABLE用来针对许多问题对表进行检查。在MyISAM表上还对索引进行检查。CHECK TABLE支持一系列的用于MyISAM表的方式。 CHANGED检查自最后一次检查以来改动过的表。EXTENDED执行最彻底的检查，FAST只检查未正常关闭的表，MEDIUM检查所有被删除的链接并进行键检验，QUICK只进行快速扫描。</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CHECK</span> <span class="token keyword">TABLE</span> orders<span class="token punctuation">,</span> orderitems FAST <span class="token keyword">QUICK</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>如果 MyISAM 表访问产生不正确和不一致的结果，可能需要用REPAIR TABLE来修复相应的表。这条语句不应该经常使用，如果需要经常使用，可能会有更大的问题要解决。</p><p>如果从一个表中删除大量数据，应该使用OPTIMIZE TABLE来收回所用的空间，从而优化表的性能。</p></blockquote></li></ol></li></ol><h2 id="第30章-改善性能"><a href="#第30章-改善性能" class="headerlink" title="第30章 改善性能"></a>第30章 改善性能</h2><ol><li>可使用<code>SHOW PROCESSLIST</code> 显示所有活动进程（以及它们的线程ID和执行时间）。可以用KILL命令终结某个特定的进程（使用这个命令需要作为管理员登录）。</li><li>使用EXPLAIN语句让MySQL解释它将如何执行一条SELECT语句。</li><li>一般来说，存储过程执行得比一条一条地执行其中的各条MySQL 语句快。</li><li>有的操作（包括INSERT）支持一个可选的DELAYED关键字，如果使用它，将把控制立即返回给调用程序，并且一旦有可能就实际执行该操作。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习中的策略梯度与baseline</title>
      <link href="qiang-hua-xue-xi-zhong-de-ce-lue-ti-du-yu-baseline/"/>
      <url>qiang-hua-xue-xi-zhong-de-ce-lue-ti-du-yu-baseline/</url>
      
        <content type="html"><![CDATA[<h2 id="一、策略梯度中的-baseline"><a href="#一、策略梯度中的-baseline" class="headerlink" title="一、策略梯度中的 baseline"></a>一、策略梯度中的 baseline</h2><blockquote><p>本小结的主要内容是做数学推导得到带 baseline 的策略梯度的公式。</p></blockquote><p>策略梯度方法常用 baseline 来降低方差，可以让收敛更快。</p><h3 id="1-1-baseline-的性质"><a href="#1-1-baseline-的性质" class="headerlink" title="1.1 baseline 的性质"></a>1.1 baseline 的性质</h3><p>baseline 指的是一个函数 b ，它不依赖于动作 $A$ ，可以得到公式：</p><script type="math/tex; mode=display">\mathbb{E}_{A \sim \pi} \left[ b \cdot \frac{\partial \log \pi(A|s; \theta)}{\partial \theta} \right] = 0 \tag{1.1}</script><p>证明过程如下：</p><script type="math/tex; mode=display">\begin{aligned}\mathbb{E}_{A \sim \pi} \left[ b \cdot \frac{\partial \log \pi(A|s; \theta)}{\partial \theta} \right] \\& （b 不依赖与动作 A） \\& = b \cdot \mathbb{E}_{A \sim \pi} \left[ \frac{\partial \log \pi(A|s; \theta)}{\partial \theta} \right] \\& （假设动作是离散的，展开期望） \\& = b \cdot \sum_{a \in A}\pi(a|s; \theta) \frac{\partial \log \pi(a|s; \theta)}{\partial \theta} \\& （求导的链式法则） \\& = b \cdot \sum_{a \in A}\pi(a|s; \theta) \left[ \frac{1}{\pi(a|s; \theta)} \cdot \frac{\partial \pi(a|s; \theta)}{\partial \theta} \right] \\& = b \cdot \sum_{a \in A} \frac{\partial \pi(a|s; \theta)}{\partial \theta} \\& （连加与求导的对象不同） \\& = b \cdot \frac{\partial \sum_{a \in A} \pi(a|s; \theta)}{\partial \theta} \\& （所有动作的概率和为1） \\& = b \cdot \frac{\partial 1}{\partial \theta} \\& （常数的导数为0） \\& = 0 \\\end{aligned}</script><h3 id="1-2-带-baseline-的策略梯度公式"><a href="#1-2-带-baseline-的策略梯度公式" class="headerlink" title="1.2 带 baseline 的策略梯度公式"></a>1.2 带 baseline 的策略梯度公式</h3><p>在<a href="https://kibazen.cn/ji-yu-ce-lue-de-qiang-hua-xue-xi/">基于策略的强化学习</a>中推导了策略梯度的公式：</p><script type="math/tex; mode=display">\frac{\partial V(s; \theta)}{\partial \theta} = \mathbb{E}_{A \sim \pi(\cdot | s; \theta)} \left[ \frac{\partial \log \pi(A | s; \theta)}{\partial \theta} \cdot Q_{\pi}(s, A) \right]</script><p>结合上面推导得到公式1和策略梯度公式，可以得到 <strong>带 baseline 的策略梯度公式</strong> ：</p><script type="math/tex; mode=display">\begin{aligned}\frac{\partial V_{\pi}(s)}{\partial \theta}& = \mathbb{E}_{A \sim \pi} \left[ \frac{\partial \log \pi(A | s; \theta)}{\partial \theta} \cdot Q_{\pi}(s, A) \right] \\& = \mathbb{E}_{A \sim \pi} \left[ \frac{\partial \log \pi(A | s; \theta)}{\partial \theta} \cdot Q_{\pi}(s, A) \right] - 0 \\& = \mathbb{E}_{A \sim \pi} \left[ \frac{\partial \log \pi(A | s; \theta)}{\partial \theta} \cdot Q_{\pi}(s, A) \right] - \mathbb{E}_{A \sim \pi} \left[ b \cdot \frac{\partial \log \pi(A|s; \theta)}{\partial \theta} \right] \\& = \mathbb{E}_{A \sim \pi} \left[ \frac{\partial \log \pi(A | s; \theta)}{\partial \theta} \cdot \left( Q_{\pi}(s, A) - b \right) \right]\end{aligned}</script><p>即，如果 baseline 函数 b 不依赖于动作 $A_t$，下面公式成立：</p><script type="math/tex; mode=display">\frac{\partial V_{\pi}(s_t)}{\partial \theta} = \mathbb{E}_{A_t \sim \pi} \left[ \frac{\partial \log \pi(A_t | s_t; \theta)}{\partial \theta} \cdot \left( Q_{\pi}(s_t, A_t) - b \right) \right] \tag{1.2}</script><p>从公式中我们可以看出：baseline 不会影响策略梯度的正确性，不管函数 b 是什么，得到的期望都是一样的。</p><h3 id="1-3-蒙特卡洛近似"><a href="#1-3-蒙特卡洛近似" class="headerlink" title="1.3 蒙特卡洛近似"></a>1.3 蒙特卡洛近似</h3><p>将 <strong>带 baseline 的策略梯度公式</strong> 中求期望的部分记作 $g(A_t)$，即：</p><script type="math/tex; mode=display">g(A_t) = \frac{\partial \log \pi(A_t | s_t; \theta)}{\partial \theta} \cdot \left( Q_{\pi}(s_t, A_t) - b \right)</script><ol><li>从策略 $\pi(\cdot | s; \theta)$ 中抽样出动作 $a_t$，然后计算 $g(a_t)$ 。计算得到的 $g(a_t)$ 就是 $\mathbb{E}_{A_t \sim \pi} \left[ g(A_t) \right]$ 的蒙特卡洛近似。</li><li>$g(a_t)$ 是策略梯度的一个无偏估计，这是因为 $g(A_t)$ 关于 $A_t$ 的期望等于策略梯度。$g(a_t)$ 其实是一个随机梯度，它是对策略梯度的蒙特卡洛近似。实际训练策略网络的时候，用的都是随机梯度 $g(a_t)$ ，而不是用真正的策略梯度。<script type="math/tex; mode=display">\mathbb{E}_{A_t \sim \pi} \left[ g(A_t) \right] = \frac{\partial V_{\pi}(s_t)}{\partial \theta}</script></li><li>使用随机梯度上升更新策略网络的参数 $\theta$<script type="math/tex; mode=display">\theta \leftarrow \theta + \beta \cdot g(a_t)</script></li></ol><p>从 <strong>带 baseline 的策略梯度公式</strong> 看到，虽然使用不同的 baseline 函数 b 不会改变期望 $\mathbb{E}_{A_t \sim \pi} \left[ g(A_t) \right]$ 的值，但是会影响 $g(a_t)$ 的值。如果选择的baseline 函数 b 很好，接近 $Q_{\pi}(s_t, A_t)$，随机策略梯度 $g(a_t)$ 的方差就会变小，就能让算法收敛更快。这也是为什么要使用 baseline 函数 b 的原因。</p><h3 id="1-4-baseline-的选择"><a href="#1-4-baseline-的选择" class="headerlink" title="1.4 baseline 的选择"></a>1.4 baseline 的选择</h3><ol><li><p>b=0</p><p> 相当于不适用 baseline，得到的是标准的策略梯度。</p><script type="math/tex; mode=display">\frac{\partial V_{\pi}(s_t)}{\partial \theta} = \mathbb{E}_{A_t \sim \pi} \left[ \frac{\partial \log \pi(A_t | s_t; \theta)}{\partial \theta} \cdot Q_{\pi}(s_t, A_t) \right]</script></li><li><p>$b=V_{\pi}(s_t)$<br> 因为 $V_{\pi}(s_t)$ 只依赖于当前状态的 $s_t$，状态 $s_t$ 是先于 $A_t$ 被观测到的，所以 $s_t$ 不依赖于 $A_t$，可以作为 baseline 。</p><p> 而选择使用 $V_{\pi}(s_t)$ 作为 baseline 的原因在于，$V_{\pi}(s_t)$ 的值接近 $Q_{\pi}(s_t, A_t)$，能够有效的降低方差。</p><script type="math/tex; mode=display">V_{\pi}(s_t) = \mathbb{E}_{A_t}[Q_{\pi}(s_t, A_t)]</script></li></ol><h2 id="二、REINFORCE-with-Baseline"><a href="#二、REINFORCE-with-Baseline" class="headerlink" title="二、REINFORCE with Baseline"></a>二、REINFORCE with Baseline</h2><h3 id="2-1-近似带-baseline-的策略梯度"><a href="#2-1-近似带-baseline-的策略梯度" class="headerlink" title="2.1 近似带 baseline 的策略梯度"></a>2.1 近似带 baseline 的策略梯度</h3><p>在<a href="#14-baseline-的选择">1.4 baseline 的选择</a>中，证明了可以使用 $V_{\pi}(s_t)$ 来作为 Baseline：</p><script type="math/tex; mode=display">\frac{\partial V_{\pi}(s_t)}{\partial \theta} = \mathbb{E}_{A_t \sim \pi} \left[ \frac{\partial \log \pi(A_t | s_t; \theta)}{\partial \theta} \cdot \left( Q_{\pi}(s_t, A_t) - V_{\pi}(s_t) \right) \right]</script><p>在使用这个公式训练时，需要做总共3步近似：</p><ol><li><p>使用随机策略梯度来近似真正的策略梯度的期望（蒙特卡洛近似）<br> 记 $g(A_t)$ 为：</p><script type="math/tex; mode=display">g(A_t) = \frac{\partial \log \pi(A_t | s_t; \theta)}{\partial \theta} \cdot \left( Q_{\pi}(s_t, A_t) - V_{\pi}(s_t) \right)</script><p> 从策略 $\pi(\cdot | s; \theta)$ 中抽样出动作 $a_t$，然后使用随机策略梯度 $g(a_t)$ 的值来代替真正的策略梯度的期望 $\mathbb{E}_{A_t \sim \pi} \left[ g(A_t) \right]$ 的值。</p></li><li><p>使用折扣回报来近似 $Q_{\pi}(s_t, a_t)$ 的值（再一次蒙特卡洛近似）<br> 经过了上一步的近似后，我们得到：</p><script type="math/tex; mode=display">g(a_t) = \frac{\partial \log \pi(a_t | s_t; \theta)}{\partial \theta} \cdot \left( Q_{\pi}(s_t, a_t) - V_{\pi}(s_t) \right)</script><p> 得到的等式中，$Q_{\pi}(s_t, a_t)$ 和 $V_{\pi}(s_t)$ 依然是未知的。</p><p> 使用策略 $\pi(\cdot | s; \theta)$ 控制智能体玩一局游戏到结束，得到轨迹：</p><script type="math/tex; mode=display">s_t, a_t, r_t, s_{t+1}, a_{t+1}, r_{t+1}, \cdots, s_n, a_n, r_n</script><p> 计算折扣回报：</p><script type="math/tex; mode=display">u_t = \sum_{i=t}^n \gamma^{i-t} r_i</script><p> 折扣回报 $u_t$ 就是 $Q_{\pi}(s_t, a_t)$ 的无偏估计。REINFORCE 算法就是使用折扣回报 $u_t$ 来近似 $Q_{\pi}(s_t, a_t)$ 的值。</p></li><li><p>使用神经网络来近似 $V_{\pi}(s_t)$（函数近似）</p><p> 使用神经网络 $v(s; \mathbf{w})$ 来近似 $V_{\pi}(s_t)$ 的值。</p></li></ol><p>经过3步近似后，可以得到 <strong>近似后的带 baseline 的策略梯度</strong> ：</p><script type="math/tex; mode=display">\frac{\partial V_{\pi}(s_t)}{\partial \theta} \approx g(a_t) \approx \frac{\partial \log \pi(a_t | s_t; \theta)}{\partial \theta} \cdot \left( u_t - v(s_t; \mathbf{w}) \right)</script><h3 id="2-2-算法训练流程"><a href="#2-2-算法训练流程" class="headerlink" title="2.2 算法训练流程"></a>2.2 算法训练流程</h3><ol><li><p>使用策略 $\pi(\cdot | s; \theta)$ 控制智能体玩一局游戏到结束，得到轨迹：</p><script type="math/tex; mode=display">s_t, a_t, r_t, s_{t+1}, a_{t+1}, r_{t+1}, \cdots, s_n, a_n, r_n</script></li><li><p>计算折扣回报 $u_t$ 和误差 $\delta_t$</p><script type="math/tex; mode=display">u_t = \sum_{i=t}^n \gamma^{i-t} r_i</script><script type="math/tex; mode=display">\delta_t = v(s_t; \mathbf{w}) - u_t（注意这里是v-q而不是q-v）</script></li><li><p>更新策略网络的参数 $\theta$</p><script type="math/tex; mode=display">\theta \leftarrow \theta - \beta \cdot \delta_t \cdot \frac{\partial \log \pi(a_t | s_t; \theta)}{\partial \theta}</script></li><li><p>更新价值网络的参数 $\mathbf{w}$</p><script type="math/tex; mode=display">\mathbf{w} \leftarrow \mathbf{w} - \alpha \cdot \delta_t \cdot \frac{\partial v(s_t; \mathbf{w})}{\partial \mathbf{w}}</script><blockquote><p>其中 $\delta_t \cdot \frac{\partial v(s_t; \mathbf{w})}{\partial \mathbf{w}}$ 是误差 $\delta_t$ 的均方差关于参数 $\mathbf{w}$ 的导数</p><script type="math/tex; mode=display">\frac{\partial \delta_t ^2 / 2}{\partial \mathbf{w}} = \delta_t \cdot \frac{\partial v(s_t; \mathbf{w})}{\partial \mathbf{w}}</script></blockquote></li><li><p>对于第1步中的每个时刻，重复第2-4步。</p></li></ol><h2 id="三、Advantage-Actor-Critic（A2C）算法"><a href="#三、Advantage-Actor-Critic（A2C）算法" class="headerlink" title="三、Advantage Actor-Critic（A2C）算法"></a>三、Advantage Actor-Critic（A2C）算法</h2><blockquote><p>把 baseline 用到 Actor-Critic Method 上得到的算法就是A2C算法。</p></blockquote><h3 id="3-1-神经网络"><a href="#3-1-神经网络" class="headerlink" title="3.1 神经网络"></a>3.1 神经网络</h3><ol><li><p>策略网络（Actor）<br> 与原始的 Actor-Critic Method 中的策略网络（Actor）相同，依然是使用神经网络 $\pi(a|s; \theta)$ 来近似策略函数 $\pi({a|s})$，其中 $\theta$ 是神经网络的参数。</p></li><li><p>价值网络（Critic）<br> <strong>价值网络使用的是状态价值网络 $V_{\pi}(s)$ 而不是动作价值网络 $Q_{\pi}(s, a)$</strong>。使用神经网络 $v(s; \mathbf{w})$ 来近似策略函数 $V_{\pi}(s)$，其中 $\mathbf{w}$ 是神经网络的参数。</p><blockquote><p>动作价值网络 $Q_{\pi}(s, a)$ 依赖于状态 $s$ 和 动作 $a$ ，而状态价值网络 $V_{\pi}(s)$ 仅依赖于状态 $s$，不依赖于动作 $a$，所以状态价值网络 $V_{\pi}(s)$ 比动作价值网络 $Q_{\pi}(s, a)$ 更好训练。</p></blockquote></li></ol><h3 id="3-2-训练过程"><a href="#3-2-训练过程" class="headerlink" title="3.2 训练过程"></a>3.2 训练过程</h3><ol><li>获取到一组 transition $(s_t, a_t, r_t, s_{t+1})$</li><li>计算 <strong>TD target</strong><script type="math/tex; mode=display">y_t = r_t + \gamma \cdot v(s_{t+1}; \mathbf{w})</script></li><li>计算 <strong>TD error</strong><script type="math/tex; mode=display">\delta_t = v(s_t; \mathbf{w}) - y_t</script></li><li>更新策略网络的参数 $\theta$<script type="math/tex; mode=display">\theta \leftarrow \theta - \beta \cdot \delta_t \cdot \frac{\partial \log \pi(a_t | s_t; \theta)}{\partial \theta}</script></li><li>更新价值网络的参数 $\mathbf{w}$<script type="math/tex; mode=display">\mathbf{w} \leftarrow \mathbf{w} - \alpha \cdot \delta_t \cdot \frac{\partial v(s_t; \mathbf{w})}{\partial \mathbf{w}}</script></li></ol><h3 id="3-3-算法推导"><a href="#3-3-算法推导" class="headerlink" title="3.3 算法推导"></a>3.3 算法推导</h3><h4 id="3-3-1-价值函数性质的推导"><a href="#3-3-1-价值函数性质的推导" class="headerlink" title="3.3.1 价值函数性质的推导"></a>3.3.1 价值函数性质的推导</h4><p>在<a href="https://kibazen.cn/qiang-hua-xue-xi-zhong-shi-xu-chai-fen-xue-xi/">强化学习中时序差分学习</a>推导出了公式：</p><script type="math/tex; mode=display">Q_{\pi}(s_t, a_t) = \mathbb{E}[R_t + \gamma \cdot Q_{\pi}(S_{t+1}, A_{t+1})], \text{ for all }\pi</script><p>所以：</p><script type="math/tex; mode=display">\begin{aligned}Q_{\pi}(s_t, a_t)& = \mathbb{E}[R_t + \gamma \cdot Q_{\pi}(S_{t+1}, A_{t+1})] \\& = \mathbb{E}_{S_{t+1}, A_{t+1}}[R_t + \gamma \cdot Q_{\pi}(S_{t+1}, A_{t+1})] \\& （R_t 与 A_{t+1} 无关） \\& = \mathbb{E}_{S_{t+1}} \left[ R_t + \gamma \cdot \mathbb{E}_{A_{t+1}}[Q_{\pi}(S_{t+1}, A_{t+1})] \right] \\& （状态价值函数的定义） \\& = \mathbb{E}_{S_{t+1}}[R_t + \gamma \cdot V_{\pi}(S_{t+1})] \\\end{aligned}</script><p>即：</p><script type="math/tex; mode=display">Q_{\pi}(s_t, a_t) = \mathbb{E}_{S_{t+1}}[R_t + \gamma \cdot V_{\pi}(S_{t+1})] \tag{3.3.1a}</script><p>另，根据状态价值函数的定义：</p><script type="math/tex; mode=display">\begin{aligned}V_{\pi}(s_t)& = \mathbb{E}_{A_t}[Q_{\pi}(s_t, A_t)] \\& （使用公式3.3.1a） \\& = \mathbb{E}_{A_t} \left[ \mathbb{E}_{S_{t+1}}[R_t + \gamma \cdot V_{\pi}(S_{t+1})] \right] \\& = \mathbb{E}_{A_t,S_{t+1}}[R_t + \gamma \cdot V_{\pi}(S_{t+1})] \\\end{aligned}</script><p>即：</p><script type="math/tex; mode=display">V_{\pi}(s_t) = \mathbb{E}_{A_t,S_{t+1}}[R_t + \gamma \cdot V_{\pi}(S_{t+1})] \tag{3.3.1b}</script><h4 id="3-3-2-价值函数性质的蒙特卡洛近似"><a href="#3-3-2-价值函数性质的蒙特卡洛近似" class="headerlink" title="3.3.2 价值函数性质的蒙特卡洛近似"></a>3.3.2 价值函数性质的蒙特卡洛近似</h4><p>假设我们获取到一组 transition $(s_t, a_t, r_t, s_{t+1})$</p><ol><li><p><strong>公式3.3.1a</strong> 可以近似为</p><script type="math/tex; mode=display">Q_{\pi}(s_t, a_t) \approx r_t + \gamma \cdot V_{\pi}(s_{t+1}) \tag{3.3.2a}</script><p> 后面会使用这个公式来近似策略梯度，A2C算法的关键也在于这个公式。</p></li><li><p><strong>公式3.3.1b</strong> 可以近似为</p><script type="math/tex; mode=display">V_{\pi}(s_t) \approx r_t + \gamma \cdot V_{\pi}(s_{t+1}) \tag{3.3.2b}</script><p> 使用TD算法训练价值网络 $V_{\pi}(s_t)$ 时，<strong>TD target</strong> 就是由这个公式来的。</p></li></ol><h4 id="3-3-3-训练策略网络"><a href="#3-3-3-训练策略网络" class="headerlink" title="3.3.3 训练策略网络"></a>3.3.3 训练策略网络</h4><p>本文前面定义了随机梯度 $g(a_t)$</p><script type="math/tex; mode=display">g(a_t) = \frac{\partial \log \pi(a_t | s_t; \theta)}{\partial \theta} \cdot \left( Q_{\pi}(s_t, a_t) - V_{\pi}(s_t) \right)</script><blockquote><p>$g(a_t)$ 中包含了 $Q_{\pi}(s_t, a_t) - V_{\pi}(s_t)$，而 $Q_{\pi}(s_t, a_t) - V_{\pi}(s_t)$ 正好是优势函数（Advantage function）的定义，所以算法名中包含了 Advantage 。</p></blockquote><p>结合 $g(a_t)$ 的定义和 <strong>公式3.3.2a</strong>，有：</p><script type="math/tex; mode=display">g(a_t) \approx \frac{\partial \log \pi(a_t | s_t; \theta)}{\partial \theta} \cdot \left( r_t + \gamma \cdot V_{\pi}(s_{t+1}) - V_{\pi}(s_t) \right)</script><p>使用神经网络 $v(s;\mathbf{w})$ 近似状态价值函数 $V_{\pi}(s)$，得到：</p><script type="math/tex; mode=display">g(a_t) \approx \frac{\partial \log \pi(a_t | s_t; \theta)}{\partial \theta} \cdot \left( r_t + \gamma \cdot v(s_{t+1};\mathbf{w}) - v(s_t;\mathbf{w}) \right)</script><p>将公式中的 $r_t + \gamma \cdot v(s_{t+1};\mathbf{w})$ 记作 $y_t$。</p><blockquote><p>$y_t$ 其实就是 <strong>TD target</strong>，后面更新价值网络时也会用到。</p></blockquote><p>既然计算出了近似的策略梯度，就可以使用梯度上升来训练策略网络了：</p><script type="math/tex; mode=display">\theta \leftarrow \theta + \beta \cdot \frac{\partial \log \pi(a_t | s_t; \theta)}{\partial \theta} \cdot (y_t - v(s_t; \mathbf{w}))</script><h4 id="3-3-4-训练价值网络"><a href="#3-3-4-训练价值网络" class="headerlink" title="3.3.4 训练价值网络"></a>3.3.4 训练价值网络</h4><p>将 <strong>公式3.3.2b</strong> 中的 $V_{\pi}(S)$ 使用神经网络 $v(S; \mathbf{w})$ 近似，得到：</p><script type="math/tex; mode=display">v(s_t; \mathbf{w}) \approx r_t + \gamma \cdot v(s_{t+1}; \mathbf{w})</script><p>将 $r_t + \gamma \cdot v(s_{t+1}; \mathbf{w})$ 记作 $y_t$。使用TD算法训练时， $y_t$ 其实就是 <strong>TD target</strong> 。</p><p>所以 <strong>TD error</strong> 就是：</p><script type="math/tex; mode=display">\delta_t = v(s_t; \mathbf{w}) - y_t</script><p>梯度：</p><script type="math/tex; mode=display">\frac{\partial \delta_t ^2 / 2}{\partial \mathbf{w}} = \delta_t \cdot \frac{\partial v(s_t; \mathbf{w})}{\partial \mathbf{w}}</script><p>最后使用梯度下降方法来更新网络参数 $\mathbf{w}$：</p><script type="math/tex; mode=display">\mathbf{w} \leftarrow \mathbf{w} - \alpha \cdot \delta_t \cdot \frac{\partial v(s_t; \mathbf{w})}{\partial \mathbf{w}}</script><h4 id="3-3-5-对算法的直观理解"><a href="#3-3-5-对算法的直观理解" class="headerlink" title="3.3.5 对算法的直观理解"></a>3.3.5 对算法的直观理解</h4><p>回顾对策略梯度的近似：</p><script type="math/tex; mode=display">g(a_t) \approx \frac{\partial \log \pi(a_t | s_t; \theta)}{\partial \theta} \cdot \left( r_t + \gamma \cdot v(s_{t+1};\mathbf{w}) - v(s_t;\mathbf{w}) \right)</script><p>这个公式用来更新策略网络 $\pi(a|s; \theta)$。</p><p>公式中的 $r_t + \gamma \cdot v(s_{t+1};\mathbf{w}) - v(s_t;\mathbf{w})$ 是状态价值网络 $v(s;\mathbf{w})$ 做出的评价。它评价了动作 $a_t$ 的好坏，可以指导策略网络 $\pi(a|s; \theta)$ 做改进，所以状态价值网络 $v(s;\mathbf{w})$ 被称为 Critic 。</p><p>但是 $r_t + \gamma \cdot v(s_{t+1};\mathbf{w}) - v(s_t;\mathbf{w})$ 中并未包含动作 $a_t$，又是如何评价动作 $a_t$ 的好坏呢？</p><ol><li><p>$v(s_t;\mathbf{w})$ 是状态价值网络在 $t$ 时刻基于状态 $s_t$ 对状态 $s_t$ 的折扣回报 $\mathbb{E}[U_t | s_t]$ 的 <strong>预测值</strong>。预测值可以评价状态 $s_t$ 的好坏，状态 $s_t$ 越好，这个值就越大。</p></li><li><p>$r_t + \gamma \cdot v(s_{t+1};\mathbf{w})$ 是状态价值网络在 $t+1$ 时刻基于状态 $s_t$ 和状态 $s_{t+1}$ 对状态 $s_t$ 的折扣回报 $\mathbb{E}[U_t | s_t, s_{t+1}]$ 的 <strong>预测值</strong>。</p></li><li><p>$v(s_t;\mathbf{w})$ 和 $r_t + \gamma \cdot v(s_{t+1};\mathbf{w})$ 的 <strong>相同点</strong>：</p><ul><li>都是状态价值网络对状态 $s_t$ 的折扣回报的预估值。</li><li>都能够评价状态 $s_t$ 的好坏。</li></ul></li><li><p>$v(s_t;\mathbf{w})$ 和 $r_t + \gamma \cdot v(s_{t+1};\mathbf{w})$ 的 <strong>区别</strong>：</p><ul><li>$v(s_t;\mathbf{w})$ 是在 $t$ 时刻做出的预测，这个预测是在执行动作 $a_t$ 之前做出的，所以这个预测与动作 $a_t$ 无关。</li><li>$r_t + \gamma \cdot v(s_{t+1};\mathbf{w})$ 是在 $t+1$ 时刻做出的预测，这个预测受动作 $a_t$ 的影响，动作 $a_t$ 越好，新的状态 $s_{t+1}$ 就越好，$r_t + \gamma \cdot v(s_{t+1};\mathbf{w})$ 的值也就越大。</li><li>如果动作 $a_t$ 越好，$r_t + \gamma \cdot v(s_{t+1};\mathbf{w})$ 的值就比 $v(s_t;\mathbf{w})$ 更大，它们的差值就是正数，反之亦然。所以两者的差可以反映动作 $a_t$ 带来的优势，两者的差就叫做 Advantage 。</li></ul></li></ol><hr><blockquote><p>参考：<a href="https://www.youtube.com/playlist?list=PLvOO0btloRnujjKTwoC5fOJxC7nmiQ4c4">策略梯度与baseline</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 策略梯度 </tag>
            
            <tag> baseline </tag>
            
            <tag> 蒙特卡洛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于策略的强化学习</title>
      <link href="ji-yu-ce-lue-de-qiang-hua-xue-xi/"/>
      <url>ji-yu-ce-lue-de-qiang-hua-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、策略函数"><a href="#一、策略函数" class="headerlink" title="一、策略函数"></a>一、策略函数</h2><p>策略函数 $\pi(a|s)$ 的本质是一个概率密度函数（Probability Density Function， PDF）。它将从环境观察到的状态 $s$ 作为输入，输出所有动作中每个动作的概率。在需要执行动作时，就从这些动作概率中随机抽取一个动作来执行。</p><h2 id="二、策略网络"><a href="#二、策略网络" class="headerlink" title="二、策略网络"></a>二、策略网络</h2><p>因为从环境观察到的状态 $s$ 常常有无数多种，所以可以使用神经网络 $\pi(a|s; \theta)$ 来近似策略函数 $\pi({a|s})$，其中 $\theta$ 是神经网络的参数。神经网络 $\pi(a|s; \theta)$ 就是策略网络。</p><p>因为策略网络输出的是各个动作的概率，而各个动作概率的总和应该是1，所以策略网络最后的激活函数通常是 softmax 以保证策略网络输出值的总和为1。</p><h2 id="三、如何训练策略网络"><a href="#三、如何训练策略网络" class="headerlink" title="三、如何训练策略网络"></a>三、如何训练策略网络</h2><p>根据状态价值函数的定义有（为便于推导，假定动作是离散的）：</p><script type="math/tex; mode=display">V_{\pi}(s_t) = \mathbb{E}_A[Q_{\pi}(s_t, A)] = \sum_a \pi(a | s_t) \cdot Q_{\pi}(s_t, a)</script><p>使用神经网络 $\pi(a|s; \theta)$ 来近似策略函数 $\pi({a|s})$ 得到：</p><script type="math/tex; mode=display">V(s; \theta) = \sum_a \pi(a | s; \theta) \cdot Q_{\pi}(s, a)</script><p>我们知道，<a href="https://kibazen.cn/ma-er-ke-fu-he-bei-er-man-gong-shi-yi-ji-sheng-cheng-mo-shi/">当找到最优价值函数时，就解决了马尔科夫决策问题</a>。即当我们找到一个策略网络的参数值 $\hat{\theta}$ 使得 $V(s; \hat{\theta})$ 的值最大，我们就找到了一个最优的策略网络。</p><p>所以，令：</p><script type="math/tex; mode=display">J(\theta) = \mathbb{E}_s[V(s; \theta)]</script><p>可以使用 <strong>梯度上升</strong> 方法来更新策略网络的参数值 $\theta$ ：</p><ol><li>从环境观察到的状态 $s$ 。</li><li>更新策略网络（ $\beta$ 是学习率）<script type="math/tex; mode=display">\theta \leftarrow \theta + \beta \cdot \frac{\partial V(s; \theta)}{\partial \theta}</script></li></ol><h2 id="四、策略梯度"><a href="#四、策略梯度" class="headerlink" title="四、策略梯度"></a>四、策略梯度</h2><p>策略梯度就是使用神经网络 $\pi(a|s; \theta)$ 来近似策略函数 $\pi({a|s})$ 后得到的状态价值函数对神经网络参数 $\theta$ 的导数，即 $\frac{\partial V(s; \theta)}{\partial \theta}$ 。</p><script type="math/tex; mode=display">\begin{aligned}\frac{\partial V(s; \theta)}{\partial \theta}& = \frac{\partial \sum_a \pi(a | s; \theta) \cdot Q_{\pi}(s, a)}{\partial \theta} \\& = \sum_a \frac{\partial \pi(a | s; \theta) \cdot Q_{\pi}(s, a)}{\partial \theta} \\&（虽然不准确，但是为了简化推导，假设 Q_{\pi}(s, a) 不依赖于 \theta ） \\& = \sum_a \frac{\partial \pi(a | s; \theta)}{\partial \theta} \cdot Q_{\pi}(s, a) \\& （链式求导法则） \\& = \sum_a \pi(a | s; \theta) \cdot \frac{\partial \log \pi(a | s; \theta)}{\partial \theta} \cdot Q_{\pi}(s, a) \\& = \mathbb{E}_{A \sim \pi(\cdot | s; \theta)} \left[ \frac{\partial \log \pi(A | s; \theta)}{\partial \theta} \cdot Q_{\pi}(s, A) \right] \\\end{aligned}</script><blockquote><ol><li>上面的计算过程中，假设了 $Q_{\pi}(s, a)$ 不依赖于 $\theta$ ，这是为了简化推导，便于理解。实际上即使将 $Q_{\pi}(s, a)$ 对于 $\theta$ 的导数也考虑进去，得到的结果也是一样的。</li><li>链式求导法则<script type="math/tex; mode=display">\frac{\partial \log [\pi (\theta)]}{\partial \theta} = \frac{1}{\pi (\theta)} \cdot \frac{\partial \pi (\theta)}{\partial \theta}</script></li></ol></blockquote><p>即：</p><script type="math/tex; mode=display">\frac{\partial V(s; \theta)}{\partial \theta} = \sum_a \frac{\partial \pi(a | s; \theta)}{\partial \theta} \cdot Q_{\pi}(s, a) \tag{4.1}</script><script type="math/tex; mode=display">\frac{\partial V(s; \theta)}{\partial \theta} = \mathbb{E}_{A \sim \pi(\cdot | s; \theta)} \left[ \frac{\partial \log \pi(A | s; \theta)}{\partial \theta} \cdot Q_{\pi}(s, A) \right] \tag{4.2}</script><h2 id="五、计算策略梯度"><a href="#五、计算策略梯度" class="headerlink" title="五、计算策略梯度"></a>五、计算策略梯度</h2><h3 id="5-1-离散动作"><a href="#5-1-离散动作" class="headerlink" title="5.1 离散动作"></a>5.1 离散动作</h3><p>如果动作是离散的，比如动作空间是 $\mathcal{A} \in \{ \text{“left”}, \text{“right”}, \text{“fire”} \}$。可以使用 <strong>公式4.1</strong> ：</p><script type="math/tex; mode=display">\frac{\partial V(s; \theta)}{\partial \theta} = \sum_a \frac{\partial \pi(a | s; \theta)}{\partial \theta} \cdot Q_{\pi}(s, a) \tag{4.1}</script><ol><li><p>对每个动作 $a \in \mathcal{A}$ ，计算</p><script type="math/tex; mode=display">\mathbf{f}(a, \theta) = \frac{\partial \pi(a | s; \theta)}{\partial \theta} \cdot Q_{\pi}(s, a)</script></li><li><p>计算策略梯度</p><script type="math/tex; mode=display">\frac{\partial V(s; \theta)}{\partial \theta} = \mathbf{f}(\text{"left"}, \theta) + \mathbf{f}(\text{"right"}, \theta) + \mathbf{f}(\text{"fire"}, \theta)</script></li></ol><h3 id="5-2-连续动作"><a href="#5-2-连续动作" class="headerlink" title="5.2 连续动作"></a>5.2 连续动作</h3><p>如果动作是连续的，比如动作空间是 $\mathcal{A} = [0,1]$。可以使用 <strong>公式4.2</strong> ：</p><script type="math/tex; mode=display">\frac{\partial V(s; \theta)}{\partial \theta} = \mathbb{E}_{A \sim \pi(\cdot | s; \theta)} \left[ \frac{\partial \log \pi(A | s; \theta)}{\partial \theta} \cdot Q_{\pi}(s, A) \right] \tag{4.2}</script><p>因为直接求期望很难，所以可以对期望做蒙特卡洛（Monte Carlo）近似，步骤如下：</p><ol><li>从概率密度函数 $\pi(\cdot | s; \theta)$ 中随机抽样得到一个动作 $\hat{a}$ 。</li><li><p>计算</p><script type="math/tex; mode=display">\mathbf{g}(\hat{a}, \theta) = \frac{\partial \log \pi(\hat{a} | s; \theta)}{\partial \theta} \cdot Q_{\pi}(s, \hat{a})</script><blockquote><ol><li>显然有 $\mathbb{E}_A \left[ \mathbf{g}(A, \theta) \right]= \frac{\partial V(s; \theta)}{\partial \theta}$ 。</li><li>因为 $\hat{a}$ 是从 $\pi(\cdot | s; \theta)$ 中随机抽样得到的，所以 $\mathbf{g}(\hat{a}, \theta)$ 是 $\frac{\partial V(s; \theta)}{\partial \theta}$ 的一个无偏估计。</li></ol></blockquote></li><li><p>使用 $\mathbf{g}(\hat{a}, \theta)$ 来近似 $\frac{\partial V(s; \theta)}{\partial \theta}$ （蒙特卡洛近似）。</p></li></ol><p>上面的这种方法对离散的动作也是有效的。</p><h2 id="六、使用策略梯度来更新策略网络"><a href="#六、使用策略梯度来更新策略网络" class="headerlink" title="六、使用策略梯度来更新策略网络"></a>六、使用策略梯度来更新策略网络</h2><p>完整的步骤如下：</p><ol><li>从环境观察到的状态 $s_t$ 。</li><li>从概率密度函数 $\pi(\cdot | s_t; \theta_t)$ 中随机抽样得到一个动作 $a_t$ 。</li><li>计算动作价值 $q_t \approx Q_{\pi}(s_t, a_t)$ 。</li><li>计算策略梯度 $\mathbf{d}_{\theta, t} = \frac{\partial \log \pi(a_t | s_t; \theta)}{\partial \theta} \mid_{\theta = {\theta}_t}$ 。</li><li>计算策略梯度的近似值 $\mathbf{g}(a_t, {\theta}_t) = q_t \cdot \mathbf{d}_{\theta, t}$ 。</li><li>更新策略网络 $\theta_{t+1} = \theta_t + \beta \cdot \mathbf{g}(a_t, \theta_t)$ 。</li></ol><p>在上面的步骤3中，计算 $q_t$ 的方式有两种。</p><h3 id="6-1-REINFORCE"><a href="#6-1-REINFORCE" class="headerlink" title="6.1 REINFORCE"></a>6.1 REINFORCE</h3><p>使用观测到的 $g_t$ 来代替 $Q_{\pi}(s_t, a_t)$ 。</p><ul><li>用策略网络 $\pi(\cdot | s_t; \theta_t)$ 控制 agent 从游戏开始到游戏结束玩一局完整的游戏，得到游戏轨迹 $s_1, a_1, r_1, s_2, a_2, r_2, \cdots , s_T, a_T, r_T$ 。</li><li>计算所有时刻的折扣回报 $g_t = \sum_{k=t}^T \gamma^{k-t} r_k$ 。</li><li>因为 $Q_\pi (s_t, a_t) = \mathbb{E}[G_t]$ ，所以可以使用折扣回报 $g_t$ 来近似 $Q_\pi (s_t, a_t)$ ，即 $q_t = g_t$ 。</li></ul><h3 id="6-2-Actor-Critic-Method"><a href="#6-2-Actor-Critic-Method" class="headerlink" title="6.2 Actor-Critic Method"></a>6.2 Actor-Critic Method</h3><p>使用神经网络来近似 $Q_{\pi}(s_t, a_t)$。</p><p>我们已经使用神经网络 $\pi(a|s; \theta)$ 来近似策略函数 $\pi({a|s})$，其中 $\theta$ 是神经网络的参数。同时，我们再使用神经网络 $q(s,a;\mathbf{w})$ 来近似价值函数 $Q_{\pi}(s, a)$，其中 $\mathbf{w}$ 是神经网络的参数。</p><script type="math/tex; mode=display">V(s; \theta, \mathbf{w}) = \sum_a \pi(a | s; \theta) \cdot q_{\pi}(s, a; \mathbf{w})</script><p>训练时，策略网络 $\pi(a|s; \theta)$ 相当于运动员（Actor），而价值网络 $q(s,a;\mathbf{w})$ 相当于裁判（Critic）：</p><ul><li>训练 Actor 的目的是让 Critic 的打分尽可能的高，即更新策略网络 $\pi(a|s; \theta)$ 使状态价值 $V(s; \theta, \mathbf{w})$ 的值增加。 Actor 依靠 Critic 的打分来改进自己。</li><li>而训练 Critic 的目的则是让它对 Actor 的打分更准确，即更新价值网络 $q_{\pi}(s, a; \mathbf{w})$ 以能够更好的估计未来奖励的总和。 Critic 依靠环境给与的奖励来改进自己。</li><li>当 Critic 的打分比较准确且 Actor 的得分都比较高时，就能得到一个比较好的策略网络了。</li></ul><p>在推理时，只需要使用 Actor 来控制 agent 动作就可以了，推理时的不需要 Critic 。</p><p>算法完整的训练流程如下：</p><ol><li><p>从环境获得状态 $s_t$ 输入策略网络 $\pi(a|s; \theta)$ ，并从得到的动作概率 $\pi(a|s_t; \theta)$ 中抽样得到动作 $a_t$ 。</p></li><li><p>在环境中执行动作 $a_t$ 并获取到新的环境状态 $s_{t+1}$ 和奖励 $r_t$ 。</p></li><li><p>将新的环境状态 $s_{t+1}$ 输入策略网络中 $\pi(a|s; \theta)$ 并随机抽样得到一个临时的动作 $\hat{a}_{t+1}$ （<strong>这个动作不会在环境中执行，仅用于更新价值网络</strong>）。</p><blockquote><p>随机抽样保证样本的无偏性，这样才能用来做蒙特卡洛近似，详见<a href="#52-连续动作">5.2 连续动作</a>。</p></blockquote></li><li><p>计算动作 $a_t$ 和 $\hat{a}_{t+1}$ 的动作价值</p><script type="math/tex; mode=display">q_t = q(s_t, a_t; \mathbf{w}_t)</script><script type="math/tex; mode=display">q_{t+1} = q(s_{t+1}, \hat{a}_{t+1}; \mathbf{w}_t)</script></li><li><p>计算 <strong>TD error</strong></p><script type="math/tex; mode=display">{\delta}_t = q_t - (r_t + \gamma \cdot q_{t+1})</script></li><li><p>对价值网络 $q(s,a;\mathbf{w})$ 求导</p><script type="math/tex; mode=display">\mathbf{d}_{\mathbf{w}, t} = \frac{\partial q(s_t, a_t; \mathbf{w})}{\partial \mathbf{w}} \mid_{\mathbf{w} = \mathbf{w}_t}</script></li><li><p>使用<a href="https://kibazen.cn/qiang-hua-xue-xi-zhong-shi-xu-chai-fen-xue-xi/">时序差分学习</a>来更新价值网络（ $\alpha$ 是学习率）</p><script type="math/tex; mode=display">\mathbf{w}_{t+1} = \mathbf{w}_t - \alpha \cdot {\delta}_t \cdot \mathbf{d}_{\mathbf{w}, t}</script><blockquote><p>其中 ${\delta}_t \cdot \mathbf{d}_{\mathbf{w}, t}$ 是 <strong>TD error</strong> $\delta_t$ 的均方差关于参数 $\mathbf{w}$ 的导数</p><script type="math/tex; mode=display">\frac{\partial \delta_t ^2 / 2}{\partial \mathbf{w}} = \delta_t \cdot \mathbf{d}_{\mathbf{w}, t}</script></blockquote></li><li><p>对策略网络 $\pi(a|s; \theta)$ 求导</p><script type="math/tex; mode=display">\mathbf{d}_{\theta, t} = \frac{\partial \log \pi(a_t | s_t; \theta)}{\partial \theta} \mid_{\theta = {\theta}_t}</script></li><li><p>使用梯度上升方法来更新策略网络（ $\beta$ 是学习率）</p><script type="math/tex; mode=display">\theta_{t+1} = \theta_t + \beta \cdot q_t \cdot \mathbf{d}_{\theta, t}</script><blockquote><p>注意：实现中大多都使用第 5 步计算出来的 ${\delta}_t$ 来替代上面公式中的 $q_t$ 得到</p><script type="math/tex; mode=display">\theta_{t+1} = \theta_t + \beta \cdot {\delta}_t \cdot \mathbf{d}_{\theta, t}</script><p>这两种方式都是对的，使用 $q_t$ 是标准算法，而使用 ${\delta}_t$ 则是 <strong>Policy Gradient with Baseline</strong> 。 使用了 Baseline 的方法不影响期望，但是降低了方差，能让算法收敛更快，所以效果更好。</p></blockquote></li></ol><hr><blockquote><p>参考：<a href="https://www.youtube.com/watch?v=qI0vyfR2_Rc&amp;list=PLvOO0btloRnsiqM72G4Uid0UWljikENlU&amp;index=3&amp;ab_channel=ShusenWang">策略学习 Policy-Based Reinforcement Learning</a><br>Policy Gradient 论文：<a href="https://papers.nips.cc/paper/1713-policy-gradient-methods-for-reinforcement-learning-with-function-approximation.pdf">Policy Gradient Methods for Reinforcement Learning with Function Approximation</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 策略函数 </tag>
            
            <tag> 策略网络 </tag>
            
            <tag> 策略梯度 </tag>
            
            <tag> 策略学习 </tag>
            
            <tag> Actor-Critic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DQN中的高估问题及解决方案</title>
      <link href="dqn-zhong-de-gao-gu-wen-ti-ji-jie-jue-fang-an/"/>
      <url>dqn-zhong-de-gao-gu-wen-ti-ji-jie-jue-fang-an/</url>
      
        <content type="html"><![CDATA[<h2 id="一、DQN-中的-Bootstrapping"><a href="#一、DQN-中的-Bootstrapping" class="headerlink" title="一、DQN 中的 Bootstrapping"></a>一、DQN 中的 Bootstrapping</h2><p>Bootstrapping，自举，字面意思是：拔自己的鞋带，把自己举起来。而 Bootstrapping 在强化学习中的意思是：<strong>用一个估算去更新同类的估算</strong>。</p><p>在 DQN 算法中，我们让 DQN 在 $t$ 时刻的估计值 $Q(s_t)$ 尽量接近 <strong>TD target</strong>：</p><script type="math/tex; mode=display">y_t = r_t + \gamma \cdot \underset{a}{\operatorname{max}} Q_*(s_{t+1}, a)</script><p><strong>TD target</strong> 中使用到了 DQN 在 $t+1$ 时刻的估计值 $Q(s_{t+1})$ ，即：我们 <strong>用</strong> Q 网络在 $t+1$ 时刻的 <strong>估计值</strong> 去更新 $t$ 时刻的 <strong>估计值</strong> 。</p><h2 id="二、DQN-中的高估问题"><a href="#二、DQN-中的高估问题" class="headerlink" title="二、DQN 中的高估问题"></a>二、DQN 中的高估问题</h2><h3 id="2-1-最大化操作导致高估"><a href="#2-1-最大化操作导致高估" class="headerlink" title="2.1 最大化操作导致高估"></a>2.1 最大化操作导致高估</h3><p><strong>最大化操作本身会导致值被高估。</strong></p><p>举个例子，假如我们有一个数组 $A$：</p><script type="math/tex; mode=display">A = [-1,  5, -6,  8,  3,  2, -4, -7,  9]</script><p>数组 $A$ 的最大值是9，平均值是1。</p><p>数组 $A$ 加上一个均值为0数组 $B$：</p><script type="math/tex; mode=display">B = [-1,  1, -1,  0,  1,  1, -1, -1,  1]</script><p>后得到的数组 $C$：</p><script type="math/tex; mode=display">C = A+B = [-2,  6, -7,  8,  4,  3, -5, -8, 10]</script><p>数组 $C$ 的平均值依然是1，但是最大值却变成了10。</p><p>在 DQN 中，数组 $A$ 相当于各个动作真实的 Q 值，因为我们并不知道这个真实值，所以用 DQN 来估算它们。而估算总会有误差，相当于引入了上面的数组 $B$ 。假设 DQN 对真实动作价值的估算是无偏的（无偏估计），即 DQN 对动作估算的 Q 值和真实的 Q 值的均值相同，这和上面的例子一样。最后 DQN 估算出各个动作的 Q 值的结果相当于上面例子的 $A+B$ ，均值依然保持不变，但是最大值却变大了，所以 DQN 中最大化操作可能得到的结果也是比真实 Q 值更大的值，即最大化的操作导致了 DQN 高估了 Q 值。</p><h3 id="2-2-Bootstrapping-传播高估"><a href="#2-2-Bootstrapping-传播高估" class="headerlink" title="2.2 Bootstrapping 传播高估"></a>2.2 Bootstrapping 传播高估</h3><p>在上面分析到， <strong>TD target</strong> 中使用了 Q 网络在 $t+1$ 时刻的预估值，因为预估本身可能会导致高估真实的 Q 值，而让 DQN 在 $t$ 时刻的估计值 $Q(s_t)$ 尽量接近 <strong>TD target</strong> 则会将高估传播回 DQN，从而形成了一种正反馈。所以，一旦 DQN 中出现了高估，这种正反馈会让高估越来越严重。</p><h2 id="四、高估导致的问题"><a href="#四、高估导致的问题" class="headerlink" title="四、高估导致的问题"></a>四、高估导致的问题</h2><p>对不同动作不同程度的高估会导致原本最优的动作变成不是最优的，原本最差的动作可能会变成最优的动作。</p><p>假设某个状态下，两个动作真实的 Q 值分别是110和150，但是经过 DQN 高估后得到 Q 值分别是200和180。显然，经过高估后的各个动作的优劣完全变了样：原本最优的动作变成了最差的，最差的动作却成了最优的了。</p><p>因为各个状态下各个动作出现的概率总是不均匀的，越频繁出现的动作 DQN 对该动作的估算更新得也更频繁，估算中出现的高估则进一步加剧了这种情况。最后导致了 DQN 对各个状态下各个动作的高估程度不同。</p><h2 id="五、解决方案"><a href="#五、解决方案" class="headerlink" title="五、解决方案"></a>五、解决方案</h2><h3 id="5-1-使用-target-network-避免-Bootstrapping"><a href="#5-1-使用-target-network-避免-Bootstrapping" class="headerlink" title="5.1 使用 target network 避免 Bootstrapping"></a>5.1 使用 target network 避免 Bootstrapping</h3><p>在 DQN 中新加一个名为 <strong>target network</strong> 的网络 $Q(s,a; \mathbf{w}^-)$ ，其结构和原始的 Q 网络 $Q(s,a; \mathbf{w})$ 相同，但是使用不同的网络参数 $\mathbf{w}^-$ 。</p><p>两个网络的用处不同，原来的 Q 网络 $Q(s,a; \mathbf{w})$ 用来控制智能体和收集学习用的经验，而 <strong>target network</strong> 则用来计算 <strong>TD target</strong> 。</p><p>使用了 <strong>target network</strong> 的 DQN 算法的完整流程如下：</p><ol><li><p>计算 <strong>TD target</strong> ：</p><script type="math/tex; mode=display">y_t = r_t + \gamma \cdot \underset{a}{\operatorname{max}} Q(s_{t+1}, a; \mathbf{w}^-)</script></li><li><p>计算 <strong>TD error</strong> ：</p><script type="math/tex; mode=display">\delta^t = Q(s_t,a_t; \mathbf{w}) - y_t</script></li><li><p>使用梯度下降算法来更新 Q 网络 $Q(s_t,a_t; \mathbf{w})$ 的参数：</p><script type="math/tex; mode=display">\mathbf{w} \leftarrow \mathbf{w} - \alpha \cdot \delta^t \cdot \frac{\partial Q(s_t,a_t;\mathbf{w})}{\partial \mathbf{w}}</script></li></ol><p>因为使用了 <strong>target network</strong> 的预估值来更新原来的 Q 网络的预估值，这就避免了 Bootstrapping ，缓解了高估的问题。但是因为需要周期性的用 Q 网络的参数值来更新 <strong>target network</strong>，所以并不能完全解决高估问题，只能缓解。</p><p><strong>target network</strong> 参数的更新方式是周期性的同步自原来的Q网络。同步的方式有两种：</p><ol><li><p>直接使用原来的 Q 网络参数替换 <strong>target network</strong> 的参数：</p><script type="math/tex; mode=display">\mathbf{w}^- \leftarrow \mathbf{w}</script></li><li><p>将原来的 Q 网络参数和 <strong>target network</strong> 的参数做加权平均：</p><script type="math/tex; mode=display">\mathbf{w}^- \leftarrow \tau \cdot \mathbf{w} + (1 - \tau) \cdot \mathbf{w}^-</script></li></ol><h3 id="5-2-使用-Double-DQN-避免最大化导致的高估"><a href="#5-2-使用-Double-DQN-避免最大化导致的高估" class="headerlink" title="5.2 使用 Double DQN 避免最大化导致的高估"></a>5.2 使用 Double DQN 避免最大化导致的高估</h3><h4 id="5-2-1-原始的-DQN"><a href="#5-2-1-原始的-DQN" class="headerlink" title="5.2.1 原始的 DQN"></a>5.2.1 原始的 DQN</h4><p>其实 DQN 在计算 <strong>TD target</strong> 时，其中的 $\underset{a}{\operatorname{max}} Q(s_{t+1}, a; \mathbf{w})$ 可以分解成两步操作：</p><ol><li>使用 <strong>原来的 Q 网络</strong> 选择最优动作<script type="math/tex; mode=display">a_* = \underset{a}{\operatorname{argmax}} Q(s_{t+1},a; \mathbf{w})</script></li><li><strong>同时</strong> 使用 <strong>原来的 Q 网络</strong> 预估动作的价值<script type="math/tex; mode=display">y_t = r_t + \gamma \cdot Q(s_{t+1}, a_*; \mathbf{w})</script></li></ol><p>这两步用的都是 <strong>原来的 Q 网络</strong> 来进行计算，这种方式的表现最差，训练出的网络会严重高估真实的动作价值。</p><h4 id="5-2-2-使用了-target-network-的-DQN"><a href="#5-2-2-使用了-target-network-的-DQN" class="headerlink" title="5.2.2 使用了 target network 的 DQN"></a>5.2.2 使用了 <strong>target network</strong> 的 DQN</h4><p>使用了 <strong>target network</strong> 的 DQN 计算 <strong>TD target</strong> 时：</p><ol><li>使用 <strong>target network</strong> 选择最优动作<script type="math/tex; mode=display">a_* = \underset{a}{\operatorname{argmax}} Q(s_{t+1},a; \mathbf{w}^-)</script></li><li><strong>同时</strong> 使用 <strong>target network</strong> 预估动作的价值<script type="math/tex; mode=display">y_t = r_t + \gamma \cdot Q(s_{t+1}, a_*; \mathbf{w}^-)</script></li></ol><p>这两步用的都是 <strong>target network</strong> 来进行计算，这种方式因避免了 Bootstrapping，所以表现会比原始的 DQN 好一些，但是训练出的网络依然会高估真实的动作价值。</p><h4 id="5-2-3-Double-DQN"><a href="#5-2-3-Double-DQN" class="headerlink" title="5.2.3 Double DQN"></a>5.2.3 Double DQN</h4><p>而 Double DQN 则是对原始的 DQN 和使用了 <strong>target network</strong> 的 DQN 的一种改进：</p><ol><li>使用 <strong>原来的 Q 网络</strong> 选择最优动作<script type="math/tex; mode=display">a_* = \underset{a}{\operatorname{argmax}} Q(s_{t+1},a; \mathbf{w})</script></li><li>使用 <strong>target network</strong> 预估动作的价值<script type="math/tex; mode=display">y_t = r_t + \gamma \cdot Q(s_{t+1}, a_*; \mathbf{w}^-)</script></li></ol><p>Double DQN 中使用 <strong>原来的 Q 网络</strong> 选择最优动作，另外使用了 <strong>target network</strong> 预估动作的价值。两步使用了不同了网络，虽然改动很少，但是却能进一步的缓解高估的问题（依然没有根除高估的问题）。</p><p>对 <strong>target network</strong> 来说可以证明如下的等式是成立的：</p><script type="math/tex; mode=display">Q(s_{t+1}, a_*; \mathbf{w}^-) \le \underset{a}{\operatorname{max}} Q(s_{t+1}, a; \mathbf{w}^-)</script><p>等式左边是 Double DQN 算出的，等式右边是 <strong>target network</strong> 算出的。上面的等式表面了 Double DQN 估算出的 Q 值总是不高于使用 <strong>target network</strong> 计算出 Q 值，所以缓解了高估的问题。</p><h3 id="5-3-使用-Dueling-Network-改进网络结构"><a href="#5-3-使用-Dueling-Network-改进网络结构" class="headerlink" title="5.3 使用 Dueling Network 改进网络结构"></a>5.3 使用 Dueling Network 改进网络结构</h3><p>Dueling Network 中使用到了优势函数的概念，这里先介绍一下优势函数。</p><blockquote><p>后面的推导，特别是关于优势函数的推导与原论文中的推导不同。</p></blockquote><h4 id="5-3-1-优势函数（Advantage-Function）"><a href="#5-3-1-优势函数（Advantage-Function）" class="headerlink" title="5.3.1 优势函数（Advantage Function）"></a>5.3.1 优势函数（Advantage Function）</h4><ol><li><p>定义</p><p> 定义优势函数为：</p><script type="math/tex; mode=display">A_*(s,a) = Q_*(s,a) - V_*(s)</script><p> 其意义是：将 <script type="math/tex">V_*(s)</script> 作为基准，在状态 $s$ 的情况下，执行动作 $a$ 的好坏。即动作 $a$ 相对 <script type="math/tex">V_*(s)</script> 的优势。</p></li><li><p>性质</p><p> 对优势函数等式的两边同时做基于动作 $a$ 的 $max$ 操作得到：</p><script type="math/tex; mode=display">\underset{a}{max}A_*(s,a) = \underset{a}{max}Q_*(s,a) - V_*(s)</script><p> 根据贝尔曼最优方程（Bellman Optimality Equation）：</p><script type="math/tex; mode=display">V_*(s) = \max_a Q_*(s,a)</script><p> 于是：</p><script type="math/tex; mode=display"> \begin{aligned} \underset{a}{max}A_*(s,a) & = \underset{a}{max}Q_*(s,a) - V_*(s) \\ & = \underset{a}{max}Q_*(s,a) - \underset{a}{max}Q_*(s,a) \\ & = 0 \end{aligned}</script><p> 即：</p><script type="math/tex; mode=display">\underset{a}{max}A_*(s,a) = 0</script></li><li><p>推导</p><p> 变换一下优势函数定义的等式，可以得到下面的等式：</p><script type="math/tex; mode=display">Q_*(s,a) = V_*(s) + A_*(s,a)</script><p> 同时根据优势函数的性质，可以在上面等式右边减去一个 $0$，得到等式：</p><script type="math/tex; mode=display">Q_*(s,a) = V_*(s) + A_*(s,a) - \underset{a}{max}A_*(s,a) \tag{5.3.1}</script><p> 但是为什么要在等式的右边减去一个0呢？对比一下减去0前后的两个等式：</p><script type="math/tex; mode=display"> \begin{aligned} Q_*(s,a) & = V_*(s) + A_*(s,a) \\ Q_*(s,a) & = V_*(s) + A_*(s,a) - \underset{a}{max}A_*(s,a) \\ \end{aligned}</script><p> 发现，上面的公式有一个下面公式没有的 <strong>唯一解问题</strong> ：如果 <script type="math/tex">V_*(s)</script> 的值整体加 $x$，而 <script type="math/tex">A_*(s,a)</script> 的值整体减 $x$。上面的等式最后的值 <script type="math/tex">Q_*(s,a)</script> 没变，但是下面等式最后的值增加了 $x$。 而没有唯一解在强化学习中就意味着难以训练出模型，所以下面一个等式才能应用到强化学习中。</p></li></ol><h4 id="5-3-2-优势函数的应用-Dueling-Network"><a href="#5-3-2-优势函数的应用-Dueling-Network" class="headerlink" title="5.3.2 优势函数的应用 Dueling Network"></a>5.3.2 优势函数的应用 Dueling Network</h4><p>根据上面利用优势函数推导出的等式：</p><script type="math/tex; mode=display">Q_*(s,a) = V_*(s) + A_*(s,a) - \underset{a}{max}A_*(s,a)</script><p>使用两个神经网络来分别近似 <script type="math/tex">V_*(s)</script> 函数和 <script type="math/tex">A_*(s,a)</script> 函数，进而就可以得到 <script type="math/tex">Q_*(s,a)</script> 函数，这就是 Dueling Network。</p><p><strong>在实际使用时，根据数学公式推导出的 Dueling Network 中对优势函数求最大化的操作，换成均值操作得到的效果更好更稳定，这种替换操作没有理论依据，但是实际效果更好。</strong></p><script type="math/tex; mode=display">Q_*(s,a) = V_*(s) + A_*(s,a) - \underset{a}{mean}A_*(s,a)</script><p>最后，因为 Dueling Network 只是改进了 DQN 中原始 Q 网络的结构，所以使用了 Dueling Network 的 DQN 的训练方法与使用了原始的 Q 网络的 DQN 训练方法相同，DQN 改进的技巧（比如Double DQN）也依然都是可以使用的。</p><hr><blockquote><p>参考：<a href="https://www.youtube.com/watch?v=X2-56QN79zc&amp;list=PLvOO0btloRntS5U8rQWT9mHFcUdYOUmIC&amp;index=2&amp;ab_channel=ShusenWang">高估问题、Target Network、Double DQN</a><br>DQN 论文：<a href="https://arxiv.org/abs/1312.5602">Playing Atari with Deep Reinforcement Learning</a><br>Target Network 论文：<a href="https://web.stanford.edu/class/psych209/Readings/MnihEtAlHassibis15NatureControlDeepRL.pdf">Human-level control through deep reinforcement learning</a><br>Double DQN 论文：<a href="https://arxiv.org/abs/1509.06461">Deep Reinforcement Learning with Double Q-learning</a><br>Dueling Network 论文：<a href="https://arxiv.org/abs/1511.06581">Dueling Network Architectures for Deep Reinforcement Learning</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高估问题 </tag>
            
            <tag> Target Network </tag>
            
            <tag> Double DQN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习中的经验回放</title>
      <link href="qiang-hua-xue-xi-zhong-de-jing-yan-hui-fang/"/>
      <url>qiang-hua-xue-xi-zhong-de-jing-yan-hui-fang/</url>
      
        <content type="html"><![CDATA[<h2 id="一、时序差分学习（Temporal-Difference-Learning）"><a href="#一、时序差分学习（Temporal-Difference-Learning）" class="headerlink" title="一、时序差分学习（Temporal Difference Learning）"></a>一、时序差分学习（Temporal Difference Learning）</h2><p>强化学习中常用时序差分学习来更新模型，<a href="https://kibazen.cn/qiang-hua-xue-xi-zhong-shi-xu-chai-fen-xue-xi/">时序差分学习</a>的一般流程是：</p><ol><li>模型根据获取到的状态 $s_t$ 决定采取动作 $a_t$ 。</li><li>环境在执行动作 $a_t$ 后会给出对应的奖励 $r_t$ 和新的状态 $s_{t+1}$ 。</li><li>根据 <strong>TD target</strong> 计算出 <strong>TD error</strong> ， 然后使用 <a href="https://en.wikipedia.org/wiki/Gradient_descent">梯度下降</a> 等方法更新模型来降低 <strong>TD error</strong> 的值。</li><li>回到1重复。</li></ol><h2 id="二、经验回放（Experience-Replay）"><a href="#二、经验回放（Experience-Replay）" class="headerlink" title="二、经验回放（Experience Replay）"></a>二、经验回放（Experience Replay）</h2><p>原始的时序差分学习在实际的应用中有两个缺点：</p><ol><li>经验浪费<br> 从上面的流程可以看出，经验 $(s_r, a_t, r_t, s_{t+1})$ 在使用一次后就会被丢掉。但是事实上，这些经验可以重复利用的。这也是需要做经验回放的主要原因。</li><li>经验相关性太强<br> 前后相邻的经验的相关性太强了。比如对游戏来说，上一帧的画面和下一帧的画面变化很小。实验证明这种相关性是有害的，不利于模型的训练。</li></ol><p>经验回放则可以有效的解决上面的两个缺点。</p><p>经验回放的原理就是只保留最近的 $n$ 条经验，每次训练时 <strong>随机均匀的</strong> 从这些经验中 <strong>不重复的</strong> 选取一条或多条经验来训练。</p><blockquote><p>$n$ 的大小通常在十万到百万之间，视情况而定。这个值对训练影响较大。<br>经验回放现在是深度强化学习的标准技巧之一。</p></blockquote><h2 id="三、优先经验回放（Prioritized-Experience-Replay）"><a href="#三、优先经验回放（Prioritized-Experience-Replay）" class="headerlink" title="三、优先经验回放（Prioritized Experience Replay）"></a>三、优先经验回放（Prioritized Experience Replay）</h2><p>对经验回放改进有很多，其中一个常见的是优先经验回放。</p><p>优先经验回放的原理是 <strong>用非均匀抽样代替均匀抽样</strong> 来抽取经验。</p><h3 id="3-1-经验的重要性不同"><a href="#3-1-经验的重要性不同" class="headerlink" title="3.1 经验的重要性不同"></a>3.1 经验的重要性不同</h3><p>模型在和环境交互时，获得的经验的重要性是不同的。</p><p>比如：在一个打怪升级的游戏中，大多数经验都是和小兵战斗，只有很少的经验是和BOSS战斗。这样就容易导致训练出来的模型容易战胜小兵，但是很难打赢BOSS。所以和BOSS战斗的经验比和小兵战斗的经验更为重要。</p><h3 id="3-2-经验的抽样概率"><a href="#3-2-经验的抽样概率" class="headerlink" title="3.2 经验的抽样概率"></a>3.2 经验的抽样概率</h3><p>对于越不熟悉的状态，模型预测出的 <strong>TD error</strong> 的绝对值就会越大，所以可以根据 <strong>TD error</strong> 的绝对值的大小来判断一条经验的重要性。即 <strong>TD error</strong> 的绝对值越大越重要。</p><p>将 <strong>TD error</strong> 对应到抽样概率的方式有两种：</p><ol><li><p>经验抽样的概率 $p_t$ 正比于 <strong>TD error</strong> $\delta_t$ 的绝对值加上一个很小的数 $\epsilon$ （避免概率为0）。</p><script type="math/tex; mode=display">p_t \propto \vert \delta_t \vert + \epsilon</script></li><li><p>将所有经验的 <strong>TD error</strong> 的绝对值进行排序，大的靠前，小的靠后。 经验抽样的概率反比于排序后经验所处的位置。</p><script type="math/tex; mode=display">p_t \propto \frac{1}{rank(t)}</script></li></ol><h3 id="3-3-调整学习率"><a href="#3-3-调整学习率" class="headerlink" title="3.3 调整学习率"></a>3.3 调整学习率</h3><p>因为抽样时是非均匀的，所以需要调整学习率来抵消不同抽样概率造成的偏差。</p><p>如果一条经验的抽样概率很大，那么它就会经常的被抽到用于更新模型，所以需要调小这条经验的学习率。反之亦然。</p><p>每条经验的学习率都需要乘以系数 $(n \cdot p_t)^{-\beta}$，其中 $n$ 是经验回放池中经验的总条数， $p_t$ 是每条经验的抽验概率， $\beta$ 是一个超参数，值在0到1之间， $\beta \in (0, 1)$。</p><p>对于均匀抽样来说，每条经验概率相同，$p_1 = \cdots = p_n = \frac{1}{n}$ ，学习率系数 $(n \cdot p_t)^{-\beta}$ 值的和为1。</p><p>对于非均匀抽样来说，抽样概率 $p_t$ 越大，学习率系数 $(n \cdot p_t)^{-\beta}$ 的值越小。论文中推荐开始时 $\beta$ 值很小，后面逐步增长到1。</p><h3 id="3-4-实现细节"><a href="#3-4-实现细节" class="headerlink" title="3.4 实现细节"></a>3.4 实现细节</h3><p>需要将所有的经验 $(s_r, a_t, r_t, s_{t+1})$ 都计算出对应的 <strong>TD error</strong>。</p><p>对于刚刚收集到的经验，可以将其 <strong>TD error</strong> 的值设置为最大值。</p><p>每次使用经验后都需要更新对应的 <strong>TD error</strong> 。</p><hr><blockquote><p>参考：<a href="https://www.youtube.com/watch?v=rhslMPmj7SY&amp;list=PLvOO0btloRntS5U8rQWT9mHFcUdYOUmIC&amp;ab_channel=ShusenWang">Experience Replay</a><br>经验回放论文：<a href="http://isl.anthropomatik.kit.edu/pdf/Lin1993.pdf">Reinforcement Learning for Robots Using Neural Networks</a><br>优先经验回放论文：<a href="https://arxiv.org/abs/1511.05952">Prioritized Experience Replay</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时序差分学习 </tag>
            
            <tag> 经验回放 </tag>
            
            <tag> 优先经验回放 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习中时序差分学习</title>
      <link href="qiang-hua-xue-xi-zhong-shi-xu-chai-fen-xue-xi/"/>
      <url>qiang-hua-xue-xi-zhong-shi-xu-chai-fen-xue-xi/</url>
      
        <content type="html"><![CDATA[<p>在<a href="https://kibazen.cn/li-jie-meng-te-qia-luo-fang-fa-he-shi-xu-chai-fen-xue-xi/">理解蒙特卡洛方法和时序差分学习</a>一文中已经对时序差分学习进行了直观上的解释，本文中将具体的描述时序差分学习的数学推导过程及在强化学习中的应用。</p><h2 id="一、时序差分学习的数学推导"><a href="#一、时序差分学习的数学推导" class="headerlink" title="一、时序差分学习的数学推导"></a>一、时序差分学习的数学推导</h2><p>根据折扣回报（Discounted Return）的定义，有：</p><script type="math/tex; mode=display">\begin{aligned}G_t& = R_t + \gamma \cdot R_{t+1} + \gamma^2 \cdot R_{t+2} + \gamma^3 \cdot R_{t+3} + \cdots \\& = R_t + \gamma \cdot (R_{t+1} + \gamma \cdot R_{t+2} + \gamma^2 \cdot R_{t+3} + \cdots) \\& = R_t + \gamma \cdot G_{t+1}\end{aligned}</script><p>根据动作价值函数（Action-value function）的定义，有：</p><script type="math/tex; mode=display">\begin{aligned}Q_{\pi}(s_t, a_t)& = \mathbb{E}[G_t | s_t, a_t] \\& = \mathbb{E}[R_t + \gamma \cdot G_{t+1} | s_t, a_t] \\& = \mathbb{E}[R_t | s_t, a_t] + \gamma \cdot \mathbb{E}[G_{t+1} | s_t, a_t] \\& = \mathbb{E}[R_t | s_t, a_t] + \gamma \cdot \mathbb{E}[Q_{\pi}(S_{t+1}, A_{t+1}) | s_t, a_t] \\& = \mathbb{E}[R_t + \gamma \cdot Q_{\pi}(S_{t+1}, A_{t+1})] \\\end{aligned}</script><p>即，对所有的策略 $\pi$ 都有如下的等式：</p><script type="math/tex; mode=display">Q_{\pi}(s_t, a_t) = \mathbb{E}[R_t + \gamma \cdot Q_{\pi}(S_{t+1}, A_{t+1})], \text{ for all }\pi</script><p>直接求 $R_t + \gamma \cdot Q_{\pi}(S_{t+1}, A_{t+1})$ 的期望很困难，可以对期望做蒙特卡洛（Monte Carlo）近似，即：</p><ul><li>使用真实的奖励值 $r_t$ 来近似 $R_t$。</li><li>使用真实的Q值 $Q_{\pi}(s_{t+1}, a_{t+1})$ 来近似 $Q_{\pi}(S_{t+1}, A_{t+1})$ 。</li></ul><p>所以：</p><script type="math/tex; mode=display">\begin{aligned}Q_{\pi}(s_t, a_t)& = \mathbb{E}[R_t + \gamma \cdot Q_{\pi}(S_{t+1}, A_{t+1})] \\& \approx r_t + \gamma \cdot Q_{\pi}(s_{t+1}, a_{t+1}) \\\end{aligned}</script><p>结论：</p><ol><li>常将 $r_t + \gamma \cdot Q_{\pi}(s_{t+1}, a_{t+1})$ 的值记作 $y_t$ 。</li><li>因为 $y_t$ 中包含了真实的奖励值 $r_t$ ，所以认为 $y_t$ 比 $Q_{\pi}(s_t, a_t)$ 更准确。</li><li>将 $y_t$ 命名为 <strong>TD target</strong>，而将 $y_t - Q_{\pi}(s_t, a_t)$ 的值命名为 <strong>TD error</strong>。</li><li><strong>TD error</strong> 的绝对值越小，就表明模型预测误差越小，预测的结果越准确。所以，在确定好 <strong>TD error</strong> 的计算方式后，可以通过 <strong>梯度下降</strong> 方法来更新模型的参数，降低 <strong>TD error</strong> 。</li><li>时序差分学习的目的是让模型预测出的 $Q_{\pi}(s_t, a_t)$ 值不断的接近<strong>TD target</strong> 。</li></ol><h2 id="二、Sarsa算法"><a href="#二、Sarsa算法" class="headerlink" title="二、Sarsa算法"></a>二、Sarsa算法</h2><blockquote><p>Sarsa是State–action–reward–state–action这几个单词的缩写。</p></blockquote><p><a href="#一时序差分学习的数学推导">时序差分学习</a>的一个应用就是Sarsa算法，Sarsa算法的目的就是使用神经网络 $Q(s,a)$ 去逼近 <strong>动作价值函数（action-value function）$Q_{\pi}(s,a)$</strong> 。</p><p>Sarsa算法的<strong>TD target</strong>为 $y_t = r_t + \gamma \cdot Q(s_{t+1}, a_{t+1})$ 。</p><h2 id="三、Q-Learning算法的数学推导"><a href="#三、Q-Learning算法的数学推导" class="headerlink" title="三、Q-Learning算法的数学推导"></a>三、Q-Learning算法的数学推导</h2><p>在<a href="#一时序差分学习的数学推导">时序差分学习的数学推导</a>中得到了，对所有的策略 $\pi$ 都有如下的等式：</p><script type="math/tex; mode=display">Q_{\pi}(s_t, a_t) = \mathbb{E}[R_t + \gamma \cdot Q_{\pi}(S_{t+1}, A_{t+1})], \text{ for all }\pi</script><p>对最优策略 ${\pi}_*$ 也成立，所以：</p><script type="math/tex; mode=display">Q_*(s_t, a_t) = \mathbb{E}[R_t + \gamma \cdot Q_*(S_{t+1}, A_{t+1})]</script><blockquote><p><script type="math/tex">Q_{\pi_*}(s_t, a_t)</script> 可以简写为 <script type="math/tex">Q_*(s_t, a_t)</script> ，都可以表示最优动作价值函数。</p></blockquote><p>因为最优动作价值函数总是采用最优的动作：</p><script type="math/tex; mode=display">A_{t+1} = \underset{a}{\operatorname{argmax}}Q_*(S_{t+1}, a)</script><p>所以：</p><script type="math/tex; mode=display">Q_*(S_{t+1}, A_{t+1}) = \max_a Q_* (S_{t+1}, a)</script><p>即：</p><script type="math/tex; mode=display">\begin{aligned}Q_*(s_t, a_t)& = \mathbb{E}[R_t + \gamma \cdot Q_*(S_{t+1}, A_{t+1})] \\& = \mathbb{E}[R_t + \gamma \cdot \underset{a}{\operatorname{max}} Q_* (S_{t+1}, a)] \\\end{aligned}</script><p>直接求 $R_t + \gamma \cdot \underset{a}{\operatorname{max}} Q_* (S_{t+1}, a)$ 的期望很困难，可以对期望做蒙特卡洛（Monte Carlo）近似，即：</p><ul><li>使用真实的奖励值 $r_t$ 来近似 $R_t$。</li><li>使用真实的Q值 <script type="math/tex">\underset{a}{ \operatorname{max} } Q_*(s_{t+1}, a)</script> 来近似 <script type="math/tex">\underset{a}{ \operatorname{max} } Q_*(S_{t+1}, a)</script> 。</li></ul><p>所以：</p><script type="math/tex; mode=display">\begin{aligned}Q_*(s_t, a_t)& = \mathbb{E}[R_t + \gamma \cdot \underset{a}{\operatorname{max}} Q_* (S_{t+1}, a)] \\& \approx r_t + \gamma \cdot \underset{a}{\operatorname{max}} Q_*(s_{t+1}, a) \\\end{aligned}</script><h2 id="四、Q-Learning算法"><a href="#四、Q-Learning算法" class="headerlink" title="四、Q-Learning算法"></a>四、Q-Learning算法</h2><p><a href="#三q-learning算法的数学推导">时序差分学习</a>的另一个应用就是Q-Learning算法，Q-Learning算法的目的就是使用神经网络 $Q(s,a)$ 去逼近 <strong>最优动作价值函数（optimal action-value function）<script type="math/tex">Q_*(s,a)</script></strong> 。</p><p>Q-Learning算法的<strong>TD target</strong>为 <script type="math/tex">y_t = r_t + \gamma \cdot \underset{a}{\operatorname{max}} Q_*(s_{t+1}, a)</script> 。</p><hr><blockquote><p>参考：<a href="https://www.youtube.com/watch?v=-cYWdUubB6Q&amp;list=PLvOO0btloRnvWZCkAUrBbVB5ZjDI2hUAM&amp;ab_channel=ShusenWang">TD Learning</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时序差分学习 </tag>
            
            <tag> Sarsa算法 </tag>
            
            <tag> Q-Learning算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解蒙特卡洛方法和时序差分学习</title>
      <link href="li-jie-meng-te-qia-luo-fang-fa-he-shi-xu-chai-fen-xue-xi/"/>
      <url>li-jie-meng-te-qia-luo-fang-fa-he-shi-xu-chai-fen-xue-xi/</url>
      
        <content type="html"><![CDATA[<p>学习机器学习时常常会用到蒙特卡洛方法和时序差分学习，所以对它们有一个直观的理解还是很重要的。本文通过举一个实际的例子来帮助理解。</p><p>假如要训练一个预估开车从成都到北京需要耗时多久的模型（Model），那么如何训练呢？</p><div id="flowchart-0" class="flow-chart"></div><h2 id="1-蒙特卡洛方法（Monte-Carlo-method）"><a href="#1-蒙特卡洛方法（Monte-Carlo-method）" class="headerlink" title="1. 蒙特卡洛方法（Monte Carlo method）"></a>1. 蒙特卡洛方法（Monte Carlo method）</h2><p>最直观的方法，既然要预估开车从成都到北京需要耗时多久，那么可以直接记录开车从成都到北京所需要的时间。然后重复很多次，比如100次，把每次的耗时都给模型学习（至于模型具体怎么学习，又需要另外的算法了，比如：<a href="https://en.wikipedia.org/wiki/Gradient_descent">梯度下降</a>），这样模型就能预估出一个比较准确的时间了。</p><p>上面这种方法其实就是<a href="https://en.wikipedia.org/wiki/Monte_Carlo_method">蒙特卡洛方法</a>。这种算法的特点如下：</p><p>优点：</p><ul><li><strong>简单直接</strong>：要预估开车从成都到北京需要耗时多久，那直接做很多次，并记录经验，然后就能比较准确的训练了。</li></ul><p>缺点：</p><ul><li><strong>收集数据麻烦</strong>：直接尝试还是很麻烦的，代价太高。如果要训练一个预测手术成功率的模型，总不能拿人去试吧。</li><li><strong>需要等到完整的一次过程后才能开始训练</strong>：开车到一半时是不能训练模型的，必须要到了目的地才能训练。如果路上车出了故障，那么之前开的路都白费了，代价也太高了。</li></ul><p>第一个缺点不好解决，但是第二个缺点还是有办法改善的，那就是使用<a href="#2-时序差分学习temporal-difference-learning">时序差分学习</a>。</p><h2 id="2-时序差分学习（Temporal-Difference-Learning）"><a href="#2-时序差分学习（Temporal-Difference-Learning）" class="headerlink" title="2. 时序差分学习（Temporal Difference Learning）"></a>2. 时序差分学习（Temporal Difference Learning）</h2><p>时序差分学习的概念不是那么容易解释，但是可以通过更实际的例子来理解：</p><p>开始时模型预估开车从成都到北京需要花100个小时。</p><div id="flowchart-1" class="flow-chart"></div><p>实际开车从成都出发，实际花费了30个小时到西安，此时模型预估到北京还是60个小时。</p><div id="flowchart-2" class="flow-chart"></div><p>所以模型在开始时更准确的预估应该是：</p><p>30小时（成都到西安的<strong>实际时间</strong>）+ 60小时（新的<strong>预估时间</strong>）= 90小时</p><p>在时序差分学习中，这个更准确的估计就叫做 <strong>TD target</strong> 。有了这个更准确预估后，就知道开始时的预估时间是多了还是少了，从而就能更新模型的参数让模型的预估越来越准确。这样就能够做到不做完整件事就开始训练模型了。</p><p>而最初的预估时间和 <strong>TD target</strong> 的差值就是 <strong>TD error</strong>：</p><p><strong>TD error</strong> = 100小时(开始时的预估耗时） - 90小时（<strong>TD error</strong>） = 10小时</p><p>时序差分学习的目标就是让 <strong>TD error</strong> 的值接近0。</p><hr><blockquote><p>参考：<a href="https://www.youtube.com/watch?v=jflq6vNcZyA&amp;t=1344s&amp;ab_channel=ShusenWang">Value-Based Reinforcement Learning</a></p><p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">cd=&gt;start: 成都bj=&gt;end: 北京cd-&gt;bj</textarea><textarea id="flowchart-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><textarea id="flowchart-1-code" style="display: none">cd=&gt;start: 成都bj=&gt;end: 北京（模型预估需100小时）cd-&gt;bj</textarea><textarea id="flowchart-1-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-1", options);</script><textarea id="flowchart-2-code" style="display: none">cd=&gt;start: 成都xa=&gt;end: 西安（实际开车花费30小时）bj=&gt;end: 北京（模型预估还需60小时）cd-&gt;xa-&gt;bj</textarea><textarea id="flowchart-2-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-2-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-2-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-2", options);</script></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时序差分学习 </tag>
            
            <tag> 蒙特卡洛方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解强化学习中的基本概念</title>
      <link href="li-jie-qiang-hua-xue-xi-zhong-de-ji-ben-gai-nian/"/>
      <url>li-jie-qiang-hua-xue-xi-zhong-de-ji-ben-gai-nian/</url>
      
        <content type="html"><![CDATA[<h2 id="一、随机变量"><a href="#一、随机变量" class="headerlink" title="一、随机变量"></a>一、随机变量</h2><p>变量的值无法预先确定仅以一定的可能性（概率）取值的量。</p><p>强化学习中一般用大写的字母表示随机变量，用小写的字母表示随机变量的观测值（确定的值）。</p><blockquote><p>比如：掷骰子中，用大写的变量 $X$ 表示可能掷出来骰子的值。假如掷一次骰子，得到它的值是2点，可以用小写的变量 $x$ 来表示，即 $x = 2$ 。</p></blockquote><p>随机变量分两种基本的类型：离散型随机变量和连续型随机变量。</p><blockquote><p>强化学习中训练不同类型的变量一般需要使用不同类型的算法，只有少部分算法同时支持两种类型的变量训练。<br>训练离散型随机变量使用的损失函数一般是交叉熵（Cross Entropy），而训练连续型随机变量使用的损失函数一般是均方误差（MSE, Mean Squared Error）。</p></blockquote><h2 id="二、概率密度函数（Probability-Density-Function，PDF）"><a href="#二、概率密度函数（Probability-Density-Function，PDF）" class="headerlink" title="二、概率密度函数（Probability Density Function，PDF）"></a>二、概率密度函数（Probability Density Function，PDF）</h2><p>描述随机变量的输出值，物理意义为随机变量在某个确定的取值点附近的可能性。</p><blockquote><p>比如：掷骰子的概率密度函数 $p(X) = \frac{1}{6}$ 。<br>强化学习中的策略 $\pi$ 就是一个概率密度函数。因为它输出的其实是各个动作的概率。</p></blockquote><p>因为概率的总和总是1，所以：</p><ol><li>对于离散型随机变量 $X$ 及其可能值的集合 $\mathcal{X}$ 有：<script type="math/tex; mode=display">\sum_{x \in \mathcal{X}} p(x) = 1</script></li><li>对于连续型随机变量 $X$ 及其可能值的域 $\mathcal{X}$ 有：<script type="math/tex; mode=display">\int_{\mathcal{X}} p(x) \mathrm{d}x = 1</script></li></ol><h2 id="三、期望"><a href="#三、期望" class="headerlink" title="三、期望"></a>三、期望</h2><p>随机变量值产生的概率乘以随机变量值的总和。期望反应了随机变量平均取值的大小。</p><ol><li>对于离散型随机变量 $X$ 及其可能值的集合 $\mathcal{X}$ ，其期望公式为：<script type="math/tex; mode=display">\mathbb{E}[f(X)] = \sum_{x \in \mathcal{X}} p(x) \cdot f(x)</script></li><li>对于连续型随机变量 $X$ 及其可能值的域 $\mathcal{X}$ ，其期望公式为：<script type="math/tex; mode=display">\mathbb{E}[f(X)] = \int_{x \in \mathcal{X}} p(x) \cdot f(x) \mathrm{d}x</script></li></ol><h2 id="四、强化学习模型"><a href="#四、强化学习模型" class="headerlink" title="四、强化学习模型"></a>四、强化学习模型</h2><p><img src="/images/理解强化学习中的基本概念/强化学习模型.jpg" alt="强化学习模型"></p><p>模型的构成：</p><ol><li><p>智能体（Agent）<br> 从环境中观测到状态（state）并执行某个动作（action）的对象。</p><blockquote><p>比如在马里奥游戏中，我们控制的马里奥角色就是智能体；在赛车游戏中，我们控制的赛车就是智能体。</p></blockquote><p> 与智能体紧密相关的概念是策略 $\pi$ 。 策略 $\pi$ 用来控制智能体，它的输入就是智能体观测到的状态，然后输出各个动作的概率。智能体执行的动作就是从这些动作概率中抽取出来的。策略 $\pi$ 其实就是一个概率密度函数，其数学定义为：</p><script type="math/tex; mode=display">\pi(a|s) = \mathbb{P}(A = a | S = s)</script></li><li><p>动作（Actios）<br> 与环境交互时可以采取的动作的集合。</p><blockquote><p>比如在马里奥游戏中，可以采取的动作有：向左走、向右走、向上跳。</p></blockquote></li><li><p>环境（Environment）<br> 智能体所处的环境。</p><blockquote><p>比如在马里奥游戏中，就是指马里奥当前所处在的游戏环境。</p></blockquote></li><li><p>状态（State）<br> 智能体对环境的观测。</p><blockquote><p>比如在马里奥游戏中，游戏当前的画面就可以认为是环境当前的状态。</p></blockquote><p> 当智能体执行动作后，环境会进入到一个新的状态，这个就是状态转移的概念。状态转移的过程是随机的。这个随机性来自于两个方面：</p><ul><li>智能体执行的动作是随机的。智能体由策略 $\pi$ 控制的，策略 $\pi$ 输出的是各个动作的概率。执行的动作是从这些动作概率中抽取出来的，所以说执行的动作是随机的。</li><li><p>环境本身的变化也是随机的。即使每次智能体执行的都是相同的动作，环境也会随机的变化。</p><blockquote><p>比如在马里奥游戏中，即使每次都让马里奥向前走，但是游戏里的怪物总是会随机的移动，所以最后环境的状态也是随机的。</p></blockquote><p>状态转移的随机性用数学表示为：</p><script type="math/tex; mode=display">p(s\prime | s,a) = \mathbb{P}(S\prime = s\prime | S = s, A = a)</script></li></ul></li><li><p>奖励（Reward）<br> 智能体在环境中执行动作后获得的奖励或惩罚。</p><blockquote><p>比如在马里奥游戏中，吃到一个金币，就有金币奖励。</p></blockquote></li></ol><blockquote><p>关于智能体对环境的观测的表述。用 state 时表示智能体能观察到环境的所有内部状态，用 observation 时表示智能体不能观察到环境的所有内部状态。比如玩围棋时用 state ，玩扑克牌时用 observation （因为你看不到别人手中的牌）。</p></blockquote><p>交互的流程：</p><ol><li>智能体从环境观测到状态 $s_t$ 。</li><li>智能体根据获取到的状态 $s_t$ 决定下一步采取动作 $a_t$ 。</li><li>环境执行动作 $a_t$ 后转移到新的状态 $s_{t+1}$ ，并给出智能体执行动作获得的奖励 $r_t$ 。</li><li>回到第1步。</li></ol><blockquote><p>第3步中获得的奖励 $r_t$ ，一些资料中也记为 $r_{t+1}$ 。比如：<a href="https://www.youtube.com/watch?v=lfHX2hHRMVQ&amp;list=PLqYmG7hTraZDM-OYHWgPebj2MfCFzFObQ&amp;index=2&amp;ab_channel=DeepMind">RL Course by David Silver - Lecture 2: Markov Decision Process</a> 。</p></blockquote><h2 id="五、回报（Return）"><a href="#五、回报（Return）" class="headerlink" title="五、回报（Return）"></a>五、回报（Return）</h2><p>强化学习的目的是让智能体与环境交互时获得的奖励尽可能的多。</p><p>智能体从 $t$ 时刻开始到游戏结束获得的所有奖励 <strong>回报（Return，Cumulative Future Reward）</strong> 为：</p><script type="math/tex; mode=display">G_t = R_t + R_{t+1} + R_{t+2} + R_{t+3} + \cdots</script><p>考虑到未来的奖励不如现在的奖励有价值，我们给未来的奖励加一个折扣系数 $\gamma$ ，且 $\gamma \in [0, 1]$ 。</p><p>所以智能体从 $t$ 时刻开始到游戏结束获得的所有奖励 <strong>折扣回报（Discounted Return，Cumulative Discounted Future Reward）</strong> 为：</p><script type="math/tex; mode=display">G_t = R_t + \gamma \cdot R_{t+1} + \gamma^2 \cdot R_{t+2} + \gamma^3 \cdot R_{t+3} + \cdots</script><p>根据<a href="https://kibazen.cn/ma-er-ke-fu-he-bei-er-man-gong-shi-yi-ji-sheng-cheng-mo-shi/">马尔科夫回报过程</a>我们可以知道，折扣回报也是一个随机变量，原因如下：</p><ol><li>智能体采取的动作是一个随机变量：<script type="math/tex; mode=display">\mathbb{P}[A=a | S=s] = \pi(a|s)</script></li><li>环境状态的转移也是随机的：<script type="math/tex; mode=display">\mathbb{P}[S\prime = s\prime | S = s, A=a] = p(s\prime | s, a)</script></li></ol><p>而对于未来的任意时刻 $i \ge t$ ，奖励 $R_i$ 都依赖 $S_i$ 和 $A_i$ 。</p><blockquote><p>比如在马里奥游戏中，如果马里奥头上有一个金币，这个时候向上跳就能获得金币奖励，但是如果这时不向上跳或者向上跳时头上没有金币都不能获得金币奖励。</p></blockquote><p>所以，对某一个时刻 $t$ 的状态 $s_t$ 来说，折扣奖励 $G_t$ 依赖于未来所有的随机动作 $A_t, A_{t+1}, A_{t+2}, \cdots$ 和随机状态 $S_{t+1}, S_{t+2}, \cdots$ 。</p><p>折扣奖励 $G_t$ 定义了未来获取奖励的总和，机器学习的目的就是控制 agent 让 $G_t$ 的值越大越好。</p><h2 id="六、动作价值函数（Action-Value-Function）"><a href="#六、动作价值函数（Action-Value-Function）" class="headerlink" title="六、动作价值函数（Action-Value Function）"></a>六、动作价值函数（Action-Value Function）</h2><p>由于 $G_t$ 是随机变量，在 $t$ 时刻并不能计算出 $G_t$ 的值。但是为了便于评估 $t$ 时刻的形势，消除 $G_t$ 中的随机性，可以对 $G_t$ 求期望，将随机性都用积分积掉，可以得到一个实数。即：</p><script type="math/tex; mode=display">Q_{\pi}(s_t,a_t) = \mathbb{E}[G_t | S_t=s_t, A_t=a_t]</script><p>求期望得到的函数 $Q_{\pi}(s_t,a_t)$ 被称为动作价值函数。</p><p>把 $G_t$ 当做未来所有动作 $A$ 和所有状态 $S$ 的函数，除了 $a_t$ 和 $s_t$ ，其余的都用积分积掉。被积分积掉的变量包括 $A_{t+1}, A_{t+2}, \cdots$ 和 $S_{t+1}, S_{t+2}, \cdots$。</p><ol><li>动作的概率密度函数为：<script type="math/tex; mode=display">\mathbb{P}[A=a | S=s] = \pi(a|s)</script></li><li>状态转移的概率密度函数为：<script type="math/tex; mode=display">\mathbb{P}[S\prime = s\prime | S = s, A=a] = p(s\prime | s, a)</script></li></ol><p>函数 $Q_{\pi}(s_t,a_t)$ 和当前的状态 $s_t$ 和动作 $a_t$ 有关。 $a_t$ 和 $s_t$ 当作被观测到的值来处理，而不是随机变量。函数 $Q_{\pi}(s_t,a_t)$ 还有策略 $\pi$ 有关，因为积分时会用到策略 $\pi$ 。</p><p>动作价值函数的意义在于可以评估策略 $\pi$ 在状态 $s_t$ 时采取动作 $a_t$ 的期望回报。即，策略 $\pi$ 处在状态 $s_t$ 时，动作价值函数 $Q_{\pi}(s_t,a_t)$ 可以给动作 $a_t$ 打分，用来判断执行动作 $a$ 是否明智。</p><blockquote><p>就相当于你在打牌时有一个先知可以告诉你这次（仅一次）出每种牌后你赢钱的期望。</p></blockquote><h2 id="七、最优动作价值函数（Optimal-Action-Value-Function）"><a href="#七、最优动作价值函数（Optimal-Action-Value-Function）" class="headerlink" title="七、最优动作价值函数（Optimal Action-Value Function）"></a>七、最优动作价值函数（Optimal Action-Value Function）</h2><p>对函数 $Q_{\pi}(s_t,a_t)$ 做关于策略 $\pi$ 的最大化操作，就可以得到最优动作价值函数：</p><script type="math/tex; mode=display">Q_*(s_t,a_t) = \max_{\pi} Q_{\pi}(s_t,a_t)</script><blockquote><p><script type="math/tex">Q_*(s_t,a_t)</script> 是 <script type="math/tex">Q_{\pi_*}(s_t,a_t)</script> 的简写。</p></blockquote><p>最大化操作就是选取无数种策略中，让 $Q_{\pi}(s_t,a_t)$ 的值最大的那个策略 $\pi_*$ 。最优动作价值函数与策略 $\pi$ 无关，因为 $\pi$ 已经被最大化操作消除了。</p><p>最优动作价值函数的意义在于可以评估在状态 $s_t$ 时采取动作 $a_t$ 后最大能获得的期望回报。</p><blockquote><p>就相当于在打牌时有一把牌让世界上牌技最好的人来玩时出每种牌后赢钱的期望。</p></blockquote><h2 id="八、状态价值函数（State-Value-Function）"><a href="#八、状态价值函数（State-Value-Function）" class="headerlink" title="八、状态价值函数（State-Value Function）"></a>八、状态价值函数（State-Value Function）</h2><p>状态价值函数是动作价值函数关于动作的期望。</p><p>将动作 $A$ 视为随机变量，然后对动作价值函数 $Q_{\pi}(s_t,A)$ 关于动作 $A$ 求期望就可以得到状态价值函数：</p><script type="math/tex; mode=display">V_{\pi}(s_t) = \mathbb{E}_{A \sim \pi(\cdot | s_t)} [Q_{\pi}(s_t,A)]</script><p>状态价值函数 $V_{\pi}(s_t)$ 只与策略 $\pi$ 和状态 $s_t$ 有关。</p><p>状态价值函数可以反映策略 $\pi$ 处于状态 $s_t$ 时的优劣势。</p><blockquote><p>比如下围棋时，状态价值函数可以反映出当前的局面是快赢了还是快输了等。</p></blockquote><ol><li>如果动作是离散型随机变量，则：<script type="math/tex; mode=display">V_{\pi}(s_t) = \mathbb{E}_A[Q_{\pi}(s_t, A)] = \sum_a \pi(a | s_t) \cdot Q_{\pi}(s_t, a)</script></li><li>如果动作是连续型随机变量，则：<script type="math/tex; mode=display">V_{\pi}(s_t) = \mathbb{E}_A[Q_{\pi}(s_t, A)] = \int \pi(a | s_t) \cdot Q_{\pi}(s_t, a) \mathrm{d}x</script></li></ol><p>状态价值函数的意义在于可以评估策略 $\pi$ 处在状态 $s_t$ 时的期望回报。</p><blockquote><p>就相当于你在打牌时，你拿了一把牌，有一个先知可以告诉你你玩这把牌赢钱的期望。</p></blockquote><h2 id="九、最优状态价值函数（Optimal-State-Value-Function）"><a href="#九、最优状态价值函数（Optimal-State-Value-Function）" class="headerlink" title="九、最优状态价值函数（Optimal State-Value Function）"></a>九、最优状态价值函数（Optimal State-Value Function）</h2><p>对状态价值函数 $V_{\pi}(s_t)$ 做关于策略 $\pi$ 的最大化操作，就可以得到最优状态价值函数：</p><script type="math/tex; mode=display">V_*(s_t) = \max_{\pi} V_{\pi}(s_t)</script><blockquote><p><script type="math/tex">V_*(s_t)</script> 是 <script type="math/tex">V_{\pi_*}(s_t)</script> 的简写。</p></blockquote><p>最大化操作就是选取无数种策略中，让 $V_{\pi}(s_t)$ 的值最大的那个策略 $\pi_*$ 。最优状态价值函数与策略 $\pi$ 无关，因为 $\pi$ 已经被最大化操作消除了。</p><p>最优状态价值函数的意义在于可以评估在状态 $s_t$ 时最大能获得的期望回报。</p><blockquote><p>就相当于在打牌时有一把牌让世界上牌技最好的人来玩时赢钱的期望。</p></blockquote><h2 id="十、用强化学习玩游戏"><a href="#十、用强化学习玩游戏" class="headerlink" title="十、用强化学习玩游戏"></a>十、用强化学习玩游戏</h2><p>强化学习的目的就是学会如何控制智能体 ，让智能体基于当前的状态 $s$ 来做出相应的动作 $a$ ，争取能在未来获取尽量多的奖励。</p><p>强化学习通常要学习的是策略 $\pi(a|s)$ 或者最优动作价值函数 $Q_*(s, a)$，当有了这两个中的一个，就可以控制智能体自动的玩游戏了。</p><h3 id="10-1-假如有一个好的策略"><a href="#10-1-假如有一个好的策略" class="headerlink" title="10.1 假如有一个好的策略"></a>10.1 假如有一个好的策略</h3><ol><li>输入观测到的状态 $s_t$ 给策略 $\pi(a|s)$ ，它会返回不同动作的概率。</li><li>根据策略 $\pi(a|s)$ 返回的这些概率采样得到一个动作 $a_t$。</li><li>让环境执行动作 $a_t$ ，得到新的状态 $s_{t+1}$和奖励 $r_t$。</li><li>回到第1步。</li></ol><blockquote><p>好的策略相当于一个牌技好的人，牌技好的人赢钱的期望总是高。</p></blockquote><p>所以我们直接训练出一个好的策略就可以了。</p><p>这种直接训练策略的方式就是强化学习中的 <strong>基于策略的学习（Policy Based Learning）</strong> 。</p><h3 id="10-2-假如有最优动作价值函数"><a href="#10-2-假如有最优动作价值函数" class="headerlink" title="10.2 假如有最优动作价值函数"></a>10.2 假如有最优动作价值函数</h3><ol><li>根据观测到的状态 $s_t$ 和最优动作价值函数 $Q_*(s_t,a_t)$ 计算出能够获得最大期望奖励的动作<script type="math/tex; mode=display">a_t = \underset{a \in A}{\operatorname{argmax}} \; Q_*(s_t,a)</script></li><li>让环境执行动作 $a_t$ ，得到新的状态 $s_{t+1}$ 和奖励 $r_t$。</li><li>回到第1步。</li></ol><blockquote><p>最优动作价值函数 $Q_*(s_t,a_t)$ 相当于一个先知，可以告诉我们出每种牌赢钱的期望，只要我们每次都出赢钱期望最大的牌，那么最后赢钱的期望就会最高。</p></blockquote><p>所以我们也可以训练出一个先知，即最优动作价值函数。</p><p>这种训练最优动作价值函数的方式就是强化学习中的 <strong>基于价值的学习（Value Based Learning）</strong> 。</p><h2 id="十一、熵"><a href="#十一、熵" class="headerlink" title="十一、熵"></a>十一、熵</h2><h3 id="11-1-自信息"><a href="#11-1-自信息" class="headerlink" title="11.1 自信息"></a>11.1 自信息</h3><p><a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E4%BF%A1%E6%81%AF">自信息（self-information）</a> 表示一个随机事件所包含的信息量。</p><blockquote><p>一个随机事件发生的概率越高，其自信息越低。如果一个事件必然发生，其自信息为 0。</p></blockquote><p>对随机变量 $X$ ，其概率分布为 $P(x)$ ，当 $X = x$ 时，自信息 $I(x)$ 定义为：</p><script type="math/tex; mode=display">I(x) = - log P(x)</script><h3 id="11-2-信息熵"><a href="#11-2-信息熵" class="headerlink" title="11.2 信息熵"></a>11.2 信息熵</h3><p>对于分布为 $P(x)$ 的随机变量 $X$ ，其熵（entropy）（<strong>自信息的期望</strong>）定义为：</p><script type="math/tex; mode=display">H(P) = E_X [I(x)] = E_X[- log P(x)] = - \sum_x P(x) log P(x)</script><p>信息论的基本定理之一指出，为了对从分布 $P$ 中随机抽取的数据进行编码，至少需要 $H[P]$ “纳特（nat）”对其进行编码。“纳特”相当于位，当时对数底为 $e$ 而不是 2，。因此，一个纳特是 $\frac{1}{log(2)} \approx 1.44$ 位。</p><p>信息熵表达随机变量所需的平均信息量。即 <strong>从不了解到了解一件事所需要的最小信息量。</strong></p><h3 id="11-3-交叉熵"><a href="#11-3-交叉熵" class="headerlink" title="11.3 交叉熵"></a>11.3 交叉熵</h3><p>对于分布为 $P(x)$ 的随机变量，熵 $H(P)$ 表示其最优编码长度。交叉熵是按照概率分布 $Q$ 的最优编码对真实分布 $P$ 的信息进行编码的长度（用 $Q$ 表示 $P$），定义如下：</p><script type="math/tex; mode=display">H(P,Q) = E_P[- log Q(x)] = - \sum_x P(x) log Q(x)</script><p>交叉熵是一种分布描述另一种分布所需要的信息量。</p><h3 id="11-4-KL-散度"><a href="#11-4-KL-散度" class="headerlink" title="11.4 KL 散度"></a>11.4 KL 散度</h3><p>KL 散度也叫 <strong>KL 距离</strong> 或者 <strong>相对熵</strong>，是用概率分布 $Q$ 来近似 $P$ 时所造成的信息损失量。</p><p>KL 散度是按照概率分布 $Q$ 的最优编码对真实分布 $P$ 的信息进行编码，其平均编码长度（<strong>交叉熵</strong>）$H(P,Q)$ 和 $P$ 的最优编码长度（<strong>熵</strong>） $H(P)$ 之间的差异。</p><p>对于离散概率分布 $P$ 和 $Q$ ，从 $Q$ 到 $P$ 的 KL 散度定义为：</p><script type="math/tex; mode=display">KL(P,Q) = H(P,Q) - H(P) = \sum_x P(x) log \frac{P(x)}{Q(x)}</script><p>KL 散度 总是非负的，即 $KL(P,Q) \ge 0$ ，可以衡量两个概率分布之间的距离。只有当 $Q = P$ 时， $KL(P,Q) = 0$ 。</p><script type="math/tex; mode=display">KL 散度 = 交叉熵 - 信息熵</script><h2 id="十二、极大似然估计"><a href="#十二、极大似然估计" class="headerlink" title="十二、极大似然估计"></a>十二、极大似然估计</h2><p>极大似然估计，通俗理解来说，就是利用已知的样本结果信息，反推最具有可能（最大概率）导致这些样本结果出现的模型参数值。</p><h2 id="十三、卷积神经网络"><a href="#十三、卷积神经网络" class="headerlink" title="十三、卷积神经网络"></a>十三、卷积神经网络</h2><h3 id="13-1-卷入神经网络的输出形状"><a href="#13-1-卷入神经网络的输出形状" class="headerlink" title="13.1 卷入神经网络的输出形状"></a>13.1 卷入神经网络的输出形状</h3><p>若</p><ul><li>输入形状为 $n_h \times n_w$</li><li>卷积核形状为 $k_h\times k_w$</li><li>上下各填充 $p_h$ 行，左右各填充 $p_w$ 列</li><li>垂直步幅 $s_h$ ，水平步幅 $s_w$</li></ul><p>则输出形状为</p><script type="math/tex; mode=display">\left\lfloor\frac{n_h  + 2 \times p_h - k_h}{s_h} + 1\right\rfloor \times \left\lfloor\frac{n_w  + 2 \times p_w - k_w}{s_w} + 1\right\rfloor</script><blockquote><p><a href="https://pytorch.org/docs/stable/generated/torch.nn.Conv2d.html">torch.nn.Conv2d</a></p></blockquote><h2 id="十四、区分-Model-free-和-Model-based"><a href="#十四、区分-Model-free-和-Model-based" class="headerlink" title="十四、区分 Model-free 和 Model-based"></a>十四、区分 Model-free 和 Model-based</h2><p><a href="https://www.quora.com/What-is-the-difference-between-model-based-and-model-free-reinforcement-learning">What is the difference between model-based and model-free reinforcement learning?</a></p><p>区分某个强化学习算法是 model-based 还是 model-free 的：在 agent 执行它的动作之前，它是否能对下一步的状态和回报做出预测，如果可以，那么就是 model-based 方法，如果不能，即为 model-free 方法。</p><h2 id="十五、参考"><a href="#十五、参考" class="headerlink" title="十五、参考"></a>十五、参考</h2><ol><li><a href="https://www.youtube.com/watch?v=vmkRMvhCW5c&amp;list=PLvOO0btloRnsiqM72G4Uid0UWljikENlU&amp;ab_channel=ShusenWang">Deep Reinforcement Learning</a></li><li><a href="https://blog.csdn.net/AIHUBEI/article/details/104720246">自信息、熵、联合熵、条件熵、互信息、交叉熵、KL散度</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随机变量 </tag>
            
            <tag> 概率密度函数 </tag>
            
            <tag> 强化学习模型 </tag>
            
            <tag> 动作价值函数 </tag>
            
            <tag> 状态价值函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>马尔可夫和贝尔曼公式以及生成模式</title>
      <link href="ma-er-ke-fu-he-bei-er-man-gong-shi-yi-ji-sheng-cheng-mo-shi/"/>
      <url>ma-er-ke-fu-he-bei-er-man-gong-shi-yi-ji-sheng-cheng-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、马尔可夫"><a href="#一、马尔可夫" class="headerlink" title="一、马尔可夫"></a>一、马尔可夫</h2><p>环境的状态必须是全部能够获取的（fully observable），即环境的 <strong>observation</strong> 就是 <strong>state</strong>。</p><h3 id="1-马尔可夫性（Markov-Property）"><a href="#1-马尔可夫性（Markov-Property）" class="headerlink" title="1. 马尔可夫性（Markov Property）"></a>1. 马尔可夫性（Markov Property）</h3><p>环境的下一个状态只由当前的的状态决定，与过去无关。</p><script type="math/tex; mode=display">\mathbb{P}[S_{t+1}|S_t] = \mathbb{P}[S_{t+1} | S_1, \ldots, S_t]</script><p>比如下棋，只用关心当前的局面，不用管过去操作。</p><h3 id="2-状态转移矩阵（State-Transition-matrix）"><a href="#2-状态转移矩阵（State-Transition-matrix）" class="headerlink" title="2. 状态转移矩阵（State Transition matrix）"></a>2. 状态转移矩阵（State Transition matrix）</h3><p>环境从一个状态转化成另一个状态的概率组成的矩阵。</p><script type="math/tex; mode=display">P_{ss\prime} = \mathbb{P}[S_{t+1}=s\prime | S_t=s] \tag{2}</script><p><strong>公式2</strong> 表示马尔可夫状态 $s$ 转移到其后继状态 $s\prime$ 的概率为 $P_{ss\prime}$，而状态转移矩阵则表示对于所有状态转移到其所有后继状态的概率，如下：</p><script type="math/tex; mode=display">P =\left[\begin{matrix}P_{11} & \cdots & P_{1n} \\\vdots & \ddots & \vdots \\P_{n1} & \cdots & P_{nn} \\\end{matrix}\right]</script><blockquote><p>$P$ 中任意行的值的和为1。</p></blockquote><h3 id="3-马尔可夫过程（Markov-Process-MP）"><a href="#3-马尔可夫过程（Markov-Process-MP）" class="headerlink" title="3. 马尔可夫过程（Markov Process, MP）"></a>3. 马尔可夫过程（Markov Process, MP）</h3><p>若环境状态变化的过程满足马尔可夫性，则称为马尔可夫过程。马尔可夫过程（或者马尔可夫链）由一个二元组 $\lt S, P \gt$ 定义。其中：</p><ul><li>$S$ 表示环境所有可能状态的有限集合</li><li>$P$ 表示这些状态之间转移概率的矩阵 <script type="math/tex">P_{ss\prime} = \mathbb{P}[S_{t+1}=s\prime | S_t=s]</script></li></ul><h3 id="4-马尔可夫链（Markov-Chain）"><a href="#4-马尔可夫链（Markov-Chain）" class="headerlink" title="4. 马尔可夫链（Markov Chain）"></a>4. 马尔可夫链（Markov Chain）</h3><p>马尔可夫过程下产生的有限状态的集合。</p><h3 id="5-马尔科夫回报过程（Markov-Reward-Process-MRP）"><a href="#5-马尔科夫回报过程（Markov-Reward-Process-MRP）" class="headerlink" title="5. 马尔科夫回报过程（Markov Reward Process, MRP）"></a>5. 马尔科夫回报过程（Markov Reward Process, MRP）</h3><p>包含 <strong>价值（values）</strong> 的马尔可夫链就是马尔科夫回报过程，由一个四元组 $\lt S, P, R, \gamma \gt$ 定义。其中：</p><ul><li>$S$ 表示环境所有可能状态的有限集合</li><li>$P$ 表示这些状态之间转移概率的矩阵 <script type="math/tex">P_{ss\prime} = \mathbb{P}[S_{t+1}=s\prime | S_t=s]</script></li><li><strong>$R$ 表示回报计算函数 <script type="math/tex">R_s = \mathbb{E}[R_{t+1} | S_t=s]</script></strong></li><li><strong>$\gamma$ 衰减系数（Discount factor），$\gamma \in [0, 1]$</strong></li></ul><h4 id="5-1-回报（Return）"><a href="#5-1-回报（Return）" class="headerlink" title="5.1 回报（Return）"></a>5.1 回报（Return）</h4><p>从时刻 $t$ 开始所有的折扣回报之和</p><script type="math/tex; mode=display">G_t = R_{t+1} + \gamma R_{t+2} + \cdots = \sum_{k=0} ^{\infty} \gamma^k R_{t+k+1}</script><h4 id="5-2-衰减系数（Discount-factor）"><a href="#5-2-衰减系数（Discount-factor）" class="headerlink" title="5.2 衰减系数（Discount factor）"></a>5.2 衰减系数（Discount factor）</h4><p>存在的原因：</p><ul><li>数学表达更方便</li><li>避免陷入循环</li><li>长远的利益具有不确定性</li></ul><p>意义：</p><ul><li>值越接近0表示越看重当前的利益</li><li>值越接近1表示越看重长远的利益</li></ul><h3 id="5-3-状态价值函数（Value-Function）"><a href="#5-3-状态价值函数（Value-Function）" class="headerlink" title="5.3 状态价值函数（Value Function）"></a>5.3 状态价值函数（Value Function）</h3><p>状态价值函数用于计算从状态 $s$ 开始的期望回报</p><script type="math/tex; mode=display">v(s) = \mathbb{E}[G_t | S_t=s]</script><h3 id="5-4-贝尔曼方程（Bellman-Equation）"><a href="#5-4-贝尔曼方程（Bellman-Equation）" class="headerlink" title="5.4 贝尔曼方程（Bellman Equation）"></a>5.4 贝尔曼方程（Bellman Equation）</h3><script type="math/tex; mode=display">\begin{aligned}v(s)& = \mathbb{E}[G_t | S_t = s] \\& = \mathbb{E}[R_{t+1} + \gamma R_{t+2} + {\gamma}^2 R_{t+3} + \cdots | S_t = s] \\& = \mathbb{E}[R_{t+1} + \gamma(R_{t+2} + \gamma R_{t+3} + \cdots) | S_t = s] \\& = \mathbb{E}[R_{t+1} + \gamma G_{t+1} | S_t = s] \\& (注意 v(S_{t+1}) 是大写的 S_{t+1} 是因为 S_t = s 的下一个状态是随机的) \\& = \mathbb{E}[R_{t+1} + \gamma v(S_{t+1}) | S_t = s] \\& (分别对 R_{t+1} 和 v(S_{t+1}) 求期望，和的期望等于期望的和) \\& = \mathbb{E}[R_{t+1} | S_t = s] + \gamma \mathbb{E}[v(S_{t+1}) | S_t = s] \\& (如果已知状态转移矩阵 P ，则可以将上式展开) \\& = R_s + \gamma \sum_{s\prime \in S} P_{ss\prime} v(s\prime) \\\end{aligned}</script><p>即：</p><script type="math/tex; mode=display">v(s) = R_s + \gamma \sum_{s\prime \in S} P_{ss\prime} v(s\prime)</script><p>对应的矩阵形式的方程为：</p><script type="math/tex; mode=display">v = R + \gamma Pv</script><script type="math/tex; mode=display">\left[\begin{matrix}v(1) \\\vdots \\v(n) \\\end{matrix}\right] = \left[\begin{matrix}R_{1} \\\vdots \\R_{n} \\\end{matrix}\right] + \gamma \left[\begin{matrix}P_{11} & \cdots & P_{1n} \\\vdots & \ddots & \vdots \\P_{n1} & \cdots & P_{nn} \\\end{matrix}\right] \left[\begin{matrix}v(1) \\\vdots \\v(n) \\\end{matrix}\right]</script><blockquote><p>其中 $R_{t+1}$ 是立即回报， $\gamma v(S_{t+1})$ 是后续状态的折扣值函数</p></blockquote><h3 id="5-5-贝尔曼方程的求解方法"><a href="#5-5-贝尔曼方程的求解方法" class="headerlink" title="5.5 贝尔曼方程的求解方法"></a>5.5 贝尔曼方程的求解方法</h3><ol><li><p>直接求解</p><script type="math/tex; mode=display"> \begin{aligned} v &= R + \gamma Pv \\ (I - \gamma P)v &= R \\ v &= (I - \gamma P)^{-1} R \\ \end{aligned}</script><p> 问题：复杂度太高 $O(n^3)$，n为状态的数量</p></li><li><p>迭代求解</p><ul><li>动态规划（Dynamic programming）</li><li>蒙地卡罗评估（Monte-Carlo evaluation）</li><li>时序差分学习（Temporal-Difference learning）</li></ul></li></ol><h3 id="6-马尔科夫决策过程（Markov-Decision-Process-MDP）"><a href="#6-马尔科夫决策过程（Markov-Decision-Process-MDP）" class="headerlink" title="6. 马尔科夫决策过程（Markov Decision Process, MDP）"></a>6. 马尔科夫决策过程（Markov Decision Process, MDP）</h3><p>包含 <strong>决策（decisions）</strong> 的马尔科夫回报过程就是马尔科夫决策过程，由一个五元组 $\lt S, A, P, R, \gamma \gt$ 定义。其中：</p><ul><li>$S$ 表示环境所有可能状态的有限集合</li><li><strong>$A$ 表示有限的动作集合</strong></li><li><strong>$P$ 表示这些状态之间转移概率的矩阵 <script type="math/tex">P_{ss\prime}^a = \mathbb{P}[S_{t+1}=s\prime | S_t=s, A_t=a]</script></strong></li><li><strong>$R$ 表示回报计算函数 <script type="math/tex">R_s^a = \mathbb{E}[R_{t+1} | S_t=s, A_t=a]</script></strong></li><li>$\gamma$ 衰减系数（Discount factor），$\gamma \in [0, 1]$</li></ul><h4 id="6-1-策略（Policy）"><a href="#6-1-策略（Policy）" class="headerlink" title="6.1 策略（Policy）"></a>6.1 策略（Policy）</h4><p>策略 $\pi$ 是状态 $s$ 时可能执行的动作 $a$ 的概率分布</p><script type="math/tex; mode=display">\pi (a|s) = \mathbb{P}[A_t=a | S_t=s]</script><p>当给定马尔科夫决策过程 $\lt S,A,P,R,\gamma \gt$ 和策略 $\pi$ 时：</p><ul><li>状态序列 $S_1, S_2, \ldots$ 就是一个马尔可夫过程 $\lt S,P^{\pi} \gt$</li><li>状态回报序列 $S_1, R_2, S_2, \ldots$ 就是一个马尔科夫回报过程 $\lt S, P^{\pi}, R^{\pi}, \gamma \gt$</li></ul><p>其中：</p><script type="math/tex; mode=display">P_{s,s\prime}^{\pi} = \sum_{a \in A}\pi(a|s) P_{s,s\prime}^a</script><script type="math/tex; mode=display">R_s^{\pi} = \sum_{a \in A}\pi(a|s) R_s^a</script><h4 id="6-2-基于策略的状态价值函数"><a href="#6-2-基于策略的状态价值函数" class="headerlink" title="6.2 基于策略的状态价值函数"></a>6.2 基于策略的状态价值函数</h4><p>马尔科夫决策过程中，基于策略 $\pi$ 的 <strong>状态</strong> 价值函数用于计算从状态 $s$ 开始，遵循策略 $\pi$ 时的期望回报</p><script type="math/tex; mode=display">v_{\pi}(s) = \mathbb{E}[G_t | S_t=s]</script><h4 id="6-3-基于策略的动作价值函数"><a href="#6-3-基于策略的动作价值函数" class="headerlink" title="6.3 基于策略的动作价值函数"></a>6.3 基于策略的动作价值函数</h4><p>马尔科夫决策过程中，基于策略 $\pi$ 的 <strong>动作</strong> 价值函数用于计算从状态 $s$ 开始，先采取动作 $a$，再遵循策略 $\pi$ 时的期望回报</p><script type="math/tex; mode=display">q_{\pi}(s,a) = \mathbb{E}_{\pi}[G_t | S_t=s, A_t=a]</script><h4 id="6-4-贝尔曼期望方程（Bellman-Expectation-Equation）"><a href="#6-4-贝尔曼期望方程（Bellman-Expectation-Equation）" class="headerlink" title="6.4 贝尔曼期望方程（Bellman Expectation Equation）"></a>6.4 贝尔曼期望方程（Bellman Expectation Equation）</h4><ol><li><p>基于策略的 <strong>状态</strong> 价值函数的贝尔曼方程可以分解为 <strong>立即回报</strong> 与 <strong>后续状态的折扣回报</strong> 的和</p><script type="math/tex; mode=display">v_{\pi}(s) = \mathbb{E}[R_{t+1} + \gamma v_{\pi}(S_{t+1}) | S_t=s]</script><p> 对应的矩阵形式的方程为：</p><script type="math/tex; mode=display">v_{\pi} = R^{\pi} + \gamma P^{\pi} v_{\pi}</script><script type="math/tex; mode=display">v_{\pi} = (I - \gamma P^{\pi})^{-1} R^{\pi}</script><p> 同时，状态 $s$ 的价值也可以通过计算在遵循策略 $\pi$ 时采取所有可能 <strong>动作的价值</strong> 与对应 <strong>动作发生的概率</strong> 乘积的和来获得，即：</p><script type="math/tex; mode=display">v_{\pi}(s) = \sum_{a \in A}\pi(a|s) q_{\pi}(s,a) \tag{6.4.1}</script></li><li><p>基于策略的 <strong>动作</strong> 价值函数的贝尔曼方程也是类似的</p><script type="math/tex; mode=display">q_{\pi}(s,a) = \mathbb{E}[R_{t+1} + \gamma q_{\pi}(S_{t+1},A_{t+1}) | S_t=s, A_t=a]</script><p> 类似的，状态 $s$ 下执行动作 $a$ 的价值也可以分解为 <strong>离开状态 $s$ 的立即回报</strong> 与 <strong>所有可能会进入状态的价值与对应进入概率</strong> 的乘积的和，即：</p><script type="math/tex; mode=display">q_{\pi}(s,a) = R_s^a + \gamma \sum_{s\prime \in S} P_{ss\prime}^a v_{\pi}(s\prime) \tag{6.4.2}</script></li><li><p>组合上面的 <strong>方程6.4.1</strong> 和 <strong>方程6.4.2</strong> ，可以得到</p><script type="math/tex; mode=display">v_{\pi}(s) = \sum_{a \in A}\pi(a|s) \left( R_s^a + \gamma \sum_{s\prime \in S} P_{ss\prime}^a v_{\pi}(s\prime) \right)</script><script type="math/tex; mode=display">q_{\pi}(s,a) = R_s^a + \gamma \sum_{s\prime \in S} P_{ss\prime}^a \sum_{a\prime \in A}\pi(a\prime|s\prime) q_{\pi}(s\prime,a\prime)</script></li></ol><h4 id="6-5-最优价值函数（Optimal-Value-Function）"><a href="#6-5-最优价值函数（Optimal-Value-Function）" class="headerlink" title="6.5 最优价值函数（Optimal Value Function）"></a>6.5 最优价值函数（Optimal Value Function）</h4><ol><li><p><strong>最优状态价值函数（Optimal State-Value Function）</strong> 就是从所有可能的策略中，<strong>选取</strong> 产生最大状态价值函数值的 <strong>策略的函数</strong></p><script type="math/tex; mode=display">v_*(s) = \max_{\pi} v_{\pi}(s) \tag{6.5.1}</script><blockquote><p><script type="math/tex">v_*(s)</script> 是 <script type="math/tex">v_{\pi_*}(s)</script> 的简写，都可以表示最优状态价值函数。</p></blockquote></li><li><p><strong>最优动作价值函数（Optimal Action-Value Function）</strong> 就是从所有可能的策略中，<strong>选取</strong> 产生最大动作状态价值函数值的 <strong>策略的函数</strong></p><script type="math/tex; mode=display">q_*(s,a) = \max_{\pi} q_{\pi}(s,a) \tag{6.5.2}</script><blockquote><p><script type="math/tex">q_*(s,a)</script> 是 <script type="math/tex">q_{\pi_*}(s,a)</script> 的简写，都可以表示最优动作价值函数。</p></blockquote></li><li><p>最优价值函数能够在马尔科夫决策过程中找到最好的策略。所以，如果我们找到了最优价值函数，那么我们就可以解决马尔科夫决策问题</p></li></ol><h4 id="6-6-最优策略（Optimal-Policy）"><a href="#6-6-最优策略（Optimal-Policy）" class="headerlink" title="6.6 最优策略（Optimal Policy）"></a>6.6 最优策略（Optimal Policy）</h4><ol><li><p>对于任意可能的状态，如果遵循一个策略的价值总是不差于遵循另一个策略，那么前一个策略就要优于后一个策略</p><script type="math/tex; mode=display">\pi \ge \pi\prime \quad if \; v_{\pi}(s) \ge v_{\pi\prime}(s), \forall{s}</script></li><li><p>定理：对任意马尔科夫决策过程，有：</p></li></ol><ul><li><p>存在一个最优策略 ${\pi}_*$ 不差于其他任何策略</p><script type="math/tex; mode=display">{\pi}_* \ge \pi, \forall{\pi}</script></li><li><p>所有的最优策略有相同的最优状态价值函数</p><script type="math/tex; mode=display">v_{\pi_*}(s) = v_*(s) \tag{6.6.2a}</script></li><li><p>所有的最优策略具有相同的最优动作价值函数</p><script type="math/tex; mode=display">q_{\pi_*}(s,a) = q_*(s,a) \tag{6.6.2b}</script></li></ul><h4 id="6-7-寻找最优策略"><a href="#6-7-寻找最优策略" class="headerlink" title="6.7 寻找最优策略"></a>6.7 寻找最优策略</h4><p>可以通过最大化最优动作价值函数 $q_*(s,a)$ 来找到最优策略</p><script type="math/tex; mode=display">\pi_*(a|s) =\begin{cases}    1 & if \; a = \underset{a \in A}{\operatorname{argmax}} \; q_*(s,a) \\    0 & otherwise \\\end{cases}\tag{6.7}</script><ul><li>对任意马尔科夫决策过程，总存在一个确定性的最优策略</li><li>如果我们知道最优动作价值函数 $q_*(s,a)$ ，则表明我们找到了最优策略</li></ul><h4 id="6-8-贝尔曼最优方程（Bellman-Optimality-Equation）"><a href="#6-8-贝尔曼最优方程（Bellman-Optimality-Equation）" class="headerlink" title="6.8 贝尔曼最优方程（Bellman Optimality Equation）"></a>6.8 贝尔曼最优方程（Bellman Optimality Equation）</h4><ol><li><p>一个状态的最优价值等于从该状态出发采取的所有动作产生的动作价值中最大的那个动作价值</p><script type="math/tex; mode=display"> \begin{aligned} v_*(s) & = v_{\pi_*}(s) & \text{公式6.6.2a} \\ & = \sum_{a \in A}\pi_*(a|s) q_{\pi_*}(s,a) & \text{公式6.4.1} \\ & = \max_a q_{\pi_*}(s,a) & \text{公式6.7} \\ & = \max_a q_*(s,a) & \text{公式6.6.2b} \\ \end{aligned}</script><p> 即</p><script type="math/tex; mode=display">v_*(s) = \max_a q_*(s,a) \tag{6.8.1}</script></li><li><p>与 <strong>方程6.4.2</strong> 类似，状态 $s$ 下执行动作 $a$ 的最优价值也可以分解为 <strong>离开状态 $s$ 的立即回报</strong> 与 <strong>所有可能会进入状态的最优状态价值与对应进入概率</strong> 的乘积的和，即：</p><script type="math/tex; mode=display">q_*(s,a) = R_s^a + \gamma \sum_{s\prime \in S} P_{ss\prime}^a v_*(s\prime) \tag{6.8.2}</script></li><li><p>组合上面的 <strong>方程6.8.1</strong> 和 <strong>方程6.8.2</strong> ，可以得到</p><script type="math/tex; mode=display">q_*(s,a) = R_s^a + \gamma \sum_{s\prime \in S} P_{ss\prime}^a  \max_{a\prime} q_*(s\prime,a\prime)</script><script type="math/tex; mode=display">v_*(s) = \max_a \left(R_s^a + \gamma \sum_{s\prime \in S} P_{ss\prime}^a v_*(s\prime)\right)</script></li></ol><h4 id="6-9-贝尔曼最优方程的求解方法"><a href="#6-9-贝尔曼最优方程的求解方法" class="headerlink" title="6.9 贝尔曼最优方程的求解方法"></a>6.9 贝尔曼最优方程的求解方法</h4><ol><li>贝尔曼最优方程是非线性的</li><li>贝尔曼最优方程通常没有固定的解决方案</li><li>可以通过一些迭代的方法来解决：<ul><li>价值迭代（Value Iteration）</li><li>策略迭代（Policy Iteration）</li><li>Q-learning</li><li>Sarsa</li></ul></li></ol><h3 id="6-10-贝尔曼期望方程和贝尔曼最优方程的关系"><a href="#6-10-贝尔曼期望方程和贝尔曼最优方程的关系" class="headerlink" title="6.10 贝尔曼期望方程和贝尔曼最优方程的关系"></a>6.10 贝尔曼期望方程和贝尔曼最优方程的关系</h3><ol><li>贝尔曼期望方程中，策略是已知的，求解贝尔曼期望方程就是在评价策略的优劣</li><li>贝尔曼最优方程中，策略是未知的，求解贝尔曼最优方程就是在找最优的策略</li></ol><hr><h2 id="二、生成模式（Generating-Patterns）"><a href="#二、生成模式（Generating-Patterns）" class="headerlink" title="二、生成模式（Generating Patterns）"></a>二、生成模式（Generating Patterns）</h2><h3 id="1-确定性模式（Deterministic-Patterns）"><a href="#1-确定性模式（Deterministic-Patterns）" class="headerlink" title="1. 确定性模式（Deterministic Patterns）"></a>1. 确定性模式（Deterministic Patterns）</h3><p>环境的下一个状态可以根据上一个状态计算出来。</p><p>比如：过完生日你就长了一岁。</p><h3 id="2-非确定性模式（Non-deterministic-patterns）"><a href="#2-非确定性模式（Non-deterministic-patterns）" class="headerlink" title="2. 非确定性模式（Non-deterministic patterns）"></a>2. 非确定性模式（Non-deterministic patterns）</h3><p>环境的下一个状态不能根据上一个状态计算出来。</p><p>比如：掷骰子。</p><p>马尔可夫假设：环境当前的状态仅仅依赖于之前的几个状态。<br>$n$ 阶马尔可夫模型：环境的下一个状态只由过去的 $n$ 个状态决定，与其他状态无关。</p><h3 id="3-隐藏模式（Hidden-Patterns）"><a href="#3-隐藏模式（Hidden-Patterns）" class="headerlink" title="3. 隐藏模式（Hidden Patterns）"></a>3. 隐藏模式（Hidden Patterns）</h3><p>隐马尔可夫模型（Hidden Markov Model, HMM）</p><hr><blockquote><p>参考：<a href="https://www.youtube.com/watch?v=lfHX2hHRMVQ&amp;list=PLqYmG7hTraZDM-OYHWgPebj2MfCFzFObQ&amp;index=2&amp;ab_channel=DeepMind">RL Course by David Silver - Lecture 2: Markov Decision Process</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 马尔可夫 </tag>
            
            <tag> 贝尔曼公式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决Ubuntu播放声音卡顿和爆音</title>
      <link href="jie-jue-ubuntu-bo-fang-sheng-yin-qia-dun-he-bao-yin/"/>
      <url>jie-jue-ubuntu-bo-fang-sheng-yin-qia-dun-he-bao-yin/</url>
      
        <content type="html"><![CDATA[<h2 id="播放声音卡顿"><a href="#播放声音卡顿" class="headerlink" title="播放声音卡顿"></a>播放声音卡顿</h2><p>安装完Ubuntu18.04后，用网易云音乐听歌时，声音总是每隔几秒卡顿一下，特此记录一下解决方法。</p><p>用命令<code>sudo lspci -v | grep -A7 Audio</code>查看系统的使用的声卡设备是<strong>Intel Corporation 200 Series PCH HD Audio</strong>，使用的驱动时<strong>snd_hda_intel</strong>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">~ <span class="token function">sudo</span> lspci -v <span class="token operator">|</span> <span class="token function">grep</span> -A7 Audio00:1f.3 Audio device: Intel Corporation <span class="token number">200</span> Series PCH HD Audio    Subsystem: Gigabyte Technology Co., Ltd <span class="token number">200</span> Series PCH HD Audio    Flags: bus master, fast devsel, latency <span class="token number">32</span>, IRQ <span class="token number">125</span>    Memory at f7140000 <span class="token punctuation">(</span><span class="token number">64</span>-bit, non-prefetchable<span class="token punctuation">)</span> <span class="token punctuation">[</span>size<span class="token operator">=</span>16K<span class="token punctuation">]</span>    Memory at f7120000 <span class="token punctuation">(</span><span class="token number">64</span>-bit, non-prefetchable<span class="token punctuation">)</span> <span class="token punctuation">[</span>size<span class="token operator">=</span>64K<span class="token punctuation">]</span>    Capabilities: <span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span> Power Management version <span class="token number">3</span>    Capabilities: <span class="token punctuation">[</span><span class="token number">60</span><span class="token punctuation">]</span> MSI: Enable+ <span class="token assign-left variable">Count</span><span class="token operator">=</span><span class="token number">1</span>/1 Maskable- 64bit+    Kernel driver <span class="token keyword">in</span> use: snd_hda_intel    Kernel modules: snd_hda_intel--01:00.1 Audio device: NVIDIA Corporation GP107GL High Definition Audio Controller <span class="token punctuation">(</span>rev a1<span class="token punctuation">)</span>    Subsystem: NVIDIA Corporation GP107GL High Definition Audio Controller    Flags: bus master, fast devsel, latency <span class="token number">0</span>, IRQ <span class="token number">17</span>    Memory at f7080000 <span class="token punctuation">(</span><span class="token number">32</span>-bit, non-prefetchable<span class="token punctuation">)</span> <span class="token punctuation">[</span>size<span class="token operator">=</span>16K<span class="token punctuation">]</span>    Capabilities: <span class="token punctuation">[</span><span class="token number">60</span><span class="token punctuation">]</span> Power Management version <span class="token number">3</span>    Capabilities: <span class="token punctuation">[</span><span class="token number">68</span><span class="token punctuation">]</span> MSI: Enable- <span class="token assign-left variable">Count</span><span class="token operator">=</span><span class="token number">1</span>/1 Maskable- 64bit+    Capabilities: <span class="token punctuation">[</span><span class="token number">78</span><span class="token punctuation">]</span> Express Endpoint, MSI 00    Capabilities: <span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span> Advanced Error Reporting    Kernel driver <span class="token keyword">in</span> use: snd_hda_intel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="播放声音爆音"><a href="#播放声音爆音" class="headerlink" title="播放声音爆音"></a>播放声音爆音</h2><p>有时电脑重启后，声音就一直每隔几秒爆音一下，重启也没用。可以执行一下命令，重启一下<strong>pulseaudio</strong>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pulseaudio --kill <span class="token punctuation">\</span>  <span class="token operator">&amp;&amp;</span> <span class="token function">rm</span> -r ~/.config/pulse/* <span class="token punctuation">\</span>  <span class="token operator">&amp;&amp;</span> pulseaudio --start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Effective Modern C++》读书笔记</title>
      <link href="effective-modern-c-du-shu-bi-ji/"/>
      <url>effective-modern-c-du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="一、型别推导"><a href="#一、型别推导" class="headerlink" title="一、型别推导"></a>一、型别推导</h2><h3 id="1-理解模板型别推导"><a href="#1-理解模板型别推导" class="headerlink" title="1. 理解模板型别推导"></a>1. 理解模板型别推导</h3><ol><li>在模板型别推导过程中，具有引用型别的实参会被当成非引用型别来处理。换言之，其引用性会被忽略。</li><li>对万能引用(Universal Reference)形参进行推导时，左值实参会进行特殊处理。</li><li>对按值传递的形参进行推导时，若实参型别中带有const或volatile饰词，则它们还是会被当作不带const或volatile饰词的型别来处理。</li><li>在模板型别推导过程中，数组或函数型别的实参会退化成对应的指针，除非它们被用来初始化引用。</li></ol><h3 id="2-理解auto型别推导"><a href="#2-理解auto型别推导" class="headerlink" title="2. 理解auto型别推导"></a>2. 理解auto型别推导</h3><ol><li>在一般情况下，auto型别推导和模板型别推导是一摸一样的，但是auto型别推导会假定用大括号括起的初始化表达式代表一个std::initializer_list，但模板型别推导却不会。</li><li>在函数返回值或lambda式的形参中使用auto，意思是使用模板型别推导而非auto型别推导。</li></ol><h3 id="3-理解decltype"><a href="#3-理解decltype" class="headerlink" title="3. 理解decltype"></a>3. 理解decltype</h3><ol><li>绝大多数情况下，decltype会得出变量或表达式的型别而不作任何修改。</li><li><p>对于型别为T的左值表达式，除非该表达式仅有一个名字，decltype总是得出型别T&amp;。</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>     <span class="token comment">// -&gt; int</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">// -&gt; int&amp;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span>    <span class="token comment">// -&gt; int&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>C++14支持decltype(auto)，和auto一样，它会从其初始化表达式出发来推导型别，但是它的型别推导使用的是decltype的规则。</li></ol><h3 id="4-掌握查看型别推导结果的方法"><a href="#4-掌握查看型别推导结果的方法" class="headerlink" title="4. 掌握查看型别推导结果的方法"></a>4. 掌握查看型别推导结果的方法</h3><ol><li>利用IDE编辑器、编译器错误消息和Boost.TypeIndex库常常能够查看到推导而得的型别。</li><li>有些工具产生的结果可能会无用，或者不准确。所以，理解C++型别推导规则是必要的。</li></ol><h2 id="二、auto"><a href="#二、auto" class="headerlink" title="二、auto"></a>二、auto</h2><h3 id="5-优先选用auto，而非显示型别声明"><a href="#5-优先选用auto，而非显示型别声明" class="headerlink" title="5. 优先选用auto，而非显示型别声明"></a>5. 优先选用auto，而非显示型别声明</h3><ol><li>auto变量必须初始化，基本上对会导致兼容性和效率问题的型别不匹配现象免疫，还可以简化重构流程，通常也比显示指定型别要少打一些字。</li><li>auto型别的变量都有着<a href="#2-理解auto型别推导">条款2</a>和<a href="#6-当auto推导的型别不符合要求时，使用带显示型别的初始化物习惯用法">条款6</a>中所描述的毛病。</li></ol><h3 id="6-当auto推导的型别不符合要求时，使用带显示型别的初始化物习惯用法"><a href="#6-当auto推导的型别不符合要求时，使用带显示型别的初始化物习惯用法" class="headerlink" title="6. 当auto推导的型别不符合要求时，使用带显示型别的初始化物习惯用法"></a>6. 当auto推导的型别不符合要求时，使用带显示型别的初始化物习惯用法</h3><ol><li>“隐形”的代理型别可以导致auto根据初始化表达式推导出“错误的”型别。</li><li>带显示型别的初始化物习惯用法强制auto推导出你想要的型别。</li></ol><h2 id="三、转向现代C"><a href="#三、转向现代C" class="headerlink" title="三、转向现代C++"></a>三、转向现代C++</h2><h3 id="7-在创建对象时注意区分-和"><a href="#7-在创建对象时注意区分-和" class="headerlink" title="7. 在创建对象时注意区分()和{}"></a>7. 在创建对象时注意区分()和{}</h3><ol><li>大括号初始化可以应用的语境最为宽泛，可以阻止隐式窄化型别转换，还对最令人苦恼之解析语法免疫。</li><li>在构造函数重载决议期间，只要有任何可能，大括号初始化物就会与带有std::initializer_list型别的形参相匹配，即使其他重载版本有着貌似更加匹配的形参表。</li><li>使用小括号还是大括号，会造成结果大相径庭的一个例子是：使用两个实参创建一个std::vector&lt;数值型别&gt;对象。</li><li>在模板内容进行对象创建时，到底应该使用小括号还是大括号会成为一个棘手问题。</li></ol><h4 id="几个容易混淆的例子"><a href="#几个容易混淆的例子" class="headerlink" title="几个容易混淆的例子"></a>几个容易混淆的例子</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Widget w1<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">// 调用默认构造函数</span>Widget <span class="token function">w2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 声明了一个名为w2的函数</span>Widget <span class="token function">w3</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 调用带有std::initializer_list型别形参的构造函数</span>Widget w4<span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// 同上</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-优先选用nullptr，而非0或NULL"><a href="#8-优先选用nullptr，而非0或NULL" class="headerlink" title="8. 优先选用nullptr，而非0或NULL"></a>8. 优先选用nullptr，而非0或NULL</h3><ol><li>相对于0或NULL，优先选用nullptr。</li><li>避免在整型和指针型别之间重载。</li></ol><h3 id="9-优先选用别名声明，而非typedef"><a href="#9-优先选用别名声明，而非typedef" class="headerlink" title="9. 优先选用别名声明，而非typedef"></a>9. 优先选用别名声明，而非typedef</h3><ol><li>typedef不支持模板化，但别名声明支持。</li><li>别名模板可以让人免写“::type”后缀，并且在模板内，对于内嵌typedef的引用经常要求加上typename前缀。</li></ol><h3 id="10-优先选用限定作用域的枚举型别，而非不限作用域的枚举型别"><a href="#10-优先选用限定作用域的枚举型别，而非不限作用域的枚举型别" class="headerlink" title="10. 优先选用限定作用域的枚举型别，而非不限作用域的枚举型别"></a>10. 优先选用限定作用域的枚举型别，而非不限作用域的枚举型别</h3><ol><li>C++98风格的枚举型别，现在称为不限范围的枚举型别。</li><li>限定作用域的枚举型别仅在枚举型别内可见。它们只能通过强制型别转换以转换至其他型别。</li><li>限制作用域的枚举型别和不限范围的枚举型别都支持底层型别指定。限制作用域的枚举型别的默认底层型别是int，而不限范围的枚举型别没有默认底层型别。</li><li>限制作用域的枚举型别总是可以进行前置声明，而不限范围的枚举型别却只有在指定了默认底层型别的前提下才可以进行前置声明。</li></ol><h3 id="11-优先选用删除函数，而非private未定义函数"><a href="#11-优先选用删除函数，而非private未定义函数" class="headerlink" title="11. 优先选用删除函数，而非private未定义函数"></a>11. 优先选用删除函数，而非private未定义函数</h3><ol><li>优先选用删除函数，而非private未定义函数。</li><li>任何函数都可以删除，包括非成员函数和模板具现。</li></ol><h3 id="12-为意在改写的函数添加override声明"><a href="#12-为意在改写的函数添加override声明" class="headerlink" title="12. 为意在改写的函数添加override声明"></a>12. 为意在改写的函数添加override声明</h3><ol><li>为意在改写的函数添加override声明。</li><li>成员函数引用饰词使得对于左值和右值对象（*this）的处理能够区分开来。</li></ol><h3 id="13-优先选用const-iterator，而非iterator"><a href="#13-优先选用const-iterator，而非iterator" class="headerlink" title="13. 优先选用const_iterator，而非iterator"></a>13. 优先选用const_iterator，而非iterator</h3><ol><li>优先选用const_iterator，而非iterator。</li><li>在最通用的代码中，优先选用非成员函数版本的begin、end和rbegin等，而非其成员函数版本。</li></ol><h3 id="14-只要函数不会发射异常，就为其加上noexcept声明"><a href="#14-只要函数不会发射异常，就为其加上noexcept声明" class="headerlink" title="14. 只要函数不会发射异常，就为其加上noexcept声明"></a>14. 只要函数不会发射异常，就为其加上noexcept声明</h3><ol><li>noexcept声明是函数接口的组成部分，这意味着调用方可能会对它有依赖。</li><li>相对于不带noexcept声明的函数，带有noexcept声明的函数有更对机会得到优化。</li><li>noexcept性质对于移动操作、swap、函数释放函数和析构函数最有价值。</li><li>大多数函数都是异常中立的，不具备noexcept性质。</li></ol><h4 id="关于条款14的补充说明"><a href="#关于条款14的补充说明" class="headerlink" title="关于条款14的补充说明"></a>关于条款14的补充说明</h4><ul><li><p>在带有noexcept声明的函数中，优化器不需要在异常传出函数的前提下，将执行期栈保持在可开解状态；也不需要在异常溢出函数的前提下，保证所有其中的对象以其被构造顺序的逆序完成析构。而那些以“throw()”异常规格声明的函数就享受不到这样的优化灵活性，和没有加异常规格声明的函数一样。</p></li><li><p>在C++98中，允许内存释放函数（即operator delete或operator delete[]）和析构函数发射异常，被认为是一种差劲的编程风格。而在C++11中，这种风格规则被升级成了一条语言规则。<strong>默认地，内存释放函数和所有的析构函数（无论是用户定义的，还是编译器自动生成的）都隐式地具备noexcept性质。</strong></p></li></ul><h3 id="15-只要有可能使用constexpr，就使用它"><a href="#15-只要有可能使用constexpr，就使用它" class="headerlink" title="15. 只要有可能使用constexpr，就使用它"></a>15. 只要有可能使用constexpr，就使用它</h3><ol><li>constexpr对象都具备const属性，并由编译期已知的值完成初始化。</li><li>constexpr函数在调用时若传入的实参值是编译期已知的，则会产生出编译期结果。</li><li>比起非constexpr对象或constexpr函数而言，constexpr对象或是constexpr函数可以用在一个作用域更广的语境中。</li></ol><h4 id="关于constexpr函数的说明"><a href="#关于constexpr函数的说明" class="headerlink" title="关于constexpr函数的说明"></a>关于constexpr函数的说明</h4><ul><li>constexpr函数可以用在要求编译期常量的语境中。在这样的语境中，若你传给一个constexpr函数的实参值是在编译期已知的，则结果也会在编译期间计算出来。如果任何一个实参值在编译期未知，则你的代码将无法通过编译。</li><li>在调用constexpr函数时，若传入的值有一个或多个在编译期未知，则它的运作方式和普通函数无异，亦即它也是在运行期执行结果的计算。这意味着，如果函数执行的是同样的操作，仅仅应用的语境一个是要求编译期常量的，一个是用于所有其他值的话，那就不必写两个函数。constexpr函数就可以同时满足所有需求。</li></ul><h4 id="关于constexpr在C-11和C-14中的不同"><a href="#关于constexpr在C-11和C-14中的不同" class="headerlink" title="关于constexpr在C++11和C++14中的不同"></a>关于constexpr在C++11和C++14中的不同</h4><p>constexpr函数仅限于传入和返回字面型别（literal type），意思就是这样的型别能够持有编译期可以决议的值。在C++11中，所有的内建型别，除了void，都符合这个条件。但是用户自定义型别同样可能也是字面型别，因为它的构造函数和其他成员函数可能也是constexpr函数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">constexpr</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">double</span> xVal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">double</span> yVal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>xVal<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>yVal<span class="token punctuation">)</span>    <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">constexpr</span> <span class="token keyword">double</span> <span class="token function">xValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">constexpr</span> <span class="token keyword">double</span> <span class="token function">yValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">setX</span><span class="token punctuation">(</span><span class="token keyword">double</span> newX<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> x <span class="token operator">=</span> newX<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">setY</span><span class="token punctuation">(</span><span class="token keyword">double</span> newY<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> y <span class="token operator">=</span> newY<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">double</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在C++11中，有两个限制使得Point的成员函数setX和setY无法声明为constexpr。</p><ol><li>首先，它们修改了操作对象。在C++11中，constexpr函数都隐式地被声明为const的了。<em>这里说的并非函数返回值的const属性，而是指成员函数的const饰词，这意味着该成员函数不能修改其操作对象（严格地说是不能修改其非mutable数据成员）。</em></li><li>其次，它们的返回型别是void。而在C++11中，void并不是个字面型别。</li></ol><p>不过这两个限制在C++14中都被解除了，所以在C++14中，就连设置器也可以声明为constexpr。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">constexpr</span> <span class="token keyword">void</span> <span class="token function">setX</span><span class="token punctuation">(</span><span class="token keyword">double</span> newX<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> x <span class="token operator">=</span> newX<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// C++14</span>    <span class="token keyword">constexpr</span> <span class="token keyword">void</span> <span class="token function">setY</span><span class="token punctuation">(</span><span class="token keyword">double</span> newY<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> y <span class="token operator">=</span> newY<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// C++14</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="关于条款15的补充说明"><a href="#关于条款15的补充说明" class="headerlink" title="关于条款15的补充说明"></a>关于条款15的补充说明</h4><ul><li><p>所有constexpr对象都是const对象，而并非所有的const对象都是constexpr对象。如果你想让编译器提供保证，让变量拥有一个值，用于要求编译期常量的语境，那么能达到这个目的的工具是constexpr，而非const。</p></li><li><p>在C++11中，constexpr函数不得包含多于一个可执行语句，即一个return语句。在C++14中，限制条件大大地放宽了。</p></li></ul><h3 id="16-保证const成员函数的线程安全性"><a href="#16-保证const成员函数的线程安全性" class="headerlink" title="16. 保证const成员函数的线程安全性"></a>16. 保证const成员函数的线程安全性</h3><ol><li>保证const成员函数的线程安全性，除非可以确信它们不会用在并发语境中。</li><li>运用std::atomic型别的变量会比运用互斥量提供更好的性能，但前者仅适用对单个变量或内存区域的操作。</li></ol><h3 id="17-理解特种成员函数的生成机制"><a href="#17-理解特种成员函数的生成机制" class="headerlink" title="17. 理解特种成员函数的生成机制"></a>17. 理解特种成员函数的生成机制</h3><ol><li>特种成员函数是指那些C++会自行生成的成员函数：默认构造函数、析构函数、复制操作，以及移动操作。</li><li>移动操作仅当类中未包含用户显式声明的复制操作、移动操作和析构函数时才生成。</li><li>复制构造函数仅当类中不包含用户显示声明的复制构造函数时才生成，如果该类声明了移动操作则复制构造函数将被删除。复制赋值运算符仅当类中不包含用户显示声明的复制赋值运算符才生成，如果该类声明了移动操作则复制赋值运算符将被删除。在已经存在显式声明的析构函数的条件下，生成复制操作已经成为了被废弃的行为。</li><li>成员函数模板在任何情况下都不会抑制特种成员函数的生成。</li></ol><h4 id="大三律"><a href="#大三律" class="headerlink" title="大三律"></a>大三律</h4><p>如果你声明了复制构造函数、复制赋值运算符，或析构函数中的任何一个，你就得同时声明所有这三个。</p><p>它植根于这样的思想：如果有改写复制操作的需求，往往意味着该类需要执行某种资源管理，而这就意味着：</p><ol><li>在一种复制操作中进行的任何资源管理，也极有可能在另一种复制操作中也需要进行；</li><li>该类的析构函数也会参与到该资源的管理中（通常是释放之）。</li></ol><h4 id="移动操作的生成条件（如果需要生成）仅当一下三者同时成立"><a href="#移动操作的生成条件（如果需要生成）仅当一下三者同时成立" class="headerlink" title="移动操作的生成条件（如果需要生成）仅当一下三者同时成立"></a>移动操作的生成条件（如果需要生成）仅当一下三者同时成立</h4><ol><li><p>该类未声明任何复制操作</p><p> 声明复制操作（无论是复制构造还是复制赋值）的行为表明了对象的常规复制途径（按成员复制）对于该类并不适用。编译器从而判定，既然按成员复制不适用于复制操作，则按成员移动极有可能也不适用于移动操作。</p></li><li><p>该类未声明任何移动操作</p><p> 假设你声明了一个移动构造函数，你实际上表明移动操作的实现方式将会与编译器生成的默认按成员移动的移动构造函数多少有些不同。而若是按成员进行的移动构造操作有不合用之处的话，那么按成员进行的移动赋值运算符极有可能也会有不合用之处。</p></li><li><p>该类未声明任何析构函数</p><ul><li><a href="#大三律">大三律</a>的一个推论是，如果存在用户声明的析构函数，则平凡的（trivial）按成员复制的也不适用于该类。根据这个推论，又能得出进一步的结论，如果声明了析构函数，则复制操作就不该被自动生成，因为它们的行为不可能正确。不过在C++98标准被接受的时代，这样的论证过程没有得到充分的重视，所以在C++98中，用户声明的析构函数即使存在，也不会影响编译器生成复制操作的意愿。这种情况在C++11仍然得到了保持，但原因仅仅在于，如果要对复制操作的生成条件施加更严格的限制，就会破坏太多的遗留代码了。</li><li>由于<a href="#大三律">大三律</a>背后的理由仍然成立，再结合声明了复制操作就会阻止隐式生成移动操作的事实，就推动了C++11中的这样一个规定：只要用户声明了析构函数，就不会生成移动操作。</li></ul></li></ol><h4 id="关于条款17的补充说明"><a href="#关于条款17的补充说明" class="headerlink" title="关于条款17的补充说明"></a>关于条款17的补充说明</h4><ul><li>当移动操作在某个数据成员或基类部分上执行移动构造或移动赋值的时候，并不能保证移动操作真的会发生。“按成员移动”实际上更像是按成员的移动请求，因为那些不可移动的型别（即那些并未为移动操作提供特殊支持的型别，这包括了大多数C++98的遗留型别）将通过其复制操作实现“移动”。每个按成员进行的“移动”操作，其核心在于把std::move应用于每一个移动源对象，其返回值被用于函数重载决议，最终决定是执行一个移动还是复制操作，这个流程将在<a href="#23-理解std::move和std::forward">条款23</a>中详述。在本条款中，只需记住，按成员移动是由两部分组成，一部分是在支持移动操作的成员上执行移动操作，另一部分实在不支持移动操作的成员上执行复制操作。</li></ul><h2 id="四、智能指针"><a href="#四、智能指针" class="headerlink" title="四、智能指针"></a>四、智能指针</h2><h3 id="18-使用std-unique-ptr管理具备专属所有权的资源"><a href="#18-使用std-unique-ptr管理具备专属所有权的资源" class="headerlink" title="18. 使用std::unique_ptr管理具备专属所有权的资源"></a>18. 使用std::unique_ptr管理具备专属所有权的资源</h3><ol><li>std::unique_ptr是小巧、高速的、具备只移型别的智能指针，对托管资源实施专属所有权语义。</li><li>默认地，资源析构采用delete运算符来实现，但可以指定自定义删除器。有状态的删除器和采用函数指针实现的删除器会增加std::unique_ptr型别的对象尺寸。</li><li>将std::unique_ptr转换成std::shared_ptr是容易实现的。</li></ol><h3 id="19-使用std-shared-ptr管理具备共享所有权的资源"><a href="#19-使用std-shared-ptr管理具备共享所有权的资源" class="headerlink" title="19. 使用std::shared_ptr管理具备共享所有权的资源"></a>19. 使用std::shared_ptr管理具备共享所有权的资源</h3><ol><li>std::shared_ptr提供方便的手段，实现了任意资源在共享所有权语义下进行生命周期管理的垃圾回收。</li><li>与std::unique_ptr相比，std::shared_ptr的尺寸通常是裸指针尺寸的两倍，它还会带来控制块的开销，并要求原子化的引用技术操作。</li><li>默认的资源析构通过delete运算符进行，但同时也支持定制删除器。删除器的型别对std::shared_ptr的型别没有影响。</li><li>避免使用裸指针型别的变量来创建std::shared_ptr指针。</li></ol><h3 id="20-对于类似std-shared-ptr但有可能空悬的指针使用std-weak-ptr"><a href="#20-对于类似std-shared-ptr但有可能空悬的指针使用std-weak-ptr" class="headerlink" title="20. 对于类似std::shared_ptr但有可能空悬的指针使用std::weak_ptr"></a>20. 对于类似std::shared_ptr但有可能空悬的指针使用std::weak_ptr</h3><ol><li>使用std::weak_ptr来代替可能空悬的std::shared_ptr。</li><li>std::weak_ptr可能的用武之地包括缓存，观察者列表，以及避免std::shared_ptr指针环路。</li></ol><h3 id="21-优先选用std-make-unique和std-make-shared，而非直接使用new"><a href="#21-优先选用std-make-unique和std-make-shared，而非直接使用new" class="headerlink" title="21. 优先选用std::make_unique和std::make_shared，而非直接使用new"></a>21. 优先选用std::make_unique和std::make_shared，而非直接使用new</h3><ol><li>相比于直接使用new表达式，make系列函数消除了重复代码、改进了异常安全性，并且对于std::make_shared和std::allocated_shared而言，生成的目标代码会尺寸更小、速度更快。</li><li>不适于使用make系列函数的场景包括需要定制删除器，以及期望直接传递大括号初始化物。</li><li>对于std::shared_ptr，不建议使用make系列函数的额外场景包括：（1）自定义内存管理的类；（2）内存紧张的系统、非常大的对象、以及存在比指涉到相同对象的std::shared_ptr生存期更久的std::weak_ptr。</li></ol><h3 id="22-使用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中"><a href="#22-使用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中" class="headerlink" title="22. 使用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中"></a>22. 使用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中</h3><ol><li>Pimpl惯用法通过降低类的客户和类实现者之间的依赖性，减少了构建遍数。</li><li>对于采用std::unique_ptr来实现的pImpl指针，须在类的头文件中声明特种成员函数，但在实现文件中实现它们。即使默认函数实现有着正确行为，也必须这样做。</li><li>上述建议仅适用于std::unique_ptr，但并不使用std::shared_ptr。</li></ol><h2 id="五、右值引用、移动语义和完美转发"><a href="#五、右值引用、移动语义和完美转发" class="headerlink" title="五、右值引用、移动语义和完美转发"></a>五、右值引用、移动语义和完美转发</h2><p>在阅读本章中的条款时，一定要把这一点铭记在心：<strong>形参总是左值，即使其型别是右值引用。</strong>即，给定函数形如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>形参w是个左值。即使它的型别是个指涉到Widget型别对象的右值引用（如果你对此感觉意外，请参阅本书第一章就写着的关于左值和右值的概述）。</p><h3 id="23-理解std-move和std-forward"><a href="#23-理解std-move和std-forward" class="headerlink" title="23. 理解std::move和std::forward"></a>23. 理解std::move和std::forward</h3><ol><li>std::move实施的是无条件的向右值型别的强制型别转换。就其本身而言，它不会执行移动操作。</li><li>仅当传入的实参被绑定到右值时，std::forward才针对该实参实施向右值型别的强制型别转换。</li><li>在运行期，std::move和std::forward都不会做任何操作。</li></ol><h3 id="24-区分万能引用和右值引用"><a href="#24-区分万能引用和右值引用" class="headerlink" title="24. 区分万能引用和右值引用"></a>24. 区分万能引用和右值引用</h3><ol><li>如果函数模板形参具备T&amp;&amp;型别，并且T的型别系推导而来，或如果对象使用auto&amp;&amp;声明其型别，则该形参或对象就是个万能引用。</li><li>如果型别声明并不精确地具备type&amp;&amp;的形式，或者型别推导并未发生，则type&amp;&amp;就代表右值引用。</li><li>若采用右值来初始化万能引用，就会得到一个右值引用。若采用左值来初始化万能引用，就会得到一个左值引用。</li></ol><h3 id="25-针对右值引用实施std-move，针对万能引用实施std-forward"><a href="#25-针对右值引用实施std-move，针对万能引用实施std-forward" class="headerlink" title="25. 针对右值引用实施std::move，针对万能引用实施std::forward"></a>25. 针对右值引用实施std::move，针对万能引用实施std::forward</h3><ol><li>针对右值引用的最后一次使用实施std::move，针对万能引用的最后一次使用实施std::forward。</li><li>作为按值返回的函数的右值引用和万能引用，依上一条所述采取相同行为。</li><li>若局部对象可能适用于返回值优化，则请勿针对其实施std::move或std::forward。</li></ol><h4 id="RVO的条件"><a href="#RVO的条件" class="headerlink" title="RVO的条件"></a>RVO的条件</h4><ul><li><p>局部对象型别和函数返回值型别相同。</p>  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Widget <span class="token function">makeWidget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Widget w<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  <code>std::move(w)</code>返回的不是局部对象w，而是w的引用，std::move(w)的结果。返回一个局部对象的引用并不满足实施RVO的前提条件，因此编译器必须把w移入函数的返回值存储位置。</p></li><li><p>返回的就是局部对象本身。</p></li></ul><p>即使实施RVO的前提条件满足，但编译器选择不执行复制省略的时候，返回对象必须作为右值处理。这么一来，就等于标准要求：<strong>当RVO的前提条件允许时，要么发生复制省略，要么std::move隐式地被实施于返回的局部对象上。</strong></p><h3 id="26-避免依万能引用型型别进行重载"><a href="#26-避免依万能引用型型别进行重载" class="headerlink" title="26. 避免依万能引用型型别进行重载"></a>26. 避免依万能引用型型别进行重载</h3><ol><li>把万能引用作为重载候选型别，几乎总会让该重载版本在始料未及的情况下被调用到。</li><li>完美转发构造函数的问题尤其严重，因为对于非常量的左值型别而言，它们一般都会形成相对于复制构造函数的更佳匹配，并且它们还会劫持派生类中对基类的复制和移动构造函数的调用。</li></ol><h3 id="27-熟悉依万能引用型别进行重载的替代方案"><a href="#27-熟悉依万能引用型别进行重载的替代方案" class="headerlink" title="27. 熟悉依万能引用型别进行重载的替代方案"></a>27. 熟悉依万能引用型别进行重载的替代方案</h3><ol><li>如果不使用万能引用和重载的组合，则替代方案包括使用彼此不同的函数名字、传递const T&amp;型别的形参、传值和标签分派。</li><li>经由std::enable_if对模板施加限制，就可以将万能引用和重载一起使用，不过这种技术控制了编译器可以调用到接受万能引用的重载版本的条件。</li><li>万能引用形参通常在性能方面具备优势，但在易用性方面一般会有劣势。</li></ol><h3 id="28-理解引用折叠"><a href="#28-理解引用折叠" class="headerlink" title="28. 理解引用折叠"></a>28. 理解引用折叠</h3><ol><li>引用折叠会在四种语境中发生：模板实例化，auto型别生成、创建和运用typedef和别名声明，以及decltype。</li><li>当编译器在引用折叠的语境下生成引用的引用时，结果会变成单个引用。如果原始的引用中有任一引用为左值引用，则结果为左值引用。否则，结果为右值引用。</li><li>万能引用就是在型别推导的过程中会区别左值和右值，以及会发生引用折叠的语境中的右值引用。</li></ol><h3 id="29-假定移动操作不存在、成本高、未使用"><a href="#29-假定移动操作不存在、成本高、未使用" class="headerlink" title="29. 假定移动操作不存在、成本高、未使用"></a>29. 假定移动操作不存在、成本高、未使用</h3><ol><li>假定移动操作不存在、成本高、未使用。</li><li>对于那些型别或对于移动语义的支持情况已知的代码，则无需作以上假定。</li></ol><h3 id="30-熟悉完美转发的失败情形"><a href="#30-熟悉完美转发的失败情形" class="headerlink" title="30. 熟悉完美转发的失败情形"></a>30. 熟悉完美转发的失败情形</h3><ol><li>完美转发的失败情形，是源于模板型别推导失败，或推导结果是错误的型别。</li><li>会导致完美转发失败的实参种类有大括号初始化物、以值0或NULL表达的空指针、仅有声明的整型static const成员变量、模板或重载的函数名字，以及位域。</li></ol><h2 id="六、lambda表达式"><a href="#六、lambda表达式" class="headerlink" title="六、lambda表达式"></a>六、lambda表达式</h2><h3 id="31-避免默认捕获模式"><a href="#31-避免默认捕获模式" class="headerlink" title="31. 避免默认捕获模式"></a>31. 避免默认捕获模式</h3><ol><li>按引用的默认捕获会导致空悬指针问题。</li><li>按值的默认捕获极易受空悬指针影响（尤其是this），并会误导人们认为lambda式是自洽的。</li></ol><h3 id="32-使用初始化捕获将对象移入闭包"><a href="#32-使用初始化捕获将对象移入闭包" class="headerlink" title="32. 使用初始化捕获将对象移入闭包"></a>32. 使用初始化捕获将对象移入闭包</h3><ol><li>使用C++14的初始化捕获将对象移入闭包。</li><li>在C++11中，经由手工实现的类或std::bind去模拟初始化捕获。</li></ol><h3 id="33-对auto-amp-amp-型别的形参使用decltype，以std-forward之"><a href="#33-对auto-amp-amp-型别的形参使用decltype，以std-forward之" class="headerlink" title="33. 对auto&amp;&amp;型别的形参使用decltype，以std::forward之"></a>33. 对auto&amp;&amp;型别的形参使用decltype，以std::forward之</h3><ol><li><p>对auto&amp;&amp;型别的形参使用decltype，以std::forward之。</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token function">normalize</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="34-优先选用lambda式，而非std-bind"><a href="#34-优先选用lambda式，而非std-bind" class="headerlink" title="34. 优先选用lambda式，而非std::bind"></a>34. 优先选用lambda式，而非std::bind</h3><ol><li>lambda式比起使用std::bind而言，可读性更好、表达力更强，可能运行效率也更高。</li><li>仅在C++11中，std::bind在实现移动捕获，或是绑定到具备模板化的函数调用运算符的对象的场合中，可能尚有余热可以发挥。</li></ol><h2 id="七、并发API"><a href="#七、并发API" class="headerlink" title="七、并发API"></a>七、并发API</h2><h3 id="35-优先选用基于任务而非基于线程的程序设计"><a href="#35-优先选用基于任务而非基于线程的程序设计" class="headerlink" title="35. 优先选用基于任务而非基于线程的程序设计"></a>35. 优先选用基于任务而非基于线程的程序设计</h3><ol><li>std::thread的API未提供直接获取异步运行函数返回值的途径，而且如果那些函数抛出异常，程序就会终止。</li><li>基于线程的程序设计要求手动管理线程耗尽、超订、负载均衡，以及新平台适配。</li><li>经由应用了默认启动策略的std::async进行基于任务的程序设计，大部分这类问题都能找到解决知道。</li></ol><h3 id="36-如果异步是必要的，则指定std-launch-async"><a href="#36-如果异步是必要的，则指定std-launch-async" class="headerlink" title="36. 如果异步是必要的，则指定std::launch::async"></a>36. 如果异步是必要的，则指定std::launch::async</h3><ol><li>std::async的默认启动策略既允许任务异步方式执行，也允许任务以同步方式执行。</li><li>如此的弹性会导致使用thread_local变量时的不确定性，隐含着任务可能永远不会执行，还会影响运用了基于超时的wait调用的程序逻辑。</li><li>如果异步是必要的，则指定std::launch::async。</li></ol><h3 id="37-使std-thread型别对象在所有路径皆不可联结（unjoinable）"><a href="#37-使std-thread型别对象在所有路径皆不可联结（unjoinable）" class="headerlink" title="37. 使std::thread型别对象在所有路径皆不可联结（unjoinable）"></a>37. 使std::thread型别对象在所有路径皆不可联结（unjoinable）</h3><ol><li>使std::thread型别对象在所有路径皆不可联结。</li><li>在析构时调用join可能导致难以调试的性能异常。</li><li>在析构时调用detach可能导致难以调试的未定义行为。</li><li>在成员列表的最后声明std::thread型别对象。</li></ol><h4 id="不可联结的std-thread型别对象"><a href="#不可联结的std-thread型别对象" class="headerlink" title="不可联结的std::thread型别对象"></a>不可联结的std::thread型别对象</h4><ol><li><strong>默认构造的std::thread。</strong> 此类std::thread没有可以执行的函数，因此也没有对应的底层执行线程。</li><li><strong>已移动的std::thread。</strong> 移动操作的结果是，一个std::thread所对应的底层执行线程（若有）被对应到另一个std::thread。</li><li><strong>已联结的std::thread。</strong> 联结后，std::thread型别对象不在对应至已结束运行的底层执行线程。</li><li><strong>已分离的std::thread。</strong> 分离操作会把std::thread型别对象和它对应的底层执行线程之间的连接断开。</li></ol><h4 id="关于条款37的补充说明"><a href="#关于条款37的补充说明" class="headerlink" title="关于条款37的补充说明"></a>关于条款37的补充说明</h4><ul><li>如果可联结线程对象的析构函数被调用，则程序的执行就终止了。</li></ul><h3 id="38-对变化多端的线程句柄析构函数行为保持关注"><a href="#38-对变化多端的线程句柄析构函数行为保持关注" class="headerlink" title="38. 对变化多端的线程句柄析构函数行为保持关注"></a>38. 对变化多端的线程句柄析构函数行为保持关注</h3><ol><li>期值（std::future/std::shared_future）的析构函数在常规情况下，仅会析构期值的成员变量。</li><li>指涉到经由std::async启动的未推迟任务的共享状态的最后一个期值会保持阻塞，直至该任务结束。</li></ol><h3 id="39-考虑针对一次性事件通信使用以void为模板型别实参的期值"><a href="#39-考虑针对一次性事件通信使用以void为模板型别实参的期值" class="headerlink" title="39. 考虑针对一次性事件通信使用以void为模板型别实参的期值"></a>39. 考虑针对一次性事件通信使用以void为模板型别实参的期值</h3><ol><li>如果仅为了实现平凡事件通信，基于条件变量的设计会要求多余的互斥量，这会给相互关联的检测和反应任务带来约束，并要求反应任务校验事件确已发生。</li><li>使用标志位的设计可以避免上述问题，但这一设计基于轮训而非阻塞。</li><li>条件变量和标志位可以一起使用，但这样的通信机制设计结果不甚自然。</li><li>使用std::promise型别对象和期值就可以回避这些问题，但是一来这个途径为了共享状态需要使用堆内存，而且仅限于一次性通信。</li></ol><h3 id="40-对并发使用std-atomic，对特种内存使用volatile"><a href="#40-对并发使用std-atomic，对特种内存使用volatile" class="headerlink" title="40. 对并发使用std::atomic，对特种内存使用volatile"></a>40. 对并发使用std::atomic，对特种内存使用volatile</h3><ol><li>std::atomic用于多线程访问的数据，且不用互斥量。它是撰写并发软件的工具。</li><li><p>volatile用于读写操作不可以被优化掉的内存。它是在面对特种内存时使用的工具。</p><p> 给y加上volatile可以避免编译器将代码：</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">y</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>y<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 优化成：</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">register</span> <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token keyword">register</span><span class="token punctuation">)</span><span class="token punctuation">;</span>y<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token keyword">register</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="八、微调"><a href="#八、微调" class="headerlink" title="八、微调"></a>八、微调</h2><h3 id="41-针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递"><a href="#41-针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递" class="headerlink" title="41. 针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递"></a>41. 针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递</h3><ol><li>对于可复制的、在移动成本低廉的并且一定会被复制的形参而言，按值传递可能会和按引用传递的具备相近的效率，并且可能生成更少量的目标代码。</li><li>经由构造复制形参的成本可能比经由赋值复制形参高出很多。</li><li>按值传递肯定会导致切片问题，所以基类型别特别不适用于按值传递。</li></ol><h3 id="42-考虑置入而非插入"><a href="#42-考虑置入而非插入" class="headerlink" title="42. 考虑置入而非插入"></a>42. 考虑置入而非插入</h3><ol><li>从原理上说，置入函数（如：emplace_back）应该有时比对应的插入函数（如：push_back）高效，而且不应该有更低效的可能。</li><li>从实践上说，置入函数在以下几个前提成立时，极有可能会运行得更快：（1）待添加的值是以构造而非赋值方式加入容器；（2）传递的实参型别与容器持有之物的型别不同；（3）容器不会由于存在重复值而拒绝待添加的值。</li><li><p>置入函数可能会执行在插入函数中会被拒绝的型别转换。</p><p> 复制初始化是不允许调用带有explicit声明饰词的构造函数的，但直接初始化就允许。</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token operator">::</span>regex r1 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    <span class="token comment">// 错误！无法通过编译 （复制初始化）</span>std<span class="token operator">::</span>regex <span class="token function">r2</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 能编译 （直接初始化）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP模型协议状态机速览</title>
      <link href="tcp-mo-xing-xie-yi-zhuang-tai-ji-su-lan/"/>
      <url>tcp-mo-xing-xie-yi-zhuang-tai-ji-su-lan/</url>
      
        <content type="html"><![CDATA[<h2 id="一、OSI-模型"><a href="#一、OSI-模型" class="headerlink" title="一、OSI 模型"></a>一、OSI 模型</h2><p><img src="/images/TCP模型协议状态机速览/计算机网络体系结构.png" alt="计算机网络体系结构"></p><div class="table-container"><table><thead><tr><th>名字</th><th>功能</th><th>数据包名</th><th>常用协议及设备</th></tr></thead><tbody><tr><td>应用层</td><td>为应用进程提供服务</td><td></td><td>HTTP、FTP、TELNET、DNS、BT、NTP、DHCP、SNMP</td></tr><tr><td>表示层</td><td>提供数据格式转换服务</td><td></td><td>JPEG、MPEG、ASCll</td></tr><tr><td>会话层</td><td>建立端连接并提供访问验证和会话管理</td><td></td><td>SSL、TLS、NFS、SQL、NETBIOS、RPC</td></tr><tr><td>传输层</td><td>向两个主机中进程之间的通信提供服务</td><td>段 Segment</td><td>TCP、UDP、SPX</td></tr><tr><td>网络层</td><td>实现两个端系统之间的数据透明传送</td><td>包 Packet</td><td>IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP；路由器</td></tr><tr><td>数据链路层</td><td>在不可靠的物理线路上进行数据的可靠传输</td><td>帧 Frame</td><td>PPP、Ethernet；网桥、交换机</td></tr><tr><td>物理层</td><td>完成相邻结点之间原始比特流传输</td><td>比特 Bit</td><td>RJ45、网线、中继器、集线器</td></tr></tbody></table></div><blockquote><p>参考：<a href="http://www.colasoft.com.cn/download/protocols_map.php">网络通讯协议图</a></p></blockquote><h3 id="1-1-物理层"><a href="#1-1-物理层" class="headerlink" title="1.1 物理层"></a>1.1 物理层</h3><p>可用一根网线（1－3、2－6 交叉接法）直连两台电脑组成一个最小的局域网。</p><p>通过网线上电平的高低来传递信息，以太网使用 <strong><a href="https://zh.wikipedia.org/wiki/%E6%9B%BC%E5%BD%BB%E6%96%AF%E7%89%B9%E7%BC%96%E7%A0%81">曼彻斯特编码（Manchester coding）</a></strong> 来编码信息。</p><p><img src="/images/TCP模型协议状态机速览/曼彻斯特编码.png" alt="曼彻斯特编码"></p><p>相关设备：</p><ul><li><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E7%BB%A7%E5%99%A8">中继器（Repeater）</a>将收到信号加强并重新发送出去以增加信号的传输记录。</li><li><a href="https://zh.wikipedia.org/wiki/%E9%9B%86%E7%B7%9A%E5%99%A8">集线器（Hub）</a>将一个网口上收到的每一个 <strong>比特（Bit）</strong>，都复制到其他网口上。</li></ul><h3 id="1-2-数据链路层"><a href="#1-2-数据链路层" class="headerlink" title="1.2 数据链路层"></a>1.2 数据链路层</h3><p><strong><a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">数据链路层（Data Link Layer）</a></strong> 可细分成：</p><ul><li><strong><a href="https://zh.wikipedia.org/wiki/%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6">媒体访问控制（Medium Access Control，MAC）</a></strong> 子层：专职处理介质访问的争用与冲突问题；</li><li><strong><a href="https://zh.wikipedia.org/wiki/%E9%80%BB%E8%BE%91%E9%93%BE%E8%B7%AF%E6%8E%A7%E5%88%B6">逻辑链路控制（Logical Link Control，LLC）</a></strong> 子层：屏蔽各种 MAC 的差别并为网络层提供统一的数据链路服务。</li></ul><p>以以太网为例，通过网线连接在一起的设备，在发送包之前需要先解决几个问题：</p><ol><li><p>谁先发、谁后发？</p><p> 这个由规则（学名：<strong>多路访问</strong>）控制。以开车为例，常见的有：</p><ul><li>信道划分：分多个车道，每个车一个车道；</li><li>轮流协议：单双号出行，轮着来；</li><li><a href="https://zh.wikipedia.org/wiki/%E8%BD%BD%E6%B3%A2%E4%BE%A6%E5%90%AC%E5%A4%9A%E8%B7%AF%E8%AE%BF%E9%97%AE">按需使用</a>：先看看路上有车没，没车就出门，否则等一会再看看。<strong>以太网用的就是这种方式。</strong></li></ul></li><li><p>包发给谁、谁接收？</p><p> 每个网卡都有一个全球唯一的物理地址，叫 <strong>链路层地址</strong>。但因为主要用来解决媒体访问控制层的问题，所以常被称为 <strong><a href="https://zh.wikipedia.org/wiki/MAC%E5%9C%B0%E5%9D%80">MAC 地址</a></strong>。在发送时，源地址和目的地址填的都是 MAC 地址。</p><p> 当只知道目标机器的 IP 地址，而不知道目标机器的 MAC 时，需要通过 <strong><a href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE">地址解析协议（Address Resolution Protocol，ARP）</a></strong> 来获取 IP 地址对应的 MAC 地址。</p></li><li><p>发送出错怎么办？</p><p> 对于以太网来说，会在每个发出的 <strong>帧（Frame）</strong> 后面加上 <strong><a href="https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%92%B0%E5%86%97%E9%A4%98%E6%A0%A1%E9%A9%97">循环冗余校验（Cyclic Redundancy Check，CRC）</a>码</strong>，来判断发送是否出错，并在出错时重发。</p></li></ol><p>相关设备：</p><ul><li><a href="https://zh.wikipedia.org/wiki/%E6%A9%8B%E6%8E%A5%E5%99%A8">网桥（Network bridge）</a>解析收到的帧，学习并记录每个网口上连接设备的 MAC 地址，形成一个转发表。在转发时就只把帧转发到与帧中目的 MAC 地址对应的某个网口上。</li><li><a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E4%BA%A4%E6%8F%9B%E5%99%A8">交换机（Switch）</a>是一种多端口的网桥。一个 N 口交换机可以看成是 N x (N-1) 个网桥的集合。</li></ul><p>相关协议：</p><ul><li><a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AE">生成树协议（Spanning Tree Protocol，STP）</a>防止交换机冗余链路产生的环路，避免广播风暴占用交换机资源。基本思想是通过 <strong>生成树算法（spanning-tree algorithm，SPA）</strong> 在网络中构建一个树形结构的逻辑网络，确保到每个目标都只有一条路径，不会产生环路。</li><li><a href="https://zh.wikipedia.org/wiki/TRILL">多链接透明互联协议（Transparent Interconnection of Lots of Link，TRILL）</a>多用于<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83">数据中心（Data center）</a>。基本思路是把三层的路由能力模拟在二层实现。运行 TRILL 协议的交换机称为 RBridge，是 <strong>具有路由转发特性的网桥设备</strong> ，只不过这个路由是根据 MAC 地址来的，不是根据 IP 来的。RBridge 之间通过链路状态协议运作。</li></ul><h3 id="1-3-网络层"><a href="#1-3-网络层" class="headerlink" title="1.3 网络层"></a>1.3 网络层</h3><p>路由器中的路由表可以通过两种方式配置：静态路由和动态路由。</p><p>静态路由指路由器的路由表由手动配置，不会根据网络拓扑结构的变化而变化。</p><p>动态路由指路由器的路由表根据路由协议算法生成，随网络运行状况的变化而变化。</p><h4 id="1-3-1-动态路由算法"><a href="#1-3-1-动态路由算法" class="headerlink" title="1.3.1 动态路由算法"></a>1.3.1 动态路由算法</h4><ol><li><p>距离矢量路由算法（Distance Vector Routing）</p><p> 也称为 <a href="https://zh.wikipedia.org/wiki/%E8%B4%9D%E5%B0%94%E6%9B%BC-%E7%A6%8F%E7%89%B9%E7%AE%97%E6%B3%95">Bellman-Ford 算法</a>。基于这类算法实现的协议有：RIP、BGP 等。</p><p> 基本思路：网络中每个路由器都维护一张矢量表，这个矢量表中每一行记录了从当前位置能到达的目标路由器的最佳出口（接口）和距离（跳数）。每隔一段时间当前路由器会向所有的邻居节点发送自己的这个表，同时它也会接收每个邻居发来的它们的表。并会将邻居的表和自己的表做一个对比更新。</p><p> 优点：简单明了，加入网络的新节点能很快的与其它节点建立起联系获得补充信息。</p><p> 缺点：每次发送信息的时候，要发送整个全局路由表；收敛时间太慢。</p></li><li><p>链路状态路由算法（Link State Routing）</p><p> 基于 <a href="https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95">Dijkstra 算法</a>，以图论作为理论基础，用图来表示网络拓扑结构，用图论中的最短路径算法来计算网络间的最佳路由。基于这类算法实现的协议有：OSPF 等。</p><p> 基本思路：路由器先发现与自己相邻的节点，然后将自己与邻居节点之间的链路状态信息广播到整个网络中。同时收集网络中其他路由器广播来的链路状态信息，在本地构建出一个全网的拓扑图，并根据此图来计算当前节点到其它路由器之间的最短路径，从而生成路由表。当某台路由器与相邻节点之间的链路状态发现变化时，依然通过广播通知其他所有路由器更新网络拓补图并重新计算最短路径。</p><p> 优点：更新信息小；能快速收敛。</p></li></ol><h4 id="1-3-2-动态路由协议"><a href="#1-3-2-动态路由协议" class="headerlink" title="1.3.2 动态路由协议"></a>1.3.2 动态路由协议</h4><ol><li><p><a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E6%94%BE%E5%BC%8F%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%BC%98%E5%85%88">开放式最短路径优先（Open Shortest Path First，OSPF）</a>是一个基于链路状态路由算法的协议，由于主要用在<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9F">自治系统（Autonomous system，AS）</a>（如：数据中心）内部，用于路由决策，因而称为<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE">内部网关协议（Interior Gateway Protocol，IGP）</a>。有时 OSPF 可以发现多个最短的路径，可以在这些路径中进行负载均衡，这常被称为等价路由。</p></li><li><p><a href="https://zh.wikipedia.org/wiki/%E8%BE%B9%E7%95%8C%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE">边界网关协议（Border Gateway Protocol，BGP）</a>是一个基于距离矢量路由算法的协议，主要用在自治系统之间。BGP 又分为两类，eBGP 和 iBGP。自治系统间，边界路由器之间使用 eBGP 广播路由。内部网络也需要访问其他的自治系统，方法就是边界路由器通过运行 iBGP，使得内部的路由器能够找到到达外网目的地的最好边界路由器。</p></li></ol><p>相关设备：</p><ul><li><a href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E5%99%A8">路由器（Router）</a>不仅拥有交换机的功能，还能解析网络地址并根据路由表选择合适的 IP 路径。</li></ul><h2 id="二、常用协议"><a href="#二、常用协议" class="headerlink" title="二、常用协议"></a>二、常用协议</h2><h3 id="2-1-以太网协议头格式"><a href="#2-1-以太网协议头格式" class="headerlink" title="2.1 以太网协议头格式"></a>2.1 以太网协议头格式</h3><p><img src="/images/TCP模型协议状态机速览/以太网协议头格式.png" alt="以太网协议头格式"></p><h3 id="2-2-IPv4-协议头格式"><a href="#2-2-IPv4-协议头格式" class="headerlink" title="2.2 IPv4 协议头格式"></a>2.2 IPv4 协议头格式</h3><p><img src="/images/TCP模型协议状态机速览/IPv4协议头格式.png" alt="IPv4协议头格式"></p><h3 id="2-3-ICMP-协议头格式"><a href="#2-3-ICMP-协议头格式" class="headerlink" title="2.3 ICMP 协议头格式"></a>2.3 ICMP 协议头格式</h3><p><img src="/images/TCP模型协议状态机速览/ICMP协议头格式.png" alt="ICMP协议头格式"></p><h3 id="2-4-TCP-协议头格式"><a href="#2-4-TCP-协议头格式" class="headerlink" title="2.4 TCP 协议头格式"></a>2.4 TCP 协议头格式</h3><p><img src="/images/TCP模型协议状态机速览/TCP协议头格式.png" alt="TCP协议头格式"></p><h3 id="2-5-UDP-协议头格式"><a href="#2-5-UDP-协议头格式" class="headerlink" title="2.5 UDP 协议头格式"></a>2.5 UDP 协议头格式</h3><p><img src="/images/TCP模型协议状态机速览/UDP协议头格式.png" alt="UDP协议头格式"></p><blockquote><p>图片来源：<a href="https://nmap.org/book/tcpip-ref.html">TCP/IP Reference</a></p></blockquote><h2 id="三、TCP状态机"><a href="#三、TCP状态机" class="headerlink" title="三、TCP状态机"></a>三、TCP状态机</h2><h3 id="3-1-完整-TCP-连接和断开状态图"><a href="#3-1-完整-TCP-连接和断开状态图" class="headerlink" title="3.1 完整 TCP 连接和断开状态图"></a>3.1 完整 TCP 连接和断开状态图</h3><p><img src="/images/TCP模型协议状态机速览/完整TCP连接和断开状态图.png" alt="完整TCP连接和断开状态图"></p><blockquote><p>图片来源：<a href="http://www.tcpipguide.com/free/t_TCPOperationalOverviewandtheTCPFiniteStateMachineF-2.htm">TCP Operational Overview and the TCP Finite State Machine (FSM) 2</a></p></blockquote><h3 id="3-2-TCP-断开状态图"><a href="#3-2-TCP-断开状态图" class="headerlink" title="3.2 TCP 断开状态图"></a>3.2 TCP 断开状态图</h3><p><img src="/images/TCP模型协议状态机速览/TCP断开状态图.png" alt="TCP断开状态图"></p><blockquote><p>图片来源：<a href="http://www.tcpipguide.com/free/t_TCPConnectionTermination-2.htm">TCP Connection Termination 2</a></p></blockquote><h3 id="3-3-TCP-双方同时断开状态图"><a href="#3-3-TCP-双方同时断开状态图" class="headerlink" title="3.3 TCP 双方同时断开状态图"></a>3.3 TCP 双方同时断开状态图</h3><p><img src="/images/TCP模型协议状态机速览/TCP双方同时断开状态图.png" alt="TCP双方同时断开状态图"></p><blockquote><p>图片来源：<a href="http://www.tcpipguide.com/free/t_TCPConnectionTermination-4.htm">TCP Connection Termination 4</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP状态机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深度探索C++对象模型》读书笔记</title>
      <link href="shen-du-tan-suo-c-dui-xiang-mo-xing-du-shu-bi-ji/"/>
      <url>shen-du-tan-suo-c-dui-xiang-mo-xing-du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="一、关于对象"><a href="#一、关于对象" class="headerlink" title="一、关于对象"></a>一、关于对象</h2><p>关于菱形继承对象的内存分布，可以查看<a href="https://kibazen.cn/c-ling-xing-ji-cheng-nei-cun-bu-ju-fen-xi/">C++菱形继承内存布局分析</a>了解。</p><h2 id="二、构造函数语义学"><a href="#二、构造函数语义学" class="headerlink" title="二、构造函数语义学"></a>二、构造函数语义学</h2><ol><li><p>四种情况下，编译器会为未声明 contructor 的 class 合成一个 default constructor。</p><ul><li><p>带有 Default Constructor 的 Member Class Object</p><blockquote><p>如果一个 class 没有任何的 constructor， 但是它含有一个拥有 default constructor 的 member object，那么这个 class 的 <strong>implicit default constructor</strong> 就是 nontrivial，编译器需要为此 class 合成一个 default constructor。此 class 的 default constructor 会调用每个 member object 的 default constructor。</p></blockquote></li><li><p>带有 Default Constructor 的 Base Class</p><blockquote><p>类似的道理，一个没有任何 constructor 的 class 派生自一个带有 default constructor 的 base class，这个 derived class 的 default constructor 会被视为 nontrivial，并需要被合成出来。它将调用上一层 base class 的 default constructor （根据它们的声明次序）。对这个 derived class 来说，合成出来的 constructor 和一个明确提供的 default constructor 一样。</p></blockquote></li><li><p>带有一个Virtual Function 的 Class</p><blockquote><p>另外两种情况，也需要合成出 default constructor：</p><ol><li>class 声明（或继承）一个 virtual function。</li><li>class 派生自一个继承串链，其中有一个或更多的 virtual base classes。</li></ol></blockquote></li><li><p>带有一个 Virtual Base Class 的 Class</p><p>这些合成的 constructor 叫 <strong>implicit nontrivial default constructor</strong>。不满足上面四种情况且没有声明任何 constructor 的 class， 他们的 constructor 叫 <strong>implicit trivial default constructor</strong>，编译不会为这些 class 合成 constructor。</p><p>在合成的 default constructor 中，只有 <strong>base class subojects</strong> 和 <strong>member class objects</strong> 会被初始化。所有其他的 nonstatic data member，如整数、整数指针、整数数组等都不会被初始化。</p></li></ul></li><li><p>和 default constructor 一样，如果 class 没有声明一个 copy constructor，编译器就会隐式的声明（implicitly declared）或隐式的定义（implicitly defined）一个。copy constructor 也分为 trivial 和 nontrivial 两种。只有 nontrivial 的实体才会被合成于程序中。决定一个 copy constructor 是否为 trivial 的标准在于 class 是否展现出所谓的“bitwise copy semantic”。</p></li><li><p>四种情况下，class 不展现出“bitwise copy semantic”。</p><ul><li><p>当 class 内含一个 member object 而后者的 class 声明中有一个 copy constructor。</p></li><li><p>当 class 继承自一个 base class 而后者存在有一个 copy constructor 时（不能是被明确声明或是被合成而得）。</p></li><li><p>当 class 声明一个或多个 virtual functions 时。</p></li><li><p>当 class 派生自一个继承串链，其中有一个或多个 virtual base classes 时。</p></li></ul></li></ol><h2 id="三、Data-语意学"><a href="#三、Data-语意学" class="headerlink" title="三、Data 语意学"></a>三、Data 语意学</h2><ol><li><p>上古时期，下面代码中，类A的成员函数返回的是全局x，而不是成员变量x。这个问题已经修复了，现在总数返回成员变量x。</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">A</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>下面的代码中，val_t的类型是使用全局的val_t的定义，即x，而不是类中声明的val_t，所以需注意。</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> val_t <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">A</span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">FuncA</span><span class="token punctuation">(</span>val_t v<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(val_t) = %d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// = sizeof(int) = 4</span>    <span class="token punctuation">}</span>    <span class="token keyword">using</span> val_t <span class="token operator">=</span> <span class="token keyword">char</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">FuncB</span><span class="token punctuation">(</span>val_t v<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(val_t) = %d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// = sizeof(char) = 1</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span><span class="token punctuation">{</span>    A a<span class="token punctuation">;</span>    a<span class="token punctuation">.</span><span class="token function">FuncA</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span><span class="token function">FuncB</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 运行结果</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">sizeof(val_t) = 4sizeof(val_t) = 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h2 id="四、Function-语意学"><a href="#四、Function-语意学" class="headerlink" title="四、Function 语意学"></a>四、Function 语意学</h2><h2 id="五、构造、解构、拷贝语意学"><a href="#五、构造、解构、拷贝语意学" class="headerlink" title="五、构造、解构、拷贝语意学"></a>五、构造、解构、拷贝语意学</h2><h2 id="六、执行期语意学"><a href="#六、执行期语意学" class="headerlink" title="六、执行期语意学"></a>六、执行期语意学</h2><h2 id="七、站在对象模型的尖端"><a href="#七、站在对象模型的尖端" class="headerlink" title="七、站在对象模型的尖端"></a>七、站在对象模型的尖端</h2>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++菱形继承内存布局分析</title>
      <link href="c-ling-xing-ji-cheng-nei-cun-bu-ju-fen-xi/"/>
      <url>c-ling-xing-ji-cheng-nei-cun-bu-ju-fen-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、编译环境"><a href="#一、编译环境" class="headerlink" title="一、编译环境"></a>一、编译环境</h2><ul><li>Visual Studio 2017</li><li>G++ (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0</li><li>Clang++ 6.0.0-1ubuntu2</li></ul><hr><h2 id="二、非虚继承"><a href="#二、非虚继承" class="headerlink" title="二、非虚继承"></a>二、非虚继承</h2><h3 id="2-1-测试代码"><a href="#2-1-测试代码" class="headerlink" title="2.1 测试代码"></a>2.1 测试代码</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// filename: nonvirtual.cpp</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio&gt;</span></span><span class="token keyword">struct</span> <span class="token class-name">A</span><span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">FA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> a <span class="token operator">=</span> <span class="token number">0x1111111111111111LL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">A</span></span><span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">FB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> b <span class="token operator">=</span> <span class="token number">0x2222222222222222LL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">C</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">A</span></span><span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">FC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> c <span class="token operator">=</span> <span class="token number">0x3333333333333333LL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">D</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">B</span><span class="token punctuation">,</span> <span class="token class-name">C</span></span><span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">FD</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> d <span class="token operator">=</span> <span class="token number">0x4444444444444444LL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span><span class="token punctuation">{</span>    A a<span class="token punctuation">;</span>    B b<span class="token punctuation">;</span>    C c<span class="token punctuation">;</span>    D d<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(void*) = %zu\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(a) = %zu, &amp;a = %p\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(b) = %zu, &amp;b = %p\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(c) = %zu, &amp;c = %p\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(d) = %zu, &amp;d = %p\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-编译方式"><a href="#2-2-编译方式" class="headerlink" title="2.2 编译方式"></a>2.2 编译方式</h3><h4 id="2-2-1-VS20177"><a href="#2-2-1-VS20177" class="headerlink" title="2.2.1 VS20177"></a>2.2.1 VS20177</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">Debug x64<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-2-2-G"><a href="#2-2-2-G" class="headerlink" title="2.2.2 G++"></a>2.2.2 G++</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">g++ -std<span class="token operator">=</span>c++11 -ggdb -o gcc-nv.out nonvirtual.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-2-3-Clang"><a href="#2-2-3-Clang" class="headerlink" title="2.2.3 Clang++"></a>2.2.3 Clang++</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">clang++ -std<span class="token operator">=</span>c++11 -ggdb -o clang-nv.out nonvirtual.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-3-执行结果"><a href="#2-3-执行结果" class="headerlink" title="2.3 执行结果"></a>2.3 执行结果</h3><h4 id="2-3-1-VS2017"><a href="#2-3-1-VS2017" class="headerlink" title="2.3.1 VS2017"></a>2.3.1 VS2017</h4><ol><li><p>执行结果</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">sizeof(void*) = 8sizeof(a) = 16, &amp;a = 000000204193F818sizeof(b) = 24, &amp;b = 000000204193F848sizeof(c) = 24, &amp;c = 000000204193F878sizeof(d) = 56, &amp;d = 000000204193F8A8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>类D的内存布局</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">+----------------+|                || +------------+ || |            | |      +---------+| | +--------+ | |      |         || | | A.vptr+----------&gt;+ A::FA() || | | A::a   | | |      | B::FB() || | +--------+ | |      | D::FD() || |   B::b     | |      |         || +------------+ |      +---------+|                || +------------+ || |            | |      +---------+| | +--------+ | |      |         || | | A.vptr+----------&gt;+ A::FA() || | | A::a   | | |      | C::FC() || | +--------+ | |      |         || |   C::c     | |      +---------+| +------------+ ||                ||     D::d       ||                |+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>类D的内存DUMP</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">0x000000204193F8A8  00007ff7c032b1e8 1111111111111111 2222222222222222 00007ff7c032ae18 1111111111111111 33333333333333330x000000204193F8D8  44444444444444440x00007FF7C032B1E8  00007ff7c0321302 00007ff7c03211b8 00007ff7c032105a0x00007FF7C032AE18  00007ff7c0321302 00007ff7c03212e4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="2-3-2-G"><a href="#2-3-2-G" class="headerlink" title="2.3.2 G++"></a>2.3.2 G++</h4><ol><li><p>执行结果</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">sizeof(void*) = 8sizeof(a) = 16, &amp;a = 0x7fffffffe350sizeof(b) = 24, &amp;b = 0x7fffffffe360sizeof(c) = 24, &amp;c = 0x7fffffffe380sizeof(d) = 56, &amp;d = 0x7fffffffe3a0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>类D的内存布局</p><p> 和VS2017的结果类似。</p></li><li><p>类D的内存DUMP</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">(gdb) x /7a &amp;d0x7fffffffe3a0: 0x555555755ca8 &lt;_ZTV1D+16&gt;      0x11111111111111110x7fffffffe3b0: 0x2222222222222222      0x555555755cd0 &lt;_ZTV1D+56&gt;0x7fffffffe3c0: 0x1111111111111111      0x33333333333333330x7fffffffe3d0: 0x4444444444444444(gdb) x /3a 0x555555755ca80x555555755ca8 &lt;_ZTV1D+16&gt;:     0x555555554b96 &lt;A::FA()&gt;        0x555555554ba2 &lt;B::FB()&gt;0x555555755cb8 &lt;_ZTV1D+32&gt;:     0x555555554bba &lt;D::FD()&gt;(gdb) x /2a 0x555555755cd00x555555755cd0 &lt;_ZTV1D+56&gt;:     0x555555554b96 &lt;A::FA()&gt;        0x555555554bae &lt;C::FC()&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="2-3-3-Clang"><a href="#2-3-3-Clang" class="headerlink" title="2.3.3 Clang++"></a>2.3.3 Clang++</h4><ol><li><p>执行结果</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">sizeof(void*) = 8sizeof(a) = 16, &amp;a = 0x7fffffffe3c0sizeof(b) = 24, &amp;b = 0x7fffffffe3a8sizeof(c) = 24, &amp;c = 0x7fffffffe390sizeof(d) = 56, &amp;d = 0x7fffffffe358<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>类D的内存布局</p><p> 和VS2017的结果类似。</p></li><li><p>类D的内存DUMP</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">(gdb) x /7a &amp;d0x7fffffffe358: 0x400a88 &lt;_ZTV1D+16&gt;    0x11111111111111110x7fffffffe368: 0x2222222222222222      0x400ab0 &lt;_ZTV1D+56&gt;0x7fffffffe378: 0x1111111111111111      0x33333333333333330x7fffffffe388: 0x4444444444444444(gdb) x /3a 0x400a880x400a88 &lt;_ZTV1D+16&gt;:   0x400880 &lt;A::FA()&gt;      0x400890 &lt;B::FB()&gt;0x400a98 &lt;_ZTV1D+32&gt;:   0x4008b0 &lt;D::FD()&gt;(gdb) x /2a 0x400ab00x400ab0 &lt;_ZTV1D+56&gt;:   0x400880 &lt;A::FA()&gt;      0x4008a0 &lt;C::FC()&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><hr><h2 id="三、虚继承"><a href="#三、虚继承" class="headerlink" title="三、虚继承"></a>三、虚继承</h2><h3 id="3-1-测试代码"><a href="#3-1-测试代码" class="headerlink" title="3.1 测试代码"></a>3.1 测试代码</h3><p>与<a href="#二非虚继承">非虚拟继承</a>的测试代码类似，只是将非虚拟继承改成了虚拟继承。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// filename: virtual.cpp</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio&gt;</span></span><span class="token keyword">struct</span> <span class="token class-name">A</span><span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">FA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> a <span class="token operator">=</span> <span class="token number">0x1111111111111111LL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">A</span></span><span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">FB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> b <span class="token operator">=</span> <span class="token number">0x2222222222222222LL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">C</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">A</span></span><span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">FC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> c <span class="token operator">=</span> <span class="token number">0x3333333333333333LL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">D</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">B</span><span class="token punctuation">,</span> <span class="token class-name">C</span></span><span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">FD</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> d <span class="token operator">=</span> <span class="token number">0x4444444444444444LL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span><span class="token punctuation">{</span>    A a<span class="token punctuation">;</span>    B b<span class="token punctuation">;</span>    C c<span class="token punctuation">;</span>    D d<span class="token punctuation">;</span>    <span class="token keyword">auto</span> pba <span class="token operator">=</span> <span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span>A<span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> pda <span class="token operator">=</span> <span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span>A<span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> pdb <span class="token operator">=</span> <span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span>B<span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(void*) = %zu\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(a) = %zu, &amp;a = %p\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(b) = %zu, &amp;b = %p\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(c) = %zu, &amp;c = %p\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(d) = %zu, &amp;d = %p\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-编译方式"><a href="#3-2-编译方式" class="headerlink" title="3.2 编译方式"></a>3.2 编译方式</h3><h4 id="3-2-1-vs2017"><a href="#3-2-1-vs2017" class="headerlink" title="3.2.1 vs2017"></a>3.2.1 vs2017</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">Debug x64<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-2-2-G"><a href="#3-2-2-G" class="headerlink" title="3.2.2 G++"></a>3.2.2 G++</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">g++ -std<span class="token operator">=</span>c++11 -ggdb -o gcc-v.out virtual.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-2-3-Clang"><a href="#3-2-3-Clang" class="headerlink" title="3.2.3 Clang++"></a>3.2.3 Clang++</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">clang++ -std<span class="token operator">=</span>c++11 -ggdb -o clang-v.out virtual.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-3-执行结果"><a href="#3-3-执行结果" class="headerlink" title="3.3 执行结果"></a>3.3 执行结果</h3><p>VS2017的执行结果与G++和Clang++不同。</p><h4 id="3-3-1-VS2017"><a href="#3-3-1-VS2017" class="headerlink" title="3.3.1 VS2017"></a>3.3.1 VS2017</h4><ol><li><p>执行结果</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">sizeof(void*) = 8sizeof(a) = 16, &amp;a = 00000002F65FF658sizeof(b) = 40, &amp;b = 00000002F65FF688sizeof(c) = 40, &amp;c = 00000002F65FF6C8sizeof(d) = 72, &amp;d = 00000002F65FF710<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>对类B的分析</p><ul><li><p>类B的内存分布</p>  <pre class="line-numbers language-text" data-language="text"><code class="language-text">                +--------------+                |              |+---------+     | +----------+ || B::FB() +&lt;--------+B.vptr   | |      +--------------------++---------+     | | B.offset+--------&gt;+ offset2ptr    = -8 |                | | B::b     | |      | offset2A.vptr = 16 |                | +----------+ |      +--------------------+                |              |+---------+     | +----------+ || A::FA() +&lt;-------+A.vptr   | |+---------+     | | A::a     | |                | +----------+ |                |              |                +--------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>类B的内存DUMP</p>  <pre class="line-numbers language-text" data-language="text"><code class="language-text">0x00000002F65FF688  00007ff6cd4eadb0 00007ff6cd4eb1e0 2222222222222222 00007ff6cd4eadc8 11111111111111110x00007FF6CD4EADB0  00007ff6cd4e11b8 &lt;B::FB()&gt;0x00007FF6CD4EB1E0  fffffff8 000000100x00007FF6CD4EADC8  00007ff6cd4e1302 &lt;A::FA()&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>对类D的分析</p><ul><li><p>类D的内存布局</p><p>  offset中，offset2ptr的数据是没使用的。</p>  <pre class="line-numbers language-text" data-language="text"><code class="language-text">                +--------------+                |              |+---------+     | +----------+ || B::FB() +&lt;-------+B.vptr   | |      +--------------------+| D::FD() |     | | B.offset+--------&gt;+ offset2ptr    = -8 |+---------+     | | B::b     | |      | offset2A.vptr = 48 |                | +----------+ |      | offset2vptr   = -8 |                |              |      | offset2C.vptr = 24 |+---------+     | +----------+ |      +--------------------+| C::FC() +&lt;-------+C.vptr   | |      +--------------------++---------+     | | C.offset+--------&gt;+ offset2vptr   = -8 |                | | C::c     | |      | offset2A.vptr = 24 |                | +----------+ |      +--------------------+                |              |                |   D::d       |                |              |+---------+     | +----------+ || A::FA() +&lt;-------+A.vptr   | |+---------+     | | A::a     | |                | +----------+ |                |              |                +--------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>类D的内存DUMP</p>  <pre class="line-numbers language-text" data-language="text"><code class="language-text">0x00000002F65FF710  00007ff6cd4eb098 00007ff6cd4eac10 2222222222222222 00007ff6cd4eae70 00007ff6cd4eac18 33333333333333330x00000002F65FF740  4444444444444444 00007ff6cd4eae90 11111111111111110x00007FF6CD4EB098  00007ff6cd4e11b8 &lt;B::FB()&gt; 00007ff6cd4e105a &lt;D::FD()&gt;0x00007FF6CD4EAC10  fffffff8 00000030 fffffff8 000000180x00007FF6CD4EAE70  00007ff6cd4e12e4 &lt;C::FC()&gt;0x00007FF6CD4EAC18  fffffff8 000000180x00007FF6CD4EAE90  00007ff6cd4e1302 &lt;A::FA()&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ol><h4 id="3-3-2-G"><a href="#3-3-2-G" class="headerlink" title="3.3.2 G++"></a>3.3.2 G++</h4><ol><li><p>执行结果</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">sizeof(void*) = 8sizeof(a) = 16, &amp;a = 0x7fffffffe360sizeof(b) = 32, &amp;b = 0x7fffffffe370sizeof(c) = 32, &amp;c = 0x7fffffffe390sizeof(d) = 56, &amp;d = 0x7fffffffe3b0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>对类B的分析</p><ul><li><p>类B的内存DUMP</p></li><li><p>类B的内存布局</p>  <pre class="line-numbers language-text" data-language="text"><code class="language-text">+------------+|            || +--------+ |     +---------+| | B.vptr+-------&gt;+ B::FB() || | B::b   | |     +---------+| +--------+ || +--------| |     +---------+| | A.vptr+-------&gt;+ A::FA() || | A::a   | |     +---------+| +--------+ ||            |+------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>  <pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt;&gt;&gt; x /4a &amp;b0x7fffffffe370: 0x555555755cc8 &lt;_ZTV1B+24&gt;      0x22222222222222220x7fffffffe380: 0x555555755ce8 &lt;_ZTV1B+56&gt;      0x1111111111111111&gt;&gt;&gt; x /1a 0x555555755cc80x555555755cc8 &lt;_ZTV1B+24&gt;:     0x555555554dc4 &lt;B::FB()&gt;&gt;&gt;&gt; x /1a 0x555555755ce80x555555755ce8 &lt;_ZTV1B+56&gt;:     0x555555554db8 &lt;A::FA()&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>对类D的分析</p><ul><li><p>类D的内存布局</p>  <pre class="line-numbers language-text" data-language="text"><code class="language-text">+----------------+|                || +------------+ || |            | || | +--------+ | |      +---------+| | | B.vptr+----------&gt;+ B::FB() || | | B::b   | | |      | D::FD() || | +--------+ | |      +---------+| | +--------| | |      +---------+| | | C.vptr+----------&gt;+ C::FC() || | | C::c   | | |      +---------+| | +--------+ | || |            | || +------------+ ||                ||     D::d       ||                ||   +--------+   |      +---------+|   | A.vptr+----------&gt;+ A::FA() ||   | A::a   |   |      +---------+|   +--------+   ||                |+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>类D的内存DUMP</p>  <pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt;&gt;&gt; x /7a &amp;d0x7fffffffe3b0: 0x555555755b58 &lt;_ZTV1D+24&gt;      0x22222222222222220x7fffffffe3c0: 0x555555755b80 &lt;_ZTV1D+64&gt;      0x33333333333333330x7fffffffe3d0: 0x4444444444444444      0x555555755ba0 &lt;_ZTV1D+96&gt;0x7fffffffe3e0: 0x1111111111111111&gt;&gt;&gt; x /2a 0x555555755b580x555555755b58 &lt;_ZTV1D+24&gt;:     0x555555554dc4 &lt;B::FB()&gt;        0x555555554ddc &lt;D::FD()&gt;&gt;&gt;&gt; x /1a 0x555555755b800x555555755b80 &lt;_ZTV1D+64&gt;:     0x555555554dd0 &lt;C::FC()&gt;&gt;&gt;&gt; x /1a 0x555555755ba00x555555755ba0 &lt;_ZTV1D+96&gt;:     0x555555554db8 &lt;A::FA()&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ol><h4 id="3-3-3-Clang"><a href="#3-3-3-Clang" class="headerlink" title="3.3.3 Clang++"></a>3.3.3 Clang++</h4><p>Clang++的结果和G++的一样。</p><ol><li><p>执行结果</p> <pre class="line-numbers language-text" data-language="text"><code class="language-text">sizeof(void*) = 8sizeof(a) = 16, &amp;a = 0x7fffffffe3c0sizeof(b) = 32, &amp;b = 0x7fffffffe3a0sizeof(c) = 32, &amp;c = 0x7fffffffe380sizeof(d) = 56, &amp;d = 0x7fffffffe348<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>对类B的分析</p><ul><li><p>类B的内存布局</p>  <pre class="line-numbers language-text" data-language="text"><code class="language-text">+------------+|            || +--------+ |     +---------+| | B.vptr+-------&gt;+ B::FB() || | B::b   | |     +---------+| +--------+ || +--------| |     +---------+| | A.vptr+-------&gt;+ A::FA() || | A::a   | |     +---------+| +--------+ ||            |+------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>类B的内存DUMP</p>  <pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt;&gt;&gt; x /4a &amp;b0x7fffffffe3a0: 0x400b60 &lt;_ZTV1B+24&gt;    0x22222222222222220x7fffffffe3b0: 0x400b80 &lt;_ZTV1B+56&gt;    0x1111111111111111&gt;&gt;&gt; x /1a 0x400b600x400b60 &lt;_ZTV1B+24&gt;:   0x400960 &lt;B::FB()&gt;&gt;&gt;&gt; x /1a 0x400b800x400b80 &lt;_ZTV1B+56&gt;:   0x400950 &lt;A::FA()&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>对类D的分析</p><ul><li><p>类D的内存布局</p>  <pre class="line-numbers language-text" data-language="text"><code class="language-text">+----------------+|                || +------------+ || |            | || | +--------+ | |      +---------+| | | B.vptr+----------&gt;+ B::FB() || | | B::b   | | |      | D::FD() || | +--------+ | |      +---------+| | +--------| | |      +---------+| | | C.vptr+----------&gt;+ C::FC() || | | C::c   | | |      +---------+| | +--------+ | || |            | || +------------+ ||                ||     D::d       ||                ||   +--------+   |      +---------+|   | A.vptr+----------&gt;+ A::FA() ||   | A::a   |   |      +---------+|   +--------+   ||                |+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>类D的内存DUMP</p>  <pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt;&gt;&gt; x /7a &amp;d0x7fffffffe348: 0x400c60 &lt;_ZTV1D+24&gt;    0x22222222222222220x7fffffffe358: 0x400c88 &lt;_ZTV1D+64&gt;    0x33333333333333330x7fffffffe368: 0x4444444444444444      0x400ca8 &lt;_ZTV1D+96&gt;0x7fffffffe378: 0x1111111111111111&gt;&gt;&gt; x /2a 0x400c600x400c60 &lt;_ZTV1D+24&gt;:   0x400960 &lt;B::FB()&gt;      0x400a00 &lt;D::FD()&gt;&gt;&gt;&gt; x /1a 0x400c880x400c88 &lt;_ZTV1D+64&gt;:   0x400970 &lt;C::FC()&gt;&gt;&gt;&gt; x /1a 0x400ca80x400ca8 &lt;_ZTV1D+96&gt;:   0x400950 &lt;A::FA()&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ol><hr><h2 id="四、分析结论"><a href="#四、分析结论" class="headerlink" title="四、分析结论"></a>四、分析结论</h2><h3 id="4-1-结论1"><a href="#4-1-结论1" class="headerlink" title="4.1 结论1"></a>4.1 结论1</h3><p>菱形非虚继承时 VS2017 、 G++ 7.5 和 Clang++ 6 编译生成的类的内存布局相同。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+----------------+|                || +------------+ || |            | |      +---------+| | +--------+ | |      |         || | | A.vptr+----------&gt;+ A::FA() || | | A::a   | | |      | B::FB() || | +--------+ | |      | D::FD() || |   B::b     | |      |         || +------------+ |      +---------+|                || +------------+ || |            | |      +---------+| | +--------+ | |      |         || | | A.vptr+----------&gt;+ A::FA() || | | A::a   | | |      | C::FC() || | +--------+ | |      |         || |   C::c     | |      +---------+| +------------+ ||                ||     D::d       ||                |+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-结论2"><a href="#4-2-结论2" class="headerlink" title="4.2 结论2"></a>4.2 结论2</h3><p>菱形虚拟继承时 VS2017 编译生成类的内存布局与 G++ 7.5 和 Clang++ 6 的结果不同。</p><ul><li><p>VS2017生成的类的内存布局：</p>  <pre class="line-numbers language-text" data-language="text"><code class="language-text">                +--------------+                |              |+---------+     | +----------+ || B::FB() +&lt;--------+B.vptr   | |      +--------------------+| D::FD() |     | | B.offset+--------&gt;+ offset2ptr    = -8 |+---------+     | | B::b     | |      | offset2A.vptr = 48 |                | +----------+ |      | offset2vptr   = -8 |                |              |      | offset2C.vptr = 24 |+---------+     | +----------+ |      +--------------------+| C::FC() +&lt;-------+C.vptr   | |      +--------------------++---------+     | | C.offset+--------&gt;+ offset2vptr   = -8 |                | | C::c     | |      | offset2A.vptr = 24 |                | +----------+ |      +--------------------+                |              |                |   D::d       |                |              |+---------+     | +----------+ || A::FA() +&lt;-------+A.vptr   | |+---------+     | | A::a     | |                | +----------+ |                |              |                +--------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>G++ 7.5 和 Clang++ 6 生成的类的内存布局相同：</p>  <pre class="line-numbers language-text" data-language="text"><code class="language-text">+----------------+|                || +------------+ || |            | || | +--------+ | |      +---------+| | | B.vptr+----------&gt;+ B::FB() || | | B::b   | | |      | D::FD() || | +--------+ | |      +---------+| | +--------| | |      +---------+| | | C.vptr+----------&gt;+ C::FC() || | | C::c   | | |      +---------+| | +--------+ | || |            | || +------------+ ||                ||     D::d       ||                ||   +--------+   |      +---------+|   | A.vptr+----------&gt;+ A::FA() ||   | A::a   |   |      +---------+|   +--------+   ||                |+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> 逆向工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《左耳听风》学习笔记</title>
      <link href="zuo-er-ting-feng-xue-xi-bi-ji/"/>
      <url>zuo-er-ting-feng-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="一、程序员如何用技术变现"><a href="#一、程序员如何用技术变现" class="headerlink" title="一、程序员如何用技术变现"></a>一、程序员如何用技术变现</h2><h3 id="（一）一些学习经验"><a href="#（一）一些学习经验" class="headerlink" title="（一）一些学习经验"></a>（一）一些学习经验</h3><ol><li>要去经历大多数人经历不到的，要把学习时间花在那些比较难的地方。</li><li>要写文章就要写没有人写过的，或是别人写过，但我能写得更好的。</li><li>更重要的是，技术和知识完全是可以变现的。</li></ol><h3 id="（二）如何保持竞争力"><a href="#（二）如何保持竞争力" class="headerlink" title="（二）如何保持竞争力"></a>（二）如何保持竞争力</h3><p>一个是技术和技能的领先，二是对技术本质和趋势的敏感度。</p><h3 id="（三）如何让自己的技能变现"><a href="#（三）如何让自己的技能变现" class="headerlink" title="（三）如何让自己的技能变现"></a>（三）如何让自己的技能变现</h3><h4 id="1-千里之行，积于跬步"><a href="#1-千里之行，积于跬步" class="headerlink" title="1.千里之行，积于跬步"></a>1.千里之行，积于跬步</h4><p>掌握大多数人不能掌握的技能或技术，需要你更多地学习，并要有更多的别人没有的经验和经历。</p><h4 id="2-关注有价值的东西"><a href="#2-关注有价值的东西" class="headerlink" title="2.关注有价值的东西"></a>2.关注有价值的东西</h4><ul><li>关于市场需求。你要看清市场，就需要看看各个公司都在做什么，他们的难题是什么。</li><li>关于技术趋势。要看一个新的技术是否顺应技术发展趋势，你需要将一些老技术的本质吃得很透。</li></ul><p>因此，在学习技术的过程一定要多问自己两个问题：</p><ul><li>一，这个技术解决什么问题？为什么别的同类技术做不到？</li><li>二，为什么是这样解决的？有没有更好的方式？</li></ul><p>另外，还有一个简单的判断方法，如果一个新的技术顺应技术发展趋势，那么在这个新的技术出现时，后面一定会有大型的商业公司支持，这类公司支持得越多，就说明你越需要关注。</p><h4 id="3-找到能体现价值的地方"><a href="#3-找到能体现价值的地方" class="headerlink" title="3.找到能体现价值的地方"></a>3.找到能体现价值的地方</h4><ul><li>在一家高速发展的公司中，技术人员的价值可以达到最大化。</li><li>在一家大公司中，技术架构和业务已经定型，基本上没有什么太多的事可以做的。而且对于已经发展起来的大公司来说，往往稳定的重要性超过了创新。</li><li>而刚起步的公司，业务还没有跑顺，公司的主要精力会放在业务拓展上，这个时候也不太需要高精尖的技术，所以，技术人员的价值也体现不出来。</li><li>比较好的成长路径是，先进入大公司学习大公司的技术和成功的经验方法，然后再找到高速成长的公司，这样你就可以实现自己更多的价值。</li></ul><h4 id="4-动手能力很重要"><a href="#4-动手能力很重要" class="headerlink" title="4.动手能力很重要"></a>4.动手能力很重要</h4><ul><li>在解决任何一个具体问题的时候，有没有动手能力就成为了关键。</li><li>代码里全是细节，细节是魔鬼，只有了解了细节，你才能提出更好或是更靠谱、可以落地的解决方案。而不是一些笼统和模糊的东西。</li></ul><h4 id="5-关注技术付费点"><a href="#5-关注技术付费点" class="headerlink" title="5.关注技术付费点"></a>5.关注技术付费点</h4><p>技术付费点基本体现在两个地方:</p><ul><li>能帮别人“挣钱”的地方；</li><li>能帮别人“省钱”的地方。</li></ul><h4 id="6-提升自己的能力和经历"><a href="#6-提升自己的能力和经历" class="headerlink" title="6.提升自己的能力和经历"></a>6.提升自己的能力和经历</h4><ul><li>参与知名的开源项目。</li><li>成为公司核心项目的开发人员。</li></ul><h4 id="7-找到有价值的信息源"><a href="#7-找到有价值的信息源" class="headerlink" title="7.找到有价值的信息源"></a>7.找到有价值的信息源</h4><ul><li>如果你的信息来自朋友圈、微博、知乎、百度或是今日头条，那么我觉得你完蛋了。这些渠道有价值的信息不多。</li><li>用好 Google，比如你在 Google 搜索引擎里输入 “XXX Best Practice”，或是 “Best programming resource”……你就会找到很多。</li></ul><h4 id="8-输出观点和价值观"><a href="#8-输出观点和价值观" class="headerlink" title="8.输出观点和价值观"></a>8.输出观点和价值观</h4><h4 id="9-朋友圈很重要"><a href="#9-朋友圈很重要" class="headerlink" title="9.朋友圈很重要"></a>9.朋友圈很重要</h4><p>优质的朋友圈基本上都有这样的特性：</p><ul><li>这些人都比较有想法、有观点，经验也比较丰富；</li><li>这些人涉猎的面比较广；</li><li>这些人都有或多或少的成功；</li><li>这些人都是喜欢折腾喜欢搞事的人；</li><li>这些人都对现状有些不满，并想做一些改变；</li><li>这些人都有一定的影响力。</li></ul><p>最后有个关键的问题是，物以类聚，人以群分。如果你不做到这些，你怎么能进入到这样的朋友圈呢？</p><p>总之，就一句话，<strong>会挣钱的人一定是会投资的人。我一直认为，最宝贵的财富并不是钱，而是你的时间，时间比钱更宝贵，因为钱你不用还在那里，而时间你不用就浪费掉了。你把你的时间投资在哪些地方，就意味着你未来会走什么样的路。所以，利用好你的时间，投到一些有意义的地方吧。</strong></p><h3 id="（四）如何技术变现套路总结-来自评论"><a href="#（四）如何技术变现套路总结-来自评论" class="headerlink" title="（四）如何技术变现套路总结(来自评论)"></a>（四）如何技术变现套路总结(来自评论)</h3><ol><li>程序员用手艺、技术养活自己，不依靠公司；</li><li>提高工作效率，去研究那些难的，公司内外的核心技术；</li><li>注重输出，输出技术、价值观，帮助更多的人，提高影响力。</li></ol><hr><h2 id="二、何为技术领导力"><a href="#二、何为技术领导力" class="headerlink" title="二、何为技术领导力"></a>二、何为技术领导力</h2><h3 id="（一）人类社会的发展阶段"><a href="#（一）人类社会的发展阶段" class="headerlink" title="（一）人类社会的发展阶段"></a>（一）人类社会的发展阶段</h3><ol><li>野蛮开采。这个阶段的主要特点是资源过多，只需要开采就好了。</li><li>资源整合。在这个阶段，资源已经被不同的人给占有了，但是需要对资源整合优化，提高利用率。这时通过管理手段就能实现。</li><li>精耕细作。这个阶段基本上是对第二阶段的精细化运作，并且通过科学的手段来达到。</li><li>发明创造。在这个阶段，人们利用已有不足的资源来创造更好的资源，并替代已有的马上要枯竭的资源。这就需要采用高科技来达到了。</li></ol><p>这也是为什么像亚马逊、Facebook 这样的公司，最终都会去发展自己的核心技术，提高自己的技术领导力，从早期的业务型公司转变成为技术型公司的原因。那些本来技术很好的公司，比如雅虎、百度，在发展到一定程度时，将自己定位成了一个广告公司，然后开始变味、走下坡路。</p><h3 id="（二）几次工业革命改变本质"><a href="#（二）几次工业革命改变本质" class="headerlink" title="（二）几次工业革命改变本质"></a>（二）几次工业革命改变本质</h3><ol><li>关键技术。蒸汽机、电、化工、原子能、炼钢、计算机，如果只看这些东西的话，似乎没什么用。但这些核心技术的突破，可以让我们建造很多更牛的工具，而这些工具能让人类干出以前干不出来的事。</li><li>自动化。这其中最重要的事就是自动化。三次革命中最重要的事就是用机器来自动化。通信、交通、军事、教育、金融等各个领域都是在拼命地自动化，以提高效率——用更低的成本来完成更多的事。</li><li>解放生产力。把人从劳动密集型的工作中解放出来，去做更高层次的知识密集型的工作。说得难听一点，就是取代人类，让人失业。值得注意的是，今天的 AI 在开始取代人类的知识密集型的工作……</li></ol><h3 id="（三）技术领导力"><a href="#（三）技术领导力" class="headerlink" title="（三）技术领导力"></a>（三）技术领导力</h3><p>回顾几次工业革命改变本质，我们可以看到的技术领导力是：</p><ul><li>尊重技术，追求核心基础技术。</li><li>追逐自动化的高效率的工具和技术，同时避免无效率的组织架构和管理。</li><li>解放生产力，追逐人效的提高。开发抽象和高质量的可以重用的技术组件。</li><li>坚持高于社会主流的技术标准和要求。</li></ul><h3 id="（四）如何拥有技术领导力"><a href="#（四）如何拥有技术领导力" class="headerlink" title="（四）如何拥有技术领导力"></a>（四）如何拥有技术领导力</h3><p>作为一个软件工程师怎样才算是拥有“技术领导力”：</p><ul><li>能够发现问题。能够发现现有方案的问题。</li><li>能够提供解决问题的思路和方案，并能比较这些方案的优缺点。</li><li>能够做出正确的技术决定。用什么样的技术、什么解决方案、怎样实现来完成一个项目。</li><li>能够用更优雅，更简单，更容易的方式来解决问题。</li><li>能够提高代码或软件的扩展性、重用性和可维护性。</li><li>能够用正确的方式管理团队。所谓正确的方式，一方面是，让正确的人做正确的事，并发挥每个人的潜力；另一方面是，可以提高团队的生产力和人效，找到最有价值的需求，用最少的成本实现之。并且，可以不断地提高自身和团队的标准。</li><li>创新能力。能够使用新的方法新的方式解决问题，追逐新的工具和技术。</li></ul><p>总结一下，就是：</p><ul><li>扎实的基础技术；</li><li>非同一般的学习能力；</li><li>坚持做正确的事；</li><li>不断提高对自己的要求标准；</li></ul><hr><h2 id="三、如何才能拥有技术领导力"><a href="#三、如何才能拥有技术领导力" class="headerlink" title="三、如何才能拥有技术领导力"></a>三、如何才能拥有技术领导力</h2><h3 id="（一）、吃透基础技术"><a href="#（一）、吃透基础技术" class="headerlink" title="（一）、吃透基础技术"></a>（一）、吃透基础技术</h3><p>基础技术是各种上层技术共同的基础。吃透基础技术是为了更好地理解程序的运行原理，并基于这些基础技术进化出更优化的产品。</p><p>基础技术主要分成两个部分：编程和系统。</p><p>编程部分</p><ul><li>C语言</li><li>编程范式</li><li>算法和数据结构</li></ul><p>系统部分</p><ul><li>计算机系统原理</li><li>操作系统原理和基础</li><li>网络基础</li><li>数据库原理</li><li>分布式技术架构</li></ul><h3 id="（二）、提高学习能力"><a href="#（二）、提高学习能力" class="headerlink" title="（二）、提高学习能力"></a>（二）、提高学习能力</h3><p>所谓学习能力，就是能够很快地学习新技术，又能在关键技术上深入的能力。只有在掌握了上述的基础原理之上，你才能拥有好的学习能力。如何提高呢？</p><ul><li>学习的信息源。信息源很重要，有好的信息源就可以更快速地获取有价值的信息，并提升学习效率。常见的信息源有 Google 等搜索引擎，Stack Overflow、Quora 等社区，图书，API 文档，论文和博客等。</li><li>与高手交流。程序员可以通过技术社区以及参加技术会议与高手交流，也可以通过参加开源项目来和高手切磋。</li><li>举一反三的思考。比如，了解了操作系统的缓存和网页缓存以后，你要思考其相同点和不同点。</li><li>不怕困难的态度。</li><li>开放的心态。实现一个目的通常有多种办法。带有开放的心态，不拘泥于一个平台、一种语言，往往能带来更多思考，也能得到更好的结果。而且，能在不同的方法和方案间做比较，比较它们的优缺点，那么你会知道在什么样的场景下用什么样的方案，你就会比一般人能够有更全面和更完整的思路。</li></ul><h3 id="（三）、坚持做正确的事"><a href="#（三）、坚持做正确的事" class="headerlink" title="（三）、坚持做正确的事"></a>（三）、坚持做正确的事</h3><p>做正确的事，比用正确的方式做事更重要，因为这样才始终会向目的地靠拢。哪些是正确的事呢？</p><ul><li>提高效率的事。你要学习和掌握良好的时间管理方式，管理好自己的时间，能显著提高自己的效率。</li><li>自动化的事。程序员要充分利用自己的职业特质，当看见有可以自动化的步骤时，编写程序来自动化操作，可以显著提高效率。</li><li>掌握前沿技术的事。掌握前沿的技术，有利于拓展自己的眼界，也有利于找到更好的工作。需要注意的是，有些技术虽然当下很火，但未必前沿，而是因为它比较易学易用，或者性价比高。由于学习一门技术需要花费不少时间，你应该选择自己最感兴趣的，有的放矢地去学习。</li><li>知识密集型的事。知识密集型是相对于劳动密集型来说的。基本上，劳动密集型的事都能通过程序和机器来完成，而知识密集型的事却仍需要人来完成，所以人的价值此时就显现出来了。</li><li>技术驱动的事。不仅是指用程序驱动的事，而且还包括一切技术改变生活的事。比如自动驾驶、火星登陆等。就算自己一时用不着，你也要了解这些，以便将来这些技术来临时能适应它们。</li></ul><h4 id="（四）、高标准要求自己"><a href="#（四）、高标准要求自己" class="headerlink" title="（四）、高标准要求自己"></a>（四）、高标准要求自己</h4><p>只有不断地提高标准，你才可能越走越高，所以，要以高标准要求自己，不断地反思、总结和审视自己，才能够提升自己。</p><ul><li>Google 的自我评分卡。</li><li>敏锐的技术嗅觉。这是一个相对综合的能力，你需要充分利用信息源，GET 到新的技术动态，并通过参与技术社区的讨论，丰富自己了解技术的角度。</li><li>强调实践，学以致用。学习知识，一定要实际用一用，可以是工作中的项目，也可以是自己的项目，不仅有利于吸收理解，更有利于深入到技术的本质。并可以与现有技术对比一下，同样的问题，用新技术解决有什么不同，带来了哪些优势，还有哪些有待改进的地方。</li><li>Lead by Example。永远在编程。不写代码，你就对技术细节不敏感，你无法做出可以实践的技术决策和方案。</li></ul><hr><h2 id="四、如何成为一个大家愿意追随的-Leader"><a href="#四、如何成为一个大家愿意追随的-Leader" class="headerlink" title="四、如何成为一个大家愿意追随的 Leader"></a>四、如何成为一个大家愿意追随的 Leader</h2><h3 id="（一）、Leader-和-Boss-的不同"><a href="#（一）、Leader-和-Boss-的不同" class="headerlink" title="（一）、Leader 和 Boss 的不同"></a>（一）、Leader 和 Boss 的不同</h3><p>再或者用通俗的话说，Leader 是大家跟我一起上，而 Boss 则是大家给我上，一个在团队的前面，一个在团队的后面。</p><p>具体来说，这两者的不同点如下：</p><ul><li><p>Boss 是驱动员工，Leader 是指导员工。</p><p>  在面对项目的时候，Boss 制定时间计划，并且推动（push）和鞭策员工完成工作，而 Leader 则是和员工一起讨论工作细节，指导员工关注工作的重点，和员工一起规划出（work out）工作的方向和计划，并且在工作中和员工一起解决细节难题，帮助员工完成工作。</p></li><li><p>Boss制造畏惧，Leader制造热情。</p><p>  Boss 在工作中是用工作职位级别压人，用你的绩效考核来制造威慑，让员工畏惧他，从而推行工作。而 Leader 是通过描绘远景，制造激动人心的目标来鼓舞和触发团队的热情和斗志。</p></li><li><p>Boss面对错误喜欢使用人事惩罚的手段，而Leader面对错误喜欢寻找解决问题的技术或管理方法。</p><p>  惩罚员工和解决问题完全是两码事，Boss因为并不懂技术也并不懂问题的细节，所以他们只能使用惩罚这样的手段，而Leader通常是喜欢解决问题的技术型人才，所以，他们会深入技术细节，从技术上找到既治标又治本的技术方案或管理方式。</p></li><li><p>Boss 只是知道怎么做，而 Leader 则是展示怎么做。</p><p>  一个好 Leader 的最大特点就是 Lead by Example，以身作则，用身教而不是言传。而 Boss 只是在说教，总是在大道理上说的一套又一套，但从来不管技术细节。</p></li><li><p>Boss 是用人，而 Leader 是发展人。</p><p>  Boss 不关心人的发展，把人当成劳动力。而 Leader 则会看到人的潜力和特长，通过授权、指导和给员工制定成长计划让员工成长，从而发展员工。所以，我们通常可以看到 Boss 总是说自己的员工有这个问题有那个问题，而 Leader 总是说，如何让员工成长以解决员工个人的各种问题。</p></li><li><p>Boss 从团队收割成绩，而 Leader 则是给予团队成绩。</p><p>  Boss 通常都会把团队的成绩占为己有，虽然 Boss 会说这是团队的功劳，但基本上是一句带过。而 Leader 则是让团队成功，让团队的成员站在台前，自己甘当绿叶和铺路石。Leader 知道只有团队的每个人成功了，团队才会成功，所以，Leader 会帮助团队中的每个人更好更流畅地走向成功。</p></li><li><p>Boss 喜欢命令和控制（ Command + Control ），而 Leader 喜欢沟通和协作（ Communication + Cooperation ）。</p><p>  Boss 喜欢通过命令来控制员工的行为，从而实现团队的有效运转，而 Leader 喜欢通过沟通和协作来增加员工的参与感，从而让员工觉得这是自己的事，愿意为之付出。</p></li><li><p>Boss 喜欢说“给我上”，而 Leader 喜欢说“跟我上”。</p><p>  Boss 总是躲在团队后面，让团队冲锋陷阵，而 Leader 总是冲在前面用自己的行动领着团队浴血奋战。</p></li></ul><h3 id="（二）、如何成为众人愿意追随的-Leader"><a href="#（二）、如何成为众人愿意追随的-Leader" class="headerlink" title="（二）、如何成为众人愿意追随的 Leader"></a>（二）、如何成为众人愿意追随的 Leader</h3><ul><li><p>帮人解决问题。</p><p>  团队或身边大多数人都在问：“这个问题怎么办？”，而你总是能站出来告诉大家该怎么办。</p></li><li><p>被人依赖。</p><p>  团队或身边大多数人在做比较关键的决定时，都会来找你咨询意见和想法。</p></li></ul><p>要有能够做到上面的要求，你需要有技术领导力。有没有技术领导力（Leadership），是成为一个 Leader 非常关键的因素。因为人们想要跟随的人通常都是比自己强比自己出色的人，或是能够跟他学到东西，能够跟他成长的人。</p><p>但是，有了技术领导力可能并不够，下面是我罗列的一些比较关键的除了技术领导力之外的一个 Leader 需要的素质：</p><ul><li><p>赢得他人的信任。</p><p>  对于信任来说，并不完全是别人相信你能做到某个事，还有别人愿意向你打开心扉，和你说他心里面最柔软的东西。而后者才是真正的信任。</p></li><li><p>开放的心态 + 倾向性的价值观。</p><ol><li><p>对于新生事物要有开放的心态，对于每个人的观点都有开放的心态，但并不是要认同所有的观点和事情，成为一个油腔滑调的人。</p></li><li><p>就价值观来说，还是需要有倾向性的，比如，我就倾向于不加班的文化，倾向于全栈，倾向于按职责分工而不是按技能分工，倾向于做一个 Leader 而不是 Boss，倾向于技术是第一生产力，倾向于 OKR 而不是 KPI……</p></li></ol></li></ul><p>我的这些倾向性可以让别人更清楚地知道我是一个什么样的人，而不会对我琢磨不透，一会东一会西只会让人觉得你太油了，反而会产生距离感和厌恶感。我认为，倾向性的价值观是别人是否可以跟随你的一个基础。</p><ul><li><p>Lead by Example。</p><ol><li>用自己的行为来向大家展示你的 Leadership。这就是说，你需要给大家做示范。很多时候，道理人人都知道，但未必人人都会做，知易行难，以身示范，一个示例会比讲一万遍道理都管用。</li><li>所以我认为，对于软件开发来说，不写代码的架构师是根本不靠谱的。要做一个有人愿意跟随的技术 Leader，你需要终身写代码，也就是所谓的 ABC – Always Be Coding。这样，你会得到更多的实际经验，能够非常明白一个技术方案的优缺点，实现复杂度，知道什么是 Best Practice，你的方案才会更具执行力和实践性。当有了执行力，你就会获得更多的成就，而这些成就反过来会让更多的人来跟随你。</li></ol></li><li><p>能够抓住重点，看透事物的本质。</p><p>  作为一个 Leader，能够抓住主要矛盾，看清事物的本质，给出清楚的观点或方向，简化复杂的事情，传道解惑、开启民智，让人豁然开朗、醍醐灌顶，才会让人追随之。</p></li><li><p>描绘令人激动的方向，提供令人向住的环境。</p><p>  一个好的 Leader 一定会把每个人心中最真善美的东西呼唤出来，并且还能让人相信这是有机会有可能做到的。</p></li><li><p>甘当铺路石，为他人创造机会。</p><p>  别人愿意跟随你，愿意和你共事，有一部分原因是你能够给别人带来更多的可能性和机会，别人觉得和你在一起能够成长，能够进步，你能够带着大家到达更远的地方。帮助别人其实就是帮助自己，成就他人其实也是在成就自己，这就像一个好的足球队一样，球队中的人都互相给队友创造机会，整个团队成功了，球队的每个人也就成功了。作为一个好的 Leader，你一定要在团队中创造好这样的文化和风气。</p></li></ul><hr><h2 id="五、时间管理：同扭曲时间的事儿抗争"><a href="#五、时间管理：同扭曲时间的事儿抗争" class="headerlink" title="五、时间管理：同扭曲时间的事儿抗争"></a>五、时间管理：同扭曲时间的事儿抗争</h2><h3 id="（一）、主动管理"><a href="#（一）、主动管理" class="headerlink" title="（一）、主动管理"></a>（一）、主动管理</h3><p>无论什么事情，如果你发现你持续处于被动的状态下，那么你一定要停下来想一想如何把被动变为主动。因为在被动的方式下工作，你是不可能做好工作的，无论什么事。</p><p><strong>你要主动管理的不是你的时间，而是管理你的同事，管理你的信息。</strong></p><h3 id="（二）、学会说“不”"><a href="#（二）、学会说“不”" class="headerlink" title="（二）、学会说“不”"></a>（二）、学会说“不”</h3><ul><li><p>当你面对做不到的需求时，你不要说这个需求做不到，尤其是，你不要马上说做不到。</p><p>  你要先想一下，这样让别人觉得你是想做的，但是，在认真思考过后，你觉得做不到，并且给出一个你觉得能做到的方案。这里的诀窍是——<strong>给出另一个你可以做到的方案，而不是把对方的方案直接回绝掉。</strong></p></li><li><p>当你面对过于复杂的需求时，你不要说不。</p><p>  你要反问一下，为什么要这样做？这样做的目的是什么？当了解完目的以后，你可以给出一个自己的方案，或是和对方讨论一个性价比更好的方案。你可以回复说，这个需求好复杂，我们能不能先干这个，再做那个，这样会更经济一些。这里的诀窍是——<strong>我不说我不能完全满足你，但我说我可以部分满足你。</strong></p></li><li><p>当你面对时间完全不够的需求时，你也不要说不。</p><p>  既然对方把压力给你，你要想办法把这个压力还回去，或是让对方来和你一同分担这个压力。</p></li></ul><p>惯用的方式是给回三个选择：</p><ul><li>我可以加班加点完成，但是我不保证好的质量，有 bug 你得认，而且事后你要给我 1 个月的时间还债。</li><li>我可以加班加点，还能保证质量，但我没办法完成这么多需求，能不能减少一些？</li><li>我可以保质保量地完成所有的需求，但是，能不能多给我 2 周时间？</li></ul><h3 id="（三）、加班和开会"><a href="#（三）、加班和开会" class="headerlink" title="（三）、加班和开会"></a>（三）、加班和开会</h3><p><strong>如果怎么做都要受伤害，那么两害相权取其轻</strong>。你要学会比较是项目延期的伤害大，还是线上故障的伤害大，是先苦后甜好，还是积压问题好，聪明的你应该能做出正确的判断。</p><p><strong>开会，不是讨论问题，而是讨论方案，开会不是要有议题，而是要有议案。</strong></p><hr><h2 id="六、时间管理：如何利用好自己的时间"><a href="#六、时间管理：如何利用好自己的时间" class="headerlink" title="六、时间管理：如何利用好自己的时间"></a>六、时间管理：如何利用好自己的时间</h2><h3 id="（一）、投资自己的时间"><a href="#（一）、投资自己的时间" class="headerlink" title="（一）、投资自己的时间"></a>（一）、投资自己的时间</h3><ul><li><p>花时间学习基础知识，花时间读文档。</p><p>  系统地学习一门技术是非常关键的，所以这个时间是值得投资的。</p></li><li><p>花时间在解放自己生产力的事上。</p><p>  在自动化、可配置、可重用、可扩展上要多花时间。花时间在解放自己的事上是最有意义的了。</p></li><li><p>花时间在让自己成长的事上。</p><p>  注意，晋升并不代表成长，成长不应该只看在一个公司内，而是要看在行业内，在行业内的成长才是真正的成长。所以，把时间花在能让自己成长，能让自己有更强的竞争力，能让自己有更大的视野，能让自己有更多可能性的事情上。</p></li><li><p>花时间在建立高效的环境上。</p><p>  不仅仅是工具上，花些时间在影响你身边的人上，比如你的同事，你的产品经理，你的老板，去影响他们，让他们理解你，让他们配合你来建立更好的流程和管理方法。在这个方向上花时间也是很值得的。</p></li></ul><h3 id="（二）、规划自己的时间"><a href="#（二）、规划自己的时间" class="headerlink" title="（二）、规划自己的时间"></a>（二）、规划自己的时间</h3><ul><li><p>定义好优先级。</p><p>  无论你写不写出来，你一定都会有一个自己的 to-do list。知道什么事是重要的，什么事是紧急的，什么事重要但不紧急，什么事又重要又紧急。这有利于你划分优先级。</p></li><li><p>最短作业优先。</p><p>  对于相同优先级的事，我个人喜欢的是“最短作业优先”的调度算法。</p></li><li><p>想清楚再做。</p><p>  对于一些没想清楚的事，或是自己不太有信心的事，还是先看看有没有已有的成熟解决方案，或是找更牛的人来给你把把关，帮你出出主意，看看有没有更好、更简单的方式。</p></li><li><p>关注长期利益规划。</p><p>  要多关注长远可以节省多少时间，而不是当前会花费多少时间。长期成本会比短期成本大得多。所以，宁可在短期延期，也不要透支未来。这里的逻辑是，工作上的事你永远也做不完的，长痛不如短痛。</p></li></ul><p><strong>你要学会规划自己的行动计划，不是短期的，而是一个中长期的。我个人建议是按季度来规划，这个季度做什么，达到什么目标，一年往前走四步，而不是只考虑眼下。</strong></p><h3 id="（三）、用好自己的时间"><a href="#（三）、用好自己的时间" class="headerlink" title="（三）、用好自己的时间"></a>（三）、用好自己的时间</h3><ul><li><p><strong>将军赶路不追小兔</strong>。</p><p>  能专注地把时间投入到一个有价值的事上是非常重要的。确定自己的目标，专注达到这个目标，而不是分心。将军的目标是要攻城，而不是追兔子。所以，你要学会过滤掉与自己目标无关的事，不要让那些无关的事控制自己。</p></li><li><p>形成习惯。</p><p>  在讲述完如何争取时间，及如何使用时间之后，我想分享一下如何将这些时间管理方法形成习惯，因为我坚信：<strong>“做”比“做好”更重要</strong>。养成一个好习惯通常需要 30 天左右的时间，尤其在最初的几天就更为重要了。这时，不妨将文章中提到的方法和几个要点，写在某本书或者笔记本的扉页上，方便查看，时刻提醒自己。</p></li><li><p>形成正反馈。</p><p>  要有正反馈，也就是成就感，有助于完成一些看似难以完成的事儿。比如，我们说过，学习是逆人性的事儿，但如果在学习过程中不断地有正反馈，就更利于我们坚持下去。要让自己有正反馈，那就需要把时间花在有价值的地方，比如，解决自己和他人的痛点，这样你会收获别人的赞扬和鼓励。</p></li><li><p>反思和举一反三。</p><p>  可以尝试每周末花上点时间思考一下，本周做了哪些事儿？时间安排是否合理？还有哪些可以优化提高的地方？有点儿类似于我们常说的“复盘”。然后思考一下，下周的主要任务是什么？并根据优先级规划一下完成这些任务的顺序，也就是做一些下周的工作规划。</p></li></ul><hr><h2 id="七、程序员面试攻略：面试前的准备"><a href="#七、程序员面试攻略：面试前的准备" class="headerlink" title="七、程序员面试攻略：面试前的准备"></a>七、程序员面试攻略：面试前的准备</h2><h3 id="（一）、怎样写简历"><a href="#（一）、怎样写简历" class="headerlink" title="（一）、怎样写简历"></a>（一）、怎样写简历</h3><p><strong>我们知道真正的好简历是要用自己的经历去写的。</strong></p><p>写简历的最佳实践——用自己的经历聊，而不是用文字写。</p><p>基本上来说，简历上的信息不要写太多，信息太多相当于没有信息，不要单纯地罗列，要突出自己的长处和技能。一般来说，简历需要包括以下几项内容：</p><ul><li><p>自我简介。</p><p>  用最简单的话来说明自己的情况，不超过 200 字。比如：10+ 年的软件开发经验（说明你的主业），4+ 年的团队 leader 经验（说明你的领导力），擅长高可用高性能的分布式架构（说明你的专业和专攻），多年互联网和金融行业背景（说明你的行业背景），任职于 XXX 公司的 XX 职位（说明你的职业），负责 XXX 平台或系统（说明你的业务场景）……</p></li><li><p>个人信息。</p><ol><li>基本信息。电子邮箱建议用 Gmail，千万不要用 QQ 邮箱，要让人感觉职业化一些。</li><li>个人网站。如果你有个人主页、博客、GitHub 或是 Stack Overflow，请一定附上，这是加分项。如果个人主页或博客有独立域名，那更好，这会给人一种你爱动手做事的感觉。页面也要干净有美感，这样会让人感觉你有品味。</li><li>网站内容。一般来说这些项都会被面试官点看浏览，所以，里面的内容你需要小心组织和呈现，千万不要造假。另外，除了技术上的一些知识总结（不要太初级，要有深度的、原理型的、刨根问底型的文章），你也可以秀一秀自己的技术价值观（比如，对代码整洁的追求，对一些技术热点事件的看法），这会让你更容易获得面试官的好感。面试官的好感很重要。</li><li>作品展。如果你有一些作品展现，会更好。当然，对于前端程序员来说，这是比较容易的。而对于后端程序员来说，这会比较难一些，只能展示一下自己的 GitHub 了。如果你有一些比较不错的证书或奖项（如微软的认证、Oracle 的认证），也可以展示一下。</li></ol></li></ul><p><strong>对应于你的简历，如果能和应聘职位的需求看齐有相类似的描述，这样可以快速地让人觉得你和要应聘的职位很匹配。</strong></p><ul><li><p>工作经历和教育经历。</p><ol><li>列一下你的工作经历。每份工作完成的主要项目（不要列一大堆项目，挑重要的），主要突出项目的难度、规模、挑战、职责，以及获得的认可和荣誉。</li><li>工作经历和教育经历，主要是对上述的个人技能的印证。不要东拉西扯，要紧紧地围绕着你的技能、特长和亮点来展开。</li></ol></li></ul><p>一般来说，你简历中的内容最好控制在两页 A4 纸以内，最好有中英文版，简历不要是 Word 版的，最好是 PDF 版，然后简历的格式和风格请参考 LinkedIn 上的（在 微软的 Office 模板网站 上也能找到一些不错的简历模板）。简历的内容不要太多，内容太多，重点就不明显了。写简历的目的是呈现自己的特长、亮点和特点。只要你能呈现出 2-3 个亮点和特长，就可以吸引到人了。</p><p>如果简历上的经历和技术亮点不足的话，那么你可以在简历的版式和形式的制作上花些心思，以及在简历的自我描述中加上一些“虚”的东西。</p><p>比如“工作态度积极，不分份内和份外的事，只要对公司和个人有利，都会努力做好；勤奋踏实，热爱学习，喜欢做一个全栈工程师；善于发现问题，并解决问题……”表示我虽然现在的经历和技能不足以打动你，但是我的态度端正，潜力巨大，你不能错过……</p><h3 id="（二）、技术知识准备"><a href="#（二）、技术知识准备" class="headerlink" title="（二）、技术知识准备"></a>（二）、技术知识准备</h3><p>一般来说，你的简历上写什么，面试官就会问什么，所以，不要打自己的脸，精通就是精通，熟悉就是熟悉，了解就是了解。然后对于你列出来的这些技术，你一定要把其最基本的技术细节给掌握了。你不见得要记住所有的知识点，但是 80% 以上的关键知识点，你多少得知道吧。面试官一般也会逐步加大问题的难度和深度，看看你到底在哪个层次上。所以，你还是需要系统地看看书，才能应对面试官的问题。比如：</p><ul><li>你写上了 Java，那么 Java 的基本语法都要了解，并发编程、NIO、JVM 等，你多少要有点儿了解，Spring、Netty 这些框架也要了解。</li><li>你写上了 Go，那么至少得把官网上的 Effective Go 给看了。</li><li>你写上了 Redis，那么除了 Redis 的数据结构，Redis 的性能优化、高可用配置、分布式锁什么的，你多少也要把官网上的那几篇文章读一读。</li><li>你写上了面向对象，那么怎么着也得把《设计模式》中的 23 个模式了解一下。</li><li>你写上了分布式架构，那么 CAP 理论、微服务架构、弹力设计、Spring Cloud、Cloud Native 这些架构就要做到心里有数。</li><li>你写上网络编程，那么 TCP/IP 的三次握手，四次挥手，两端的状态变化你得知道吧，Socket 编程的那几个系统调用，还有 select、poll、epoll 这些异步 IO 多路复用的东西，你得知道。</li></ul><h3 id="（三）、算法题准备"><a href="#（三）、算法题准备" class="headerlink" title="（三）、算法题准备"></a>（三）、算法题准备</h3><p>面试前去LeetCode练练。<a href="https://www.geeksforgeeks.org/top-20-dynamic-programming-interview-questions/">Top 20 的动态规划题的列表</a>。</p><h3 id="（四）、工作项目准备"><a href="#（四）、工作项目准备" class="headerlink" title="（四）、工作项目准备"></a>（四）、工作项目准备</h3><p><strong>无论什么公司的面试，都会让你说一个你做过的项目，或是你过去解决过的一个难题。</strong> 一般来说，会有下面这样的几个经典的面试问题：</p><ol><li>说一个你做过的最自豪的项目，或是最近做过的一个项目。</li><li>说一个你解决过的最难的技术问题，或是最有技术含量的问题。</li><li>说一个你最痛苦的项目，或最艰难的项目。</li><li>说一个犯过的最大的技术错误，或是引发的技术故障。</li></ol><p>对于上面这四个问题：第一个问题，主要是想看看你过去工作中做过的最高级的事是什么，还有你的兴趣点和兴奋点是什么；第二和第三个问题，主要是想看看你解决难题的能力，以及面对压力和困难时的心态；第四个问题，主要是想了解一下你面对错误时的态度，还要了解你是否会对错误有所总结和改进。</p><p>怎样准备这样的题，我这里有几个提示：</p><ul><li><p>要有框架。</p><p>  讲故事要学会使用 STAR 。Situation - 在什么样的环境和背景下，Task - 你要干什么样的事，Action - 你采取了什么样的行动和努力，Result - 最终得到了什么样的效果。这是整个语言组织的框架，不要冗长啰嗦。</p></li><li><p>要有细节。</p><p>  没有细节的故事听起来就很假，所以，其中要有很多细节。因为是技术方面的，所以，一定要有很多技术细节。</p></li><li><p>要有感情。</p><p>  讲这些故事一定要带感情。要让面试官感受到你的热情、骄傲、坚韧和顽强。一定要是真实的，只有真实的事才会有真实的感情。</p></li><li><p>要有思考。</p><p>  只有细节和故事还不够，还要有自己的思考和得失总结，以及后续的改进。</p></li></ul><p>对此，如果你想有一个比较好的面试回答效果，<strong>这不是你能临时准备出来的，工夫都是花在平时的。而训练这方面能力的最好方式就是在工作中写文档 ，在工作之余写博客。</strong> 只有写得多了，写得好了，你这样的能力才能训练出来。</p><hr><h2 id="八、程序员面试攻略：面试中的技巧"><a href="#八、程序员面试攻略：面试中的技巧" class="headerlink" title="八、程序员面试攻略：面试中的技巧"></a>八、程序员面试攻略：面试中的技巧</h2><h3 id="（一）、形象和谈吐"><a href="#（一）、形象和谈吐" class="headerlink" title="（一）、形象和谈吐"></a>（一）、形象和谈吐</h3><ul><li>着装让人感到干净、整洁。</li><li>保持微笑，表现得热情、开朗和幽默。</li><li>说话的时候，要看着对方，一方面这是对对方的尊重和礼貌，另一方面，这也是一种自信。</li><li>面试官问的问题，你要给出充足的细节，千万不要让面试官不断地追问，那样就被动了。</li></ul><h3 id="（二）、答不出来"><a href="#（二）、答不出来" class="headerlink" title="（二）、答不出来"></a>（二）、答不出来</h3><p>面试中有一些问题很难，但是不要放弃，要不断尝试。很多时候，面试官并不期待你能在很短的时候内解出一道难题，他只是想看一下你遇到难题时的态度和思维方式。如果你能证明给面试官看，你解决问题的方向和方法是正确的，就算是没有找到答案，也是很不错的。因为只要方向走对了，剩下的就是时间问题了。</p><p>如果实在解不出来，或是被问了不懂的知识性问题，那么就直接说不懂就好了。记下来，回去多看多练，下次记住了就好。</p><p>另外，对于没有答上来的问题，有的人会在面试后请教一下面试官。但是我觉得更好的方式是，问面试官要个他的邮箱或微信，回去后，努力搞懂，举一反三，然后写个东西再发回去。这样做是有可能让你起死回生的。多少可以暗示对方：“你看，我有不懂的，但是我能下工夫很快就搞懂了，你看我的学习能力还不错哦。你就不再考虑一下了吗？”</p><h3 id="（三）、尖锐问题"><a href="#（三）、尖锐问题" class="headerlink" title="（三）、尖锐问题"></a>（三）、尖锐问题</h3><ul><li><p>你为什么要离开现在的公司？</p><p>  一般来说，永远不要说之前公司的坏话。说客观原因。</p></li><li><p>说一下你的缺点？</p><ol><li>真实的回答。</li><li>最后还要补一句，我知道我的缺点，我也在努力改正，我正在通过什么样的方式改正。这非常关键，因为这基本上是面试官最喜欢看到的答案了，就是你不仅能正视自己的缺点，而且还能不断地改正。</li></ol></li><li><p>说一下你的优点？</p><ol><li>真实的回答。优点是需要用证据来说明的。</li><li>比如，我通常的回答是，我的优点就是学习能力强，因为我掌握的技术面很广，而且，我什么样的技术都学，比如最新的 Cloud Native 技术。作为后端人员我还学前端方面的技术如 React.js 和 Vue.js，这一切都来源于我扎实的基础知识……</li><li>回答这个问题的时候，一般都会反衬出你的价值观，HR 就是想了解你的价值观。比如，我比较踏实，我想把技术一直做到老。再比如，我有韧性，我受过哪些挫折、失败、不公、无奈和无助，我没有当逃兵……</li></ol></li><li><p>你为什么换工作换得这么勤？</p><ol><li>给出合理的解释，以消除用人方的疑惑。</li><li>一方面，你还是需要诚恳一点儿，另一方面，你在解释时需要承认频繁换工作也不是自己想的，自己何尝不想在一份工作上干得时间长一点儿。无奈，要么是公司有变化，要么就是自己没选好。一方面表达自己也厌倦了频繁换工作这种事，另一方面，你要把这个话题引到另外一个方向上——什么样的工作自己可以干很久？自己所期望的工作内容和工作环境是什么样的？这样就转而去谈你所向往的工作内容和环境了，并再表达一下在这样的工作环境下，是可以很长时间做下去的，并愿意和公司一起发展。</li><li>但是，先不要说得太理想了，不然，用人方也会觉得自己是做不到的。正确的说法是，自己并不担心公司有各种各样的问题，只要有一起扛事的队友一起拼搏，这才是最关键的。</li></ol></li><li><p>你在一家公司呆了接近 10 年为什么没有做到管理层？你又是怎么保持竞争力的？</p><ol><li>一般来说，不想做管理的程序员也挺多的，在技术的方向上勤勤恳恳深耕细作，会是一个非常难得的优秀工程师。专注于技术，不分心，不断地在技术上的深度和广度上钻研，这就是保持竞争力最好的方式。</li></ol></li><li><p>你工作满 5 年了，为什么还不是一个高级程序员？</p><ol><li>对于国外的顶尖公司来说，如果你有 5 年的工作经验，但还不能胜任高级程序员（Amazon 的 SDE2）的职位，那么你这个人就基本会被 pass 掉了，包括在职的员工也是一样的。</li><li>国内的公司可能会问你这个问题，对此，我个人认为比较好的回答是要分几方面来谈。一方面，过去因为什么原因耽误了些时间（环境因素、客观条件因素），另一方面，要表示同样也有主观因素，不然显得有点找借口的感觉，不诚恳。</li><li>接下来，要表明自己心里面也比较慌（表明自己不用别人提醒可以自己意识到自己的问题），所以，近一年来一直在学习，罗列一下学过哪些东西，最好还有学习目标和学习计划（表明自己除了有意识外，还有行动）。当然，厉害的面试官会不断地追问你一些细节，以此来确定你没有说假话，对此，你要有充足的准备。</li></ol></li><li><p>你为什么换了一个方向？你觉得你有什么优势？</p><ol><li>这个问题其实并不难回答，实话实说就好了。但是不要让招聘方感受到你浮燥的内心，或是朝三暮四的性格，更不要让人感觉到你像“小猫钓鱼”那样一边不行又来搞另一边。</li><li>我觉得回答这个问题有两种方式：一种是非常自信的回答——“我从来没有改变我的方向，因为种种原因，我没能得到我想要的方向，虽然现在很残酷，但是我一直都没有放弃我的方向，我一直都在努力学习……”如果你要这么回答了，你就要真的是这样的，在新的方向有所研究和建树，不然会被识破的。</li><li>另一种回答则常规一点，首先说明一下，自己的兴趣爱好，为什么这个方向要比之前的那个方向更适合自己。可以用几个例子来说明，但其中要有一些细节，比如，自己试过这个新方向 ，发现干得比原来那边更好，更容易出成绩，自己的兴奋点更大，所以觉得新方向更适合自己。然后，承认换一个方向短期内并没有优势。但是，因为自己的某某特质，比如，学习能力强、勤奋、聪明等特质，未来一定是可以胜任的。</li><li>但是，你要用证据证明你的学习能力强，你比一般人勤奋，比一般人聪明。不然如果对方追问下去，会让你破绽百出的。总之，回答这样的问题，需要一定的证据作为补充，而且还要伴随着以降职降薪为代价。所以，一般来说，选定方向最好不要再变了，如果一定要变的话，你也要有必胜的信心和先下后上的心态，而且这些信心和心态要让招聘方看到。</li></ol></li><li><p>对于技术的热情或初心体现在你生活和工作中的哪里？</p><ol><li>你要小心回答，而且是要带感情的，但一定要是真实的。</li><li>总结一下，对技术的热情或初心，需要表现在这么几个特质上：执着、坚持、坚韧、不服输、担当、不妥协、不浮燥……我说一句，我相信每个人或多或少都会有这些特质，这是你的亮点，要小心呵护。不然，你跟一条咸鱼就没什么两样了。</li></ol></li></ul><h3 id="（四）、结尾问题"><a href="#（四）、结尾问题" class="headerlink" title="（四）、结尾问题"></a>（四）、结尾问题</h3><ul><li><p>如果你面得比较好</p><ol><li>这个时候可以问几个尖锐的问题，这样有利于后面谈 offer 和岗位（抓住机会反转被动为主动）。比如：</li><li>你们公司有多少一线开发经理还在写代码？你们的一线经理都没有时间来写代码了，不知道细节怎么做好管理？另外是不是说明你们公司有大量的内耗？</li><li>任何公司都有好的有不好的，你能不能分享一下你最喜欢这个公司的地方和最不喜欢的地方？</li></ol></li><li><p>如果你面得一般</p><ol><li>这个时候你也可以问些加分的问题。</li><li>比如：目前贵公司或是贵团队最需要解决什么样的问题？我能帮贵公司做些什么？能不能给我一些资料我先了解一下，这样我后面如果能进来，就能上手更快一些了。因为你面得一般的话，面试官会比较犹豫和纠结，此时你需要让面试官不要犹豫，所以，你可以表现得更加热情和主动一点。你看，竟然一副通过面试明天就要上班的“无耻嘴脸”也会为你加点分的……（哈哈哈）</li></ol></li><li><p>如果你面得很不行，基本挂掉了</p><p>  这个时候，也要问问题。但最好问一下面试官对你的评价，并且让他指出你的不足和需要改进的地方。面试本来就是一次经历和一次学习，你也可以把其当作是一种受教育的过程。所以，不要放过自己可以成长的机会。通过面试官给你的评价，你日后就知道自己需要努力的地方和方向了。这是多好的一件事儿啊。</p></li></ul><hr><h2 id="九、高效学习：端正学习态度"><a href="#九、高效学习：端正学习态度" class="headerlink" title="九、高效学习：端正学习态度"></a>九、高效学习：端正学习态度</h2><h3 id="（一）、主动学习和被动学习"><a href="#（一）、主动学习和被动学习" class="headerlink" title="（一）、主动学习和被动学习"></a>（一）、主动学习和被动学习</h3><p>人的学习分为「被动学习」和「主动学习」两个层次。</p><ul><li>被动学习：如听讲、阅读、视听、演示，学习内容的平均留存率为 5%、10%、20% 和 30%。</li><li>主动学习：如通过讨论、实践、教授给他人，会将原来被动学习的内容留存率从 5% 提升到 50%、75% 和 90%。</li></ul><p><strong>学习不是努力读更多的书，盲目追求阅读的速度和数量，这会让人产生低层次的勤奋和成长的感觉，这只是在使蛮力。要思辨，要践行，要总结和归纳，否则，你只是在机械地重复某件事，而不会有质的成长的。</strong></p><h3 id="（二）、浅度学习和深度学习"><a href="#（二）、浅度学习和深度学习" class="headerlink" title="（二）、浅度学习和深度学习"></a>（二）、浅度学习和深度学习</h3><p>老实说，对于当前这个社会：</p><ul><li>大多数人的信息渠道都被微信朋友圈、微博、知乎、今日头条、抖音占据着。这些信息渠道中有营养的信息少之又少。</li><li>大多数公司都是实行类似于 996 这样的加班文化，在透支和消耗着下一代年轻人，让他们成长不起来。</li><li>因为国内互联网访问不通畅，加上英文水平受限，所以，大多数人根本没法获取到国外的第一手信息。</li><li>快餐文化盛行，绝大多数人都急于速成，心态比较浮燥，对事物不求甚解。</li></ul><p>只要你注意观察，就会发现，少数的精英人士，他们在训练自己获取知识的能力，他们到源头查看第一手的资料，然后，深度钻研，并通过自己的思考后，生产更好的内容。而绝大部分受众享受轻度学习，消费内容。</p><p>你有没有发现，在知识的领域也有阶层之分，那些长期在底层知识阶层的人，需要等着高层的人来喂养，他们长期陷于各种谣言和不准确的信息环境中，于是就导致错误或幼稚的认知，并习惯于那些不费劲儿的轻度学习方式，从而一点点地丧失了深度学习的独立思考能力，从而再也没有能力打破知识阶层的限制，被困在认知底层翻不了身。</p><p>可见深度学习十分重要，但应该怎样进行深度学习呢？下面几点是关键。</p><ul><li>高质量的信息源和第一手的知识。</li><li>把知识连成地图，将自己的理解反述出来。</li><li>不断地反思和思辨，与不同年龄段的人讨论。</li><li>举一反三，并践行之，把知识转换成技能。</li></ul><p>换言之，学习有三个步骤。</p><ul><li>知识采集。信息源是非常重要的，<strong>获取信息源头、破解表面信息的内在本质、多方数据印证</strong>，是这个步骤的关键。</li><li>知识缝合。所谓缝合就是把信息组织起来，成为结构体的知识。这里，<strong>连接记忆，逻辑推理，知识梳理</strong>是很重要的三部分。</li><li>技能转换。通过<strong>举一反三、实践和练习，以及传授教导</strong>，把知识转化成自己的技能。这种技能可以让你进入更高的阶层。</li></ul><h3 id="（三）、学习是为了找到方法"><a href="#（三）、学习是为了找到方法" class="headerlink" title="（三）、学习是为了找到方法"></a>（三）、学习是为了找到方法</h3><p><strong>学习不仅仅是为了找到答案，而更是为了找到方法。</strong></p><p>只有掌握解题的思路和方法，你才算得上拥有解决问题的能力。所有的练习，所有的答案，其实都是在引导你去寻找一种“以不变应万变”的方法或能力。</p><p><strong>学习是为了找到通往答案的路径和方法，是为了拥有无师自通的能力。</strong></p><h3 id="（四）、学习是为了找到原理"><a href="#（四）、学习是为了找到原理" class="headerlink" title="（四）、学习是为了找到原理"></a>（四）、学习是为了找到原理</h3><p><strong>学习不仅仅是为了知道，而更是为了思考和理解。</strong> 在学习的过程中，我们不是为了知道某个事的表面是什么，而是要通过表象去探索其内在的本质和原理。</p><p>问题会驱使你像一个侦探一样去探索背后的事实和真相，并在不断的思考中一点一点地理解整个事情的内在本质、逻辑和原理。 <strong>一旦理解和掌握了这些本质的东西，你就会发现，整个复杂多变的世界在变得越来越简单。你就好像找到了所有问题的最终答案似的，一通百通了。</strong></p><h3 id="（五）、学习是为了了解自己"><a href="#（五）、学习是为了了解自己" class="headerlink" title="（五）、学习是为了了解自己"></a>（五）、学习是为了了解自己</h3><p><strong>学习不仅仅是为了开拓眼界，而更是为了找到自己的未知，为了了解自己。</strong> 英文中有句话叫：You do not know what you do not know，可以翻译为：你不知道你不知道的东西。也就是说，你永远不会去学习你不知道其存在的东西。就好像你永远 Google 不出来你不知道的事，因为对于你不知道的事，你不知道用什么样的关键词，你不知道关键词，你就找不到你想要的知识。</p><p><strong>开拓眼界的目的就是发现自己的不足和上升空间，从而才能让自己成长。</strong></p><h3 id="（六）、学习是为了改变自己"><a href="#（六）、学习是为了改变自己" class="headerlink" title="（六）、学习是为了改变自己"></a>（六）、学习是为了改变自己</h3><p><strong>学习不仅仅是为了成长，而更是为了改变自己。</strong> 很多时候，我们觉得学习是为了自己的成长，但是其实，学习是为了改变自己，然后才能获得成长。为什么这么说呢？我们知道，人都是有直觉的，但如果人的直觉真的靠谱，那么我们就不需要学习了。而学习就是为了告诉我们，我们的很多直觉或是思维方式是不对的，不好的，不科学的。</p><p><strong>学习是为了改变自己的思考方式，改变自己的思维方式，改变自己与生俱来的那些垃圾和低效的算法。总之，学习让我们改变自己，行动和践行，反思和改善，从而获得成长。</strong></p><hr><h2 id="十、高效学习：源头、原理和知识地图"><a href="#十、高效学习：源头、原理和知识地图" class="headerlink" title="十、高效学习：源头、原理和知识地图"></a>十、高效学习：源头、原理和知识地图</h2><h3 id="（一）、挑选知识和信息源"><a href="#（一）、挑选知识和信息源" class="headerlink" title="（一）、挑选知识和信息源"></a>（一）、挑选知识和信息源</h3><p>信息源要有下面几个特质：</p><ul><li>应该是第一手资料，不是被别人理解过、消化过的二手资料。尤其对于知识性的东西来说，更是这样。应该是原汁原味的，不应该是被添油加醋的。</li><li>应该是有佐证、有数据、有引用的，或是有权威人士或大公司生产系统背书的资料。应该是被时间和实践检验过的，或是小心求证过的，不是拍脑袋野路子或是道听途说出来的资料。</li><li>应该是加入了一些自己的经验和思考，可以引发人深思的，是所谓信息的密集很大的文章。</li></ul><h3 id="（二）、注重基础和原理"><a href="#（二）、注重基础和原理" class="headerlink" title="（二）、注重基础和原理"></a>（二）、注重基础和原理</h3><p><strong>基础知识和原理性的东西和技术，都是经历过长时间的考验的，所以，这些基础技术也有很多人类历史上的智慧结晶，会给你很多启示和帮助。</strong> 比如：TCP 协议的状态机，可以让你明白，如果你要设计一个异步通信协议，状态机是一件多么重要的事，还有 TCP 拥塞控制中的方式，让你知道，设计一个以响应时间来限流的中件间是什么样的。</p><h3 id="（三）、使用知识图"><a href="#（三）、使用知识图" class="headerlink" title="（三）、使用知识图"></a>（三）、使用知识图</h3><p>联想记忆法。比如，在学习 C++ 的时候，面对《C++ Primer》这种厚得不行的书，我就使用联想记忆法。</p><p>我把 C++ 分成三部分：</p><ul><li>第一部分是 C++ 是用来解决 C 语言的问题的，那么 C 语言有什么问题呢？指针、宏、错误处理、数据拷贝…… C++ 用什么技术来解决这些问题呢？</li><li>第二部分是 C++ 的面向对象特性：封装、继承、多态。封装，让我想到了构造函数、析构函数等。构造函数让我想到了初始化列表，想到了默认构造函数，想到了拷贝构造函数，想到了 new……多态，让我想到了虚函数，想到了 RTTI，RTTI 让我想到了 dynamic_cast 和 typeid 等。</li><li>第三部分是 C++ 的泛型编程。我想到了 template，想到了操作符重载，想到了函数对象，想到 STL，想到数据容器，想到了 iterator，想到了通用算法，等等。</li></ul><p>于是，我通过“顺藤摸瓜”的方式，从知识树的主干开始做广度或是深度遍历，于是我就得到了一整棵的知识树。这种“顺藤摸瓜”的记忆方式让我记住了很多知识。<strong>最重要的是，当出现一些我不知道的知识点时，我就会往这棵知识树上挂，而这样一来，也使得我的学习更为系统和全面。</strong></p><p>这种画知识图的方式可以让你从一个技术最重要最主干的地方出发开始遍历所有的技术细节，也就是画地图的方式。如果你不想在知识的海洋中迷路，你需要有一份地图，所以，<strong>学习并不是为了要记忆那些知识点，而是为了要找到一个知识的地图，你在这个地图上能通过关键路径找到你想要的答案。</strong></p><hr><h2 id="十一、高效学习：深度，归纳和坚持实践"><a href="#十一、高效学习：深度，归纳和坚持实践" class="headerlink" title="十一、高效学习：深度，归纳和坚持实践"></a>十一、高效学习：深度，归纳和坚持实践</h2><h3 id="（一）、系统地学习"><a href="#（一）、系统地学习" class="headerlink" title="（一）、系统地学习"></a>（一）、系统地学习</h3><p>当然学习一门技术时，Go 语言也好，Docker 也好，我都有一个学习模板。只有把这个学习模板中的内容都填实了，我才罢休。这个模板如下：</p><ol><li><p>这个技术出现的背景、初衷和要达到什么样的目标或是要解决什么样的问题。</p><p> 这个问题非常关键，也就是说，你在学习一个技术的时候，需要知道这个技术的成因和目标，也就是这个技术的灵魂。如果不知道这些的话，那么你会看不懂这个技术的一些设计理念。</p></li><li><p>这个技术的优势和劣势分别是什么，或者说，这个技术的 trade-off 是什么。</p><p> 任何技术都有其好坏，在解决一个问题的时候，也会带来新的问题。另外，一般来说，任何设计都有 trade-off（要什么和不要什么），所以，你要清楚这个技术的优势和劣势，以及带来的挑战。</p></li><li><p>这个技术适用的场景。</p><p> 任何技术都有其适用的场景，离开了这个场景，这个技术可能会有很多槽点，所以学习技术不但要知道这个技术是什么，还要知道其适用的场景。没有任何一个技术是普适的。注意，所谓场景一般分别两个，一个是业务场景，一个是技术场景。</p></li><li><p>技术的组成部分和关键点。</p><p> 这是技术的核心思想和核心组件了，也是这个技术的灵魂所在了。学习技术的核心部分是快速掌握的关键。</p></li><li><p>技术的底层原理和关键实现。</p><p> 任何一个技术都有其底层的关键基础技术，这些关键技术很有可能也是其它技术的关键基础技术。所以，学习这些关键的基础底层技术，可以让你未来很快地掌握其它技术。可以参看我在 CoolShell 上写的 Docker 底层技术那一系列文章。</p></li><li><p>已有的实现和它之间的对比。</p><p> 一般来说，任何一个技术都会有不同的实现，不同的实现都会有不同的侧重。学习不同的实现，可以让你得到不同的想法和思路，对于开阔思维，深入细节是非常重要的。</p></li></ol><h3 id="（二）、举一反三"><a href="#（二）、举一反三" class="headerlink" title="（二）、举一反三"></a>（二）、举一反三</h3><p>我觉得一个人的举一反三能力，可以分解成如下三种基本能力：</p><ol><li><p>联想能力。</p><p> 这种能力的锻炼需要你平时就在不停地思考同一个事物的不同的用法，或是联想与之有关的其他事物。对于软件开发和技术学习也一样。</p></li><li><p>抽象能力。</p><p> 抽象能力是举一反三的基本技能。平时你解决问题的时候，如果你能对这个问题进行抽象，你就可以获得更多的表现形式。抽象能力需要找到解决问题的通用模型，比如数学就是对现实世界的一种抽象。只要我们能把现实世界的各种问题建立成数据模型（如，建立各种维度的向量），我们就可以用数学来求解，这也是机器学习的本质。</p></li><li><p>自省能力。</p><p> 所谓自省能力就是自己找自己的难看。当你得到一个解的时候，要站在自己的对立面来找这个解的漏洞。有点像左右手互博。这种自己和自己辩论的能力又叫思辨能力。将自己分裂成正反方，左右方，甚至多方，站在不同的立场上来和自己辩论，从而做到不漏过一个 case，从而获得完整全面的问题分析能力。</p></li></ol><p>在这方面，我对自己的训练如下：</p><ul><li>对于一个场景，制造出各种不同的问题或难题。</li><li>对于一个问题，努力寻找尽可能多的解，并比较这些解的优劣。</li><li>对于一个解，努力寻找各种不同的测试案例，以图让其健壮。</li></ul><h3 id="（三）、总结和归纳"><a href="#（三）、总结和归纳" class="headerlink" title="（三）、总结和归纳"></a>（三）、总结和归纳</h3><p>对自己的知识进行总结和归纳是提高学习能力的一个非常重要的手段。这是把一个复杂问题用简单的语言来描述的能力。也就是说，我们把学到的东西用自己的语言和理解重新组织并表达出来，本质上是对信息进行消化和再加工的过程，这个过程可能会有信息损失，但也可能会有新信息加入，本质上是信息重构的过程。</p><p>不过，我们需要注意的是，如果只学了部分知识或者还没有学透，就开始对知识进行总结归纳，那么总结归纳出来的知识结构也只能是混乱和幼稚的。因此， <strong>学习的开始阶段，可以不急于总结归纳，不急于下判断，做结论，而应该保留部分知识的不确定性，保持对知识的开放状态。</strong> 当对整个知识的理解更深入，自己站的位置更高以后，总结和归纳才会更有条理。总结归纳更多是在复习中对知识的回顾和重组，而不是一边学习一边就总结归纳。</p><p>我们来总结一下做总结归纳的方法：<strong>把你看到和学习到的信息，归整好，排列好，关联好，总之把信息碎片给结构化掉，然后在结构化的信息中，找到规律，找到相通之处，找到共同之处，进行简化、归纳和总结，最终形成一种套路，一种模式，一种通用方法。</strong></p><p>要训练自己这方面的能力，你需要多看一些经典的方法论图书，看看别人是怎样总结和归纳知识的。你可以在一开始模仿并把自己的理解的知识给写出来，写博客会是一种很好的方式。另外一种更好的方式是讲一遍给别人听。总之，你需要把你总结归纳的知识公开出来，给别人看，接受别人的批评和反馈，这样你才能成长得更快。其实，我也在锻炼这样的能力。</p><h3 id="（四）、实践出真知"><a href="#（四）、实践出真知" class="headerlink" title="（四）、实践出真知"></a>（四）、实践出真知</h3><p>所谓实践出真知，也就是学以致用，不然只是纸上谈兵，误国误民。只有实践过，你才能对学到的东西有更深的体会。</p><p>多写多用。</p><h3 id="（五）、坚持不懈"><a href="#（五）、坚持不懈" class="headerlink" title="（五）、坚持不懈"></a>（五）、坚持不懈</h3><p>一方面你要把你的坚持形成成果晒出来，让别人来给你点赞，另一方面，你还要把坚持变成一种习惯，就像吃饭喝水一样，你感觉不到太多的成本付出。只有做到这两点，你才能够真正坚持。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客时间 </tag>
            
            <tag> 职业规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《C语言程序设计：现代方法(第2版)》读书笔记</title>
      <link href="c-yu-yan-cheng-xu-she-ji-xian-dai-fang-fa-di-2-ban-du-shu-bi-ji/"/>
      <url>c-yu-yan-cheng-xu-she-ji-xian-dai-fang-fa-di-2-ban-du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>主要是备忘C99标准中的一些变化。</p><h2 id="允许代码段与声明混合"><a href="#允许代码段与声明混合" class="headerlink" title="允许代码段与声明混合"></a>允许代码段与声明混合</h2><p>允许在程序块中任何地方声明变量，只要在第一次调用该变量之前声明就可以。</p><h2 id="支持-风格注释"><a href="#支持-风格注释" class="headerlink" title="支持//风格注释"></a>支持//风格注释</h2><h2 id="变量不再隐式声明为int类型"><a href="#变量不再隐式声明为int类型" class="headerlink" title="变量不再隐式声明为int类型"></a>变量不再隐式声明为int类型</h2><h2 id="不支持隐式声明函数"><a href="#不支持隐式声明函数" class="headerlink" title="不支持隐式声明函数"></a>不支持隐式声明函数</h2><h2 id="更准确的整型除法"><a href="#更准确的整型除法" class="headerlink" title="更准确的整型除法"></a>更准确的整型除法</h2><p>C89中i/j的两个整数操作数中有负数时，除法的结果既可以向上取整，也可以向下取整，在C99中总是向0取整。C89中如果i或j为负数，i%j结果与实现有关，在c99中结果符号总与i的符号相同。</p><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><p>新的布尔类型<code>_Bool</code>，本质是无符号的整型。<code>_Bool</code>类型的变量只能存储0或1，所以，将非0的值赋值给<code>_Bool</code>类型的变量都会导致变量的值变为1。同时还提供了新的头文件<stdbool.h>，内容如下：</stdbool.h></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">__bool_true_false_are_defined   <span class="token number">1</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">bool    <span class="token keyword">_Bool</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">false   <span class="token number">0</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">true    <span class="token number">1</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="for语句的变化"><a href="#for语句的变化" class="headerlink" title="for语句的变化"></a>for语句的变化</h2><p>在C99中，for语言的第一个表达式可以替换为一个声明，下面的代码也是合法的了：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="64位整数和扩展整数类型的支持"><a href="#64位整数和扩展整数类型的支持" class="headerlink" title="64位整数和扩展整数类型的支持"></a>64位整数和扩展整数类型的支持</h2><p>C99提供了两个额外的标准整数类型：<code>long long int</code>和<code>unsigned long long int</code>，大小至少64位宽。同时，以<code>LL</code>或<code>ll</code>（所有字母的大小写要一致）结尾的整数常量是<code>long long int</code>类型的，以<code>ULL</code>或<code>ull</code>（所有字母的大小写要一致）结尾的整数常量是<code>unsigned long long int</code>类型的。</p><p>除了标准的整数类型外，C99标准还允许在具体实现时定义<code>扩展的数类整数</code>（包括有符号的和无符号的）。比如：128位的整数类型。</p><h2 id="隐式转换的变化"><a href="#隐式转换的变化" class="headerlink" title="隐式转换的变化"></a>隐式转换的变化</h2><p>因为C99中增加了一些类型（_Bool、long long类型、扩展的整数类型和复数类型）。新的隐式转换规则略有变化（这里忽略了扩展整数类型和枚举类型）：</p><ol><li>long long int、unsigned long long int</li><li>long int、unsigned long int</li><li>int、unsigned int</li><li>short int、unsigned short int</li><li>char、signed char、unsigned char（这里要注意char类型和signed char类型是不同的类型）</li><li>_Bool</li></ol><p>C99用整数提升（integer promotion）取代了C89中的整值提升（integral promotion），可以将任何等级低于int和unsigned int的类型转换为int（只要该类型的所有值都可以用int类型表示）或unsigned int。</p><p>和C89一样类似，C99中执行常用的算术转换的规则可以划分为两种情况：</p><ul><li><p><code>任一操作数的类型是浮点数类型的情况。</code>只要两个操作数都不是复数型，规则如下(下面的内容摘录自<a href="https://book.douban.com/subject/1139336/">C程序设计语言(第2版_新版)</a>)：</p><ol><li>如果任何一个操作数为long double类型，将另一个操作数转换为long double类型，过程结束。</li><li>如果任何一个操作数为double类型，将另一个操作数转换为double类型，过程结束。</li><li>如果任何一个操作数为float类型，将另一个操作数转换为float类型，过程结束。</li></ol></li><li><p><code>两个操作数的类型都不是浮点类型的情况。</code>首先对两个操作数进行整数提升。如果这时两个操作数的类型相同，过程结束。否则，依次尝试下面的规则，一旦遇到可应用的规则就不再考虑别的规则：</p><ol><li>如果两个操作数都是有符号型或都是无符号型，将整数转换等级低的操作数转换为等级较高的操作数的类型。</li><li>如果无符号操作数的等级<code>高于或等于</code>有符号操作数的等级，将有符号操作数转换为无符号操作数的类型。</li><li>如果有符号操作数类型可以表示无符号操作数类型的所有值，将无符号操作数转换为有符号操作数的类型。</li><li>否则，将两个操作数都转换为与有符号操作数的类型相对应的无符号类型。</li></ol></li></ul><p>另外，所有算术类型都可以转换为_Bool类型。如果原始值为0则转换结果为0，否则结果为1。</p><h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2><blockquote><p>这条C99中没有变化，只是C和C++略有不同。</p></blockquote><p>如果数组的初始化式比数组短，那么数组中剩余的元素赋值为0：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">/* initial value of a is {1, 2, 0} */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>但是在C中初始化式完全为空是非法的，如果想要把数组全部初始化为0，必须要在大括号中放一个0。这点要求在C++中是没有的。</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// initial value of a to {0, 0, 0}</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// invalid in c but valid in c++</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="数组指定初始化式"><a href="#数组指定初始化式" class="headerlink" title="数组指定初始化式"></a>数组指定初始化式</h2><p>C99中，提供了指定下标的方式来初始化数组中指定位置的值。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">/* a is {0, 1, 0, 3, 0} */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同时，初始化式中老方法（逐个元素初始化）和新方法（指定初始化式）可以同时使用。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">/* b is {1, 0, 2} */</span><span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">/* b us {0, 0, 2, 1}*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="变长数组"><a href="#变长数组" class="headerlink" title="变长数组"></a>变长数组</h2><p>下面的代码在C99标准下是合法的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> a<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* C99 only*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>变长数组的长度是在程序执行时计算的，而不是在编译时计算的。变长数组的主要限制是它们没有静态存储时限（因为它是放在栈上面的），另一个限制是变长数组没有初始化式。</p><h2 id="变长数组形式参数"><a href="#变长数组形式参数" class="headerlink" title="变长数组形式参数"></a>变长数组形式参数</h2><p>下面的代码在C99标准下是合法的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sum_2d_array</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> arr<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：参数的顺序很重要。<code>int m</code>和<code>int n</code>必须要在<code>int arr[m][n]</code>的左边。</p></blockquote><p>在声明包含有变长数组形式的函数时，可以使用<code>*</code>，比如上面的函数可以声明为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sum_2d_array</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> arr<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">sum_2d_array</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">sum_2d_array</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">sum_2d_array</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>变长数组参数对编译器来说，只是提示性的，编译器并不进行额外的错误检测，只是方便编译优化等。所以实际上变长数组的大小和变长数组的参数可能是无关的。</code></p><h2 id="在数组参数声明中使用static"><a href="#在数组参数声明中使用static" class="headerlink" title="在数组参数声明中使用static"></a>在数组参数声明中使用static</h2><p>C99允许在数组参数声明中使用关键字static。在下面的代码中，将static放在数字3之前表示数组a的长度至少可以保证为3：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sum_array</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token keyword">static</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样使用static对程序的行为不会有任何影响。static的存在只是提示编译器，方便编译器根据此提示优化指令。</p><p>最后，如果数组参数是多维的，static仅可用于第一维（比如，指定二维数组的行数）。</p><h2 id="数组复合字面量"><a href="#数组复合字面量" class="headerlink" title="数组复合字面量"></a>数组复合字面量</h2><p>代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>total <span class="token operator">=</span> <span class="token function">sum_array</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在C99中，可以简化为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">total <span class="token operator">=</span> <span class="token function">sum_array</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，<code>(int []){3, 0, 3, 4, 1}</code>就是<code>复合字面量</code>。</p><p>复合字面量是通过指定其包含的元素而创建的没有名字的数组。其格式为：先在一对圆括号内给定类型名，随后在一对花括号内设定所包括元素的值。</p><p>复合字面量类似于应用于数组初始化式的强制转换。事实上，复合字面量和数组初始化式遵守同样的规则。复合字面量可以包含指示符，就像指定初始化式一样；可以不提供数组完全的初始化（未初始化的元素默认被初始化为0）。例如：复合字面量<code>(int[10]){8,6}</code>有10个元素，前面两个元素的值为8和6，剩下的元素值为0。</p><p>函数内部创建的复合字面量可以包含任意表达式，不限于常量。例如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">total <span class="token operator">=</span> <span class="token function">sum_array</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">2</span><span class="token operator">*</span>i<span class="token punctuation">,</span> i<span class="token operator">+</span>j<span class="token punctuation">,</span> j<span class="token operator">*</span>k<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中i、j、k都是变量。</p><p>复合字面量为左值，所以其元素的值可以改变。如果要求其值为“只读”，可以在类型前面加上<code>const</code>，如<code>(const int[]){5,4}</code>。</p><h2 id="指向常量数组复合字面量的指针"><a href="#指向常量数组复合字面量的指针" class="headerlink" title="指向常量数组复合字面量的指针"></a>指向常量数组复合字面量的指针</h2><p>指针指向复合字面量创建的数组中的某个元素是合法的。下面两段代码都是合法的，并且意义相同。</p><p>代码一：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>代码二：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="C99中的指针和变长数组"><a href="#C99中的指针和变长数组" class="headerlink" title="C99中的指针和变长数组"></a>C99中的指针和变长数组</h2><p>指针可以指向变长数组中的元素。如果变长数组是多维的，指针的类型取决于除第一维外每一维的长度。下面是二维的情况：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> a<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为p的类型依赖于n，而n不是常量，所以说p具有可改变类型。需要注意的是，编译器并非总能确定<code>p = a</code>这样的赋值语句的合法性，例如，下面的代码可以通过编译，但只有当<code>m = n</code>是才正确：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>p <span class="token operator">=</span> a<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果<code>m != n</code>，后续对p的使用都将导致未定义的行为。</p><p>与变长数组一样，可改变类型也具有特定的限制，其中最重要的限制是，可改变类型的声明必须出现在函数体内部或者在函数原型中。</p><h2 id="C99中新增的预定义宏"><a href="#C99中新增的预定义宏" class="headerlink" title="C99中新增的预定义宏"></a>C99中新增的预定义宏</h2><div class="table-container"><table><thead><tr><th style="text-align:center">名字</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>__STDC_HOSTED__</code></td><td style="text-align:center">如果是托管式实现，值为1；如果是独立式实现，值为0</td></tr><tr><td style="text-align:center"><code>__STDC_VERSION__</code></td><td style="text-align:center">支持的C标准版本</td></tr><tr><td style="text-align:center"><code>__STDC_IEC_559__</code></td><td style="text-align:center">如果支持IEC 60559浮点算术运算，则定义该宏，且值为1</td></tr><tr><td style="text-align:center"><code>__STDC_IEC_559_COMPLEX</code></td><td style="text-align:center">如果支持IEC 60559复数算术运算，则定义该宏，且值为1</td></tr><tr><td style="text-align:center"><code>__STDC_ISO_10646__</code></td><td style="text-align:center">如果wchar_t类型的值由ISO/IEC 10646标准中的码值表示，则定义该宏，且值的格式是yyyymmL（表示修订的年月）</td></tr></tbody></table></div><h2 id="空的宏参数"><a href="#空的宏参数" class="headerlink" title="空的宏参数"></a>空的宏参数</h2><p>C99允许宏调用中的任意或所有参数为空。但是这样的调用需要有和一般调用一样多的逗号（方便看出哪些参数被省略了）。</p><p>在大多数情况下，实际参数为空的效果是显而易见的。例如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">ADD</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span> <span class="token punctuation">(</span>x<span class="token operator">+</span>y<span class="token punctuation">)</span></span></span>i <span class="token operator">=</span> <span class="token function">ADD</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>i <span class="token operator">=</span> <span class="token function">ADD</span><span class="token punctuation">(</span><span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>经过预处理后变成：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">i <span class="token operator">=</span> <span class="token punctuation">(</span>j<span class="token operator">+</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>i <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">+</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当空参数是#或##运算符的操作数时，用法有特殊规定。例如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">MK_STR</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> #x</span></span><span class="token keyword">char</span> empty_string<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">MK_STR</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">JOIN</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">)</span> x</span><span class="token punctuation">##</span><span class="token expression">y</span><span class="token punctuation">##</span><span class="token expression">z</span></span><span class="token keyword">int</span> <span class="token function">JOIN</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">JOIN</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">JOIN</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">JOIN</span><span class="token punctuation">(</span><span class="token punctuation">,</span><span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>经过预处理后变成：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> empty_string<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token keyword">int</span> abc<span class="token punctuation">,</span> ab<span class="token punctuation">,</span> ac<span class="token punctuation">,</span> c<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="参数个数可变的宏"><a href="#参数个数可变的宏" class="headerlink" title="参数个数可变的宏"></a>参数个数可变的宏</h2><p>在C89中，如果宏有参数，那么参数的个数是固定的。在C99中，这个条件被适当放宽了，允许宏具有可变长度的参数列表。</p><p>宏具有可变参数个数的主要原因是：它可以将参数传递给具有可变参数个数的函数。比如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">TEST</span><span class="token punctuation">(</span>cond<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cond<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">printf</span><span class="token punctuation">(</span></span><span class="token string">"pass test: %s\n"</span><span class="token expression"><span class="token punctuation">,</span> #cond<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">printf</span><span class="token punctuation">(</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>...</code>记号（省略号）出现在宏参数列表的最后，前面是普通参数。<code>__VA_ARGS__</code>是一个专用的标识符，只能出现在具有可变参数个数的宏的替换列表中，代表所有与省略号相对应的参数。（至少有一个与省略号相对应的参数，但该参数可以为空。）</p><h2 id="func标识符"><a href="#func标识符" class="headerlink" title="func标识符"></a><strong>func</strong>标识符</h2><p>每个函数都可以访问<code>__func__</code>标识符，它的行为很像一个存储当前正在执行的函数的名字的字符串变量。作用相当于在函数体的一开始包含了如下声明：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token constant">__func__</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"function-name"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>__func__</code>的另一个用法：作为参数传递给函数，让函数知道调用它的函数的名字。</p><h2 id="Pragma运算符"><a href="#Pragma运算符" class="headerlink" title="_Pragma运算符"></a>_Pragma运算符</h2><p>C99引入了与#pragma指令一起使用的_Pragma运算符。其具有如下形式：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">_Pragma</span> <span class="token punctuation">(</span>字符串字面量<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>遇到该表达式时，预处理器通过移除字符串两端的双引号并分别用字符<code>"</code>和<code>\</code>代替转义序列<code>\"</code>和<code>\\</code>来实现对字符串字面量的“去字符串化”。下面的两行代码意义相同：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">_Pragma</span><span class="token punctuation">(</span><span class="token string">"data(heap_size =&gt; 1000, stack_size =&gt; 2000)"</span><span class="token punctuation">)</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">data</span><span class="token punctuation">(</span>heap_size <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">1000</span><span class="token punctuation">,</span> stack_size <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">2000</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="结构指定初始化式"><a href="#结构指定初始化式" class="headerlink" title="结构指定初始化式"></a>结构指定初始化式</h2><p>与数组指定初始化式类似，结构也可以使用指定初始化式。下面两行初始化代码意义相同：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">KibaZen</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">int</span> b<span class="token punctuation">;</span>    <span class="token keyword">int</span> c<span class="token punctuation">;</span>    <span class="token keyword">int</span> d<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">kibaZen</span> k <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">KibaZen</span> z <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="结构复合字面量"><a href="#结构复合字面量" class="headerlink" title="结构复合字面量"></a>结构复合字面量</h2><p>和数组复合字面量类似，结构也有复合字面量。下面的代码是合法的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">KibaZen</span> kz <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kibaZen</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="受限指针"><a href="#受限指针" class="headerlink" title="受限指针"></a>受限指针</h2><p>在C99中，用restrict声明的指针叫做受限指针（restricted pointer）。它向编译器保证，在这个指针的生命周期内，任何通过该指针访问的内存，都只能被这个指针改变。目的是为了是给编译器提供额外的信息帮助编译器进行代码优化。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> restrict dst<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> restrict src<span class="token punctuation">,</span> size_t n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">memmove</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> dst<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> src<span class="token punctuation">,</span> size_t n<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>C99标准下，<code>memcpy</code>中的dst和src都使用了restrict，说明复制源和目的地不应互相重叠（但不能确保不重叠）。而<code>memmove</code>中的dst和src没有使用restrict，说明即使在重叠时也能正常复制。</p><h2 id="灵活数组成员"><a href="#灵活数组成员" class="headerlink" title="灵活数组成员"></a>灵活数组成员</h2><p>在存储字符串时我们可能会定义下面的结构：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">vstring</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> len<span class="token punctuation">;</span>    <span class="token keyword">char</span> chars<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">vstring</span><span class="token operator">*</span> str <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">vstring</span><span class="token punctuation">)</span> <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>str<span class="token operator">-&gt;</span>nlen <span class="token operator">=</span> n<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里使用了一种“欺骗”的方法，分配比该结构声明时应具有的内存更多的内存，然后使用这些内存来存储chars数组额外的元素。这种方法称为“struct hack”。C89标准并不能保证struct hack技术工作，也不允许数组长度为0(GCC允许)。</p><p>C99提供了灵活数组成员（flexible array member）来达到同样的目的。当结构的最后一个成员是数组时，其长度可以省略：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">vstring</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> len<span class="token punctuation">;</span>    <span class="token keyword">char</span> chars<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">/* flexible array member - c99 only */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">vstring</span><span class="token operator">*</span> str <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">vstring</span><span class="token punctuation">)</span> <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>str<span class="token operator">-&gt;</span>len <span class="token operator">=</span> n<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具有灵活数组成员的结构是不完整类型（incomplete type）。不完整类型缺少用于确定所需内存大小的信息。</p><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>C99标准下，可以使用关键字inline创建内联函数。</p><h2 id="新的头文件-lt-stdbool-h-gt"><a href="#新的头文件-lt-stdbool-h-gt" class="headerlink" title="新的头文件<stdbool.h>"></a>新的头文件<code>&lt;stdbool.h&gt;</code></h2><h2 id="C99对…printf转换说明的修改"><a href="#C99对…printf转换说明的修改" class="headerlink" title="C99对…printf转换说明的修改"></a>C99对…printf转换说明的修改</h2><p>C99对printf函数和fprintf函数的转换说明做了不少修改。</p><ul><li>增加了长度修饰符：hh、ll、j、z和t。</li><li>增加了转换说明符：F、a和A。</li><li>允许输出无穷数和NaN。</li><li>支持宽字符输出：<code>%lc</code>和<code>%ls</code>。</li><li>C89未定义的转换说明C99允许了。%le、%lE、%lf、%lg和%lG在C99是合法的（l长度修饰符被忽略）。</li></ul><h2 id="C99对…scanf转换说明的改变"><a href="#C99对…scanf转换说明的改变" class="headerlink" title="C99对…scanf转换说明的改变"></a>C99对…scanf转换说明的改变</h2><p>C99对scanf函数和fscanf函数的转换说明也做了一些修改。</p><ul><li>增加了长度修饰符：hh、ll、j、z和t。</li><li>增加了转换说明符：F、a和A。</li><li>具有读无穷数和NaN的能力。</li><li>支持宽字符。<code>%lc</code>转换说明用于读出单个的多字节字符或者一系列多字节字符；<code>%ls</code>用于读取由多字节字符组成的字符串（在结尾添加空字符）。<code>%l[集合]</code>和<code>%l[^集合]</code>转换说明也可以读取多字节字符串。</li></ul><p>scanf示例：</p><div class="table-container"><table><thead><tr><th style="text-align:center">代码</th><th style="text-align:center">输入</th><th style="text-align:center">变量</th></tr></thead><tbody><tr><td style="text-align:center"><code>n = scanf("%i%i%i", &amp;i, &amp;j, &amp;k);</code></td><td style="text-align:center"><code>12 012 0x12</code></td><td style="text-align:center">n=3; i=12; j=10; k=18;</td></tr><tr><td style="text-align:center"><code>n = scanf("%[0123456789]", str);</code></td><td style="text-align:center"><code>123abc</code></td><td style="text-align:center">n=1; str=”123”;</td></tr><tr><td style="text-align:center"><code>n = scanf("%[0123456789]", str);</code></td><td style="text-align:center"><code>abc123</code></td><td style="text-align:center">n=0; str的值不变;</td></tr><tr><td style="text-align:center"><code>n = scanf("%[^0123456789]", str);</code></td><td style="text-align:center"><code>abc123</code></td><td style="text-align:center">n=1; str=”abc”;</td></tr><tr><td style="text-align:center"><code>n = scanf("%*d%d%n", &amp;i, &amp;j);</code></td><td style="text-align:center"><code>10 20 30</code></td><td style="text-align:center">n=1; i=20; j=5;</td></tr></tbody></table></div><h2 id="在-lt-math-h-gt-中增加许多类型、宏和函数"><a href="#在-lt-math-h-gt-中增加许多类型、宏和函数" class="headerlink" title="在<math.h>中增加许多类型、宏和函数"></a>在<code>&lt;math.h&gt;</code>中增加许多类型、宏和函数</h2><h2 id="通用字符名"><a href="#通用字符名" class="headerlink" title="通用字符名"></a>通用字符名</h2><p>可以用两种方式书写通用字符名（\udddd和\Udddddddd），每个d都是一个十六进制的数字。</p><p>UCS的码值可以在<a href="www.unicode.org/charts/">www.unicode.org/charts/</a>找到。</p><h2 id="支持宽字符的-lt-wchar-h-gt-和-lt-wctype-h-gt-函数库"><a href="#支持宽字符的-lt-wchar-h-gt-和-lt-wctype-h-gt-函数库" class="headerlink" title="支持宽字符的<wchar.h>和<wctype.h>函数库"></a>支持宽字符的<code>&lt;wchar.h&gt;</code>和<code>&lt;wctype.h&gt;</code>函数库</h2><h2 id="在-lt-stdio-h-gt-和-lt-wchar-h-gt-中支持vscanf族函数"><a href="#在-lt-stdio-h-gt-和-lt-wchar-h-gt-中支持vscanf族函数" class="headerlink" title="在<stdio.h>和<wchar.h>中支持vscanf族函数"></a>在<code>&lt;stdio.h&gt;</code>和<code>&lt;wchar.h&gt;</code>中支持vscanf族函数</h2><h2 id="新增-lt-stdint-h-gt-整数类型"><a href="#新增-lt-stdint-h-gt-整数类型" class="headerlink" title="新增<stdint.h>整数类型"></a>新增<code>&lt;stdint.h&gt;</code>整数类型</h2><h2 id="新增-lt-inttypes-h-gt-整数类型的格式"><a href="#新增-lt-inttypes-h-gt-整数类型的格式" class="headerlink" title="新增<inttypes.h>整数类型的格式"></a>新增<code>&lt;inttypes.h&gt;</code>整数类型的格式</h2><h2 id="新增-lt-complex-h-gt-复数算术运算"><a href="#新增-lt-complex-h-gt-复数算术运算" class="headerlink" title="新增<complex.h>复数算术运算"></a>新增<code>&lt;complex.h&gt;</code>复数算术运算</h2><h2 id="新增-lt-tgmath-h-gt-泛型数学"><a href="#新增-lt-tgmath-h-gt-泛型数学" class="headerlink" title="新增<tgmath.h>泛型数学"></a>新增<code>&lt;tgmath.h&gt;</code>泛型数学</h2><p><tgmath.h>提供了带参数的宏，宏的名字与<math.h>和<complex.h>中的函数名相匹配。这些泛型宏（type-generic macro）可以检测参数的类型，然后调用<math.h>或<complex.h>中相对应的函数。</complex.h></math.h></complex.h></math.h></tgmath.h></p><p>比如：sqrt函数不仅有3种复数版本（csqrt、csqrtf和csqrtl），还有double（sqrt）、float（sqrtf）以及long double版本（sqrtl）。使用<tgmath.h>后，程序员可以直接使用sqrt，而不用担心需要的到底是哪个版本：根据参数x类型的不同，函数调用sqrt(x)有可能是6个版本sqrt中的任何一个。</tgmath.h></p><p>顺便提一下，<tgmath.h>中包含了<math.h>和<complex.h>。</complex.h></math.h></tgmath.h></p><h2 id="新增-lt-fenv-h-gt-浮点环境"><a href="#新增-lt-fenv-h-gt-浮点环境" class="headerlink" title="新增<fenv.h>浮点环境"></a>新增<code>&lt;fenv.h&gt;</code>浮点环境</h2><p>IEEE标准754在表示浮点数时使用最广泛。（C99标准把IEEE 754成为IEC 60559）。<fenv.h>的目的是使程序可以访问IEEE标准指定的浮点状态标志和控制模式。</fenv.h></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法=逻辑+控制</title>
      <link href="suan-fa-luo-ji-kong-zhi/"/>
      <url>suan-fa-luo-ji-kong-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="观点"><a href="#观点" class="headerlink" title="观点"></a>观点</h2><p><a href="https://en.wikipedia.org/wiki/Robert_Kowalski">Robert Kowalski</a>在其论文<a href="https://www.doc.ic.ac.uk/~rak/papers/algorithm%20=%20logic%20+%20control.pdf">Algorithm = Logic + Control</a>中指出：</p><blockquote><p>An algorithm can be regarded as consisting of a logic component, which specifies the knowledge to be used in solving problems, and a control component, which determines the problem-solving strategies by means of which that knowledge is used. The logic component determines the meaning of the algorithm whereas the control component only affects its efficiency. The efficiency of an algorithm can often be improved by improving the control component without changing the logic of the algorithm. We argue that computer programs would be more often correct and more easily improved and modified if their logic and control aspects were identified and separated in the program text.</p><p>算法可以视为由逻辑部分和控制部分组成。其中，逻辑部分指明了解决问题时需要用到的知识。而控制部分则（根据逻辑部分用到的知识来）决定解决问题时需要用到的策略。逻辑部分确定算法的含义，而控制部分只影响其效率。在不改变算法逻辑部分的条件下，通常可以通过改进算法控制部分来提升算法的效率。我们认为，如果软件代码中的逻辑部分和控制部分能够有效的识别和区分开，那么软件将会变得更加容易改进和维护。</p><p>We have argued that conventional algorithms can usefully be regarded as consisting of two components:<br>(1) a logic component which specifies what is to be done and<br>(2) a control component which determines how it is to be done.</p><p>我们认为传统的算法可以被视为由两个部分组成：<br>(1) 一个表明算法<code>做什么</code>的逻辑部分<br>(2) 和一个决定了算法<code>如何做</code>的控制部分。</p></blockquote><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>那么如何来理解<code>算法 = 逻辑 + 控制</code>以及如何区分算法中的<code>逻辑</code>和<code>控制</code>呢？作者举例几个例子来阐述，其中一个简单易懂的例子就是阶乘。</p><p>首先，阶乘的定义是：</p><ol><li><code>0</code>的阶乘是<code>1</code>。</li><li>如果<code>x</code>的阶乘是<code>v</code>，那么<code>x+1</code>的阶乘就是<code>v*(x+1)</code>。</li></ol><p>我们一般有两种方式计算一个数n的阶乘：</p><ol><li>自底向上。首先计算<code>0</code>的阶乘，然后是<code>1</code>，然后是<code>2</code>…一直到<code>n</code>。本质就是从<code>0</code>循环计算直到<code>n</code>。</li><li>自顶向下。要计算<code>n</code>的阶乘，首先就要计算<code>n-1</code>的阶乘。要计算<code>n-1</code>的阶乘，首先就要计算<code>n-2</code>的阶乘。这样一直到需要计算0的阶乘，而我们知道<code>0</code>的阶乘是<code>1</code>。本质就是递归的求解。</li></ol><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>结合<a href="#观点">Robert Kowalski的观点</a>和上面的<a href="#举例">阶乘的例子</a>来理解。</p><p>阶乘算法可以视为由两个部分组成：</p><ol><li>逻辑部分，是阶乘的定义。<br>为什么呢？逻辑部分的定义就是<code>做什么</code>，而阶乘算法的<code>做什么</code>就是计算一个数的阶乘。其中”<em>逻辑部分指明了解决问题时需要用到的知识</em>“的知识，指的就是阶乘算法的定义。换而言之，算法的逻辑部分，指定是算法的业务逻辑。</li><li>控制部分，是阶乘的计算方法。<br>为什么呢？控制部分的定义就是<code>如何做</code>，上面例子中如何计算的阶乘的方法有两种：自底向上和自顶向下。”<em>在不改变算法逻辑部分的条件下，通常可以通过改进算法控制部分来提升算法的效率。</em>“ 我们也确实可以通过优化阶乘计算过程中的细节来提高计算的效率，比如在自底向上的方法中，缓存计算过的值，避免重复计算来提高效率。但是我们很难通过调整阶乘定义的描述方式来优化整个阶乘算法的效率。</li></ol><p>另外一个容易理解的例子是排序算法。不同的排序算法都可以实现排序的功能，而不用的排序算法的效率是不同的，比如冒泡排序，归并排序等。所以对排序算法来说，排序功能是<code>逻辑部分</code>，冒泡、归并等具体的做法则是排序算法的<code>控制部分</code>。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><a href="#观点">Robert Kowalski的观点</a>帮助我们能够更好的分解程序中的算法，将<code>做什么</code>和<code>怎么做</code>的代码分开，其实也是应用<a href="https://kibazen.cn/she-ji-mo-shi-du-shu-bi-ji/">设计模式</a>中<code>策略模式</code>的过程。</p><p>我们都知道，程序是由算法和数据结构组成的（最开始由<a href="https://en.wikipedia.org/wiki/Niklaus_Wirth">Niklaus Wirth</a>在其书<a href="http://www.ethoberon.ethz.ch/WirthPubl/AD.pdf">Algorithms + Data Structures = Programs</a>提出），即<code>算法 + 数据结构 = 程序</code>，而<a href="#观点">Robert Kowalski的观点</a>则是将这个公式进一步的细化，从而让我们能够得出：<code>算法逻辑 + 算法控制 + 数据结构 = 程序</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通俗易懂的介绍CAP定理</title>
      <link href="tong-su-yi-dong-de-jie-shao-cap-ding-li/"/>
      <url>tong-su-yi-dong-de-jie-shao-cap-ding-li/</url>
      
        <content type="html"><![CDATA[<p>本文<code>意译</code>自<a href="http://ksat.me/">Kaushik Sathupadi</a>博客中的一篇博文，该博文通俗易懂的介绍了CAP定理。<br>原文：<a href="http://ksat.me/a-plain-english-introduction-to-cap-theorem">A plain english introduction to CAP Theorem</a><br>翻译：<a href="https://kibazen.cn">kibazen</a></p><hr><p>你经常会听说CAP定理，该定理指明了在设计分布式系统时的一些上限限制。与我大多数其他的教程一样，让我们通过真实世界中的例子来理解CAP定理。</p><blockquote><p>译注：CAP指：一致性（Consistency）、可用性（Availability）、分区容忍性（Partition tolerance）。</p></blockquote><h2 id="一、新的事业“记忆公司”"><a href="#一、新的事业“记忆公司”" class="headerlink" title="一、新的事业“记忆公司”"></a>一、新的事业“记忆公司”</h2><p>昨晚，当你的妻子感谢你记得她的生日，并给她买了礼物时，你的脑海中突然冒出一个奇怪的想法。大家都不擅长记忆，但是你却擅长记忆。所以，为什么不用自己的记忆天赋来创业呢？心动不如行动，于是你z在报纸上打了一个广告：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">记忆公司 —— 即使你不记得，都不会忘记是否还在为忘记很多事而烦恼？不用担心，只需一个电话就可以解决！当你需要记住某事时，拨打电话555-55-REMEN告诉我们你想记住的事。比如：打电话告诉我们你上司的电话号码，然后就可以忘记它了。当拨打同样的电话号码555-55-REMEN，我们就会告诉你上司的电话号码。收费：每次服务仅需0.1元哦！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后，你与客户典型的一次对话内容就会像下面这样：</p><ul><li>客户：你好，麻烦帮我记一下我邻居的生日？</li><li>你：好的，请问是多少？</li><li>客户：1月2日</li><li>你：（记在笔记本上）已经记录好了。当你需要时请再联系我们！</li><li>客户：谢谢！</li><li>你：没关系！本次服务收费0.1元！</li></ul><h2 id="二、业务增长"><a href="#二、业务增长" class="headerlink" title="二、业务增长"></a>二、业务增长</h2><p>因为你的想法很简单，只需要笔记本和电话就能高效的完成业务，公司发展的很顺利，也收到了YCombinator的投资。公司的业务越来越多，每天都会接到上千个电话。</p><p>但是问题也开始出现了，客户需要等待越来越久电话才会接通。一些客户甚至听烦了服务电话的铃声，直接在等待接通的过程中就挂断了电话。同时，当你生病无法工作时，就会白白的丢失了一天业务。这对当天需要服务的客户来说，体验也很不好。所以，是时候扩大公司的规模了，让你的妻子也来帮忙。</p><blockquote><p>译注：随着业务的增长，单点的服务已经不能满足业务的需求。</p></blockquote><p>一个简单的计划：</p><ol><li>你和你的妻子同时接听客户的电话。</li><li>对客户来说，还是只需要记住<code>555-55-REMEN</code>这个电话。</li><li>客户的服务电话会平均且高效的分配给你们。</li></ol><h2 id="三、服务第一次出现问题"><a href="#三、服务第一次出现问题" class="headerlink" title="三、服务第一次出现问题"></a>三、服务第一次出现问题</h2><p>实施新计划的两天后，你接到了老客户John的电话。下面是当时的通话记录：</p><ul><li>John：你好！</li><li>你：欢迎拨打记忆公司热线，有什么可以帮到你？</li><li>John：请告诉我到新泽西的飞机是几点的？</li><li>你：好的，请稍等……（翻了一下自己的笔记本，没找到相关的内容）</li><li>你：你好，你好像并没有告诉我你飞机的信息，我这里找不到相关的信息。</li><li>John：什么？我昨天不是告诉你们了吗？（电话就被挂断了）</li></ul><p>怎么回事呢？John说谎了吗？你思考了一会，然后发现了问题的所在：是不是昨天是你的妻子接到的电话？然后你看妻子的笔记本上面确实有相关信息，这时你和你的妻子才认识到出问题了。</p><p>这个电话分配计划设计的有问题啊！分配系统没有保证<code>一致性</code>！客户每次打来的电话都不一定是同一个人接到，那么客户得到的回答就可能是不对的。</p><blockquote><p>译注：一致性：同样的请求，每次处理的结果应当一致。</p></blockquote><h2 id="四、解决一致性问题"><a href="#四、解决一致性问题" class="headerlink" title="四、解决一致性问题"></a>四、解决一致性问题</h2><p>你的竞争对手可能会忽略这个问题，但是你不会。于是你思考整夜，终于在早上想出了一个不错的计划：</p><ol><li>当接到客户要求我们记录事情的电话时，在挂电话之前，都要先通知另外的人新记录事情的内容。</li><li>所有人同时将新纪录事情的内容<code>更新</code>到各自的笔记本上。</li><li>因为所有人的本子上都有最新的所有已记录的事情，所以，当客户再来问之前记录的内容时，就不用问其他人，因为自己的笔记本上就可以查到了。</li></ol><p>但是这个计划有一个问题，第2步”<code>更新</code>“会影响所有人，这样大家就不能同时工作了。比如：你接到一个记录事情的电话，然后马上告诉我也需要记录这个事，这时我就没办法接听其他客户的电话了。但是这可以接受的，因为大多数客户打来电话都是查询之前的内容（记一次，问多次）。同时，这种方法也解决了之前记了事情但是查不到的问题。</p><p>“这个系统还有一个问题你没考虑到。”你的妻子说。如果我们中有一人某天没有工作时就会出问题，我们不能再记录任何新的事情，因为无法更新那个没工作的人的笔记本。这样就会出现<code>可用性</code>的问题。比如：如果你今天没工作，而此时我又接到一个更新电话，那我就没法完成更新的工作，因为我不能更新你的笔记本。</p><blockquote><p>译注：可用性：即使系统内部某些子系统出现问题，整个系统依然能正常的对外提供服务。</p></blockquote><h2 id="五、更好的解决方法"><a href="#五、更好的解决方法" class="headerlink" title="五、更好的解决方法"></a>五、更好的解决方法</h2><p>你终于意识到了为什么分布式系统并没一开始想的那么简单了。难道就找不到一个既能保证<code>一致性</code>，同时也能保证<code>可用性</code>的解决方法了吗？于是你经过彻夜的思考，在早上又想出了一个和之前的类似，但是更好的计划：</p><ol><li>当接到客户要求我们记录事情的电话时，在挂电话之前，都要先通知另外的人新记录事情的内容。</li><li>如果其他人在正常的工作的话，那么就同时将新纪录事情的内容<code>更新</code>到各自的笔记本上。如果有人没有正常工作的话，就需要给他发邮件提醒他更新。等到他们开始正常工作时，首先需要根据所有收到的更新邮件来更新笔记本，更新完成后，才能开始接电话，为客户提供服务。</li><li>因为所有人的本子上都有最新的所有已记录的事情，所以，当客户再来问之前记录的内容时，就不用问其他人，因为自己的笔记本上就可以查到了。</li></ol><p>太好了！这下“记忆公司”提供的服务就能同时保证<code>一致性</code>和<code>可用性</code>了。</p><h2 id="六、妻子怒了"><a href="#六、妻子怒了" class="headerlink" title="六、妻子怒了"></a>六、妻子怒了</h2><p>有了上面的计划，现在公司的事情进展的很顺利。但是如果你和你的妻子都在上班，而其中一个人接收到更新电话时并没有通知其他人更新呢？比如：你惹你妻子不高兴了，她决定今天一天都不理你了，也不通知你更新笔记本了。那么今天你妻子的笔记本的所有更新你笔记本上都没有。所以，上面的计划只是保证<code>一致性</code>和<code>可用性</code>，并没有保证<code>分区容忍性</code>。<br>你也可以选择在哄好妻子之前，不接任何客户的电话来避免这个问题。但是在你哄好妻子前的这段时间，系统又是不可用的，这样又没法保证<code>可用性</code>了。</p><blockquote><p>分区容忍性：即使各个系统暂时无法正常的通信，整个系统依然能正常的对外提供服务。</p></blockquote><h2 id="七、结论"><a href="#七、结论" class="headerlink" title="七、结论"></a>七、结论</h2><p>好了，让我们来看看CAP定理到底在说什么。CAP定理说的是：当你设计分布式系统时，无法同时让系统满足<code>一致性</code>、<code>可用性</code>和<code>分区容忍性</code>。顶多只能满足其中的两个：</p><ol><li><code>一致性</code>：对你的客户来说，一旦他们更新要记住的事。无论何时，他们总是能获取到最新的记录内容。</li><li><code>可用性</code>：只要你和你的妻子中有人在上班，公司就能正常且正确运行。</li><li><code>分区容忍性</code>：即使你和你的妻子有一段时间不沟通了，公司依然能正常且正确的运行。</li></ol><h2 id="额外奖励：-请一个可以来回跑的秘书来保证最终结果的一致性"><a href="#额外奖励：-请一个可以来回跑的秘书来保证最终结果的一致性" class="headerlink" title="额外奖励： 请一个可以来回跑的秘书来保证最终结果的一致性"></a>额外奖励： 请一个可以来回跑的秘书来保证最终结果的一致性</h2><p>这里还有一个其他的解决方法。可以请一个秘书，当你或你的妻子笔记本更新时，她可以帮你们自动的更新其他人的笔记本上。这么做的最大好处就是：在有记录更新时，就不用等待其他人的笔记本更新完了才能接下一个电话了。这也是很多NoSQL系统的工作原理：数据库节点本地更新自己，然后一个后台进程再将这些修改同步到其他的数据库节点。这种方法的唯一问题就在于会在短时间内丢失一致性。比如：你的妻子接到了客户的更新电话，在秘书把你妻子笔记本上的这个变化同步到你的笔记本上之前，这个客户又打电话来问，但是是你接到了这个电话，这时他就会得到一个错误的回答。话虽如此，这种情况还是比较少的。比如：假如你的客户不会在5分钟内就来打电话问呢。</p><p>这个就是CAP和最终一致性，本文到此结束。</p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机中浮点数的表示方法</title>
      <link href="ji-suan-ji-zhong-fu-dian-shu-de-biao-shi-fang-fa/"/>
      <url>ji-suan-ji-zhong-fu-dian-shu-de-biao-shi-fang-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="IEEE-754标准"><a href="#IEEE-754标准" class="headerlink" title="IEEE 754标准"></a>IEEE 754标准</h2><p>在C/C++等编程语言中，浮点数在计算机中的表示采用的是IEEE 754标准。该标准一共的规定了四种表示浮点数值的方式，其中常见的表示方式有两种：单精确度（32位）和双精确度（64位）。这两种表示方式在C/C++语言中分别可以用<code>float</code>和<code>double</code>关键字来定义。</p><h2 id="单精度浮点数的表示方法"><a href="#单精度浮点数的表示方法" class="headerlink" title="单精度浮点数的表示方法"></a>单精度浮点数的表示方法</h2><p>单精度浮点数的表示方法其实就是把一个32位分成了三个部分：</p><ol><li>第一个部分，占1位，表示浮点数的符号，英文Sign，简称为S。</li><li>第二个部分，占8位，表示浮点数的指数，英文Exponent，简称为E。</li><li>第三个部分，占23位，表示浮点数的尾数，英文Mantissa，简称为M。</li></ol><p>如下图所示：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text"> 31         22                    0+----------------------------------+|S|EEEEEEEE|MMMMMMMMMMMMMMMMMMMMMMM|+----------------------------------+   30     23<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应浮点数表示的值为：</p><script type="math/tex; mode=display">(-1)^S \cdot (1 + \frac{M}{2^{23}}) \cdot 2^{(E-127)}</script><p>结合上面的公式，来理解各个部分的意义就更容易了：</p><ol><li><p>符号部分，$(-1)^S$</p><p> 当S为0时，$(-1)^0 = 1$，表示浮点数的值大于0；同理，当S为1时，$(-1)^1 = -1$，表示浮点数的值小于0。</p></li><li><p>指数部分，$2^{(E-127)}$</p><p> 首先要明白：对于任何一个正实数x，都可以找到一个整数n，使得$2^n &lt;= x &lt; 2^{n+1}$。举个例子，比如5，可以找到n=2，使得$2^2 &lt;= 5 &lt; 2^3$，即$4 &lt;= 5 &lt; 8$。浮点数中的指数部分就是这里的n。</p><p> 那么为什么还要减去127呢？因为当浮点数值的绝对值小于1时，指数部分其实是小于0的。举个例子，比如0.45，只有$n=-2$时，使得$2^{-2} &lt;= 0.45 &lt; 2^{-1}$，即$0.25 &lt;= 0.45 &lt; 0.5$。而浮点数中指数部分占8位，可以表示范围[0-$2^8$)，即[0-256)，为了在指数部分能够表示负数，<code>IEEE 754规定</code>减去127，即$n = E - 127$。所以，如果浮点数的$n=-2$，那么实际的E应该是125。</p></li><li><p>尾数部分，$(1 + \frac{M}{2^{23}})$</p><p> 尾数部分占23位，可以表示范围[0-$2^{23}$)，即[0-8388608)。</p><p> 可以这样理解尾数部分：把一条线分成8388608个段，也就是把$2^n$到$2^{n+1}$分成8388608个线段。尾数部分的值M，表示从$2^n$到浮点数值的绝对值x所要经过的线段数量，也就是$2^n$到x的长度占$2^n$到$2^{n+1}$长度的比例是多少。这个比例的值就是尾数部分公式中$\frac{M}{2^{23}}$的来由，而加1则表示线段的起点$2^n$的值。</p></li></ol><h2 id="单精度浮点数举例"><a href="#单精度浮点数举例" class="headerlink" title="单精度浮点数举例"></a>单精度浮点数举例</h2><p>有了上面的说明，再结合例子来理解一下，比如浮点数3.14：</p><ol><li><p>符号部分</p><p> 因为3.14大于0，所以$S = 0$。</p></li><li><p>指数部分</p><p> $2^1 &lt;= 3.14 &lt; 2^2$，所以$n=1$，那么$E = n + 127 = 128$。</p></li><li><p>尾数部分</p><p> $2^1$到3.14的长度占$2^1$到$2^2$长度的比例是$\frac{(3.14 - 2^1)}{(2^2 - 2^1)} = 0.57$</p></li></ol><p>总线段数量为$2^{23}$，那么，从$2^1$到3.14所要经过的线段数量$M = 0.57 * 2^{23} = 4781506.56$，四舍五入，转换成整数结果为$M = 4781507$。<code>因为有四舍五入，所以浮点数保存的数据和实际数据是有误差的。</code></p><p>把S、E、M转换成二进制，就可以得到3.14的二进制表示<code>0x4048f5c3</code>：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text"> S     E             M+----------------------------------+|0|10000000|10010001111010111000011|+----------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>最后代入浮点数公式计算：</p><script type="math/tex; mode=display">(-1)^0 \cdot (1 + \frac{4781507}{2^{23}}) \cdot 2^{(128-127)} = 3.1400001049041748046875</script><p>也可以使用<a href="https://www.h-schmidt.net/FloatConverter/IEEE754.html">IEEE-754浮点数转换工具</a>来分析浮点数的表示方法。</p><h2 id="双精度浮点数的表示方法"><a href="#双精度浮点数的表示方法" class="headerlink" title="双精度浮点数的表示方法"></a>双精度浮点数的表示方法</h2><p>双精度浮点数和单精度浮点数的原理是一样的，只是各个部分长度不同而已。</p><p>双精度浮点数的表示方法其实就是把一个64位分成了三个部分：</p><ol><li>第一个部分，占1位，表示浮点数的符号，英文Sign，简称为S。</li><li>第二个部分，占11位，表示浮点数的指数，英文Exponent，简称为E。</li><li>第三个部分，占52位，表示浮点数的尾数，英文Mantissa，简称为M。</li></ol><p>对应浮点数表示的值为：</p><script type="math/tex; mode=display">(-1)^S \cdot (1 + \frac{M}{2^{52}}) \cdot 2^{(E-1023)}</script>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浮点数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《重构：改善既有代码的设计(第2版)》读书笔记</title>
      <link href="chong-gou-gai-shan-ji-you-dai-ma-de-she-ji-di-2-ban-du-shu-bi-ji/"/>
      <url>chong-gou-gai-shan-ji-you-dai-ma-de-she-ji-di-2-ban-du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>重构(refactoring)：在不改变代码外在行为的前提下，对代码做出修改，以改进程序的内部结构。重构的本质就是在代码写好之后改进它的设计。</li></ol><h2 id="第1章-重构，第一个示例"><a href="#第1章-重构，第一个示例" class="headerlink" title="第1章 重构，第一个示例"></a>第1章 重构，第一个示例</h2><ol><li>如果你要给程序添加一个特性，但发现代码因缺乏良好的结构而不易于进行更改，那就先重构那个程序，使其比较容易添加该特性，然后再添加该特性。</li><li>需求的变化使重构变得必要。如果一段代码能正常工作，并且不会再被修改，那么完全可以不去重构它。</li><li>重构的第一步：确保即将被修改的代码拥有一组可靠的测试。这些测试必须有自我检验能力。</li><li>无论每次重构多么简单，养成重构后即运行测试的习惯非常重要。</li><li>对于重构过程的性能问题的处理：大多数情况下可以忽略它。如果重构引入了性能损耗，先完成重构，再做性能优化。</li><li>编程时，需要遵循营地法则：保证你离开时的代码库一定比来时更健康。</li><li>好代码的检验标准就是人们是否能轻而易举地修改它。</li></ol><h2 id="第2章-重构的原则"><a href="#第2章-重构的原则" class="headerlink" title="第2章 重构的原则"></a>第2章 重构的原则</h2><ol><li>重构(名词)：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。</li><li>重构(动词)：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。</li><li>如果有人说他们的代码在重构过程中有一两天时间不可用，基本上可以确定，他们在做的事不是重构。</li><li>“结构调整”(restructuring)泛指对代码库进行的各种形式的重新组织或清理，重构则是特定的一类结构调整。</li><li>使用重构技术开发软件时，添加新功能和重构，同一时间，二者只能做其一。</li><li>为何重构：重构改进软件的设计；重构使软件更容易理解；重构帮助找到bug；重构提高编程速度。</li><li>何时重构：预备性重构(添加新功能之前重构)；帮助理解的重构(提升代码阅读性)；捡垃圾式重构(消除代码冗余等)；有计划的重构(固定周期对之前写过的代码重构)和见机行事的重构(写新代码过程中发现其他代码需要重构)；长期重构(更新三方库等)；代码复审时重构。</li><li>不必将重构与添加新功能在版本控制的提交中分开。原因：重构常因新功能所致，单独提交脱离重构的上下文，体现不出为何需要重构；重构的代码和新功能代码高耦合。</li><li>如果经理不能接受代码重构需要花时间，那就不要给经理说。</li><li>何时不应该重构：凌乱且不需要修改的代码；重写比重构更容易的代码。</li><li>重构的挑战：延缓新功能开发；代码所有权(代码是其他部门写的)；分支(多分支开发，最后合并代码)；测试(代码测试不完善，无法保证重构后不引入新BUG)；遗留代码；数据库(改字段值)。</li><li>重构的唯一目的就是让我们开发更快，用更少的工作量创造更大的价值。</li><li>“写代码之前就完成软件的设计和架构”这个思想是不正确的。因为需求会变，且一开始的考虑而不是完全的周全。</li><li>三大实践：自测试代码、持续集成、重构。</li><li>用性能测试工具去定位性能问题，而不是根据对代码的了解来猜测。</li><li>一些语言(Java、C#等)可以借助工具进行自动化的重构。</li></ol><h2 id="第3章-代码的坏味道"><a href="#第3章-代码的坏味道" class="headerlink" title="第3章 代码的坏味道"></a>第3章 代码的坏味道</h2><ol><li>当你”闻到”代码中有坏味道时，就表明代码需要进行重构了。</li><li>当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余。</li><li>神秘命名。</li><li>重复代码。</li><li>过长函数。</li><li>过长参数列表。</li><li>全局数据。(PS：慎用单例模式)</li><li>可变数据(如在js中使用Immutable.js)。</li><li>发散式变化(违背了单一职责原则)。</li><li>霰弹式修改(需求变化是，需要在很多个地方做修改。封装性不够好)。</li><li>依恋情结(违背了依赖倒置原则)。</li><li>数据泥团(很多类中的变量名相同，考虑抽象出基类)。</li><li>基本类型偏执(针对问题域定义新的类型而不是用基本类型，比如定义坐标类，而不是用std::pair)。</li><li>重复的switch。</li><li>循环语句。</li><li>冗赘的元素(有些类结构是不必要的)。</li><li>夸夸其谈通用性。</li><li>临时字段(类内部某个字段仅为某种特定情况而设)。</li><li>过长的消息链。</li><li>中间人(过度使用委托)。</li><li>内幕交易(用委托替代继承等)。</li><li>过大的类。</li><li>异曲同工的类。</li><li>纯数据类(使用面向对象编程而不是面向过程)。</li><li>被拒绝的遗赠(子类复用了超类的实现，却又不愿意支持超类的接口，那就不要用继承)。</li><li>注释(过长的注释)。</li></ol><h2 id="第4章-构筑测试体系"><a href="#第4章-构筑测试体系" class="headerlink" title="第4章 构筑测试体系"></a>第4章 构筑测试体系</h2><ol><li>稳固的测试集合是正确地进行重构的前提条件之一。</li><li>确保所有测试都完全自动化，让它们检查自己的测试结果。</li><li>一套测试就是一个强大的bug侦测器，能够大大缩减查找bug所需的时间。</li><li>测试驱动开发的编程方式依赖于下面这个短循环：先编写一个（失败的）测试，编写代码使测试通过，然后进行重构以保证代码整洁。</li><li>总是确保测试不该通过时真的会失败。</li><li>频繁地运行测试。对于你正在处理的代码，与其对应的测试至少每隔几分钟就要运行一次，每天至少运行一次所有的测试。</li><li>编写未臻完善的测试并经常运行，好过对完美测试的无尽等待。</li><li>考虑可能出错的边界条件，把测试火力集中在那儿。</li><li>如果错误会导致脏数据在应用中到处传递，或是产生一些很难调试的失败，考虑引入断言手法，使代码不满足预设条件时快速失败。不用为这样的失败断言添加测试，它们本身就是一种测试的形式。</li><li>不要因为测试无法捕捉所有的bug就不写测试，因为测试的确可以捕捉到大多数bug。</li><li>每当你收到bug报告，请先写一个单元测试来暴露这个bug。</li></ol><h2 id="第5章-介绍重构名录"><a href="#第5章-介绍重构名录" class="headerlink" title="第5章 介绍重构名录"></a>第5章 介绍重构名录</h2><ol><li>书的剩余部分是重构方法的索引，作为参看书来使用。</li></ol><h2 id="第6章-第一组重构"><a href="#第6章-第一组重构" class="headerlink" title="第6章 第一组重构"></a>第6章 第一组重构</h2><ol><li>提炼函数 vs 内联函数。</li><li>提炼变量 vs 内联变量。</li><li>改变函数声明。</li><li>封装变量。</li><li>变量改名。</li><li>引入参数对象。</li><li>函数组合成类v</li><li>函数组合成变换。</li><li>拆分阶段。</li></ol><h2 id="第7章-封装"><a href="#第7章-封装" class="headerlink" title="第7章 封装"></a>第7章 封装</h2><ol><li>封装记录。</li><li>封装集合。</li><li>以对象取代基本类型。</li><li>以查询取代临时变量。</li><li>提炼类 vs 内联类。</li><li>隐藏委托关系 vs 移除中间人。</li><li>替换算法。</li></ol><h2 id="第8章-搬移特性"><a href="#第8章-搬移特性" class="headerlink" title="第8章 搬移特性"></a>第8章 搬移特性</h2><ol><li>搬移函数。</li><li>搬移字段。</li><li>搬移语句到函数 vs 搬移语句到调用者。</li><li>移动语句。</li><li>拆分循环。</li><li>以管道取代循环。</li><li>移除死代码。</li></ol><h2 id="第9章-重新组织数据"><a href="#第9章-重新组织数据" class="headerlink" title="第9章 重新组织数据"></a>第9章 重新组织数据</h2><ol><li>拆分变量。</li><li>字段改名。</li><li>以查询取代派生变量。</li><li>将引用对象改为值对象 vs 将值对象改为引用对象。</li></ol><h2 id="第10章-简化条件逻辑"><a href="#第10章-简化条件逻辑" class="headerlink" title="第10章 简化条件逻辑"></a>第10章 简化条件逻辑</h2><ol><li>分解条件表达式 vs 合并条件表达式。</li><li>以卫语句取代嵌套条件表达式(Replace Nested Conditional with Guard Clauses)。</li><li>以多态取代条件表达式。</li><li>引入特例。</li><li>引入断言。</li></ol><h2 id="第11章-重构API"><a href="#第11章-重构API" class="headerlink" title="第11章 重构API"></a>第11章 重构API</h2><ol><li>将查询函数和修改函数分离。</li><li>函数参数化。</li><li>移除标记参数。</li><li>保持对象完整。</li><li>以查询取代参数 vs 以参数取代查询。</li><li>移除设值函数。</li><li>以工厂函数取代构造函数。</li><li>以命令取代函数 vs 以函数取代命令。</li></ol><h2 id="第12章-处理继承关系"><a href="#第12章-处理继承关系" class="headerlink" title="第12章 处理继承关系"></a>第12章 处理继承关系</h2><ol><li>函数上移 vs 函数下移。</li><li>字段上移 vs 字段下移。</li><li>构造函数本体上移。</li><li>以子类取代类型码 vs 移除子类。</li><li>提炼超类。</li><li>折叠继承体系。</li><li>以委托取代子类。</li><li>以委托取代超类。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《设计模式》读书笔记</title>
      <link href="she-ji-mo-shi-du-shu-bi-ji/"/>
      <url>she-ji-mo-shi-du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><h3 id="1-1-设计模式的编目"><a href="#1-1-设计模式的编目" class="headerlink" title="1.1 设计模式的编目"></a>1.1 设计模式的编目</h3><ol><li><strong>Abstract Factory</strong>: 提供了一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</li><li><strong>Adapter</strong>: 将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</li><li><strong>Bridge</strong>: 将抽象部分与它的实现部分分离，使它们都可以独立地变化。</li><li><strong>Builder</strong>: 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</li><li><strong>Chain of Responsibility</strong>: 为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。</li><li><strong>Command</strong>: 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。</li><li><strong>Composite</strong>: 将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得客户对单个对象和复合对象的使用具有一致性。</li><li><strong>Decorator</strong>: 动态地给一个对象添加一些额外的职责。就扩展功能而言，Decorator模式比生成子类方式更为灵活。</li><li><strong>Facade</strong>: 为子系统中的一组接口提供一个一致，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</li><li><strong>Factory Method</strong>: 定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method是一个类的实例化延迟到其子类。</li><li><strong>Flyweight</strong>: 运用共享技术有效地支持大量细粒度的对象。</li><li><strong>Interpreter</strong>: 给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。</li><li><strong>Iterator</strong>: 提供了一个方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。</li><li><strong>Mediator</strong>: 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</li><li><strong>Memento</strong>: 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</li><li><strong>Observer</strong>: 定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。</li><li><strong>Prototype</strong>: 用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。</li><li><strong>Proxy</strong>: 为其他对象提供一个代理以控制对这个对象的访问。</li><li><strong>Singleton</strong>: 保证一个类仅有一个实例，并提供一个访问它的全局访问点。</li><li><strong>State</strong>: 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。</li><li><strong>Strategy</strong>: 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。</li><li><strong>Template Method</strong>: 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</li><li><strong>Visitor</strong>: 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</li></ol><h3 id="1-2-组织编目"><a href="#1-2-组织编目" class="headerlink" title="1.2 组织编目"></a>1.2 组织编目</h3><p><img src="/images/《设计模式》读书笔记/设计模式空间.png" alt="设计模式空间"></p><h3 id="1-3-怎样选择设计模式"><a href="#1-3-怎样选择设计模式" class="headerlink" title="1.3 怎样选择设计模式"></a>1.3 怎样选择设计模式</h3><p><img src="/images/《设计模式》读书笔记/设计模式所支持的设计的可变方面.png" alt="设计模式所支持的设计的可变方面"></p><hr><h2 id="二、创建型模式"><a href="#二、创建型模式" class="headerlink" title="二、创建型模式"></a>二、创建型模式</h2><h3 id="2-1-Abstract-Factory-抽象工厂"><a href="#2-1-Abstract-Factory-抽象工厂" class="headerlink" title="2.1 Abstract Factory(抽象工厂)"></a>2.1 Abstract Factory(抽象工厂)</h3><h4 id="2-1-1-类图"><a href="#2-1-1-类图" class="headerlink" title="2.1.1 类图"></a>2.1.1 类图</h4><p><img src="/images/《设计模式》读书笔记/抽象工厂类图.png" alt="抽象工厂类图"></p><h4 id="2-1-2-参与者"><a href="#2-1-2-参与者" class="headerlink" title="2.1.2 参与者"></a>2.1.2 参与者</h4><p>AbstractFactory</p><ol><li>声明一个创建抽象产品对象的操作接口。</li></ol><p>ConcreteFactory</p><ol><li>实现创建具体产品对象的操作。</li></ol><p>AbstractProduct</p><ol><li>为一类产品声明一个接口。</li></ol><p>ConcreteProduct</p><ol><li>定义一个将被相应的具体工厂创建的产品对象。</li><li>实现AbstractProduct接口。</li></ol><p>Client</p><ol><li>仅使用由AbstractFactory和AbstractProduct类声明的接口。</li></ol><h4 id="2-1-3-协作"><a href="#2-1-3-协作" class="headerlink" title="2.1.3 协作"></a>2.1.3 协作</h4><ol><li>通常在运行时刻创建一个ConcreteFactory类的实例。这一具体的工厂创建具有特定实现的产品对象。为创建不同的产品对象，客户应使用不同的具体工程。</li><li>AbstractFactory将产品对象的创建延迟到它的ConcreteFactory子类。</li></ol><h3 id="2-2-Builder-生成器"><a href="#2-2-Builder-生成器" class="headerlink" title="2.2 Builder(生成器)"></a>2.2 Builder(生成器)</h3><h4 id="2-2-1-类图"><a href="#2-2-1-类图" class="headerlink" title="2.2.1 类图"></a>2.2.1 类图</h4><p><img src="/images/《设计模式》读书笔记/生成器类图.png" alt="生成器类图"></p><h4 id="2-2-2-参与者"><a href="#2-2-2-参与者" class="headerlink" title="2.2.2 参与者"></a>2.2.2 参与者</h4><p>Builder</p><ol><li>为创建一个Product对象的各个部件指定抽象接口。</li></ol><p>ConcreteBuilder</p><ol><li>实现Builder的接口以构造和装配该产品的各个部件。</li><li>定义并明确它所创建的表示。</li><li>提供一个检索产品的接口。</li></ol><p>Director</p><ol><li>构造一个使用Builder接口的对象。</li></ol><p>Product</p><ol><li>表示被构造的复杂对象。ConcreteBuilder创建该产品的内部表示并定义它的装配过程。</li><li>包含定义组成部件的类，包括将这些部件装配成最终产品的接口。</li></ol><h4 id="2-2-3-协作"><a href="#2-2-3-协作" class="headerlink" title="2.2.3 协作"></a>2.2.3 协作</h4><ol><li>客户创建Director对象，并用它所想要的Builder对象进行配置。</li><li>一旦产品部件被生成，导向器就会通知生成器。</li><li>生成器处理导向器的请求，并将部件添加到该产品中。</li><li>客户从生成器中检索产品。</li></ol><p>交互图</p><p><img src="/images/《设计模式》读书笔记/生成器协作类图.png" alt="生成器协作类图"></p><h3 id="2-3-Factory-Method-工厂方法"><a href="#2-3-Factory-Method-工厂方法" class="headerlink" title="2.3 Factory Method(工厂方法)"></a>2.3 Factory Method(工厂方法)</h3><h4 id="2-3-1-类图"><a href="#2-3-1-类图" class="headerlink" title="2.3.1 类图"></a>2.3.1 类图</h4><p><img src="/images/《设计模式》读书笔记/工厂方法类图.png" alt="工厂方法类图"></p><h4 id="2-3-2-参与者"><a href="#2-3-2-参与者" class="headerlink" title="2.3.2 参与者"></a>2.3.2 参与者</h4><p>Product</p><ol><li>定义工厂方法所创建的对象的接口。</li></ol><p>ConcreteProduct</p><ol><li>实现Product接口。</li></ol><p>Creator</p><ol><li>声明工厂方法，该方法返回一个Product类型的对象。Creator也可以定义一个工厂方法的缺省实现，它返回一个缺省的ConcreteProduct对象。</li><li>也可以调用工厂方法以创建一个Product对象。</li></ol><p>ConcreteCreator</p><ol><li>重定义工厂方法以返回一个ConcreteProduct实例。</li></ol><h4 id="2-3-3-协作"><a href="#2-3-3-协作" class="headerlink" title="2.3.3 协作"></a>2.3.3 协作</h4><ol><li>Creator依赖于它的子类来定义工厂方法，所以它返回一个适当的ConcreteProduct实例。</li></ol><h3 id="2-4-Prototype-原型"><a href="#2-4-Prototype-原型" class="headerlink" title="2.4 Prototype(原型)"></a>2.4 Prototype(原型)</h3><h4 id="2-4-1-类图"><a href="#2-4-1-类图" class="headerlink" title="2.4.1 类图"></a>2.4.1 类图</h4><p><img src="/images/《设计模式》读书笔记/原型类图.png" alt="原型类图"></p><h4 id="2-4-2-参与者"><a href="#2-4-2-参与者" class="headerlink" title="2.4.2 参与者"></a>2.4.2 参与者</h4><p>Prototype</p><ol><li>声明一个克隆自身的接口。</li></ol><p>ConcretePrototype</p><ol><li>实现一个克隆自身的操作。</li></ol><p>Client</p><ol><li>让一个原型克隆自身从而创建一个新的对象。</li></ol><h4 id="2-4-3-协作"><a href="#2-4-3-协作" class="headerlink" title="2.4.3 协作"></a>2.4.3 协作</h4><ol><li>客户请求一个原型克隆自身。</li></ol><h3 id="2-5-Singleton-单件"><a href="#2-5-Singleton-单件" class="headerlink" title="2.5 Singleton(单件)"></a>2.5 Singleton(单件)</h3><h4 id="2-5-1-类图"><a href="#2-5-1-类图" class="headerlink" title="2.5.1 类图"></a>2.5.1 类图</h4><p><img src="/images/《设计模式》读书笔记/单件类图.png" alt="单件类图"></p><h4 id="2-5-2-参与者"><a href="#2-5-2-参与者" class="headerlink" title="2.5.2 参与者"></a>2.5.2 参与者</h4><p>Singleton</p><ol><li>定义一个Instance操作，允许客户访问它的唯一实例。Instance是一个类操作（C++中的一个静态成员函数）。</li><li>可能负责创建它自己的唯一实例。</li></ol><h4 id="2-5-3-协作"><a href="#2-5-3-协作" class="headerlink" title="2.5.3 协作"></a>2.5.3 协作</h4><ol><li>客户只能通过Singleton的Instance操作访问一个Singleton的实例。</li></ol><hr><h2 id="三、结构型模式"><a href="#三、结构型模式" class="headerlink" title="三、结构型模式"></a>三、结构型模式</h2><h3 id="3-1-Adapter-适配器"><a href="#3-1-Adapter-适配器" class="headerlink" title="3.1 Adapter(适配器)"></a>3.1 Adapter(适配器)</h3><h4 id="3-1-1-类图"><a href="#3-1-1-类图" class="headerlink" title="3.1.1 类图"></a>3.1.1 类图</h4><p>类版本</p><p><img src="/images/《设计模式》读书笔记/适配器类版本类图.png" alt="适配器类版本类图"></p><p>对象版本</p><p><img src="/images/《设计模式》读书笔记/适配器对象版本类图.png" alt="适配器对象版本类图"></p><h4 id="3-1-2-参与者"><a href="#3-1-2-参与者" class="headerlink" title="3.1.2 参与者"></a>3.1.2 参与者</h4><p>Target</p><ol><li>定义Client使用的与特定领域相关的接口。</li></ol><p>Client</p><ol><li>与符合Target接口的对象协同。</li></ol><p>Adaptee</p><ol><li>定义一个已经存在的接口，这个接口需要适配。</li></ol><p>Adapter</p><ol><li>对Adaptee的接口与Target接口进行适配。</li></ol><h4 id="3-1-3-协作"><a href="#3-1-3-协作" class="headerlink" title="3.1.3 协作"></a>3.1.3 协作</h4><ol><li>Client在Adapter实例上调用一些操作。接着适配器调用Adaptee的操作实现这个请求。</li></ol><h3 id="3-2-Bridge-桥接"><a href="#3-2-Bridge-桥接" class="headerlink" title="3.2 Bridge(桥接)"></a>3.2 Bridge(桥接)</h3><h4 id="3-2-1-类图"><a href="#3-2-1-类图" class="headerlink" title="3.2.1 类图"></a>3.2.1 类图</h4><p><img src="/images/《设计模式》读书笔记/桥接类图.png" alt="桥接类图"></p><h4 id="3-2-2-参与者"><a href="#3-2-2-参与者" class="headerlink" title="3.2.2 参与者"></a>3.2.2 参与者</h4><p>Abstraction</p><ol><li>定义抽象类的接口。</li><li>维护一个指向Implementor类型对象的指针。</li></ol><p>RefinedAbstraction</p><ol><li>扩充由Abstraction定义的接口。</li></ol><p>Implementor</p><ol><li>定义实现类的接口，该接口不一定要与Abstraction的接口完全一致；事实上这两个接口可以完全不同。一般来讲，Implementor接口仅提供基本操作，而Abstraction则定义了基于这些基本操作的较高层次的操作。</li></ol><p>ConcreteImplementor</p><ol><li>实现Implementor接口并定义它的具体实现。</li></ol><h4 id="3-2-3-协作"><a href="#3-2-3-协作" class="headerlink" title="3.2.3 协作"></a>3.2.3 协作</h4><ol><li>Abstraction将client的请求转发给它的Implementor对象。</li></ol><h3 id="3-3-Composite-组合"><a href="#3-3-Composite-组合" class="headerlink" title="3.3 Composite(组合)"></a>3.3 Composite(组合)</h3><h4 id="3-3-1-类图"><a href="#3-3-1-类图" class="headerlink" title="3.3.1 类图"></a>3.3.1 类图</h4><p><img src="/images/《设计模式》读书笔记/组合类图.png" alt="组合类图"></p><h4 id="3-3-2-参与者"><a href="#3-3-2-参与者" class="headerlink" title="3.3.2 参与者"></a>3.3.2 参与者</h4><p>Component</p><ol><li>为组合中的对象声明接口。</li><li>在适当的情况下，实现所有类共有接口的缺省行为。</li><li>声明一个接口用于访问和管理Component的子组件。</li><li>(可选)在递归结构中定义一个接口，用于访问一个父组件，并在合适的情况下实现它。</li></ol><p>Leaf</p><ol><li>在组合中表示叶节点对象，叶节点没有子节点。</li><li>在组合中定义图元对象的行为。</li></ol><p>Composite</p><ol><li>定义有子部件的那些部件的行为。</li><li>存储子部件。</li><li>在Component接口中实现与子部件有关的操作。</li></ol><p>Client</p><ol><li>通过Component接口操纵组合部件的对象。</li></ol><h4 id="3-3-3-协作"><a href="#3-3-3-协作" class="headerlink" title="3.3.3 协作"></a>3.3.3 协作</h4><ol><li>用户使用Component类接口与组合结构中的对象进行交互。如果接收者是一个叶节点，则直接处理请求。如果接收者是Composite，它通常将请求发送给它的子部件，在转发请求之前与/或之后可能执行一些辅助操作。</li></ol><h3 id="3-4-Decorator-装饰"><a href="#3-4-Decorator-装饰" class="headerlink" title="3.4 Decorator(装饰)"></a>3.4 Decorator(装饰)</h3><h4 id="3-4-1-类图"><a href="#3-4-1-类图" class="headerlink" title="3.4.1 类图"></a>3.4.1 类图</h4><p><img src="/images/《设计模式》读书笔记/装饰类图.png" alt="装饰类图"></p><h4 id="3-4-2-对象结构示例图"><a href="#3-4-2-对象结构示例图" class="headerlink" title="3.4.2 对象结构示例图"></a>3.4.2 对象结构示例图</h4><p><img src="/images/《设计模式》读书笔记/装饰对象结构示例图.png" alt="装饰对象结构示例图"></p><h4 id="3-4-3-参与者"><a href="#3-4-3-参与者" class="headerlink" title="3.4.3 参与者"></a>3.4.3 参与者</h4><p>Component</p><ol><li>定义一个对象接口，可以给这些对象动态地添加职责。</li></ol><p>ConcreteComponent</p><ol><li>定义一个对象，可以给这个对象添加一些职责。</li></ol><p>Decorator</p><ol><li>维持一个指向Component对象的指针，并定义一个与Component接口一致的接口。</li></ol><p>ConcreteDecorator</p><ol><li>向组件添加职责。</li></ol><h4 id="3-4-4-协作"><a href="#3-4-4-协作" class="headerlink" title="3.4.4 协作"></a>3.4.4 协作</h4><ol><li>Decorator将请求转发给它的Component对象，并有可能在转发请求前后执行一些附加的动作。</li></ol><h3 id="3-5-Facade-外观"><a href="#3-5-Facade-外观" class="headerlink" title="3.5 Facade(外观)"></a>3.5 Facade(外观)</h3><h4 id="3-5-1-类图"><a href="#3-5-1-类图" class="headerlink" title="3.5.1 类图"></a>3.5.1 类图</h4><p><img src="/images/《设计模式》读书笔记/外观类图.png" alt="外观类图"></p><h4 id="3-5-2-参与者"><a href="#3-5-2-参与者" class="headerlink" title="3.5.2 参与者"></a>3.5.2 参与者</h4><p>Facade</p><ol><li>知道哪些子系统类负责处理请求。</li><li>将客户的请求代理给适当的子系统对象。</li></ol><p>Subsystem classes</p><ol><li>实现子系统的功能。</li><li>处理由Facade对象指派的任务。</li><li>没有facade的任何相关信息；即没有指向facade的指针。</li></ol><h4 id="3-5-3-协作"><a href="#3-5-3-协作" class="headerlink" title="3.5.3 协作"></a>3.5.3 协作</h4><ol><li>客户程序通过发送请求给Facade的方式与子系统通信，Facade将这些消息转发给适当的子系统对象。尽管是子系统中的有关对象在做实际工作，但Facade模式本身也必须将它的接口转换成子系统的接口。</li><li>使用Facade的客户程序不需要直接访问子系统对象。</li></ol><h3 id="3-6-Flyweight-享元"><a href="#3-6-Flyweight-享元" class="headerlink" title="3.6 Flyweight(享元)"></a>3.6 Flyweight(享元)</h3><h4 id="3-6-1-类图"><a href="#3-6-1-类图" class="headerlink" title="3.6.1 类图"></a>3.6.1 类图</h4><p><img src="/images/《设计模式》读书笔记/享元类图.png" alt="享元类图"></p><h4 id="3-6-2-对象结构示例图"><a href="#3-6-2-对象结构示例图" class="headerlink" title="3.6.2 对象结构示例图"></a>3.6.2 对象结构示例图</h4><p><img src="/images/《设计模式》读书笔记/享元对象结构示例图.png" alt="享元对象结构示例图"></p><h4 id="3-6-3-参与者"><a href="#3-6-3-参与者" class="headerlink" title="3.6.3 参与者"></a>3.6.3 参与者</h4><p>Flyweight</p><ol><li>描述一个接口，通过这个接口flyweight可以接受并作用于外部状态。</li></ol><p>ConcreteFlyweight</p><ol><li>实现Flyweight接口，并为内部状态（如果有的话）增加存储空间。ConcreteFlyweight对象必须是可共享的。它所存储的状态必须是内部的；即，它必须独立于ConcreteFlyweight对象的场景。</li></ol><p>UnsharedConcreteFlyweight</p><ol><li>并非所有的Flyweight子类都需要被共享。Flyweight接口使共享成为可能，但它并不强制共享。在Flyweight对象结构的某些层次，UnsharedConcreteFlyweight对象通常将ConcreteFlyweight对象作为子节点。</li></ol><p>FlyweightFactory</p><ol><li>创建并管理flyweight对象。</li><li>确保合理地共享flyweight。当用户请求一个flyweight时，FlyweightFactory对象提供一个已创建的实例或者创建一个（如果不存在的话）。</li></ol><p>Client</p><ol><li>维持一个对flyweight的引用。</li><li>计算或存储一个（多个）flyweight的外部状态。</li></ol><h4 id="3-6-4-协作"><a href="#3-6-4-协作" class="headerlink" title="3.6.4 协作"></a>3.6.4 协作</h4><ol><li>flyweight执行时所需的状态必定时内部的或外部的。内部状态存储于ConcreteFlyweight对象之中；而外部对象则由Client对象存储或计算。当用户调用flyweight对象的操作时，将该状态传递给它。</li><li>用户不应直接对ConcreteFlyweight类进行实例化，而只能从FlyeightFactory对象得到ConcreteFlyweight对象，这可以保证对它们适当地进行共享。</li></ol><h3 id="3-7-Proxy-代理"><a href="#3-7-Proxy-代理" class="headerlink" title="3.7 Proxy(代理)"></a>3.7 Proxy(代理)</h3><h4 id="3-7-1-类图"><a href="#3-7-1-类图" class="headerlink" title="3.7.1 类图"></a>3.7.1 类图</h4><p><img src="/images/《设计模式》读书笔记/代理类图.png" alt="代理类图"></p><h4 id="3-7-2-对象结构示例图"><a href="#3-7-2-对象结构示例图" class="headerlink" title="3.7.2 对象结构示例图"></a>3.7.2 对象结构示例图</h4><p><img src="/images/《设计模式》读书笔记/代理对象结构示例图.png" alt="代理对象结构示例图"></p><h4 id="3-7-3-参与者"><a href="#3-7-3-参与者" class="headerlink" title="3.7.3 参与者"></a>3.7.3 参与者</h4><p>Proxy</p><ol><li>保持一个引用使得代理可以访问实体。若RealSubject和Subject的接口相同，Proxy会引用Subject。</li><li>提供一个与Subject的接口相同的接口，这样代理就可以用来替代实体。</li><li>控制对实体的存取，并可能负责创建和删除它。</li><li><p>其他功能依赖于代理的类型：</p><ol><li>Remote Proxy负责对请求及其参数进行编码，并向不同地址空间中的实体发送已编码的请求。</li><li>Virtual Proxy可以缓存实体的附加信息，以便延迟对它的访问。</li><li>Protection Proxy检查调用者是否具有实现一个请求所必须的访问权限。</li></ol></li></ol><p>Subject</p><ol><li>定义RealSubject和Proxy的共用接口，这样就在任何使用RealSubject的地方都可以使用Proxy。</li></ol><p>RealSubject</p><ol><li>定义Proxy所代表的实体。</li></ol><h4 id="3-7-4-协作"><a href="#3-7-4-协作" class="headerlink" title="3.7.4 协作"></a>3.7.4 协作</h4><ol><li>代理根据其种类，在适当的时候向RealSubject转发请求。</li></ol><hr><h2 id="四、行为模式"><a href="#四、行为模式" class="headerlink" title="四、行为模式"></a>四、行为模式</h2><h3 id="4-1-Chain-of-Responsibility-职责链"><a href="#4-1-Chain-of-Responsibility-职责链" class="headerlink" title="4.1 Chain of Responsibility(职责链)"></a>4.1 Chain of Responsibility(职责链)</h3><h4 id="4-1-1-类图"><a href="#4-1-1-类图" class="headerlink" title="4.1.1 类图"></a>4.1.1 类图</h4><p><img src="/images/《设计模式》读书笔记/职责链类图.png" alt="职责链类图"></p><h4 id="4-1-2-对象结构示例图"><a href="#4-1-2-对象结构示例图" class="headerlink" title="4.1.2 对象结构示例图"></a>4.1.2 对象结构示例图</h4><p><img src="/images/《设计模式》读书笔记/职责链对象结构示例图.png" alt="职责链对象结构示例图"></p><h4 id="4-1-3-参与者"><a href="#4-1-3-参与者" class="headerlink" title="4.1.3 参与者"></a>4.1.3 参与者</h4><p>Handler</p><ol><li>定义一个处理请求的接口。</li><li>（可选）实现后继链。</li></ol><p>ConcreteHandler</p><ol><li>处理它所负责的请求。</li><li>可访问它的后继者。</li><li>如果可处理该请求，就处理；否则将该请求转发给它的后继者。</li></ol><p>Client</p><ol><li>向链上的具体处理者(ConcreteHandler)对象提交请求。</li></ol><h4 id="4-1-4-协作"><a href="#4-1-4-协作" class="headerlink" title="4.1.4 协作"></a>4.1.4 协作</h4><ol><li>当客户提交一个请求时，请求沿链传递直至有一个ConcreteHandler对象负责处理它。</li></ol><h3 id="4-2-Command-命令"><a href="#4-2-Command-命令" class="headerlink" title="4.2 Command(命令)"></a>4.2 Command(命令)</h3><h4 id="4-2-1-类图"><a href="#4-2-1-类图" class="headerlink" title="4.2.1 类图"></a>4.2.1 类图</h4><p><img src="/images/《设计模式》读书笔记/命令类图.png" alt="命令类图"></p><h4 id="4-2-2-参与者"><a href="#4-2-2-参与者" class="headerlink" title="4.2.2 参与者"></a>4.2.2 参与者</h4><p>Command</p><ol><li>声明执行操作的接口。</li></ol><p>ConcreteCommand</p><ol><li>将一个接收者对象绑定于一个动作。</li><li>调用接收者相应的操作，以实现Execute。</li></ol><p>Client</p><ol><li>创建一个具体命令对象并设定它的接收者。</li></ol><p>Invoker</p><ol><li>要求该命令执行这个请求。</li></ol><p>Receiver</p><ol><li>知道如何实施与执行一个请求相关的操作。任何类都可能作为一个接收者。</li></ol><h4 id="4-2-3-协作"><a href="#4-2-3-协作" class="headerlink" title="4.2.3 协作"></a>4.2.3 协作</h4><ol><li>Client创建一个ConcreteCommand对象并指定它的Receiver对象。</li><li>某Invoker对象存储该ConcreteCommand对象。</li><li>该Invoker通过调用Command对象的Execute操作来提交一个请求。若该命令是可撤销的，ConcreteCommand就在执行Execute操作之前存储当前状态已用于取消该命令。</li><li>ConcreteCommand对象对调用它的Recevier的进行操作以执行该请求。</li></ol><h4 id="4-2-4-时序图"><a href="#4-2-4-时序图" class="headerlink" title="4.2.4 时序图"></a>4.2.4 时序图</h4><p><img src="/images/《设计模式》读书笔记/命令时序图.png" alt="命令时序图"></p><h3 id="4-3-Interpreter-解释器"><a href="#4-3-Interpreter-解释器" class="headerlink" title="4.3 Interpreter(解释器)"></a>4.3 Interpreter(解释器)</h3><h4 id="4-3-1-类图"><a href="#4-3-1-类图" class="headerlink" title="4.3.1 类图"></a>4.3.1 类图</h4><p><img src="/images/《设计模式》读书笔记/解释器类图.png" alt="解释器类图"></p><h4 id="4-3-2-参与者"><a href="#4-3-2-参与者" class="headerlink" title="4.3.2 参与者"></a>4.3.2 参与者</h4><p>AbstractExpression(抽象表达式)</p><ol><li>声明一个抽象的解释操作，这个接口为抽象语法树中所有的节点所共享。</li></ol><p>TerminalExpression(终结符表达式)</p><ol><li>实现与文法中的终结符相关联的解释操作。</li><li>一个句子中的每个终结符需要该类的一个实例。</li></ol><p>NonterminalExpression(非终结符表达式)</p><ol><li>对文法中的每一条规则<code>R ::=R&lt;sub&gt;1&lt;/sub&gt;R&lt;sub&gt;2&lt;/sub&gt;...R&lt;sub&gt;n&lt;/sub&gt;</code>都需要一个NonterminalExpression类。</li><li>为从<code>R&lt;sub&gt;1&lt;/sub&gt;</code>到<code>R&lt;sub&gt;n&lt;/sub&gt;</code>的每个符号都维护一个AbstractExpression类型的实例变量。</li><li>为文法中的非终结符实现解释(Interpret)操作。解释(Interpret)一般要递归地调用表示<code>R&lt;sub&gt;1&lt;/sub&gt;</code>到<code>R&lt;sub&gt;n&lt;/sub&gt;</code>的那些对象的解释操作。</li></ol><p>Context</p><ol><li>包含解释器之外的一些全局信息。</li></ol><p>Client</p><ol><li>构建（或被给定）表示该文法定义的语言中一个特定的句子的抽象语法树。该抽象语法树由NonterminalExpression和TerminalExpression的实例装配而成。</li><li>调用解释操作。</li></ol><h4 id="4-3-3-协作"><a href="#4-3-3-协作" class="headerlink" title="4.3.3 协作"></a>4.3.3 协作</h4><ol><li>Client构建（或被给定）一个句子，它是NonterminalExpression和TerminalExpression的实例的一个抽象语法树，然后初始化上下文并调用解释操作。</li><li>每一个非终结符表达式节点定义相应子表达式的解释操作。而各终结符表达式的解释操作构成了递归的基础。</li><li>每一节点的解释操作用上下文来存储和访问解释器的状态。</li></ol><h3 id="4-4-Iterator-迭代器"><a href="#4-4-Iterator-迭代器" class="headerlink" title="4.4 Iterator(迭代器)"></a>4.4 Iterator(迭代器)</h3><h4 id="4-4-1-类图"><a href="#4-4-1-类图" class="headerlink" title="4.4.1 类图"></a>4.4.1 类图</h4><p><img src="/images/《设计模式》读书笔记/迭代器类图.png" alt="迭代器类图"></p><h4 id="4-4-2-参与者"><a href="#4-4-2-参与者" class="headerlink" title="4.4.2 参与者"></a>4.4.2 参与者</h4><p>Iterator</p><ol><li>迭代器定义访问和遍历元素的接口。</li></ol><p>ConcreteIterator</p><ol><li>具体迭代器实现迭代器接口。</li><li>对该聚合遍历时跟踪当前位置。</li></ol><p>Aggregate</p><ol><li>聚合定义创建相应迭代器对象的接口。</li></ol><p>ConcreteAggregate</p><ol><li>具体聚合实现创建相应迭代器的接口，该操作返回ConcreteIterator的一个适当的实例。</li></ol><h4 id="4-4-3-协作"><a href="#4-4-3-协作" class="headerlink" title="4.4.3 协作"></a>4.4.3 协作</h4><ol><li>ConcreteIterator跟踪聚合中的当前对象，并能够计算出待遍历的后继对象。</li></ol><h3 id="4-5-Mediator-中介者"><a href="#4-5-Mediator-中介者" class="headerlink" title="4.5 Mediator(中介者)"></a>4.5 Mediator(中介者)</h3><h4 id="4-5-1-类图"><a href="#4-5-1-类图" class="headerlink" title="4.5.1 类图"></a>4.5.1 类图</h4><p><img src="/images/《设计模式》读书笔记/中介者类图.png" alt="中介者类图"></p><h4 id="4-5-2-对象结构示例图"><a href="#4-5-2-对象结构示例图" class="headerlink" title="4.5.2 对象结构示例图"></a>4.5.2 对象结构示例图</h4><p><img src="/images/《设计模式》读书笔记/中介者对象结构示例图.png" alt="中介者对象结构示例图"></p><h4 id="4-5-3-参与者"><a href="#4-5-3-参与者" class="headerlink" title="4.5.3 参与者"></a>4.5.3 参与者</h4><p>Mediator</p><ol><li>中介者定义一个接口用于与各同事(Colleague)对象通信。</li></ol><p>ConcreteMediator</p><ol><li>具体中介者通过协调各同事对象实现协作行为。</li><li>了解并维护它的各个同事。</li></ol><p>Colleague class</p><ol><li>每一个同事类都知道它的中介对象。</li><li>每一个同事对象在需与其他的同事通信的时候，与它的中介者通信。</li></ol><h4 id="4-5-4-协作"><a href="#4-5-4-协作" class="headerlink" title="4.5.4 协作"></a>4.5.4 协作</h4><ol><li>同事向一个中介者对象发送和接受请求。中介着在各同事间适当地转发请求以实现协作行为。</li></ol><h3 id="4-6-Memento-备忘录"><a href="#4-6-Memento-备忘录" class="headerlink" title="4.6 Memento(备忘录)"></a>4.6 Memento(备忘录)</h3><h4 id="4-6-1-类图"><a href="#4-6-1-类图" class="headerlink" title="4.6.1 类图"></a>4.6.1 类图</h4><p><img src="/images/《设计模式》读书笔记/备忘录类图.png" alt="备忘录类图"></p><h4 id="4-6-2-参与者"><a href="#4-6-2-参与者" class="headerlink" title="4.6.2 参与者"></a>4.6.2 参与者</h4><p>Memento</p><ol><li>备忘录存储原发器对象的内部状态。原发器根据需要决定备忘录存储原发器的哪些内部状态。</li><li>防止原发器以外的其他对象访问备忘录。备忘录实际上有两个接口，管理者(caretaker)只能看到备忘录的窄接口——它只能将备忘录传递给其他对象。相反，原发器能够看到一个宽接口，允许它访问返回到先前状态所需的所有数据。理想的情况是只允许生成本备忘录的那个原发器访问本备忘录的内部状态。</li></ol><p>Originator</p><ol><li>原发器创建一个备忘录，用以记录当前时刻它的内部状态。</li><li>使用备忘录恢复内部状态。</li></ol><p>CareTaker</p><ol><li>负责保存好备忘录。</li><li>不能对备忘录的内容进行操作或检查。</li></ol><h4 id="4-6-3-协作"><a href="#4-6-3-协作" class="headerlink" title="4.6.3 协作"></a>4.6.3 协作</h4><ol><li>管理器向原发器请求一个备忘录，保留一段时间后，将其送回给原发器。</li></ol><h4 id="4-6-4-时序图"><a href="#4-6-4-时序图" class="headerlink" title="4.6.4 时序图"></a>4.6.4 时序图</h4><p><img src="/images/《设计模式》读书笔记/备忘录时序图.png" alt="备忘录时序图"></p><h3 id="4-7-Observer-观察者"><a href="#4-7-Observer-观察者" class="headerlink" title="4.7 Observer(观察者)"></a>4.7 Observer(观察者)</h3><h4 id="4-7-1-类图"><a href="#4-7-1-类图" class="headerlink" title="4.7.1 类图"></a>4.7.1 类图</h4><p><img src="/images/《设计模式》读书笔记/观察者类图.png" alt="观察者类图"></p><h4 id="4-7-2-参与者"><a href="#4-7-2-参与者" class="headerlink" title="4.7.2 参与者"></a>4.7.2 参与者</h4><p>Subject</p><ol><li>目标知道它的观察者。可以有任意多个观察者观察同一目标。</li><li>提供注册和删除观察者对象的接口。</li></ol><p>Observer</p><ol><li>为那些在目标发生改变时需获得通知的对象定义一个更新接口。</li></ol><p>ConcreteSubject</p><ol><li>将有关状态存入各ConcreteObserver对象。</li><li>当它的状态发生改变时，向它的各个观察者发出通知。</li></ol><p>ConcreteObserver</p><ol><li>维护一个指向ConcreteSubject对象的引用。</li><li>存储有关状态，这些状态应与目标的状态保持一致。<br>实现Observer的更新接口以使自身状态与目标的状态保持一致。</li></ol><h4 id="4-7-3-协作"><a href="#4-7-3-协作" class="headerlink" title="4.7.3 协作"></a>4.7.3 协作</h4><ol><li>当ConcreteSubject发生任何可能导致其观察者与本身状态不一致的改变时，它将通知它的各个观察者。</li><li>在得到一个具体目标的改变通知后，ConcreteObserver对象可向目标对象查询信息。ConcreteObserver使用这些信息以使它的状态与目标对象的状态一致。</li></ol><h4 id="4-7-4-时序图"><a href="#4-7-4-时序图" class="headerlink" title="4.7.4 时序图"></a>4.7.4 时序图</h4><p><img src="/images/《设计模式》读书笔记/观察者时序图.png" alt="观察者时序图"></p><h3 id="4-8-State-状态"><a href="#4-8-State-状态" class="headerlink" title="4.8 State(状态)"></a>4.8 State(状态)</h3><h4 id="4-8-1-类图"><a href="#4-8-1-类图" class="headerlink" title="4.8.1 类图"></a>4.8.1 类图</h4><p><img src="/images/《设计模式》读书笔记/状态类图.png" alt="状态类图"></p><h4 id="4-8-2-参与者"><a href="#4-8-2-参与者" class="headerlink" title="4.8.2 参与者"></a>4.8.2 参与者</h4><p>Context</p><ol><li>定义客户感兴趣的接口。</li><li>维护一个ConcreteState子类的实例，这个实例定义当前状态。</li></ol><p>State</p><ol><li>定义一个接口以封装与Context的一个特定状态相关的行为。</li></ol><p>ConcreteState subclasses</p><ol><li>每一子类实现一个与Context的一个状态相关的行为。</li></ol><h4 id="4-8-3-协作"><a href="#4-8-3-协作" class="headerlink" title="4.8.3 协作"></a>4.8.3 协作</h4><ol><li>Context将与状态相关的请求委托给当前的ConcreteState对象处理。</li><li>Context可将自身作为一个参数传递给处理该请求的状态对象。这使得状态对象在必要时可访问Context。</li><li>Context是客户使用的主要接口。客户可用状态对象来配置一个Context，一旦一个Context配置完毕，它的客户不再需要直接与状态对象打交道。</li><li>Context或ConcreteState子类都可决定哪个状态是另外哪一个的后继者，以及是在何种条件下进行状态转换。</li></ol><h3 id="4-9-Strategy-策略"><a href="#4-9-Strategy-策略" class="headerlink" title="4.9 Strategy(策略)"></a>4.9 Strategy(策略)</h3><h4 id="4-9-1-类图"><a href="#4-9-1-类图" class="headerlink" title="4.9.1 类图"></a>4.9.1 类图</h4><p><img src="/images/《设计模式》读书笔记/策略类图.png" alt="策略类图"></p><h4 id="4-9-2-参与者"><a href="#4-9-2-参与者" class="headerlink" title="4.9.2 参与者"></a>4.9.2 参与者</h4><p>Strategy</p><ol><li>定义所有支持的算法的公共接口。Context使用这个接口来调用某ConcreteStrategy定义的算法。</li></ol><p>ConcreteStrategy</p><ol><li>以Strategy接口实现某具体算法。</li></ol><p>Context</p><ol><li>用一个ConcreteStrategy对象来配置。</li><li>维护一个对Strategy对象的引用。</li><li>可定义一个接口来让Strategy访问它的数据。</li></ol><h4 id="4-9-3-协作"><a href="#4-9-3-协作" class="headerlink" title="4.9.3 协作"></a>4.9.3 协作</h4><ol><li>Strategy和Context相互作用以实现选定的算法。当算法被调用时，Context可以将该算法所需要的所有数据都传递给该Strategy。或者，Context可以将自身作为一个参数传递给Strategy操作。这就让Strategy在需要时可以回调Context。</li><li>Context将它的客户的请求转发给它的Strategy。客户通常创建并传递一个ConcreteStrategy对象给该Context；这样，客户仅与Context交互。通常有一系列的ConcreteStrategy类可供客户从中选择。</li></ol><h3 id="4-10-Template-Method-模板方法"><a href="#4-10-Template-Method-模板方法" class="headerlink" title="4.10 Template Method(模板方法)"></a>4.10 Template Method(模板方法)</h3><h4 id="4-10-1-类图"><a href="#4-10-1-类图" class="headerlink" title="4.10.1 类图"></a>4.10.1 类图</h4><p><img src="/images/《设计模式》读书笔记/模板方法类图.png" alt="模板方法类图"></p><h4 id="4-10-2-参与者"><a href="#4-10-2-参与者" class="headerlink" title="4.10.2 参与者"></a>4.10.2 参与者</h4><p>AbstractClass</p><ol><li>定义抽象的原语操作(primitive operation)，具体的子类将重定义它们以实现一个算法的各个步骤。</li><li>实现一个模板方法，定义一个算法骨架。该模板方法不仅调用原语操作，也调用定义在AbstractClass或其他对象中的操作。</li></ol><p>ConcreteClass</p><ol><li>实现原语操作以完成算法中与特定子类相关的步骤。</li></ol><h4 id="4-10-3-协作"><a href="#4-10-3-协作" class="headerlink" title="4.10.3 协作"></a>4.10.3 协作</h4><ol><li>ConcreteClass靠AbstractClass来实现算法中不变的步骤。</li></ol><h3 id="4-11-Visitor-访问者"><a href="#4-11-Visitor-访问者" class="headerlink" title="4.11 Visitor(访问者)"></a>4.11 Visitor(访问者)</h3><h4 id="4-11-1-类图"><a href="#4-11-1-类图" class="headerlink" title="4.11.1 类图"></a>4.11.1 类图</h4><p><img src="/images/《设计模式》读书笔记/访问者类图.png" alt="访问者类图"></p><h4 id="4-11-2-参与者"><a href="#4-11-2-参与者" class="headerlink" title="4.11.2 参与者"></a>4.11.2 参与者</h4><p>Visitor</p><ol><li>为该对象结构中ConcreteElement的每一个类声明一个Visit操作。该操作的名字和特征标识了发送Visit请求给该访问者的那个类。这使得访问者可以确定正被访问元素的具体的类。这样访问者就可以通过该元素的特定接口直接访问它。</li></ol><p>ConcreteVisitor</p><ol><li>实现每个由Visitor声明的操作。每个操作实现本算法的一部分，而该算法片段乃是对应于结构中对象的类。ConcreteVisitor为该算法提供了上下文并存储它的局部状态。这一状态常常在遍历该结构的过程中累计结果。</li></ol><p>Element</p><ol><li>定义一个Accept操作，它以一个访问者为参数。</li></ol><p>ConcreteElement</p><ol><li>实现Accept操作，该操作以一个访问者为参数。</li></ol><p>ObjectStructure</p><ol><li>能枚举它的元素。</li><li>可以提供一个高层的接口以允许该访问者访问它的元素。</li><li>可以是一个复合或是一个集合，如一个列表或一个无序集合。</li></ol><h4 id="4-11-3-协作"><a href="#4-11-3-协作" class="headerlink" title="4.11.3 协作"></a>4.11.3 协作</h4><ol><li>一个使用Visitor模式的客户必须创建一个ConcreteVisitor对象，然后遍历该对象结构，并用该访问者访问每一个元素。</li><li>当一个元素被访问是，它调用对应于它的类的Visitor操作。如果必要，该元素将自身作为这个操作的一个参数以便访问者访问它的状态。</li></ol><h4 id="4-11-4-时序图"><a href="#4-11-4-时序图" class="headerlink" title="4.11.4 时序图"></a>4.11.4 时序图</h4><p><img src="/images/《设计模式》读书笔记/访问者时序图.png" alt="访问者时序图"></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下打包程序生成自解压自运行文件</title>
      <link href="linux-xia-da-bao-cheng-xu-sheng-cheng-zi-jie-ya-zi-yun-xing-wen-jian/"/>
      <url>linux-xia-da-bao-cheng-xu-sheng-cheng-zi-jie-ya-zi-yun-xing-wen-jian/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/usr/bin/env bash</span><span class="token comment"># Program:</span><span class="token comment">#   打包程序生成自解压自运行文件</span><span class="token comment"># History:</span><span class="token comment">#   2020/03/25  [KibaAmor](https://kibazen.cn)    Create this file</span><span class="token comment"># 遇到错误时退出</span><span class="token builtin class-name">set</span> -e<span class="token comment"># 配置</span><span class="token comment">#################################################################</span><span class="token comment"># 打包后可执行文件的名字</span><span class="token assign-left variable">PACKAGE_NAME</span><span class="token operator">=</span><span class="token string">"server.run"</span><span class="token comment"># 需要被打包程序的目录名(不要包含路径)</span><span class="token assign-left variable">TARGET_DIR</span><span class="token operator">=</span>server<span class="token comment"># 被打包程序的可执行程序</span><span class="token assign-left variable">EXEC_NAME</span><span class="token operator">=</span><span class="token string">"run.sh"</span><span class="token comment"># 开始生成自解压的可执行程序</span><span class="token comment">#################################################################</span><span class="token comment"># 创建自解压脚本</span><span class="token function">cat</span> <span class="token operator">&gt;</span> <span class="token variable">${PACKAGE_NAME}</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'END'#!/usr/bin/env bash# Program:#   打包目录'TARGET_DIR'生成自解压自运行的可执行文件# History:#   CURRENT_DATETIME  [KibaAmor](https://kibazen.cn)    Create this file# 遇到错误时退出set -e# 解压目录必须不存在test -e TARGET_DIR &amp;&amp; echo "'TARGET_DIR' already exist. Remove?" &amp;&amp;  rm -Ir TARGET_DIRtest -e TARGET_DIR &amp;&amp; echo "'TARGET_DIR' is still exist. please remove manual" &amp;&amp; exit -1# 生成一个空的，用于解压文件的目录mkdir TARGET_DIR# 定位程序压缩后二进制数据在脚本中的位置BIN_LINE_NUM=$(awk '/^__LAST_LINE__/ { print NR+1; exit 0; }' $0)# 解压被打包的程序tail -n +${BIN_LINE_NUM} $0 | tar -xz -C TARGET_DIR --strip-components=1# 进入目录cd TARGET_DIR# 赋予可执行权限chmod +x ./EXEC_NAME# 开始执行被打包的程序./EXEC_NAME $*# 正常退出exit 0__LAST_LINE__END</span><span class="token assign-left variable">CURRENT_DATETIME</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">date</span> +<span class="token string">'%Y/%m/%d %H:%M:%S'</span><span class="token variable">)</span></span><span class="token comment"># 替换自解压脚本中的变量</span><span class="token function">sed</span> -i <span class="token string">"s/TARGET_DIR/<span class="token variable">${TARGET_DIR}</span>/g"</span> <span class="token variable">${PACKAGE_NAME}</span><span class="token function">sed</span> -i <span class="token string">"s/EXEC_NAME/<span class="token variable">${EXEC_NAME}</span>/g"</span> <span class="token variable">${PACKAGE_NAME}</span><span class="token function">sed</span> -i <span class="token string">"s@CURRENT_DATETIME@<span class="token variable"><span class="token variable">$(</span><span class="token function">date</span> +<span class="token string">'%Y/%m/%d %H:%M:%S'</span><span class="token variable">)</span></span>@g"</span> <span class="token variable">${PACKAGE_NAME}</span><span class="token comment"># 将打包的程序压缩，并将压缩后的二进制数据附加到自解压脚本后面</span><span class="token function">tar</span> c <span class="token variable">${TARGET_DIR}</span> <span class="token operator">|</span> <span class="token function">gzip</span> -f <span class="token operator">&gt;&gt;</span> <span class="token variable">${PACKAGE_NAME}</span><span class="token comment"># 给自解压脚本执行权限</span><span class="token function">chmod</span> +x <span class="token variable">${PACKAGE_NAME}</span><span class="token comment"># 输出信息</span><span class="token builtin class-name">echo</span> <span class="token string">"打包成功. 打包后的文件为：<span class="token variable">${PACKAGE_NAME}</span>"</span><span class="token comment"># 正常退出</span><span class="token builtin class-name">exit</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何正确的学习设计模式</title>
      <link href="ru-he-zheng-que-de-xue-xi-she-ji-mo-shi/"/>
      <url>ru-he-zheng-que-de-xue-xi-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、编程初期遇到的问题"><a href="#一、编程初期遇到的问题" class="headerlink" title="一、编程初期遇到的问题"></a>一、编程初期遇到的问题</h2><p>初学编程时，写的代码基本上都编程作业，ACM之类的，代码量一般都不多，几百行，少有上千行。所以，初读设计模式相关书籍时，只是觉得很厉害，并没有切实的体会到使用设计模式带来的好处。随着写的程序代码量逐渐增多，发现代码的逻辑越来越混乱，实现的功能BUG也越来越多。</p><p>在编程的过程中，也接触到了很多优秀的代码库，比如：<a href="https://www.ogre3d.org/">OGRE(Open-source Graphics Rendering Engines)</a>，一个优秀同时也是开源的3D图形图像渲染引擎。在学习使用的过程中，发现其代码逻辑清晰，便于阅读。对比自己写的代码和<a href="https://www.ogre3d.org/">OGRE</a>的代码，发现OGRE的代码中使用了很多的设计模式。所有就简单的认为：</p><blockquote><p>使用设计模式就能让代码组织更加简单，让代码的逻辑也更加清晰明了，同时大大的提高了代码的可读性，降低了程序出BUG的几率。</p></blockquote><h2 id="二、对设计模式错误的认识"><a href="#二、对设计模式错误的认识" class="headerlink" title="二、对设计模式错误的认识"></a>二、对设计模式错误的认识</h2><p>有了上面的结论，认为只要学会了所有的设计模式，就能够提高编程的能力。但是在背完所有的设计模式后发现：</p><ul><li><code>不知道什么时候该用设计模式。</code> 设计模式确实很好，但是还是也不知道什么时候该用设计模式，因为平时的编程中不用设计模式，功能也能实现出来。</li><li><code>套用了设计模式后代码质量也没提升。</code> 即使在编程的过程中，刻意的使用了一些设计模式，也没体会到设计模式带来的好处，更没有体会到想象中代码质量会立竿见影的提高。</li></ul><p>伴随着对设计模式使用的疑问，阅读了更多的书籍。当读到《重构：改善既有代码的设计》这本书时，按照书中的指导，重构了已有的代码，发现修改后的代码，阅读起来更加的容易，代码逻辑也比修改之前更加清晰。再对比修改前后的代码，发现：</p><ul><li><code>如果有多个地方都需要完成相同的功能，应该把代码封装成一个单独的函数，而不是复制粘贴。</code> 因为复制粘贴后，代码多了，改起来容易漏，也就容易出问题了，同时代码也变得难读。</li><li><code>如果一个函数或者一个类的代码有很多，通常更容易出BUG。</code> 如果一个函数或者一个类里面的代码有很多的话，读起来逻辑复杂，做的事情也多，就老是容易出问题。</li></ul><p>其他的细节还有很多。比如，如果注释都说不清楚一段代码在干什么，那么这段代码常常更容易出问题。</p><p>再次读<a href="https://www.ogre3d.org/">OGRE</a>的源代码时就发现，整个源代码在这些细节上都做的很好。比如：一个函数只做一件事，而且从函数的名字里就能知道具体做的什么。而源代码中使用的设计模式更是巧妙的让一个复杂的功能变得简单好理解。</p><h2 id="三、认识软件工程"><a href="#三、认识软件工程" class="headerlink" title="三、认识软件工程"></a>三、认识软件工程</h2><p>阅读书籍过程中也多次接触到了<code>软件工程</code>这个术语，但是一直不是很明白<code>软件工程</code>具体是做什么的，直到读到了《敏捷软件开发》这本书。<code>软件工程是一门研究用工程化方法构建和维护有效的、实用的和高质量的软件的学科。</code>而《敏捷软件开发》这本书正是讲述如何实践软件工程的经典巨著。理解一下，<code>软件工程</code>就是一门学习研究写出高质量软件(代码)的学科。而《敏捷软件开发》则是介绍具体用某种方法来实现写出高质量软件目的的书。</p><p>《敏捷软件开发》这本书中提出了<code>敏捷设计</code>这一方法，并将其定义为：</p><blockquote><p>敏捷设计是一个持续的应用原则、模式以及实现来改进软件的结构和可读性的过程。它是一个过程，不是一个事件。</p></blockquote><p>它认为，只要在编写代码实现软件时，遵守一些软件开发原则和模式，那么就能够提高代码的质量。</p><h2 id="四、了解敏捷开发的原则"><a href="#四、了解敏捷开发的原则" class="headerlink" title="四、了解敏捷开发的原则"></a>四、了解敏捷开发的原则</h2><p>《敏捷软件开发》着重介绍并解释了5种软件开发原则。分别是：</p><ol><li><code>单一职责原则(SRP)</code>：就一个类而言，应该仅有一个引起它变化的原因。</li><li><code>开放-封闭原则(OCP)</code>：软件实体（类、模块、函数等等）应该是可以扩展的，但是不可修改的。</li><li><code>里氏替换原则(LSP)</code>：子类型(subtype)必须能够替换掉它们的基类型(base type)。</li><li><code>依赖倒置原则(DIP)</code>：高层模块不应该依赖于低层模块。二者都应该依赖于抽象。抽象不应该依赖于细节。细节应该依赖于抽象。</li><li><code>接口隔离原则(ISP)</code>：不应该强迫客户依赖于它们不用的方法。</li></ol><p>与其说是<code>原则</code>，不如说是<code>标准</code>。因为它们告诉了我们一个标准：应该把代码设计成一个什么样子，满足什么条件，有什么特征，但是并没有说应该如何编写代码。</p><p>此时，再回过头阅读<a href="https://www.ogre3d.org/">OGRE</a>等优秀的代码库时才明白，这些代码库优秀的原因之一是它们遵循了良好的软件开发原则，而使用设计模式则是让代码遵循这些软件开发原则的方法。这也是初学设计模式时，生搬硬套设计模式并没有改善代码质量的根本原因。因为根本就不知道应该把代码改成什么样，需要满足什么要求。结果就是把劣质的代码换一种方式写出来而已。</p><p>所以，我们能够得出一个结论，那就是：</p><blockquote><p>优秀的软件由高质量的代码编写而成，而遵从软件开发原则是代码成为高质量代码的条件之一，设计模式只是让代码遵从开发原则的方法。</p></blockquote><h2 id="五、正确的学习设计模式"><a href="#五、正确的学习设计模式" class="headerlink" title="五、正确的学习设计模式"></a>五、正确的学习设计模式</h2><p>最后，如何正确的学习设计模式呢？</p><ol><li>发现自己写的代码越来越复杂，BUG越来越多。</li><li>寻求提高代码质量的方法。</li><li>学习软件工程。<code>认识到别人代码质量高的原因之一是因为别人遵循了良好软件开发原则。</code></li><li>开始真正的学习并运用设计模式。</li><li>最后，明白了什么时候应该怎么用设计模式，更清楚了软件工程的重要性。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全局唯一ID生成方法总结</title>
      <link href="quan-ju-wei-yi-id-sheng-cheng-fang-fa-zong-jie/"/>
      <url>quan-ju-wei-yi-id-sheng-cheng-fang-fa-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么情况下需要全局唯一ID"><a href="#一、什么情况下需要全局唯一ID" class="headerlink" title="一、什么情况下需要全局唯一ID"></a>一、什么情况下需要全局唯一ID</h2><p>在一个由多个服务器组成的业务系统中，有很多对象都需要一个ID来标识该对象，以示区分。这个ID应该是系统(全局)范围内唯一的，这种ID就是<code>全局唯一ID(GUID，Globally Unique Identifier)</code>。比如：购物商城中的用户ID和订单ID就应该是<code>全局唯一ID</code>。</p><h2 id="二、生成全局唯一ID要求"><a href="#二、生成全局唯一ID要求" class="headerlink" title="二、生成全局唯一ID要求"></a>二、生成全局唯一ID要求</h2><p>既然要使用<code>全局唯一ID</code>，那么就需要先生成<code>全局唯一ID</code>。生成时主要考虑以下面几点：</p><ol><li><code>全系统范围内唯一。</code> 显而易见，全局唯一ID肯定应该是全系统唯一不重复的。</li><li><code>ID易于存储和比较。</code> <code>全局唯一ID</code>的占用空间应该尽量的小且便于比较。比如：类型为64位整形(int64)的<code>全局唯一ID</code>就明显比类型为字符串(string)的<code>全局唯一ID</code>更易于存储和比较，使用起来也更好用。</li><li><code>生成结果是有序递增(递减)的。</code> 一般会将生成后的<code>全局唯一ID</code>作为数据库的主键来存储该对象的信息。有序的主键在插入数据库时性能一般会更好。</li><li><code>生成结果不可预测。</code> 生成的结果应当是不能预测的。如果能够预测出下一个生成结果，基本上就能猜测出所有的生成结果，比如在一个订单系统中，就能获取到所有的订单信息，这在安全性上是难以接受的。</li><li><code>生成快速且稳定。</code> 在一个系统中，很有可能需要频繁的生成<code>全局唯一ID</code>，一旦生成的速度过慢甚至生成时卡顿，将导致整个系统的卡顿或者崩溃。所以，<code>全局唯一ID</code>的生成应当是快速且稳定的。</li></ol><h2 id="三、目前成熟的生成方法"><a href="#三、目前成熟的生成方法" class="headerlink" title="三、目前成熟的生成方法"></a>三、目前成熟的生成方法</h2><h3 id="1-数据库自增ID"><a href="#1-数据库自增ID" class="headerlink" title="1. 数据库自增ID"></a>1. 数据库自增ID</h3><p>很多数据库提供生成自增ID的功能，如MySQL提供了变量<code>auto_increment_offset</code>来设置自增的初始值，变量<code>auto_increment_increment</code>设置每次自增的步长。借助数据库提供的这个功能，我们就能简单的实现生成<code>全局唯一ID</code>的功能了。</p><p>这种方式的优点很明显，那就是简单。不需要开发一个单独的系统，也不需要专人去维护。<br>但是缺点也是很明显的：</p><ol><li><code>生成性能不够好。</code> 每次生成<code>全局唯一ID</code>都需要通过网络访问数据库一次，生成时间可能达到几十上百毫秒。而且在数据库内部生成自增ID时，常常还会加锁，多个地方同时生成<code>全局唯一ID</code>时，还需要竞争抢锁。并发性能也就不好。</li><li><code>稳定性不够好。</code> 使用数据库来生成<code>全局唯一ID</code>方法的特点就是所有需要生成<code>全局唯一ID</code>的业务都需要连接相同的数据库，压力集中于一点。一旦数据库崩溃，将不能生成<code>全局唯一ID</code>，这会严重影响使用<code>全局唯一ID</code>的业务系统。即使数据库采用了主从结构，也难以保证在主从数据库切换时，生成的<code>全局唯一ID</code>不重复。</li><li><code>生成结果可以预测。</code> 一旦确定了自增初始值和自增步长后，基本上不会再动态修改这两个值，那么根据这两个值生成出来的ID也就是可预测的了。</li></ol><p>虽然使用数据库来生成<code>全局唯一ID</code>有上面的种种缺点，但是可以通过一些方法来改善这些问题：</p><h4 id="A-Flickr的分布式唯一主键生成算法"><a href="#A-Flickr的分布式唯一主键生成算法" class="headerlink" title="A. Flickr的分布式唯一主键生成算法"></a>A. Flickr的<a href="https://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/">分布式唯一主键生成算法</a></h4><p>针对使用数据库生成<code>全局唯一ID</code>性能不好的问题，Flickr提供了这样的解决方案：</p><blockquote><p>部署多台数据库，每台数据库设置不同的自增初始值，相同的自增步长值。同时自增步长值必须大于等于数据库的数量。这样就能保证每台数据都能生成<code>全局唯一ID</code>，且所有生成的<code>全局唯一ID</code>都不重复。</p></blockquote><p>举例，比如部署了两台数据库，其自增初始值，自增步长值及结果分别如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">数据库</th><th style="text-align:center">自增初始值</th><th style="text-align:center">自增步长值</th><th style="text-align:center">生成结果</th></tr></thead><tbody><tr><td style="text-align:center">数据库A</td><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">0,2,4,6,8…</td></tr><tr><td style="text-align:center">数据库B</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1,3,5,7,9…</td></tr></tbody></table></div><p>实际使用此方案时生成的<code>全局唯一ID</code>可能不是上面这种连续的结果，MySQL的下个自增ID的实际计算公式是<code>INT(current_value / increment) x increment + offset</code>，具体的可以参考<a href="https://stackoverflow.com/questions/35766521/mysql-master-master-replication-causing-missing-autoincrement-values/">MySql Master-Master Replication Causing Missing AutoIncrement Values</a>。</p><p>Flickr<a href="https://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/">分布式唯一主键生成算法</a>的核心思想是：</p><blockquote><p>分散单点数据库的压力到了多点数据库，从而在提升了生成的性能和稳定性。</p></blockquote><p>但是这种方法中有一个很大的弊端，那就是因为要提前的确定自增的步长，所以扩展性很差。</p><h4 id="B-美团的Leaf-segment算法"><a href="#B-美团的Leaf-segment算法" class="headerlink" title="B. 美团的Leaf-segment算法"></a>B. 美团的<a href="https://tech.meituan.com/2017/04/21/mt-leaf.html">Leaf-segment算法</a></h4><p>同样是针对使用数据库生成<code>全局唯一ID</code>性能不好的问题，美团提供的解决方案是：</p><blockquote><p>不同的业务使用不同的自增ID。同一个业务一次获取多个<code>全局唯一ID</code>，缓存起来慢慢使用。同时在要用完时前就再次异步获取新的<code>全局唯一ID</code>缓存起来备用，就能为业务提供持续不断的<code>全局唯一ID</code>生成功能。</p></blockquote><p>举例，系统中有用户和订单都需要使用<code>全局唯一ID</code>来标识。那么数据库中就分别为用户和订单使用不同的自增ID。每次获取10000个<code>全局唯一ID</code>。并规定当前消耗10%的<code>全局唯一ID</code>就马上异步的获取下一批并将结果缓存起来备用。</p><div class="table-container"><table><thead><tr><th style="text-align:center">自增ID</th><th style="text-align:center">自增初始值</th><th style="text-align:center">自增步长值</th><th style="text-align:center">生成结果</th></tr></thead><tbody><tr><td style="text-align:center">用户</td><td style="text-align:center">0</td><td style="text-align:center">10000</td><td style="text-align:center">0,10000,20000…</td></tr><tr><td style="text-align:center">订单</td><td style="text-align:center">0</td><td style="text-align:center">10000</td><td style="text-align:center">0,10000,20000…</td></tr></tbody></table></div><p>美团<a href="https://tech.meituan.com/2017/04/21/mt-leaf.html">Leaf-segment算法</a>的核心思想是：批量获取和提前缓存。</p><ul><li>批量获取的同时，也减少请求数据库的次数，也就降低了数据库的压力。</li><li>而提前缓存则是保证了即使在网络波动时和业务高峰时都能够持续不阻塞的生成<code>全局唯一ID</code>。</li></ul><h3 id="2-UUID算法"><a href="#2-UUID算法" class="headerlink" title="2. UUID算法"></a>2. UUID算法</h3><p>UUID的全称是Universally Unique Identifier，中文名为通用唯一识别码。</p><p>UUID包含32个16进制的数字，大小是16字节128为，一般以连字号分为五段，形式为8-4-4-4-12的36个字符，比如：12fae663-e3dd-4b9e-b1a9-b7e598d2f853。具体的细节可以参考UUID的IETF标准<a href="https://www.ietf.org/rfc/rfc4122.txt">A Universally Unique IDentifier (UUID) URN Namespace</a>。</p><p>UUID生成的算法主要有5种，都不需要联网，本地即可生成。所以，使用UUID算法生成<code>全局唯一ID</code>的优点是很明显的，那就是：<code>高性能且难于预测结果</code>。但是缺点也很明显：</p><ol><li><code>UUID不易存储和使用。</code> 目前的主流编程语言和数据库，最大支持64位的整数。128位的UUID难以原生的以整数方式存储和使用。</li><li><code>UUID不是有序递增(递减)的。</code> UUID算法生成出来的ID一般不是有序的，这对将UUID作为主键存入数据库的使用方式来说并不友好。</li></ol><p>基于上面的缺点，UUID很少作为<code>全局唯一ID</code>来使用。</p><h3 id="3-字节-位-分段算法"><a href="#3-字节-位-分段算法" class="headerlink" title="3. 字节(位)分段算法"></a>3. 字节(位)分段算法</h3><p>这种算法的思想其实来自Twitter的<a href="https://github.com/twitter-archive/snowflake">雪花算法</a>，其他的同类算法都是在此基础上的一些变种。算法核心是：</p><blockquote><p>将组成<code>全局唯一ID</code>的多个字节看做一个整体，并其划分成不同的段，分别控制不同段的值。</p></blockquote><p>该算法具有与UUID算法相同的好处，那就是都不需要联网，本地即可生成。除此之外，还支持多个服务器同时生成，且生成的结果总体的保持递增或递减。在控制字节大小的情况下，也能较好的存储和比较。</p><h4 id="A-Twitter的雪花算法"><a href="#A-Twitter的雪花算法" class="headerlink" title="A. Twitter的雪花算法"></a>A. Twitter的<a href="https://github.com/twitter-archive/snowflake">雪花算法</a></h4><p>该算法生成的<code>全局唯一ID</code>的大小为64字节，能够使用64位整型来存储。其格式为：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+------------------------------------------------------------------------------------+| UNUSED(1BIT) |     TIMESTAMP(41BIT)     |  MACHINE-ID(10BIT)  |   SERIAL-NO(12BIT) |+------------------------------------------------------------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中：</p><ul><li><code>1位不用。</code> 最高位不用，固定为0。因为二进制中最高位为1的表示是负数，而我们一般整数来表示ID，不希望有负数的ID，所以不用。</li><li><code>41位的时间戳。</code> 用41位的空间来表示单位为毫秒的时间戳，大约可以表示<code>(1L &lt;&lt; 41) /（1000 * 60 * 60 * 24 * 365）= 69</code>年的时间。</li><li><code>10位的机器位。</code> 用来区分不同服务器生成出来的ID。10位空间最多可以表示(1L &lt;&lt; 10) = 1024台服务器。</li><li><code>12位的序列化。</code> 用12位空间来存储在同一毫秒内，同一台服务器生成出来的ID数量。最多可以存储(1L &lt;&lt; 12) = 4096个。</li></ul><p>使用Twitter的<a href="https://github.com/twitter-archive/snowflake">雪花算法</a>只有一个明显的缺点，就是：</p><blockquote><p>算法高度依赖时间戳，如果各个生成ID的服务器时间不同步，将会导致生成出来的ID是乱序或者重复的。</p></blockquote><h4 id="B-百度的UidGenerator算法"><a href="#B-百度的UidGenerator算法" class="headerlink" title="B. 百度的UidGenerator算法"></a>B. 百度的<a href="https://github.com/baidu/uid-generator">UidGenerator算法</a></h4><p>百度<a href="https://github.com/baidu/uid-generator">UidGenerator算法</a>与Twitter<a href="https://github.com/twitter-archive/snowflake">雪花算法</a>的主要区别在于调整了各个分段的大小，改变了各个分度的意义，本质没变。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">+-------------------------------------------------------------------------------------+| UNUSED(1BIT) |  DELTA SECONDS(28BIT)  |  WORKER-NODE-ID(22BIT)  |  SERIAL-NO(13BIT) |+-------------------------------------------------------------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>1位不用。</code> 最高位依旧不用，固定为0。</li><li><code>28位的时间差。</code> 表示当前时间相对与”2016-05-20”的差值，单位为秒。最多可支持约8.7年。</li><li><code>22位的机器位。</code> 表示机器ID。每次机器重启后都废弃重新从数据库申请，最多可支持约420w次机器启动。</li><li><code>13位的序列化。</code> 每秒下的并发序列，可支持每秒8192个并发。</li></ul><h4 id="C-美团的Leaf-snowflake算法"><a href="#C-美团的Leaf-snowflake算法" class="headerlink" title="C. 美团的Leaf-snowflake算法"></a>C. 美团的<a href="https://tech.meituan.com/2017/04/21/mt-leaf.html">Leaf-snowflake算法</a></h4><p>美团<a href="https://tech.meituan.com/2017/04/21/mt-leaf.html">Leaf-snowflake算法</a>沿用了Twitter<a href="https://github.com/twitter-archive/snowflake">雪花算法</a>各个字段的意义，但是扩展了算法的使用方式，提高了算法的易用性和在时钟乱序时的容错性。</p><h5 id="提升算法的易用性"><a href="#提升算法的易用性" class="headerlink" title="提升算法的易用性"></a>提升算法的易用性</h5><p>在生成<code>全局唯一ID</code>的服务器集群中加入了Zookeeper。每次服务器启动时都去ZooKeeper读取(不存在时则注册)自己的用于生成<code>全局唯一ID</code>时的服务器ID值。因为服务器ID一般不会变，所以可以将这个值缓存起来，即使以后遇到连接ZooKeeper时，也能正常的启动服务器，并提供生成ID的服务。</p><h5 id="提升时钟乱序时的容错性"><a href="#提升时钟乱序时的容错性" class="headerlink" title="提升时钟乱序时的容错性"></a>提升时钟乱序时的容错性</h5><p>服务器会在启动时判断时钟发生是否发生了回拨，具体细节如下：</p><ul><li>如果服务器启动时，Zookeeper无此服务器的时间记录，那么就判断当前服务器的时间和其他的运行<a href="https://tech.meituan.com/2017/04/21/mt-leaf.html">Leaf-snowflake算法</a>服务器的时间的平均值(通过RPC获取)之间的差值，如果差值大于某个阈值，认为本机系统时间发生大步长偏移，启动失败并报警。</li><li>如果服务器启动时，Zookeeper已经有此服务器的时间记录，且当前服务器的时间小于记录的时间，那么就认为服务器时间发生了大步长回拨，服务启动失败并报警。</li><li>服务器正常启动后，定时(如每隔3秒)的向Zookeeper记录本服务器当前时间。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>负载均衡简介</title>
      <link href="fu-zai-jun-heng-jian-jie/"/>
      <url>fu-zai-jun-heng-jian-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="一、为什么需要负载均衡"><a href="#一、为什么需要负载均衡" class="headerlink" title="一、为什么需要负载均衡"></a>一、为什么需要负载均衡</h2><p>随着业务的发展，业务的流量也越来越大，以前单台服务器提供的服务，无论如何优化，都不能满足现有业务的需求。这时，就需要将业务流量分摊到多个不同的服务器上来减少单个服务器的压力。而<code>负载均衡(Load Balance)</code>就是用来将业务流量分发到不用的服务器上面的。</p><h2 id="二、什么是负载均衡"><a href="#二、什么是负载均衡" class="headerlink" title="二、什么是负载均衡"></a>二、什么是负载均衡</h2><pre class="line-numbers language-text" data-language="text"><code class="language-text">+---------------------------------------------------------------------------+|                                                                           ||                                                             +----------+  ||                                                             |          |  ||                                              +------------&gt; |  Server  |  ||                                              |              |          |  ||                                              |              +----------+  ||                                              |                            ||  +----------+         +----------------+     |              +----------+  ||  |          |         |                |     |              |          |  ||  |  Client  | +-----&gt; |  Load Balance  | +----------------&gt; |  Server  |  ||  |          |         |                |     |              |          |  ||  +----------+         +----------------+     |              +----------+  ||                                              |                            ||                                              |              +----------+  ||                                              |              |          |  ||                                              +------------&gt; |  Server  |  ||                                                             |          |  ||                                                             +----------+  ||                                                                           |+---------------------------------------------------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>负载均衡(软件或硬件)会将所有的客户端流量，通过特定的调度算法分发到不同的后端服务器上，同时还会监控后端服务器的压力和监控状态，以便在某些后端服务器压力过大或故障时，减少对该服务器的流量分发，从而保证了整个业务的稳定。</p><h2 id="三、利用DNS实现负载均衡"><a href="#三、利用DNS实现负载均衡" class="headerlink" title="三、利用DNS实现负载均衡"></a>三、利用DNS实现负载均衡</h2><p>早期解决单个服务器压力过大的方法之一是利用DNS将域名解析到不同的IP的方式来实现的。如：客户端在不同的地区解析相同的域名时，DNS解析出离客户端最近的服务器IP。这样，不同的客户端就连接到提供了相同服务但是机器不同的服务器。从而分散了服务器压力，同时也缩短服务响应时间。这也是CDN原理。</p><p>利用DNS来实现负载均衡好处有成本低，实现简单等。但是弊端也是很明显的：</p><ol><li><code>流量分发的不够均匀。</code> DNS在解析IP时，能够根据客户端地理位置来分发流量，但是没法根据后端服务器的实际压力来分发流量。这样就可能会出现一台服务器压力满载，而其他的服务器无压力的情况。</li><li><code>支持的分发策略少。</code>DNS一般只支持轮询方式来解析。大大的限制了使用场景。</li><li><code>服务器故障时切换延迟大。</code> 由于DNS服务器是多层，且各层服务器中有缓存，导致了DNS修改后不能立即生效。这种情况下，如果一个后端服务器崩溃停止服务器，即使我们立即修改DNS，部分的客户端也无法立即恢复服务。这会严重影响用户体验。</li><li><code>DNS劫持和缓存污染导致的安全问题。</code> 由于DNS存在被劫持和缓存被污染可能，这会导致域名解析出来的IP可能不是我们服务器的IP，从而会导致客户端连接到了错误的服务器，造成安全问题。</li></ol><p>所以严格来说，使用DNS只能算是分发流量，而不能算作真正的负载均衡。</p><blockquote><p>Tips:</p><ol><li><code>DNS劫持:</code> DNS服务器被控制，查询DNS时，服务器直接返回给你它想让你看的信息。</li><li><code>DNS缓存污染:</code> 黑客通过技术手段使用户查询到虚假解析信息。</li></ol></blockquote><h2 id="四、基于OSI分层分类的负载均衡"><a href="#四、基于OSI分层分类的负载均衡" class="headerlink" title="四、基于OSI分层分类的负载均衡"></a>四、基于OSI分层分类的负载均衡</h2><div class="table-container"><table><thead><tr><th style="text-align:center">层级</th><th style="text-align:center">OSI参考模型</th><th style="text-align:center">各层解释</th></tr></thead><tbody><tr><td style="text-align:center">7</td><td style="text-align:center">应用层(Application)</td><td style="text-align:center">提供网络与用户应用软件之间的接口服务</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">表达层(Presentation)</td><td style="text-align:center">提供格式化的表示和转换数据服务，如加密和压缩</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">会话层(Session)</td><td style="text-align:center">提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">传输层(Transimission)</td><td style="text-align:center">提供建立、维护和取消传输连接功能，负责可靠地传输数据(PC)</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">网络层(Network)</td><td style="text-align:center">处理网络间路由，确保数据及时传送(路由器)</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">数据链路层(DataLink)</td><td style="text-align:center">负责无错传输数据，确认帧、发错重传等(交换机)</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">物理层(Physics)</td><td style="text-align:center">提供机械、电气、功能和过程特性(网卡、网线、双绞线、同轴电缆、中继器)</td></tr></tbody></table></div><p>参考OSI的七层模型，我们可以：</p><ol><li>在第二层(数据链路层)做基于MAC地址的<code>二层负载均衡</code>。通过一个虚拟MAC地址接收请求，然后再将数据转发到真实的MAC地址。</li><li>在第三层(网络层)做基于IP地址的<code>三层负载均衡</code>。通过一个虚拟IP地址接收请求，然后再将数据转发到真实的IP地址。</li><li>在第四层(传输层)做基于IP和端口的<code>四层负载均衡</code>。通过一个虚拟IP地址和端口接收请求，然后再将数据转发到真实的IP地址和端口。</li><li>在第七层(应用层)做基于应用层信息(如：URL)的<code>七层负载均衡</code>。通过一个虚拟的URL接收请求，然后再将数据转发到真实URL所在的服务器。</li></ol><p>常用的负载均衡有：<a href="#七层负载均衡">七层负载均衡</a>和<a href="#四层负载均衡">四层负载均衡</a>。</p><blockquote><p>Tips:</p><ol><li>DNS属于应用层的协议，所以<a href="#利用DNS实现负载均衡">利用DNS实现负载均衡</a>算是<a href="#七层负载均衡">七层负载均衡</a>。</li></ol></blockquote><h2 id="五、七层负载均衡"><a href="#五、七层负载均衡" class="headerlink" title="五、七层负载均衡"></a>五、七层负载均衡</h2><p><code>七层负载均衡</code>工作在OSI的第七层(传输层)，位于第四层(应用层)之上，所以需要完整的TCP/IP协议栈的实现，这也让负载均衡能够解析流量的内容。</p><p>客户端不能与直接与后端服务器建立传输层的连接(如TCP连接)，取而代之，客户端将直接与负载均衡建立连接，负载均衡解析完协议内容后，根据协议内容、流量分发策略和后端压力等信息选择一个后端服务器，并与服务器建立连接，然后将进行流量分发。所以，<code>七层负载均衡的主要工作就是代理。</code></p><p><code>七层负载均衡</code>的好处是显而易见的：</p><ol><li><code>可以查看修改流量内容。</code> 能够查看流量内容让负载均衡能够记录日志，方便进行大数据分析；也能够根据内容来做更加智能的流量分发；还能对明显非法的访问进行简单的过滤。能够修改流量让负载均衡能够添加额外的信息到流量中，为后端的业务处理提供更丰富的信息。</li><li><code>可以避免后端服务遭受传输层的流量攻击。</code> 因为客户端不再直接与后端服务器建立传输层的连接，后端服务器也就不会再受到可能的SYN Flood攻击。</li><li><code>无需特别的硬件就能实现。</code> 因为<code>七层负载均衡</code>工作在应用层，所以利用普通的软件即可实现。常用的软件有：Nginx、HAProxy等。</li></ol><p>同时也带来了一些不便：</p><ol><li><code>隐藏了客户端的连接信息。</code> 因为负载均衡取代了后端服务器与客户端建立连接。所以后端服务器<code>无法直接获取</code>真实的客户端IP信息等。但是可以通过修改流量的内容，将客户端的信息添加到流量中来避免此问题。</li><li><code>增加了排错的难度。</code> 增加七层负载的同时，也为将业务流程复杂化了，出错时也增加了排错的难度。</li></ol><p>所以，在使用<code>七层负载均衡</code>之前，需要综合考虑使用<code>七层负载均衡</code>能带来的好处以及不便。如果使用负载均衡的主要目的是分发流量，均衡后端压力，还可以考虑使用<a href="#四层负载均衡">四层负载均衡</a>。</p><h2 id="六、四层负载均衡"><a href="#六、四层负载均衡" class="headerlink" title="六、四层负载均衡"></a>六、四层负载均衡</h2><p><code>四层负载均衡</code>工作在OSI的第四层(传输层)，不需要完整的TCP/IP协议栈的实现，所以也不能解析流量的内容。在这一点来说，效率比<code>七层负载均衡</code>更高。</p><p>负载均衡仅能根据流量中目标地址和端口，加上指定的流量分发策略等信息进行流量分发。客户端能够直接与后端服务器建立传输层的连接(如TCP连接)，此时负载均衡的作用类似于路由器转发报文，只是更加智能可控。所以，<code>四层负载均衡的主要工作就是转发。</code></p><p>使用<code>四层负载均衡</code>最明显的好处是在保持分发策略最大化可控的同时性能的最大化。因为<code>四层负载均衡</code>并不需要解析传输层的协议内容，相比与<code>七层负载均衡</code>来说，少了很多工作。</p><p>但是，使用<code>四层负载均衡</code>的缺点也是很明显的：</p><ol><li><code>成本高昂。</code> <code>四层负载均衡</code>大多基于硬件来实现，虽然也有软件实现的。</li><li><code>暴露了后端的服务器。</code> 这与不用负载均衡前的情况相同，后端服务器直接暴露给客户端。服务器遭受攻击时会直接影响业务。</li></ol><hr><p>参考</p><ul><li><a href="https://tech.meituan.com/2017/01/05/mgw.html">MGW——美团点评高性能四层负载均衡</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下Bash配置文件的执行顺序</title>
      <link href="linux-xia-bash-pei-zhi-wen-jian-de-zhi-xing-shun-xu/"/>
      <url>linux-xia-bash-pei-zhi-wen-jian-de-zhi-xing-shun-xu/</url>
      
        <content type="html"><![CDATA[<blockquote><p><em>翻译自<a href="https://linux.101hacks.com/bash-scripting/execution-sequence-of-bash-files/">Linux 101 Hacks: 84</a></em></p></blockquote><h2 id="下列文件的执行顺序是什么"><a href="#下列文件的执行顺序是什么" class="headerlink" title="下列文件的执行顺序是什么"></a>下列文件的执行顺序是什么</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/etc/profile~/.bash_profile~/.bashrc~/.bash_login~/.profile~/.bash_logout<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="交互式登录shell的执行顺序"><a href="#交互式登录shell的执行顺序" class="headerlink" title="交互式登录shell的执行顺序"></a>交互式登录shell的执行顺序</h2><p>下面的伪代码将说明这些文件的执行顺序</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">execute /etc/profileIF ~/.bash_profile exists THEN    execute ~/.bash_profileELSE    IF ~/.bash_login exist THEN        execute ~/.bash_login    ELSE        IF ~/.profile exist THEN            execute ~/.profile        END IF    END IFEND IF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当你从交互式shell中注销，以下是执行顺序：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">IF ~/.bash_logout exists THEN    execute ~/.bash_logoutEND IF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>请注意/etc/bashrc是通过~/.bashrc执行，如下所示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># cat ~/.bashrc</span>IF <span class="token punctuation">[</span> -f /etc/bashrc <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span><span class="token builtin class-name">.</span> /etc/bashrcFI<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="非登录交互式shell的执行顺序"><a href="#非登录交互式shell的执行顺序" class="headerlink" title="非登录交互式shell的执行顺序"></a>非登录交互式shell的执行顺序</h2><p>当你启动一个非登录交互式shell,下面是执行顺序</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">IF ~/.bashrc exists THEN    execute ~/.bashrcEND IF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>注意</code>：当一个非交互式shell启动，它会寻找环境变量ENV，并执行包含在环境变量ENV中的文件。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Boost编译选项备忘</title>
      <link href="boost-bian-yi-xuan-xiang-bei-wang/"/>
      <url>boost-bian-yi-xuan-xiang-bei-wang/</url>
      
        <content type="html"><![CDATA[<h2 id="初始化Boost"><a href="#初始化Boost" class="headerlink" title="初始化Boost"></a>初始化Boost</h2><p>进入boost所在的目录，执行下面的命令初始化boost</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Windows</span>./bootstrap.bat<span class="token comment"># Linux</span>./bootstrap.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="编译使用C-静态CRT的64位Boost静态库"><a href="#编译使用C-静态CRT的64位Boost静态库" class="headerlink" title="编译使用C++静态CRT的64位Boost静态库"></a>编译使用C++静态CRT的64位Boost静态库</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./b2.exe --prefix<span class="token operator">=</span>./install64_staticlib_staticrt --stagedir<span class="token operator">=</span>./stage64_staticlib_staticrt --build-dir<span class="token operator">=</span>./build64_staticlib_staticrt --build-type<span class="token operator">=</span>complete --layout<span class="token operator">=</span>versioned --buildid<span class="token operator">=</span>amd64 --without-mpi --without-graph --without-graph_parallel --without-python address-model<span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">variant</span><span class="token operator">=</span>debug,release <span class="token assign-left variable">threading</span><span class="token operator">=</span>multi <span class="token assign-left variable">link</span><span class="token operator">=</span>static runtime-link<span class="token operator">=</span>static -a -q -j16 <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成的文件列表如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">libboost_atomic-vc140-mt-s-1_59-amd64.liblibboost_atomic-vc140-mt-sgd-1_59-amd64.liblibboost_chrono-vc140-mt-s-1_59-amd64.liblibboost_chrono-vc140-mt-sgd-1_59-amd64.liblibboost_container-vc140-mt-s-1_59-amd64.liblibboost_container-vc140-mt-sgd-1_59-amd64.liblibboost_context-vc140-mt-s-1_59-amd64.liblibboost_context-vc140-mt-sgd-1_59-amd64.liblibboost_coroutine-vc140-mt-s-1_59-amd64.liblibboost_coroutine-vc140-mt-sgd-1_59-amd64.liblibboost_date_time-vc140-mt-s-1_59-amd64.liblibboost_date_time-vc140-mt-sgd-1_59-amd64.liblibboost_exception-vc140-mt-s-1_59-amd64.liblibboost_exception-vc140-mt-sgd-1_59-amd64.liblibboost_filesystem-vc140-mt-s-1_59-amd64.liblibboost_filesystem-vc140-mt-sgd-1_59-amd64.liblibboost_iostreams-vc140-mt-s-1_59-amd64.liblibboost_iostreams-vc140-mt-sgd-1_59-amd64.liblibboost_locale-vc140-mt-s-1_59-amd64.liblibboost_locale-vc140-mt-sgd-1_59-amd64.liblibboost_log-vc140-mt-s-1_59-amd64.liblibboost_log-vc140-mt-sgd-1_59-amd64.liblibboost_log_setup-vc140-mt-s-1_59-amd64.liblibboost_log_setup-vc140-mt-sgd-1_59-amd64.liblibboost_math_c99-vc140-mt-s-1_59-amd64.liblibboost_math_c99-vc140-mt-sgd-1_59-amd64.liblibboost_math_c99f-vc140-mt-s-1_59-amd64.liblibboost_math_c99f-vc140-mt-sgd-1_59-amd64.liblibboost_math_c99l-vc140-mt-s-1_59-amd64.liblibboost_math_c99l-vc140-mt-sgd-1_59-amd64.liblibboost_math_tr1-vc140-mt-s-1_59-amd64.liblibboost_math_tr1-vc140-mt-sgd-1_59-amd64.liblibboost_math_tr1f-vc140-mt-s-1_59-amd64.liblibboost_math_tr1f-vc140-mt-sgd-1_59-amd64.liblibboost_math_tr1l-vc140-mt-s-1_59-amd64.liblibboost_math_tr1l-vc140-mt-sgd-1_59-amd64.liblibboost_prg_exec_monitor-vc140-mt-s-1_59-amd64.liblibboost_prg_exec_monitor-vc140-mt-sgd-1_59-amd64.liblibboost_program_options-vc140-mt-s-1_59-amd64.liblibboost_program_options-vc140-mt-sgd-1_59-amd64.liblibboost_random-vc140-mt-s-1_59-amd64.liblibboost_random-vc140-mt-sgd-1_59-amd64.liblibboost_regex-vc140-mt-s-1_59-amd64.liblibboost_regex-vc140-mt-sgd-1_59-amd64.liblibboost_serialization-vc140-mt-s-1_59-amd64.liblibboost_serialization-vc140-mt-sgd-1_59-amd64.liblibboost_signals-vc140-mt-s-1_59-amd64.liblibboost_signals-vc140-mt-sgd-1_59-amd64.liblibboost_system-vc140-mt-s-1_59-amd64.liblibboost_system-vc140-mt-sgd-1_59-amd64.liblibboost_test_exec_monitor-vc140-mt-s-1_59-amd64.liblibboost_test_exec_monitor-vc140-mt-sgd-1_59-amd64.liblibboost_thread-vc140-mt-s-1_59-amd64.liblibboost_thread-vc140-mt-sgd-1_59-amd64.liblibboost_timer-vc140-mt-s-1_59-amd64.liblibboost_timer-vc140-mt-sgd-1_59-amd64.liblibboost_unit_test_framework-vc140-mt-s-1_59-amd64.liblibboost_unit_test_framework-vc140-mt-sgd-1_59-amd64.liblibboost_wave-vc140-mt-s-1_59-amd64.liblibboost_wave-vc140-mt-sgd-1_59-amd64.liblibboost_wserialization-vc140-mt-s-1_59-amd64.liblibboost_wserialization-vc140-mt-sgd-1_59-amd64.lib<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./b2 --prefix<span class="token operator">=</span>./install64_staticlib_staticrt --stagedir<span class="token operator">=</span>./stage64_staticlib_staticrt --build-dir<span class="token operator">=</span>./build64_staticlib_staticrt --build-type<span class="token operator">=</span>complete --layout<span class="token operator">=</span>versioned --buildid<span class="token operator">=</span>amd64 --without-mpi --without-graph --without-graph_parallel --without-python <span class="token assign-left variable">cxxflags</span><span class="token operator">=</span>-fPIC <span class="token assign-left variable">cflags</span><span class="token operator">=</span>-fPIC address-model<span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">variant</span><span class="token operator">=</span>debug,release <span class="token assign-left variable">threading</span><span class="token operator">=</span>multi <span class="token assign-left variable">link</span><span class="token operator">=</span>static runtime-link<span class="token operator">=</span>static -a -q -j6 <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成的文件列表如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">libboost_atomic-gcc49-mt-s-1_59-amd64.alibboost_atomic-gcc49-mt-sd-1_59-amd64.alibboost_chrono-gcc49-mt-s-1_59-amd64.alibboost_chrono-gcc49-mt-sd-1_59-amd64.alibboost_container-gcc49-mt-s-1_59-amd64.alibboost_container-gcc49-mt-sd-1_59-amd64.alibboost_context-gcc49-mt-s-1_59-amd64.alibboost_context-gcc49-mt-sd-1_59-amd64.alibboost_coroutine-gcc49-mt-s-1_59-amd64.alibboost_coroutine-gcc49-mt-sd-1_59-amd64.alibboost_date_time-gcc49-mt-s-1_59-amd64.alibboost_date_time-gcc49-mt-sd-1_59-amd64.alibboost_exception-gcc49-mt-s-1_59-amd64.alibboost_exception-gcc49-mt-sd-1_59-amd64.alibboost_filesystem-gcc49-mt-s-1_59-amd64.alibboost_filesystem-gcc49-mt-sd-1_59-amd64.alibboost_iostreams-gcc49-mt-s-1_59-amd64.alibboost_iostreams-gcc49-mt-sd-1_59-amd64.alibboost_locale-gcc49-mt-s-1_59-amd64.alibboost_locale-gcc49-mt-sd-1_59-amd64.alibboost_log-gcc49-mt-s-1_59-amd64.alibboost_log-gcc49-mt-sd-1_59-amd64.alibboost_log_setup-gcc49-mt-s-1_59-amd64.alibboost_log_setup-gcc49-mt-sd-1_59-amd64.alibboost_math_c99f-gcc49-mt-s-1_59-amd64.alibboost_math_c99f-gcc49-mt-sd-1_59-amd64.alibboost_math_c99-gcc49-mt-s-1_59-amd64.alibboost_math_c99-gcc49-mt-sd-1_59-amd64.alibboost_math_c99l-gcc49-mt-s-1_59-amd64.alibboost_math_c99l-gcc49-mt-sd-1_59-amd64.alibboost_math_tr1f-gcc49-mt-s-1_59-amd64.alibboost_math_tr1f-gcc49-mt-sd-1_59-amd64.alibboost_math_tr1-gcc49-mt-s-1_59-amd64.alibboost_math_tr1-gcc49-mt-sd-1_59-amd64.alibboost_math_tr1l-gcc49-mt-s-1_59-amd64.alibboost_math_tr1l-gcc49-mt-sd-1_59-amd64.alibboost_prg_exec_monitor-gcc49-mt-s-1_59-amd64.alibboost_prg_exec_monitor-gcc49-mt-sd-1_59-amd64.alibboost_program_options-gcc49-mt-s-1_59-amd64.alibboost_program_options-gcc49-mt-sd-1_59-amd64.alibboost_random-gcc49-mt-s-1_59-amd64.alibboost_random-gcc49-mt-sd-1_59-amd64.alibboost_regex-gcc49-mt-s-1_59-amd64.alibboost_regex-gcc49-mt-sd-1_59-amd64.alibboost_serialization-gcc49-mt-s-1_59-amd64.alibboost_serialization-gcc49-mt-sd-1_59-amd64.alibboost_signals-gcc49-mt-s-1_59-amd64.alibboost_signals-gcc49-mt-sd-1_59-amd64.alibboost_system-gcc49-mt-s-1_59-amd64.alibboost_system-gcc49-mt-sd-1_59-amd64.alibboost_test_exec_monitor-gcc49-mt-s-1_59-amd64.alibboost_test_exec_monitor-gcc49-mt-sd-1_59-amd64.alibboost_thread-gcc49-mt-s-1_59-amd64.alibboost_thread-gcc49-mt-sd-1_59-amd64.alibboost_timer-gcc49-mt-s-1_59-amd64.alibboost_timer-gcc49-mt-sd-1_59-amd64.alibboost_unit_test_framework-gcc49-mt-s-1_59-amd64.alibboost_unit_test_framework-gcc49-mt-sd-1_59-amd64.alibboost_wave-gcc49-mt-s-1_59-amd64.alibboost_wave-gcc49-mt-sd-1_59-amd64.alibboost_wserialization-gcc49-mt-s-1_59-amd64.alibboost_wserialization-gcc49-mt-sd-1_59-amd64.a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="修改boost的头文件"><a href="#修改boost的头文件" class="headerlink" title="修改boost的头文件"></a>修改boost的头文件</h2><p>把下面的内容加到文件<code>install64_staticlib_staticrt/include/boost-1_59/boost/config</code>的最后：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">BOOST_LIB_BUILDID amd64</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arch安装备忘</title>
      <link href="arch-an-zhuang-bei-wang/"/>
      <url>arch-an-zhuang-bei-wang/</url>
      
        <content type="html"><![CDATA[<h2 id="获取ISO"><a href="#获取ISO" class="headerlink" title="获取ISO"></a>获取<a href="http://mirrors.163.com/archlinux/iso/latest/">ISO</a></h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> http://mirrors.163.com/archlinux/iso/latest/archlinux-2018.05.01-x86_64.iso<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="从ISO文件引导系统"><a href="#从ISO文件引导系统" class="headerlink" title="从ISO文件引导系统"></a>从ISO文件引导系统</h2><h2 id="更新系统时间"><a href="#更新系统时间" class="headerlink" title="更新系统时间"></a>更新系统时间</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">timedatectl set-ntp <span class="token boolean">true</span>timedatectl status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">parted</span> -a optimal /dev/sdamklabel gptunit mibmkpart primary <span class="token number">1</span> <span class="token number">3</span>name <span class="token number">1</span> grub<span class="token builtin class-name">set</span> <span class="token number">1</span> bios_grub onmkpart primary <span class="token number">3</span> <span class="token number">256</span>name <span class="token number">2</span> boot<span class="token builtin class-name">set</span> <span class="token number">2</span> boot onmkpart primary <span class="token number">256</span> <span class="token number">8448</span>name <span class="token number">3</span> swapmkpart primary <span class="token number">8448</span> -1name <span class="token number">4</span> rootfsprintquitmkfs.ext4 /dev/sda2mkfs.ext4 /dev/sda4<span class="token function">mkswap</span> /dev/sda3<span class="token function">swapon</span> /dev/sda3<span class="token function">mount</span> /dev/sda4 /mnt<span class="token function">mkdir</span> /mnt/boot<span class="token function">mount</span> /dev/sda2 /mnt/boot<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="安装Arch"><a href="#安装Arch" class="headerlink" title="安装Arch"></a>安装Arch</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mv</span> /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.bk<span class="token function">grep</span> <span class="token number">163</span>.com /etc/pacman.d/mirrorlist.bk <span class="token operator">&gt;</span> /etc/pacman.d/mirrorlistpacstrap /mnt base base-develgenfstab -U /mnt <span class="token operator">&gt;&gt;</span> /mnt/etc/fstab<span class="token function">cat</span> /mnt/etc/fstabarch-chroot /mnt<span class="token function">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtimehwclock --systohc<span class="token function">mv</span> /etc/locale.gen /etc/locale.gen.bk<span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">&gt;</span>/etc/locale.gen</span>en_US ISO-8859-1en_US.UTF-8 UTF-8zh_CN GB18030zh_CN.GBK GBKzh_CN.GB2312 GB2312zh_CN.UTF-8 UTF-8EOF</span>locale-genlocale -a<span class="token builtin class-name">echo</span> <span class="token string">"LANG=en_US.UTF-8"</span> <span class="token operator">&gt;</span> /etc/locale.conf<span class="token builtin class-name">echo</span> <span class="token string">"kiba"</span> <span class="token operator">&gt;</span> /etc/hostname<span class="token function">passwd</span>systemctl <span class="token builtin class-name">enable</span> dhcpcdpacman -S <span class="token function">vim</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="安装Grub"><a href="#安装Grub" class="headerlink" title="安装Grub"></a>安装Grub</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pacman -S grubgrub-install /dev/sda<span class="token function">grub-mkconfig</span> -o /boot/grub/grub.cfg<span class="token builtin class-name">exit</span><span class="token builtin class-name">cd</span><span class="token function">umount</span> -R /mnt<span class="token function">reboot</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="安装常用软件"><a href="#安装常用软件" class="headerlink" title="安装常用软件"></a>安装常用软件</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 可以使用命令`pacman -Fs binname`根据执行文件的名字搜索软件包的名字</span>pacman -S openssh<span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">&gt;&gt;</span>/etc/ssh/sshd_config</span>PermitRootLogin yesPasswordAuthentication yesEOF</span>systemctl <span class="token builtin class-name">enable</span> sshdsystemctl start sshd<span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">&gt;&gt;</span>/etc/pacman.conf</span>[archlinuxcn]SigLevel = Optional TrustAllServer = http://mirrors.163.com/archlinux-cn/<span class="token variable">$arch</span>EOF</span>pacman -Syy <span class="token operator">&amp;&amp;</span> pcman -Syu <span class="token operator">&amp;&amp;</span> pacman -S archlinuxcn-keyringpacman -S yaourtpacman -S <span class="token function">wget</span> <span class="token function">git</span><span class="token function">mkdir</span> /usr/share/pictures<span class="token function">wget</span> http://b.hiphotos.baidu.com/zhidao/pic/item/1ad5ad6eddc451da88f9f31ab3fd5266d0163237.jpg -O /usr/share/pictures/background.jpg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="安装GUI"><a href="#安装GUI" class="headerlink" title="安装GUI"></a>安装GUI</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pacman -S xorg xorg-xinit xf86-video-fbdevpacman -S i3-wm i3status i3lock dmenu rxvt-unicode rxvt-unicode-terminfo conky fehpacman -S ttf-font-awesome<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arch </tag>
            
            <tag> 系统安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gentoo安装备忘</title>
      <link href="gentoo-an-zhuang-bei-wang/"/>
      <url>gentoo-an-zhuang-bei-wang/</url>
      
        <content type="html"><![CDATA[<h2 id="获取ISO"><a href="#获取ISO" class="headerlink" title="获取ISO"></a>获取<a href="http://mirrors.163.com/gentoo/releases/amd64/autobuilds/">ISO</a></h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> http://mirrors.163.com/gentoo/releases/amd64/autobuilds/current-install-amd64-minimal/install-amd64-minimal-20180415T214502Z.iso<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="从ISO文件引导系统"><a href="#从ISO文件引导系统" class="headerlink" title="从ISO文件引导系统"></a>从ISO文件引导系统</h2><h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">parted</span> -a optimal /dev/sdamklabel gptunit mibmkpart primary <span class="token number">1</span> <span class="token number">3</span>name <span class="token number">1</span> grub<span class="token builtin class-name">set</span> <span class="token number">1</span> bios_grub onmkpart primary <span class="token number">3</span> <span class="token number">256</span>name <span class="token number">2</span> boot<span class="token builtin class-name">set</span> <span class="token number">2</span> boot onmkpart primary <span class="token number">256</span> <span class="token number">8448</span>name <span class="token number">3</span> swapmkpart primary <span class="token number">8448</span> -1name <span class="token number">4</span> rootfsprintquitmkfs.ext4 /dev/sda2mkfs.ext4 /dev/sda4<span class="token function">mkswap</span> /dev/sda3<span class="token function">swapon</span> /dev/sda3<span class="token function">mount</span> /dev/sda4 /mnt/gentoo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="安装Gentoo"><a href="#安装Gentoo" class="headerlink" title="安装Gentoo"></a>安装Gentoo</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /mnt/gentoo<span class="token function">wget</span> http://mirrors.163.com/gentoo/releases/amd64/autobuilds/current-install-amd64-minimal/stage3-amd64-20180415T214502Z.tar.xz<span class="token comment"># hardened</span><span class="token function">wget</span> http://mirrors.163.com/gentoo/releases/amd64/autobuilds/current-stage3-amd64-hardened/stage3-amd64-hardened-20180517T214504Z.tar.xz<span class="token comment"># systemd</span><span class="token function">wget</span> http://mirrors.163.com/gentoo/releases/amd64/autobuilds/current-stage3-amd64-systemd/stage3-amd64-systemd-20180518.tar.bz2<span class="token function">tar</span> xpf stage3-amd64-20180415T214502Z.tar.xz --xattrs-include<span class="token operator">=</span><span class="token string">'*.*'</span> --numeric-owner<span class="token function">cp</span> /mnt/gentoo/etc/portage/make.conf /mnt/gentoo/etc/portage/make.conf.bk<span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">&gt;</span> /mnt/gentoo/etc/portage/make.conf</span>CFLAGS="-march=native -O2 -pipe"CXXFLAGS="-march=native -O2 -pipe"CHOST="x86_64-pc-linux-gnu"MAKEOPTS="-j9 -l8"EMERGE_DEFAULT_OPTS="--jobs=8 --load-average=8 --ask --verbose --with-bdeps=y"PORTAGE_NICENESS=15# get by cpuid2cpuflags(emerge app-portage/cpuid2cpuflags)CPU_FLAGS_X86="aes avx avx2 f16c fma3 mmx mmxext pclmul popcnt sse sse2 sse3 sse4_1 sse4_2 ssse3"ACCEPT_KEYWORDS="amd64"#GENTOO_MIRRORS="https://mirrors.tuna.tsinghua.edu.cn/gentoo/"#GENTOO_MIRRORS="https://mirrors.163.com/gentoo/"GENTOO_MIRRORS="http://mirrors.ustc.edu.cn/gentoo/"L10N="en-US zh-CN"#LINGUAS="en_US zh_CN"LC_MESSAGES="C"PORTDIR="/usr/portage"DISTDIR="/usr/portage/distfiles"PKGDIR="/usr/portage/packages"#FEATURES="ccache"#CCACHE_SIZE="8G"#USE="dbus policykit udisks udev consolekit X"#VIDEO_CARDS="vmware"#INPUT_DEVICES="keyboard mouse"EOF</span><span class="token function">mkdir</span> --parents /mnt/gentoo/etc/portage/repos.conf<span class="token function">cp</span> /mnt/gentoo/usr/share/portage/config/repos.conf /mnt/gentoo/etc/portage/repos.conf/gentoo.conf.bk<span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">&gt;</span> /mnt/gentoo/etc/portage/repos.conf/gentoo.conf</span>[DEFAULT]main-repo = gentoo[gentoo]location = /usr/portagesync-type = rsync#sync-uri = rsync://rsync.gentoo.org/gentoo-portage#sync-uri = rsync://rsync.cn.gentoo.org/gentoo-portagesync-uri = rsync://rsync.mirrors.ustc.edu.cn/gentoo-portage/auto-sync = yessync-rsync-verify-jobs = 1sync-rsync-verify-metamanifest = nosync-rsync-verify-max-age = 24sync-openpgp-key-path = /usr/share/openpgp-keys/gentoo-release.ascsync-openpgp-key-refresh-retry-count = 40sync-openpgp-key-refresh-retry-overall-timeout = 1200sync-openpgp-key-refresh-retry-delay-exp-base = 2sync-openpgp-key-refresh-retry-delay-max = 60sync-openpgp-key-refresh-retry-delay-mult = 4# for daily squashfs snapshots#sync-type = squashdelta#sync-uri = mirror://gentoo/../snapshots/squashfsEOF</span><span class="token function">cp</span> --dereference /etc/resolv.conf /mnt/gentoo/etc/<span class="token function">mount</span> --types proc /proc /mnt/gentoo/proc<span class="token function">mount</span> --rbind /sys /mnt/gentoo/sys<span class="token function">mount</span> --make-rslave /mnt/gentoo/sys<span class="token function">mount</span> --rbind /dev /mnt/gentoo/dev<span class="token function">mount</span> --make-rslave /mnt/gentoo/dev<span class="token function">chroot</span> /mnt/gentoo /bin/bash<span class="token builtin class-name">source</span> /etc/profile<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PS1</span></span><span class="token operator">=</span><span class="token string">"(chroot) <span class="token variable">${<span class="token environment constant">PS1</span>}</span>"</span><span class="token function">mkdir</span> /boot<span class="token function">mount</span> /dev/sda2 /bootemerge-webrsyncemerge --synceselect profile listeselect profile <span class="token builtin class-name">set</span> default/linux/amd64/17.0/desktop/plasmaemerge --ask --update --deep --newuse @world<span class="token function">ls</span> /usr/share/zoneinfo<span class="token builtin class-name">echo</span> <span class="token string">"Asia/Shanghai"</span> <span class="token operator">&gt;</span> /etc/timezoneemerge --config sys-libs/timezone-data<span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">&gt;</span>/etc/locale.gen</span>en_US ISO-8859-1en_US.UTF-8 UTF-8zh_CN GB18030zh_CN.GBK GBKzh_CN.GB2312 GB2312zh_CN.UTF-8 UTF-8EOF</span>locale-genlocale -aeselect locale listeselect locale <span class="token builtin class-name">set</span> en_US.utf8env-update <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">source</span> /etc/profile <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PS1</span></span><span class="token operator">=</span><span class="token string">"(chroot) <span class="token environment constant">$PS1</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="配置内核"><a href="#配置内核" class="headerlink" title="配置内核"></a>配置内核</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">emerge sys-kernel/gentoo-sources<span class="token function">ls</span> -l /usr/src/linuxemerge sys-kernel/genkernel<span class="token function">nano</span> -w /etc/fstab<span class="token comment"># /dev/sda2 /boot ext2 defaults 0 2</span>genkernel all<span class="token comment"># or genkernel --lvm all</span><span class="token function">ls</span> /boot/kernel* /boot/initramfs*emerge sys-kernel/linux-firmware<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="配置系统"><a href="#配置系统" class="headerlink" title="配置系统"></a>配置系统</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">nano</span> -w /etc/fstab<span class="token comment">#/dev/sda2  /boot       ext4    defaults,noatime    0 2</span><span class="token comment">#/dev/sda3  none        swap    sw                  0 0</span><span class="token comment">#/dev/sda4  /           ext4    noatime             0 1</span><span class="token comment">#/dev/cdrom /mnt/cdrom  auto    noauto,user         0 0</span><span class="token function">cp</span> /etc/conf.d/hostname /etc/conf.d/hostname.bk<span class="token builtin class-name">echo</span> <span class="token string">"hostname=<span class="token entity" title="\&quot;">\"</span>gentoo<span class="token entity" title="\&quot;">\"</span>"</span> <span class="token operator">&gt;</span> /etc/conf.d/hostnameemerge --noreplace net-misc/netifrc<span class="token builtin class-name">echo</span> <span class="token string">"config_eno16777736=<span class="token entity" title="\&quot;">\"</span>dhcp<span class="token entity" title="\&quot;">\"</span>"</span> <span class="token operator">&gt;</span> /etc/conf.d/net<span class="token function">passwd</span><span class="token builtin class-name">cd</span> /etc/init.d<span class="token function">ln</span> -s net.lo net.eno16777736rc-update <span class="token function">add</span> net.eno16777736 default<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="安装系统工具"><a href="#安装系统工具" class="headerlink" title="安装系统工具"></a>安装系统工具</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">emerge app-admin/sysklogdrc-update <span class="token function">add</span> sysklogd defaultemerge sys-process/cronierc-update <span class="token function">add</span> cronie defaultemerge sys-apps/mlocaterc-update <span class="token function">add</span> sshd defaultemerge net-misc/dhcpcdrc-update <span class="token function">add</span> dhcpcd defaultrc-update <span class="token function">add</span> dbus defaultrc-update <span class="token function">add</span> udev sysinitrc-update <span class="token function">add</span> consolekit default<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="安装Grub"><a href="#安装Grub" class="headerlink" title="安装Grub"></a>安装Grub</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">emerge sys-boot/grub:2grub-install /dev/sda<span class="token function">grub-mkconfig</span> -o /boot/grub/grub.cfg<span class="token builtin class-name">exit</span><span class="token builtin class-name">cd</span><span class="token function">umount</span> -l /mnt/gentoo/dev<span class="token punctuation">{</span>/shm,/pts,<span class="token punctuation">}</span><span class="token function">umount</span> -R /mnt/gentoo<span class="token function">reboot</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="安装系统内核工具"><a href="#安装系统内核工具" class="headerlink" title="安装系统内核工具"></a>安装系统内核工具</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">emerge app-portage/eix app-portage/gentoolkit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="更新系统"><a href="#更新系统" class="headerlink" title="更新系统"></a>更新系统</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">eix-syncemerge -avuDN --tree worldemerge -av --depcleanrevdep-rebuild -v -- --askdispatch-confeclean-dist -deix-test-obsoleteglsa-check -t allglsa-check -f all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="安装Xorg"><a href="#安装Xorg" class="headerlink" title="安装Xorg"></a>安装Xorg</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">emerge --ask x11-base/xorg-drivers media-libs/mesa x11-base/xorg-x11 x11-wm/twm x11-terms/xtermstartx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="安装Kde"><a href="#安装Kde" class="headerlink" title="安装Kde"></a>安装Kde</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">emerge --ask kde-plasma/plasma-meta<span class="token builtin class-name">echo</span> <span class="token string">"DISPLAYMANAGER=<span class="token entity" title="\&quot;">\"</span>sddm<span class="token entity" title="\&quot;">\"</span>"</span> <span class="token operator">&gt;&gt;</span> /etc/conf.d/xdmrc-update <span class="token function">add</span> xdm default<span class="token function">useradd</span> -m k<span class="token function">passwd</span> k<span class="token comment">#su k</span><span class="token comment">#groups</span><span class="token comment">#usermod -a -G plugdev k</span>emerge app-portage/laymanlayman -Llayman -a gentoo-zhemerge app-i18n/fcitx app-i18n/fcitx-cloudpinyin app-i18n/kcm-fcitx<span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">&gt;&gt;</span>/home/k/.xprofile</span>eval "<span class="token variable"><span class="token variable">$(</span>dbus-launch --sh-syntax --exit-with-session<span class="token variable">)</span></span>"export XMODIFIERS="@im=fcitx"export QT_IM_MODULE=fcitxexport GTK_IM_MODULE=fcitxEOF</span><span class="token comment">#/etc/init.d/xdm restart</span><span class="token function">reboot</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">emerge --ask kde-apps/kde-apps-metaemerge --ask www-client/google-chromeemerge --ask app-portage/pfl<span class="token comment"># e-file = apt-file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="更新系统时间"><a href="#更新系统时间" class="headerlink" title="更新系统时间"></a>更新系统时间</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># ntp</span>emerge --ask net-misc/openntpd<span class="token function">mv</span> /etc/ntpd.conf /etc/ntpd.conf.bk<span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">&gt;</span>/etc/ntpd.conf</span>servers 0.cn.pool.ntp.orgservers 1.cn.pool.ntp.orgservers 2.cn.pool.ntp.orgservers 3.cn.pool.ntp.orgEOF</span>/etc/init.d/ntpd startrc-update <span class="token function">add</span> ntpd default<span class="token function">cp</span> /etc/conf.d/hwclock /etc/conf.d/hwclock.bk<span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">&gt;</span>/etc/conf.d/hwclock</span>clock="local"clock_args=""EOF</span>hwclock --systohc --utchwclock --hctosys --localtime<span class="token function">date</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统安装 </tag>
            
            <tag> Gentoo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断两个矩形是否相交</title>
      <link href="pan-duan-liang-ge-ju-xing-shi-fou-xiang-jiao/"/>
      <url>pan-duan-liang-ge-ju-xing-shi-fou-xiang-jiao/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给出两个矩形的一个顶点和宽度高度，判断两个矩形是否相交并计算出相交的区域。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>下面给了出几种算法的C代码并对其进行了测试，算法依次更简单快速：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">IsOverlap1</span><span class="token punctuation">(</span><span class="token keyword">double</span> ax1<span class="token punctuation">,</span> <span class="token keyword">double</span> ay1<span class="token punctuation">,</span> <span class="token keyword">double</span> aw<span class="token punctuation">,</span> <span class="token keyword">double</span> ah<span class="token punctuation">,</span>    <span class="token keyword">double</span> bx1<span class="token punctuation">,</span> <span class="token keyword">double</span> by1<span class="token punctuation">,</span> <span class="token keyword">double</span> bw<span class="token punctuation">,</span> <span class="token keyword">double</span> bh<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">double</span> ax2<span class="token punctuation">,</span> ay2<span class="token punctuation">,</span> bx2<span class="token punctuation">,</span> by2<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">&lt;</span> <span class="token number">0.0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> a <span class="token operator">+=</span> b<span class="token punctuation">;</span> b <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">-</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>ax1<span class="token punctuation">,</span> aw<span class="token punctuation">,</span> ax2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>ay1<span class="token punctuation">,</span> ah<span class="token punctuation">,</span> ay2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>bx1<span class="token punctuation">,</span> bw<span class="token punctuation">,</span> bx2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>by1<span class="token punctuation">,</span> bh<span class="token punctuation">,</span> by2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">undef</span> <span class="token expression">_PARAM_CHECK_</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token punctuation">(</span>a <span class="token operator">&lt;=</span> b <span class="token operator">&amp;&amp;</span> b <span class="token operator">&lt;=</span> c<span class="token punctuation">)</span></span></span>    <span class="token comment">/*    1.B有顶点在A中    -------A    |     |    |   ------B    |   | |  |    ----|--  |        |    |        ------    */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>ax1<span class="token punctuation">,</span> bx1<span class="token punctuation">,</span> ax2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>ay1<span class="token punctuation">,</span> by1<span class="token punctuation">,</span> ay2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>ax1<span class="token punctuation">,</span> bx1<span class="token punctuation">,</span> ax2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>ay1<span class="token punctuation">,</span> by2<span class="token punctuation">,</span> ay2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>ax1<span class="token punctuation">,</span> bx2<span class="token punctuation">,</span> ax2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>ay1<span class="token punctuation">,</span> by1<span class="token punctuation">,</span> ay2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>ax1<span class="token punctuation">,</span> bx2<span class="token punctuation">,</span> ax2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>ay1<span class="token punctuation">,</span> by2<span class="token punctuation">,</span> ay2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">/*    2.A有2或4个顶点在B中    -------B    | --- |    --|-|--      ---A    -------    | --- |    | |A| |    | --- |    -------B    */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>bx1<span class="token punctuation">,</span> ax1<span class="token punctuation">,</span> bx2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>by1<span class="token punctuation">,</span> ay1<span class="token punctuation">,</span> by2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>bx1<span class="token punctuation">,</span> ax2<span class="token punctuation">,</span> bx2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>by1<span class="token punctuation">,</span> ay2<span class="token punctuation">,</span> by2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">/*    3.A与B十字相交且A横B竖       ---B       | |    ---|-|---A    |  | |  |    ---|-|---       | |       ---    */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>ax1<span class="token punctuation">,</span> bx1<span class="token punctuation">,</span> ax2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>ax1<span class="token punctuation">,</span> bx2<span class="token punctuation">,</span> ax2<span class="token punctuation">)</span>        <span class="token operator">&amp;&amp;</span> <span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>by1<span class="token punctuation">,</span> ay1<span class="token punctuation">,</span> by2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>by1<span class="token punctuation">,</span> ay2<span class="token punctuation">,</span> by2<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">/*    3.A与B十字相交且A竖B横       ---A       | |    ---|-|---B    |  | |  |    ---|-|---       | |       ---    */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>bx1<span class="token punctuation">,</span> ax1<span class="token punctuation">,</span> bx2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>bx1<span class="token punctuation">,</span> ax2<span class="token punctuation">,</span> bx2<span class="token punctuation">)</span>        <span class="token operator">&amp;&amp;</span> <span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>ay1<span class="token punctuation">,</span> by1<span class="token punctuation">,</span> ay2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">_IS_BETWEEN_</span><span class="token punctuation">(</span>ay1<span class="token punctuation">,</span> by2<span class="token punctuation">,</span> ay2<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">IsOverlap2</span><span class="token punctuation">(</span><span class="token keyword">double</span> ax1<span class="token punctuation">,</span> <span class="token keyword">double</span> ay1<span class="token punctuation">,</span> <span class="token keyword">double</span> aw<span class="token punctuation">,</span> <span class="token keyword">double</span> ah<span class="token punctuation">,</span>    <span class="token keyword">double</span> bx1<span class="token punctuation">,</span> <span class="token keyword">double</span> by1<span class="token punctuation">,</span> <span class="token keyword">double</span> bw<span class="token punctuation">,</span> <span class="token keyword">double</span> bh<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">/*    如果A与B中心在X和Y轴上的距离小于他们边长和的一半就相交    */</span>    <span class="token keyword">double</span> ax2<span class="token punctuation">,</span> ay2<span class="token punctuation">,</span> bx2<span class="token punctuation">,</span> by2<span class="token punctuation">;</span>    <span class="token keyword">double</span> dx<span class="token punctuation">,</span> dy<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">&lt;</span> <span class="token number">0.0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> a <span class="token operator">+=</span> b<span class="token punctuation">;</span> b <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">-</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>ax1<span class="token punctuation">,</span> aw<span class="token punctuation">,</span> ax2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>ay1<span class="token punctuation">,</span> ah<span class="token punctuation">,</span> ay2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>bx1<span class="token punctuation">,</span> bw<span class="token punctuation">,</span> bx2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>by1<span class="token punctuation">,</span> bh<span class="token punctuation">,</span> by2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">undef</span> <span class="token expression">_PARAM_CHECK_</span></span>    dx <span class="token operator">=</span> ax1 <span class="token operator">+</span> ax2 <span class="token operator">-</span> <span class="token punctuation">(</span>bx1 <span class="token operator">+</span> bx2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* A与B中心在X轴上距离的2倍 */</span>    dy <span class="token operator">=</span> ay1 <span class="token operator">+</span> ay2 <span class="token operator">-</span> <span class="token punctuation">(</span>by1 <span class="token operator">+</span> by2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* A与B中心在Y轴上距离的2倍 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dx <span class="token operator">&lt;</span> <span class="token number">0.0</span><span class="token punctuation">)</span> dx <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">-</span> dx<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dy <span class="token operator">&lt;</span> <span class="token number">0.0</span><span class="token punctuation">)</span> dy <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">-</span> dy<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dx <span class="token operator">&lt;=</span> aw <span class="token operator">+</span> bw <span class="token operator">&amp;&amp;</span> dy <span class="token operator">&lt;=</span> ah <span class="token operator">+</span> bh<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">IsOverlap3</span><span class="token punctuation">(</span><span class="token keyword">double</span> ax1<span class="token punctuation">,</span> <span class="token keyword">double</span> ay1<span class="token punctuation">,</span> <span class="token keyword">double</span> aw<span class="token punctuation">,</span> <span class="token keyword">double</span> ah<span class="token punctuation">,</span>    <span class="token keyword">double</span> bx1<span class="token punctuation">,</span> <span class="token keyword">double</span> by1<span class="token punctuation">,</span> <span class="token keyword">double</span> bw<span class="token punctuation">,</span> <span class="token keyword">double</span> bh<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">/*    找出不相交的情况，取反    */</span>    <span class="token keyword">double</span> ax2<span class="token punctuation">,</span> ay2<span class="token punctuation">,</span> bx2<span class="token punctuation">,</span> by2<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">&lt;</span> <span class="token number">0.0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> a <span class="token operator">+=</span> b<span class="token punctuation">;</span> b <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">-</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>ax1<span class="token punctuation">,</span> aw<span class="token punctuation">,</span> ax2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>ay1<span class="token punctuation">,</span> ah<span class="token punctuation">,</span> ay2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>bx1<span class="token punctuation">,</span> bw<span class="token punctuation">,</span> bx2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>by1<span class="token punctuation">,</span> bh<span class="token punctuation">,</span> by2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">undef</span> <span class="token expression">_PARAM_CHECK_</span></span>    <span class="token comment">/* A在B左边 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ax2 <span class="token operator">&lt;</span> bx1<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/* A在B右边 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bx2 <span class="token operator">&lt;</span> ax1<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/* A在B上边 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>by2 <span class="token operator">&lt;</span> ay1<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/* A在B下边 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ay2 <span class="token operator">&lt;</span> by1<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">IsOverlap4</span><span class="token punctuation">(</span><span class="token keyword">double</span> ax1<span class="token punctuation">,</span> <span class="token keyword">double</span> ay1<span class="token punctuation">,</span> <span class="token keyword">double</span> aw<span class="token punctuation">,</span> <span class="token keyword">double</span> ah<span class="token punctuation">,</span>    <span class="token keyword">double</span> bx1<span class="token punctuation">,</span> <span class="token keyword">double</span> by1<span class="token punctuation">,</span> <span class="token keyword">double</span> bw<span class="token punctuation">,</span> <span class="token keyword">double</span> bh<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">double</span> ax2<span class="token punctuation">,</span> ay2<span class="token punctuation">,</span> bx2<span class="token punctuation">,</span> by2<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">&lt;</span> <span class="token number">0.0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> a <span class="token operator">+=</span> b<span class="token punctuation">;</span> b <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">-</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>ax1<span class="token punctuation">,</span> aw<span class="token punctuation">,</span> ax2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>ay1<span class="token punctuation">,</span> ah<span class="token punctuation">,</span> ay2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>bx1<span class="token punctuation">,</span> bw<span class="token punctuation">,</span> bx2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>by1<span class="token punctuation">,</span> bh<span class="token punctuation">,</span> by2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">undef</span> <span class="token expression">_PARAM_CHECK_</span></span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>ax1 <span class="token operator">&lt;=</span> bx2 <span class="token operator">&amp;&amp;</span> bx1 <span class="token operator">&lt;=</span> ax2 <span class="token operator">&amp;&amp;</span> ay1 <span class="token operator">&lt;=</span> by2 <span class="token operator">&amp;&amp;</span> by1 <span class="token operator">&lt;=</span> ay2<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">GetOverlap</span><span class="token punctuation">(</span><span class="token keyword">double</span> ax1<span class="token punctuation">,</span> <span class="token keyword">double</span> ay1<span class="token punctuation">,</span> <span class="token keyword">double</span> aw<span class="token punctuation">,</span> <span class="token keyword">double</span> ah<span class="token punctuation">,</span>    <span class="token keyword">double</span> bx1<span class="token punctuation">,</span> <span class="token keyword">double</span> by1<span class="token punctuation">,</span> <span class="token keyword">double</span> bw<span class="token punctuation">,</span> <span class="token keyword">double</span> bh<span class="token punctuation">,</span>    <span class="token keyword">double</span><span class="token operator">*</span> cx1<span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">*</span> cy1<span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">*</span> cw<span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">*</span> ch<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">double</span> ax2<span class="token punctuation">,</span> ay2<span class="token punctuation">,</span> bx2<span class="token punctuation">,</span> by2<span class="token punctuation">;</span>    <span class="token keyword">double</span> x1<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> x2<span class="token punctuation">,</span> y2<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">&lt;</span> <span class="token number">0.0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> a <span class="token operator">+=</span> b<span class="token punctuation">;</span> b <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">-</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>ax1<span class="token punctuation">,</span> aw<span class="token punctuation">,</span> ax2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>ay1<span class="token punctuation">,</span> ah<span class="token punctuation">,</span> ay2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>bx1<span class="token punctuation">,</span> bw<span class="token punctuation">,</span> bx2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_PARAM_CHECK_</span><span class="token punctuation">(</span>by1<span class="token punctuation">,</span> bh<span class="token punctuation">,</span> by2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">undef</span> <span class="token expression">_PARAM_CHECK_</span></span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ax1 <span class="token operator">&lt;=</span> bx2 <span class="token operator">&amp;&amp;</span> bx1 <span class="token operator">&lt;=</span> ax2 <span class="token operator">&amp;&amp;</span> ay1 <span class="token operator">&lt;=</span> by2 <span class="token operator">&amp;&amp;</span> by1 <span class="token operator">&lt;=</span> ay2<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        x1 <span class="token operator">=</span> ax1 <span class="token operator">&gt;</span> bx1 <span class="token operator">?</span> ax1 <span class="token operator">:</span> bx1<span class="token punctuation">;</span>        y1 <span class="token operator">=</span> ay1 <span class="token operator">&gt;</span> by1 <span class="token operator">?</span> ay1 <span class="token operator">:</span> by1<span class="token punctuation">;</span>        x2 <span class="token operator">=</span> ax2 <span class="token operator">&lt;</span> bx2 <span class="token operator">?</span> ax2 <span class="token operator">:</span> bx2<span class="token punctuation">;</span>        y2 <span class="token operator">=</span> ay2 <span class="token operator">&lt;</span> by2 <span class="token operator">?</span> ay2 <span class="token operator">:</span> by2<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> cx1<span class="token punctuation">)</span> <span class="token operator">*</span>cx1 <span class="token operator">=</span> x1<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> cy1<span class="token punctuation">)</span> <span class="token operator">*</span>cy1 <span class="token operator">=</span> y1<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> cw<span class="token punctuation">)</span> <span class="token operator">*</span>cw <span class="token operator">=</span> x2 <span class="token operator">-</span> x1<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> ch<span class="token punctuation">)</span> <span class="token operator">*</span>ch <span class="token operator">=</span> y2 <span class="token operator">-</span> y1<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">,</span> <span class="token keyword">double</span> ax1<span class="token punctuation">,</span> <span class="token keyword">double</span> ay1<span class="token punctuation">,</span> <span class="token keyword">double</span> aw<span class="token punctuation">,</span> <span class="token keyword">double</span> ah<span class="token punctuation">,</span>    <span class="token keyword">double</span> bx1<span class="token punctuation">,</span> <span class="token keyword">double</span> by1<span class="token punctuation">,</span> <span class="token keyword">double</span> bw<span class="token punctuation">,</span> <span class="token keyword">double</span> bh<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">double</span> cx1 <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> cy1 <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> cw <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> ch <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> s<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"-----------------------------------------------\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Test:%s\n"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"A:%lf, %lf, %lf, %lf\n"</span><span class="token punctuation">,</span> ax1<span class="token punctuation">,</span> ay1<span class="token punctuation">,</span> aw<span class="token punctuation">,</span> ah<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"B:%lf, %lf, %lf, %lf\n"</span><span class="token punctuation">,</span> bx1<span class="token punctuation">,</span> by1<span class="token punctuation">,</span> bw<span class="token punctuation">,</span> bh<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Result1:%d\n"</span><span class="token punctuation">,</span> <span class="token function">IsOverlap1</span><span class="token punctuation">(</span>ax1<span class="token punctuation">,</span> ay1<span class="token punctuation">,</span> aw<span class="token punctuation">,</span> ah<span class="token punctuation">,</span> bx1<span class="token punctuation">,</span> by1<span class="token punctuation">,</span> bw<span class="token punctuation">,</span> bh<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Result2:%d\n"</span><span class="token punctuation">,</span> <span class="token function">IsOverlap2</span><span class="token punctuation">(</span>ax1<span class="token punctuation">,</span> ay1<span class="token punctuation">,</span> aw<span class="token punctuation">,</span> ah<span class="token punctuation">,</span> bx1<span class="token punctuation">,</span> by1<span class="token punctuation">,</span> bw<span class="token punctuation">,</span> bh<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Result3:%d\n"</span><span class="token punctuation">,</span> <span class="token function">IsOverlap3</span><span class="token punctuation">(</span>ax1<span class="token punctuation">,</span> ay1<span class="token punctuation">,</span> aw<span class="token punctuation">,</span> ah<span class="token punctuation">,</span> bx1<span class="token punctuation">,</span> by1<span class="token punctuation">,</span> bw<span class="token punctuation">,</span> bh<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Result4:%d\n"</span><span class="token punctuation">,</span> <span class="token function">IsOverlap4</span><span class="token punctuation">(</span>ax1<span class="token punctuation">,</span> ay1<span class="token punctuation">,</span> aw<span class="token punctuation">,</span> ah<span class="token punctuation">,</span> bx1<span class="token punctuation">,</span> by1<span class="token punctuation">,</span> bw<span class="token punctuation">,</span> bh<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">GetOverlap</span><span class="token punctuation">(</span>ax1<span class="token punctuation">,</span> ay1<span class="token punctuation">,</span> aw<span class="token punctuation">,</span> ah<span class="token punctuation">,</span> bx1<span class="token punctuation">,</span> by1<span class="token punctuation">,</span> bw<span class="token punctuation">,</span> bh<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cx1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cy1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cw<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Overlap:%lf, %lf, %lf, %lf\n"</span><span class="token punctuation">,</span> cx1<span class="token punctuation">,</span> cy1<span class="token punctuation">,</span> cw<span class="token punctuation">,</span> ch<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The left-up    of B in A"</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span>  <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The left-down  of B in A"</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span>  <span class="token number">2.0</span><span class="token punctuation">,</span>  <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The right-up   of B in A"</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The right-down of B in A"</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.0</span><span class="token punctuation">,</span>  <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The left-up    of A in B"</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span>  <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The left-down  of A in B"</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span>  <span class="token number">2.0</span><span class="token punctuation">,</span>  <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The right-up   of A in B"</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The right-down of A in B"</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.0</span><span class="token punctuation">,</span>  <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The up    of B in A"</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span>  <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">4.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The down  of B in A"</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span>  <span class="token number">0.5</span><span class="token punctuation">,</span>  <span class="token number">4.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The left  of B in A"</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">4.0</span><span class="token punctuation">,</span>  <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The right of B in A"</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span>  <span class="token number">4.0</span><span class="token punctuation">,</span>  <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The up    of A in B"</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span>  <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">4.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The down  of A in B"</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span>  <span class="token number">0.5</span><span class="token punctuation">,</span>  <span class="token number">4.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The left  of A in B"</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">4.0</span><span class="token punctuation">,</span>  <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The right of A in B"</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span>  <span class="token number">4.0</span><span class="token punctuation">,</span>  <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The B in A"</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"The A in B"</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"horizontal A cross vertical B"</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"horizontal B cross vertical A"</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码测试结果"><a href="#代码测试结果" class="headerlink" title="代码测试结果"></a>代码测试结果</h2><pre class="line-numbers language-text" data-language="text"><code class="language-text">-----------------------------------------------Test:The left-up    of B in AA:1.000000, 1.000000, 2.000000, 2.000000B:2.000000, 2.000000, 2.000000, -2.000000Result1:1Result2:1Result3:1Result4:1Overlap:2.000000, 1.000000, 1.000000, 1.000000-----------------------------------------------Test:The left-down  of B in AA:1.000000, 1.000000, 2.000000, 2.000000B:2.000000, 2.000000, 2.000000, 2.000000Result1:1Result2:1Result3:1Result4:1Overlap:2.000000, 2.000000, 1.000000, 1.000000-----------------------------------------------Test:The right-up   of B in AA:1.000000, 1.000000, 2.000000, 2.000000B:2.000000, 2.000000, -2.000000, -2.000000Result1:1Result2:1Result3:1Result4:1Overlap:1.000000, 1.000000, 1.000000, 1.000000-----------------------------------------------Test:The right-down of B in AA:1.000000, 1.000000, 2.000000, 2.000000B:2.000000, 2.000000, -2.000000, 2.000000Result1:1Result2:1Result3:1Result4:1Overlap:1.000000, 2.000000, 1.000000, 1.000000-----------------------------------------------Test:The left-up    of A in BA:2.000000, 2.000000, 2.000000, -2.000000B:1.000000, 1.000000, 2.000000, 2.000000Result1:1Result2:1Result3:1Result4:1Overlap:2.000000, 1.000000, 1.000000, 1.000000-----------------------------------------------Test:The left-down  of A in BA:2.000000, 2.000000, 2.000000, 2.000000B:1.000000, 1.000000, 2.000000, 2.000000Result1:1Result2:1Result3:1Result4:1Overlap:2.000000, 2.000000, 1.000000, 1.000000-----------------------------------------------Test:The right-up   of A in BA:2.000000, 2.000000, -2.000000, -2.000000B:1.000000, 1.000000, 2.000000, 2.000000Result1:1Result2:1Result3:1Result4:1Overlap:1.000000, 1.000000, 1.000000, 1.000000-----------------------------------------------Test:The right-down of A in BA:2.000000, 2.000000, -2.000000, 2.000000B:1.000000, 1.000000, 2.000000, 2.000000Result1:1Result2:1Result3:1Result4:1Overlap:1.000000, 2.000000, 1.000000, 1.000000-----------------------------------------------Test:The up    of B in AA:1.000000, 1.000000, 2.000000, 2.000000B:2.000000, 2.000000, 0.500000, -4.000000Result1:1Result2:1Result3:1Result4:1Overlap:2.000000, 1.000000, 0.500000, 1.000000-----------------------------------------------Test:The down  of B in AA:1.000000, 1.000000, 2.000000, 2.000000B:2.000000, 2.000000, 0.500000, 4.000000Result1:1Result2:1Result3:1Result4:1Overlap:2.000000, 2.000000, 0.500000, 1.000000-----------------------------------------------Test:The left  of B in AA:1.000000, 1.000000, 2.000000, 2.000000B:2.000000, 2.000000, -4.000000, 0.500000Result1:1Result2:1Result3:1Result4:1Overlap:1.000000, 2.000000, 1.000000, 0.500000-----------------------------------------------Test:The right of B in AA:1.000000, 1.000000, 2.000000, 2.000000B:2.000000, 2.000000, 4.000000, 0.500000Result1:1Result2:1Result3:1Result4:1Overlap:2.000000, 2.000000, 1.000000, 0.500000-----------------------------------------------Test:The up    of A in BA:2.000000, 2.000000, 0.500000, -4.000000B:1.000000, 1.000000, 2.000000, 2.000000Result1:1Result2:1Result3:1Result4:1Overlap:2.000000, 1.000000, 0.500000, 1.000000-----------------------------------------------Test:The down  of A in BA:2.000000, 2.000000, 0.500000, 4.000000B:1.000000, 1.000000, 2.000000, 2.000000Result1:1Result2:1Result3:1Result4:1Overlap:2.000000, 2.000000, 0.500000, 1.000000-----------------------------------------------Test:The left  of A in BA:2.000000, 2.000000, -4.000000, 0.500000B:1.000000, 1.000000, 2.000000, 2.000000Result1:1Result2:1Result3:1Result4:1Overlap:1.000000, 2.000000, 1.000000, 0.500000-----------------------------------------------Test:The right of A in BA:2.000000, 2.000000, 4.000000, 0.500000B:1.000000, 1.000000, 2.000000, 2.000000Result1:1Result2:1Result3:1Result4:1Overlap:2.000000, 2.000000, 1.000000, 0.500000-----------------------------------------------Test:The B in AA:1.000000, 1.000000, 2.000000, 2.000000B:2.000000, 2.000000, 0.500000, 0.500000Result1:1Result2:1Result3:1Result4:1Overlap:2.000000, 2.000000, 0.500000, 0.500000-----------------------------------------------Test:The A in BA:2.000000, 2.000000, 0.500000, 0.500000B:1.000000, 1.000000, 2.000000, 2.000000Result1:1Result2:1Result3:1Result4:1Overlap:2.000000, 2.000000, 0.500000, 0.500000-----------------------------------------------Test:horizontal A cross vertical BA:0.000000, 1.000000, 2.000000, 1.000000B:1.000000, 0.000000, 1.000000, 2.000000Result1:1Result2:1Result3:1Result4:1Overlap:1.000000, 1.000000, 1.000000, 1.000000-----------------------------------------------Test:horizontal B cross vertical AA:1.000000, 0.000000, 1.000000, 2.000000B:0.000000, 1.000000, 2.000000, 1.000000Result1:1Result2:1Result3:1Result4:1Overlap:1.000000, 1.000000, 1.000000, 1.000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩形相交 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下Bash中case用法详解</title>
      <link href="linux-xia-bash-zhong-case-yong-fa-xiang-jie/"/>
      <url>linux-xia-bash-zhong-case-yong-fa-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>Linux下Bash中的case和C/C++中的switch类似，但是Bash中的case更强大和复杂。</p><ol><li>强大主要体现在：Bash中case中的关键字可以是字符串类型，而每一项中可以包含正则表达式。</li><li>复杂主要体现在：Bash中case的每一个项后有三个选择：break(常规的break)、unconditional follow up(无条件继续)和conditional follow up(有条件继续)。</li></ol><p>这篇文章的重点是上面的第2点。</p><blockquote><p><code>注意</code>: case的无条件继续和有条件继续是bash 4.1.x及之后的版本中才有的特性。</p></blockquote><p>执行如下命令可以查看你当前bash的版本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token environment constant">$BASH_VERSION</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>常规的break是在每一项后面加;;</li><li>无条件继续是在每一项后面加;&amp;</li><li>有条件继续实在每一项后面加;;&amp;</li></ul><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token builtin class-name">echo</span> <span class="token string">"Test No.1 ..."</span><span class="token keyword">case</span> <span class="token string">"1"</span> <span class="token keyword">in</span>    <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'1'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>    <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'2'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token number">3</span><span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'3'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span>    ?<span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'?'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span>    *<span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'*'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">esac</span><span class="token builtin class-name">echo</span> <span class="token string">"Test No.2 ..."</span><span class="token keyword">case</span> <span class="token string">"1"</span> <span class="token keyword">in</span>    <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'1'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'2'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>    <span class="token number">3</span><span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'3'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span>    ?<span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'?'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span>    *<span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'*'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">esac</span><span class="token builtin class-name">echo</span> <span class="token string">"Test No.3 ..."</span><span class="token keyword">case</span> <span class="token string">"1"</span> <span class="token keyword">in</span>    <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'1'</span>        <span class="token punctuation">;</span><span class="token operator">&amp;</span>    <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'2'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token number">3</span><span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'3'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span>    ?<span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'?'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span>    *<span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'*'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">esac</span><span class="token builtin class-name">echo</span> <span class="token string">"Test No.4 ..."</span><span class="token keyword">case</span> <span class="token string">"1"</span> <span class="token keyword">in</span>    <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'1'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'2'</span>        <span class="token punctuation">;</span><span class="token operator">&amp;</span>    <span class="token number">3</span><span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'3'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span>    ?<span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'?'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span>    *<span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">'*'</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">esac</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><pre class="line-numbers language-text" data-language="text"><code class="language-text">Test No.1 ...1?Test No.2 ...1Test No.3 ...12Test No.4 ...1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个带参数解析的Shell例子</title>
      <link href="yi-ge-dai-can-shu-jie-xi-de-shell-li-zi/"/>
      <url>yi-ge-dai-can-shu-jie-xi-de-shell-li-zi/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment"># Program:</span><span class="token comment">#   LZSH server log filter</span><span class="token comment"># History:</span><span class="token comment">#   2014/07/01  Kom     First release</span><span class="token comment">#   2014/07/03  Kom     Remote and multi-param support</span><span class="token comment">#   2014/07/18  Kom     Fix multi keyword bug</span><span class="token comment">#   2014/07/18  Kom     Continue exe even if some cmd failed</span><span class="token comment">#   2014/07/18  Kom     optimize</span><span class="token comment"># Set PATH</span><span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span>/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<span class="token builtin class-name">export</span> <span class="token environment constant">PATH</span><span class="token comment">#Disable filename globbing</span><span class="token builtin class-name">set</span> -f<span class="token comment"># Set script name variable</span><span class="token assign-left variable">SCRIPT</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">basename</span> $<span class="token punctuation">{</span><span class="token environment constant">BASH_SOURCE</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token variable">`</span></span><span class="token assign-left variable">SCRIPT_VER</span><span class="token operator">=</span><span class="token number">20140718</span>-1809<span class="token comment"># Initialize variables to default values</span><span class="token assign-left variable">IP</span><span class="token operator">=</span><span class="token assign-left variable"><span class="token environment constant">USER</span></span><span class="token operator">=</span><span class="token assign-left variable">TMPOUTPUT</span><span class="token operator">=</span><span class="token builtin class-name">declare</span> -a KEYS<span class="token builtin class-name">declare</span> -a INPUTS<span class="token assign-left variable">OUTPUT</span><span class="token operator">=</span><span class="token comment"># Set fonts for help</span><span class="token assign-left variable">NORM</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span>tput sgr0<span class="token variable">`</span></span><span class="token assign-left variable">BOLD</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span>tput bold<span class="token variable">`</span></span><span class="token assign-left variable">REV</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span>tput smso<span class="token variable">`</span></span><span class="token comment"># Help function</span><span class="token keyword">function</span> <span class="token function-name function">HELP</span><span class="token punctuation">{</span>    <span class="token builtin class-name">echo</span> -e <span class="token punctuation">\</span>n<span class="token string">"<span class="token variable">${BOLD}</span>龙之守护数据过滤脚本<span class="token variable">${SCRIPT}</span><span class="token variable">${NORM}</span>的帮助文档"</span>    <span class="token builtin class-name">echo</span> -e <span class="token string">"<span class="token variable">${BOLD}</span>版本：<span class="token variable">${SCRIPT_VER}</span><span class="token variable">${NORM}</span>"</span><span class="token punctuation">\</span>n    <span class="token builtin class-name">echo</span> -e <span class="token string">"<span class="token variable">${REV}</span>用法:<span class="token variable">${NORM}</span> <span class="token variable">${BOLD}</span><span class="token variable">$SCRIPT</span> 参数<span class="token variable">${NORM}</span>"</span><span class="token punctuation">\</span>n    <span class="token builtin class-name">echo</span> <span class="token string">"可选参数:"</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">${REV}</span>-a<span class="token variable">${NORM}</span>  --输入文件所在的IP，为空表示本地（默认为空）"</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">${REV}</span>-u<span class="token variable">${NORM}</span>  --访问输入文件所用的用户名，当文件在本地时不使用此参数"</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">${REV}</span>-k<span class="token variable">${NORM}</span>  --用于过滤的关键字，此参数可以多个联合使用(例如：-k物品创建 -k强化石)"</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">${REV}</span>-i<span class="token variable">${NORM}</span>  --输入文件的全路径，此参数可以多个联合使用(例如：-i/home/log/objscenesserver21.log.140701-* -i/home/log/objscenesserver40.log.140701-*)"</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">${REV}</span>-o<span class="token variable">${NORM}</span>  --本地输出文件的全路径(例如：-o/local/lzsh.log)"</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">${REV}</span>-t<span class="token variable">${NORM}</span>  --临时输出文件的全路径，当文件在本地时不使用此参数"</span>    <span class="token builtin class-name">echo</span> -e <span class="token string">"<span class="token variable">${REV}</span>-h<span class="token variable">${NORM}</span>  --显示此帮助并退出"</span><span class="token punctuation">\</span>n    <span class="token builtin class-name">echo</span> -e <span class="token string">"示例: "</span>    <span class="token builtin class-name">echo</span> -e <span class="token string">"<span class="token variable">${BOLD}</span><span class="token variable">$SCRIPT</span> -a127.0.0.1 -uUsername -k物品创建 -k强化石 -i/home/log/objscenesserver21.log.140701-* -o/local/lzsh.log -t/tmp/lzsh.log<span class="token variable">${NORM}</span>"</span><span class="token punctuation">\</span>n    <span class="token builtin class-name">exit</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token comment"># Check the number of argument. If none are passed, print help and exit.</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$#</span> -eq <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>    HELP<span class="token keyword">else</span>    <span class="token builtin class-name">echo</span> <span class="token string">"输入参数：<span class="token variable">${BOLD}</span><span class="token variable">$*</span><span class="token variable">${NORM}</span>"</span><span class="token keyword">fi</span><span class="token keyword">while</span> <span class="token builtin class-name">getopts</span> :a:u:t:i:o:k:h FLAG<span class="token punctuation">;</span> <span class="token keyword">do</span>    <span class="token keyword">case</span> <span class="token variable">$FLAG</span> <span class="token keyword">in</span>        a<span class="token punctuation">)</span>            <span class="token assign-left variable">IP</span><span class="token operator">=</span><span class="token variable">$OPTARG</span>            <span class="token punctuation">;</span><span class="token punctuation">;</span>        u<span class="token punctuation">)</span>            <span class="token assign-left variable"><span class="token environment constant">USER</span></span><span class="token operator">=</span><span class="token variable">$OPTARG</span>            <span class="token punctuation">;</span><span class="token punctuation">;</span>        t<span class="token punctuation">)</span>            <span class="token assign-left variable">TMPOUTPUT</span><span class="token operator">=</span><span class="token variable">$OPTARG</span>            <span class="token punctuation">;</span><span class="token punctuation">;</span>        i<span class="token punctuation">)</span>            <span class="token assign-left variable">INPUTS</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token variable">${INPUTS<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span> <span class="token variable">$OPTARG</span><span class="token punctuation">)</span>            <span class="token punctuation">;</span><span class="token punctuation">;</span>        o<span class="token punctuation">)</span>            <span class="token assign-left variable">OUTPUT</span><span class="token operator">=</span><span class="token variable">$OPTARG</span>            <span class="token punctuation">;</span><span class="token punctuation">;</span>        k<span class="token punctuation">)</span>            <span class="token assign-left variable">KEYS</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token variable">${KEYS<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span> <span class="token variable">$OPTARG</span><span class="token punctuation">)</span>            <span class="token punctuation">;</span><span class="token punctuation">;</span>        h<span class="token punctuation">)</span> <span class="token comment"># show help</span>            HELP            <span class="token punctuation">;</span><span class="token punctuation">;</span>        ?<span class="token punctuation">)</span> <span class="token comment"># unrecognized option - show help</span>            <span class="token builtin class-name">echo</span> -e <span class="token punctuation">\</span>n<span class="token string">"非法参数：-<span class="token variable">${BOLD}</span><span class="token variable">$OPTARG</span><span class="token variable">${NORM}</span>"</span>            HELP            <span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token keyword">esac</span><span class="token keyword">done</span><span class="token builtin class-name">shift</span> <span class="token variable"><span class="token variable">$((</span>OPTIND<span class="token operator">-</span><span class="token number">1</span><span class="token variable">))</span></span> <span class="token comment">#  This tells getopts to move on to the next argument</span><span class="token comment">#######################################################################</span><span class="token comment"># Parameters check</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">${<span class="token operator">#</span>KEYS}</span> -eq <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>    <span class="token builtin class-name">echo</span> <span class="token string">"你必须指定至少一个<span class="token variable">${BOLD}</span>关键字<span class="token variable">${NORM}</span>"</span>    <span class="token builtin class-name">exit</span> -1<span class="token keyword">else</span>    <span class="token builtin class-name">echo</span> <span class="token string">"关键字：<span class="token variable">${BOLD}</span><span class="token variable">${KEYS<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span><span class="token variable">${NORM}</span>"</span><span class="token keyword">fi</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">${<span class="token operator">#</span>INPUTS}</span> -eq <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>    <span class="token builtin class-name">echo</span> <span class="token string">"你必须指定至少一个<span class="token variable">${BOLD}</span>输入文件<span class="token variable">${NORM}</span>"</span>    <span class="token builtin class-name">exit</span> -1<span class="token keyword">else</span>    <span class="token builtin class-name">echo</span> <span class="token string">"输入文件：<span class="token variable">${BOLD}</span><span class="token variable">${INPUTS<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span><span class="token variable">${NORM}</span>"</span><span class="token keyword">fi</span><span class="token keyword">if</span> <span class="token punctuation">[</span> -z <span class="token variable">$OUTPUT</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>    <span class="token builtin class-name">echo</span> <span class="token string">"你必须指定<span class="token variable">${BOLD}</span>本地输出文件<span class="token variable">${NORM}</span>"</span>    <span class="token builtin class-name">exit</span> -1<span class="token keyword">fi</span><span class="token builtin class-name">echo</span> <span class="token string">"输出文件：<span class="token variable">${BOLD}</span><span class="token variable">${OUTPUT<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span><span class="token variable">${NORM}</span>"</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> -z <span class="token variable">$IP</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>    <span class="token keyword">if</span> <span class="token punctuation">[</span> -z <span class="token environment constant">$USER</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>        <span class="token builtin class-name">echo</span> <span class="token string">"必须指定用于访问<span class="token variable">${BOLD}</span><span class="token variable">${IP}</span><span class="token variable">${NORM}</span>的<span class="token variable">${BOLD}</span>用户名<span class="token variable">${NORM}</span>"</span>        <span class="token builtin class-name">exit</span> -1    <span class="token keyword">fi</span>    <span class="token keyword">if</span> <span class="token punctuation">[</span> -z <span class="token variable">$TMPOUTPUT</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>        <span class="token builtin class-name">echo</span> <span class="token string">"必须指定在<span class="token variable">${BOLD}</span><span class="token variable">${IP}</span><span class="token variable">${NORM}</span>上的<span class="token variable">${BOLD}</span>临时输出文件<span class="token variable">${NORM}</span>"</span>        <span class="token builtin class-name">exit</span> -1    <span class="token keyword">fi</span><span class="token keyword">fi</span><span class="token comment">#######################################################################</span><span class="token comment"># Work</span><span class="token assign-left variable">TARGETOUTPUT</span><span class="token operator">=</span><span class="token string">""</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> -z <span class="token variable">$IP</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>    <span class="token assign-left variable">TARGETOUTPUT</span><span class="token operator">=</span><span class="token variable">$TMPOUTPUT</span><span class="token keyword">else</span>    <span class="token assign-left variable">TARGETOUTPUT</span><span class="token operator">=</span><span class="token variable">$OUTPUT</span><span class="token keyword">fi</span><span class="token assign-left variable">CMD</span><span class="token operator">=</span><span class="token string">""</span><span class="token keyword">for</span> <span class="token for-or-select variable">k</span> <span class="token keyword">in</span> <span class="token variable">${KEYS<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span><span class="token keyword">do</span>    <span class="token assign-left variable">CMD</span><span class="token operator">=</span><span class="token variable">${CMD}</span><span class="token string">"grep <span class="token variable">$k</span> <span class="token variable">${INPUTS<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span> &gt;&gt; <span class="token variable">$TARGETOUTPUT</span>; "</span><span class="token keyword">done</span><span class="token assign-left variable">CMD</span><span class="token operator">=</span><span class="token string">"echo &gt; <span class="token variable">$TARGETOUTPUT</span>; <span class="token variable">$CMD</span>"</span><span class="token builtin class-name">echo</span> <span class="token variable">$CMD</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> -z <span class="token variable">$IP</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>    <span class="token builtin class-name">echo</span> -e <span class="token punctuation">\</span>n<span class="token string">"将要执行ssh命令："</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">${BOLD}</span>ssh <span class="token environment constant">$USER</span>@<span class="token variable">$IP</span> "</span><span class="token variable">$CMD</span><span class="token string">"<span class="token variable">${NORM}</span>"</span>    <span class="token function">sh</span> -c <span class="token string">"ssh <span class="token environment constant">$USER</span>@<span class="token variable">$IP</span> "</span><span class="token variable">$CMD</span><span class="token string">""</span>    <span class="token builtin class-name">echo</span> -e <span class="token punctuation">\</span>n<span class="token string">"将要执行scp命令："</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">${BOLD}</span>scp <span class="token environment constant">$USER</span>@<span class="token variable">$IP</span>:<span class="token variable">$TMPOUTPUT</span> <span class="token variable">$OUTPUT</span><span class="token variable">${NORM}</span>"</span>    <span class="token function">sh</span> -c <span class="token string">"scp <span class="token environment constant">$USER</span>@<span class="token variable">$IP</span>:<span class="token variable">$TMPOUTPUT</span> <span class="token variable">$OUTPUT</span>"</span><span class="token keyword">else</span>    <span class="token builtin class-name">echo</span> -e <span class="token punctuation">\</span>n<span class="token string">"将要执行命令："</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">${BOLD}</span><span class="token variable">$CMD</span><span class="token variable">${NORM}</span>"</span>    <span class="token function">sh</span> -c <span class="token string">"<span class="token variable">$CMD</span>"</span><span class="token keyword">fi</span><span class="token builtin class-name">exit</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win32程序发生异常时处理的流程</title>
      <link href="win32-cheng-xu-fa-sheng-yi-chang-shi-chu-li-de-liu-cheng/"/>
      <url>win32-cheng-xu-fa-sheng-yi-chang-shi-chu-li-de-liu-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="一、程序没有被调试"><a href="#一、程序没有被调试" class="headerlink" title="一、程序没有被调试"></a>一、程序没有被调试</h2><ol><li>线程建立时，系统安装一个系统线程异常处理例程。</li><li>异常发生时，Win2K/XP控制权转移给NTDLL.KiUserExceptionDispatcher。</li><li>如果你安装了线程相关的异常处理例程，系统就把异常发送给你的处理例程，交由其处理。</li><li>每个线程相关的异常处理例程可以处理或者不处理这个异常,如果他不处理并且安装了多个线程相关的异常处理例程，可交由链起来的其他例程处理。</li><li>如果这些例程均选择不处理异常，系统线程异常处理例程将起作用，调用ZwQueryInformationProcess判断是否被调试，没有调试并且你调用SetUnhandledExceptionFilter安装了最后异常处理例程的话，系统转向对它的调用。</li><li>如果你没有安装最后异常处理例程或者他没有处理这个异常，系统会调用默认的系统处理程序，通常显示一个对话框，你可以选择关闭或者最后将其附加到调试器上的调试按钮。如果没有调试器能被附加于其上或者调试器也处理不了，系统就调用ExitProcess终结程序。</li><li>不过在终结之前，系统仍然对发生异常的线程异常处理句柄来一次展开，这是线程异常处理例程最后清理的机会。一般只用来释放资源，不要试图修复什么。注意只对线程异常有展开。</li></ol><h2 id="二、程序被调试"><a href="#二、程序被调试" class="headerlink" title="二、程序被调试"></a>二、程序被调试</h2><ol><li>线程建立时，系统安装一个系统线程异常处理例程。</li><li>异常发生时，系统挂起程序并向调试器发送。EXCEPTION_DEBUG_EVENT消息。</li><li>调试器未能处理异常(比如我们在OD里按Shift+F7)，控制权转移给 NTDLL。KiUserExceptionDispatcher如果你安装了线程相关的异常处理例程，系统就把异常发送给你的程序seh处理例程，交由其处理。</li><li>每个线程相关的异常处理例程可以处理或者不处理这个异常，如果他不处理并且安装了多个线程相关的异常处理例程，可交由链起来的其他例程处理。</li><li>如果这些例程均选择不处理异常，系统线程异常处理例程将起作用，调用ZwQueryInformationProcess判断是否被调试。</li><li>由于被调试，操作系统仍会再次挂起程序通知debugger。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++重载内存分配时需要注意的地方</title>
      <link href="c-chong-zai-nei-cun-fen-pei-shi-xu-yao-zhu-yi-de-di-fang/"/>
      <url>c-chong-zai-nei-cun-fen-pei-shi-xu-yao-zhu-yi-de-di-fang/</url>
      
        <content type="html"><![CDATA[<h2 id="一、测试代码"><a href="#一、测试代码" class="headerlink" title="一、测试代码"></a>一、测试代码</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;new&gt;</span></span><span class="token comment">//#define VF</span><span class="token comment">//#define FLAG</span><span class="token keyword">class</span> <span class="token class-name">MemObj</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">VF</span></span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">MemObj</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">// VF</span></span>    <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t stSize<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"operator new(size_t) %d\n"</span><span class="token punctuation">,</span> stSize<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">malloc</span><span class="token punctuation">(</span>stSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">FLAG</span></span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> pMemory<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"operator delete(void*)\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>pMemory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> pMemory<span class="token punctuation">,</span> size_t stSize<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"operator delete(void*, size_t) %d\n"</span><span class="token punctuation">,</span> stSize<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>pMemory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">MemObj</span></span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> m_nValue<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span><span class="token punctuation">{</span>    MemObj<span class="token operator">*</span> pObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">MemObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> pObj<span class="token punctuation">;</span>    Test<span class="token operator">*</span> pTest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> pTest<span class="token punctuation">;</span>    pObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> pObj<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、测试"><a href="#二、测试" class="headerlink" title="二、测试"></a>二、测试</h2><p>通过控制宏VF和宏FLAG的定义与否来查看各个情况下代码运行的结果。</p><h3 id="测试1：不定义宏VF和FLAG"><a href="#测试1：不定义宏VF和FLAG" class="headerlink" title="测试1：不定义宏VF和FLAG"></a>测试1：不定义宏VF和FLAG</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">operator new(size_t) 1operator delete(void*, size_t) 1operator new(size_t) 4operator delete(void*, size_t) 1operator new(size_t) 4operator delete(void*, size_t) 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="测试2：定义宏FLAG但不定义宏VF"><a href="#测试2：定义宏FLAG但不定义宏VF" class="headerlink" title="测试2：定义宏FLAG但不定义宏VF"></a>测试2：定义宏FLAG但不定义宏VF</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">operator new(size_t) 1operator delete(void*)operator new(size_t) 4operator delete(void*)operator new(size_t) 4operator delete(void*)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="测试3：定义宏VF但不定义宏FLAG"><a href="#测试3：定义宏VF但不定义宏FLAG" class="headerlink" title="测试3：定义宏VF但不定义宏FLAG"></a>测试3：定义宏VF但不定义宏FLAG</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">operator new(size_t) 4operator delete(void*, size_t) 4operator new(size_t) 8operator delete(void*, size_t) 8operator new(size_t) 8operator delete(void*, size_t) 8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="测试4：同时定义宏VF和FLAG"><a href="#测试4：同时定义宏VF和FLAG" class="headerlink" title="测试4：同时定义宏VF和FLAG"></a>测试4：同时定义宏VF和FLAG</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">operator new(size_t) 4operator delete(void*)operator new(size_t) 8operator delete(void*)operator new(size_t) 8operator delete(void*)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、结果分析"><a href="#三、结果分析" class="headerlink" title="三、结果分析"></a>三、结果分析</h2><h3 id="1-对比测试1和测试2"><a href="#1-对比测试1和测试2" class="headerlink" title="1. 对比测试1和测试2"></a>1. 对比测试1和测试2</h3><p>重载了operator new(size_t stSize)后，在删除的时候：</p><ol><li>如果没有定义<code>void operator delete(void* pMemory)，那么会调用void operator delete(void* pMemory, size_t stSize)</code>；</li><li>如果定义了<code>void operator delete(void* pMemory)，不管是否定义void operator delete(void* pMemory, size_t stSize)都会调用void operator delete(void* pMemory)</code>。</li></ol><p>结论：<br>重载operator new(size_t)后，如果同时重载了operator delete(void<em>)，删除时候会调用operator delete(void</em>)，否则才会调用operator delete(void*, size_t)。</p><h3 id="2-对比测试1和测试3"><a href="#2-对比测试1和测试3" class="headerlink" title="2. 对比测试1和测试3"></a>2. 对比测试1和测试3</h3><p>如果不将基类的析构函数定义为虚析构函数，会有内存泄漏。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win32下FS寄存器、TEB和PEB详解</title>
      <link href="win32-xia-fs-ji-cun-qi-teb-he-peb-xiang-jie/"/>
      <url>win32-xia-fs-ji-cun-qi-teb-he-peb-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>在Win32下，FS段寄存器指向当前的TEB结构，在TEB编译0x30处是PEB指针，通过这个指针即可获得PED的地址。</p><p>实现方法：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">__asm<span class="token punctuation">{</span>    mov eax<span class="token punctuation">,</span> fs<span class="token operator">:</span><span class="token punctuation">[</span><span class="token number">0x30</span><span class="token punctuation">]</span>    mov PED<span class="token punctuation">,</span> eax<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TEB和PEB的结构如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">PEB_BASE</span> <span class="token punctuation">(</span><span class="token number">0x7ffdf000</span><span class="token punctuation">)</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_NT_TIB</span><span class="token punctuation">{</span>                                           <span class="token comment">// Size: 01C</span>    <span class="token keyword">struct</span> <span class="token class-name">_EXCEPTION_REGISTRATION_RECORD</span> <span class="token operator">*</span>ExceptionList<span class="token punctuation">;</span> <span class="token comment">// 000</span>    PVOID StackBase<span class="token punctuation">;</span>                        <span class="token comment">// 004</span>    PVOID StackLimit<span class="token punctuation">;</span>                       <span class="token comment">// 008</span>    PVOID SubSystemTib<span class="token punctuation">;</span>                     <span class="token comment">// 00C</span>    <span class="token keyword">union</span>                                   <span class="token comment">// 010</span>    <span class="token punctuation">{</span>        PVOID FiberData<span class="token punctuation">;</span>        ULONG Version<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    PVOID ArbitraryUserPointer<span class="token punctuation">;</span>             <span class="token comment">// 014</span>    <span class="token keyword">struct</span> <span class="token class-name">_NT_TIB</span> <span class="token operator">*</span>Self<span class="token punctuation">;</span>                   <span class="token comment">// 018</span><span class="token punctuation">}</span> NT_TIB<span class="token punctuation">,</span> <span class="token operator">*</span>PNT_TIB<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_TEB</span><span class="token punctuation">{</span>                                           <span class="token comment">// Size:  FBC</span>    NT_TIB Tib<span class="token punctuation">;</span>                             <span class="token comment">// 000</span>    PVOID EnvironmentPointer<span class="token punctuation">;</span>               <span class="token comment">// 01C</span>    CLIENT_ID Cid<span class="token punctuation">;</span>                          <span class="token comment">// 020</span>    PVOID ActiveRpcHandle<span class="token punctuation">;</span>                  <span class="token comment">// 028</span>    PVOID ThreadLocalStoragePointer<span class="token punctuation">;</span>        <span class="token comment">// 02C</span>    <span class="token keyword">struct</span> <span class="token class-name">_PEB</span> <span class="token operator">*</span>ProcessEnvironmentBlock<span class="token punctuation">;</span>   <span class="token comment">// 030</span>    ULONG LastErrorValue<span class="token punctuation">;</span>                   <span class="token comment">// 034</span>    ULONG CountOfOwnedCriticalSections<span class="token punctuation">;</span>     <span class="token comment">// 038</span>    PVOID CsrClientThread<span class="token punctuation">;</span>                  <span class="token comment">// 03C</span>    <span class="token keyword">struct</span> <span class="token class-name">_W32THREAD</span><span class="token operator">*</span> Win32ThreadInfo<span class="token punctuation">;</span>     <span class="token comment">// 040</span>    ULONG User32Reserved<span class="token punctuation">[</span><span class="token number">0x1A</span><span class="token punctuation">]</span><span class="token punctuation">;</span>             <span class="token comment">// 044</span>    ULONG UserReserved<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                  <span class="token comment">// 0AC</span>    PVOID WOW32Reserved<span class="token punctuation">;</span>                    <span class="token comment">// 0C0</span>    LCID CurrentLocale<span class="token punctuation">;</span>                     <span class="token comment">// 0C4</span>    ULONG FpSoftwareStatusRegister<span class="token punctuation">;</span>         <span class="token comment">// 0C8</span>    PVOID SystemReserved1<span class="token punctuation">[</span><span class="token number">0x36</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">// 0CC</span>    LONG ExceptionCode<span class="token punctuation">;</span>                     <span class="token comment">// 1A4</span>    <span class="token keyword">struct</span> <span class="token class-name">_ACTIVATION_CONTEXT_STACK</span> <span class="token operator">*</span>ActivationContextStackPointer<span class="token punctuation">;</span> <span class="token comment">// 1A8</span>    UCHAR SpareBytes1<span class="token punctuation">[</span><span class="token number">0x28</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment">// 1AC</span>    GDI_TEB_BATCH GdiTebBatch<span class="token punctuation">;</span>              <span class="token comment">// 1D4</span>    CLIENT_ID RealClientId<span class="token punctuation">;</span>                 <span class="token comment">// 6B4</span>    PVOID GdiCachedProcessHandle<span class="token punctuation">;</span>           <span class="token comment">// 6BC</span>    ULONG GdiClientPID<span class="token punctuation">;</span>                     <span class="token comment">// 6C0</span>    ULONG GdiClientTID<span class="token punctuation">;</span>                     <span class="token comment">// 6C4</span>    PVOID GdiThreadLocalInfo<span class="token punctuation">;</span>               <span class="token comment">// 6C8</span>    ULONG Win32ClientInfo<span class="token punctuation">[</span><span class="token number">62</span><span class="token punctuation">]</span><span class="token punctuation">;</span>              <span class="token comment">// 6CC</span>    PVOID glDispatchTable<span class="token punctuation">[</span><span class="token number">0xE9</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">// 7C4</span>    ULONG glReserved1<span class="token punctuation">[</span><span class="token number">0x1D</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment">// B68</span>    PVOID glReserved2<span class="token punctuation">;</span>                      <span class="token comment">// BDC</span>    PVOID glSectionInfo<span class="token punctuation">;</span>                    <span class="token comment">// BE0</span>    PVOID glSection<span class="token punctuation">;</span>                        <span class="token comment">// BE4</span>    PVOID glTable<span class="token punctuation">;</span>                          <span class="token comment">// BE8</span>    PVOID glCurrentRC<span class="token punctuation">;</span>                      <span class="token comment">// BEC</span>    PVOID glContext<span class="token punctuation">;</span>                        <span class="token comment">// BF0</span>    NTSTATUS LastStatusValue<span class="token punctuation">;</span>               <span class="token comment">// BF4</span>    UNICODE_STRING StaticUnicodeString<span class="token punctuation">;</span>     <span class="token comment">// BF8</span>    WCHAR StaticUnicodeBuffer<span class="token punctuation">[</span><span class="token number">0x105</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">// C00</span>    PVOID DeallocationStack<span class="token punctuation">;</span>                <span class="token comment">// E0C</span>    PVOID TlsSlots<span class="token punctuation">[</span><span class="token number">0x40</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                   <span class="token comment">// E10</span>    LIST_ENTRY TlsLinks<span class="token punctuation">;</span>                    <span class="token comment">// F10</span>    PVOID Vdm<span class="token punctuation">;</span>                              <span class="token comment">// F18</span>    PVOID ReservedForNtRpc<span class="token punctuation">;</span>                 <span class="token comment">// F1C</span>    PVOID DbgSsReserved<span class="token punctuation">[</span><span class="token number">0x2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>               <span class="token comment">// F20</span>    ULONG HardErrorDisabled<span class="token punctuation">;</span>                <span class="token comment">// F28</span>    PVOID Instrumentation<span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">;</span>              <span class="token comment">// F2C</span>    PVOID SubProcessTag<span class="token punctuation">;</span>                    <span class="token comment">// F64</span>    PVOID EtwTraceData<span class="token punctuation">;</span>                     <span class="token comment">// F68</span>    PVOID WinSockData<span class="token punctuation">;</span>                      <span class="token comment">// F6C</span>    ULONG GdiBatchCount<span class="token punctuation">;</span>                    <span class="token comment">// F70</span>    BOOLEAN InDbgPrint<span class="token punctuation">;</span>                     <span class="token comment">// F74</span>    BOOLEAN FreeStackOnTermination<span class="token punctuation">;</span>         <span class="token comment">// F75</span>    BOOLEAN HasFiberData<span class="token punctuation">;</span>                   <span class="token comment">// F76</span>    UCHAR IdealProcessor<span class="token punctuation">;</span>                   <span class="token comment">// F77</span>    ULONG GuaranteedStackBytes<span class="token punctuation">;</span>             <span class="token comment">// F78</span>    PVOID ReservedForPerf<span class="token punctuation">;</span>                  <span class="token comment">// F7C</span>    PVOID ReservedForOle<span class="token punctuation">;</span>                   <span class="token comment">// F80</span>    ULONG WaitingOnLoaderLock<span class="token punctuation">;</span>              <span class="token comment">// F84</span>    ULONG SparePointer1<span class="token punctuation">;</span>                    <span class="token comment">// F88</span>    ULONG SoftPatchPtr1<span class="token punctuation">;</span>                    <span class="token comment">// F8C</span>    ULONG SoftPatchPtr2<span class="token punctuation">;</span>                    <span class="token comment">// F90</span>    PVOID <span class="token operator">*</span>TlsExpansionSlots<span class="token punctuation">;</span>               <span class="token comment">// F94</span>    ULONG ImpersionationLocale<span class="token punctuation">;</span>             <span class="token comment">// F98</span>    ULONG IsImpersonating<span class="token punctuation">;</span>                  <span class="token comment">// F9C</span>    PVOID NlsCache<span class="token punctuation">;</span>                         <span class="token comment">// FA0</span>    PVOID pShimData<span class="token punctuation">;</span>                        <span class="token comment">// FA4</span>    ULONG HeapVirualAffinity<span class="token punctuation">;</span>               <span class="token comment">// FA8</span>    PVOID CurrentTransactionHandle<span class="token punctuation">;</span>         <span class="token comment">// FAC</span>    PTEB_ACTIVE_FRAME ActiveFrame<span class="token punctuation">;</span>          <span class="token comment">// FB0</span>    PVOID FlsData<span class="token punctuation">;</span>                          <span class="token comment">// FB4</span>    UCHAR SafeThunkCall<span class="token punctuation">;</span>                    <span class="token comment">// FB8</span>    UCHAR BooleanSpare<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                  <span class="token comment">// FB9</span><span class="token punctuation">}</span> TEB<span class="token punctuation">,</span> <span class="token operator">*</span>PTEB<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_LIST_ENTRY</span><span class="token punctuation">{</span>                                           <span class="token comment">// Size: 008</span>    <span class="token keyword">struct</span> <span class="token class-name">_LIST_ENTRY</span> <span class="token operator">*</span>Flink<span class="token punctuation">;</span>              <span class="token comment">// 000 从前到后</span>    <span class="token keyword">struct</span> <span class="token class-name">_LIST_ENTRY</span> <span class="token operator">*</span>Blink<span class="token punctuation">;</span>              <span class="token comment">// 004 从后到前</span><span class="token punctuation">}</span> LIST_ENTRY<span class="token punctuation">,</span> <span class="token operator">*</span>PLIST_ENTRY<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_PER_LDR_DATA</span><span class="token punctuation">{</span>                                           <span class="token comment">// Size: 0024</span>    ULONG Length<span class="token punctuation">;</span>                           <span class="token comment">// 000</span>    BOOLEAN Initialize<span class="token punctuation">;</span>                     <span class="token comment">// 004</span>    PVOID SsHandle<span class="token punctuation">;</span>                         <span class="token comment">// 008</span>    LIST_ENTRY InLoadOrderModuleList<span class="token punctuation">;</span>       <span class="token comment">// 00C</span>    LIST_ENTRY InMemoryOrderModuleList<span class="token punctuation">;</span>     <span class="token comment">// 014</span>    LIST_ENTRY InInitializationOrderModuleList<span class="token punctuation">;</span> <span class="token comment">// 01C</span><span class="token punctuation">}</span> PER_LDR_DATA<span class="token punctuation">,</span> <span class="token operator">*</span>PPER_LDR_DATA<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_UNICODE_STRING</span><span class="token punctuation">{</span>                                           <span class="token comment">// Size: 008</span>  USHORT  Length<span class="token punctuation">;</span>                           <span class="token comment">// 000 占用的内存字节数，个数*2；</span>  USHORT  MaximumLength<span class="token punctuation">;</span>                    <span class="token comment">// 002</span>  PWSTR  Buffer<span class="token punctuation">;</span>                            <span class="token comment">// 004</span><span class="token punctuation">}</span> UNICODE_STRING <span class="token punctuation">,</span><span class="token operator">*</span>PUNICODE_STRING<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_LDR_DATA_TABLE_ENTRY</span><span class="token punctuation">{</span>                                           <span class="token comment">// Size: 050</span>     LIST_ENTRY InLoadOrderLinks<span class="token punctuation">;</span>           <span class="token comment">// 000 LIST_ENTRY里的Flink和Blink其实是指向LDR_MODULE结构，即LDR_DATA_TABLE_ENTRY</span>     LIST_ENTRY InMemoryOrderLinks<span class="token punctuation">;</span>         <span class="token comment">// 008 同上</span>     LIST_ENTRY InInitializationOrderLinks<span class="token punctuation">;</span> <span class="token comment">// 010 同上</span>     PVOID DllBase<span class="token punctuation">;</span>                         <span class="token comment">// 018</span>     PVOID EntryPoint<span class="token punctuation">;</span>                      <span class="token comment">// 01C</span>     ULONG SizeOfImage<span class="token punctuation">;</span>                     <span class="token comment">// 020</span>     UNICODE_STRING FullDllName<span class="token punctuation">;</span>            <span class="token comment">// 024</span>     UNICODE_STRING BaseDllName<span class="token punctuation">;</span>            <span class="token comment">// 02C</span>     ULONG Flags<span class="token punctuation">;</span>                           <span class="token comment">// 034</span>     WORD LoadCount<span class="token punctuation">;</span>                        <span class="token comment">// 038</span>     WORD TlsIndex<span class="token punctuation">;</span>                         <span class="token comment">// 03A</span>     <span class="token keyword">union</span>                                  <span class="token comment">// 03C</span>     <span class="token punctuation">{</span>          LIST_ENTRY HashLinks<span class="token punctuation">;</span>             <span class="token comment">// 03C</span>          <span class="token keyword">struct</span>          <span class="token punctuation">{</span>               PVOID SectionPointer<span class="token punctuation">;</span>        <span class="token comment">// 03C</span>               ULONG CheckSum<span class="token punctuation">;</span>              <span class="token comment">// 040</span>          <span class="token punctuation">}</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">;</span>     <span class="token keyword">union</span>     <span class="token punctuation">{</span>          ULONG TimeDateStamp<span class="token punctuation">;</span>              <span class="token comment">// 044</span>          PVOID LoadedImports<span class="token punctuation">;</span>              <span class="token comment">// 044</span>     <span class="token punctuation">}</span><span class="token punctuation">;</span>     _ACTIVATION_CONTEXT <span class="token operator">*</span> EntryPointActivationContext<span class="token punctuation">;</span> <span class="token comment">// 048</span>     PVOID PatchInformation<span class="token punctuation">;</span>                <span class="token comment">// 04C</span><span class="token punctuation">}</span> LDR_DATA_TABLE_ENTRY<span class="token punctuation">,</span> <span class="token operator">*</span>PLDR_DATA_TABLE_ENTRY<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_PEB</span><span class="token punctuation">{</span>                                           <span class="token comment">// Size: 1D8</span>    UCHAR InheritedAddressSpace<span class="token punctuation">;</span>            <span class="token comment">// 000</span>    UCHAR ReadImageFileExecOptions<span class="token punctuation">;</span>         <span class="token comment">// 001</span>    UCHAR BeingDebugged<span class="token punctuation">;</span>                    <span class="token comment">// 002</span>    UCHAR SpareBool<span class="token punctuation">;</span>                        <span class="token comment">// 003 Allocation size</span>    HANDLE Mutant<span class="token punctuation">;</span>                          <span class="token comment">// 004</span>    HINSTANCE ImageBaseAddress<span class="token punctuation">;</span>             <span class="token comment">// 008</span>    <span class="token keyword">struct</span> <span class="token class-name">_PER_LDR_DATA</span> <span class="token operator">*</span>Ldr<span class="token punctuation">;</span>              <span class="token comment">// 00C</span>    strcut _RTL_USER_PPROCESS_PARAMETERS <span class="token operator">*</span>ProcessParameters<span class="token punctuation">;</span> <span class="token comment">// 010</span>    ULONG SubSystemData<span class="token punctuation">;</span>                    <span class="token comment">// 014</span>    HANDLE DefaultHeap<span class="token punctuation">;</span>                     <span class="token comment">// 018</span>    KSPIN_LOCK FastPebLock<span class="token punctuation">;</span>                 <span class="token comment">// 01C</span>    ULONG FastPebLockRoutine<span class="token punctuation">;</span>               <span class="token comment">// 020</span>    ULONG FastPebUnlockRoutine<span class="token punctuation">;</span>             <span class="token comment">// 024</span>    ULONG EnvironmentUpdateCount<span class="token punctuation">;</span>           <span class="token comment">// 028</span>    ULONG KernelCallbackTable<span class="token punctuation">;</span>              <span class="token comment">// 02C</span>    LARGE_INTEGER SystemReserved<span class="token punctuation">;</span>           <span class="token comment">// 030</span>    <span class="token keyword">struct</span> <span class="token class-name">_PER_FREE_BLOCK</span> <span class="token operator">*</span>FreeList<span class="token punctuation">;</span>       <span class="token comment">// 038</span>    ULONG TlsExpansionCounter<span class="token punctuation">;</span>              <span class="token comment">// 03C</span>    ULONG TlsBitmap<span class="token punctuation">;</span>                        <span class="token comment">// 040</span>    LARGE_INTEGER TlsBitmapBits<span class="token punctuation">;</span>            <span class="token comment">// 044</span>    ULONG ReadOnlySharedMemoryBase<span class="token punctuation">;</span>         <span class="token comment">// 04C</span>    ULONG ReadOnlySharedMemoryHeap<span class="token punctuation">;</span>         <span class="token comment">// 050</span>    ULONG ReadOnlyStaticServerData<span class="token punctuation">;</span>         <span class="token comment">// 054</span>    ULONG AnsiCodePageData<span class="token punctuation">;</span>                 <span class="token comment">// 058</span>    ULONG OemCodePageData<span class="token punctuation">;</span>                  <span class="token comment">// 05C</span>    ULONG UnicodeCaseTableData<span class="token punctuation">;</span>             <span class="token comment">// 060</span>    ULONG NumberOfProcessors<span class="token punctuation">;</span>               <span class="token comment">// 064</span>    LARGE_INTEGER NtGlobalFlag<span class="token punctuation">;</span>             <span class="token comment">// 068 Address of a local copy</span>    LARGE_INTEGER CriticalSectionTimeout<span class="token punctuation">;</span>   <span class="token comment">// 070</span>    ULONG HeapSegmentReserve<span class="token punctuation">;</span>               <span class="token comment">// 078</span>    ULONG HeapSegmentCommit<span class="token punctuation">;</span>                <span class="token comment">// 07C</span>    ULONG HeapDeCommitTotalFreeThreshold<span class="token punctuation">;</span>   <span class="token comment">// 080</span>    ULONG HeapDeCommitFreeBlockThreshold<span class="token punctuation">;</span>   <span class="token comment">// 084</span>    ULONG NumberOfHeaps<span class="token punctuation">;</span>                    <span class="token comment">// 088</span>    ULONG MaximumNumberOfHeaps<span class="token punctuation">;</span>             <span class="token comment">// 08C</span>    ULONG ProcessHeaps<span class="token punctuation">;</span>                     <span class="token comment">// 090</span>    ULONG GdiSharedHandleTable<span class="token punctuation">;</span>             <span class="token comment">// 094</span>    ULONG ProcessStarterHelper<span class="token punctuation">;</span>             <span class="token comment">// 098</span>    ULONG GdiDCAttributeList<span class="token punctuation">;</span>               <span class="token comment">// 09C</span>    KSPIN_LOCK LoaderLock<span class="token punctuation">;</span>                  <span class="token comment">// 0A0</span>    ULONG OSMajorVersion<span class="token punctuation">;</span>                   <span class="token comment">// 0A4</span>    ULONG OSMinorVersion<span class="token punctuation">;</span>                   <span class="token comment">// 0A8</span>    USHORT OSBuildNumber<span class="token punctuation">;</span>                   <span class="token comment">// 0AC</span>    USHORT OSCSDVersion<span class="token punctuation">;</span>                    <span class="token comment">// 0AE</span>    ULONG OSPlatformId<span class="token punctuation">;</span>                     <span class="token comment">// 0B0</span>    ULONG ImageSubsystem<span class="token punctuation">;</span>                   <span class="token comment">// 0B4</span>    ULONG ImageSubsystemMajorVersion<span class="token punctuation">;</span>       <span class="token comment">// 0B8</span>    ULONG ImageSubsystemMinorVersion<span class="token punctuation">;</span>       <span class="token comment">// 0BC</span>    ULONG ImageProcessAffinityMask<span class="token punctuation">;</span>         <span class="token comment">// 0C0</span>    ULONG GdiHandleBuffer<span class="token punctuation">[</span><span class="token number">0x22</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">// 0C4</span>    ULONG PostProcessInitRoutine<span class="token punctuation">;</span>           <span class="token comment">// 14C</span>    ULONG TlsExpansionBitmap<span class="token punctuation">;</span>               <span class="token comment">// 150</span>    UCHAR TlsExpansionBitmapBits<span class="token punctuation">[</span><span class="token number">0x80</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// 154</span>    ULONG SessionId<span class="token punctuation">;</span>                        <span class="token comment">// 1D4</span><span class="token punctuation">}</span> PEB<span class="token punctuation">,</span> <span class="token operator">*</span>PPEB<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> 逆向工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>elf文件查看工具</title>
      <link href="elf-wen-jian-cha-kan-gong-ju/"/>
      <url>elf-wen-jian-cha-kan-gong-ju/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* * Copyright (c) 2013 Kiba Amor &lt;KibaAmor@gmai.com&gt; * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * *  * Redistributions of source code must retain the above copyright *    notice, this list ofconditions and the following disclaimer. * *  * Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materialsprovided with the *    distribution. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;elf.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">_countof</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">_countof</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token operator">/</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>X<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">safe_free</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>  <span class="token expression"><span class="token keyword">if</span> <span class="token punctuation">(</span>X <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> </span><span class="token punctuation">\</span>  <span class="token expression"><span class="token punctuation">{</span> </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token function">free</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">;</span> </span><span class="token punctuation">\</span>    <span class="token expression">X <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> </span><span class="token punctuation">\</span>  <span class="token expression"><span class="token punctuation">}</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>__x86_64__<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">ARCH </span><span class="token string">"x86_64"</span></span><span class="token keyword">typedef</span> Elf64_Ehdr Elf_Ehdr<span class="token punctuation">;</span><span class="token keyword">typedef</span> Elf64_Phdr Elf_Phdr<span class="token punctuation">;</span><span class="token keyword">typedef</span> Elf64_Shdr Elf_Shdr<span class="token punctuation">;</span><span class="token keyword">typedef</span> Elf64_Sym  Elf_Sym<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">ELF_ST_TYPE</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token function">ELF64_ST_TYPE</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">ELF_ST_BIND</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token function">ELF64_ST_BIND</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">ELF_ST_VISIBILITY</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token function">ELF64_ST_VISIBILITY</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span></span></span><span class="token keyword">typedef</span> Elf64_Rel  Elf_Rel<span class="token punctuation">;</span><span class="token keyword">typedef</span> Elf64_Rela Elf_Rela<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">ELF_R_SYM</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span>  <span class="token function">ELF64_R_SYM</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">ELF_R_TYPE</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token function">ELF64_R_TYPE</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">ARCH </span><span class="token string">"x86"</span></span><span class="token keyword">typedef</span> Elf32_Ehdr Elf_Ehdr<span class="token punctuation">;</span><span class="token keyword">typedef</span> Elf32_Phdr Elf_Phdr<span class="token punctuation">;</span><span class="token keyword">typedef</span> Elf32_Shdr Elf_Shdr<span class="token punctuation">;</span><span class="token keyword">typedef</span> Elf32_Sym  Elf_Sym<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">ELF_ST_TYPE</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token function">ELF32_ST_TYPE</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">ELF_ST_BIND</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token function">ELF32_ST_BIND</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">ELF_ST_VISIBILITY</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token function">ELF32_ST_VISIBILITY</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span></span></span><span class="token keyword">typedef</span> Elf32_Rel  Elf_Rel<span class="token punctuation">;</span><span class="token keyword">typedef</span> Elf32_Rela Elf_Rela<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">ELF_R_SYM</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span>  <span class="token function">ELF32_R_SYM</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">ELF_R_TYPE</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token function">ELF32_R_TYPE</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">// __x86_64__</span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>  <span class="token keyword">int</span>         key<span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> value<span class="token punctuation">;</span><span class="token punctuation">}</span> pair_t<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> g_selfname <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> g_filename <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">int</span>         g_file <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>Elf_Ehdr<span class="token operator">*</span>   g_ehdr <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>Elf_Phdr<span class="token operator">*</span>   g_phdrs <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">int</span>         g_phdr_num <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>Elf_Shdr<span class="token operator">*</span>   g_shdrs <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">int</span>         g_shdr_num <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span>       g_shdr_str_tab <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">clean_up</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>g_file <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">close</span><span class="token punctuation">(</span>g_file<span class="token punctuation">)</span><span class="token punctuation">;</span>    g_file <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">safe_free</span><span class="token punctuation">(</span>g_ehdr<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">safe_free</span><span class="token punctuation">(</span>g_phdrs<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">safe_free</span><span class="token punctuation">(</span>g_shdrs<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">safe_free</span><span class="token punctuation">(</span>g_shdr_str_tab<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">get_file</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>g_file <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    g_file <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>g_filename<span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>g_file <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open input file failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> g_file<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">read_at</span><span class="token punctuation">(</span><span class="token keyword">int</span> file<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> buf<span class="token punctuation">,</span> <span class="token keyword">int</span> cnt<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">==</span> <span class="token function">lseek</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> <span class="token constant">SEEK_SET</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token function">read</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> cnt<span class="token punctuation">)</span> <span class="token operator">==</span> cnt <span class="token operator">?</span> cnt <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">is_elf_file</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span> ident<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ident      <span class="token operator">||</span> ident<span class="token punctuation">[</span>EI_MAG0<span class="token punctuation">]</span> <span class="token operator">!=</span> ELFMAG0      <span class="token operator">||</span> ident<span class="token punctuation">[</span>EI_MAG1<span class="token punctuation">]</span> <span class="token operator">!=</span> ELFMAG1      <span class="token operator">||</span> ident<span class="token punctuation">[</span>EI_MAG2<span class="token punctuation">]</span> <span class="token operator">!=</span> ELFMAG2      <span class="token operator">||</span> ident<span class="token punctuation">[</span>EI_MAG3<span class="token punctuation">]</span> <span class="token operator">!=</span> ELFMAG3<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> Elf_Ehdr<span class="token operator">*</span> <span class="token function">get_ehdr</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>g_ehdr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    g_ehdr <span class="token operator">=</span> <span class="token punctuation">(</span>Elf_Ehdr <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Elf_Ehdr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">read_at</span><span class="token punctuation">(</span><span class="token function">get_file</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> g_ehdr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Elf_Ehdr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"read elf header failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">is_elf_file</span><span class="token punctuation">(</span>g_ehdr<span class="token operator">-&gt;</span>e_ident<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"'%s' is not a elf file\n"</span><span class="token punctuation">,</span> g_filename<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Elf_Ehdr<span class="token punctuation">)</span> <span class="token operator">!=</span> g_ehdr<span class="token operator">-&gt;</span>e_ehsize<span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"elf header size mismatch\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> g_ehdr<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> Elf_Phdr<span class="token operator">*</span> <span class="token function">get_phdrs</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">const</span> Elf_Ehdr<span class="token operator">*</span> ehdr <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>g_phdrs <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    ehdr <span class="token operator">=</span> <span class="token function">get_ehdr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Elf_Phdr<span class="token punctuation">)</span> <span class="token operator">!=</span> ehdr<span class="token operator">-&gt;</span>e_phentsize<span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"program header size mismatch\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    g_phdr_num <span class="token operator">=</span> ehdr<span class="token operator">-&gt;</span>e_phnum<span class="token punctuation">;</span>    g_phdrs <span class="token operator">=</span> <span class="token punctuation">(</span>Elf_Phdr <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Elf_Phdr<span class="token punctuation">)</span> <span class="token operator">*</span> g_phdr_num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">read_at</span><span class="token punctuation">(</span><span class="token function">get_file</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ehdr<span class="token operator">-&gt;</span>e_phoff<span class="token punctuation">,</span> g_phdrs<span class="token punctuation">,</span>        <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Elf_Phdr<span class="token punctuation">)</span> <span class="token operator">*</span> g_phdr_num<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"read program header failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> g_phdrs<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> Elf_Shdr<span class="token operator">*</span> <span class="token function">get_shdrs</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">const</span> Elf_Ehdr<span class="token operator">*</span> ehdr <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>g_shdrs <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    ehdr <span class="token operator">=</span> <span class="token function">get_ehdr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Elf_Shdr<span class="token punctuation">)</span> <span class="token operator">!=</span> ehdr<span class="token operator">-&gt;</span>e_shentsize<span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"section header size mismatch\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    g_shdr_num <span class="token operator">=</span> ehdr<span class="token operator">-&gt;</span>e_shnum<span class="token punctuation">;</span>    g_shdrs <span class="token operator">=</span> <span class="token punctuation">(</span>Elf_Shdr <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Elf_Shdr<span class="token punctuation">)</span> <span class="token operator">*</span> g_shdr_num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">read_at</span><span class="token punctuation">(</span><span class="token function">get_file</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ehdr<span class="token operator">-&gt;</span>e_shoff<span class="token punctuation">,</span> g_shdrs<span class="token punctuation">,</span>          <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Elf_Shdr<span class="token punctuation">)</span> <span class="token operator">*</span> g_shdr_num<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"read section header failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> g_shdrs<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">get_sect_cont_by_idx</span><span class="token punctuation">(</span><span class="token keyword">int</span> sect_idx<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">const</span> Elf_Shdr<span class="token operator">*</span> shdrs <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token keyword">void</span><span class="token operator">*</span> sect_cont <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>sect_idx <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> sect_idx <span class="token operator">&gt;=</span> g_shdr_num<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  shdrs <span class="token operator">=</span> <span class="token function">get_shdrs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  sect_cont <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>shdrs<span class="token punctuation">[</span>sect_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_size<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">read_at</span><span class="token punctuation">(</span><span class="token function">get_file</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> shdrs<span class="token punctuation">[</span>sect_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_offset<span class="token punctuation">,</span>    sect_cont<span class="token punctuation">,</span> shdrs<span class="token punctuation">[</span>sect_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_size<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">safe_free</span><span class="token punctuation">(</span>sect_cont<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> sect_cont<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">get_shdr_str_tab</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>g_shdr_str_tab <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    g_shdr_str_tab <span class="token operator">=</span> <span class="token function">get_sect_cont_by_idx</span><span class="token punctuation">(</span><span class="token function">get_ehdr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>e_shstrndx<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> g_shdr_str_tab<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">get_sect_idx_by_name</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> sect_name<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">const</span> Elf_Shdr<span class="token operator">*</span> shdrs <span class="token operator">=</span> <span class="token function">get_shdrs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> shdr_str_tab <span class="token operator">=</span> <span class="token function">get_shdr_str_tab</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> g_shdr_num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>sect_name<span class="token punctuation">,</span> shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_name <span class="token operator">+</span> shdr_str_tab<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> i<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">print_pair</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">const</span> pair_t<span class="token operator">*</span> pairs<span class="token punctuation">,</span> <span class="token keyword">int</span> cnt<span class="token punctuation">,</span> <span class="token keyword">int</span> linefeed<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>cnt <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> pairs<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> pairs<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>linefeed<span class="token punctuation">)</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">print_ehdr_ident</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">const</span> pair_t classpairs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>  <span class="token punctuation">{</span>    <span class="token punctuation">{</span>ELFCLASSNONE<span class="token punctuation">,</span>  <span class="token string">"None"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ELFCLASS32<span class="token punctuation">,</span>    <span class="token string">"ELF32"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ELFCLASS64<span class="token punctuation">,</span>    <span class="token string">"ELF64"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> pair_t datapairs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>  <span class="token punctuation">{</span>    <span class="token punctuation">{</span>ELFDATANONE<span class="token punctuation">,</span> <span class="token string">"None"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ELFDATA2LSB<span class="token punctuation">,</span> <span class="token string">"2's complement, little endian"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ELFDATA2MSB<span class="token punctuation">,</span> <span class="token string">"2's complement, big endian"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> pair_t osabipairs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>  <span class="token punctuation">{</span>    <span class="token comment">//{ELFOSABI_NONE,     "UNIX System VB ABI"},</span>    <span class="token punctuation">{</span>ELFOSABI_SYSV<span class="token punctuation">,</span>       <span class="token string">"UNIX System VB ABI"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ELFOSABI_HPUX<span class="token punctuation">,</span>       <span class="token string">"HP-UX"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ELFOSABI_NETBSD<span class="token punctuation">,</span>     <span class="token string">"NetBSD"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment">//{ELFOSABI_GNU,      "Object uses GNU ELF extensions"},</span>    <span class="token punctuation">{</span>ELFOSABI_LINUX<span class="token punctuation">,</span>      <span class="token string">"Object uses GNU ELF extensions"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ELFOSABI_SOLARIS<span class="token punctuation">,</span>    <span class="token string">"Sun Solaris"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ELFOSABI_AIX<span class="token punctuation">,</span>        <span class="token string">"AIX"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ELFOSABI_IRIX<span class="token punctuation">,</span>       <span class="token string">"IBM Irix"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ELFOSABI_FREEBSD<span class="token punctuation">,</span>    <span class="token string">"FreeBSD"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ELFOSABI_TRU64<span class="token punctuation">,</span>      <span class="token string">"Compaq TRU64 UNIX"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ELFOSABI_MODESTO<span class="token punctuation">,</span>    <span class="token string">"Novell Modesto"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ELFOSABI_OPENBSD<span class="token punctuation">,</span>    <span class="token string">"OpenBSD"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ELFOSABI_ARM_AEABI<span class="token punctuation">,</span>  <span class="token string">"ARM EABI"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ELFOSABI_ARM<span class="token punctuation">,</span>        <span class="token string">"ARM"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ELFOSABI_STANDALONE<span class="token punctuation">,</span> <span class="token string">"Standlone (embedded) application"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> Elf_Ehdr<span class="token operator">*</span> ehdr <span class="token operator">=</span> <span class="token function">get_ehdr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span> ident <span class="token operator">=</span> ehdr<span class="token operator">-&gt;</span>e_ident<span class="token punctuation">;</span>  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ELF Header:\n  Magic:  "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> EI_NIDENT<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%02X "</span><span class="token punctuation">,</span> ident<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n  Class:                              "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">print_pair</span><span class="token punctuation">(</span>ident<span class="token punctuation">[</span>EI_CLASS<span class="token punctuation">]</span><span class="token punctuation">,</span> classpairs<span class="token punctuation">,</span> <span class="token function">_countof</span><span class="token punctuation">(</span>classpairs<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Data:                               "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">print_pair</span><span class="token punctuation">(</span>ident<span class="token punctuation">[</span>EI_DATA<span class="token punctuation">]</span><span class="token punctuation">,</span> datapairs<span class="token punctuation">,</span> <span class="token function">_countof</span><span class="token punctuation">(</span>datapairs<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Version:                            %d%s\n"</span><span class="token punctuation">,</span> ident<span class="token punctuation">[</span>EI_VERSION<span class="token punctuation">]</span><span class="token punctuation">,</span>      ident<span class="token punctuation">[</span>EI_VERSION<span class="token punctuation">]</span> <span class="token operator">==</span> EV_CURRENT <span class="token operator">?</span> <span class="token string">"(current)"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  OS/ABI:                             "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">print_pair</span><span class="token punctuation">(</span>ident<span class="token punctuation">[</span>EI_OSABI<span class="token punctuation">]</span><span class="token punctuation">,</span> osabipairs<span class="token punctuation">,</span> <span class="token function">_countof</span><span class="token punctuation">(</span>osabipairs<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">print_ehdr</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">const</span> pair_t objtypepairs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>  <span class="token punctuation">{</span>    <span class="token punctuation">{</span>ET_NONE<span class="token punctuation">,</span> <span class="token string">"None"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ET_REL<span class="token punctuation">,</span>  <span class="token string">"Relocatable file"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ET_EXEC<span class="token punctuation">,</span> <span class="token string">"Executable file"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ET_DYN<span class="token punctuation">,</span>  <span class="token string">"Shared object file"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>ET_CORE<span class="token punctuation">,</span> <span class="token string">"Core file"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> pair_t machinepairs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>  <span class="token punctuation">{</span>    <span class="token punctuation">{</span>EM_NONE<span class="token punctuation">,</span>       <span class="token string">"None"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_M32<span class="token punctuation">,</span>        <span class="token string">"AT&amp;T WE 32100"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_SPARC<span class="token punctuation">,</span>      <span class="token string">"SUN SPARC"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_386<span class="token punctuation">,</span>        <span class="token string">"Intel 80386"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_68K<span class="token punctuation">,</span>        <span class="token string">"Motorola m68k family"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_88K<span class="token punctuation">,</span>        <span class="token string">"Motorola m88k family"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_860<span class="token punctuation">,</span>        <span class="token string">"Intel 80860"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_MIPS<span class="token punctuation">,</span>       <span class="token string">"MIPS R3000 big-endian"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_S370<span class="token punctuation">,</span>       <span class="token string">"IBM System/370"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_MIPS_RS3_LE<span class="token punctuation">,</span><span class="token string">"MIPS R3000 little-endian"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_PARISC<span class="token punctuation">,</span>     <span class="token string">"HPPA"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_VPP500<span class="token punctuation">,</span>     <span class="token string">"Fujitsu VPP500"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_SPARC32PLUS<span class="token punctuation">,</span><span class="token string">"Sun's \"v8plus\""</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_960<span class="token punctuation">,</span>        <span class="token string">"Intel 80960"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_PPC<span class="token punctuation">,</span>        <span class="token string">"PowerPC"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_PPC64<span class="token punctuation">,</span>      <span class="token string">"PowerPC 64-bit"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_S390<span class="token punctuation">,</span>       <span class="token string">"IBM S390"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_V800<span class="token punctuation">,</span>       <span class="token string">"NEC V800 series"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_FR20<span class="token punctuation">,</span>       <span class="token string">"Fujitsu FR20"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_RH32<span class="token punctuation">,</span>       <span class="token string">"TRW RH-32"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_RCE<span class="token punctuation">,</span>        <span class="token string">"Motorola RCE"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_ARM<span class="token punctuation">,</span>        <span class="token string">"ARM"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_FAKE_ALPHA<span class="token punctuation">,</span> <span class="token string">"Digital Alpha"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_SH<span class="token punctuation">,</span>         <span class="token string">"Hitachi SH"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_SPARCV9<span class="token punctuation">,</span>    <span class="token string">"SPARC v9 64-bit"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_TRICORE<span class="token punctuation">,</span>    <span class="token string">"Siemens Tricore"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_ARC<span class="token punctuation">,</span>        <span class="token string">"Argonaut RISC Core"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_H8_300<span class="token punctuation">,</span>     <span class="token string">"Hitachi H8/300"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_H8_300H<span class="token punctuation">,</span>    <span class="token string">"Hitachi H8/300H"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_H8S<span class="token punctuation">,</span>        <span class="token string">"Hitachi H8S"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_H8_500<span class="token punctuation">,</span>     <span class="token string">"Hitachi H8/500"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_IA_64<span class="token punctuation">,</span>      <span class="token string">"Intel Merced"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_MIPS_X<span class="token punctuation">,</span>     <span class="token string">"Stanford MIPS-X"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_COLDFIRE<span class="token punctuation">,</span>   <span class="token string">"Motorola Coldfire"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_68HC12<span class="token punctuation">,</span>     <span class="token string">"Motorola M68HC12"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_MMA<span class="token punctuation">,</span>        <span class="token string">"Fujitsu MMA Multimedia Accelerator"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_PCP<span class="token punctuation">,</span>        <span class="token string">"Siemens PCP"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_NCPU<span class="token punctuation">,</span>       <span class="token string">"Sony nCPU embeeded RISC"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_NDR1<span class="token punctuation">,</span>       <span class="token string">"Denso NDR1 microprocessor"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_STARCORE<span class="token punctuation">,</span>   <span class="token string">"Motorola Start*Core processor"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_ME16<span class="token punctuation">,</span>       <span class="token string">"Toyota ME16 processor"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_ST100<span class="token punctuation">,</span>      <span class="token string">"STMicroelectronic ST100 processor"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_TINYJ<span class="token punctuation">,</span>      <span class="token string">"Advanced Logic Corp. Tinyj emb.fam"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_X86_64<span class="token punctuation">,</span>     <span class="token string">"AMD x86-64 architecture"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_PDSP<span class="token punctuation">,</span>       <span class="token string">"Sony DSP Processor"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_FX66<span class="token punctuation">,</span>       <span class="token string">"Siemens FX66 microcontroller"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_ST9PLUS<span class="token punctuation">,</span>    <span class="token string">"STMicroelectronics ST9+ 8/16 mc"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_ST7<span class="token punctuation">,</span>        <span class="token string">"STmicroelectronics ST7 8 bit mc"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_68HC16<span class="token punctuation">,</span>     <span class="token string">"Motorola MC68HC16 microcontroller"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_68HC11<span class="token punctuation">,</span>     <span class="token string">"Motorola MC68HC11 microcontroller"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_68HC08<span class="token punctuation">,</span>     <span class="token string">"Motorola MC68HC08 microcontroller"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_68HC05<span class="token punctuation">,</span>     <span class="token string">"Motorola MC68HC05 microcontroller"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_SVX<span class="token punctuation">,</span>        <span class="token string">"Silicon Graphics SVx"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_ST19<span class="token punctuation">,</span>       <span class="token string">"STMicroelectronics ST19 8 bit mc"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_VAX<span class="token punctuation">,</span>        <span class="token string">"Digital VAX"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_CRIS<span class="token punctuation">,</span>       <span class="token string">"Axis Communications 32-bit embedded processor"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_JAVELIN<span class="token punctuation">,</span>    <span class="token string">"Infineon Technologies 32-bit embedded processor"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_FIREPATH<span class="token punctuation">,</span>   <span class="token string">"Element 14 64-bit DSP Processor"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_ZSP<span class="token punctuation">,</span>        <span class="token string">"LSI Logic 16-bit DSP Processor"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_MMIX<span class="token punctuation">,</span>       <span class="token string">"Donald Knuth's educational 64-bit processor"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_HUANY<span class="token punctuation">,</span>      <span class="token string">"Harvard University machine-independent object files"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_PRISM<span class="token punctuation">,</span>      <span class="token string">"SiTera Prism"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_AVR<span class="token punctuation">,</span>        <span class="token string">"Atmel AVR 8-bit microcontroller"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_FR30<span class="token punctuation">,</span>       <span class="token string">"Fujitsu FR30"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_D10V<span class="token punctuation">,</span>       <span class="token string">"Mitsubishi D10V"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_D30V<span class="token punctuation">,</span>       <span class="token string">"Mitsubishi D30V"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_V850<span class="token punctuation">,</span>       <span class="token string">"NEC v850"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_M32R<span class="token punctuation">,</span>       <span class="token string">"Mitsubishi M32R"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_MN10300<span class="token punctuation">,</span>    <span class="token string">"Matsushita MN10300"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_MN10200<span class="token punctuation">,</span>    <span class="token string">"Matsushita MN10200"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_PJ<span class="token punctuation">,</span>         <span class="token string">"picoJava"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_OPENRISC<span class="token punctuation">,</span>   <span class="token string">"OpenRISC 32-bit embedded processor"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_ARC_A5<span class="token punctuation">,</span>     <span class="token string">"ARC Cores Tangent-A5"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EM_XTENSA<span class="token punctuation">,</span>     <span class="token string">"Tensilica Xtensa Architecture"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> pair_t versionpairs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>  <span class="token punctuation">{</span>    <span class="token punctuation">{</span>EV_NONE<span class="token punctuation">,</span>     <span class="token string">"None"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>EV_CURRENT<span class="token punctuation">,</span>  <span class="token string">"Current version"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> Elf_Ehdr<span class="token operator">*</span> ehdr <span class="token operator">=</span> <span class="token function">get_ehdr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">print_ehdr_ident</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Object file type:                   "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">print_pair</span><span class="token punctuation">(</span>ehdr<span class="token operator">-&gt;</span>e_type<span class="token punctuation">,</span> objtypepairs<span class="token punctuation">,</span> <span class="token function">_countof</span><span class="token punctuation">(</span>objtypepairs<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Machine:                            "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">print_pair</span><span class="token punctuation">(</span>ehdr<span class="token operator">-&gt;</span>e_machine<span class="token punctuation">,</span> machinepairs<span class="token punctuation">,</span> <span class="token function">_countof</span><span class="token punctuation">(</span>machinepairs<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Version:                            "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">print_pair</span><span class="token punctuation">(</span>ehdr<span class="token operator">-&gt;</span>e_version<span class="token punctuation">,</span> versionpairs<span class="token punctuation">,</span> <span class="token function">_countof</span><span class="token punctuation">(</span>versionpairs<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Entry point address:                0x%08x\n"</span><span class="token punctuation">,</span> ehdr<span class="token operator">-&gt;</span>e_entry<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Start of program headers:           0x%08x (bytes into file)\n"</span><span class="token punctuation">,</span> ehdr<span class="token operator">-&gt;</span>e_phoff<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Start of section headers:           0x%08x (bytes into file)\n"</span><span class="token punctuation">,</span> ehdr<span class="token operator">-&gt;</span>e_shoff<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Flags:                              0x%08x\n"</span><span class="token punctuation">,</span> ehdr<span class="token operator">-&gt;</span>e_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Size of this header:                %d (bytes)\n"</span><span class="token punctuation">,</span> ehdr<span class="token operator">-&gt;</span>e_ehsize<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Size of program headers:            %d (bytes)\n"</span><span class="token punctuation">,</span> ehdr<span class="token operator">-&gt;</span>e_phentsize<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Number of program headers:          %d\n"</span><span class="token punctuation">,</span> ehdr<span class="token operator">-&gt;</span>e_phnum<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Size of section headers:            %d (bytes)\n"</span><span class="token punctuation">,</span> ehdr<span class="token operator">-&gt;</span>e_shentsize<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Number of section headers:          %d\n"</span><span class="token punctuation">,</span> ehdr<span class="token operator">-&gt;</span>e_shnum<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Section header string table index:  %d\n\n"</span><span class="token punctuation">,</span> ehdr<span class="token operator">-&gt;</span>e_shstrndx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">print_phdrs</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">const</span> pair_t typepairs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>  <span class="token punctuation">{</span>    <span class="token punctuation">{</span>PT_NULL<span class="token punctuation">,</span>         <span class="token string">"NULL        "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>PT_LOAD<span class="token punctuation">,</span>         <span class="token string">"LOAD        "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>PT_DYNAMIC<span class="token punctuation">,</span>      <span class="token string">"DYNAMIC     "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>PT_INTERP<span class="token punctuation">,</span>       <span class="token string">"INTERP      "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>PT_NOTE<span class="token punctuation">,</span>         <span class="token string">"NOTE        "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>PT_SHLIB<span class="token punctuation">,</span>        <span class="token string">"SHLIB       "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>PT_PHDR<span class="token punctuation">,</span>         <span class="token string">"PHDR        "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>PT_TLS<span class="token punctuation">,</span>          <span class="token string">"TLS         "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>PT_GNU_EH_FRAME<span class="token punctuation">,</span> <span class="token string">"GNU_EH_FRAME"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>PT_GNU_STACK<span class="token punctuation">,</span>    <span class="token string">"GUN_STACK   "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>PT_GNU_RELRO<span class="token punctuation">,</span>    <span class="token string">"GNU_RELRO   "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> Elf_Phdr<span class="token operator">*</span> phdrs <span class="token operator">=</span> <span class="token function">get_phdrs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> i<span class="token punctuation">;</span>  <span class="token keyword">char</span> tmp_buf<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Program Headers:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Type         Offset     VirtAddr   PhysAddr   FileSize   MemSize    Flag Align\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> g_phdr_num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print_pair</span><span class="token punctuation">(</span>phdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p_type<span class="token punctuation">,</span> typepairs<span class="token punctuation">,</span> <span class="token function">_countof</span><span class="token punctuation">(</span>typepairs<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" 0x%08x"</span><span class="token punctuation">,</span> phdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p_offset<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" 0x%08x"</span><span class="token punctuation">,</span> phdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p_vaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" 0x%08x"</span><span class="token punctuation">,</span> phdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p_paddr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" 0x%08x"</span><span class="token punctuation">,</span> phdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p_filesz<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" 0x%08x"</span><span class="token punctuation">,</span> phdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p_memsz<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">snprintf</span><span class="token punctuation">(</span>tmp_buf<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token string">"%s%s%s"</span><span class="token punctuation">,</span>        phdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p_flags <span class="token operator">&amp;</span> PF_X <span class="token operator">?</span> <span class="token string">"X"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>        phdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p_flags <span class="token operator">&amp;</span> PF_W <span class="token operator">?</span> <span class="token string">"W"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>        phdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p_flags <span class="token operator">&amp;</span> PF_R <span class="token operator">?</span> <span class="token string">"R"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" %-4s"</span><span class="token punctuation">,</span> tmp_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" 0x%04x\n"</span><span class="token punctuation">,</span> phdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p_align<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">print_shdrs</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">const</span> pair_t typepairs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>  <span class="token punctuation">{</span>    <span class="token punctuation">{</span>SHT_NULL<span class="token punctuation">,</span>            <span class="token string">"NULL          "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_PROGBITS<span class="token punctuation">,</span>        <span class="token string">"PROGBITS      "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_SYMTAB<span class="token punctuation">,</span>          <span class="token string">"SYMTAB        "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_STRTAB<span class="token punctuation">,</span>          <span class="token string">"STRTAB        "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_RELA<span class="token punctuation">,</span>            <span class="token string">"RELA          "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_HASH<span class="token punctuation">,</span>            <span class="token string">"HASH          "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_DYNAMIC<span class="token punctuation">,</span>         <span class="token string">"DYNAMIC       "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_NOTE<span class="token punctuation">,</span>            <span class="token string">"NOTE          "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_NOBITS<span class="token punctuation">,</span>          <span class="token string">"NOBITS        "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_REL<span class="token punctuation">,</span>             <span class="token string">"REL           "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_SHLIB<span class="token punctuation">,</span>           <span class="token string">"SHLIB         "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_DYNSYM<span class="token punctuation">,</span>          <span class="token string">"DYNSYM        "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_INIT_ARRAY<span class="token punctuation">,</span>      <span class="token string">"INIT_ARRAY    "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_FINI_ARRAY<span class="token punctuation">,</span>      <span class="token string">"FINI_ARRAY    "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_PREINIT_ARRAY<span class="token punctuation">,</span>   <span class="token string">"PREINIT_ARRAY "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_GROUP<span class="token punctuation">,</span>           <span class="token string">"GROUP         "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_SYMTAB_SHNDX<span class="token punctuation">,</span>    <span class="token string">"SYMTAB_SHNDX  "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_GNU_ATTRIBUTES<span class="token punctuation">,</span>  <span class="token string">"GNU_ATTRIBUTES"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_GNU_HASH<span class="token punctuation">,</span>        <span class="token string">"GNU_HASH      "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_GNU_LIBLIST<span class="token punctuation">,</span>     <span class="token string">"GNU_LIBLIST   "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_GNU_verdef<span class="token punctuation">,</span>      <span class="token string">"GNU_verdef    "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_GNU_verneed<span class="token punctuation">,</span>     <span class="token string">"GNU_verneed   "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>SHT_GNU_versym<span class="token punctuation">,</span>      <span class="token string">"GNU_versym    "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> Elf_Shdr<span class="token operator">*</span> shdrs <span class="token operator">=</span> <span class="token function">get_shdrs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> shdr_str_tab <span class="token operator">=</span> <span class="token function">get_shdr_str_tab</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> i<span class="token punctuation">;</span>  <span class="token keyword">char</span> tmp_buf<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Section Headers:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Idx Name               Type           Flags VirtAddr   Offset     Size       Link Info Align  EntrySize\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> g_shdr_num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" %- 3d "</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" %-18s "</span><span class="token punctuation">,</span> shdr_str_tab <span class="token operator">+</span> shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print_pair</span><span class="token punctuation">(</span>shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_type<span class="token punctuation">,</span> typepairs<span class="token punctuation">,</span> <span class="token function">_countof</span><span class="token punctuation">(</span>typepairs<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">snprintf</span><span class="token punctuation">(</span>tmp_buf<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token string">" %s%s%s%s%s%s%s%s%s%s"</span><span class="token punctuation">,</span>        shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_flags <span class="token operator">&amp;</span> SHF_WRITE             <span class="token operator">?</span> <span class="token string">"W"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>        shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_flags <span class="token operator">&amp;</span> SHF_ALLOC             <span class="token operator">?</span> <span class="token string">"A"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>        shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_flags <span class="token operator">&amp;</span> SHF_EXECINSTR         <span class="token operator">?</span> <span class="token string">"E"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>        shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_flags <span class="token operator">&amp;</span> SHF_MERGE             <span class="token operator">?</span> <span class="token string">"M"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>        shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_flags <span class="token operator">&amp;</span> SHF_STRINGS           <span class="token operator">?</span> <span class="token string">"S"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>        shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_flags <span class="token operator">&amp;</span> SHF_INFO_LINK         <span class="token operator">?</span> <span class="token string">"I"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>        shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_flags <span class="token operator">&amp;</span> SHF_LINK_ORDER        <span class="token operator">?</span> <span class="token string">"L"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>        shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_flags <span class="token operator">&amp;</span> SHF_OS_NONCONFORMING  <span class="token operator">?</span> <span class="token string">"O"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>        shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_flags <span class="token operator">&amp;</span> SHF_GROUP             <span class="token operator">?</span> <span class="token string">"G"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>        shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_flags <span class="token operator">&amp;</span> SHF_TLS               <span class="token operator">?</span> <span class="token string">"T"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%-5s "</span><span class="token punctuation">,</span> tmp_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" 0x%08x"</span><span class="token punctuation">,</span> shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" 0x%08x"</span><span class="token punctuation">,</span> shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_offset<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" 0x%08x"</span><span class="token punctuation">,</span> shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%- 4d "</span><span class="token punctuation">,</span> shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_link<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%- 4d "</span><span class="token punctuation">,</span> shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_info<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" 0x%04x"</span><span class="token punctuation">,</span> shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_addralign<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" 0x%08x\n"</span><span class="token punctuation">,</span> shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_entsize<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Key to Flags:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  W (Writable), A (Alloc), E(Executable), M (Merge), S (Strings),\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  I (Info), L (Link Order), O (Os Nonconforming), G (Group), T (TLS)\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">print_symbol_info_by_sect_idx</span><span class="token punctuation">(</span><span class="token keyword">int</span> sect_idx<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">const</span> pair_t typepairs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>  <span class="token punctuation">{</span>    <span class="token punctuation">{</span>STT_NOTYPE<span class="token punctuation">,</span>    <span class="token string">"NOTYPE   "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>STT_OBJECT<span class="token punctuation">,</span>    <span class="token string">"OBJECT   "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>STT_FUNC<span class="token punctuation">,</span>      <span class="token string">"FUNC     "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>STT_SECTION<span class="token punctuation">,</span>   <span class="token string">"SECTION  "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>STT_FILE<span class="token punctuation">,</span>      <span class="token string">"FILE     "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>STT_COMMON<span class="token punctuation">,</span>    <span class="token string">"COMMON   "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>STT_TLS<span class="token punctuation">,</span>       <span class="token string">"TLS      "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>STT_GNU_IFUNC<span class="token punctuation">,</span> <span class="token string">"GUN_IFUNC"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> pair_t bindpairs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>  <span class="token punctuation">{</span>    <span class="token punctuation">{</span>STB_LOCAL<span class="token punctuation">,</span>       <span class="token string">"LOCAL     "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>STB_GLOBAL<span class="token punctuation">,</span>      <span class="token string">"GLOBAL    "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>STB_WEAK<span class="token punctuation">,</span>        <span class="token string">"WEAK      "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>STB_GNU_UNIQUE<span class="token punctuation">,</span>  <span class="token string">"GUN_UNIQUE"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> pair_t visiblepairs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>  <span class="token punctuation">{</span>    <span class="token punctuation">{</span>STV_DEFAULT<span class="token punctuation">,</span>   <span class="token string">"DEFAULT   "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>STV_INTERNAL<span class="token punctuation">,</span>  <span class="token string">"INTERNAL  "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>STV_HIDDEN<span class="token punctuation">,</span>    <span class="token string">"HIDDEN    "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>STV_PROTECTED<span class="token punctuation">,</span> <span class="token string">"PROTECTED "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> Elf_Shdr<span class="token operator">*</span> shdrs <span class="token operator">=</span> <span class="token function">get_shdrs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> shdr_str_tab <span class="token operator">=</span> <span class="token function">get_shdr_str_tab</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Elf_Sym<span class="token operator">*</span> symbol <span class="token operator">=</span> <span class="token punctuation">(</span>Elf_Sym <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">get_sect_cont_by_idx</span><span class="token punctuation">(</span>sect_idx<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> symbol_num <span class="token operator">=</span> shdrs<span class="token punctuation">[</span>sect_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_size <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Elf_Sym<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">char</span><span class="token operator">*</span> symbol_str_tab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">get_sect_cont_by_idx</span><span class="token punctuation">(</span>shdrs<span class="token punctuation">[</span>sect_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_link<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>symbol <span class="token operator">==</span> <span class="token constant">NULL</span>    <span class="token operator">||</span> symbol_str_tab <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">safe_free</span><span class="token punctuation">(</span>symbol<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">safe_free</span><span class="token punctuation">(</span>symbol_str_tab<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Symbol Info For '%s':\n"</span><span class="token punctuation">,</span> shdrs<span class="token punctuation">[</span>sect_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_name <span class="token operator">+</span> shdr_str_tab<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Idx Value      Size   Type      Bind       Visibility Shndx  Name\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> symbol_num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  %3d"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" 0x%08x"</span><span class="token punctuation">,</span> symbol<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>st_value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" 0x%04x "</span><span class="token punctuation">,</span> symbol<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>st_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print_pair</span><span class="token punctuation">(</span><span class="token function">ELF_ST_TYPE</span><span class="token punctuation">(</span>symbol<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>st_info<span class="token punctuation">)</span><span class="token punctuation">,</span> typepairs<span class="token punctuation">,</span> <span class="token function">_countof</span><span class="token punctuation">(</span>typepairs<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print_pair</span><span class="token punctuation">(</span><span class="token function">ELF_ST_BIND</span><span class="token punctuation">(</span>symbol<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>st_info<span class="token punctuation">)</span><span class="token punctuation">,</span> bindpairs<span class="token punctuation">,</span> <span class="token function">_countof</span><span class="token punctuation">(</span>bindpairs<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">print_pair</span><span class="token punctuation">(</span><span class="token function">ELF_ST_VISIBILITY</span><span class="token punctuation">(</span>symbol<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>st_other<span class="token punctuation">)</span><span class="token punctuation">,</span> visiblepairs<span class="token punctuation">,</span> <span class="token function">_countof</span><span class="token punctuation">(</span>visiblepairs<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>symbol<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>st_shndx<span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token keyword">case</span> SHN_UNDEF<span class="token operator">:</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"UNDEF "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token keyword">case</span> SHN_ABS<span class="token operator">:</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ABS   "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token keyword">case</span> SHN_COMMON<span class="token operator">:</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"COMMON"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token keyword">default</span><span class="token operator">:</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%-6d"</span><span class="token punctuation">,</span> symbol<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>st_shndx<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" %s\n"</span><span class="token punctuation">,</span> symbol<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>st_name <span class="token operator">+</span> symbol_str_tab<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">safe_free</span><span class="token punctuation">(</span>symbol<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">safe_free</span><span class="token punctuation">(</span>symbol_str_tab<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">print_symbol_info</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">const</span> Elf_Shdr<span class="token operator">*</span> shdrs <span class="token operator">=</span> <span class="token function">get_shdrs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Symbol Info:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> g_shdr_num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_type <span class="token operator">==</span> SHT_SYMTAB      <span class="token operator">||</span> shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_type <span class="token operator">==</span> SHT_DYNSYM<span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token function">print_symbol_info_by_sect_idx</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">print_relocation_info</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">const</span> Elf_Shdr<span class="token operator">*</span> shdrs <span class="token operator">=</span> <span class="token function">get_shdrs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> shdr_str_tab <span class="token operator">=</span> <span class="token function">get_shdr_str_tab</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Elf_Rel<span class="token operator">*</span> rel <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> rel_num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  Elf_Sym<span class="token operator">*</span> sym <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token keyword">char</span><span class="token operator">*</span> sym_str_tab <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Relocation Info:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> g_shdr_num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_type <span class="token operator">==</span> SHT_REL<span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Relocation Info Without Addends For '%s':\n"</span><span class="token punctuation">,</span>          shdrs<span class="token punctuation">[</span>shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_info<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_name <span class="token operator">+</span> shdr_str_tab<span class="token punctuation">)</span><span class="token punctuation">;</span>      rel_num <span class="token operator">=</span> shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_size <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Elf_Rel<span class="token punctuation">)</span><span class="token punctuation">;</span>      rel <span class="token operator">=</span> <span class="token punctuation">(</span>Elf_Rel <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">get_sect_cont_by_idx</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>      sym <span class="token operator">=</span> <span class="token punctuation">(</span>Elf_Sym <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">get_sect_cont_by_idx</span><span class="token punctuation">(</span>shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_link<span class="token punctuation">)</span><span class="token punctuation">;</span>      sym_str_tab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">get_sect_cont_by_idx</span><span class="token punctuation">(</span>shdrs<span class="token punctuation">[</span>shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_link<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_link<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  OFFSET     TYPE       VALUE\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> rel_num<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>      <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  0x%08x"</span><span class="token punctuation">,</span> rel<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>r_offset<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" 0x%08x"</span><span class="token punctuation">,</span> <span class="token function">ELF_R_TYPE</span><span class="token punctuation">(</span>rel<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>r_info<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" %s\n"</span><span class="token punctuation">,</span> sym<span class="token punctuation">[</span><span class="token function">ELF_R_SYM</span><span class="token punctuation">(</span>rel<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>r_info<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>st_name <span class="token operator">+</span> sym_str_tab<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token function">safe_free</span><span class="token punctuation">(</span>rel<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">safe_free</span><span class="token punctuation">(</span>sym<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">safe_free</span><span class="token punctuation">(</span>sym_str_tab<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">print_all_str_tab</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">const</span> Elf_Shdr<span class="token operator">*</span> shdrs <span class="token operator">=</span> <span class="token function">get_shdrs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> shdr_str_tab <span class="token operator">=</span> <span class="token function">get_shdr_str_tab</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">char</span><span class="token operator">*</span> str_tab <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> str_tab_pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"All String Table:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> g_shdr_num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_type <span class="token operator">==</span> SHT_STRTAB<span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"String Table '%s':\n"</span><span class="token punctuation">,</span> shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_name <span class="token operator">+</span> shdr_str_tab<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  Idx Value\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      str_tab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">get_sect_cont_by_idx</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> str_tab_pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> str_tab_pos <span class="token operator">&lt;</span> shdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_size<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>      <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  %3d %s\n"</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> str_tab <span class="token operator">+</span> str_tab_pos<span class="token punctuation">)</span><span class="token punctuation">;</span>        str_tab_pos <span class="token operator">+=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str_tab <span class="token operator">+</span> str_tab_pos<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token function">safe_free</span><span class="token punctuation">(</span>str_tab<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">print_usage</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Usage: %s file\n"</span><span class="token punctuation">,</span> g_selfname<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">" -a  same as -h -p -s -S -r -d\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">" -h  dump ELF file header\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">" -p  dump ELF file program header\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">" -s  dump ELF file section header\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">" -S  dump Symbol Info\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">" -r  dump relocation info\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">" -d  dump all string table\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">" -v  print version info and exit\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">print_version</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Elf(Executable Linkable Format) file dump tool("</span>ARCH<span class="token string">")\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Copyright (c) 2013 Kiba Amor &lt;KibaAmor@gmai.com&gt;\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"All rights reserved.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Version 1.0\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> show_ehdr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> show_phdrs <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> show_shdrs <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> show_symbol_info <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> show_relocation_info <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> show_all_str_tab <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  g_selfname <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'-'</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>g_filename <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"multi input file detected\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> EXIT_FAILURE<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">else</span>      <span class="token punctuation">{</span>        g_filename <span class="token operator">=</span> argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">continue</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">strlen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token keyword">switch</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span>        <span class="token keyword">case</span> <span class="token string">'a'</span><span class="token operator">:</span>          show_ehdr <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          show_phdrs <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          show_shdrs <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          show_symbol_info <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          show_relocation_info <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          show_all_str_tab <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'h'</span><span class="token operator">:</span>          show_ehdr <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'p'</span><span class="token operator">:</span>          show_phdrs <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'s'</span><span class="token operator">:</span>          show_shdrs <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'S'</span><span class="token operator">:</span>          show_symbol_info <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'r'</span><span class="token operator">:</span>          show_relocation_info <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'d'</span><span class="token operator">:</span>          show_all_str_tab <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'v'</span><span class="token operator">:</span>          <span class="token function">print_version</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> EXIT_FAILURE<span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token operator">:</span>          <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"unkown option: '%c'\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> EXIT_FAILURE<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>g_filename <span class="token operator">==</span> <span class="token constant">NULL</span>      <span class="token operator">||</span> <span class="token punctuation">(</span>show_ehdr <span class="token operator">==</span> <span class="token number">0</span>      <span class="token operator">&amp;&amp;</span> show_phdrs <span class="token operator">==</span> <span class="token number">0</span>      <span class="token operator">&amp;&amp;</span> show_shdrs <span class="token operator">==</span> <span class="token number">0</span>      <span class="token operator">&amp;&amp;</span> show_symbol_info <span class="token operator">==</span> <span class="token number">0</span>      <span class="token operator">&amp;&amp;</span> show_relocation_info <span class="token operator">==</span> <span class="token number">0</span>      <span class="token operator">&amp;&amp;</span> show_all_str_tab <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">print_usage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> EXIT_FAILURE<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">atexit</span><span class="token punctuation">(</span>clean_up<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>show_ehdr<span class="token punctuation">)</span>    <span class="token function">print_ehdr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>show_phdrs<span class="token punctuation">)</span>    <span class="token function">print_phdrs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>show_shdrs<span class="token punctuation">)</span>    <span class="token function">print_shdrs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>show_symbol_info<span class="token punctuation">)</span>    <span class="token function">print_symbol_info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>show_relocation_info<span class="token punctuation">)</span>    <span class="token function">print_relocation_info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>show_all_str_tab<span class="token punctuation">)</span>    <span class="token function">print_all_str_tab</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> EXIT_SUCCESS<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> 逆向工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用socat来测试echo服务器和客户端</title>
      <link href="li-yong-socat-lai-ce-shi-echo-fu-wu-qi-he-ke-hu-duan/"/>
      <url>li-yong-socat-lai-ce-shi-echo-fu-wu-qi-he-ke-hu-duan/</url>
      
        <content type="html"><![CDATA[<h2 id="用socat开启echo服务器"><a href="#用socat开启echo服务器" class="headerlink" title="用socat开启echo服务器"></a>用socat开启echo服务器</h2><p>在本地9999端口开启一个echo服务器</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">socat tcp-listen:8888 <span class="token builtin class-name">echo</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="用socat测试echo服务器"><a href="#用socat测试echo服务器" class="headerlink" title="用socat测试echo服务器"></a>用socat测试echo服务器</h2><p>把文件in.dat中内容发送到本地的8888端口，并将接收到的数据存放在out中。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">socat tcp:127.0.0.1:8888 open:in.dat,rdonly<span class="token operator">!</span><span class="token operator">!</span>open:out.dat,create,wronly<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>可用于对echo服务器进行数据压力测试。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具使用 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
