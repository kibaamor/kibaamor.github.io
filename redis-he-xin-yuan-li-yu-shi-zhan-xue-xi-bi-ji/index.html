<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <meta name="keywords" content="《Redis 核心原理与实战》学习笔记, kiba, zen, amor, kibazen, kibaamor, 木叶, 木叶禅">
    <meta name="description" content="You are too concerned with what was and what will be">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>《Redis 核心原理与实战》学习笔记 | 木叶禅</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/css/my.css">

    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="木叶禅" type="application/atom+xml">
</head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">木叶禅</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/learn/" class="waves-effect waves-light">
      
      <i class="fas fa-book" style="zoom: 0.6;"></i>
      
      <span>Learn</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/memo/" class="waves-effect waves-light">
      
      <i class="fas fa-sticky-note" style="zoom: 0.6;"></i>
      
      <span>Memo</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories/" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags/" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about/" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">木叶禅</div>
        <div class="logo-desc">
            
            You are too concerned with what was and what will be
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/learn/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-book"></i>
			
			Learn
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/memo/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-sticky-note"></i>
			
			Memo
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    
<script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = 'f65e070788a2647953051a7a1b70ada7fd2b3f70cd4d93c977207f5b762987d4';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/18.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">《Redis 核心原理与实战》学习笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Redis/">
                                <span class="chip bg-color">Redis</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                学习笔记
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2025-06-29
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2025-06-30
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    23.7k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    91 分
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="01-Redis-是如何执行的"><a href="#01-Redis-是如何执行的" class="headerlink" title="01 Redis 是如何执行的"></a>01 Redis 是如何执行的</h2><h3 id="命令执行流程"><a href="#命令执行流程" class="headerlink" title="命令执行流程"></a>命令执行流程</h3><p>一条命令的执行过程有很多细节，但大体可分为：客户端先将用户输入的命令，转化为 Redis 相关的通讯协议，再用 socket 连接的方式将内容发送给服务器端，服务器端在接收到相关内容之后，先将内容转化为具体的执行命令，再判断用户授权信息和其他相关信息，当验证通过之后会执行最终命令，命令执行完之后，会进行相关的信息记录和数据统计，然后再把执行结果发送给客户端，这样一条命令的执行流程就结束了。如果是集群模式的话，主节点还会将命令同步至子节点，下面我们一起来看更加具体的执行流程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/Redis命令大体执行流程图.png" alt="Redis命令大体执行流程图"></p>
<h4 id="步骤一：用户输入一条命令"><a href="#步骤一：用户输入一条命令" class="headerlink" title="步骤一：用户输入一条命令"></a>步骤一：用户输入一条命令</h4><h4 id="步骤二：客户端先将命令转换成-Redis-协议，然后再通过-socket-连接发送给服务器端"><a href="#步骤二：客户端先将命令转换成-Redis-协议，然后再通过-socket-连接发送给服务器端" class="headerlink" title="步骤二：客户端先将命令转换成 Redis 协议，然后再通过 socket 连接发送给服务器端"></a>步骤二：客户端先将命令转换成 Redis 协议，然后再通过 socket 连接发送给服务器端</h4><p>客户端和服务器端是基于 socket 通信的，服务器端在初始化时会创建了一个 socket 监听，用于监测链接客户端的 socket 链接，源码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">initServer</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//......</span>
    <span class="token comment">// 开启 Socket 事件监听</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>port <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>
        <span class="token function">listenToPort</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>port<span class="token punctuation">,</span>server<span class="token punctuation">.</span>ipfd<span class="token punctuation">,</span><span class="token operator">&amp;</span>server<span class="token punctuation">.</span>ipfd_count<span class="token punctuation">)</span> <span class="token operator">==</span> C_ERR<span class="token punctuation">)</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//......</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>socket 小知识：每个 socket 被创建后，会分配两个缓冲区，输入缓冲区和输出缓冲区。 写入函数并不会立即向网络中传输数据，而是先将数据写入缓冲区中，再由 TCP 协议将数据从缓冲区发送到目标机器。一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是 TCP 协议负责的事情。 注意：数据有可能刚被写入缓冲区就发送到网络，也可能在缓冲区中不断积压，多次写入的数据被一次性发送到网络，这取决于当时的网络情况、当前线程是否空闲等诸多因素，不由程序员控制。 读取函数也是如此，它也是从输入缓冲区中读取数据，而不是直接从网络中读取。</p>
</blockquote>
<p>当 socket 成功连接之后，客户端会先把命令转换成 Redis 通讯协议（RESP 协议，REdis Serialization Protocol）发送给服务器端，这个通信协议是为了保障服务器能最快速的理解命令的含义而制定的，如果没有这个通讯协议，那么 Redis 服务器端要遍历所有的空格以确认此条命令的含义，这样会加大服务器的运算量，而直接发送通讯协议，相当于把服务器端的解析工作交给了每一个客户端，这样会很大程度的提高 Redis 的运行速度。例如，当我们输入 <code>set key val</code> 命令时，客户端会把这个命令转换为 <code>*3\r\n$3\r\nSET\r\n$4\r\nKEY\r\n$4\r\nVAL\r\n</code> 协议发送给服务器端。 更多通讯协议，可访问官方文档：<a target="_blank" rel="noopener" href="https://redis.io/topics/protocol">https://redis.io/topics/protocol</a></p>
<h5 id="扩展知识：I-O-多路复用"><a href="#扩展知识：I-O-多路复用" class="headerlink" title="扩展知识：I/O 多路复用"></a>扩展知识：I/O 多路复用</h5><p>Redis 使用的是 I/O 多路复用功能来监听多 socket 链接的，这样就可以使用一个线程链接来处理多个请求，减少线程切换带来的开销，同时也避免了 I/O 阻塞操作，从而大大提高了 Redis 的运行效率。</p>
<p>I/O 多路复用机制如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/IO多路复用机制.png" alt="IO多路复用机制"></p>
<p>综合来说，此步骤的执行流程如下：</p>
<ul>
<li>与服务器端以 socket 和 I/O 多路复用的技术建立链接；</li>
<li>将命令转换为 Redis 通讯协议，再将这些协议发送至缓冲区。</li>
</ul>
<h4 id="步骤三：服务器端接收到命令"><a href="#步骤三：服务器端接收到命令" class="headerlink" title="步骤三：服务器端接收到命令"></a>步骤三：服务器端接收到命令</h4><p>服务器会先去输入缓冲中读取数据，然后判断数据的大小是否超过了系统设置的值(默认是 1GB)，如果大于此值就会返回错误信息，并关闭客户端连接。 默认大小如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/Redis默认数据大小.png" alt="Redis默认数据大小"></p>
<p>当数据大小验证通过之后，服务器端会对输入缓冲区中的请求命令进行分析，提取命令请求中包含的命令参数，存储在 client 对象(服务器端会为每个链接创建一个 Client 对象)的属性中。</p>
<h4 id="步骤四：执行前准备"><a href="#步骤四：执行前准备" class="headerlink" title="步骤四：执行前准备"></a>步骤四：执行前准备</h4><ol>
<li>判断是否为退出命令，如果是则直接返回；</li>
<li>非 null 判断，检查 client 对象是否为 null，如果是返回错误信息；</li>
<li>获取执行命令，根据 client 对象存储的属性信息去 redisCommand 结构中查询执行命令；</li>
<li>用户权限效验，未通过身份验证的客户端只能执行 AUTH(授权) 命令，未通过身份验证的客户端执行了 AUTH 之外的命令则返回错误信息；</li>
<li>集群相关操作，如果是集群模式，把命令重定向到目标节点，如果是 master(主节点) 则不需要重定向；</li>
<li>检查服务器端最大内存限制，如果服务器端开启了最大内存限制，会先检查内存大小，如果内存超过了最大值会对内存进行回收操作；</li>
<li>持久化检测，检查服务器是否开启了持久化和持久化出错停止写入配置，如果开启了此配置并且有持久化失败的情况，禁止执行写命令；</li>
<li>集群模式最少从节点(slave)验证，如果是集群模式并且配置了 <code>repl*min*slaves*to*write</code> (最小从节点写入)，当从节点的数量少于配置项时，禁止执行写命令；</li>
<li>只读从节点验证，当此服务器为只读从节点时，只接受 master 的写命令；</li>
<li>客户端订阅判断，当客户端正在订阅频道时，只会执行部分命令（只会执行 SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE、PUNSUBSCRIBE，其他命令都会被拒绝）。</li>
<li>从节点状态效验，当服务器为 slave 并且没有连接 master 时，只会执行状态查询相关的命令，如 info 等；</li>
<li>服务器初始化效验，当服务器正在启动时，只会执行 loading 标志的命令，其他的命令都会被拒绝；</li>
<li>lua 脚本阻塞效验，当服务器因为执行 lua 脚本阻塞时，只会执行部分命令；</li>
<li>事务命令效验，如果执行的是事务命令，则开启事务把命令放入等待队列；</li>
<li>监视器 (monitor) 判断，如果服务器打开了监视器功能，那么服务器也会把执行命令和相关参数发送给监视器 (监视器是用于监控服务器运行状态的)。</li>
</ol>
<p>当服务器经过以上操作之后，就可以执行真正的操作命令了。</p>
<h4 id="步骤五：执行最终命令，调用-redisCommand-中的-proc-函数执行命令。"><a href="#步骤五：执行最终命令，调用-redisCommand-中的-proc-函数执行命令。" class="headerlink" title="步骤五：执行最终命令，调用 redisCommand 中的 proc 函数执行命令。"></a>步骤五：执行最终命令，调用 redisCommand 中的 proc 函数执行命令。</h4><h4 id="步骤六：执行完后相关记录和统计"><a href="#步骤六：执行完后相关记录和统计" class="headerlink" title="步骤六：执行完后相关记录和统计"></a>步骤六：执行完后相关记录和统计</h4><ol>
<li>检查慢查询是否开启，如果开启会记录慢查询日志；</li>
<li>检查统计信息是否开启，如果开启会记录一些统计信息，例如执行命令所耗费时长和计数器(calls)加1；</li>
<li>检查持久化功能是否开启，如果开启则会记录持久化信息；</li>
<li>如果有其它从服务器正在复制当前服务器，则会将刚刚执行的命令传播给其他从服务器。</li>
</ol>
<h4 id="步骤七：返回结果给客户端"><a href="#步骤七：返回结果给客户端" class="headerlink" title="步骤七：返回结果给客户端"></a>步骤七：返回结果给客户端</h4><p>命令执行完之后，服务器会通过 socket 的方式把执行结果发送给客户端，客户端再把结果展示给用户，至此一条命令的执行就结束了。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>当用户输入一条命令之后，客户端会以 socket 的方式把数据转换成 Redis 协议，并发送至服务器端，服务器端在接受到数据之后，会先将协议转换为真正的执行命令，在经过各种验证以保证命令能够正确并安全的执行，但验证处理完之后，会调用具体的方法执行此条命令，执行完成之后会进行相关的统计和记录，然后再把执行结果返回给客户端，整个执行流程，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/Redis命令执行流程小结.png" alt="Redis命令执行流程小结"></p>
<h2 id="03-Redis-持久化——RDB"><a href="#03-Redis-持久化——RDB" class="headerlink" title="03 Redis 持久化——RDB"></a>03 Redis 持久化——RDB</h2><p>Redis 的读写都是在内存中，所以它的性能较高，但在内存中的数据会随着服务器的重启而丢失，为了保证数据不丢失，我们需要将内存中的数据存储到磁盘，以便 Redis 重启时能够从磁盘中恢复原有的数据，而整个过程就叫做 Redis 持久化。</p>
<p>Redis 持久化也是 Redis 和 Memcached 的主要区别之一，因为 Memcached 不具备持久化功能。</p>
<h3 id="持久化的几种方式"><a href="#持久化的几种方式" class="headerlink" title="持久化的几种方式"></a>持久化的几种方式</h3><p>Redis 持久化拥有以下三种方式：</p>
<ul>
<li>快照方式（RDB, Redis DataBase）将某一个时刻的内存数据，以二进制的方式写入磁盘；</li>
<li>文件追加方式（AOF, Append Only File），记录所有的操作命令，并以文本的形式追加到文件中；</li>
<li>混合持久化方式，Redis 4.0 之后新增的方式，混合持久化是结合了 RDB 和 AOF 的优点，在写入的时候，先把当前的数据以 RDB 的形式写入文件的开头，再将后续的操作命令以 AOF 的格式存入文件，这样既能保证 Redis 重启时的速度，又能减低数据丢失的风险。</li>
</ul>
<h3 id="RDB简介"><a href="#RDB简介" class="headerlink" title="RDB简介"></a>RDB简介</h3><p>RDB（Redis DataBase）是将某一个时刻的内存快照（Snapshot），以二进制的方式写入磁盘的过程。</p>
<h3 id="持久化触发"><a href="#持久化触发" class="headerlink" title="持久化触发"></a>持久化触发</h3><p>RDB 的持久化触发方式有两类：一类是手动触发，另一类是自动触发。</p>
<h4 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h4><p>手动触发持久化的操作有两个： <code>save</code> 和 <code>bgsave</code> ，它们主要区别体现在：是否阻塞 Redis 主线程的执行。</p>
<p>在客户端中执行 <code>save</code> 命令，就会触发 Redis 的持久化，但同时也是使 Redis 处于阻塞状态，直到 RDB 持久化完成，才会响应其他客户端发来的命令，所以<strong>在生产环境一定要慎用。</strong></p>
<p><code>bgsave</code> （background save）既后台保存的意思， 它和 <code>save</code> 命令最大的区别就是 <code>bgsave</code> 会 <code>fork()</code> 一个子进程来执行持久化，整个过程中只有在 <code>fork()</code> 子进程时有短暂的阻塞，当子进程被创建之后，Redis 的主进程就可以响应其他客户端的请求了，相对于整个流程都阻塞的 <code>save</code> 命令来说，显然 <code>bgsave</code> 命令更适合我们使用。</p>
<h4 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h4><p>说完了 RDB 的手动触发方式，下面来看如何自动触发 RDB 持久化？ RDB 自动持久化主要来源于以下几种情况。</p>
<ol>
<li><p><code>save m n</code></p>
<p> <code>save m n</code> 是指在 <code>m</code> 秒内，如果有 <code>n</code> 个键发生改变，则自动触发持久化。 参数 <code>m</code> 和 <code>n</code> 可以在 Redis 的配置文件中找到，例如，<code>save 60 1</code> 则表明在 60 秒内，至少有一个键发生改变，就会触发 RDB 持久化。 自动触发持久化，本质是 Redis 通过判断，如果满足设置的触发条件，自动执行一次 <code>bgsave</code> 命令。 注意：当设置多个 <code>save m n</code> 命令时，满足任意一个条件都会触发持久化。 例如，我们设置了以下两个 <code>save m n</code> 命令：</p>
<ul>
<li><code>save 60 10</code></li>
<li><p><code>save 600 1</code></p>
<p>当 60s 内如果有 10 次 Redis 键值发生改变，就会触发持久化；如果 60s 内 Redis 的键值改变次数少于 10 次，那么 Redis 就会判断 600s 内，Redis 的键值是否至少被修改了一次，如果满足则会触发持久化。</p>
</li>
</ul>
</li>
<li><p><code>flushall</code></p>
<p> <code>flushall</code> 命令用于清空 Redis 数据库，在生产环境下一定慎用，当 Redis 执行了 <code>flushall</code> 命令之后，则会触发自动持久化，把 RDB 文件清空。</p>
</li>
<li><p>主从同步触发</p>
<p> 在 Redis 主从复制中，当从节点执行全量复制操作时，主节点会执行 <code>bgsave</code> 命令，并将 RDB 文件发送给从节点，该过程会自动触发 Redis 持久化。</p>
</li>
</ol>
<h3 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h3><p>RDB 配置参数可以在 Redis 的配置文件中找见，具体内容如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text"># RDB 保存的条件
save 900 1
save 300 10
save 60 10000

# bgsave 失败之后，是否停止持久化数据到磁盘，yes 表示停止持久化，no 表示忽略错误继续写文件。
stop-writes-on-bgsave-error yes

# RDB 文件压缩
rdbcompression yes

# 写入文件和读取文件时是否开启 RDB 文件检查，检查是否有无损坏，如果在启动是检查发现损坏，则停止启动。
rdbchecksum yes

# RDB 文件名
dbfilename dump.rdb

# RDB 文件目录
dir ./<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中比较重要的参数如下列表： </p>
<ol>
<li><p>save 参数</p>
<p> 它是用来配置触发 RDB 持久化条件的参数，满足保存条件时将会把数据持久化到硬盘。 默认配置说明如下：</p>
<ul>
<li><code>save 900 1</code>：表示 900 秒内如果至少有 1 个 key 值变化，则把数据持久化到硬盘；</li>
<li><code>save 300 10</code>：表示 300 秒内如果至少有 10 个 key 值变化，则把数据持久化到硬盘；</li>
<li><code>save 60 10000</code>：表示 60 秒内如果至少有 10000 个 key 值变化，则把数据持久化到硬盘。</li>
</ul>
</li>
<li><p>rdbcompression 参数</p>
<p> 它的默认值是 yes 表示开启 RDB 文件压缩，Redis 会采用 LZF 算法进行压缩。如果不想消耗 CPU 性能来进行文件压缩的话，可以设置为关闭此功能，这样的缺点是需要更多的磁盘空间来保存文件。</p>
</li>
<li><p>rdbchecksum 参数</p>
<p> 它的默认值为 yes 表示写入文件和读取文件时是否开启 RDB 文件检查，检查是否有无损坏，如果在启动是检查发现损坏，则停止启动。</p>
</li>
</ol>
<h3 id="配置查询"><a href="#配置查询" class="headerlink" title="配置查询"></a>配置查询</h3><p>Redis 中可以使用命令查询当前配置参数。查询命令的格式为：<code>config get xxx</code> ，例如，想要获取 RDB 文件的存储名称设置，可以使用 <code>config get dbfilename</code>。</p>
<p>查询 RDB 的文件目录，可使用命令 <code>config get dir</code>。</p>
<h3 id="配置设置"><a href="#配置设置" class="headerlink" title="配置设置"></a>配置设置</h3><p>设置 RDB 的配置，可以通过以下两种方式：</p>
<ul>
<li>手动修改 Redis 配置文件；</li>
<li>使用命令行设置，例如，使用 config set dir “/usr/data” 就是用于修改 RDB 的存储目录。</li>
</ul>
<p>注意：手动修改 Redis 配置文件的方式是全局生效的，即重启 Redis 服务器设置参数也不会丢失，而使用命令修改的方式，在 Redis 重启之后就会丢失。但手动修改 Redis 配置文件，想要立即生效需要重启 Redis 服务器，而命令的方式则不需要重启 Redis 服务器。</p>
<blockquote>
<p>小贴士：Redis 的配置文件位于 Redis 安装目录的根路径下，默认名称为 redis.conf。</p>
</blockquote>
<h3 id="RDB-文件恢复"><a href="#RDB-文件恢复" class="headerlink" title="RDB 文件恢复"></a>RDB 文件恢复</h3><p>当 Redis 服务器启动时，如果 Redis 根目录存在 RDB 文件 dump.rdb，Redis 就会自动加载 RDB 文件恢复持久化数据。<br>如果根目录没有 dump.rdb 文件，请先将 dump.rdb 文件移动到 Redis 的根目录。</p>
<p>验证 RDB 文件是否被加载 Redis 在启动时有日志信息，会显示是否加载了 RDB 文件，我们执行 Redis 启动命令：<code>src/redis-server redis.conf</code> ，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/RDB文件恢复.png" alt="RDB文件恢复"></p>
<p>从日志上可以看出， Redis 服务在启动时已经正常加载了 RDB 文件。</p>
<blockquote>
<p>小贴士：Redis 服务器在载入 RDB 文件期间，会一直处于阻塞状态，直到载入工作完成为止。</p>
</blockquote>
<h3 id="RDB-优缺点"><a href="#RDB-优缺点" class="headerlink" title="RDB 优缺点"></a>RDB 优缺点</h3><h4 id="RDB-优点"><a href="#RDB-优点" class="headerlink" title="RDB 优点"></a>RDB 优点</h4><ul>
<li>RDB 的内容为二进制的数据，占用内存更小，更紧凑，更适合做为备份文件；</li>
<li>RDB 对灾难恢复非常有用，它是一个紧凑的文件，可以更快的传输到远程服务器进行 Redis 服务恢复；</li>
<li>RDB 可以更大程度的提高 Redis 的运行速度，因为每次持久化时 Redis 主进程都会 <code>fork()</code> 一个子进程，进行数据持久化到磁盘，Redis 主进程并不会执行磁盘 I/O 等操作；</li>
<li>与 AOF 格式的文件相比，RDB 文件可以更快的重启。</li>
</ul>
<h4 id="RDB-缺点"><a href="#RDB-缺点" class="headerlink" title="RDB 缺点"></a>RDB 缺点</h4><ul>
<li>因为 RDB 只能保存某个时间间隔的数据，如果中途 Redis 服务被意外终止了，则会丢失一段时间内的 Redis 数据；</li>
<li>RDB 需要经常 <code>fork()</code> 才能使用子进程将其持久化在磁盘上。如果数据集很大，<code>fork()</code> 可能很耗时，并且如果数据集很大且 CPU 性能不佳，则可能导致 Redis 停止为客户端服务几毫秒甚至一秒钟。</li>
</ul>
<h3 id="禁用持久化"><a href="#禁用持久化" class="headerlink" title="禁用持久化"></a>禁用持久化</h3><p>禁用持久化可以提高 Redis 的执行效率，如果对数据丢失不敏感的情况下，可以在连接客户端的情况下，执行 <code>config set save ""</code> 命令即可禁用 Redis 的持久化。</p>
<h3 id="参考-amp-鸣谢"><a href="#参考-amp-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h3><ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/topics/persistence">https://redis.io/topics/persistence</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36318234/article/details/79994133">https://blog.csdn.net/qq_36318234/article/details/79994133</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ysocean/p/9114268.html">https://www.cnblogs.com/ysocean/p/9114268.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wdliu/p/9377278.html">https://www.cnblogs.com/wdliu/p/9377278.html</a></li>
</ul>
<h2 id="04-Redis-持久化——AOF"><a href="#04-Redis-持久化——AOF" class="headerlink" title="04 Redis 持久化——AOF"></a>04 Redis 持久化——AOF</h2><p>使用 RDB 持久化有一个风险，它可能会造成最新数据丢失的风险。因为 RDB 的持久化有一定的时间间隔，在这个时间段内如果 Redis 服务意外终止的话，就会造成最新的数据全部丢失。</p>
<p>可能会操作 Redis 服务意外终止的条件：</p>
<ul>
<li>安装 Redis 的机器停止运行，蓝屏或者系统崩溃；</li>
<li>安装 Redis 的机器出现电源故障，例如突然断电；</li>
<li>使用 <code>kill -9 Redis_PID</code> 等。</li>
</ul>
<p>那么如何解决以上的这些问题呢？Redis 为我们提供了另一种持久化的方案——AOF。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>AOF（Append Only File）中文是附加到文件，顾名思义 AOF 可以把 Redis 每个键值对操作都记录到文件（appendonly.aof）中。</p>
<h3 id="持久化查询和设置"><a href="#持久化查询和设置" class="headerlink" title="持久化查询和设置"></a>持久化查询和设置</h3><h4 id="查询-AOF-启动状态"><a href="#查询-AOF-启动状态" class="headerlink" title="查询 AOF 启动状态"></a>查询 AOF 启动状态</h4><p>使用 <code>config get appendonly</code> 命令，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/查询AOF启动状态.png" alt="查询AOF启动状态"></p>
<p>其中，第一行为 AOF 文件的名称，而最后一行表示 AOF 启动的状态，yes 表示已启动，no 表示未启动。</p>
<h3 id="开启-AOF-持久化"><a href="#开启-AOF-持久化" class="headerlink" title="开启 AOF 持久化"></a>开启 AOF 持久化</h3><h4 id="命令行启动-AOF"><a href="#命令行启动-AOF" class="headerlink" title="命令行启动 AOF"></a>命令行启动 AOF</h4><p>命令行启动 AOF，使用 <code>config set appendonly yes</code> 命令。</p>
<p>命令行启动 AOF 的优缺点：命令行启动优点是无需重启 Redis 服务，缺点是如果 Redis 服务重启，则之前使用命令行设置的配置就会失效。</p>
<h4 id="配置文件启动-AOF"><a href="#配置文件启动-AOF" class="headerlink" title="配置文件启动 AOF"></a>配置文件启动 AOF</h4><p>Redis 的配置文件在它的根路径下的 redis.conf 文件中，获取 Redis 的根目录可以使用命令 <code>config get dir</code> 获取，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/获取Redis的根目录.png" alt="获取Redis的根目录"></p>
<p>只需要在配置文件中设置 <code>appendonly yes</code> 即可，默认 appendonly no 表示关闭 AOF 持久化。</p>
<p>配置文件启动 AOF 的优缺点：修改配置文件的缺点是每次修改配置文件都要重启 Redis 服务才能生效，优点是无论重启多少次 Redis 服务，配置文件中设置的配置信息都不会失效。</p>
<h3 id="触发持久化"><a href="#触发持久化" class="headerlink" title="触发持久化"></a>触发持久化</h3><p>AOF 持久化开启之后，只要满足一定条件，就会触发 AOF 持久化。AOF 的触发条件分为两种：自动触发和手动触发。</p>
<h4 id="自动触发-1"><a href="#自动触发-1" class="headerlink" title="自动触发"></a>自动触发</h4><p>有两种情况可以自动触发 AOF 持久化，分为是：</p>
<ol>
<li>满足 AOF 设置的策略触发</li>
<li>满足 AOF 重写触发条件</li>
</ol>
<p>其中，AOF 重写触发会在本文的后半部分详细介绍，这里重点来说 AOF 持久化策略都有哪些。 AOF 持久化策略，分为以下三种：</p>
<ul>
<li>always：每条 Redis 操作命令都会写入磁盘，最多丢失一条数据；</li>
<li>everysec：每秒钟写入一次磁盘，最多丢失一秒的数据；</li>
<li>no：不设置写入磁盘的规则，根据当前操作系统来决定何时写入磁盘，Linux 默认 30s 写入一次数据至磁盘。</li>
</ul>
<p>这三种配置可以在 Redis 的配置文件（redis.conf）中设置，如下代码所示：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text"># 开启每秒写入一次的持久化策略
appendfsync everysec<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<blockquote>
<p>小贴士：因为每次写入磁盘都会对 Redis 的性能造成一定的影响，所以要根据用户的实际情况设置相应的策略，一般设置每秒写入一次磁盘的频率就可以满足大部分的使用场景了。</p>
</blockquote>
<h4 id="手动触发-1"><a href="#手动触发-1" class="headerlink" title="手动触发"></a>手动触发</h4><p>在客户端执行 <code>bgrewriteaof</code> 命令就可以手动触发 AOF 持久化。</p>
<h3 id="AOF-文件重写"><a href="#AOF-文件重写" class="headerlink" title="AOF 文件重写"></a>AOF 文件重写</h3><p>AOF 是通过记录 Redis 的执行命令来持久化（保存）数据的，所以随着时间的流逝 AOF 文件会越来越多，这样不仅增加了服务器的存储压力，也会造成 Redis 重启速度变慢，为了解决这个问题 Redis 提供了 AOF 重写的功能。</p>
<h4 id="什么是-AOF-重写？"><a href="#什么是-AOF-重写？" class="headerlink" title="什么是 AOF 重写？"></a>什么是 AOF 重写？</h4><p>AOF 重写指的是它会直接读取 Redis 服务器当前的状态，并压缩保存为 AOF 文件。例如，我们增加了一个计数器，并对它做了 99 次修改，如果不做 AOF 重写的话，那么持久化文件中就会有 100 条记录执行命令的信息，而 AOF 重写之后，之后记录一条此计数器最终的结果信息，这样就去除了所有的无效信息。</p>
<h4 id="AOF-重写实现"><a href="#AOF-重写实现" class="headerlink" title="AOF 重写实现"></a>AOF 重写实现</h4><p>触发 AOF 文件重写，要满足两个条件，这两个条件也是配置在 Redis 配置文件中的，它们分别：</p>
<ul>
<li><code>auto-aof-rewrite-min-size</code>：允许 AOF 重写的最小文件容量，默认是 64mb 。</li>
<li><code>auto-aof-rewrite-percentage</code>：AOF 文件重写的大小比例，默认值是 100，表示 100%，也就是只有当前 AOF 文件，比最后一次（上次）的 AOF 文件大一倍时，才会启动 AOF 文件重写。</li>
</ul>
<blockquote>
<p>小贴士：只有同时满足 auto-aof-rewrite-min-size 和 auto-aof-rewrite-percentage 设置的条件，才会触发 AOF 文件重写。</p>
</blockquote>
<p>注意：使用 <code>bgrewriteaof</code> 命令，可以自动触发 AOF 文件重写。</p>
<h4 id="AOF-重写流程"><a href="#AOF-重写流程" class="headerlink" title="AOF 重写流程"></a>AOF 重写流程</h4><p>AOF 文件重写是生成一个全新的文件，并把当前数据的最少操作命令保存到新文件上，当把所有的数据都保存至新文件之后，Redis 会交换两个文件，并把最新的持久化操作命令追加到新文件上。</p>
<h3 id="配置说明-1"><a href="#配置说明-1" class="headerlink" title="配置说明"></a>配置说明</h3><p>AOF 的配置参数在 Redis 的配置文件中，也就是 Redis 根路径下的 redis.conf 文件中，配置参数和说明如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text"># 是否开启 AOF，yes 为开启，默认是关闭
appendonly no

# AOF 默认文件名
appendfilename "appendonly.aof"

# AOF 持久化策略配置
# appendfsync always
appendfsync everysec
# appendfsync no

# AOF 文件重写的大小比例，默认值是 100，表示 100%，也就是只有当前 AOF 文件，比最后一次的 AOF 文件大一倍时，才会启动 AOF 文件重写。
auto-aof-rewrite-percentage 100

# 允许 AOF 重写的最小文件容量
auto-aof-rewrite-min-size 64mb

# 是否开启启动时加载 AOF 文件效验，默认值是 yes，表示尽可能的加载 AOF 文件，忽略错误部分信息，并启动 Redis 服务。
# 如果值为 no，则表示，停止启动 Redis，用户必须手动修复 AOF 文件才能正常启动 Redis 服务。
aof-load-truncated yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中比较重要的是 <code>appendfsync</code> 参数，用它来设置 AOF 的持久化策略，可以选择按时间间隔或者操作次数来存储 AOF 文件，这个参数的三个值在文章开头有说明，这里就不再复述了。</p>
<h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><h4 id="正常数据恢复"><a href="#正常数据恢复" class="headerlink" title="正常数据恢复"></a>正常数据恢复</h4><p>正常情况下，只要开启了 AOF 持久化，并且提供了正常的 appendonly.aof 文件，在 Redis 启动时就会自定加载 AOF 文件并启动，执行如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/正常AOF数据恢复.png" alt="正常AOF数据恢复"></p>
<p>其中 <code>DB loaded from append only file......</code> 表示 Redis 服务器在启动时，先去加载了 AOF 持久化文件。</p>
<blockquote>
<p>小贴士：默认情况下 appendonly.aof 文件保存在 Redis 的根目录下。</p>
</blockquote>
<p>持久化文件加载规则</p>
<ul>
<li>如果只开启了 AOF 持久化，Redis 启动时只会加载 AOF 文件（appendonly.aof），进行数据恢复；</li>
<li>如果只开启了 RDB 持久化，Redis 启动时只会加载 RDB 文件（dump.rdb），进行数据恢复；</li>
<li>如果同时开启了 RDB 和 AOF 持久化，Redis 启动时只会加载 AOF 文件（appendonly.aof），进行数据恢复。</li>
</ul>
<p>在 AOF 开启的情况下，即使 AOF 文件不存在，只有 RDB 文件，也不会加载 RDB 文件。 AOF 和 RDB 的加载流程如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/持久化文件加载规则.png" alt="持久化文件加载规则"></p>
<h4 id="简单异常数据恢复"><a href="#简单异常数据恢复" class="headerlink" title="简单异常数据恢复"></a>简单异常数据恢复</h4><p>在 AOF 写入文件时如果服务器崩溃，或者是 AOF 存储已满的情况下，AOF 的最后一条命令可能被截断，这就是异常的 AOF 文件。</p>
<p>在 AOF 文件异常的情况下，如果为修改 Redis 的配置文件，也就是使用 aof-load-truncated 等于 yes 的配置，Redis 在启动时会忽略最后一条命令，并顺利启动 Redis，执行结果如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">* Reading RDB preamble from AOF file...
* Reading the remaining AOF tail...
# !!! Warning: short read while loading the AOF file !!!
# !!! Truncating the AOF at offset 439 !!!
# AOF loaded anyway because aof-load-truncated is enabled<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="复杂异常数据恢复"><a href="#复杂异常数据恢复" class="headerlink" title="复杂异常数据恢复"></a>复杂异常数据恢复</h4><p>AOF 文件可能出现更糟糕的情况，当 AOF 文件不仅被截断，而且中间的命令也被破坏，这个时候再启动 Redis 会提示错误信息并中止运行，错误信息如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">* Reading the remaining AOF tail...
# Bad file format reading the append only file: make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>出现此类问题的解决方案如下：</p>
<ol>
<li>首先使用 AOF 修复工具，检测出现的问题，在命令行中输入 redis-check-aof 命令，它会跳转到出现问题的命令行，这个时候可以尝试手动修复此文件；</li>
<li>如果无法手动修复，我们可以使用 redis-check-aof —fix 自动修复 AOF 异常文件，不过执行此命令，可能会导致异常部分至文件末尾的数据全部被丢弃。</li>
</ol>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="AOF-优点"><a href="#AOF-优点" class="headerlink" title="AOF 优点"></a>AOF 优点</h4><ul>
<li>AOF 持久化保存的数据更加完整，AOF 提供了三种保存策略：每次操作保存、每秒钟保存一次、跟随系统的持久化策略保存，其中每秒保存一次，从数据的安全性和性能两方面考虑是一个不错的选择，也是 AOF 默认的策略，即使发生了意外情况，最多只会丢失 1s 钟的数据；</li>
<li>AOF 采用的是命令追加的写入方式，所以不会出现文件损坏的问题，即使由于某些意外原因，导致了最后操作的持久化数据写入了一半，也可以通过 redis-check-aof 工具轻松的修复；</li>
<li>AOF 持久化文件，非常容易理解和解析，它是把所有 Redis 键值操作命令，以文件的方式存入了磁盘。即使不小心使用 flushall 命令删除了所有键值信息，只要使用 AOF 文件，删除最后的 flushall 命令，重启 Redis 即可恢复之前误删的数据。</li>
</ul>
<h4 id="AOF-缺点"><a href="#AOF-缺点" class="headerlink" title="AOF 缺点"></a>AOF 缺点</h4><ul>
<li>对于相同的数据集来说，AOF 文件要大于 RDB 文件；</li>
<li>在 Redis 负载比较高的情况下，RDB 比 AOF 性能更好；</li>
<li>RDB 使用快照的形式来持久化整个 Redis 数据，而 AOF 只是将每次执行的命令追加到 AOF 文件中，因此从理论上说，RDB 比 AOF 更健壮。</li>
</ul>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>AOF 保存数据更加完整，它可以记录每次 Redis 的键值变化，或者是选择每秒保存一次数据。AOF 的持久化文件更加易读，但相比与二进制的 RDB 来说，所占的存储空间也越大，为了解决这个问题，AOF 提供自动化重写机制，最大程度的减少了 AOF 占用空间大的问题。同时 AOF 也提供了很方便的异常文件恢复命令： redis-check-aof —fix ，为使用 AOF 提供了很好的保障。</p>
<h3 id="参考-amp-鸣谢-1"><a href="#参考-amp-鸣谢-1" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h3><ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/topics/persistence">https://redis.io/topics/persistence</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36318234/article/details/79994133">https://blog.csdn.net/qq_36318234/article/details/79994133</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wdliu/p/9377278.html">https://www.cnblogs.com/wdliu/p/9377278.html</a></li>
</ul>
<h2 id="05-Redis-持久化——混合持久化"><a href="#05-Redis-持久化——混合持久化" class="headerlink" title="05 Redis 持久化——混合持久化"></a>05 Redis 持久化——混合持久化</h2><p>RDB 和 AOF 持久化各有利弊，RDB 可能会导致一定时间内的数据丢失，而 AOF 由于文件较大则会影响 Redis 的启动速度，为了能同时使用 RDB 和 AOF 各种的优点，Redis 4.0 之后新增了混合持久化的方式。</p>
<p>在开启混合持久化的情况下，AOF 重写时会把 Redis 的持久化数据，以 RDB 的格式写入到 AOF 文件的开头，之后的数据再以 AOF 的格式化追加的文件的末尾。</p>
<p>混合持久化的数据存储结构如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/混合持久化的数据存储结构.png" alt="混合持久化的数据存储结构"></p>
<h3 id="开启混合持久化"><a href="#开启混合持久化" class="headerlink" title="开启混合持久化"></a>开启混合持久化</h3><p>查询是否开启混合持久化可以使用 <code>config get aof-use-rdb-preamble</code> 命令。</p>
<p>Redis 5.0 默认值为 yes。 如果是其他版本的 Redis 首先需要检查一下，是否已经开启了混合持久化，如果关闭的情况下，可以通过以下两种方式开启：</p>
<ul>
<li>通过命令行开启</li>
<li>通过修改 Redis 配置文件开启</li>
</ul>
<h4 id="通过命令行开启"><a href="#通过命令行开启" class="headerlink" title="通过命令行开启"></a>通过命令行开启</h4><p>使用命令 <code>config set aof-use-rdb-preamble yes</code>。</p>
<blockquote>
<p>小贴士：命令行设置配置的缺点是重启 Redis 服务之后，设置的配置就会失效。</p>
</blockquote>
<h4 id="通过修改-Redis-配置文件开启"><a href="#通过修改-Redis-配置文件开启" class="headerlink" title="通过修改 Redis 配置文件开启"></a>通过修改 Redis 配置文件开启</h4><p>在 Redis 的根路径下找到 redis.conf 文件，把配置文件中的 <code>aof-use-rdb-preamble no</code> 改为 <code>aof-use-rdb-preamble yes</code>。</p>
<h3 id="实例运行"><a href="#实例运行" class="headerlink" title="实例运行"></a>实例运行</h3><p>当在混合持久化关闭的情况下，使用 <code>bgrewriteaof</code> 触发 AOF 文件重写之后，查看 <code>appendonly.aof</code> 文件的持久化日志，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/混合持久化关闭时AOF文件内容.png" alt="混合持久化关闭时AOF文件内容"></p>
<p>可以看出，当混合持久化关闭的情况下 AOF 持久化文件存储的为标准的 AOF 格式的文件。 当混合持久化开启的模式下，使用 <code>bgrewriteaof</code> 命令触发 AOF 文件重写，得到 <code>appendonly.aof</code> 的文件内容如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/混合持久化开启时AOF文件内容.png" alt="混合持久化开启时AOF文件内容"></p>
<p>可以看出 appendonly.aof 文件存储的内容是 <code>REDIS</code> 开头的 RDB 格式的内容，并非为 AOF 格式的日志。</p>
<h3 id="数据恢复和源码解析"><a href="#数据恢复和源码解析" class="headerlink" title="数据恢复和源码解析"></a>数据恢复和源码解析</h3><p>混合持久化的数据恢复和 AOF 持久化过程是一样的，只需要把 appendonly.aof 放到 Redis 的根目录，在 Redis 启动时，只要开启了 AOF 持久化，Redis 就会自动加载并恢复数据。 Redis 启动信息如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/混合持久化开启时Redis的启动日志.png" alt="混合持久化开启时Redis的启动日志"></p>
<p>可以看出 Redis 在服务器初始化的时候加载了 AOF 文件的内容。</p>
<h4 id="混合持久化的加载流程"><a href="#混合持久化的加载流程" class="headerlink" title="混合持久化的加载流程"></a>混合持久化的加载流程</h4><p>混合持久化的加载流程如下：</p>
<ol>
<li>判断是否开启 AOF 持久化，开启继续执行后续流程，未开启执行加载 RDB 文件的流程；</li>
<li>判断 appendonly.aof 文件是否存在，文件存在则执行后续流程；</li>
<li>判断 AOF 文件开头是 RDB 的格式, 先加载 RDB 内容再加载剩余的 AOF 内容；</li>
<li>判断 AOF 文件开头不是 RDB 的格式，直接以 AOF 格式加载整个文件。</li>
</ol>
<p>AOF 加载流程图如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/AOF加载流程图.png" alt="AOF加载流程图"></p>
<h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>Redis 判断 AOF 文件的开头是否是 RDB 格式的，是通过关键字 <code>REDIS</code> 判断的，RDB 文件的开头一定是 <code>REDIS</code> 关键字开头的，判断源码在 Redis 的 <code>src/aof.c</code> 中，核心代码如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> sig<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* "REDIS" */</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fread</span><span class="token punctuation">(</span>sig<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>fp<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">5</span> <span class="token operator">||</span> <span class="token function">memcmp</span><span class="token punctuation">(</span>sig<span class="token punctuation">,</span><span class="token string">"REDIS"</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// AOF 文件开头非 RDB 格式，非混合持久化文件</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fseek</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">SEEK_SET</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> readerr<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">/* RDB preamble. Pass loading the RDB functions. */</span>
    rio rdb<span class="token punctuation">;</span>

    <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_NOTICE<span class="token punctuation">,</span><span class="token string">"Reading RDB preamble from AOF file..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fseek</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">SEEK_SET</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> readerr<span class="token punctuation">;</span>
    <span class="token function">rioInitWithFile</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rdb<span class="token punctuation">,</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// AOF 文件开头是 RDB 格式，先加载 RDB 再加载 AOF</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rdbLoadRio</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rdb<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> C_OK<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span><span class="token string">"Error reading the RDB preamble of the AOF file, AOF loading aborted"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> readerr<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_NOTICE<span class="token punctuation">,</span><span class="token string">"Reading the remaining AOF tail..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 加载 AOF 格式的数据</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出 Redis 是通过判断 AOF 文件的开头是否是 <code>REDIS</code> 关键字，来确定此文件是否为混合持久化文件的。</p>
<blockquote>
<p>小贴士：AOF 格式的开头是 <code>*</code>，而 RDB 格式的开头是 <code>REDIS</code>。</p>
</blockquote>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>混合持久化优点：</p>
<ul>
<li>混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险。</li>
</ul>
<p>混合持久化缺点：</p>
<ul>
<li>AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；</li>
<li>兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了。</li>
</ul>
<h3 id="持久化最佳实践"><a href="#持久化最佳实践" class="headerlink" title="持久化最佳实践"></a>持久化最佳实践</h3><p>持久化虽然保证了数据不丢失，但同时拖慢了 Redis 的运行速度，那怎么更合理的使用 Redis 的持久化功能呢？ Redis 持久化的最佳实践可从以下几个方面考虑。</p>
<h4 id="控制持久化开关"><a href="#控制持久化开关" class="headerlink" title="控制持久化开关"></a>控制持久化开关</h4><p>使用者可根据实际的业务情况考虑，如果对数据的丢失不敏感的情况下，可考虑关闭 Redis 的持久化，这样所以的键值操作都在内存中，就可以保证最高效率的运行 Redis 了。 持久化关闭操作：</p>
<ul>
<li>关闭 RDB 持久化，使用命令： <code>config set save ""</code></li>
<li>关闭 AOF 和 混合持久化，使用命令： <code>config set appendonly no</code></li>
</ul>
<h4 id="主从部署"><a href="#主从部署" class="headerlink" title="主从部署"></a>主从部署</h4><p>使用主从部署，一台用于响应主业务，一台用于数据持久化，这样就可能让 Redis 更加高效的运行。</p>
<h4 id="使用混合持久化"><a href="#使用混合持久化" class="headerlink" title="使用混合持久化"></a>使用混合持久化</h4><p>混合持久化结合了 RDB 和 AOF 的优点，Redis 5.0 默认是开启的。</p>
<h4 id="使用配置更高的机器"><a href="#使用配置更高的机器" class="headerlink" title="使用配置更高的机器"></a>使用配置更高的机器</h4><p>Redis 对 CPU 的要求并不高，反而是对内存和磁盘的要求很高，因为 Redis 大部分时候都在做读写操作，使用更多的内存和更快的磁盘，对 Redis 性能的提高非常有帮助。</p>
<h3 id="参考-amp-鸣谢-2"><a href="#参考-amp-鸣谢-2" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h3><ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/topics/persistence">https://redis.io/topics/persistence</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36318234/article/details/79994133">https://blog.csdn.net/qq_36318234/article/details/79994133</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wdliu/p/9377278.html">https://www.cnblogs.com/wdliu/p/9377278.html</a></li>
</ul>
<h2 id="06-字符串使用与内部实现原理"><a href="#06-字符串使用与内部实现原理" class="headerlink" title="06 字符串使用与内部实现原理"></a>06 字符串使用与内部实现原理</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wan-ming-zhu/p/18078015">https://www.cnblogs.com/wan-ming-zhu/p/18078015</a></p>
<p>Redis 发展到现在已经有 9 种数据类型了，其中最基础、最常用的数据类型有 5 种，它们分别是：字符串类型、列表类型、哈希表类型、集合类型、有序集合类型，而在这 5 种数据类型中最常用的是字符串类型，所以本文我们先从字符串的使用开始说起。</p>
<p>字符串类型的全称是 Simple Dynamic Strings 简称 SDS，中文意思是：简单动态字符串。它是以键值对 key-value 的形式进行存储的，根据 key 来存储和获取 value 值，它的使用相对来说比较简单，但在实际项目中应用非常广泛。</p>
<h3 id="1-字符串类型能做什么？"><a href="#1-字符串类型能做什么？" class="headerlink" title="1 字符串类型能做什么？"></a>1 字符串类型能做什么？</h3><p>字符串类型的使用场景有很多，但从功能的角度来区分，大致可分为以下两种：</p>
<ul>
<li>字符串存储和操作；</li>
<li>整数类型和浮点类型的存储和计算。</li>
</ul>
<p>字符串最常用的业务场景有以下几个。</p>
<h4 id="1）页面数据缓存"><a href="#1）页面数据缓存" class="headerlink" title="1）页面数据缓存"></a>1）页面数据缓存</h4><p>我们知道，一个系统最宝贵的资源就是数据库资源，随着公司业务的发展壮大，数据库的存储量也会越来越大，并且要处理的请求也越来越多，当数据量和并发量到达一定级别之后，数据库就变成了拖慢系统运行的”罪魁祸首”，为了避免这种情况的发生，我们可以把查询结果放入缓存(Redis)中，让下次同样的查询直接去缓存系统取结果，而非查询数据库，这样既减少了数据库的压力，同时也提高了程序的运行速度。</p>
<p>介于以上这个思路，我们可以把文章详情页的数据放入缓存系统。具体的做法是先将文章详情页序列化为字符串存入缓存，再从缓存中读取到字符串，反序列化成对象，然后再赋值到页面进行显示 (当然也可以用哈希类型进行存储，这会在下一篇文章中讲到)，这样我们就实现了文章详情页的缓存功能，架构流程对比图如下所示。</p>
<p>原始系统运行流程图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/原始系统运行流程图.png" alt="原始系统运行流程图"></p>
<p>引入缓存系统后的流程图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/引入缓存系统后的流程图.png" alt="引入缓存系统后的流程图"></p>
<h4 id="2）数字计算与统计"><a href="#2）数字计算与统计" class="headerlink" title="2）数字计算与统计"></a>2）数字计算与统计</h4><p>Redis 可以用来存储整数和浮点类型的数据，并且可以通过命令直接累加并存储整数信息，这样就省去了每次先要取数据、转换数据、拼加数据、再存入数据的麻烦，只需要使用一个命令就可以完成此流程，具体实现过程本文下半部分会讲。这样我们就可以使用此功能来实现访问量的统计，当有人访问时访问量 +1 就可以了。</p>
<h4 id="3）共享-Session-信息"><a href="#3）共享-Session-信息" class="headerlink" title="3）共享 Session 信息"></a>3）共享 Session 信息</h4><p>通常我们在开发后台管理系统时，会使用 Session 来保存用户的会话(登录)状态，这些 Session 信息会被保存在服务器端，但这只适用于单系统应用，如果是分布式系统此模式将不再适用。</p>
<p>例如用户一的 Session 信息被存储在服务器一，但第二次访问时用户一被分配到服务器二，这个时候服务器并没有用户一的 Session 信息，就会出现需要重复登录的问题。分布式系统每次会把请求随机分配到不同的服务器，因此我们需要借助缓存系统对这些 Session 信息进行统一的存储和管理，这样无论请求发送到那台服务器，服务器都会去统一的缓存系统获取相关的 Session 信息，这样就解决了分布式系统下 Session 存储的问题。</p>
<h3 id="2-字符串如何使用？"><a href="#2-字符串如何使用？" class="headerlink" title="2 字符串如何使用？"></a>2 字符串如何使用？</h3><p>通常我们会使用两种方式来操作 Redis：第一种是使用命令行来操作，例如 redis-cli；另一种是使用代码的方式来操作。</p>
<blockquote>
<p>小贴士：mset 是一个原子性(atomic)操作，所有给定 key 都会在同一时间内被设置，不会出现某些 key 被更新，而另一些 key 没被更新的情况。</p>
</blockquote>
<h3 id="3-代码实战"><a href="#3-代码实战" class="headerlink" title="3 代码实战"></a>3 代码实战</h3><h3 id="4-字符串的内部实现"><a href="#4-字符串的内部实现" class="headerlink" title="4 字符串的内部实现"></a>4 字符串的内部实现</h3><h4 id="1）源码分析"><a href="#1）源码分析" class="headerlink" title="1）源码分析"></a>1）源码分析</h4><p>Redis 3.2 之前 SDS 源码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sds</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> len<span class="token punctuation">;</span> <span class="token comment">// 已占用的字节数</span>
    <span class="token keyword">int</span> free<span class="token punctuation">;</span> <span class="token comment">// 剩余可以字节数</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 存储字符串的数据空间</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出 Redis 3.2 之前 SDS 内部是一个带有长度信息的字节数组，存储结构如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/Redis3.2之前SDS.png" alt="Redis3.2之前SDS"></p>
<p>为了更加有效的利用内存，Redis 3.2 优化了 SDS 的存储结构，源码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">char</span> <span class="token operator">*</span>sds<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr5</span> <span class="token punctuation">{</span> <span class="token comment">// 对应的字符串长度小于 1&lt;&lt;5</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr8</span> <span class="token punctuation">{</span> <span class="token comment">// 对应的字符串长度小于 1&lt;&lt;8</span>
    uint8_t len<span class="token punctuation">;</span> <span class="token comment">/* 已使用长度，1 字节存储 */</span>
    uint8_t alloc<span class="token punctuation">;</span> <span class="token comment">/* 总长度 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> 
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 真正存储字符串的数据空间</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr16</span> <span class="token punctuation">{</span> <span class="token comment">// 对应的字符串长度小于 1&lt;&lt;16</span>
    uint16_t len<span class="token punctuation">;</span> <span class="token comment">/* 已使用长度，2 字节存储 */</span>
    uint16_t alloc<span class="token punctuation">;</span> 
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> 
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr32</span> <span class="token punctuation">{</span> <span class="token comment">// 对应的字符串长度小于 1&lt;&lt;32</span>
    uint32_t len<span class="token punctuation">;</span> <span class="token comment">/* 已使用长度，4 字节存储 */</span>
    uint32_t alloc<span class="token punctuation">;</span> 
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> 
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr64</span> <span class="token punctuation">{</span> <span class="token comment">// 对应的字符串长度小于 1&lt;&lt;64</span>
    uint64_t len<span class="token punctuation">;</span> <span class="token comment">/* 已使用长度，8 字节存储 */</span>
    uint64_t alloc<span class="token punctuation">;</span> 
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> 
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样就可以针对不同长度的字符串申请相应的存储类型，从而有效的节约了内存使用。</p>
<h4 id="2）数据类型"><a href="#2）数据类型" class="headerlink" title="2）数据类型"></a>2）数据类型</h4><p>我们可以使用 <code>object encoding key</code> 命令来查看对象(键值对)存储的数据类型，当我们使用此命令来查询 SDS 对象时，发现 SDS 对象竟然包含了三种不同的数据类型：int、embstr 和 raw。</p>
<p>int 类型</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; set key 666
OK
127.0.0.1:6379&gt; object encoding key
"int"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>embstr 类型</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; set key abc
OK
127.0.0.1:6379&gt; object encoding key
"embstr"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>raw 类型</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; set key abcdefghigklmnopqrstyvwxyzabcdefghigklmnopqrs
OK
127.0.0.1:6379&gt; object encoding key
"raw"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>int 类型很好理解，整数类型对应的就是 int 类型，而字符串则对应是 embstr 类型，当字符串长度大于 44 字节时，会变为 raw 类型存储。</p>
<h4 id="3）为什么是-44-字节？"><a href="#3）为什么是-44-字节？" class="headerlink" title="3）为什么是 44 字节？"></a>3）为什么是 44 字节？</h4><p>在 Redis 中，如果 SDS 的存储值大于 64 字节时，Redis 的内存分配器会认为此对象为大字符串，并使用 raw 类型来存储，当数据小于 64 字节时(字符串类型)，会使用 embstr 类型存储。既然内存分配器的判断标准是 64 字节，那为什么 embstr 类型和 raw 类型的存储判断值是 44 字节？</p>
<p>这是因为 Redis 在存储对象时，会创建此对象的关联信息，redisObject 对象头和 SDS 自身属性信息，这些信息都会占用一定的存储空间，因此长度判断标准就从 64 字节变成了 44 字节。</p>
<p>在 Redis 中，所有的对象都会包含 redisObject 对象头。我们先来看 redisObject 对象的源码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisObject</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> type<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// 4 bit</span>
    <span class="token keyword">unsigned</span> encoding<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// 4 bit</span>
    <span class="token keyword">unsigned</span> lru<span class="token operator">:</span>LRU_BITS<span class="token punctuation">;</span> <span class="token comment">// 3 个字节</span>
    <span class="token keyword">int</span> refcount<span class="token punctuation">;</span> <span class="token comment">// 4 个字节</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span> <span class="token comment">// 8 个字节</span>
<span class="token punctuation">}</span> robj<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>它的参数说明如下：</p>
<ul>
<li><code>type</code>：对象的数据类型，例如：string、list、hash 等，占用 4 bits 也就是半个字符的大小；</li>
<li><code>encoding</code>：对象数据编码，占用 4 bits；</li>
<li><code>lru</code>：记录对象的 LRU(Least Recently Used 的缩写，即最近最少使用)信息，内存回收时会用到此属性，占用 24 bits(3 字节)；</li>
<li><code>refcount</code>：引用计数器，占用 32 bits(4 字节)；</li>
<li><code>*ptr</code>：对象指针用于指向具体的内容，占用 64 bits(8 字节)。</li>
</ul>
<p>redisObject 总共占用 <code>0.5 bytes + 0.5 bytes + 3 bytes + 4 bytes + 8 bytes = 16 bytes(字节)</code>。</p>
<p>了解了 redisObject 之后，我们再来看 SDS 自身的数据结构，从 SDS 的源码可以看出，SDS 的存储类型一共有 5 种：<code>SDS*TYPE*5</code>、<code>SDS*TYPE*8</code>、<code>SDS*TYPE*16</code>、<code>SDS*TYPE*32</code>、<code>SDS*TYPE*64</code>，在这些类型中最小的存储类型为 <code>SDS*TYPE*５</code>，但 <code>SDS*TYPE*５</code> 类型会默认转成 <code>SDS*TYPE*8</code>，以下源码可以证明，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/sdsnewlen.png" alt="sdsnewlen"></p>
<p>那我们直接来看 <code>SDS*TYPE*8</code> 的源码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr8</span> <span class="token punctuation">{</span>
    uint8_t len<span class="token punctuation">;</span> <span class="token comment">// 1 byte</span>
    uint8_t alloc<span class="token punctuation">;</span> <span class="token comment">// 1 byte</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">// 1 byte</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出除了内容数组(buf)之外，其他三个属性分别占用了 1 个字节，最终分隔字符等于 64 字节，减去 redisObject 的 16 个字节，再减去 SDS 自身的 3 个字节，再减去结束符 \0 结束符占用 1 个字节，最终的结果是 44 字节(64-16-3-1=44)，内存占用如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/为什么是44字节.png" alt="为什么是44字节"></p>
<blockquote>
<p>但 SDS 不需要用 \0 字符来标识字符串结尾，而是有个专门的 len 成员变量来记录长度，所以可存储包含 \0 的数据。但是 SDS 为了兼容部分 C 语言标准库的函数，还是会在结尾加上 \0 字符。注意：我们说 alloc 成员维护的是 buf[] 数组的长度，但是这个长度不包括结尾的 \0，比如 alloc 为 10，但 buf[] 的长度其实是 11。</p>
</blockquote>
<h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5 小结"></a>5 小结</h3><p>本文介绍了字符串的定义及其使用，它的使用主要分为：单键值对操作、多键值对操作、数字统计、键值对过期操作、字符串操作进阶等。同时也介绍了字符串使用的三个场景，字符串类型可用作为：页面数据缓存，可以缓存一些文章详情信息等；数字计算与统计，例如计算页面的访问次数；也可以用作 Session 共享，用来记录管理员的登录信息等。同时我们深入的介绍了字符串的五种数据存储结构，以及字符串的三种内部数据类型，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/字符串小结.png" alt="字符串小结"></p>
<p>同时我们也知道了 embstr 类型向 raw 类型转化，是因为每个 Redis 对象都包含了一个 redisObject 对象头和 SDS 自身属性占用了一定的空间，最终导致数据类型的判断长度是 44 字节。</p>
<h2 id="08-字典使用与内部实现原理"><a href="#08-字典使用与内部实现原理" class="headerlink" title="08 字典使用与内部实现原理"></a>08 字典使用与内部实现原理</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wan-ming-zhu/p/18079378">https://www.cnblogs.com/wan-ming-zhu/p/18079378</a></p>
<p>字典类型 (Hash) 又被成为散列类型或者是哈希表类型，它是将一个键值 (key) 和一个特殊的”哈希表”关联起来，这个”哈希表”表包含两列数据：字段和值。例如我们使用字典类型来存储一篇文章的详情信息，存储结构如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/使用字典类型来存储一篇文章.png" alt="使用字典类型来存储一篇文章"></p>
<p>同理我们也可以使用字典类型来存储用户信息，并且使用字典类型来存储此类信息，是不需要手动序列化和反序列化数据的，所以使用起来更加的方便和高效。</p>
<h3 id="1-基础使用"><a href="#1-基础使用" class="headerlink" title="1.基础使用"></a>1.基础使用</h3><h3 id="2-代码实战"><a href="#2-代码实战" class="headerlink" title="2.代码实战"></a>2.代码实战</h3><h3 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="3.数据结构"></a>3.数据结构</h3><p>字典类型本质上是由数组和链表结构组成的，来看字典类型的源码实现：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token punctuation">{</span> <span class="token comment">// dict.h</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">;</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token keyword">void</span> <span class="token operator">*</span>val<span class="token punctuation">;</span>
        uint64_t u64<span class="token punctuation">;</span>
        int64_t s64<span class="token punctuation">;</span>
        <span class="token keyword">double</span> d<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> v<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">// 下一个 entry</span>
<span class="token punctuation">}</span> dictEntry<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>字典类型的数据结构，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/字典类型的数据结构.png" alt="字典类型的数据结构"></p>
<p>通常情况下字典类型会使用数组的方式来存储相关的数据，但发生哈希冲突时才会使用链表的结构来存储数据。</p>
<h3 id="4-哈希冲突"><a href="#4-哈希冲突" class="headerlink" title="4.哈希冲突"></a>4.哈希冲突</h3><p>字典类型的存储流程是先将键值进行 Hash 计算，得到存储键值对应的数组索引，再根据数组索引进行数据存储，但在小概率事件下可能会出完全不相同的键值进行 Hash 计算之后，得到相同的 Hash 值，这种情况我们称之为哈希冲突。</p>
<p>哈希冲突一般通过链表的形式解决，相同的哈希值会对应一个链表结构，每次有哈希冲突时，就把新的元素插入到链表的尾部，请参考上面数据结构的那张图。</p>
<p>键值查询的流程如下：</p>
<ul>
<li>通过算法 (Hash，计算和取余等) 操作获得数组的索引值，根据索引值找到对应的元素；</li>
<li>判断元素和查找的键值是否相等，相等则成功返回数据，否则需要查看 next 指针是否还有对应其他元素，如果没有，则返回 null，如果有的话，重复此步骤。</li>
</ul>
<p>键值查询流程，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/键值查询流程.png" alt="键值查询流程"></p>
<h3 id="5-渐进式rehash"><a href="#5-渐进式rehash" class="headerlink" title="5.渐进式rehash"></a>5.渐进式rehash</h3><p>Redis 为了保证应用的高性能运行，提供了一个重要的机制——渐进式 rehash。 渐进式 rehash 是用来保证字典缩放效率的，也就是说在字典进行扩容或者缩容是会采取渐进式 rehash 的机制。</p>
<h4 id="1）扩容"><a href="#1）扩容" class="headerlink" title="1）扩容"></a>1）扩容</h4><p>当元素数量等于数组长度时就会进行扩容操作，源码在 dict.c 文件中，核心代码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">dictExpand</span><span class="token punctuation">(</span>dict <span class="token operator">*</span>d<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">/* 需要的容量小于当前容量，则不需要扩容 */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dictIsRehashing</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token operator">||</span> d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>used <span class="token operator">&gt;</span> size<span class="token punctuation">)</span>
        <span class="token keyword">return</span> DICT_ERR<span class="token punctuation">;</span>
    dictht n<span class="token punctuation">;</span> 
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> realsize <span class="token operator">=</span> <span class="token function">_dictNextPower</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 重新计算扩容后的值</span>
    <span class="token comment">/* 计算新的扩容大小等于当前容量，不需要扩容 */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>realsize <span class="token operator">==</span> d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>size<span class="token punctuation">)</span> <span class="token keyword">return</span> DICT_ERR<span class="token punctuation">;</span>
    <span class="token comment">/* 分配一个新的哈希表，并将所有指针初始化为NULL */</span>
    n<span class="token punctuation">.</span>size <span class="token operator">=</span> realsize<span class="token punctuation">;</span>
    n<span class="token punctuation">.</span>sizemask <span class="token operator">=</span> realsize<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    n<span class="token punctuation">.</span>table <span class="token operator">=</span> <span class="token function">zcalloc</span><span class="token punctuation">(</span>realsize<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>dictEntry<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    n<span class="token punctuation">.</span>used <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>table <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 第一次初始化</span>
        d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>
        <span class="token keyword">return</span> DICT_OK<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment">// 把增量输入放入新 ht[1] 中</span>
    d<span class="token operator">-&gt;</span>rehashidx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 非默认值 -1，表示需要进行 rehash</span>
    <span class="token keyword">return</span> DICT_OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从以上源码可以看出，如果需要扩容则会申请一个新的内存地址赋值给 ht[1]，并把字典的 rehashindex 设置为 0，表示之后需要进行 rehash 操作。</p>
<h4 id="2）缩容"><a href="#2）缩容" class="headerlink" title="2）缩容"></a>2）缩容</h4><p>当字典的使用容量不足总空间的 10% 时就会触发缩容，Redis 在进行缩容时也会把 rehashindex 设置为 0，表示之后需要进行 rehash 操作。</p>
<h4 id="3）渐进式rehash流程"><a href="#3）渐进式rehash流程" class="headerlink" title="3）渐进式rehash流程"></a>3）渐进式rehash流程</h4><p>在进行渐进式 rehash 时，会同时保留两个 hash 结构，新键值对加入时会直接插入到新的 hash 结构中，并会把旧 hash 结构中的元素一点一点的移动到新的 hash 结构中，当移除完最后一个元素时，清空旧 hash 结构，主要的执行流程如下：</p>
<ul>
<li>扩容或者缩容时把字典中的字段 rehashidx 标识为 0；</li>
<li>在执行定时任务或者执行客户端的 hset、hdel 等操作指令时，判断是否需要触发 rehash 操作（通过 rehashidx 标识判断），如果需要触发 rehash 操作，也就是调用 dictRehash 函数，dictRehash 函数会把 ht[0] 中的元素依次添加到新的 Hash 表 ht[1] 中；</li>
<li>rehash 操作完成之后，清空 Hash 表 ht[0]，然后对调 ht[1] 和 ht[0] 的值，把新的数据表 ht[1] 更改为 ht[0]，然后把字典中的 rehashidx 标识为 -1，表示不需要执行 rehash 操作。</li>
</ul>
<h3 id="7-小结"><a href="#7-小结" class="headerlink" title="7.小结"></a>7.小结</h3><p>本文我们学习了字典类型的操作命令和在代码中的使用，也明白了字典类型实际是由数组和链表组成的，当字典进行扩容或者缩容时会进行渐进式 rehash 操作，渐进式 rehash 是用来保证 Redis 运行效率的，它的执行流程是同时保留两个哈希表，把旧表中的元素一点一点的移动到新表中，查询的时候会先查询两个哈希表，当所有元素都移动到新的哈希表之后，就会删除旧的哈希表。</p>
<h2 id="10-列表使用与内部实现原理"><a href="#10-列表使用与内部实现原理" class="headerlink" title="10 列表使用与内部实现原理"></a>10 列表使用与内部实现原理</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wan-ming-zhu/p/18078658">https://www.cnblogs.com/wan-ming-zhu/p/18078658</a></p>
<p>列表类型 (List) 是一个使用链表结构存储的有序结构，它的元素插入会按照先后顺序存储到链表结构中，因此它的元素操作 (插入\删除) 时间复杂度为 O(1)，所以相对来说速度还是比较快的，但它的查询时间复杂度为 O(n)，因此查询可能会比较慢。</p>
<h3 id="1-基础使用-1"><a href="#1-基础使用-1" class="headerlink" title="1 基础使用"></a>1 基础使用</h3><p>列表类型的使用相对来说比较简单，对它的操作就相当操作一个没有任何 key 值的 value 集合，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/列表.png" alt="列表"></p>
<h3 id="3-内部实现"><a href="#3-内部实现" class="headerlink" title="3 内部实现"></a>3 内部实现</h3><p>我们先用 <code>debug encoding key</code> 来查看列表类型的内部存储类型，如下所示：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; object encoding list
"quicklist"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>从结果可以看出，列表类型的底层数据类型是 quicklist。</p>
<p>quicklist (快速列表) 是 Redis 3.2 引入的数据类型，早期的列表类型使用的是ziplist (压缩列表) 和双向链表组成的，Redis 3.2 改为用 quicklist 来存储列表元素。</p>
<p>我们来看下 quicklist 的实现源码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">quicklist</span> <span class="token punctuation">{</span> <span class="token comment">// src/quicklist.h</span>
    quicklistNode <span class="token operator">*</span>head<span class="token punctuation">;</span>
    quicklistNode <span class="token operator">*</span>tail<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> count<span class="token punctuation">;</span>        <span class="token comment">/* ziplist 的个数 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">;</span>          <span class="token comment">/* quicklist 的节点数 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> compress <span class="token operator">:</span> <span class="token number">16</span><span class="token punctuation">;</span> <span class="token comment">/* LZF 压缩算法深度 */</span>
    <span class="token comment">//...</span>
<span class="token punctuation">}</span> quicklist<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">quicklistNode</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">quicklistNode</span> <span class="token operator">*</span>prev<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">quicklistNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>zl<span class="token punctuation">;</span>           <span class="token comment">/* 对应的 ziplist */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> sz<span class="token punctuation">;</span>             <span class="token comment">/* ziplist 字节数 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> count <span class="token operator">:</span> <span class="token number">16</span><span class="token punctuation">;</span>     <span class="token comment">/* ziplist 个数 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> encoding <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>   <span class="token comment">/* RAW==1 or LZF==2 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> container <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">/* NONE==1 or ZIPLIST==2 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> recompress <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* 该节点先前是否被压缩 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> attempted_compress <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* 节点太小无法压缩 */</span>
    <span class="token comment">//...</span>
<span class="token punctuation">}</span> quicklistNode<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">quicklistLZF</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> sz<span class="token punctuation">;</span> 
    <span class="token keyword">char</span> compressed<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> quicklistLZF<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从以上源码可以看出 quicklist 是一个双向链表，链表中的每个节点实际上是一个 ziplist，它们的结构如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/列表的结构.png" alt="列表的结构"></p>
<p>ziplist 作为 quicklist 的实际存储结构，它本质是一个字节数组，ziplist 数据结构如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/ziplist数据结构.png" alt="ziplist数据结构"></p>
<p>其中的字段含义如下：</p>
<ul>
<li>zlbytes：压缩列表字节长度，占 4 字节；</li>
<li>zltail：压缩列表尾元素相对于起始元素地址的偏移量，占 4 字节；</li>
<li>zllen：压缩列表的元素个数；</li>
<li>entryX：压缩列表存储的所有元素，可以是字节数组或者是整数；</li>
<li>zlend：压缩列表的结尾，占 1 字节，固定值 0xFF；</li>
</ul>
<h3 id="4-源码解析"><a href="#4-源码解析" class="headerlink" title="4 源码解析"></a>4 源码解析</h3><h4 id="1）添加功能源码分析"><a href="#1）添加功能源码分析" class="headerlink" title="1）添加功能源码分析"></a>1）添加功能源码分析</h4><p>quicklist 添加操作对应函数是 quicklistPush，源码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">quicklistPush</span><span class="token punctuation">(</span>quicklist <span class="token operator">*</span>quicklist<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>value<span class="token punctuation">,</span> <span class="token keyword">const</span> size_t sz<span class="token punctuation">,</span>
                   <span class="token keyword">int</span> where<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>where <span class="token operator">==</span> QUICKLIST_HEAD<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 在列表头部添加元素</span>
        <span class="token function">quicklistPushHead</span><span class="token punctuation">(</span>quicklist<span class="token punctuation">,</span> value<span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>where <span class="token operator">==</span> QUICKLIST_TAIL<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 在列表尾部添加元素</span>
        <span class="token function">quicklistPushTail</span><span class="token punctuation">(</span>quicklist<span class="token punctuation">,</span> value<span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以 quicklistPushHead 为例，源码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">quicklistPushHead</span><span class="token punctuation">(</span>quicklist <span class="token operator">*</span>quicklist<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>value<span class="token punctuation">,</span> size_t sz<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    quicklistNode <span class="token operator">*</span>orig_head <span class="token operator">=</span> quicklist<span class="token operator">-&gt;</span>head<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>
            <span class="token function">_quicklistNodeAllowInsert</span><span class="token punctuation">(</span>quicklist<span class="token operator">-&gt;</span>head<span class="token punctuation">,</span> quicklist<span class="token operator">-&gt;</span>fill<span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 在头部节点插入元素</span>
        quicklist<span class="token operator">-&gt;</span>head<span class="token operator">-&gt;</span>zl <span class="token operator">=</span>
            <span class="token function">ziplistPush</span><span class="token punctuation">(</span>quicklist<span class="token operator">-&gt;</span>head<span class="token operator">-&gt;</span>zl<span class="token punctuation">,</span> value<span class="token punctuation">,</span> sz<span class="token punctuation">,</span> ZIPLIST_HEAD<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">quicklistNodeUpdateSz</span><span class="token punctuation">(</span>quicklist<span class="token operator">-&gt;</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 头部节点不能继续插入，需要新建 quicklistNode、ziplist 进行插入</span>
        quicklistNode <span class="token operator">*</span>node <span class="token operator">=</span> <span class="token function">quicklistCreateNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        node<span class="token operator">-&gt;</span>zl <span class="token operator">=</span> <span class="token function">ziplistPush</span><span class="token punctuation">(</span><span class="token function">ziplistNew</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> value<span class="token punctuation">,</span> sz<span class="token punctuation">,</span> ZIPLIST_HEAD<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">quicklistNodeUpdateSz</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 将新建的 quicklistNode 插入到 quicklist 结构中</span>
        <span class="token function">_quicklistInsertNodeBefore</span><span class="token punctuation">(</span>quicklist<span class="token punctuation">,</span> quicklist<span class="token operator">-&gt;</span>head<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    quicklist<span class="token operator">-&gt;</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
    quicklist<span class="token operator">-&gt;</span>head<span class="token operator">-&gt;</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>orig_head <span class="token operator">!=</span> quicklist<span class="token operator">-&gt;</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>quicklistPushHead 函数的执行流程，先判断 quicklist 的 head 节点是否可以插入数据，如果可以插入则使用 ziplist 的接口进行插入，否则就新建 quicklistNode 节点进行插入。</p>
<p>函数的入参是待插入的 quicklist，还有需要插入的值 value 以及他的大小 sz。</p>
<p>函数的返回值为 int，0 表示没有新建 head，1 表示新建了 head。</p>
<h4 id="2）删除功能源码分析"><a href="#2）删除功能源码分析" class="headerlink" title="2）删除功能源码分析"></a>2）删除功能源码分析</h4><p>quicklist 元素删除分为两种情况：单一元素删除和区间元素删除，它们都位于 src/quicklist.c 文件中。</p>
<h5 id="单一元素删除"><a href="#单一元素删除" class="headerlink" title="单一元素删除"></a>单一元素删除</h5><p>单一元素的删除函数是 quicklistDelEntry，源码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">quicklistDelEntry</span><span class="token punctuation">(</span>quicklistIter <span class="token operator">*</span>iter<span class="token punctuation">,</span> quicklistEntry <span class="token operator">*</span>entry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    quicklistNode <span class="token operator">*</span>prev <span class="token operator">=</span> entry<span class="token operator">-&gt;</span>node<span class="token operator">-&gt;</span>prev<span class="token punctuation">;</span>
    quicklistNode <span class="token operator">*</span>next <span class="token operator">=</span> entry<span class="token operator">-&gt;</span>node<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token comment">// 删除指定位置的元素</span>
    <span class="token keyword">int</span> deleted_node <span class="token operator">=</span> <span class="token function">quicklistDelIndex</span><span class="token punctuation">(</span><span class="token punctuation">(</span>quicklist <span class="token operator">*</span><span class="token punctuation">)</span>entry<span class="token operator">-&gt;</span>quicklist<span class="token punctuation">,</span>
                                         entry<span class="token operator">-&gt;</span>node<span class="token punctuation">,</span> <span class="token operator">&amp;</span>entry<span class="token operator">-&gt;</span>zi<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//...</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出 quicklistDelEntry 函数的底层，依赖 quicklistDelIndex 函数进行元素删除。</p>
<h5 id="区间元素删除"><a href="#区间元素删除" class="headerlink" title="区间元素删除"></a>区间元素删除</h5><p>区间元素删除的函数是 quicklistDelRange，源码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// start 表示开始删除的下标，count 表示要删除的个数</span>
<span class="token keyword">int</span> <span class="token function">quicklistDelRange</span><span class="token punctuation">(</span>quicklist <span class="token operator">*</span>quicklist<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">long</span> start<span class="token punctuation">,</span>
                      <span class="token keyword">const</span> <span class="token keyword">long</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> extent <span class="token operator">=</span> count<span class="token punctuation">;</span> 
    <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> extent <span class="token operator">&gt;</span> <span class="token punctuation">(</span>quicklist<span class="token operator">-&gt;</span>count <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 删除的元素个数大于已有元素</span>
        extent <span class="token operator">=</span> quicklist<span class="token operator">-&gt;</span>count <span class="token operator">-</span> start<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> extent <span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">-</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 删除指定的元素个数</span>
        extent <span class="token operator">=</span> <span class="token operator">-</span>start<span class="token punctuation">;</span> <span class="token comment">/* c.f. LREM -29 29; just delete until end. */</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//...</span>
    <span class="token comment">// extent 为剩余需要删除的元素个数，</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>extent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 保存下个 quicklistNode，因为本节点可能会被删除</span>
        quicklistNode <span class="token operator">*</span>next <span class="token operator">=</span> node<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> del<span class="token punctuation">;</span>
        <span class="token keyword">int</span> delete_entire_node <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>entry<span class="token punctuation">.</span>offset <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> extent <span class="token operator">&gt;=</span> node<span class="token operator">-&gt;</span>count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 删除整个 quicklistNode</span>
            delete_entire_node <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            del <span class="token operator">=</span> node<span class="token operator">-&gt;</span>count<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>entry<span class="token punctuation">.</span>offset <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> extent <span class="token operator">&gt;=</span> node<span class="token operator">-&gt;</span>count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 删除本节点的所有元素</span>
            del <span class="token operator">=</span> node<span class="token operator">-&gt;</span>count <span class="token operator">-</span> entry<span class="token punctuation">.</span>offset<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>entry<span class="token punctuation">.</span>offset <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// entry.offset&lt;0 表示从后向前，相反则表示从前向后剩余的元素个数</span>
            del <span class="token operator">=</span> <span class="token operator">-</span>entry<span class="token punctuation">.</span>offset<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>del <span class="token operator">&gt;</span> extent<span class="token punctuation">)</span>
                del <span class="token operator">=</span> extent<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 删除本节点部分元素</span>
            del <span class="token operator">=</span> extent<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">D</span><span class="token punctuation">(</span><span class="token string">"[%ld]: asking to del: %ld because offset: %d; (ENTIRE NODE: %d), "</span>
          <span class="token string">"node count: %u"</span><span class="token punctuation">,</span>
          extent<span class="token punctuation">,</span> del<span class="token punctuation">,</span> entry<span class="token punctuation">.</span>offset<span class="token punctuation">,</span> delete_entire_node<span class="token punctuation">,</span> node<span class="token operator">-&gt;</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>delete_entire_node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">__quicklistDelNode</span><span class="token punctuation">(</span>quicklist<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">quicklistDecompressNodeForUse</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
            node<span class="token operator">-&gt;</span>zl <span class="token operator">=</span> <span class="token function">ziplistDeleteRange</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>zl<span class="token punctuation">,</span> entry<span class="token punctuation">.</span>offset<span class="token punctuation">,</span> del<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">quicklistNodeUpdateSz</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
            node<span class="token operator">-&gt;</span>count <span class="token operator">-=</span> del<span class="token punctuation">;</span>
            quicklist<span class="token operator">-&gt;</span>count <span class="token operator">-=</span> del<span class="token punctuation">;</span>
            <span class="token function">quicklistDeleteIfEmpty</span><span class="token punctuation">(</span>quicklist<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">)</span>
                <span class="token function">quicklistRecompressOnly</span><span class="token punctuation">(</span>quicklist<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 剩余待删除元素的个数</span>
        extent <span class="token operator">-=</span> del<span class="token punctuation">;</span>
        <span class="token comment">// 下个 quicklistNode</span>
        node <span class="token operator">=</span> next<span class="token punctuation">;</span>
        <span class="token comment">// 从下个 quicklistNode 起始位置开始删除</span>
        entry<span class="token punctuation">.</span>offset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从上面代码可以看出，quicklist 在区间删除时，会先找到 start 所在的 quicklistNode，计算删除的元素是否小于要删除的 count，如果不满足删除的个数，则会移动至下一个 quicklistNode 继续删除，依次循环直到删除完成为止。</p>
<p>quicklistDelRange 函数的返回值为 int 类型，当返回 1 时表示成功的删除了指定区间的元素，返回 0 时表示没有删除任何元素。</p>
<h4 id="3）更多源码"><a href="#3）更多源码" class="headerlink" title="3）更多源码"></a>3）更多源码</h4><p>除了上面介绍的几个常用函数之外，还有一些更多的函数，例如：</p>
<ul>
<li>quicklistCreate：创建 quicklist；</li>
<li>quicklistInsertAfter：在某个元素的后面添加数据；</li>
<li>quicklistInsertBefore：在某个元素的前面添加数据；</li>
<li>quicklistPop：取出并删除列表的第一个或最后一个元素；</li>
<li>quicklistReplaceAtIndex：替换某个元素。</li>
</ul>
<h3 id="6-小结"><a href="#6-小结" class="headerlink" title="6 小结"></a>6 小结</h3><p>通过本文我们可以知道列表类型并不是简单的双向链表，而是采用了 quicklist 的数据结构对数据进行存取，quicklist 是 Redis 3.2 新增的数据类型，它的底层采取的是压缩列表加双向链表的存储结构，quicklist 为了存储更多的数据，会对每个 quicklistNode 节点进行压缩，这样就可以有效的存储更多的消息队列或者文章的数据了。</p>
<h2 id="12-集合使用与内部实现原理"><a href="#12-集合使用与内部实现原理" class="headerlink" title="12 集合使用与内部实现原理"></a>12 集合使用与内部实现原理</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wan-ming-zhu/p/18079410">https://www.cnblogs.com/wan-ming-zhu/p/18079410</a></p>
<p>集合类型 (Set) 是一个无序并唯一的键值集合。</p>
<p>之所以说集合类型是一个无序集合，是因为它的存储顺序不会按照插入的先后顺序进行存储，如下代码所示：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; sadd myset v2 v1 v3 #插入数据 v2、v1、v3 
(integer) 3
127.0.0.1:6379&gt; smembers myset #查询数据
1) "v1"
2) "v3"
3) "v2"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从上面代码执行结果可以看出，myset 的存储顺序并不是以插入的先后顺序进行存储的。</p>
<p>集合类型和列表类型的区别如下：</p>
<ul>
<li>列表可以存储重复元素，集合只能存储非重复元素；</li>
<li>列表是按照元素的先后顺序存储元素的，而集合则是无序方式存储元素的。</li>
</ul>
<h3 id="3-内部实现-1"><a href="#3-内部实现-1" class="headerlink" title="3 内部实现"></a>3 内部实现</h3><p>集合类型是由 intset (整数集合) 或 hashtable (普通哈希表) 组成的。当集合类型以 hashtable 存储时，哈希表的 key 为要插入的元素值，而哈希表的 value 则为 Null，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/集合内部实现.png" alt="集合内部实现"></p>
<p>当集合中所有的值都为整数时，Redis 会使用 intset 结构来存储，如下代码所示：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; sadd myset 1 9 3 -2
(integer) 4
127.0.0.1:6379&gt; object encoding myset
"intset"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>从上面代码可以看出，<strong>当所有元素都为整数时，集合会以 intset 结构进行(数据)存储</strong>。 当发生以下两种情况时，会导致集合类型使用 hashtable 而非 intset 存储：</p>
<ol>
<li>当元素的个数超过一定数量时，默认是 512 个，该值可通过命令 <code>set-max-intset-entries xxx</code> 来配置。</li>
<li><p>当元素为非整数时，集合将会使用 hashtable 来存储，如下代码所示：</p>
 <pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; sadd myht "redis" "db"
(integer) 2
127.0.0.1:6379&gt; object encoding myht
"hashtable"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>从上面代码可以看出，<strong>当元素为非整数时，集合会使用 hashtable 进行存储。</strong></p>
</li>
</ol>
<h3 id="4-源码解析-1"><a href="#4-源码解析-1" class="headerlink" title="4 源码解析"></a>4 源码解析</h3><p>集合源码在 t_set.c 文件中，核心源码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 
 * 添加元素到集合
 * 如果当前值已经存在，则返回 0 不作任何处理，否则就添加该元素，并返回 1。
 */</span>
<span class="token keyword">int</span> <span class="token function">setTypeAdd</span><span class="token punctuation">(</span>robj <span class="token operator">*</span>subject<span class="token punctuation">,</span> sds value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> llval<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>subject<span class="token operator">-&gt;</span>encoding <span class="token operator">==</span> OBJ_ENCODING_HT<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 字典类型</span>
        dict <span class="token operator">*</span>ht <span class="token operator">=</span> subject<span class="token operator">-&gt;</span>ptr<span class="token punctuation">;</span>
        dictEntry <span class="token operator">*</span>de <span class="token operator">=</span> <span class="token function">dictAddRaw</span><span class="token punctuation">(</span>ht<span class="token punctuation">,</span>value<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>de<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 把 value 作为字典到 key，将 Null 作为字典到 value，将元素存入到字典</span>
            <span class="token function">dictSetKey</span><span class="token punctuation">(</span>ht<span class="token punctuation">,</span>de<span class="token punctuation">,</span><span class="token function">sdsdup</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">dictSetVal</span><span class="token punctuation">(</span>ht<span class="token punctuation">,</span>de<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>subject<span class="token operator">-&gt;</span>encoding <span class="token operator">==</span> OBJ_ENCODING_INTSET<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// inset 数据类型</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isSdsRepresentableAsLongLong</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span><span class="token operator">&amp;</span>llval<span class="token punctuation">)</span> <span class="token operator">==</span> C_OK<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            uint8_t success <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            subject<span class="token operator">-&gt;</span>ptr <span class="token operator">=</span> <span class="token function">intsetAdd</span><span class="token punctuation">(</span>subject<span class="token operator">-&gt;</span>ptr<span class="token punctuation">,</span>llval<span class="token punctuation">,</span><span class="token operator">&amp;</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>success<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 超过 inset 的最大存储数量，则使用字典类型存储</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">intsetLen</span><span class="token punctuation">(</span>subject<span class="token operator">-&gt;</span>ptr<span class="token punctuation">)</span> <span class="token operator">&gt;</span> server<span class="token punctuation">.</span>set_max_intset_entries<span class="token punctuation">)</span>
                    <span class="token function">setTypeConvert</span><span class="token punctuation">(</span>subject<span class="token punctuation">,</span>OBJ_ENCODING_HT<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 转化为整数类型失败，使用字典类型存储</span>
            <span class="token function">setTypeConvert</span><span class="token punctuation">(</span>subject<span class="token punctuation">,</span>OBJ_ENCODING_HT<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token function">serverAssert</span><span class="token punctuation">(</span><span class="token function">dictAdd</span><span class="token punctuation">(</span>subject<span class="token operator">-&gt;</span>ptr<span class="token punctuation">,</span><span class="token function">sdsdup</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> DICT_OK<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 未知编码(类型)</span>
        <span class="token function">serverPanic</span><span class="token punctuation">(</span><span class="token string">"Unknown set encoding"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以上这些代码验证了，我们上面所说的内容，当元素都为整数并且元素的个数没有到达设置的最大值时，键值的存储使用的是 intset 的数据结构，反之到元素超过了一定的范围，又或者是存储的元素为非整数时，集合会选择使用 hashtable 的数据结构进行存储。</p>
<h2 id="14-有序集合使用与内部实现原理"><a href="#14-有序集合使用与内部实现原理" class="headerlink" title="14 有序集合使用与内部实现原理"></a>14 有序集合使用与内部实现原理</h2><p>有序集合类型 (Sorted Set) 相比于集合类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序结合的元素值，一个是排序值。有序集合的存储元素值也是不能重复的，但分值是可以重复的。</p>
<h3 id="3-内部实现-2"><a href="#3-内部实现-2" class="headerlink" title="3 内部实现"></a>3 内部实现</h3><p>有序集合是由 ziplist (压缩列表) 或 skiplist (跳跃表) 组成的。</p>
<h4 id="1）ziplist"><a href="#1）ziplist" class="headerlink" title="1）ziplist"></a>1）ziplist</h4><p>当数据比较少时，有序集合使用的是 ziplist 存储的，如下代码所示：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; zadd myzset 1 db 2 redis 3 mysql
(integer) 3
127.0.0.1:6379&gt; object encoding myzset
"ziplist"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>从结果可以看出，有序集合把 myset 键值对存储在 ziplist 结构中了。 有序集合使用 ziplist 格式存储必须满足以下两个条件：</p>
<ul>
<li>有序集合保存的元素个数要小于 128 个；</li>
<li>有序集合保存的所有元素成员的长度都必须小于 64 字节。</li>
</ul>
<p>如果不能满足以上两个条件中的任意一个，有序集合将会使用 skiplist 结构进行存储。 接下来我们来测试以下，当有序集合中某个元素长度大于 64 字节时会发生什么情况？ 代码如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; zadd zmaxleng 1.0 redis
(integer) 1
127.0.0.1:6379&gt; object encoding zmaxleng
"ziplist"
127.0.0.1:6379&gt; zadd zmaxleng 2.0 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
(integer) 1
127.0.0.1:6379&gt; object encoding zmaxleng
"skiplist"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过以上代码可以看出，当有序集合保存的所有元素成员的长度大于 64 字节时，有序集合就会从 ziplist 转换成为 skiplist。</p>
<blockquote>
<p>小贴士：可以通过配置文件中的 <code>zset-max-ziplist-entries</code>（默认 128）和 <code>zset-max-ziplist-value</code>（默认 64）来设置有序集合使用 ziplist 存储的临界值。</p>
</blockquote>
<h4 id="2）skiplist"><a href="#2）skiplist" class="headerlink" title="2）skiplist"></a>2）skiplist</h4><p>skiplist 数据编码底层是使用 zset 结构实现的，而 zset 结构中包含了一个字典和一个跳跃表，源码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zset</span> <span class="token punctuation">{</span>
    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span>
    zskiplist <span class="token operator">*</span>zsl<span class="token punctuation">;</span>
<span class="token punctuation">}</span> zset<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>更多关于跳跃表的源码实现，会在后面的章节详细介绍。</p>
<blockquote>
<p>注意：虽然查看结构时显示的是 skiplist，但它除了使用跳表之外，还使用了哈希表。所以有序集合比较特殊，它是唯一同时使用两种数据结构的类型。这样的好处是既能进行高效的范围查询，也能进行高效的单点查询。</p>
</blockquote>
<h5 id="跳跃表实现原理"><a href="#跳跃表实现原理" class="headerlink" title="跳跃表实现原理"></a>跳跃表实现原理</h5><p>跳跃表的结构如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/跳跃表的结构.png" alt="跳跃表的结构"></p>
<p>根据以上图片展示，当我们在跳跃表中查询值 32 时，执行流程如下：</p>
<ol>
<li>从最上层开始找，1 比 32 小，在当前层移动到下一个节点进行比较；</li>
<li>7 比 32 小，当前层移动下一个节点比较，由于下一个节点指向 Null，所以以 7 为目标，移动到下一层继续向后比较；</li>
<li>18 小于 32，继续向后移动查找，对比 77 大于 32，以 18 为目标，移动到下一层继续向后比较；</li>
<li>对比 32 等于 32，值被顺利找到。</li>
</ol>
<p>从上面的流程可以看出，跳跃表会想从最上层开始找起，依次向后查找，如果本层的节点大于要找的值，或者本层的节点为 Null 时，以上一个节点为目标，往下移一层继续向后查找并循环此流程，直到找到该节点并返回，如果对比到最后一个元素仍未找到，则返回 Null。</p>
<h5 id="为什么是跳跃表？而非红黑树？"><a href="#为什么是跳跃表？而非红黑树？" class="headerlink" title="为什么是跳跃表？而非红黑树？"></a>为什么是跳跃表？而非红黑树？</h5><p>因为跳跃表的性能和红黑树基本相近，但却比红黑树更好实现，所有 Redis 的有序集合会选用跳跃表来实现存储。</p>
<h2 id="16-Redis-事务深入解析"><a href="#16-Redis-事务深入解析" class="headerlink" title="16 Redis 事务深入解析"></a>16 Redis 事务深入解析</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wan-ming-zhu/p/18079959">https://www.cnblogs.com/wan-ming-zhu/p/18079959</a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>事务指的是提供一种将多个命令打包，一次性按顺序地执行的机制，并且保证服务器只有在执行完事务中的所有命令后，才会继续处理此客户端的其他命令。</p>
<p>事务也是其他关系型数据库所必备的基础功能，以支付的场景为例，正常情况下只有正常消费完成之后，才会减去账户余额。但如果没有事务的保障，可能会发生消费失败了，但依旧会把账户的余额给扣减了，我想这种情况应该任何人都无法接受吧？所以事务是数据库中一项非常重要的基础功能。</p>
<h3 id="事务基本使用"><a href="#事务基本使用" class="headerlink" title="事务基本使用"></a>事务基本使用</h3><p>Redis 中的事务从开始到结束也是要经历三个阶段：</p>
<ul>
<li>开启事务</li>
<li>命令入列</li>
<li>执行事务/放弃事务</li>
</ul>
<p>其中，开启事务使用 multi 命令，事务执行使用 exec 命令，放弃事务使用 discard 命令。</p>
<h4 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h4><p>multi 命令用于开启事务，实现代码如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt; multi
OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>multi 命令可以让客户端从非事务模式状态，变为事务模式状态，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/multi.png" alt="multi"></p>
<p>注意：multi 命令不能嵌套使用，如果已经开启了事务的情况下，再执行 multi 命令，会提示如下错误：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; multi
OK
127.0.0.1:6379&gt; multi
(error) ERR MULTI calls can not be nested<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="命令入列"><a href="#命令入列" class="headerlink" title="命令入列"></a>命令入列</h4><p>客户端进入事务状态之后，执行的所有常规 Redis 操作命令（非触发事务执行或放弃和导致入列异常的命令）会依次入列，命令入列成功后会返回 QUEUED，如下代码所示：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt; multi
OK
&gt; set k v
QUEUED
&gt; get k
QUEUED<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/Redis事务状态后命令执行流程.png" alt="Redis事务状态后命令执行流程"></p>
<p>注意：命令会按照先进先出（FIFO）的顺序出入列，也就是说事务会按照命令的入列顺序，从前往后依次执行。</p>
<h4 id="执行事务-放弃事务"><a href="#执行事务-放弃事务" class="headerlink" title="执行事务/放弃事务"></a>执行事务/放弃事务</h4><p>执行事务的命令是 exec，放弃事务的命令是 discard。</p>
<p>执行事务示例代码如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt; multi
OK
&gt; set k v2
QUEUED
&gt; exec
1) OK
&gt; get k
"v2"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>放弃事务示例代码如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt; multi
OK
&gt; set k v3
QUEUED
&gt; discard
OK
&gt; get k
"v2"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/Redis执行事务放弃事务.png" alt="Redis执行事务放弃事务"></p>
<h3 id="事务错误-amp-回滚"><a href="#事务错误-amp-回滚" class="headerlink" title="事务错误&amp;回滚"></a>事务错误&amp;回滚</h3><p>事务执行中的错误分为以下三类：</p>
<ul>
<li>执行时才会出现的错误（简称：执行时错误）；</li>
<li>入列时错误，不会终止整个事务；</li>
<li>入列时错误，会终止整个事务。</li>
</ul>
<h4 id="执行时错误"><a href="#执行时错误" class="headerlink" title="执行时错误"></a>执行时错误</h4><p>示例代码如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt; get k
"v"
&gt; multi
OK
&gt; set k v2
QUEUED
&gt; expire k 10s
QUEUED
&gt; exec
1) OK
2) (error) ERR value is not an integer or out of range
&gt; get k
"v2"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>执行命令解释如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/执行时才会出现的错误.png" alt="执行时才会出现的错误"></p>
<p>从以上结果可以看出，即使事务队列中某个命令在执行期间发生了错误，事务也会继续执行，直到事务队列中所有命令执行完成。</p>
<h4 id="入列错误不会导致事务结束"><a href="#入列错误不会导致事务结束" class="headerlink" title="入列错误不会导致事务结束"></a>入列错误不会导致事务结束</h4><p>示例代码如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt; get k
"v"
&gt; multi
OK
&gt; set k v2
QUEUED
&gt; multi
(error) ERR MULTI calls can not be nested
&gt; exec
1) OK
&gt; get k
"v2"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>执行命令解释如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/入列错误不会导致事务结束.png" alt="入列错误不会导致事务结束"></p>
<p>可以看出，重复执行 multi 会导致入列错误，但不会终止事务，最终查询的结果是事务执行成功了。除了重复执行 multi 命令，还有在事务状态下执行 watch 也是同样的效果，下文会详细讲解关于 watch 的内容。</p>
<h4 id="入列错误导致事务结束"><a href="#入列错误导致事务结束" class="headerlink" title="入列错误导致事务结束"></a>入列错误导致事务结束</h4><p>示例代码如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt; get k
"v2"
&gt; multi
OK
&gt; set k v3
QUEUED
&gt; set k
(error) ERR wrong number of arguments for 'set' command
&gt; exec
(error) EXECABORT Transaction discarded because of previous errors.
&gt; get k
"v2"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>执行命令解释如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/入列错误导致事务结束.png" alt="入列错误导致事务结束"></p>
<p>所以我们看到错误可以分为两种：一种是事务执行时才会发现的错误；另一种是在入队的时候就能发现的错误。</p>
<ul>
<li>执行时出现的错误，不会影响事务队列中的其它命令；即使某条命令失败，其它命令依旧可以正常执行；</li>
<li>入队时发现的错误，如果是 multi、watch 这种错误也不会终止事务，只是不会让它入队；但如果是命令不符合 Redis 的规则，那么这种错误就类似于编程语言的语法错误，直接编译时就报错，没必要等到执行了。所以在 Redis 中的表现就是整个事务都废弃掉，里面的命令一条也不会执行；</li>
</ul>
<h4 id="为什么不支持事务回滚？"><a href="#为什么不支持事务回滚？" class="headerlink" title="为什么不支持事务回滚？"></a>为什么不支持事务回滚？</h4><p>Redis 官方文档的解释如下：</p>
<blockquote>
<p>If you have a relational databases background, the fact that Redis commands can fail during a transaction, but still Redis will execute the rest of the transaction instead of rolling back, may look odd to you.</p>
<p>However there are good opinions for this behavior:</p>
<ul>
<li>Redis commands can fail only if called with a wrong syntax (and the problem is not detectable during the command queueing), or against keys holding the wrong data type: this means that in practical terms a failing command is the result of a programming errors, and a kind of error that is very likely to be detected during development, and not in production.</li>
<li>Redis is internally simplified and faster because it does not need the ability to roll back.</li>
</ul>
<p>An argument against Redis point of view is that bugs happen, however it should be noted that in general the roll back does not save you from programming errors. For instance if a query increments a key by 2 instead of 1, or increments the wrong key, there is no way for a rollback mechanism to help. Given that no one can save the programmer from his or her errors, and that the kind of errors required for a Redis command to fail are unlikely to enter in production, we selected the simpler and faster approach of not supporting roll backs on errors.</p>
</blockquote>
<p>大概的意思是，作者不支持事务回滚的原因有以下两个：</p>
<ul>
<li>他认为 Redis 事务的执行时，错误通常都是编程错误造成的，这种错误通常只会出现在开发环境中，而很少会在实际的生产环境中出现，所以他认为没有必要为 Redis 开发事务回滚功能；</li>
<li>不支持事务回滚是因为这种复杂的功能和 Redis 追求的简单高效的设计主旨不符合。</li>
</ul>
<blockquote>
<p>这里不支持事务回滚，指的是不支持运行时错误的事务回滚。</p>
</blockquote>
<h4 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h4><p>watch 命令用于客户端并发情况下，为事务提供一个乐观锁（CAS，Check And Set），也就是可以用 watch 命令来监控一个或多个变量，如果在事务的过程中，<strong>某个监控项被修改了，那么整个事务就会终止执行。</strong></p>
<p>watch 基本语法如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">watch key [key ...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>watch 示例代码如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt; watch k
OK
&gt; multi
OK
&gt; set k v2
QUEUED
&gt; exec
(nil)
&gt; get k
"v"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意：以上事务在执行期间，也就是开启事务（multi）之后，执行事务（exec）之前，模拟多客户端并发操作了变量 k 的值，这个时候再去执行事务，才会出现如上结果，exec 执行的结果为 nil。</p>
<p>可以看出，当执行 exec 返回的结果是 nil 时，表示 watch 监控的对象在事务执行的过程中被修改了。从 get k 的结果也可以印证，因为事务中设置的值 <code>set k v2</code> 并未正常执行。</p>
<p>执行流程如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/watch执行流程.png" alt="watch执行流程"></p>
<p>注意： watch 命令只能在客户端开启事务之前执行，在事务中执行 watch 命令会引发错误，但不会造成整个事务失败，如下代码所示：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt; multi
OK
&gt; set k v3
QUEUED
&gt; watch k
(error) ERR WATCH inside MULTI is not allowed
&gt; exec
1) OK
&gt; get k
"v3"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>执行命令解释如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/watch执行命令解释.png" alt="watch执行命令解释"></p>
<blockquote>
<p>一个 watch 对应一个事务，watch 之后只要执行了事务，不管里面的命令是成功还是失败，这个 watch 就算是结束了。再次开启事务，设置的 key 就是不被监视的 key 了。</p>
</blockquote>
<p>unwatch 命令用于清除所有之前监控的所有对象（键值对）。</p>
<p>unwatch 示例如下所示：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt; set k v
OK
&gt; watch k
OK
&gt; multi
OK
&gt; unwatch
QUEUED
&gt; set k v2
QUEUED
&gt; exec
1) OK
2) OK
&gt; get k
"v2"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出，即使在事务的执行过程中，k 值被修改了，因为调用了 unwatch 命令，整个事务依然会顺利执行。</p>
<h4 id="知识点练习"><a href="#知识点练习" class="headerlink" title="知识点练习"></a>知识点练习</h4><p>以下两个客户端交替执行的结果是？</p>
<p>客户端一，执行如下命令：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt; set k v
OK
&gt; watch k
OK
&gt; multi
OK
&gt; set k v2
QUEUED<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>客户端二，执行如下命令：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt; set k v
OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>客户端一，再执行如下命令：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt; exec<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>此时 k 的值为多少？</p>
<p>答： k 的值为 v，而非 v2。</p>
<p>题目解析：本题考查的是 watch 命令监控时，即使把原对象的值重新赋值给了原对象，这个时候 watch 命令也会认为监控对象还是被修改了。</p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>事务为多个命令提供一次性按顺序执行的机制，与 Redis 事务相关的命令有以下五个：</p>
<ul>
<li>multi：开启事务</li>
<li>exec：执行事务</li>
<li>discard：丢弃事务</li>
<li>watch：为事务提供乐观锁实现</li>
<li>unwatch：取消监控（取消事务中的乐观锁）</li>
</ul>
<p>正常情况下 Redis 事务分为三个阶段：开启事务、命令入列、执行事务。Redis 事务并不支持运行时错误的事务回滚，但在某些入列错误，如 set key 或者是 watch 监控项被修改时，提供整个事务回滚的功能。</p>
<h2 id="17-Redis-键值过期操作"><a href="#17-Redis-键值过期操作" class="headerlink" title="17 Redis 键值过期操作"></a>17 Redis 键值过期操作</h2><h3 id="过期设置"><a href="#过期设置" class="headerlink" title="过期设置"></a>过期设置</h3><p>Redis 中设置过期时间主要通过以下四种方式：</p>
<ul>
<li><code>expire key seconds</code>：设置 key 在 n 秒后过期；</li>
<li><code>pexpire key milliseconds</code>：设置 key 在 n 毫秒后过期；</li>
<li><code>expireat key timestamp</code>：设置 key 在某个时间戳（精确到秒）之后过期；</li>
<li><code>pexpireat key millisecondsTimestamp</code>：设置 key 在某个时间戳（精确到毫秒）之后过期；</li>
</ul>
<h3 id="字符串中的过期操作"><a href="#字符串中的过期操作" class="headerlink" title="字符串中的过期操作"></a>字符串中的过期操作</h3><p>字符串中几个直接操作过期时间的方法，如下列表：</p>
<ul>
<li><code>set key value ex seconds</code>：设置键值对的同时指定过期时间（精确到秒）；<br>-<code>set key value px milliseconds</code>：设置键值对的同时指定过期时间（精确到毫秒）；</li>
<li><code>setex key seconds valule</code>：设置键值对的同时指定过期时间（精确到秒）。</li>
</ul>
<h3 id="移除过期时间"><a href="#移除过期时间" class="headerlink" title="移除过期时间"></a>移除过期时间</h3><p>使用命令： persist key 可以移除键值的过期时间。</p>
<h3 id="持久化中的过期键"><a href="#持久化中的过期键" class="headerlink" title="持久化中的过期键"></a>持久化中的过期键</h3><p>Redis 持久化文件有两种格式：RDB（Redis Database）和 AOF（Append Only File），下面我们分别来看过期键在这两种格式中的呈现状态。</p>
<h4 id="RDB-中的过期键"><a href="#RDB-中的过期键" class="headerlink" title="RDB 中的过期键"></a>RDB 中的过期键</h4><p>RDB 文件分为两个阶段，RDB 文件生成阶段和加载阶段。</p>
<h5 id="1-RDB-文件生成"><a href="#1-RDB-文件生成" class="headerlink" title="1. RDB 文件生成"></a>1. RDB 文件生成</h5><p>从内存状态持久化成 RDB（文件）的时候，会对 key 进行过期检查，过期的键不会被保存到新的 RDB 文件中，因此 Redis 中的过期键不会对生成新 RDB 文件产生任何影响。</p>
<h5 id="2-RDB-文件加载"><a href="#2-RDB-文件加载" class="headerlink" title="2. RDB 文件加载"></a>2. RDB 文件加载</h5><p>RDB 加载分为以下两种情况：</p>
<ul>
<li>如果 Redis 是主服务器运行模式的话，在载入 RDB 文件时，程序会对文件中保存的键进行检查，过期键不会被载入到数据库中。所以过期键不会对载入 RDB 文件的主服务器造成影响；</li>
<li>如果 Redis 是从服务器运行模式的话，在载入 RDB 文件时，不论键是否过期都会被载入到数据库中。但由于主从服务器在进行数据同步时，从服务器的数据会被清空。所以一般来说，过期键对载入 RDB 文件的从服务器也不会造成影响。</li>
</ul>
<p>RDB 文件加载的源码可以在 rdb.c 文件的 rdbLoad() 函数中找到，源码所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Check if the key already expired. This function is used when loading
* an RDB file from disk, either at startup, or when an RDB was
* received from the master. In the latter case, the master is
* responsible for key expiry. If we would expire keys here, the
* snapshot taken by the master may not be reflected on the slave. 
*
* 如果服务器为主节点的话，
* 那么在键已经过期的时候，不再将它们关联到数据库中去
*/</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>masterhost <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> expiretime <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> expiretime <span class="token operator">&lt;</span> now<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">decrRefCount</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">decrRefCount</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 跳过</span>
    <span class="token keyword">continue</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="AOF-中的过期键"><a href="#AOF-中的过期键" class="headerlink" title="AOF 中的过期键"></a>AOF 中的过期键</h4><h5 id="1-AOF-文件写入"><a href="#1-AOF-文件写入" class="headerlink" title="1. AOF 文件写入"></a>1. AOF 文件写入</h5><p>当 Redis 以 AOF 模式持久化时，如果数据库某个过期键还没被删除，那么 AOF 文件会保留此过期键，当此过期键被删除后，Redis 会向 AOF 文件追加一条 DEL 命令来显式地删除该键值。</p>
<h5 id="2-AOF-重写"><a href="#2-AOF-重写" class="headerlink" title="2. AOF 重写"></a>2. AOF 重写</h5><p>执行 AOF 重写时，会对 Redis 中的键值对进行检查已过期的键不会被保存到重写后的 AOF 文件中，因此不会对 AOF 重写造成任何影响。</p>
<h4 id="主从库的过期键"><a href="#主从库的过期键" class="headerlink" title="主从库的过期键"></a>主从库的过期键</h4><p>当 Redis 运行在主从模式下时，从库不会进行过期扫描，从库对过期的处理是被动的。也就是即使从库中的 key 过期了，如果有客户端访问从库时，依然可以得到 key 对应的值，像未过期的键值对一样返回。</p>
<p>从库的过期键处理依靠主服务器控制，主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库，从库通过执行这条 del 指令来删除过期的 key。</p>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/Redis键值过期操作小结.png" alt="Redis键值过期操作小结"></p>
<h2 id="18-Redis-过期策略与源码分析"><a href="#18-Redis-过期策略与源码分析" class="headerlink" title="18 Redis 过期策略与源码分析"></a>18 Redis 过期策略与源码分析</h2><h3 id="过期键执行流程"><a href="#过期键执行流程" class="headerlink" title="过期键执行流程"></a>过期键执行流程</h3><p>Redis 之所以能知道那些键值过期，是因为在 Redis 中维护了一个字典，存储了所有设置了过期时间的键值，我们称之为过期字典。</p>
<p>过期键判断流程如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/过期键判断流程.png" alt="过期键判断流程"></p>
<h3 id="过期键源码分析"><a href="#过期键源码分析" class="headerlink" title="过期键源码分析"></a>过期键源码分析</h3><p>过期键存储在 redisDb 结构中，源代码在 src/server.h 文件中</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Redis database representation. There are multiple databases identified
 * by integers from 0 (the default database) up to the max configured
 * database. The database number is the 'id' field in the structure. */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisDb</span> <span class="token punctuation">{</span>
    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span>                 <span class="token comment">/* 数据库键空间，存放着所有的键值对 */</span>
    dict <span class="token operator">*</span>expires<span class="token punctuation">;</span>              <span class="token comment">/* 键的过期时间 */</span>
    dict <span class="token operator">*</span>blocking_keys<span class="token punctuation">;</span>        <span class="token comment">/* Keys with clients waiting for data (BLPOP)*/</span>
    dict <span class="token operator">*</span>ready_keys<span class="token punctuation">;</span>           <span class="token comment">/* Blocked keys that received a PUSH */</span>
    dict <span class="token operator">*</span>watched_keys<span class="token punctuation">;</span>         <span class="token comment">/* WATCHED keys for MULTI/EXEC CAS */</span>
    <span class="token keyword">int</span> id<span class="token punctuation">;</span>                     <span class="token comment">/* Database ID */</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> avg_ttl<span class="token punctuation">;</span>          <span class="token comment">/* Average TTL, just for stats */</span>
    list <span class="token operator">*</span>defrag_later<span class="token punctuation">;</span>         <span class="token comment">/* List of key names to attempt to defrag one by one, gradually. */</span>
<span class="token punctuation">}</span> redisDb<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>小贴士：本文的所有源码都是基于 Redis 5。</p>
</blockquote>
<h3 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h3><p>Redis 会删除已过期的键值，以此来减少 Redis 的空间占用，但因为 Redis 本身是单线的，如果因为删除操作而影响主业务的执行就得不偿失了，为此 Redis 需要制定多个（过期）删除策略来保证糟糕的事情不会发生。</p>
<p>常见的过期策略有以下几种：</p>
<ul>
<li>惰性删除</li>
<li>定期删除</li>
</ul>
<p>下面分别来看每种策略有何不同。</p>
<h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><p>不主动删除过期键，每次从数据库获取键值时判断是否过期，如果过期则删除键值，并返回 null。</p>
<ul>
<li>优点：因为每次访问时，才会判断过期键，所以此策略只会使用很少的系统资源。</li>
<li>缺点：系统占用空间删除不及时，导致空间利用率降低，造成了一定的空间浪费。</li>
</ul>
<h5 id="源码解析-1"><a href="#源码解析-1" class="headerlink" title="源码解析"></a>源码解析</h5><p>惰性删除的源码位于 src/db.c 文件的 expireIfNeeded 方法中，源码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">expireIfNeeded</span><span class="token punctuation">(</span>redisDb <span class="token operator">*</span>db<span class="token punctuation">,</span> robj <span class="token operator">*</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 判断键是否过期</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">keyIsExpired</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>masterhost <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">/* 删除过期键 */</span>
    <span class="token comment">// 增加过期键个数</span>
    server<span class="token punctuation">.</span>stat_expiredkeys<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token comment">// 传播键过期的消息</span>
    <span class="token function">propagateExpire</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>key<span class="token punctuation">,</span>server<span class="token punctuation">.</span>lazyfree_lazy_expire<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">notifyKeyspaceEvent</span><span class="token punctuation">(</span>NOTIFY_EXPIRED<span class="token punctuation">,</span>
        <span class="token string">"expired"</span><span class="token punctuation">,</span>key<span class="token punctuation">,</span>db<span class="token operator">-&gt;</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// server.lazyfree_lazy_expire 为 1 表示异步删除（懒空间释放），反之同步删除</span>
    <span class="token keyword">return</span> server<span class="token punctuation">.</span>lazyfree_lazy_expire <span class="token operator">?</span> <span class="token function">dbAsyncDelete</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>key<span class="token punctuation">)</span> <span class="token operator">:</span>
                                         <span class="token function">dbSyncDelete</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 判断键是否过期</span>
<span class="token keyword">int</span> <span class="token function">keyIsExpired</span><span class="token punctuation">(</span>redisDb <span class="token operator">*</span>db<span class="token punctuation">,</span> robj <span class="token operator">*</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    mstime_t when <span class="token operator">=</span> <span class="token function">getExpire</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>when <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">/* No expire for this key */</span>
    <span class="token comment">/* Don't expire anything while loading. It will be done later. */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>loading<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    mstime_t now <span class="token operator">=</span> server<span class="token punctuation">.</span>lua_caller <span class="token operator">?</span> server<span class="token punctuation">.</span>lua_time_start <span class="token operator">:</span> <span class="token function">mstime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> now <span class="token operator">&gt;</span> when<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 获取键的过期时间</span>
<span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">getExpire</span><span class="token punctuation">(</span>redisDb <span class="token operator">*</span>db<span class="token punctuation">,</span> robj <span class="token operator">*</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    dictEntry <span class="token operator">*</span>de<span class="token punctuation">;</span>
    <span class="token comment">/* No expire? return ASAP */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dictSize</span><span class="token punctuation">(</span>db<span class="token operator">-&gt;</span>expires<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span>
       <span class="token punctuation">(</span>de <span class="token operator">=</span> <span class="token function">dictFind</span><span class="token punctuation">(</span>db<span class="token operator">-&gt;</span>expires<span class="token punctuation">,</span>key<span class="token operator">-&gt;</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">/* The entry was found in the expire dict, this means it should also
     * be present in the main dict (safety check). */</span>
    <span class="token function">serverAssertWithInfo</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span>key<span class="token punctuation">,</span><span class="token function">dictFind</span><span class="token punctuation">(</span>db<span class="token operator">-&gt;</span>dict<span class="token punctuation">,</span>key<span class="token operator">-&gt;</span>ptr<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">dictGetSignedIntegerVal</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>所有对数据库的读写命令在执行之前，都会调用 expireIfNeeded 方法判断键值是否过期，过期则会从数据库中删除，反之则不做任何处理。</p>
<p>惰性删除执行流程，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/惰性删除执行流程.png" alt="惰性删除执行流程"></p>
<h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><p>每隔一段时间检查一次数据库，随机删除一些过期键。</p>
<p>Redis 默认每秒进行 10 次过期扫描，此配置可通过 Redis 的配置文件 redis.conf 进行配置，配置键为 hz 它的默认值是 hz 10。</p>
<p>需要注意的是：Redis 每次扫描并不是遍历过期字典中的所有键，而是采用随机抽取判断并删除过期键的形式执行的。</p>
<h5 id="定期删除流程"><a href="#定期删除流程" class="headerlink" title="定期删除流程"></a>定期删除流程</h5><ol>
<li>从过期字典中随机取出 20 个键；</li>
<li>删除这 20 个键中过期的键；</li>
<li>如果过期 key 的比例超过 25%，重复步骤 1。</li>
</ol>
<p>同时为了保证过期扫描不会出现循环过度，导致线程卡死现象，算法还增加了扫描时间的上限，默认不会超过 25ms。</p>
<p>定期删除执行流程，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/定期删除执行流程.png" alt="定期删除执行流程"></p>
<ul>
<li>优点：通过限制删除操作的时长和频率，来减少删除操作对 Redis 主业务的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用。</li>
<li>缺点：内存清理方面没有定时删除效果好，同时没有惰性删除使用的系统资源少。</li>
</ul>
<h5 id="源码解析-2"><a href="#源码解析-2" class="headerlink" title="源码解析"></a>源码解析</h5><p>定期删除的核心源码在 src/expire.c 文件下的 activeExpireCycle 方法中，源码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">activeExpireCycle</span><span class="token punctuation">(</span><span class="token keyword">int</span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> current_db <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">/* 上次定期删除遍历到的数据库ID */</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> timelimit_exit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token comment">/* Time limit hit in previous call? */</span>
    <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token keyword">long</span> last_fast_cycle <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">/* 上一次执行快速定期删除的时间点 */</span>
    <span class="token keyword">int</span> j<span class="token punctuation">,</span> iteration <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> dbs_per_call <span class="token operator">=</span> CRON_DBS_PER_CALL<span class="token punctuation">;</span> <span class="token comment">// 每次定期删除，遍历的数据库的数量</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token function">ustime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> timelimit<span class="token punctuation">,</span> elapsed<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">clientsArePaused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> ACTIVE_EXPIRE_CYCLE_FAST<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timelimit_exit<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token comment">// ACTIVE_EXPIRE_CYCLE_FAST_DURATION 是快速定期删除的执行时长</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> last_fast_cycle <span class="token operator">+</span> ACTIVE_EXPIRE_CYCLE_FAST_DURATION<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        last_fast_cycle <span class="token operator">=</span> start<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>dbs_per_call <span class="token operator">&gt;</span> server<span class="token punctuation">.</span>dbnum <span class="token operator">||</span> timelimit_exit<span class="token punctuation">)</span>
        dbs_per_call <span class="token operator">=</span> server<span class="token punctuation">.</span>dbnum<span class="token punctuation">;</span>
    <span class="token comment">// 慢速定期删除的执行时长</span>
    timelimit <span class="token operator">=</span> <span class="token number">1000000</span><span class="token operator">*</span>ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC<span class="token operator">/</span>server<span class="token punctuation">.</span>hz<span class="token operator">/</span><span class="token number">100</span><span class="token punctuation">;</span>
    timelimit_exit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>timelimit <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> timelimit <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> ACTIVE_EXPIRE_CYCLE_FAST<span class="token punctuation">)</span>
        timelimit <span class="token operator">=</span> ACTIVE_EXPIRE_CYCLE_FAST_DURATION<span class="token punctuation">;</span> <span class="token comment">/* 删除操作的执行时长 */</span>
    <span class="token keyword">long</span> total_sampled <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> total_expired <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> dbs_per_call <span class="token operator">&amp;&amp;</span> timelimit_exit <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> expired<span class="token punctuation">;</span>
        redisDb <span class="token operator">*</span>db <span class="token operator">=</span> server<span class="token punctuation">.</span>db<span class="token operator">+</span><span class="token punctuation">(</span>current_db <span class="token operator">%</span> server<span class="token punctuation">.</span>dbnum<span class="token punctuation">)</span><span class="token punctuation">;</span>
        current_db<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">do</span> <span class="token punctuation">{</span>
            <span class="token comment">// .......</span>
            expired <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            ttl_sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            ttl_samples <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token comment">// 每个数据库中检查的键的数量</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">&gt;</span> ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP<span class="token punctuation">)</span>
                num <span class="token operator">=</span> ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP<span class="token punctuation">;</span>
            <span class="token comment">// 从数据库中随机选取 num 个键进行检查</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>num<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                dictEntry <span class="token operator">*</span>de<span class="token punctuation">;</span>
                <span class="token keyword">long</span> <span class="token keyword">long</span> ttl<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>de <span class="token operator">=</span> <span class="token function">dictGetRandomKey</span><span class="token punctuation">(</span>db<span class="token operator">-&gt;</span>expires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
                ttl <span class="token operator">=</span> dictGetSignedInteger
                <span class="token comment">// 过期检查，并对过期键进行删除</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">activeExpireCycleTryExpire</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>de<span class="token punctuation">,</span>now<span class="token punctuation">)</span><span class="token punctuation">)</span> expired<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>ttl <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">/* We want the average TTL of keys yet not expired. */</span>
                    ttl_sum <span class="token operator">+=</span> ttl<span class="token punctuation">;</span>
                    ttl_samples<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                total_sampled<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            total_expired <span class="token operator">+=</span> expired<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>ttl_samples<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">long</span> <span class="token keyword">long</span> avg_ttl <span class="token operator">=</span> ttl_sum<span class="token operator">/</span>ttl_samples<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>db<span class="token operator">-&gt;</span>avg_ttl <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> db<span class="token operator">-&gt;</span>avg_ttl <span class="token operator">=</span> avg_ttl<span class="token punctuation">;</span>
                db<span class="token operator">-&gt;</span>avg_ttl <span class="token operator">=</span> <span class="token punctuation">(</span>db<span class="token operator">-&gt;</span>avg_ttl<span class="token operator">/</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">49</span> <span class="token operator">+</span> <span class="token punctuation">(</span>avg_ttl<span class="token operator">/</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>iteration <span class="token operator">&amp;</span> <span class="token number">0xf</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* check once every 16 iterations. */</span>
                elapsed <span class="token operator">=</span> <span class="token function">ustime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>start<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>elapsed <span class="token operator">&gt;</span> timelimit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    timelimit_exit <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                    server<span class="token punctuation">.</span>stat_expired_time_cap_reached_count<span class="token operator">++</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment">/* 每次检查只删除 ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP/4 个过期键 */</span>
        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>expired <span class="token operator">&gt;</span> ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP<span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// .......</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>activeExpireCycle 方法在规定的时间，分多次遍历各个数据库，从过期字典中随机检查一部分过期键的过期时间，删除其中的过期键。</p>
<p>这个函数有两种执行模式，一个是快速模式一个是慢速模式，体现是代码中的 timelimit 变量，这个变量是用来约束此函数的运行时间的。<br>快速模式下 timelimit 的值是固定的，等于预定义常量 <code>ACTIVE_EXPIRE_CYCLE_FAST_DURATION</code>，慢速模式下，这个变量的值是通过 <code>1000000*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/100</code> 计算的。</p>
<h4 id="Redis-使用的过期策略"><a href="#Redis-使用的过期策略" class="headerlink" title="Redis 使用的过期策略"></a>Redis 使用的过期策略</h4><p>Redis 使用的是惰性删除加定期删除的过期策略。</p>
<h2 id="19-Redis-管道技术——Pipeline"><a href="#19-Redis-管道技术——Pipeline" class="headerlink" title="19 Redis 管道技术——Pipeline"></a>19 Redis 管道技术——Pipeline</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wan-ming-zhu/p/18079991">https://www.cnblogs.com/wan-ming-zhu/p/18079991</a></p>
<p>管道技术（Pipeline）是客户端提供的一种批处理技术，用于一次处理多个 Redis 命令，从而提高整个交互的性能。</p>
<p>通常情况下 Redis 是单行执行的，客户端先向服务器发送请求，服务端接收并处理请求后再把结果返回给客户端，这种处理模式在非频繁请求时不会有任何问题。</p>
<p>但如果出现集中大批量的请求时，因为每个请求都要经历先请求再响应的过程，这就会造成网络资源浪费，此时就需要管道技术来把所有的命令整合一次发给服务端，再一次响应给客户端，这样就能大大的提升了 Redis 的响应速度。</p>
<p>普通命令模式，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/普通命令模式.png" alt="普通命令模式"></p>
<p>管道模式，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/管道模式.png" alt="管道模式"></p>
<blockquote>
<p>小贴士：管道中命令越多，管道技术的作用就更大，相比于普通模式来说执行效率就越高。</p>
</blockquote>
<h3 id="管道技术解决了什么问题？"><a href="#管道技术解决了什么问题？" class="headerlink" title="管道技术解决了什么问题？"></a>管道技术解决了什么问题？</h3><p>管道技术解决了多个命令集中请求时造成网络资源浪费的问题，加快了 Redis 的响应速度，让 Redis 拥有更高的运行速度。但要注意的一点是，管道技术本质上是客户端提供的功能，而非 Redis 服务器端的功能。</p>
<h3 id="管道技术需要注意的事项"><a href="#管道技术需要注意的事项" class="headerlink" title="管道技术需要注意的事项"></a>管道技术需要注意的事项</h3><p>管道技术虽然有它的优势，但在使用时还需注意以下几个细节：</p>
<ul>
<li>发送的命令数量不会被限制，但输入缓存区也就是命令的最大存储体积为 1GB，当发送的命令超过此限制时，命令不会被执行，并且会被 Redis 服务器端断开此链接；</li>
<li>如果管道的数据过多可能会导致客户端的等待时间过长，导致网络阻塞；</li>
<li>部分客户端自己本身也有缓存区大小的设置，如果管道命令没有没执行或者是执行不完整，可以排查此情况或较少管道内的命令重新尝试执行。</li>
</ul>
<h2 id="20-查询附近的人——GEO"><a href="#20-查询附近的人——GEO" class="headerlink" title="20 查询附近的人——GEO"></a>20 查询附近的人——GEO</h2><p>Redis 在 3.2 版本中增加了 GEO 类型用于存储和查询地理位置，关于 GEO 的命令不多，主要包含以下 6 个：</p>
<ul>
<li>geoadd：添加地理位置</li>
<li>geopos：查询位置信息</li>
<li>geodist：距离统计</li>
<li>georadius：查询某位置内的其他成员信息</li>
<li>geohash：查询位置的哈希值</li>
<li>zrem：删除地理位置</li>
</ul>
<h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>GEO 是 Redis 3.2 版本中新增的功能，只有升级到 3.2+ 才能使用，GEO 本质上是基于 ZSet 实现的，这点在 Redis 源码找到相关信息，我们可以 GEO 使用实现查找附近的人或者附近的地点，还可以用它来计算两个位置相隔的直线距离。</p>
<h2 id="21-游标迭代器（过滤器）——Scan"><a href="#21-游标迭代器（过滤器）——Scan" class="headerlink" title="21 游标迭代器（过滤器）——Scan"></a>21 游标迭代器（过滤器）——Scan</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wan-ming-zhu/p/18080118">https://www.cnblogs.com/wan-ming-zhu/p/18080118</a></p>
<p>Redis 2.8 时推出了 Scan。</p>
<p>官方文档地址：<a target="_blank" rel="noopener" href="https://redis.io/commands/scan">https://redis.io/commands/scan</a></p>
<p>翻译为中文的含义是：Scan 及它的相关命令可以保证以下查询规则。</p>
<ul>
<li>它可以完整返回开始到结束检索集合中出现的所有元素，也就是在整个查询过程中如果这些元素没有被删除，且符合检索条件，则一定会被查询出来；</li>
<li>它可以保证不会查询出，在开始检索之前删除的那些元素。</li>
</ul>
<p>然后，Scan 命令包含以下缺点：</p>
<ul>
<li>一个元素可能被返回多次，需要客户端来实现去重；</li>
<li>在迭代过程中如果有元素被修改，那么修改的元素能不能被遍历到不确定。 (Elements that were not constantly present in the collection during a full iteration, may be returned or not: it is undefined.)</li>
</ul>
<h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><p>通过本文我们可以知道 Scan 包含以下四个指令：</p>
<ul>
<li>Scan：用于检索当前数据库中所有数据；</li>
<li>HScan：用于检索哈希类型的数据；</li>
<li>SScan：用于检索集合类型中的数据；</li>
<li>ZScan：由于检索有序集合中的数据。</li>
</ul>
<p>Scan 具备以下几个特点：</p>
<ol>
<li>Scan 可以实现 keys 的匹配功能；</li>
<li>Scan 是通过游标进行查询的不会导致 Redis 假死；</li>
<li>Scan 提供了 count 参数，可以规定遍历的数量；</li>
<li>Scan 会把游标返回给客户端，用户客户端继续遍历查询；</li>
<li>Scan 返回的结果可能会有重复数据，需要客户端去重；</li>
<li>单次返回空值且游标不为 0，说明遍历还没结束；</li>
<li>Scan 可以保证在开始检索之前，被删除的元素一定不会被查询出来；</li>
<li>在迭代过程中如果有元素被修改， Scan 不保证能查询出相关的元素。</li>
</ol>
<h2 id="22-优秀的基数统计算法——HyperLogLog"><a href="#22-优秀的基数统计算法——HyperLogLog" class="headerlink" title="22 优秀的基数统计算法——HyperLogLog"></a>22 优秀的基数统计算法——HyperLogLog</h2><h3 id="为什么要使用-HyperLogLog？"><a href="#为什么要使用-HyperLogLog？" class="headerlink" title="为什么要使用 HyperLogLog？"></a>为什么要使用 HyperLogLog？</h3><p>在我们实际开发的过程中，可能会遇到这样一个问题，当我们需要统计一个大型网站的独立访问次数时，该用什么的类型来统计？</p>
<p>如果我们使用 Redis 中的集合来统计，当它每天有数千万级别的访问时，将会是一个巨大的问题。因为这些访问量不能被清空，我们运营人员可能会随时查看这些信息，那么随着时间的推移，这些统计数据所占用的空间会越来越大，逐渐超出我们能承载最大空间。</p>
<p>例如，我们用 IP 来作为独立访问的判断依据，那么我们就要把每个独立 IP 进行存储，以 IP4 来计算，IP4 最多需要 15 个字节来存储信息，例如：110.110.110.110。当有一千万个独立 IP 时，所占用的空间就是 15 bit*10000000 约定于 143MB，但这只是一个页面的统计信息，假如我们有 1 万个这样的页面，那我们就需要 1T 以上的空间来存储这些数据，而且随着 IP6 的普及，这个存储数字会越来越大，那我们就不能用集合的方式来存储了，这个时候我们需要开发新的数据类型 HyperLogLog 来做这件事了。</p>
<h3 id="HyperLogLog-介绍"><a href="#HyperLogLog-介绍" class="headerlink" title="HyperLogLog 介绍"></a>HyperLogLog 介绍</h3><p>HyperLogLog（下文简称为 HLL）是 Redis 2.8.9 版本添加的数据结构，它用于高性能的基数（去重）统计功能，它的缺点就是存在极低的误差率。</p>
<p>HLL 具有以下几个特点：</p>
<ul>
<li>能够使用极少的内存来统计巨量的数据，它只需要 12K 空间就能统计 2^64 的数据；</li>
<li>统计存在一定的误差，误差率整体较低，标准误差为 0.81%；</li>
<li>误差可以被设置辅助计算因子进行降低。</li>
</ul>
<h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><p>HLL 的命令只有 3 个，但都非常的实用，下面分别来看。</p>
<h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; pfadd key "redis"
(integer) 1
127.0.0.1:6379&gt; pfadd key "java" "sql"
(integer) 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>相关语法：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">pfadd key element [element ...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>此命令支持添加一个或多个元素至 HLL 结构中。</p>
<h4 id="统计不重复的元素"><a href="#统计不重复的元素" class="headerlink" title="统计不重复的元素"></a>统计不重复的元素</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; pfadd key "redis"
(integer) 1
127.0.0.1:6379&gt; pfadd key "sql"
(integer) 1
127.0.0.1:6379&gt; pfadd key "redis"
(integer) 0
127.0.0.1:6379&gt; pfcount key
(integer) 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从 pfcount 的结果可以看出，在 HLL 结构中键值为 key 的元素，有 2 个不重复的值：redis 和 sql，可以看出结果还是挺准的。</p>
<p>相关语法：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">pfcount key [key ...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>此命令支持统计一个或多个 HLL 结构。</p>
<h4 id="合并一个或多个-HLL-至新结构"><a href="#合并一个或多个-HLL-至新结构" class="headerlink" title="合并一个或多个 HLL 至新结构"></a>合并一个或多个 HLL 至新结构</h4><p>新增 k 和 k2 合并至新结构 k3 中，代码如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; pfadd k "java" "sql"
(integer) 1
127.0.0.1:6379&gt; pfadd k2 "redis" "sql"
(integer) 1
127.0.0.1:6379&gt; pfmerge k3 k k2
OK
127.0.0.1:6379&gt; pfcount k3
(integer) 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>相关语法：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">pfmerge destkey sourcekey [sourcekey ...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h5 id="pfmerge-使用场景"><a href="#pfmerge-使用场景" class="headerlink" title="pfmerge 使用场景"></a>pfmerge 使用场景</h5><p>当我们需要合并两个或多个同类页面的访问数据时，我们可以使用 pfmerge 来操作。</p>
<h3 id="HLL-算法原理"><a href="#HLL-算法原理" class="headerlink" title="HLL 算法原理"></a>HLL 算法原理</h3><p>HyperLogLog 算法来源于论文 <a target="_blank" rel="noopener" href="https://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf">HyperLogLog the analysis of a near-optimal cardinality estimation algorithm</a>，想要了解 HLL 的原理，先要从伯努利试验说起，伯努利实验说的是抛硬币的事。一次伯努利实验相当于抛硬币，不管抛多少次只要出现一个正面，就称为一次伯努利实验。</p>
<p>我们用 k 来表示每次抛硬币的次数，n 表示第几次抛的硬币，用 k_max 来表示抛硬币的最高次数，最终根据估算发现 n 和 k_max 存在的关系是 n=2^(k_max)，但同时我们也发现了另一个问题当试验次数很小的时候，这种估算方法的误差会很大，例如我们进行以下 3 次实验：</p>
<ul>
<li>第 1 次试验：抛 3 次出现正面，此时 k=3，n=1；</li>
<li>第 2 次试验：抛 2 次出现正面，此时 k=2，n=2；</li>
<li>第 3 次试验：抛 6 次出现正面，此时 k=6，n=3。</li>
</ul>
<p>对于这三组实验来说，k_max=6，n=3，但放入估算公式明显 3≠2^6。为了解决这个问题 HLL 引入了分桶算法和调和平均数来使这个算法更接近真实情况。</p>
<p>分桶算法是指把原来的数据平均分为 m 份，在每段中求平均数在乘以 m，以此来消减因偶然性带来的误差，提高预估的准确性，简单来说就是把一份数据分为多份，把一轮计算，分为多轮计算。</p>
<p>而调和平均数指的是使用平均数的优化算法，而非直接使用平均数。</p>
<blockquote>
<p>例如小明的月工资是 1000 元，而小王的月工资是 100000 元，如果直接取平均数，那小明的平均工资就变成了 (1000+100000)/2=50500 元，这显然是不准确的，而使用调和平均数算法计算的结果是 2/(1⁄1000+1⁄100000)≈1998 元，显然此算法更符合实际平均数。</p>
</blockquote>
<p>所以综合以上情况，在 Redis 中使用 HLL 插入数据，相当于把存储的值经过 hash 之后，再将 hash 值转换为二进制，存入到不同的桶中，这样就可以用很小的空间存储很多的数据，统计时再去相应的位置进行对比很快就能得出结论，这就是 HLL 算法的基本原理，想要更深入的了解算法及其推理过程，可以看去原版的论文。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://kibazen.cn" rel="external nofollow noreferrer">Kiba Amor</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                    </span>
                <span class="reprint-info">
                    <a href="https://kibazen.cn/redis-he-xin-yuan-li-yu-shi-zhan-xue-xi-bi-ji/">https://kibazen.cn/redis-he-xin-yuan-li-yu-shi-zhan-xue-xi-bi-ji/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY-NC-ND 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://kibazen.cn" target="_blank">Kiba Amor</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Redis/">
                                    <span class="chip bg-color">Redis</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/share/css/share.min.css">
<div id="article-share">

    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/redis-he-xin-yuan-li-yu-shi-zhan-xue-xi-bi-ji/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/18.jpg" class="responsive-img" alt="《Redis 核心原理与实战》学习笔记">
                        
                        <span class="card-title">《Redis 核心原理与实战》学习笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2025-06-29
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                    学习笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Redis/">
                        <span class="chip bg-color">Redis</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/ddd-si-xiang-jie-du-ji-you-xiu-shi-jian-xue-xi-bi-ji/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/8.jpg" class="responsive-img" alt="《DDD思想解读及优秀实践》学习笔记">
                        
                        <span class="card-title">《DDD思想解读及优秀实践》学习笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2025-02-05
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                    学习笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/">
                        <span class="chip bg-color">领域驱动设计</span>
                    </a>
                    
                    <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                        <span class="chip bg-color">极客时间</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('2'),
            headingSelector: 'h2, h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2025</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">Kiba Amor</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/kibaamor" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:5093911+kibaamor@users.noreply.github.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>













    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

    
    

    

    

	
    

    

    

    
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
