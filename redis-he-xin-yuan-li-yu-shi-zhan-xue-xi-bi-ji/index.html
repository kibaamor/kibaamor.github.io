<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <meta name="keywords" content="《Redis 核心原理与实战》学习笔记, kiba, zen, amor, kibazen, kibaamor, 木叶, 木叶禅">
    <meta name="description" content="You are too concerned with what was and what will be">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>《Redis 核心原理与实战》学习笔记 | 木叶禅</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/css/my.css">

    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="木叶禅" type="application/atom+xml">
</head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">木叶禅</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/learn/" class="waves-effect waves-light">
      
      <i class="fas fa-book" style="zoom: 0.6;"></i>
      
      <span>Learn</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/memo/" class="waves-effect waves-light">
      
      <i class="fas fa-sticky-note" style="zoom: 0.6;"></i>
      
      <span>Memo</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories/" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags/" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about/" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">木叶禅</div>
        <div class="logo-desc">
            
            You are too concerned with what was and what will be
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/learn/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-book"></i>
			
			Learn
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/memo/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-sticky-note"></i>
			
			Memo
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    
<script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = 'f65e070788a2647953051a7a1b70ada7fd2b3f70cd4d93c977207f5b762987d4';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/18.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">《Redis 核心原理与实战》学习笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Redis/">
                                <span class="chip bg-color">Redis</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                学习笔记
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2025-06-29
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2025-07-10
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    51.6k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    208 分
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="01-Redis-是如何执行的"><a href="#01-Redis-是如何执行的" class="headerlink" title="01 Redis 是如何执行的"></a>01 Redis 是如何执行的</h2><h3 id="命令执行流程"><a href="#命令执行流程" class="headerlink" title="命令执行流程"></a>命令执行流程</h3><p>一条命令的执行过程有很多细节，但大体可分为：客户端先将用户输入的命令，转化为 Redis 相关的通讯协议，再用 socket 连接的方式将内容发送给服务器端，服务器端在接收到相关内容之后，先将内容转化为具体的执行命令，再判断用户授权信息和其他相关信息，当验证通过之后会执行最终命令，命令执行完之后，会进行相关的信息记录和数据统计，然后再把执行结果发送给客户端，这样一条命令的执行流程就结束了。如果是集群模式的话，主节点还会将命令同步至子节点，下面我们一起来看更加具体的执行流程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/Redis命令大体执行流程图.png" alt="Redis命令大体执行流程图"></p>
<h4 id="步骤一：用户输入一条命令"><a href="#步骤一：用户输入一条命令" class="headerlink" title="步骤一：用户输入一条命令"></a>步骤一：用户输入一条命令</h4><h4 id="步骤二：客户端先将命令转换成-Redis-协议，然后再通过-socket-连接发送给服务器端"><a href="#步骤二：客户端先将命令转换成-Redis-协议，然后再通过-socket-连接发送给服务器端" class="headerlink" title="步骤二：客户端先将命令转换成 Redis 协议，然后再通过 socket 连接发送给服务器端"></a>步骤二：客户端先将命令转换成 Redis 协议，然后再通过 socket 连接发送给服务器端</h4><p>客户端和服务器端是基于 socket 通信的，服务器端在初始化时会创建了一个 socket 监听，用于监测链接客户端的 socket 链接，源码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">initServer</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//......</span>
    <span class="token comment">// 开启 Socket 事件监听</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>port <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>
        <span class="token function">listenToPort</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>port<span class="token punctuation">,</span>server<span class="token punctuation">.</span>ipfd<span class="token punctuation">,</span><span class="token operator">&amp;</span>server<span class="token punctuation">.</span>ipfd_count<span class="token punctuation">)</span> <span class="token operator">==</span> C_ERR<span class="token punctuation">)</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//......</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>socket 小知识：每个 socket 被创建后，会分配两个缓冲区，输入缓冲区和输出缓冲区。 写入函数并不会立即向网络中传输数据，而是先将数据写入缓冲区中，再由 TCP 协议将数据从缓冲区发送到目标机器。一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是 TCP 协议负责的事情。 注意：数据有可能刚被写入缓冲区就发送到网络，也可能在缓冲区中不断积压，多次写入的数据被一次性发送到网络，这取决于当时的网络情况、当前线程是否空闲等诸多因素，不由程序员控制。 读取函数也是如此，它也是从输入缓冲区中读取数据，而不是直接从网络中读取。</p>
</blockquote>
<p>当 socket 成功连接之后，客户端会先把命令转换成 Redis 通讯协议（RESP 协议，REdis Serialization Protocol）发送给服务器端，这个通信协议是为了保障服务器能最快速的理解命令的含义而制定的，如果没有这个通讯协议，那么 Redis 服务器端要遍历所有的空格以确认此条命令的含义，这样会加大服务器的运算量，而直接发送通讯协议，相当于把服务器端的解析工作交给了每一个客户端，这样会很大程度的提高 Redis 的运行速度。例如，当我们输入 <code>set key val</code> 命令时，客户端会把这个命令转换为 <code>*3\r\n$3\r\nSET\r\n$4\r\nKEY\r\n$4\r\nVAL\r\n</code> 协议发送给服务器端。 更多通讯协议，可访问官方文档：<a target="_blank" rel="noopener" href="https://redis.io/topics/protocol">https://redis.io/topics/protocol</a></p>
<h5 id="扩展知识：I-O-多路复用"><a href="#扩展知识：I-O-多路复用" class="headerlink" title="扩展知识：I/O 多路复用"></a>扩展知识：I/O 多路复用</h5><p>Redis 使用的是 I/O 多路复用功能来监听多 socket 链接的，这样就可以使用一个线程链接来处理多个请求，减少线程切换带来的开销，同时也避免了 I/O 阻塞操作，从而大大提高了 Redis 的运行效率。</p>
<p>I/O 多路复用机制如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/IO多路复用机制.png" alt="IO多路复用机制"></p>
<p>综合来说，此步骤的执行流程如下：</p>
<ul>
<li>与服务器端以 socket 和 I/O 多路复用的技术建立链接；</li>
<li>将命令转换为 Redis 通讯协议，再将这些协议发送至缓冲区。</li>
</ul>
<h4 id="步骤三：服务器端接收到命令"><a href="#步骤三：服务器端接收到命令" class="headerlink" title="步骤三：服务器端接收到命令"></a>步骤三：服务器端接收到命令</h4><p>服务器会先去输入缓冲中读取数据，然后判断数据的大小是否超过了系统设置的值(默认是 1GB)，如果大于此值就会返回错误信息，并关闭客户端连接。 默认大小如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/Redis默认数据大小.png" alt="Redis默认数据大小"></p>
<p>当数据大小验证通过之后，服务器端会对输入缓冲区中的请求命令进行分析，提取命令请求中包含的命令参数，存储在 client 对象(服务器端会为每个链接创建一个 Client 对象)的属性中。</p>
<h4 id="步骤四：执行前准备"><a href="#步骤四：执行前准备" class="headerlink" title="步骤四：执行前准备"></a>步骤四：执行前准备</h4><ol>
<li>判断是否为退出命令，如果是则直接返回；</li>
<li>非 null 判断，检查 client 对象是否为 null，如果是返回错误信息；</li>
<li>获取执行命令，根据 client 对象存储的属性信息去 redisCommand 结构中查询执行命令；</li>
<li>用户权限效验，未通过身份验证的客户端只能执行 AUTH(授权) 命令，未通过身份验证的客户端执行了 AUTH 之外的命令则返回错误信息；</li>
<li>集群相关操作，如果是集群模式，把命令重定向到目标节点，如果是 master(主节点) 则不需要重定向；</li>
<li>检查服务器端最大内存限制，如果服务器端开启了最大内存限制，会先检查内存大小，如果内存超过了最大值会对内存进行回收操作；</li>
<li>持久化检测，检查服务器是否开启了持久化和持久化出错停止写入配置，如果开启了此配置并且有持久化失败的情况，禁止执行写命令；</li>
<li>集群模式最少从节点(slave)验证，如果是集群模式并且配置了 <code>repl*min*slaves*to*write</code> (最小从节点写入)，当从节点的数量少于配置项时，禁止执行写命令；</li>
<li>只读从节点验证，当此服务器为只读从节点时，只接受 master 的写命令；</li>
<li>客户端订阅判断，当客户端正在订阅频道时，只会执行部分命令（只会执行 SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE、PUNSUBSCRIBE，其他命令都会被拒绝）。</li>
<li>从节点状态效验，当服务器为 slave 并且没有连接 master 时，只会执行状态查询相关的命令，如 info 等；</li>
<li>服务器初始化效验，当服务器正在启动时，只会执行 loading 标志的命令，其他的命令都会被拒绝；</li>
<li>lua 脚本阻塞效验，当服务器因为执行 lua 脚本阻塞时，只会执行部分命令；</li>
<li>事务命令效验，如果执行的是事务命令，则开启事务把命令放入等待队列；</li>
<li>监视器 (monitor) 判断，如果服务器打开了监视器功能，那么服务器也会把执行命令和相关参数发送给监视器 (监视器是用于监控服务器运行状态的)。</li>
</ol>
<p>当服务器经过以上操作之后，就可以执行真正的操作命令了。</p>
<h4 id="步骤五：执行最终命令，调用-redisCommand-中的-proc-函数执行命令。"><a href="#步骤五：执行最终命令，调用-redisCommand-中的-proc-函数执行命令。" class="headerlink" title="步骤五：执行最终命令，调用 redisCommand 中的 proc 函数执行命令。"></a>步骤五：执行最终命令，调用 redisCommand 中的 proc 函数执行命令。</h4><h4 id="步骤六：执行完后相关记录和统计"><a href="#步骤六：执行完后相关记录和统计" class="headerlink" title="步骤六：执行完后相关记录和统计"></a>步骤六：执行完后相关记录和统计</h4><ol>
<li>检查慢查询是否开启，如果开启会记录慢查询日志；</li>
<li>检查统计信息是否开启，如果开启会记录一些统计信息，例如执行命令所耗费时长和计数器(calls)加1；</li>
<li>检查持久化功能是否开启，如果开启则会记录持久化信息；</li>
<li>如果有其它从服务器正在复制当前服务器，则会将刚刚执行的命令传播给其他从服务器。</li>
</ol>
<h4 id="步骤七：返回结果给客户端"><a href="#步骤七：返回结果给客户端" class="headerlink" title="步骤七：返回结果给客户端"></a>步骤七：返回结果给客户端</h4><p>命令执行完之后，服务器会通过 socket 的方式把执行结果发送给客户端，客户端再把结果展示给用户，至此一条命令的执行就结束了。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>当用户输入一条命令之后，客户端会以 socket 的方式把数据转换成 Redis 协议，并发送至服务器端，服务器端在接受到数据之后，会先将协议转换为真正的执行命令，在经过各种验证以保证命令能够正确并安全的执行，但验证处理完之后，会调用具体的方法执行此条命令，执行完成之后会进行相关的统计和记录，然后再把执行结果返回给客户端，整个执行流程，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/Redis命令执行流程小结.png" alt="Redis命令执行流程小结"></p>
<h2 id="03-Redis-持久化——RDB"><a href="#03-Redis-持久化——RDB" class="headerlink" title="03 Redis 持久化——RDB"></a>03 Redis 持久化——RDB</h2><p>Redis 的读写都是在内存中，所以它的性能较高，但在内存中的数据会随着服务器的重启而丢失，为了保证数据不丢失，我们需要将内存中的数据存储到磁盘，以便 Redis 重启时能够从磁盘中恢复原有的数据，而整个过程就叫做 Redis 持久化。</p>
<p>Redis 持久化也是 Redis 和 Memcached 的主要区别之一，因为 Memcached 不具备持久化功能。</p>
<h3 id="持久化的几种方式"><a href="#持久化的几种方式" class="headerlink" title="持久化的几种方式"></a>持久化的几种方式</h3><p>Redis 持久化拥有以下三种方式：</p>
<ul>
<li>快照方式（RDB, Redis DataBase）将某一个时刻的内存数据，以二进制的方式写入磁盘；</li>
<li>文件追加方式（AOF, Append Only File），记录所有的操作命令，并以文本的形式追加到文件中；</li>
<li>混合持久化方式，Redis 4.0 之后新增的方式，混合持久化是结合了 RDB 和 AOF 的优点，在写入的时候，先把当前的数据以 RDB 的形式写入文件的开头，再将后续的操作命令以 AOF 的格式存入文件，这样既能保证 Redis 重启时的速度，又能减低数据丢失的风险。</li>
</ul>
<h3 id="RDB简介"><a href="#RDB简介" class="headerlink" title="RDB简介"></a>RDB简介</h3><p>RDB（Redis DataBase）是将某一个时刻的内存快照（Snapshot），以二进制的方式写入磁盘的过程。</p>
<h3 id="持久化触发"><a href="#持久化触发" class="headerlink" title="持久化触发"></a>持久化触发</h3><p>RDB 的持久化触发方式有两类：一类是手动触发，另一类是自动触发。</p>
<h4 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h4><p>手动触发持久化的操作有两个： <code>save</code> 和 <code>bgsave</code> ，它们主要区别体现在：是否阻塞 Redis 主线程的执行。</p>
<p>在客户端中执行 <code>save</code> 命令，就会触发 Redis 的持久化，但同时也是使 Redis 处于阻塞状态，直到 RDB 持久化完成，才会响应其他客户端发来的命令，所以<strong>在生产环境一定要慎用。</strong></p>
<p><code>bgsave</code> （background save）既后台保存的意思， 它和 <code>save</code> 命令最大的区别就是 <code>bgsave</code> 会 <code>fork()</code> 一个子进程来执行持久化，整个过程中只有在 <code>fork()</code> 子进程时有短暂的阻塞，当子进程被创建之后，Redis 的主进程就可以响应其他客户端的请求了，相对于整个流程都阻塞的 <code>save</code> 命令来说，显然 <code>bgsave</code> 命令更适合我们使用。</p>
<h4 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h4><p>说完了 RDB 的手动触发方式，下面来看如何自动触发 RDB 持久化？ RDB 自动持久化主要来源于以下几种情况。</p>
<ol>
<li><p><code>save m n</code></p>
<p> <code>save m n</code> 是指在 <code>m</code> 秒内，如果有 <code>n</code> 个键发生改变，则自动触发持久化。 参数 <code>m</code> 和 <code>n</code> 可以在 Redis 的配置文件中找到，例如，<code>save 60 1</code> 则表明在 60 秒内，至少有一个键发生改变，就会触发 RDB 持久化。 自动触发持久化，本质是 Redis 通过判断，如果满足设置的触发条件，自动执行一次 <code>bgsave</code> 命令。 注意：当设置多个 <code>save m n</code> 命令时，满足任意一个条件都会触发持久化。 例如，我们设置了以下两个 <code>save m n</code> 命令：</p>
<ul>
<li><code>save 60 10</code></li>
<li><p><code>save 600 1</code></p>
<p>当 60s 内如果有 10 次 Redis 键值发生改变，就会触发持久化；如果 60s 内 Redis 的键值改变次数少于 10 次，那么 Redis 就会判断 600s 内，Redis 的键值是否至少被修改了一次，如果满足则会触发持久化。</p>
</li>
</ul>
</li>
<li><p><code>flushall</code></p>
<p> <code>flushall</code> 命令用于清空 Redis 数据库，在生产环境下一定慎用，当 Redis 执行了 <code>flushall</code> 命令之后，则会触发自动持久化，把 RDB 文件清空。</p>
</li>
<li><p>主从同步触发</p>
<p> 在 Redis 主从复制中，当从节点执行全量复制操作时，主节点会执行 <code>bgsave</code> 命令，并将 RDB 文件发送给从节点，该过程会自动触发 Redis 持久化。</p>
</li>
</ol>
<h3 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h3><p>RDB 配置参数可以在 Redis 的配置文件中找见，具体内容如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text"># RDB 保存的条件
save 900 1
save 300 10
save 60 10000

# bgsave 失败之后，是否停止持久化数据到磁盘，yes 表示停止持久化，no 表示忽略错误继续写文件。
stop-writes-on-bgsave-error yes

# RDB 文件压缩
rdbcompression yes

# 写入文件和读取文件时是否开启 RDB 文件检查，检查是否有无损坏，如果在启动是检查发现损坏，则停止启动。
rdbchecksum yes

# RDB 文件名
dbfilename dump.rdb

# RDB 文件目录
dir ./<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中比较重要的参数如下列表： </p>
<ol>
<li><p>save 参数</p>
<p> 它是用来配置触发 RDB 持久化条件的参数，满足保存条件时将会把数据持久化到硬盘。 默认配置说明如下：</p>
<ul>
<li><code>save 900 1</code>：表示 900 秒内如果至少有 1 个 key 值变化，则把数据持久化到硬盘；</li>
<li><code>save 300 10</code>：表示 300 秒内如果至少有 10 个 key 值变化，则把数据持久化到硬盘；</li>
<li><code>save 60 10000</code>：表示 60 秒内如果至少有 10000 个 key 值变化，则把数据持久化到硬盘。</li>
</ul>
</li>
<li><p>rdbcompression 参数</p>
<p> 它的默认值是 yes 表示开启 RDB 文件压缩，Redis 会采用 LZF 算法进行压缩。如果不想消耗 CPU 性能来进行文件压缩的话，可以设置为关闭此功能，这样的缺点是需要更多的磁盘空间来保存文件。</p>
</li>
<li><p>rdbchecksum 参数</p>
<p> 它的默认值为 yes 表示写入文件和读取文件时是否开启 RDB 文件检查，检查是否有无损坏，如果在启动是检查发现损坏，则停止启动。</p>
</li>
</ol>
<h3 id="配置查询"><a href="#配置查询" class="headerlink" title="配置查询"></a>配置查询</h3><p>Redis 中可以使用命令查询当前配置参数。查询命令的格式为：<code>config get xxx</code> ，例如，想要获取 RDB 文件的存储名称设置，可以使用 <code>config get dbfilename</code>。</p>
<p>查询 RDB 的文件目录，可使用命令 <code>config get dir</code>。</p>
<h3 id="配置设置"><a href="#配置设置" class="headerlink" title="配置设置"></a>配置设置</h3><p>设置 RDB 的配置，可以通过以下两种方式：</p>
<ul>
<li>手动修改 Redis 配置文件；</li>
<li>使用命令行设置，例如，使用 config set dir “/usr/data” 就是用于修改 RDB 的存储目录。</li>
</ul>
<p>注意：手动修改 Redis 配置文件的方式是全局生效的，即重启 Redis 服务器设置参数也不会丢失，而使用命令修改的方式，在 Redis 重启之后就会丢失。但手动修改 Redis 配置文件，想要立即生效需要重启 Redis 服务器，而命令的方式则不需要重启 Redis 服务器。</p>
<blockquote>
<p>小贴士：Redis 的配置文件位于 Redis 安装目录的根路径下，默认名称为 redis.conf。</p>
</blockquote>
<h3 id="RDB-文件恢复"><a href="#RDB-文件恢复" class="headerlink" title="RDB 文件恢复"></a>RDB 文件恢复</h3><p>当 Redis 服务器启动时，如果 Redis 根目录存在 RDB 文件 dump.rdb，Redis 就会自动加载 RDB 文件恢复持久化数据。<br>如果根目录没有 dump.rdb 文件，请先将 dump.rdb 文件移动到 Redis 的根目录。</p>
<p>验证 RDB 文件是否被加载 Redis 在启动时有日志信息，会显示是否加载了 RDB 文件，我们执行 Redis 启动命令：<code>src/redis-server redis.conf</code> ，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/RDB文件恢复.png" alt="RDB文件恢复"></p>
<p>从日志上可以看出， Redis 服务在启动时已经正常加载了 RDB 文件。</p>
<blockquote>
<p>小贴士：Redis 服务器在载入 RDB 文件期间，会一直处于阻塞状态，直到载入工作完成为止。</p>
</blockquote>
<h3 id="RDB-优缺点"><a href="#RDB-优缺点" class="headerlink" title="RDB 优缺点"></a>RDB 优缺点</h3><h4 id="RDB-优点"><a href="#RDB-优点" class="headerlink" title="RDB 优点"></a>RDB 优点</h4><ul>
<li>RDB 的内容为二进制的数据，占用内存更小，更紧凑，更适合做为备份文件；</li>
<li>RDB 对灾难恢复非常有用，它是一个紧凑的文件，可以更快的传输到远程服务器进行 Redis 服务恢复；</li>
<li>RDB 可以更大程度的提高 Redis 的运行速度，因为每次持久化时 Redis 主进程都会 <code>fork()</code> 一个子进程，进行数据持久化到磁盘，Redis 主进程并不会执行磁盘 I/O 等操作；</li>
<li>与 AOF 格式的文件相比，RDB 文件可以更快的重启。</li>
</ul>
<h4 id="RDB-缺点"><a href="#RDB-缺点" class="headerlink" title="RDB 缺点"></a>RDB 缺点</h4><ul>
<li>因为 RDB 只能保存某个时间间隔的数据，如果中途 Redis 服务被意外终止了，则会丢失一段时间内的 Redis 数据；</li>
<li>RDB 需要经常 <code>fork()</code> 才能使用子进程将其持久化在磁盘上。如果数据集很大，<code>fork()</code> 可能很耗时，并且如果数据集很大且 CPU 性能不佳，则可能导致 Redis 停止为客户端服务几毫秒甚至一秒钟。</li>
</ul>
<h3 id="禁用持久化"><a href="#禁用持久化" class="headerlink" title="禁用持久化"></a>禁用持久化</h3><p>禁用持久化可以提高 Redis 的执行效率，如果对数据丢失不敏感的情况下，可以在连接客户端的情况下，执行 <code>config set save ""</code> 命令即可禁用 Redis 的持久化。</p>
<h3 id="参考-amp-鸣谢"><a href="#参考-amp-鸣谢" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h3><ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/topics/persistence">https://redis.io/topics/persistence</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36318234/article/details/79994133">https://blog.csdn.net/qq_36318234/article/details/79994133</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ysocean/p/9114268.html">https://www.cnblogs.com/ysocean/p/9114268.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wdliu/p/9377278.html">https://www.cnblogs.com/wdliu/p/9377278.html</a></li>
</ul>
<h2 id="04-Redis-持久化——AOF"><a href="#04-Redis-持久化——AOF" class="headerlink" title="04 Redis 持久化——AOF"></a>04 Redis 持久化——AOF</h2><p>使用 RDB 持久化有一个风险，它可能会造成最新数据丢失的风险。因为 RDB 的持久化有一定的时间间隔，在这个时间段内如果 Redis 服务意外终止的话，就会造成最新的数据全部丢失。</p>
<p>可能会操作 Redis 服务意外终止的条件：</p>
<ul>
<li>安装 Redis 的机器停止运行，蓝屏或者系统崩溃；</li>
<li>安装 Redis 的机器出现电源故障，例如突然断电；</li>
<li>使用 <code>kill -9 Redis_PID</code> 等。</li>
</ul>
<p>那么如何解决以上的这些问题呢？Redis 为我们提供了另一种持久化的方案——AOF。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>AOF（Append Only File）中文是附加到文件，顾名思义 AOF 可以把 Redis 每个键值对操作都记录到文件（appendonly.aof）中。</p>
<h3 id="持久化查询和设置"><a href="#持久化查询和设置" class="headerlink" title="持久化查询和设置"></a>持久化查询和设置</h3><h4 id="查询-AOF-启动状态"><a href="#查询-AOF-启动状态" class="headerlink" title="查询 AOF 启动状态"></a>查询 AOF 启动状态</h4><p>使用 <code>config get appendonly</code> 命令，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/查询AOF启动状态.png" alt="查询AOF启动状态"></p>
<p>其中，第一行为 AOF 文件的名称，而最后一行表示 AOF 启动的状态，yes 表示已启动，no 表示未启动。</p>
<h3 id="开启-AOF-持久化"><a href="#开启-AOF-持久化" class="headerlink" title="开启 AOF 持久化"></a>开启 AOF 持久化</h3><h4 id="命令行启动-AOF"><a href="#命令行启动-AOF" class="headerlink" title="命令行启动 AOF"></a>命令行启动 AOF</h4><p>命令行启动 AOF，使用 <code>config set appendonly yes</code> 命令。</p>
<p>命令行启动 AOF 的优缺点：命令行启动优点是无需重启 Redis 服务，缺点是如果 Redis 服务重启，则之前使用命令行设置的配置就会失效。</p>
<h4 id="配置文件启动-AOF"><a href="#配置文件启动-AOF" class="headerlink" title="配置文件启动 AOF"></a>配置文件启动 AOF</h4><p>Redis 的配置文件在它的根路径下的 redis.conf 文件中，获取 Redis 的根目录可以使用命令 <code>config get dir</code> 获取，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/获取Redis的根目录.png" alt="获取Redis的根目录"></p>
<p>只需要在配置文件中设置 <code>appendonly yes</code> 即可，默认 appendonly no 表示关闭 AOF 持久化。</p>
<p>配置文件启动 AOF 的优缺点：修改配置文件的缺点是每次修改配置文件都要重启 Redis 服务才能生效，优点是无论重启多少次 Redis 服务，配置文件中设置的配置信息都不会失效。</p>
<h3 id="触发持久化"><a href="#触发持久化" class="headerlink" title="触发持久化"></a>触发持久化</h3><p>AOF 持久化开启之后，只要满足一定条件，就会触发 AOF 持久化。AOF 的触发条件分为两种：自动触发和手动触发。</p>
<h4 id="自动触发-1"><a href="#自动触发-1" class="headerlink" title="自动触发"></a>自动触发</h4><p>有两种情况可以自动触发 AOF 持久化，分为是：</p>
<ol>
<li>满足 AOF 设置的策略触发</li>
<li>满足 AOF 重写触发条件</li>
</ol>
<p>其中，AOF 重写触发会在本文的后半部分详细介绍，这里重点来说 AOF 持久化策略都有哪些。 AOF 持久化策略，分为以下三种：</p>
<ul>
<li>always：每条 Redis 操作命令都会写入磁盘，最多丢失一条数据；</li>
<li>everysec：每秒钟写入一次磁盘，最多丢失一秒的数据；</li>
<li>no：不设置写入磁盘的规则，根据当前操作系统来决定何时写入磁盘，Linux 默认 30s 写入一次数据至磁盘。</li>
</ul>
<p>这三种配置可以在 Redis 的配置文件（redis.conf）中设置，如下代码所示：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text"># 开启每秒写入一次的持久化策略
appendfsync everysec<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<blockquote>
<p>小贴士：因为每次写入磁盘都会对 Redis 的性能造成一定的影响，所以要根据用户的实际情况设置相应的策略，一般设置每秒写入一次磁盘的频率就可以满足大部分的使用场景了。</p>
</blockquote>
<h4 id="手动触发-1"><a href="#手动触发-1" class="headerlink" title="手动触发"></a>手动触发</h4><p>在客户端执行 <code>bgrewriteaof</code> 命令就可以手动触发 AOF 持久化。</p>
<h3 id="AOF-文件重写"><a href="#AOF-文件重写" class="headerlink" title="AOF 文件重写"></a>AOF 文件重写</h3><p>AOF 是通过记录 Redis 的执行命令来持久化（保存）数据的，所以随着时间的流逝 AOF 文件会越来越多，这样不仅增加了服务器的存储压力，也会造成 Redis 重启速度变慢，为了解决这个问题 Redis 提供了 AOF 重写的功能。</p>
<h4 id="什么是-AOF-重写？"><a href="#什么是-AOF-重写？" class="headerlink" title="什么是 AOF 重写？"></a>什么是 AOF 重写？</h4><p>AOF 重写指的是它会直接读取 Redis 服务器当前的状态，并压缩保存为 AOF 文件。例如，我们增加了一个计数器，并对它做了 99 次修改，如果不做 AOF 重写的话，那么持久化文件中就会有 100 条记录执行命令的信息，而 AOF 重写之后，之后记录一条此计数器最终的结果信息，这样就去除了所有的无效信息。</p>
<h4 id="AOF-重写实现"><a href="#AOF-重写实现" class="headerlink" title="AOF 重写实现"></a>AOF 重写实现</h4><p>触发 AOF 文件重写，要满足两个条件，这两个条件也是配置在 Redis 配置文件中的，它们分别：</p>
<ul>
<li><code>auto-aof-rewrite-min-size</code>：允许 AOF 重写的最小文件容量，默认是 64mb 。</li>
<li><code>auto-aof-rewrite-percentage</code>：AOF 文件重写的大小比例，默认值是 100，表示 100%，也就是只有当前 AOF 文件，比最后一次（上次）的 AOF 文件大一倍时，才会启动 AOF 文件重写。</li>
</ul>
<blockquote>
<p>小贴士：只有同时满足 auto-aof-rewrite-min-size 和 auto-aof-rewrite-percentage 设置的条件，才会触发 AOF 文件重写。</p>
</blockquote>
<p>注意：使用 <code>bgrewriteaof</code> 命令，可以自动触发 AOF 文件重写。</p>
<h4 id="AOF-重写流程"><a href="#AOF-重写流程" class="headerlink" title="AOF 重写流程"></a>AOF 重写流程</h4><p>AOF 文件重写是生成一个全新的文件，并把当前数据的最少操作命令保存到新文件上，当把所有的数据都保存至新文件之后，Redis 会交换两个文件，并把最新的持久化操作命令追加到新文件上。</p>
<h3 id="配置说明-1"><a href="#配置说明-1" class="headerlink" title="配置说明"></a>配置说明</h3><p>AOF 的配置参数在 Redis 的配置文件中，也就是 Redis 根路径下的 redis.conf 文件中，配置参数和说明如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text"># 是否开启 AOF，yes 为开启，默认是关闭
appendonly no

# AOF 默认文件名
appendfilename "appendonly.aof"

# AOF 持久化策略配置
# appendfsync always
appendfsync everysec
# appendfsync no

# AOF 文件重写的大小比例，默认值是 100，表示 100%，也就是只有当前 AOF 文件，比最后一次的 AOF 文件大一倍时，才会启动 AOF 文件重写。
auto-aof-rewrite-percentage 100

# 允许 AOF 重写的最小文件容量
auto-aof-rewrite-min-size 64mb

# 是否开启启动时加载 AOF 文件效验，默认值是 yes，表示尽可能的加载 AOF 文件，忽略错误部分信息，并启动 Redis 服务。
# 如果值为 no，则表示，停止启动 Redis，用户必须手动修复 AOF 文件才能正常启动 Redis 服务。
aof-load-truncated yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中比较重要的是 <code>appendfsync</code> 参数，用它来设置 AOF 的持久化策略，可以选择按时间间隔或者操作次数来存储 AOF 文件，这个参数的三个值在文章开头有说明，这里就不再复述了。</p>
<h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><h4 id="正常数据恢复"><a href="#正常数据恢复" class="headerlink" title="正常数据恢复"></a>正常数据恢复</h4><p>正常情况下，只要开启了 AOF 持久化，并且提供了正常的 appendonly.aof 文件，在 Redis 启动时就会自定加载 AOF 文件并启动，执行如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/正常AOF数据恢复.png" alt="正常AOF数据恢复"></p>
<p>其中 <code>DB loaded from append only file......</code> 表示 Redis 服务器在启动时，先去加载了 AOF 持久化文件。</p>
<blockquote>
<p>小贴士：默认情况下 appendonly.aof 文件保存在 Redis 的根目录下。</p>
</blockquote>
<p>持久化文件加载规则</p>
<ul>
<li>如果只开启了 AOF 持久化，Redis 启动时只会加载 AOF 文件（appendonly.aof），进行数据恢复；</li>
<li>如果只开启了 RDB 持久化，Redis 启动时只会加载 RDB 文件（dump.rdb），进行数据恢复；</li>
<li>如果同时开启了 RDB 和 AOF 持久化，Redis 启动时只会加载 AOF 文件（appendonly.aof），进行数据恢复。</li>
</ul>
<p>在 AOF 开启的情况下，即使 AOF 文件不存在，只有 RDB 文件，也不会加载 RDB 文件。 AOF 和 RDB 的加载流程如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/持久化文件加载规则.png" alt="持久化文件加载规则"></p>
<h4 id="简单异常数据恢复"><a href="#简单异常数据恢复" class="headerlink" title="简单异常数据恢复"></a>简单异常数据恢复</h4><p>在 AOF 写入文件时如果服务器崩溃，或者是 AOF 存储已满的情况下，AOF 的最后一条命令可能被截断，这就是异常的 AOF 文件。</p>
<p>在 AOF 文件异常的情况下，如果为修改 Redis 的配置文件，也就是使用 aof-load-truncated 等于 yes 的配置，Redis 在启动时会忽略最后一条命令，并顺利启动 Redis，执行结果如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">* Reading RDB preamble from AOF file...
* Reading the remaining AOF tail...
# !!! Warning: short read while loading the AOF file !!!
# !!! Truncating the AOF at offset 439 !!!
# AOF loaded anyway because aof-load-truncated is enabled<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="复杂异常数据恢复"><a href="#复杂异常数据恢复" class="headerlink" title="复杂异常数据恢复"></a>复杂异常数据恢复</h4><p>AOF 文件可能出现更糟糕的情况，当 AOF 文件不仅被截断，而且中间的命令也被破坏，这个时候再启动 Redis 会提示错误信息并中止运行，错误信息如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">* Reading the remaining AOF tail...
# Bad file format reading the append only file: make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>出现此类问题的解决方案如下：</p>
<ol>
<li>首先使用 AOF 修复工具，检测出现的问题，在命令行中输入 redis-check-aof 命令，它会跳转到出现问题的命令行，这个时候可以尝试手动修复此文件；</li>
<li>如果无法手动修复，我们可以使用 redis-check-aof —fix 自动修复 AOF 异常文件，不过执行此命令，可能会导致异常部分至文件末尾的数据全部被丢弃。</li>
</ol>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="AOF-优点"><a href="#AOF-优点" class="headerlink" title="AOF 优点"></a>AOF 优点</h4><ul>
<li>AOF 持久化保存的数据更加完整，AOF 提供了三种保存策略：每次操作保存、每秒钟保存一次、跟随系统的持久化策略保存，其中每秒保存一次，从数据的安全性和性能两方面考虑是一个不错的选择，也是 AOF 默认的策略，即使发生了意外情况，最多只会丢失 1s 钟的数据；</li>
<li>AOF 采用的是命令追加的写入方式，所以不会出现文件损坏的问题，即使由于某些意外原因，导致了最后操作的持久化数据写入了一半，也可以通过 redis-check-aof 工具轻松的修复；</li>
<li>AOF 持久化文件，非常容易理解和解析，它是把所有 Redis 键值操作命令，以文件的方式存入了磁盘。即使不小心使用 flushall 命令删除了所有键值信息，只要使用 AOF 文件，删除最后的 flushall 命令，重启 Redis 即可恢复之前误删的数据。</li>
</ul>
<h4 id="AOF-缺点"><a href="#AOF-缺点" class="headerlink" title="AOF 缺点"></a>AOF 缺点</h4><ul>
<li>对于相同的数据集来说，AOF 文件要大于 RDB 文件；</li>
<li>在 Redis 负载比较高的情况下，RDB 比 AOF 性能更好；</li>
<li>RDB 使用快照的形式来持久化整个 Redis 数据，而 AOF 只是将每次执行的命令追加到 AOF 文件中，因此从理论上说，RDB 比 AOF 更健壮。</li>
</ul>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>AOF 保存数据更加完整，它可以记录每次 Redis 的键值变化，或者是选择每秒保存一次数据。AOF 的持久化文件更加易读，但相比与二进制的 RDB 来说，所占的存储空间也越大，为了解决这个问题，AOF 提供自动化重写机制，最大程度的减少了 AOF 占用空间大的问题。同时 AOF 也提供了很方便的异常文件恢复命令： redis-check-aof —fix ，为使用 AOF 提供了很好的保障。</p>
<h3 id="参考-amp-鸣谢-1"><a href="#参考-amp-鸣谢-1" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h3><ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/topics/persistence">https://redis.io/topics/persistence</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36318234/article/details/79994133">https://blog.csdn.net/qq_36318234/article/details/79994133</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wdliu/p/9377278.html">https://www.cnblogs.com/wdliu/p/9377278.html</a></li>
</ul>
<h2 id="05-Redis-持久化——混合持久化"><a href="#05-Redis-持久化——混合持久化" class="headerlink" title="05 Redis 持久化——混合持久化"></a>05 Redis 持久化——混合持久化</h2><p>RDB 和 AOF 持久化各有利弊，RDB 可能会导致一定时间内的数据丢失，而 AOF 由于文件较大则会影响 Redis 的启动速度，为了能同时使用 RDB 和 AOF 各种的优点，Redis 4.0 之后新增了混合持久化的方式。</p>
<p>在开启混合持久化的情况下，AOF 重写时会把 Redis 的持久化数据，以 RDB 的格式写入到 AOF 文件的开头，之后的数据再以 AOF 的格式化追加的文件的末尾。</p>
<p>混合持久化的数据存储结构如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/混合持久化的数据存储结构.png" alt="混合持久化的数据存储结构"></p>
<h3 id="开启混合持久化"><a href="#开启混合持久化" class="headerlink" title="开启混合持久化"></a>开启混合持久化</h3><p>查询是否开启混合持久化可以使用 <code>config get aof-use-rdb-preamble</code> 命令。</p>
<p>Redis 5.0 默认值为 yes。 如果是其他版本的 Redis 首先需要检查一下，是否已经开启了混合持久化，如果关闭的情况下，可以通过以下两种方式开启：</p>
<ul>
<li>通过命令行开启</li>
<li>通过修改 Redis 配置文件开启</li>
</ul>
<h4 id="通过命令行开启"><a href="#通过命令行开启" class="headerlink" title="通过命令行开启"></a>通过命令行开启</h4><p>使用命令 <code>config set aof-use-rdb-preamble yes</code>。</p>
<blockquote>
<p>小贴士：命令行设置配置的缺点是重启 Redis 服务之后，设置的配置就会失效。</p>
</blockquote>
<h4 id="通过修改-Redis-配置文件开启"><a href="#通过修改-Redis-配置文件开启" class="headerlink" title="通过修改 Redis 配置文件开启"></a>通过修改 Redis 配置文件开启</h4><p>在 Redis 的根路径下找到 redis.conf 文件，把配置文件中的 <code>aof-use-rdb-preamble no</code> 改为 <code>aof-use-rdb-preamble yes</code>。</p>
<h3 id="实例运行"><a href="#实例运行" class="headerlink" title="实例运行"></a>实例运行</h3><p>当在混合持久化关闭的情况下，使用 <code>bgrewriteaof</code> 触发 AOF 文件重写之后，查看 <code>appendonly.aof</code> 文件的持久化日志，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/混合持久化关闭时AOF文件内容.png" alt="混合持久化关闭时AOF文件内容"></p>
<p>可以看出，当混合持久化关闭的情况下 AOF 持久化文件存储的为标准的 AOF 格式的文件。 当混合持久化开启的模式下，使用 <code>bgrewriteaof</code> 命令触发 AOF 文件重写，得到 <code>appendonly.aof</code> 的文件内容如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/混合持久化开启时AOF文件内容.png" alt="混合持久化开启时AOF文件内容"></p>
<p>可以看出 appendonly.aof 文件存储的内容是 <code>REDIS</code> 开头的 RDB 格式的内容，并非为 AOF 格式的日志。</p>
<h3 id="数据恢复和源码解析"><a href="#数据恢复和源码解析" class="headerlink" title="数据恢复和源码解析"></a>数据恢复和源码解析</h3><p>混合持久化的数据恢复和 AOF 持久化过程是一样的，只需要把 appendonly.aof 放到 Redis 的根目录，在 Redis 启动时，只要开启了 AOF 持久化，Redis 就会自动加载并恢复数据。 Redis 启动信息如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/混合持久化开启时Redis的启动日志.png" alt="混合持久化开启时Redis的启动日志"></p>
<p>可以看出 Redis 在服务器初始化的时候加载了 AOF 文件的内容。</p>
<h4 id="混合持久化的加载流程"><a href="#混合持久化的加载流程" class="headerlink" title="混合持久化的加载流程"></a>混合持久化的加载流程</h4><p>混合持久化的加载流程如下：</p>
<ol>
<li>判断是否开启 AOF 持久化，开启继续执行后续流程，未开启执行加载 RDB 文件的流程；</li>
<li>判断 appendonly.aof 文件是否存在，文件存在则执行后续流程；</li>
<li>判断 AOF 文件开头是 RDB 的格式, 先加载 RDB 内容再加载剩余的 AOF 内容；</li>
<li>判断 AOF 文件开头不是 RDB 的格式，直接以 AOF 格式加载整个文件。</li>
</ol>
<p>AOF 加载流程图如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/AOF加载流程图.png" alt="AOF加载流程图"></p>
<h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>Redis 判断 AOF 文件的开头是否是 RDB 格式的，是通过关键字 <code>REDIS</code> 判断的，RDB 文件的开头一定是 <code>REDIS</code> 关键字开头的，判断源码在 Redis 的 <code>src/aof.c</code> 中，核心代码如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> sig<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* "REDIS" */</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fread</span><span class="token punctuation">(</span>sig<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>fp<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">5</span> <span class="token operator">||</span> <span class="token function">memcmp</span><span class="token punctuation">(</span>sig<span class="token punctuation">,</span><span class="token string">"REDIS"</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// AOF 文件开头非 RDB 格式，非混合持久化文件</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fseek</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">SEEK_SET</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> readerr<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">/* RDB preamble. Pass loading the RDB functions. */</span>
    rio rdb<span class="token punctuation">;</span>

    <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_NOTICE<span class="token punctuation">,</span><span class="token string">"Reading RDB preamble from AOF file..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fseek</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">SEEK_SET</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> readerr<span class="token punctuation">;</span>
    <span class="token function">rioInitWithFile</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rdb<span class="token punctuation">,</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// AOF 文件开头是 RDB 格式，先加载 RDB 再加载 AOF</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rdbLoadRio</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rdb<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> C_OK<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span><span class="token string">"Error reading the RDB preamble of the AOF file, AOF loading aborted"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> readerr<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_NOTICE<span class="token punctuation">,</span><span class="token string">"Reading the remaining AOF tail..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 加载 AOF 格式的数据</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出 Redis 是通过判断 AOF 文件的开头是否是 <code>REDIS</code> 关键字，来确定此文件是否为混合持久化文件的。</p>
<blockquote>
<p>小贴士：AOF 格式的开头是 <code>*</code>，而 RDB 格式的开头是 <code>REDIS</code>。</p>
</blockquote>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>混合持久化优点：</p>
<ul>
<li>混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险。</li>
</ul>
<p>混合持久化缺点：</p>
<ul>
<li>AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；</li>
<li>兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了。</li>
</ul>
<h3 id="持久化最佳实践"><a href="#持久化最佳实践" class="headerlink" title="持久化最佳实践"></a>持久化最佳实践</h3><p>持久化虽然保证了数据不丢失，但同时拖慢了 Redis 的运行速度，那怎么更合理的使用 Redis 的持久化功能呢？ Redis 持久化的最佳实践可从以下几个方面考虑。</p>
<h4 id="控制持久化开关"><a href="#控制持久化开关" class="headerlink" title="控制持久化开关"></a>控制持久化开关</h4><p>使用者可根据实际的业务情况考虑，如果对数据的丢失不敏感的情况下，可考虑关闭 Redis 的持久化，这样所以的键值操作都在内存中，就可以保证最高效率的运行 Redis 了。 持久化关闭操作：</p>
<ul>
<li>关闭 RDB 持久化，使用命令： <code>config set save ""</code></li>
<li>关闭 AOF 和 混合持久化，使用命令： <code>config set appendonly no</code></li>
</ul>
<h4 id="主从部署"><a href="#主从部署" class="headerlink" title="主从部署"></a>主从部署</h4><p>使用主从部署，一台用于响应主业务，一台用于数据持久化，这样就可能让 Redis 更加高效的运行。</p>
<h4 id="使用混合持久化"><a href="#使用混合持久化" class="headerlink" title="使用混合持久化"></a>使用混合持久化</h4><p>混合持久化结合了 RDB 和 AOF 的优点，Redis 5.0 默认是开启的。</p>
<h4 id="使用配置更高的机器"><a href="#使用配置更高的机器" class="headerlink" title="使用配置更高的机器"></a>使用配置更高的机器</h4><p>Redis 对 CPU 的要求并不高，反而是对内存和磁盘的要求很高，因为 Redis 大部分时候都在做读写操作，使用更多的内存和更快的磁盘，对 Redis 性能的提高非常有帮助。</p>
<h3 id="参考-amp-鸣谢-2"><a href="#参考-amp-鸣谢-2" class="headerlink" title="参考&amp;鸣谢"></a>参考&amp;鸣谢</h3><ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/topics/persistence">https://redis.io/topics/persistence</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36318234/article/details/79994133">https://blog.csdn.net/qq_36318234/article/details/79994133</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wdliu/p/9377278.html">https://www.cnblogs.com/wdliu/p/9377278.html</a></li>
</ul>
<h2 id="06-字符串使用与内部实现原理"><a href="#06-字符串使用与内部实现原理" class="headerlink" title="06 字符串使用与内部实现原理"></a>06 字符串使用与内部实现原理</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wan-ming-zhu/p/18078015">https://www.cnblogs.com/wan-ming-zhu/p/18078015</a></p>
<p>Redis 发展到现在已经有 9 种数据类型了，其中最基础、最常用的数据类型有 5 种，它们分别是：字符串类型、列表类型、哈希表类型、集合类型、有序集合类型，而在这 5 种数据类型中最常用的是字符串类型，所以本文我们先从字符串的使用开始说起。</p>
<p>字符串类型的全称是 Simple Dynamic Strings 简称 SDS，中文意思是：简单动态字符串。它是以键值对 key-value 的形式进行存储的，根据 key 来存储和获取 value 值，它的使用相对来说比较简单，但在实际项目中应用非常广泛。</p>
<h3 id="1-字符串类型能做什么？"><a href="#1-字符串类型能做什么？" class="headerlink" title="1 字符串类型能做什么？"></a>1 字符串类型能做什么？</h3><p>字符串类型的使用场景有很多，但从功能的角度来区分，大致可分为以下两种：</p>
<ul>
<li>字符串存储和操作；</li>
<li>整数类型和浮点类型的存储和计算。</li>
</ul>
<p>字符串最常用的业务场景有以下几个。</p>
<h4 id="1）页面数据缓存"><a href="#1）页面数据缓存" class="headerlink" title="1）页面数据缓存"></a>1）页面数据缓存</h4><p>我们知道，一个系统最宝贵的资源就是数据库资源，随着公司业务的发展壮大，数据库的存储量也会越来越大，并且要处理的请求也越来越多，当数据量和并发量到达一定级别之后，数据库就变成了拖慢系统运行的”罪魁祸首”，为了避免这种情况的发生，我们可以把查询结果放入缓存(Redis)中，让下次同样的查询直接去缓存系统取结果，而非查询数据库，这样既减少了数据库的压力，同时也提高了程序的运行速度。</p>
<p>介于以上这个思路，我们可以把文章详情页的数据放入缓存系统。具体的做法是先将文章详情页序列化为字符串存入缓存，再从缓存中读取到字符串，反序列化成对象，然后再赋值到页面进行显示 (当然也可以用哈希类型进行存储，这会在下一篇文章中讲到)，这样我们就实现了文章详情页的缓存功能，架构流程对比图如下所示。</p>
<p>原始系统运行流程图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/原始系统运行流程图.png" alt="原始系统运行流程图"></p>
<p>引入缓存系统后的流程图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/引入缓存系统后的流程图.png" alt="引入缓存系统后的流程图"></p>
<h4 id="2）数字计算与统计"><a href="#2）数字计算与统计" class="headerlink" title="2）数字计算与统计"></a>2）数字计算与统计</h4><p>Redis 可以用来存储整数和浮点类型的数据，并且可以通过命令直接累加并存储整数信息，这样就省去了每次先要取数据、转换数据、拼加数据、再存入数据的麻烦，只需要使用一个命令就可以完成此流程，具体实现过程本文下半部分会讲。这样我们就可以使用此功能来实现访问量的统计，当有人访问时访问量 +1 就可以了。</p>
<h4 id="3）共享-Session-信息"><a href="#3）共享-Session-信息" class="headerlink" title="3）共享 Session 信息"></a>3）共享 Session 信息</h4><p>通常我们在开发后台管理系统时，会使用 Session 来保存用户的会话(登录)状态，这些 Session 信息会被保存在服务器端，但这只适用于单系统应用，如果是分布式系统此模式将不再适用。</p>
<p>例如用户一的 Session 信息被存储在服务器一，但第二次访问时用户一被分配到服务器二，这个时候服务器并没有用户一的 Session 信息，就会出现需要重复登录的问题。分布式系统每次会把请求随机分配到不同的服务器，因此我们需要借助缓存系统对这些 Session 信息进行统一的存储和管理，这样无论请求发送到那台服务器，服务器都会去统一的缓存系统获取相关的 Session 信息，这样就解决了分布式系统下 Session 存储的问题。</p>
<h3 id="2-字符串如何使用？"><a href="#2-字符串如何使用？" class="headerlink" title="2 字符串如何使用？"></a>2 字符串如何使用？</h3><p>通常我们会使用两种方式来操作 Redis：第一种是使用命令行来操作，例如 redis-cli；另一种是使用代码的方式来操作。</p>
<blockquote>
<p>小贴士：mset 是一个原子性(atomic)操作，所有给定 key 都会在同一时间内被设置，不会出现某些 key 被更新，而另一些 key 没被更新的情况。</p>
</blockquote>
<h3 id="3-代码实战"><a href="#3-代码实战" class="headerlink" title="3 代码实战"></a>3 代码实战</h3><h3 id="4-字符串的内部实现"><a href="#4-字符串的内部实现" class="headerlink" title="4 字符串的内部实现"></a>4 字符串的内部实现</h3><h4 id="1）源码分析"><a href="#1）源码分析" class="headerlink" title="1）源码分析"></a>1）源码分析</h4><p>Redis 3.2 之前 SDS 源码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sds</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> len<span class="token punctuation">;</span> <span class="token comment">// 已占用的字节数</span>
    <span class="token keyword">int</span> free<span class="token punctuation">;</span> <span class="token comment">// 剩余可以字节数</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 存储字符串的数据空间</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出 Redis 3.2 之前 SDS 内部是一个带有长度信息的字节数组，存储结构如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/Redis3.2之前SDS.png" alt="Redis3.2之前SDS"></p>
<p>为了更加有效的利用内存，Redis 3.2 优化了 SDS 的存储结构，源码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">char</span> <span class="token operator">*</span>sds<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr5</span> <span class="token punctuation">{</span> <span class="token comment">// 对应的字符串长度小于 1&lt;&lt;5</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr8</span> <span class="token punctuation">{</span> <span class="token comment">// 对应的字符串长度小于 1&lt;&lt;8</span>
    uint8_t len<span class="token punctuation">;</span> <span class="token comment">/* 已使用长度，1 字节存储 */</span>
    uint8_t alloc<span class="token punctuation">;</span> <span class="token comment">/* 总长度 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> 
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 真正存储字符串的数据空间</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr16</span> <span class="token punctuation">{</span> <span class="token comment">// 对应的字符串长度小于 1&lt;&lt;16</span>
    uint16_t len<span class="token punctuation">;</span> <span class="token comment">/* 已使用长度，2 字节存储 */</span>
    uint16_t alloc<span class="token punctuation">;</span> 
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> 
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr32</span> <span class="token punctuation">{</span> <span class="token comment">// 对应的字符串长度小于 1&lt;&lt;32</span>
    uint32_t len<span class="token punctuation">;</span> <span class="token comment">/* 已使用长度，4 字节存储 */</span>
    uint32_t alloc<span class="token punctuation">;</span> 
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> 
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr64</span> <span class="token punctuation">{</span> <span class="token comment">// 对应的字符串长度小于 1&lt;&lt;64</span>
    uint64_t len<span class="token punctuation">;</span> <span class="token comment">/* 已使用长度，8 字节存储 */</span>
    uint64_t alloc<span class="token punctuation">;</span> 
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> 
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样就可以针对不同长度的字符串申请相应的存储类型，从而有效的节约了内存使用。</p>
<h4 id="2）数据类型"><a href="#2）数据类型" class="headerlink" title="2）数据类型"></a>2）数据类型</h4><p>我们可以使用 <code>object encoding key</code> 命令来查看对象(键值对)存储的数据类型，当我们使用此命令来查询 SDS 对象时，发现 SDS 对象竟然包含了三种不同的数据类型：int、embstr 和 raw。</p>
<p>int 类型</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; set key 666
OK
127.0.0.1:6379&gt; object encoding key
"int"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>embstr 类型</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; set key abc
OK
127.0.0.1:6379&gt; object encoding key
"embstr"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>raw 类型</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; set key abcdefghigklmnopqrstyvwxyzabcdefghigklmnopqrs
OK
127.0.0.1:6379&gt; object encoding key
"raw"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>int 类型很好理解，整数类型对应的就是 int 类型，而字符串则对应是 embstr 类型，当字符串长度大于 44 字节时，会变为 raw 类型存储。</p>
<h4 id="3）为什么是-44-字节？"><a href="#3）为什么是-44-字节？" class="headerlink" title="3）为什么是 44 字节？"></a>3）为什么是 44 字节？</h4><p>在 Redis 中，如果 SDS 的存储值大于 64 字节时，Redis 的内存分配器会认为此对象为大字符串，并使用 raw 类型来存储，当数据小于 64 字节时(字符串类型)，会使用 embstr 类型存储。既然内存分配器的判断标准是 64 字节，那为什么 embstr 类型和 raw 类型的存储判断值是 44 字节？</p>
<p>这是因为 Redis 在存储对象时，会创建此对象的关联信息，redisObject 对象头和 SDS 自身属性信息，这些信息都会占用一定的存储空间，因此长度判断标准就从 64 字节变成了 44 字节。</p>
<p>在 Redis 中，所有的对象都会包含 redisObject 对象头。我们先来看 redisObject 对象的源码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisObject</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> type<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// 4 bit</span>
    <span class="token keyword">unsigned</span> encoding<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// 4 bit</span>
    <span class="token keyword">unsigned</span> lru<span class="token operator">:</span>LRU_BITS<span class="token punctuation">;</span> <span class="token comment">// 3 个字节</span>
    <span class="token keyword">int</span> refcount<span class="token punctuation">;</span> <span class="token comment">// 4 个字节</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span> <span class="token comment">// 8 个字节</span>
<span class="token punctuation">}</span> robj<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>它的参数说明如下：</p>
<ul>
<li><code>type</code>：对象的数据类型，例如：string、list、hash 等，占用 4 bits 也就是半个字符的大小；</li>
<li><code>encoding</code>：对象数据编码，占用 4 bits；</li>
<li><code>lru</code>：记录对象的 LRU(Least Recently Used 的缩写，即最近最少使用)信息，内存回收时会用到此属性，占用 24 bits(3 字节)；</li>
<li><code>refcount</code>：引用计数器，占用 32 bits(4 字节)；</li>
<li><code>*ptr</code>：对象指针用于指向具体的内容，占用 64 bits(8 字节)。</li>
</ul>
<p>redisObject 总共占用 <code>0.5 bytes + 0.5 bytes + 3 bytes + 4 bytes + 8 bytes = 16 bytes(字节)</code>。</p>
<p>了解了 redisObject 之后，我们再来看 SDS 自身的数据结构，从 SDS 的源码可以看出，SDS 的存储类型一共有 5 种：<code>SDS*TYPE*5</code>、<code>SDS*TYPE*8</code>、<code>SDS*TYPE*16</code>、<code>SDS*TYPE*32</code>、<code>SDS*TYPE*64</code>，在这些类型中最小的存储类型为 <code>SDS*TYPE*５</code>，但 <code>SDS*TYPE*５</code> 类型会默认转成 <code>SDS*TYPE*8</code>，以下源码可以证明，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/sdsnewlen.png" alt="sdsnewlen"></p>
<p>那我们直接来看 <code>SDS*TYPE*8</code> 的源码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr8</span> <span class="token punctuation">{</span>
    uint8_t len<span class="token punctuation">;</span> <span class="token comment">// 1 byte</span>
    uint8_t alloc<span class="token punctuation">;</span> <span class="token comment">// 1 byte</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">// 1 byte</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出除了内容数组(buf)之外，其他三个属性分别占用了 1 个字节，最终分隔字符等于 64 字节，减去 redisObject 的 16 个字节，再减去 SDS 自身的 3 个字节，再减去结束符 \0 结束符占用 1 个字节，最终的结果是 44 字节(64-16-3-1=44)，内存占用如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/为什么是44字节.png" alt="为什么是44字节"></p>
<blockquote>
<p>但 SDS 不需要用 \0 字符来标识字符串结尾，而是有个专门的 len 成员变量来记录长度，所以可存储包含 \0 的数据。但是 SDS 为了兼容部分 C 语言标准库的函数，还是会在结尾加上 \0 字符。注意：我们说 alloc 成员维护的是 buf[] 数组的长度，但是这个长度不包括结尾的 \0，比如 alloc 为 10，但 buf[] 的长度其实是 11。</p>
</blockquote>
<h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5 小结"></a>5 小结</h3><p>本文介绍了字符串的定义及其使用，它的使用主要分为：单键值对操作、多键值对操作、数字统计、键值对过期操作、字符串操作进阶等。同时也介绍了字符串使用的三个场景，字符串类型可用作为：页面数据缓存，可以缓存一些文章详情信息等；数字计算与统计，例如计算页面的访问次数；也可以用作 Session 共享，用来记录管理员的登录信息等。同时我们深入的介绍了字符串的五种数据存储结构，以及字符串的三种内部数据类型，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/字符串小结.png" alt="字符串小结"></p>
<p>同时我们也知道了 embstr 类型向 raw 类型转化，是因为每个 Redis 对象都包含了一个 redisObject 对象头和 SDS 自身属性占用了一定的空间，最终导致数据类型的判断长度是 44 字节。</p>
<h2 id="08-字典使用与内部实现原理"><a href="#08-字典使用与内部实现原理" class="headerlink" title="08 字典使用与内部实现原理"></a>08 字典使用与内部实现原理</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wan-ming-zhu/p/18079378">https://www.cnblogs.com/wan-ming-zhu/p/18079378</a></p>
<p>字典类型 (Hash) 又被成为散列类型或者是哈希表类型，它是将一个键值 (key) 和一个特殊的”哈希表”关联起来，这个”哈希表”表包含两列数据：字段和值。例如我们使用字典类型来存储一篇文章的详情信息，存储结构如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/使用字典类型来存储一篇文章.png" alt="使用字典类型来存储一篇文章"></p>
<p>同理我们也可以使用字典类型来存储用户信息，并且使用字典类型来存储此类信息，是不需要手动序列化和反序列化数据的，所以使用起来更加的方便和高效。</p>
<h3 id="1-基础使用"><a href="#1-基础使用" class="headerlink" title="1.基础使用"></a>1.基础使用</h3><h3 id="2-代码实战"><a href="#2-代码实战" class="headerlink" title="2.代码实战"></a>2.代码实战</h3><h3 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="3.数据结构"></a>3.数据结构</h3><p>字典类型本质上是由数组和链表结构组成的，来看字典类型的源码实现：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token punctuation">{</span> <span class="token comment">// dict.h</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">;</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token keyword">void</span> <span class="token operator">*</span>val<span class="token punctuation">;</span>
        uint64_t u64<span class="token punctuation">;</span>
        int64_t s64<span class="token punctuation">;</span>
        <span class="token keyword">double</span> d<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> v<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">// 下一个 entry</span>
<span class="token punctuation">}</span> dictEntry<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>字典类型的数据结构，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/字典类型的数据结构.png" alt="字典类型的数据结构"></p>
<p>通常情况下字典类型会使用数组的方式来存储相关的数据，但发生哈希冲突时才会使用链表的结构来存储数据。</p>
<h3 id="4-哈希冲突"><a href="#4-哈希冲突" class="headerlink" title="4.哈希冲突"></a>4.哈希冲突</h3><p>字典类型的存储流程是先将键值进行 Hash 计算，得到存储键值对应的数组索引，再根据数组索引进行数据存储，但在小概率事件下可能会出完全不相同的键值进行 Hash 计算之后，得到相同的 Hash 值，这种情况我们称之为哈希冲突。</p>
<p>哈希冲突一般通过链表的形式解决，相同的哈希值会对应一个链表结构，每次有哈希冲突时，就把新的元素插入到链表的尾部，请参考上面数据结构的那张图。</p>
<p>键值查询的流程如下：</p>
<ul>
<li>通过算法 (Hash，计算和取余等) 操作获得数组的索引值，根据索引值找到对应的元素；</li>
<li>判断元素和查找的键值是否相等，相等则成功返回数据，否则需要查看 next 指针是否还有对应其他元素，如果没有，则返回 null，如果有的话，重复此步骤。</li>
</ul>
<p>键值查询流程，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/键值查询流程.png" alt="键值查询流程"></p>
<h3 id="5-渐进式rehash"><a href="#5-渐进式rehash" class="headerlink" title="5.渐进式rehash"></a>5.渐进式rehash</h3><p>Redis 为了保证应用的高性能运行，提供了一个重要的机制——渐进式 rehash。 渐进式 rehash 是用来保证字典缩放效率的，也就是说在字典进行扩容或者缩容是会采取渐进式 rehash 的机制。</p>
<h4 id="1）扩容"><a href="#1）扩容" class="headerlink" title="1）扩容"></a>1）扩容</h4><p>当元素数量等于数组长度时就会进行扩容操作，源码在 dict.c 文件中，核心代码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">dictExpand</span><span class="token punctuation">(</span>dict <span class="token operator">*</span>d<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">/* 需要的容量小于当前容量，则不需要扩容 */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dictIsRehashing</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token operator">||</span> d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>used <span class="token operator">&gt;</span> size<span class="token punctuation">)</span>
        <span class="token keyword">return</span> DICT_ERR<span class="token punctuation">;</span>
    dictht n<span class="token punctuation">;</span> 
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> realsize <span class="token operator">=</span> <span class="token function">_dictNextPower</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 重新计算扩容后的值</span>
    <span class="token comment">/* 计算新的扩容大小等于当前容量，不需要扩容 */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>realsize <span class="token operator">==</span> d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>size<span class="token punctuation">)</span> <span class="token keyword">return</span> DICT_ERR<span class="token punctuation">;</span>
    <span class="token comment">/* 分配一个新的哈希表，并将所有指针初始化为NULL */</span>
    n<span class="token punctuation">.</span>size <span class="token operator">=</span> realsize<span class="token punctuation">;</span>
    n<span class="token punctuation">.</span>sizemask <span class="token operator">=</span> realsize<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    n<span class="token punctuation">.</span>table <span class="token operator">=</span> <span class="token function">zcalloc</span><span class="token punctuation">(</span>realsize<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>dictEntry<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    n<span class="token punctuation">.</span>used <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>table <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 第一次初始化</span>
        d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>
        <span class="token keyword">return</span> DICT_OK<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    d<span class="token operator">-&gt;</span>ht<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment">// 把增量输入放入新 ht[1] 中</span>
    d<span class="token operator">-&gt;</span>rehashidx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 非默认值 -1，表示需要进行 rehash</span>
    <span class="token keyword">return</span> DICT_OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从以上源码可以看出，如果需要扩容则会申请一个新的内存地址赋值给 ht[1]，并把字典的 rehashindex 设置为 0，表示之后需要进行 rehash 操作。</p>
<h4 id="2）缩容"><a href="#2）缩容" class="headerlink" title="2）缩容"></a>2）缩容</h4><p>当字典的使用容量不足总空间的 10% 时就会触发缩容，Redis 在进行缩容时也会把 rehashindex 设置为 0，表示之后需要进行 rehash 操作。</p>
<h4 id="3）渐进式rehash流程"><a href="#3）渐进式rehash流程" class="headerlink" title="3）渐进式rehash流程"></a>3）渐进式rehash流程</h4><p>在进行渐进式 rehash 时，会同时保留两个 hash 结构，新键值对加入时会直接插入到新的 hash 结构中，并会把旧 hash 结构中的元素一点一点的移动到新的 hash 结构中，当移除完最后一个元素时，清空旧 hash 结构，主要的执行流程如下：</p>
<ul>
<li>扩容或者缩容时把字典中的字段 rehashidx 标识为 0；</li>
<li>在执行定时任务或者执行客户端的 hset、hdel 等操作指令时，判断是否需要触发 rehash 操作（通过 rehashidx 标识判断），如果需要触发 rehash 操作，也就是调用 dictRehash 函数，dictRehash 函数会把 ht[0] 中的元素依次添加到新的 Hash 表 ht[1] 中；</li>
<li>rehash 操作完成之后，清空 Hash 表 ht[0]，然后对调 ht[1] 和 ht[0] 的值，把新的数据表 ht[1] 更改为 ht[0]，然后把字典中的 rehashidx 标识为 -1，表示不需要执行 rehash 操作。</li>
</ul>
<h3 id="7-小结"><a href="#7-小结" class="headerlink" title="7.小结"></a>7.小结</h3><p>本文我们学习了字典类型的操作命令和在代码中的使用，也明白了字典类型实际是由数组和链表组成的，当字典进行扩容或者缩容时会进行渐进式 rehash 操作，渐进式 rehash 是用来保证 Redis 运行效率的，它的执行流程是同时保留两个哈希表，把旧表中的元素一点一点的移动到新表中，查询的时候会先查询两个哈希表，当所有元素都移动到新的哈希表之后，就会删除旧的哈希表。</p>
<h2 id="10-列表使用与内部实现原理"><a href="#10-列表使用与内部实现原理" class="headerlink" title="10 列表使用与内部实现原理"></a>10 列表使用与内部实现原理</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wan-ming-zhu/p/18078658">https://www.cnblogs.com/wan-ming-zhu/p/18078658</a></p>
<p>列表类型 (List) 是一个使用链表结构存储的有序结构，它的元素插入会按照先后顺序存储到链表结构中，因此它的元素操作 (插入\删除) 时间复杂度为 O(1)，所以相对来说速度还是比较快的，但它的查询时间复杂度为 O(n)，因此查询可能会比较慢。</p>
<h3 id="1-基础使用-1"><a href="#1-基础使用-1" class="headerlink" title="1 基础使用"></a>1 基础使用</h3><p>列表类型的使用相对来说比较简单，对它的操作就相当操作一个没有任何 key 值的 value 集合，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/列表.png" alt="列表"></p>
<h3 id="3-内部实现"><a href="#3-内部实现" class="headerlink" title="3 内部实现"></a>3 内部实现</h3><p>我们先用 <code>debug encoding key</code> 来查看列表类型的内部存储类型，如下所示：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; object encoding list
"quicklist"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>从结果可以看出，列表类型的底层数据类型是 quicklist。</p>
<p>quicklist (快速列表) 是 Redis 3.2 引入的数据类型，早期的列表类型使用的是ziplist (压缩列表) 和双向链表组成的，Redis 3.2 改为用 quicklist 来存储列表元素。</p>
<p>我们来看下 quicklist 的实现源码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">quicklist</span> <span class="token punctuation">{</span> <span class="token comment">// src/quicklist.h</span>
    quicklistNode <span class="token operator">*</span>head<span class="token punctuation">;</span>
    quicklistNode <span class="token operator">*</span>tail<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> count<span class="token punctuation">;</span>        <span class="token comment">/* ziplist 的个数 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">;</span>          <span class="token comment">/* quicklist 的节点数 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> compress <span class="token operator">:</span> <span class="token number">16</span><span class="token punctuation">;</span> <span class="token comment">/* LZF 压缩算法深度 */</span>
    <span class="token comment">//...</span>
<span class="token punctuation">}</span> quicklist<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">quicklistNode</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">quicklistNode</span> <span class="token operator">*</span>prev<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">quicklistNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>zl<span class="token punctuation">;</span>           <span class="token comment">/* 对应的 ziplist */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> sz<span class="token punctuation">;</span>             <span class="token comment">/* ziplist 字节数 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> count <span class="token operator">:</span> <span class="token number">16</span><span class="token punctuation">;</span>     <span class="token comment">/* ziplist 个数 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> encoding <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>   <span class="token comment">/* RAW==1 or LZF==2 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> container <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">/* NONE==1 or ZIPLIST==2 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> recompress <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* 该节点先前是否被压缩 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> attempted_compress <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* 节点太小无法压缩 */</span>
    <span class="token comment">//...</span>
<span class="token punctuation">}</span> quicklistNode<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">quicklistLZF</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> sz<span class="token punctuation">;</span> 
    <span class="token keyword">char</span> compressed<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> quicklistLZF<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从以上源码可以看出 quicklist 是一个双向链表，链表中的每个节点实际上是一个 ziplist，它们的结构如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/列表的结构.png" alt="列表的结构"></p>
<p>ziplist 作为 quicklist 的实际存储结构，它本质是一个字节数组，ziplist 数据结构如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/ziplist数据结构.png" alt="ziplist数据结构"></p>
<p>其中的字段含义如下：</p>
<ul>
<li>zlbytes：压缩列表字节长度，占 4 字节；</li>
<li>zltail：压缩列表尾元素相对于起始元素地址的偏移量，占 4 字节；</li>
<li>zllen：压缩列表的元素个数；</li>
<li>entryX：压缩列表存储的所有元素，可以是字节数组或者是整数；</li>
<li>zlend：压缩列表的结尾，占 1 字节，固定值 0xFF；</li>
</ul>
<h3 id="4-源码解析"><a href="#4-源码解析" class="headerlink" title="4 源码解析"></a>4 源码解析</h3><h4 id="1）添加功能源码分析"><a href="#1）添加功能源码分析" class="headerlink" title="1）添加功能源码分析"></a>1）添加功能源码分析</h4><p>quicklist 添加操作对应函数是 quicklistPush，源码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">quicklistPush</span><span class="token punctuation">(</span>quicklist <span class="token operator">*</span>quicklist<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>value<span class="token punctuation">,</span> <span class="token keyword">const</span> size_t sz<span class="token punctuation">,</span>
                   <span class="token keyword">int</span> where<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>where <span class="token operator">==</span> QUICKLIST_HEAD<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 在列表头部添加元素</span>
        <span class="token function">quicklistPushHead</span><span class="token punctuation">(</span>quicklist<span class="token punctuation">,</span> value<span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>where <span class="token operator">==</span> QUICKLIST_TAIL<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 在列表尾部添加元素</span>
        <span class="token function">quicklistPushTail</span><span class="token punctuation">(</span>quicklist<span class="token punctuation">,</span> value<span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以 quicklistPushHead 为例，源码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">quicklistPushHead</span><span class="token punctuation">(</span>quicklist <span class="token operator">*</span>quicklist<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>value<span class="token punctuation">,</span> size_t sz<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    quicklistNode <span class="token operator">*</span>orig_head <span class="token operator">=</span> quicklist<span class="token operator">-&gt;</span>head<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>
            <span class="token function">_quicklistNodeAllowInsert</span><span class="token punctuation">(</span>quicklist<span class="token operator">-&gt;</span>head<span class="token punctuation">,</span> quicklist<span class="token operator">-&gt;</span>fill<span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 在头部节点插入元素</span>
        quicklist<span class="token operator">-&gt;</span>head<span class="token operator">-&gt;</span>zl <span class="token operator">=</span>
            <span class="token function">ziplistPush</span><span class="token punctuation">(</span>quicklist<span class="token operator">-&gt;</span>head<span class="token operator">-&gt;</span>zl<span class="token punctuation">,</span> value<span class="token punctuation">,</span> sz<span class="token punctuation">,</span> ZIPLIST_HEAD<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">quicklistNodeUpdateSz</span><span class="token punctuation">(</span>quicklist<span class="token operator">-&gt;</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 头部节点不能继续插入，需要新建 quicklistNode、ziplist 进行插入</span>
        quicklistNode <span class="token operator">*</span>node <span class="token operator">=</span> <span class="token function">quicklistCreateNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        node<span class="token operator">-&gt;</span>zl <span class="token operator">=</span> <span class="token function">ziplistPush</span><span class="token punctuation">(</span><span class="token function">ziplistNew</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> value<span class="token punctuation">,</span> sz<span class="token punctuation">,</span> ZIPLIST_HEAD<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">quicklistNodeUpdateSz</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 将新建的 quicklistNode 插入到 quicklist 结构中</span>
        <span class="token function">_quicklistInsertNodeBefore</span><span class="token punctuation">(</span>quicklist<span class="token punctuation">,</span> quicklist<span class="token operator">-&gt;</span>head<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    quicklist<span class="token operator">-&gt;</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
    quicklist<span class="token operator">-&gt;</span>head<span class="token operator">-&gt;</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>orig_head <span class="token operator">!=</span> quicklist<span class="token operator">-&gt;</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>quicklistPushHead 函数的执行流程，先判断 quicklist 的 head 节点是否可以插入数据，如果可以插入则使用 ziplist 的接口进行插入，否则就新建 quicklistNode 节点进行插入。</p>
<p>函数的入参是待插入的 quicklist，还有需要插入的值 value 以及他的大小 sz。</p>
<p>函数的返回值为 int，0 表示没有新建 head，1 表示新建了 head。</p>
<h4 id="2）删除功能源码分析"><a href="#2）删除功能源码分析" class="headerlink" title="2）删除功能源码分析"></a>2）删除功能源码分析</h4><p>quicklist 元素删除分为两种情况：单一元素删除和区间元素删除，它们都位于 src/quicklist.c 文件中。</p>
<h5 id="单一元素删除"><a href="#单一元素删除" class="headerlink" title="单一元素删除"></a>单一元素删除</h5><p>单一元素的删除函数是 quicklistDelEntry，源码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">quicklistDelEntry</span><span class="token punctuation">(</span>quicklistIter <span class="token operator">*</span>iter<span class="token punctuation">,</span> quicklistEntry <span class="token operator">*</span>entry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    quicklistNode <span class="token operator">*</span>prev <span class="token operator">=</span> entry<span class="token operator">-&gt;</span>node<span class="token operator">-&gt;</span>prev<span class="token punctuation">;</span>
    quicklistNode <span class="token operator">*</span>next <span class="token operator">=</span> entry<span class="token operator">-&gt;</span>node<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token comment">// 删除指定位置的元素</span>
    <span class="token keyword">int</span> deleted_node <span class="token operator">=</span> <span class="token function">quicklistDelIndex</span><span class="token punctuation">(</span><span class="token punctuation">(</span>quicklist <span class="token operator">*</span><span class="token punctuation">)</span>entry<span class="token operator">-&gt;</span>quicklist<span class="token punctuation">,</span>
                                         entry<span class="token operator">-&gt;</span>node<span class="token punctuation">,</span> <span class="token operator">&amp;</span>entry<span class="token operator">-&gt;</span>zi<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//...</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出 quicklistDelEntry 函数的底层，依赖 quicklistDelIndex 函数进行元素删除。</p>
<h5 id="区间元素删除"><a href="#区间元素删除" class="headerlink" title="区间元素删除"></a>区间元素删除</h5><p>区间元素删除的函数是 quicklistDelRange，源码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// start 表示开始删除的下标，count 表示要删除的个数</span>
<span class="token keyword">int</span> <span class="token function">quicklistDelRange</span><span class="token punctuation">(</span>quicklist <span class="token operator">*</span>quicklist<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">long</span> start<span class="token punctuation">,</span>
                      <span class="token keyword">const</span> <span class="token keyword">long</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> extent <span class="token operator">=</span> count<span class="token punctuation">;</span> 
    <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> extent <span class="token operator">&gt;</span> <span class="token punctuation">(</span>quicklist<span class="token operator">-&gt;</span>count <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 删除的元素个数大于已有元素</span>
        extent <span class="token operator">=</span> quicklist<span class="token operator">-&gt;</span>count <span class="token operator">-</span> start<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> extent <span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">-</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 删除指定的元素个数</span>
        extent <span class="token operator">=</span> <span class="token operator">-</span>start<span class="token punctuation">;</span> <span class="token comment">/* c.f. LREM -29 29; just delete until end. */</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//...</span>
    <span class="token comment">// extent 为剩余需要删除的元素个数，</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>extent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 保存下个 quicklistNode，因为本节点可能会被删除</span>
        quicklistNode <span class="token operator">*</span>next <span class="token operator">=</span> node<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> del<span class="token punctuation">;</span>
        <span class="token keyword">int</span> delete_entire_node <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>entry<span class="token punctuation">.</span>offset <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> extent <span class="token operator">&gt;=</span> node<span class="token operator">-&gt;</span>count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 删除整个 quicklistNode</span>
            delete_entire_node <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            del <span class="token operator">=</span> node<span class="token operator">-&gt;</span>count<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>entry<span class="token punctuation">.</span>offset <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> extent <span class="token operator">&gt;=</span> node<span class="token operator">-&gt;</span>count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 删除本节点的所有元素</span>
            del <span class="token operator">=</span> node<span class="token operator">-&gt;</span>count <span class="token operator">-</span> entry<span class="token punctuation">.</span>offset<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>entry<span class="token punctuation">.</span>offset <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// entry.offset&lt;0 表示从后向前，相反则表示从前向后剩余的元素个数</span>
            del <span class="token operator">=</span> <span class="token operator">-</span>entry<span class="token punctuation">.</span>offset<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>del <span class="token operator">&gt;</span> extent<span class="token punctuation">)</span>
                del <span class="token operator">=</span> extent<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 删除本节点部分元素</span>
            del <span class="token operator">=</span> extent<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">D</span><span class="token punctuation">(</span><span class="token string">"[%ld]: asking to del: %ld because offset: %d; (ENTIRE NODE: %d), "</span>
          <span class="token string">"node count: %u"</span><span class="token punctuation">,</span>
          extent<span class="token punctuation">,</span> del<span class="token punctuation">,</span> entry<span class="token punctuation">.</span>offset<span class="token punctuation">,</span> delete_entire_node<span class="token punctuation">,</span> node<span class="token operator">-&gt;</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>delete_entire_node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">__quicklistDelNode</span><span class="token punctuation">(</span>quicklist<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">quicklistDecompressNodeForUse</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
            node<span class="token operator">-&gt;</span>zl <span class="token operator">=</span> <span class="token function">ziplistDeleteRange</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>zl<span class="token punctuation">,</span> entry<span class="token punctuation">.</span>offset<span class="token punctuation">,</span> del<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">quicklistNodeUpdateSz</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
            node<span class="token operator">-&gt;</span>count <span class="token operator">-=</span> del<span class="token punctuation">;</span>
            quicklist<span class="token operator">-&gt;</span>count <span class="token operator">-=</span> del<span class="token punctuation">;</span>
            <span class="token function">quicklistDeleteIfEmpty</span><span class="token punctuation">(</span>quicklist<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">)</span>
                <span class="token function">quicklistRecompressOnly</span><span class="token punctuation">(</span>quicklist<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 剩余待删除元素的个数</span>
        extent <span class="token operator">-=</span> del<span class="token punctuation">;</span>
        <span class="token comment">// 下个 quicklistNode</span>
        node <span class="token operator">=</span> next<span class="token punctuation">;</span>
        <span class="token comment">// 从下个 quicklistNode 起始位置开始删除</span>
        entry<span class="token punctuation">.</span>offset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从上面代码可以看出，quicklist 在区间删除时，会先找到 start 所在的 quicklistNode，计算删除的元素是否小于要删除的 count，如果不满足删除的个数，则会移动至下一个 quicklistNode 继续删除，依次循环直到删除完成为止。</p>
<p>quicklistDelRange 函数的返回值为 int 类型，当返回 1 时表示成功的删除了指定区间的元素，返回 0 时表示没有删除任何元素。</p>
<h4 id="3）更多源码"><a href="#3）更多源码" class="headerlink" title="3）更多源码"></a>3）更多源码</h4><p>除了上面介绍的几个常用函数之外，还有一些更多的函数，例如：</p>
<ul>
<li>quicklistCreate：创建 quicklist；</li>
<li>quicklistInsertAfter：在某个元素的后面添加数据；</li>
<li>quicklistInsertBefore：在某个元素的前面添加数据；</li>
<li>quicklistPop：取出并删除列表的第一个或最后一个元素；</li>
<li>quicklistReplaceAtIndex：替换某个元素。</li>
</ul>
<h3 id="6-小结"><a href="#6-小结" class="headerlink" title="6 小结"></a>6 小结</h3><p>通过本文我们可以知道列表类型并不是简单的双向链表，而是采用了 quicklist 的数据结构对数据进行存取，quicklist 是 Redis 3.2 新增的数据类型，它的底层采取的是压缩列表加双向链表的存储结构，quicklist 为了存储更多的数据，会对每个 quicklistNode 节点进行压缩，这样就可以有效的存储更多的消息队列或者文章的数据了。</p>
<h2 id="12-集合使用与内部实现原理"><a href="#12-集合使用与内部实现原理" class="headerlink" title="12 集合使用与内部实现原理"></a>12 集合使用与内部实现原理</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wan-ming-zhu/p/18079410">https://www.cnblogs.com/wan-ming-zhu/p/18079410</a></p>
<p>集合类型 (Set) 是一个无序并唯一的键值集合。</p>
<p>之所以说集合类型是一个无序集合，是因为它的存储顺序不会按照插入的先后顺序进行存储，如下代码所示：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; sadd myset v2 v1 v3 #插入数据 v2、v1、v3 
(integer) 3
127.0.0.1:6379&gt; smembers myset #查询数据
1) "v1"
2) "v3"
3) "v2"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从上面代码执行结果可以看出，myset 的存储顺序并不是以插入的先后顺序进行存储的。</p>
<p>集合类型和列表类型的区别如下：</p>
<ul>
<li>列表可以存储重复元素，集合只能存储非重复元素；</li>
<li>列表是按照元素的先后顺序存储元素的，而集合则是无序方式存储元素的。</li>
</ul>
<h3 id="3-内部实现-1"><a href="#3-内部实现-1" class="headerlink" title="3 内部实现"></a>3 内部实现</h3><p>集合类型是由 intset (整数集合) 或 hashtable (普通哈希表) 组成的。当集合类型以 hashtable 存储时，哈希表的 key 为要插入的元素值，而哈希表的 value 则为 Null，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/集合内部实现.png" alt="集合内部实现"></p>
<p>当集合中所有的值都为整数时，Redis 会使用 intset 结构来存储，如下代码所示：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; sadd myset 1 9 3 -2
(integer) 4
127.0.0.1:6379&gt; object encoding myset
"intset"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>从上面代码可以看出，<strong>当所有元素都为整数时，集合会以 intset 结构进行(数据)存储</strong>。 当发生以下两种情况时，会导致集合类型使用 hashtable 而非 intset 存储：</p>
<ol>
<li>当元素的个数超过一定数量时，默认是 512 个，该值可通过命令 <code>set-max-intset-entries xxx</code> 来配置。</li>
<li><p>当元素为非整数时，集合将会使用 hashtable 来存储，如下代码所示：</p>
 <pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; sadd myht "redis" "db"
(integer) 2
127.0.0.1:6379&gt; object encoding myht
"hashtable"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>从上面代码可以看出，<strong>当元素为非整数时，集合会使用 hashtable 进行存储。</strong></p>
</li>
</ol>
<h3 id="4-源码解析-1"><a href="#4-源码解析-1" class="headerlink" title="4 源码解析"></a>4 源码解析</h3><p>集合源码在 t_set.c 文件中，核心源码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 
 * 添加元素到集合
 * 如果当前值已经存在，则返回 0 不作任何处理，否则就添加该元素，并返回 1。
 */</span>
<span class="token keyword">int</span> <span class="token function">setTypeAdd</span><span class="token punctuation">(</span>robj <span class="token operator">*</span>subject<span class="token punctuation">,</span> sds value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> llval<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>subject<span class="token operator">-&gt;</span>encoding <span class="token operator">==</span> OBJ_ENCODING_HT<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 字典类型</span>
        dict <span class="token operator">*</span>ht <span class="token operator">=</span> subject<span class="token operator">-&gt;</span>ptr<span class="token punctuation">;</span>
        dictEntry <span class="token operator">*</span>de <span class="token operator">=</span> <span class="token function">dictAddRaw</span><span class="token punctuation">(</span>ht<span class="token punctuation">,</span>value<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>de<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 把 value 作为字典到 key，将 Null 作为字典到 value，将元素存入到字典</span>
            <span class="token function">dictSetKey</span><span class="token punctuation">(</span>ht<span class="token punctuation">,</span>de<span class="token punctuation">,</span><span class="token function">sdsdup</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">dictSetVal</span><span class="token punctuation">(</span>ht<span class="token punctuation">,</span>de<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>subject<span class="token operator">-&gt;</span>encoding <span class="token operator">==</span> OBJ_ENCODING_INTSET<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// inset 数据类型</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isSdsRepresentableAsLongLong</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span><span class="token operator">&amp;</span>llval<span class="token punctuation">)</span> <span class="token operator">==</span> C_OK<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            uint8_t success <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            subject<span class="token operator">-&gt;</span>ptr <span class="token operator">=</span> <span class="token function">intsetAdd</span><span class="token punctuation">(</span>subject<span class="token operator">-&gt;</span>ptr<span class="token punctuation">,</span>llval<span class="token punctuation">,</span><span class="token operator">&amp;</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>success<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 超过 inset 的最大存储数量，则使用字典类型存储</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">intsetLen</span><span class="token punctuation">(</span>subject<span class="token operator">-&gt;</span>ptr<span class="token punctuation">)</span> <span class="token operator">&gt;</span> server<span class="token punctuation">.</span>set_max_intset_entries<span class="token punctuation">)</span>
                    <span class="token function">setTypeConvert</span><span class="token punctuation">(</span>subject<span class="token punctuation">,</span>OBJ_ENCODING_HT<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 转化为整数类型失败，使用字典类型存储</span>
            <span class="token function">setTypeConvert</span><span class="token punctuation">(</span>subject<span class="token punctuation">,</span>OBJ_ENCODING_HT<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token function">serverAssert</span><span class="token punctuation">(</span><span class="token function">dictAdd</span><span class="token punctuation">(</span>subject<span class="token operator">-&gt;</span>ptr<span class="token punctuation">,</span><span class="token function">sdsdup</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> DICT_OK<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 未知编码(类型)</span>
        <span class="token function">serverPanic</span><span class="token punctuation">(</span><span class="token string">"Unknown set encoding"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以上这些代码验证了，我们上面所说的内容，当元素都为整数并且元素的个数没有到达设置的最大值时，键值的存储使用的是 intset 的数据结构，反之到元素超过了一定的范围，又或者是存储的元素为非整数时，集合会选择使用 hashtable 的数据结构进行存储。</p>
<h2 id="14-有序集合使用与内部实现原理"><a href="#14-有序集合使用与内部实现原理" class="headerlink" title="14 有序集合使用与内部实现原理"></a>14 有序集合使用与内部实现原理</h2><p>有序集合类型 (Sorted Set) 相比于集合类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序结合的元素值，一个是排序值。有序集合的存储元素值也是不能重复的，但分值是可以重复的。</p>
<h3 id="3-内部实现-2"><a href="#3-内部实现-2" class="headerlink" title="3 内部实现"></a>3 内部实现</h3><p>有序集合是由 ziplist (压缩列表) 或 skiplist (跳跃表) 组成的。</p>
<h4 id="1）ziplist"><a href="#1）ziplist" class="headerlink" title="1）ziplist"></a>1）ziplist</h4><p>当数据比较少时，有序集合使用的是 ziplist 存储的，如下代码所示：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; zadd myzset 1 db 2 redis 3 mysql
(integer) 3
127.0.0.1:6379&gt; object encoding myzset
"ziplist"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>从结果可以看出，有序集合把 myset 键值对存储在 ziplist 结构中了。 有序集合使用 ziplist 格式存储必须满足以下两个条件：</p>
<ul>
<li>有序集合保存的元素个数要小于 128 个；</li>
<li>有序集合保存的所有元素成员的长度都必须小于 64 字节。</li>
</ul>
<p>如果不能满足以上两个条件中的任意一个，有序集合将会使用 skiplist 结构进行存储。 接下来我们来测试以下，当有序集合中某个元素长度大于 64 字节时会发生什么情况？ 代码如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; zadd zmaxleng 1.0 redis
(integer) 1
127.0.0.1:6379&gt; object encoding zmaxleng
"ziplist"
127.0.0.1:6379&gt; zadd zmaxleng 2.0 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
(integer) 1
127.0.0.1:6379&gt; object encoding zmaxleng
"skiplist"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过以上代码可以看出，当有序集合保存的所有元素成员的长度大于 64 字节时，有序集合就会从 ziplist 转换成为 skiplist。</p>
<blockquote>
<p>小贴士：可以通过配置文件中的 <code>zset-max-ziplist-entries</code>（默认 128）和 <code>zset-max-ziplist-value</code>（默认 64）来设置有序集合使用 ziplist 存储的临界值。</p>
</blockquote>
<h4 id="2）skiplist"><a href="#2）skiplist" class="headerlink" title="2）skiplist"></a>2）skiplist</h4><p>skiplist 数据编码底层是使用 zset 结构实现的，而 zset 结构中包含了一个字典和一个跳跃表，源码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zset</span> <span class="token punctuation">{</span>
    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span>
    zskiplist <span class="token operator">*</span>zsl<span class="token punctuation">;</span>
<span class="token punctuation">}</span> zset<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>更多关于跳跃表的源码实现，会在后面的章节详细介绍。</p>
<blockquote>
<p>注意：虽然查看结构时显示的是 skiplist，但它除了使用跳表之外，还使用了哈希表。所以有序集合比较特殊，它是唯一同时使用两种数据结构的类型。这样的好处是既能进行高效的范围查询，也能进行高效的单点查询。</p>
</blockquote>
<h5 id="跳跃表实现原理"><a href="#跳跃表实现原理" class="headerlink" title="跳跃表实现原理"></a>跳跃表实现原理</h5><p>跳跃表的结构如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/跳跃表的结构.png" alt="跳跃表的结构"></p>
<p>根据以上图片展示，当我们在跳跃表中查询值 32 时，执行流程如下：</p>
<ol>
<li>从最上层开始找，1 比 32 小，在当前层移动到下一个节点进行比较；</li>
<li>7 比 32 小，当前层移动下一个节点比较，由于下一个节点指向 Null，所以以 7 为目标，移动到下一层继续向后比较；</li>
<li>18 小于 32，继续向后移动查找，对比 77 大于 32，以 18 为目标，移动到下一层继续向后比较；</li>
<li>对比 32 等于 32，值被顺利找到。</li>
</ol>
<p>从上面的流程可以看出，跳跃表会想从最上层开始找起，依次向后查找，如果本层的节点大于要找的值，或者本层的节点为 Null 时，以上一个节点为目标，往下移一层继续向后查找并循环此流程，直到找到该节点并返回，如果对比到最后一个元素仍未找到，则返回 Null。</p>
<h5 id="为什么是跳跃表？而非红黑树？"><a href="#为什么是跳跃表？而非红黑树？" class="headerlink" title="为什么是跳跃表？而非红黑树？"></a>为什么是跳跃表？而非红黑树？</h5><p>因为跳跃表的性能和红黑树基本相近，但却比红黑树更好实现，所有 Redis 的有序集合会选用跳跃表来实现存储。</p>
<h2 id="16-Redis-事务深入解析"><a href="#16-Redis-事务深入解析" class="headerlink" title="16 Redis 事务深入解析"></a>16 Redis 事务深入解析</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wan-ming-zhu/p/18079959">https://www.cnblogs.com/wan-ming-zhu/p/18079959</a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>事务指的是提供一种将多个命令打包，一次性按顺序地执行的机制，并且保证服务器只有在执行完事务中的所有命令后，才会继续处理此客户端的其他命令。</p>
<p>事务也是其他关系型数据库所必备的基础功能，以支付的场景为例，正常情况下只有正常消费完成之后，才会减去账户余额。但如果没有事务的保障，可能会发生消费失败了，但依旧会把账户的余额给扣减了，我想这种情况应该任何人都无法接受吧？所以事务是数据库中一项非常重要的基础功能。</p>
<h3 id="事务基本使用"><a href="#事务基本使用" class="headerlink" title="事务基本使用"></a>事务基本使用</h3><p>Redis 中的事务从开始到结束也是要经历三个阶段：</p>
<ul>
<li>开启事务</li>
<li>命令入列</li>
<li>执行事务/放弃事务</li>
</ul>
<p>其中，开启事务使用 multi 命令，事务执行使用 exec 命令，放弃事务使用 discard 命令。</p>
<h4 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h4><p>multi 命令用于开启事务，实现代码如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt; multi
OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>multi 命令可以让客户端从非事务模式状态，变为事务模式状态，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/multi.png" alt="multi"></p>
<p>注意：multi 命令不能嵌套使用，如果已经开启了事务的情况下，再执行 multi 命令，会提示如下错误：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; multi
OK
127.0.0.1:6379&gt; multi
(error) ERR MULTI calls can not be nested<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="命令入列"><a href="#命令入列" class="headerlink" title="命令入列"></a>命令入列</h4><p>客户端进入事务状态之后，执行的所有常规 Redis 操作命令（非触发事务执行或放弃和导致入列异常的命令）会依次入列，命令入列成功后会返回 QUEUED，如下代码所示：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt; multi
OK
&gt; set k v
QUEUED
&gt; get k
QUEUED<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/Redis事务状态后命令执行流程.png" alt="Redis事务状态后命令执行流程"></p>
<p>注意：命令会按照先进先出（FIFO）的顺序出入列，也就是说事务会按照命令的入列顺序，从前往后依次执行。</p>
<h4 id="执行事务-放弃事务"><a href="#执行事务-放弃事务" class="headerlink" title="执行事务/放弃事务"></a>执行事务/放弃事务</h4><p>执行事务的命令是 exec，放弃事务的命令是 discard。</p>
<p>执行事务示例代码如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt; multi
OK
&gt; set k v2
QUEUED
&gt; exec
1) OK
&gt; get k
"v2"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>放弃事务示例代码如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt; multi
OK
&gt; set k v3
QUEUED
&gt; discard
OK
&gt; get k
"v2"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/Redis执行事务放弃事务.png" alt="Redis执行事务放弃事务"></p>
<h3 id="事务错误-amp-回滚"><a href="#事务错误-amp-回滚" class="headerlink" title="事务错误&amp;回滚"></a>事务错误&amp;回滚</h3><p>事务执行中的错误分为以下三类：</p>
<ul>
<li>执行时才会出现的错误（简称：执行时错误）；</li>
<li>入列时错误，不会终止整个事务；</li>
<li>入列时错误，会终止整个事务。</li>
</ul>
<h4 id="执行时错误"><a href="#执行时错误" class="headerlink" title="执行时错误"></a>执行时错误</h4><p>示例代码如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt; get k
"v"
&gt; multi
OK
&gt; set k v2
QUEUED
&gt; expire k 10s
QUEUED
&gt; exec
1) OK
2) (error) ERR value is not an integer or out of range
&gt; get k
"v2"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>执行命令解释如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/执行时才会出现的错误.png" alt="执行时才会出现的错误"></p>
<p>从以上结果可以看出，即使事务队列中某个命令在执行期间发生了错误，事务也会继续执行，直到事务队列中所有命令执行完成。</p>
<h4 id="入列错误不会导致事务结束"><a href="#入列错误不会导致事务结束" class="headerlink" title="入列错误不会导致事务结束"></a>入列错误不会导致事务结束</h4><p>示例代码如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt; get k
"v"
&gt; multi
OK
&gt; set k v2
QUEUED
&gt; multi
(error) ERR MULTI calls can not be nested
&gt; exec
1) OK
&gt; get k
"v2"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>执行命令解释如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/入列错误不会导致事务结束.png" alt="入列错误不会导致事务结束"></p>
<p>可以看出，重复执行 multi 会导致入列错误，但不会终止事务，最终查询的结果是事务执行成功了。除了重复执行 multi 命令，还有在事务状态下执行 watch 也是同样的效果，下文会详细讲解关于 watch 的内容。</p>
<h4 id="入列错误导致事务结束"><a href="#入列错误导致事务结束" class="headerlink" title="入列错误导致事务结束"></a>入列错误导致事务结束</h4><p>示例代码如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt; get k
"v2"
&gt; multi
OK
&gt; set k v3
QUEUED
&gt; set k
(error) ERR wrong number of arguments for 'set' command
&gt; exec
(error) EXECABORT Transaction discarded because of previous errors.
&gt; get k
"v2"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>执行命令解释如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/入列错误导致事务结束.png" alt="入列错误导致事务结束"></p>
<p>所以我们看到错误可以分为两种：一种是事务执行时才会发现的错误；另一种是在入队的时候就能发现的错误。</p>
<ul>
<li>执行时出现的错误，不会影响事务队列中的其它命令；即使某条命令失败，其它命令依旧可以正常执行；</li>
<li>入队时发现的错误，如果是 multi、watch 这种错误也不会终止事务，只是不会让它入队；但如果是命令不符合 Redis 的规则，那么这种错误就类似于编程语言的语法错误，直接编译时就报错，没必要等到执行了。所以在 Redis 中的表现就是整个事务都废弃掉，里面的命令一条也不会执行；</li>
</ul>
<h4 id="为什么不支持事务回滚？"><a href="#为什么不支持事务回滚？" class="headerlink" title="为什么不支持事务回滚？"></a>为什么不支持事务回滚？</h4><p>Redis 官方文档的解释如下：</p>
<blockquote>
<p>If you have a relational databases background, the fact that Redis commands can fail during a transaction, but still Redis will execute the rest of the transaction instead of rolling back, may look odd to you.</p>
<p>However there are good opinions for this behavior:</p>
<ul>
<li>Redis commands can fail only if called with a wrong syntax (and the problem is not detectable during the command queueing), or against keys holding the wrong data type: this means that in practical terms a failing command is the result of a programming errors, and a kind of error that is very likely to be detected during development, and not in production.</li>
<li>Redis is internally simplified and faster because it does not need the ability to roll back.</li>
</ul>
<p>An argument against Redis point of view is that bugs happen, however it should be noted that in general the roll back does not save you from programming errors. For instance if a query increments a key by 2 instead of 1, or increments the wrong key, there is no way for a rollback mechanism to help. Given that no one can save the programmer from his or her errors, and that the kind of errors required for a Redis command to fail are unlikely to enter in production, we selected the simpler and faster approach of not supporting roll backs on errors.</p>
</blockquote>
<p>大概的意思是，作者不支持事务回滚的原因有以下两个：</p>
<ul>
<li>他认为 Redis 事务的执行时，错误通常都是编程错误造成的，这种错误通常只会出现在开发环境中，而很少会在实际的生产环境中出现，所以他认为没有必要为 Redis 开发事务回滚功能；</li>
<li>不支持事务回滚是因为这种复杂的功能和 Redis 追求的简单高效的设计主旨不符合。</li>
</ul>
<blockquote>
<p>这里不支持事务回滚，指的是不支持运行时错误的事务回滚。</p>
</blockquote>
<h4 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h4><p>watch 命令用于客户端并发情况下，为事务提供一个乐观锁（CAS，Check And Set），也就是可以用 watch 命令来监控一个或多个变量，如果在事务的过程中，<strong>某个监控项被修改了，那么整个事务就会终止执行。</strong></p>
<p>watch 基本语法如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">watch key [key ...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>watch 示例代码如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt; watch k
OK
&gt; multi
OK
&gt; set k v2
QUEUED
&gt; exec
(nil)
&gt; get k
"v"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意：以上事务在执行期间，也就是开启事务（multi）之后，执行事务（exec）之前，模拟多客户端并发操作了变量 k 的值，这个时候再去执行事务，才会出现如上结果，exec 执行的结果为 nil。</p>
<p>可以看出，当执行 exec 返回的结果是 nil 时，表示 watch 监控的对象在事务执行的过程中被修改了。从 get k 的结果也可以印证，因为事务中设置的值 <code>set k v2</code> 并未正常执行。</p>
<p>执行流程如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/watch执行流程.png" alt="watch执行流程"></p>
<p>注意： watch 命令只能在客户端开启事务之前执行，在事务中执行 watch 命令会引发错误，但不会造成整个事务失败，如下代码所示：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt; multi
OK
&gt; set k v3
QUEUED
&gt; watch k
(error) ERR WATCH inside MULTI is not allowed
&gt; exec
1) OK
&gt; get k
"v3"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>执行命令解释如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/watch执行命令解释.png" alt="watch执行命令解释"></p>
<blockquote>
<p>一个 watch 对应一个事务，watch 之后只要执行了事务，不管里面的命令是成功还是失败，这个 watch 就算是结束了。再次开启事务，设置的 key 就是不被监视的 key 了。</p>
</blockquote>
<p>unwatch 命令用于清除所有之前监控的所有对象（键值对）。</p>
<p>unwatch 示例如下所示：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt; set k v
OK
&gt; watch k
OK
&gt; multi
OK
&gt; unwatch
QUEUED
&gt; set k v2
QUEUED
&gt; exec
1) OK
2) OK
&gt; get k
"v2"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出，即使在事务的执行过程中，k 值被修改了，因为调用了 unwatch 命令，整个事务依然会顺利执行。</p>
<h4 id="知识点练习"><a href="#知识点练习" class="headerlink" title="知识点练习"></a>知识点练习</h4><p>以下两个客户端交替执行的结果是？</p>
<p>客户端一，执行如下命令：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt; set k v
OK
&gt; watch k
OK
&gt; multi
OK
&gt; set k v2
QUEUED<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>客户端二，执行如下命令：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt; set k v
OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>客户端一，再执行如下命令：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">&gt; exec<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>此时 k 的值为多少？</p>
<p>答： k 的值为 v，而非 v2。</p>
<p>题目解析：本题考查的是 watch 命令监控时，即使把原对象的值重新赋值给了原对象，这个时候 watch 命令也会认为监控对象还是被修改了。</p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>事务为多个命令提供一次性按顺序执行的机制，与 Redis 事务相关的命令有以下五个：</p>
<ul>
<li>multi：开启事务</li>
<li>exec：执行事务</li>
<li>discard：丢弃事务</li>
<li>watch：为事务提供乐观锁实现</li>
<li>unwatch：取消监控（取消事务中的乐观锁）</li>
</ul>
<p>正常情况下 Redis 事务分为三个阶段：开启事务、命令入列、执行事务。Redis 事务并不支持运行时错误的事务回滚，但在某些入列错误，如 set key 或者是 watch 监控项被修改时，提供整个事务回滚的功能。</p>
<h2 id="17-Redis-键值过期操作"><a href="#17-Redis-键值过期操作" class="headerlink" title="17 Redis 键值过期操作"></a>17 Redis 键值过期操作</h2><h3 id="过期设置"><a href="#过期设置" class="headerlink" title="过期设置"></a>过期设置</h3><p>Redis 中设置过期时间主要通过以下四种方式：</p>
<ul>
<li><code>expire key seconds</code>：设置 key 在 n 秒后过期；</li>
<li><code>pexpire key milliseconds</code>：设置 key 在 n 毫秒后过期；</li>
<li><code>expireat key timestamp</code>：设置 key 在某个时间戳（精确到秒）之后过期；</li>
<li><code>pexpireat key millisecondsTimestamp</code>：设置 key 在某个时间戳（精确到毫秒）之后过期；</li>
</ul>
<h3 id="字符串中的过期操作"><a href="#字符串中的过期操作" class="headerlink" title="字符串中的过期操作"></a>字符串中的过期操作</h3><p>字符串中几个直接操作过期时间的方法，如下列表：</p>
<ul>
<li><code>set key value ex seconds</code>：设置键值对的同时指定过期时间（精确到秒）；<br>-<code>set key value px milliseconds</code>：设置键值对的同时指定过期时间（精确到毫秒）；</li>
<li><code>setex key seconds value</code>：设置键值对的同时指定过期时间（精确到秒）。</li>
</ul>
<h3 id="移除过期时间"><a href="#移除过期时间" class="headerlink" title="移除过期时间"></a>移除过期时间</h3><p>使用命令： persist key 可以移除键值的过期时间。</p>
<h3 id="持久化中的过期键"><a href="#持久化中的过期键" class="headerlink" title="持久化中的过期键"></a>持久化中的过期键</h3><p>Redis 持久化文件有两种格式：RDB（Redis Database）和 AOF（Append Only File），下面我们分别来看过期键在这两种格式中的呈现状态。</p>
<h4 id="RDB-中的过期键"><a href="#RDB-中的过期键" class="headerlink" title="RDB 中的过期键"></a>RDB 中的过期键</h4><p>RDB 文件分为两个阶段，RDB 文件生成阶段和加载阶段。</p>
<h5 id="1-RDB-文件生成"><a href="#1-RDB-文件生成" class="headerlink" title="1. RDB 文件生成"></a>1. RDB 文件生成</h5><p>从内存状态持久化成 RDB（文件）的时候，会对 key 进行过期检查，过期的键不会被保存到新的 RDB 文件中，因此 Redis 中的过期键不会对生成新 RDB 文件产生任何影响。</p>
<h5 id="2-RDB-文件加载"><a href="#2-RDB-文件加载" class="headerlink" title="2. RDB 文件加载"></a>2. RDB 文件加载</h5><p>RDB 加载分为以下两种情况：</p>
<ul>
<li>如果 Redis 是主服务器运行模式的话，在载入 RDB 文件时，程序会对文件中保存的键进行检查，过期键不会被载入到数据库中。所以过期键不会对载入 RDB 文件的主服务器造成影响；</li>
<li>如果 Redis 是从服务器运行模式的话，在载入 RDB 文件时，不论键是否过期都会被载入到数据库中。但由于主从服务器在进行数据同步时，从服务器的数据会被清空。所以一般来说，过期键对载入 RDB 文件的从服务器也不会造成影响。</li>
</ul>
<p>RDB 文件加载的源码可以在 rdb.c 文件的 rdbLoad() 函数中找到，源码所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Check if the key already expired. This function is used when loading
* an RDB file from disk, either at startup, or when an RDB was
* received from the master. In the latter case, the master is
* responsible for key expiry. If we would expire keys here, the
* snapshot taken by the master may not be reflected on the slave. 
*
* 如果服务器为主节点的话，
* 那么在键已经过期的时候，不再将它们关联到数据库中去
*/</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>masterhost <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> expiretime <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> expiretime <span class="token operator">&lt;</span> now<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">decrRefCount</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">decrRefCount</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 跳过</span>
    <span class="token keyword">continue</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="AOF-中的过期键"><a href="#AOF-中的过期键" class="headerlink" title="AOF 中的过期键"></a>AOF 中的过期键</h4><h5 id="1-AOF-文件写入"><a href="#1-AOF-文件写入" class="headerlink" title="1. AOF 文件写入"></a>1. AOF 文件写入</h5><p>当 Redis 以 AOF 模式持久化时，如果数据库某个过期键还没被删除，那么 AOF 文件会保留此过期键，当此过期键被删除后，Redis 会向 AOF 文件追加一条 DEL 命令来显式地删除该键值。</p>
<h5 id="2-AOF-重写"><a href="#2-AOF-重写" class="headerlink" title="2. AOF 重写"></a>2. AOF 重写</h5><p>执行 AOF 重写时，会对 Redis 中的键值对进行检查已过期的键不会被保存到重写后的 AOF 文件中，因此不会对 AOF 重写造成任何影响。</p>
<h4 id="主从库的过期键"><a href="#主从库的过期键" class="headerlink" title="主从库的过期键"></a>主从库的过期键</h4><p>当 Redis 运行在主从模式下时，从库不会进行过期扫描，从库对过期的处理是被动的。也就是即使从库中的 key 过期了，如果有客户端访问从库时，依然可以得到 key 对应的值，像未过期的键值对一样返回。</p>
<p>从库的过期键处理依靠主服务器控制，主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库，从库通过执行这条 del 指令来删除过期的 key。</p>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/Redis键值过期操作小结.png" alt="Redis键值过期操作小结"></p>
<h2 id="18-Redis-过期策略与源码分析"><a href="#18-Redis-过期策略与源码分析" class="headerlink" title="18 Redis 过期策略与源码分析"></a>18 Redis 过期策略与源码分析</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wan-ming-zhu/p/18080200">https://www.cnblogs.com/wan-ming-zhu/p/18080200</a></p>
<h3 id="过期键执行流程"><a href="#过期键执行流程" class="headerlink" title="过期键执行流程"></a>过期键执行流程</h3><p>Redis 之所以能知道那些键值过期，是因为在 Redis 中维护了一个字典，存储了所有设置了过期时间的键值，我们称之为过期字典。</p>
<p>过期键判断流程如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/过期键判断流程.png" alt="过期键判断流程"></p>
<h3 id="过期键源码分析"><a href="#过期键源码分析" class="headerlink" title="过期键源码分析"></a>过期键源码分析</h3><p>过期键存储在 redisDb 结构中，源代码在 src/server.h 文件中</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Redis database representation. There are multiple databases identified
 * by integers from 0 (the default database) up to the max configured
 * database. The database number is the 'id' field in the structure. */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisDb</span> <span class="token punctuation">{</span>
    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span>                 <span class="token comment">/* 数据库键空间，存放着所有的键值对 */</span>
    dict <span class="token operator">*</span>expires<span class="token punctuation">;</span>              <span class="token comment">/* 键的过期时间 */</span>
    dict <span class="token operator">*</span>blocking_keys<span class="token punctuation">;</span>        <span class="token comment">/* Keys with clients waiting for data (BLPOP)*/</span>
    dict <span class="token operator">*</span>ready_keys<span class="token punctuation">;</span>           <span class="token comment">/* Blocked keys that received a PUSH */</span>
    dict <span class="token operator">*</span>watched_keys<span class="token punctuation">;</span>         <span class="token comment">/* WATCHED keys for MULTI/EXEC CAS */</span>
    <span class="token keyword">int</span> id<span class="token punctuation">;</span>                     <span class="token comment">/* Database ID */</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> avg_ttl<span class="token punctuation">;</span>          <span class="token comment">/* Average TTL, just for stats */</span>
    list <span class="token operator">*</span>defrag_later<span class="token punctuation">;</span>         <span class="token comment">/* List of key names to attempt to defrag one by one, gradually. */</span>
<span class="token punctuation">}</span> redisDb<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>小贴士：本文的所有源码都是基于 Redis 5。</p>
</blockquote>
<h3 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h3><p>Redis 会删除已过期的键值，以此来减少 Redis 的空间占用，但因为 Redis 本身是单线的，如果因为删除操作而影响主业务的执行就得不偿失了，为此 Redis 需要制定多个（过期）删除策略来保证糟糕的事情不会发生。</p>
<p>常见的过期策略有以下几种：</p>
<ul>
<li>惰性删除</li>
<li>定期删除</li>
</ul>
<blockquote>
<p>Redis 不会为每个设置了过期时间的 key 创建一个定时器用于删除该 key。</p>
</blockquote>
<p>下面分别来看每种策略有何不同。</p>
<h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><p>不主动删除过期键，每次从数据库获取键值时判断是否过期，如果过期则删除键值，并返回 null。</p>
<ul>
<li>优点：因为每次访问时，才会判断过期键，所以此策略只会使用很少的系统资源。</li>
<li>缺点：系统占用空间删除不及时，导致空间利用率降低，造成了一定的空间浪费。</li>
</ul>
<h5 id="源码解析-1"><a href="#源码解析-1" class="headerlink" title="源码解析"></a>源码解析</h5><p>惰性删除的源码位于 src/db.c 文件的 expireIfNeeded 方法中，源码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">expireIfNeeded</span><span class="token punctuation">(</span>redisDb <span class="token operator">*</span>db<span class="token punctuation">,</span> robj <span class="token operator">*</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 判断键是否过期</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">keyIsExpired</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>masterhost <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">/* 删除过期键 */</span>
    <span class="token comment">// 增加过期键个数</span>
    server<span class="token punctuation">.</span>stat_expiredkeys<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token comment">// 传播键过期的消息</span>
    <span class="token function">propagateExpire</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>key<span class="token punctuation">,</span>server<span class="token punctuation">.</span>lazyfree_lazy_expire<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">notifyKeyspaceEvent</span><span class="token punctuation">(</span>NOTIFY_EXPIRED<span class="token punctuation">,</span>
        <span class="token string">"expired"</span><span class="token punctuation">,</span>key<span class="token punctuation">,</span>db<span class="token operator">-&gt;</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// server.lazyfree_lazy_expire 为 1 表示异步删除（懒空间释放），反之同步删除</span>
    <span class="token keyword">return</span> server<span class="token punctuation">.</span>lazyfree_lazy_expire <span class="token operator">?</span> <span class="token function">dbAsyncDelete</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>key<span class="token punctuation">)</span> <span class="token operator">:</span>
                                         <span class="token function">dbSyncDelete</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 判断键是否过期</span>
<span class="token keyword">int</span> <span class="token function">keyIsExpired</span><span class="token punctuation">(</span>redisDb <span class="token operator">*</span>db<span class="token punctuation">,</span> robj <span class="token operator">*</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    mstime_t when <span class="token operator">=</span> <span class="token function">getExpire</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>when <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">/* No expire for this key */</span>
    <span class="token comment">/* Don't expire anything while loading. It will be done later. */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>loading<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    mstime_t now <span class="token operator">=</span> server<span class="token punctuation">.</span>lua_caller <span class="token operator">?</span> server<span class="token punctuation">.</span>lua_time_start <span class="token operator">:</span> <span class="token function">mstime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> now <span class="token operator">&gt;</span> when<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 获取键的过期时间</span>
<span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">getExpire</span><span class="token punctuation">(</span>redisDb <span class="token operator">*</span>db<span class="token punctuation">,</span> robj <span class="token operator">*</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    dictEntry <span class="token operator">*</span>de<span class="token punctuation">;</span>
    <span class="token comment">/* No expire? return ASAP */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dictSize</span><span class="token punctuation">(</span>db<span class="token operator">-&gt;</span>expires<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span>
       <span class="token punctuation">(</span>de <span class="token operator">=</span> <span class="token function">dictFind</span><span class="token punctuation">(</span>db<span class="token operator">-&gt;</span>expires<span class="token punctuation">,</span>key<span class="token operator">-&gt;</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">/* The entry was found in the expire dict, this means it should also
     * be present in the main dict (safety check). */</span>
    <span class="token function">serverAssertWithInfo</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span>key<span class="token punctuation">,</span><span class="token function">dictFind</span><span class="token punctuation">(</span>db<span class="token operator">-&gt;</span>dict<span class="token punctuation">,</span>key<span class="token operator">-&gt;</span>ptr<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">dictGetSignedIntegerVal</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>所有对数据库的读写命令在执行之前，都会调用 expireIfNeeded 方法判断键值是否过期，过期则会从数据库中删除，反之则不做任何处理。</p>
<p>惰性删除执行流程，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/惰性删除执行流程.png" alt="惰性删除执行流程"></p>
<h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><p>每隔一段时间检查一次数据库，随机删除一些过期键。</p>
<p>Redis 默认每秒进行 10 次过期扫描，此配置可通过 Redis 的配置文件 redis.conf 进行配置，配置键为 hz 它的默认值是 hz 10。</p>
<p>需要注意的是：Redis 每次扫描并不是遍历过期字典中的所有键，而是采用随机抽取判断并删除过期键的形式执行的。</p>
<h5 id="定期删除流程"><a href="#定期删除流程" class="headerlink" title="定期删除流程"></a>定期删除流程</h5><ol>
<li>从过期字典中随机取出 20 个键；</li>
<li>删除这 20 个键中过期的键；</li>
<li>如果过期 key 的比例超过 25%，重复步骤 1。</li>
</ol>
<p>同时为了保证过期扫描不会出现循环过度，导致线程卡死现象，算法还增加了扫描时间的上限，默认不会超过 25ms。</p>
<p>定期删除执行流程，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/定期删除执行流程.png" alt="定期删除执行流程"></p>
<ul>
<li>优点：通过限制删除操作的时长和频率，来减少删除操作对 Redis 主业务的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用。</li>
<li>缺点：内存清理方面没有定时删除效果好，同时没有惰性删除使用的系统资源少。</li>
</ul>
<h5 id="源码解析-2"><a href="#源码解析-2" class="headerlink" title="源码解析"></a>源码解析</h5><p>定期删除的核心源码在 src/expire.c 文件下的 activeExpireCycle 方法中，源码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">activeExpireCycle</span><span class="token punctuation">(</span><span class="token keyword">int</span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> current_db <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">/* 上次定期删除遍历到的数据库ID */</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> timelimit_exit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token comment">/* Time limit hit in previous call? */</span>
    <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token keyword">long</span> last_fast_cycle <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">/* 上一次执行快速定期删除的时间点 */</span>
    <span class="token keyword">int</span> j<span class="token punctuation">,</span> iteration <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> dbs_per_call <span class="token operator">=</span> CRON_DBS_PER_CALL<span class="token punctuation">;</span> <span class="token comment">// 每次定期删除，遍历的数据库的数量</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token function">ustime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> timelimit<span class="token punctuation">,</span> elapsed<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">clientsArePaused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> ACTIVE_EXPIRE_CYCLE_FAST<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timelimit_exit<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token comment">// ACTIVE_EXPIRE_CYCLE_FAST_DURATION 是快速定期删除的执行时长</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> last_fast_cycle <span class="token operator">+</span> ACTIVE_EXPIRE_CYCLE_FAST_DURATION<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        last_fast_cycle <span class="token operator">=</span> start<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>dbs_per_call <span class="token operator">&gt;</span> server<span class="token punctuation">.</span>dbnum <span class="token operator">||</span> timelimit_exit<span class="token punctuation">)</span>
        dbs_per_call <span class="token operator">=</span> server<span class="token punctuation">.</span>dbnum<span class="token punctuation">;</span>
    <span class="token comment">// 慢速定期删除的执行时长</span>
    timelimit <span class="token operator">=</span> <span class="token number">1000000</span><span class="token operator">*</span>ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC<span class="token operator">/</span>server<span class="token punctuation">.</span>hz<span class="token operator">/</span><span class="token number">100</span><span class="token punctuation">;</span>
    timelimit_exit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>timelimit <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> timelimit <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> ACTIVE_EXPIRE_CYCLE_FAST<span class="token punctuation">)</span>
        timelimit <span class="token operator">=</span> ACTIVE_EXPIRE_CYCLE_FAST_DURATION<span class="token punctuation">;</span> <span class="token comment">/* 删除操作的执行时长 */</span>
    <span class="token keyword">long</span> total_sampled <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> total_expired <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> dbs_per_call <span class="token operator">&amp;&amp;</span> timelimit_exit <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> expired<span class="token punctuation">;</span>
        redisDb <span class="token operator">*</span>db <span class="token operator">=</span> server<span class="token punctuation">.</span>db<span class="token operator">+</span><span class="token punctuation">(</span>current_db <span class="token operator">%</span> server<span class="token punctuation">.</span>dbnum<span class="token punctuation">)</span><span class="token punctuation">;</span>
        current_db<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">do</span> <span class="token punctuation">{</span>
            <span class="token comment">// .......</span>
            expired <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            ttl_sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            ttl_samples <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token comment">// 每个数据库中检查的键的数量</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">&gt;</span> ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP<span class="token punctuation">)</span>
                num <span class="token operator">=</span> ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP<span class="token punctuation">;</span>
            <span class="token comment">// 从数据库中随机选取 num 个键进行检查</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>num<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                dictEntry <span class="token operator">*</span>de<span class="token punctuation">;</span>
                <span class="token keyword">long</span> <span class="token keyword">long</span> ttl<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>de <span class="token operator">=</span> <span class="token function">dictGetRandomKey</span><span class="token punctuation">(</span>db<span class="token operator">-&gt;</span>expires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
                ttl <span class="token operator">=</span> dictGetSignedInteger
                <span class="token comment">// 过期检查，并对过期键进行删除</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">activeExpireCycleTryExpire</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>de<span class="token punctuation">,</span>now<span class="token punctuation">)</span><span class="token punctuation">)</span> expired<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>ttl <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">/* We want the average TTL of keys yet not expired. */</span>
                    ttl_sum <span class="token operator">+=</span> ttl<span class="token punctuation">;</span>
                    ttl_samples<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                total_sampled<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            total_expired <span class="token operator">+=</span> expired<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>ttl_samples<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">long</span> <span class="token keyword">long</span> avg_ttl <span class="token operator">=</span> ttl_sum<span class="token operator">/</span>ttl_samples<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>db<span class="token operator">-&gt;</span>avg_ttl <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> db<span class="token operator">-&gt;</span>avg_ttl <span class="token operator">=</span> avg_ttl<span class="token punctuation">;</span>
                db<span class="token operator">-&gt;</span>avg_ttl <span class="token operator">=</span> <span class="token punctuation">(</span>db<span class="token operator">-&gt;</span>avg_ttl<span class="token operator">/</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">49</span> <span class="token operator">+</span> <span class="token punctuation">(</span>avg_ttl<span class="token operator">/</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>iteration <span class="token operator">&amp;</span> <span class="token number">0xf</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* check once every 16 iterations. */</span>
                elapsed <span class="token operator">=</span> <span class="token function">ustime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>start<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>elapsed <span class="token operator">&gt;</span> timelimit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    timelimit_exit <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                    server<span class="token punctuation">.</span>stat_expired_time_cap_reached_count<span class="token operator">++</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment">/* 每次检查只删除 ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP/4 个过期键 */</span>
        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>expired <span class="token operator">&gt;</span> ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP<span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// .......</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>activeExpireCycle 方法在规定的时间，分多次遍历各个数据库，从过期字典中随机检查一部分过期键的过期时间，删除其中的过期键。</p>
<p>这个函数有两种执行模式，一个是快速模式一个是慢速模式，体现是代码中的 timelimit 变量，这个变量是用来约束此函数的运行时间的。<br>快速模式下 timelimit 的值是固定的，等于预定义常量 <code>ACTIVE_EXPIRE_CYCLE_FAST_DURATION</code>，慢速模式下，这个变量的值是通过 <code>1000000*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/100</code> 计算的。</p>
<h4 id="Redis-使用的过期策略"><a href="#Redis-使用的过期策略" class="headerlink" title="Redis 使用的过期策略"></a>Redis 使用的过期策略</h4><p>Redis 使用的是惰性删除加定期删除的过期策略。</p>
<h2 id="19-Redis-管道技术——Pipeline"><a href="#19-Redis-管道技术——Pipeline" class="headerlink" title="19 Redis 管道技术——Pipeline"></a>19 Redis 管道技术——Pipeline</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wan-ming-zhu/p/18079991">https://www.cnblogs.com/wan-ming-zhu/p/18079991</a></p>
<p>管道技术（Pipeline）是客户端提供的一种批处理技术，用于一次处理多个 Redis 命令，从而提高整个交互的性能。</p>
<p>通常情况下 Redis 是单行执行的，客户端先向服务器发送请求，服务端接收并处理请求后再把结果返回给客户端，这种处理模式在非频繁请求时不会有任何问题。</p>
<p>但如果出现集中大批量的请求时，因为每个请求都要经历先请求再响应的过程，这就会造成网络资源浪费，此时就需要管道技术来把所有的命令整合一次发给服务端，再一次响应给客户端，这样就能大大的提升了 Redis 的响应速度。</p>
<p>普通命令模式，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/普通命令模式.png" alt="普通命令模式"></p>
<p>管道模式，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/管道模式.png" alt="管道模式"></p>
<blockquote>
<p>小贴士：管道中命令越多，管道技术的作用就更大，相比于普通模式来说执行效率就越高。</p>
</blockquote>
<h3 id="管道技术解决了什么问题？"><a href="#管道技术解决了什么问题？" class="headerlink" title="管道技术解决了什么问题？"></a>管道技术解决了什么问题？</h3><p>管道技术解决了多个命令集中请求时造成网络资源浪费的问题，加快了 Redis 的响应速度，让 Redis 拥有更高的运行速度。但要注意的一点是，管道技术本质上是客户端提供的功能，而非 Redis 服务器端的功能。</p>
<h3 id="管道技术需要注意的事项"><a href="#管道技术需要注意的事项" class="headerlink" title="管道技术需要注意的事项"></a>管道技术需要注意的事项</h3><p>管道技术虽然有它的优势，但在使用时还需注意以下几个细节：</p>
<ul>
<li>发送的命令数量不会被限制，但输入缓存区也就是命令的最大存储体积为 1GB，当发送的命令超过此限制时，命令不会被执行，并且会被 Redis 服务器端断开此链接；</li>
<li>如果管道的数据过多可能会导致客户端的等待时间过长，导致网络阻塞；</li>
<li>部分客户端自己本身也有缓存区大小的设置，如果管道命令没有没执行或者是执行不完整，可以排查此情况或较少管道内的命令重新尝试执行。</li>
</ul>
<h2 id="20-查询附近的人——GEO"><a href="#20-查询附近的人——GEO" class="headerlink" title="20 查询附近的人——GEO"></a>20 查询附近的人——GEO</h2><p>Redis 在 3.2 版本中增加了 GEO 类型用于存储和查询地理位置，关于 GEO 的命令不多，主要包含以下 6 个：</p>
<ul>
<li>geoadd：添加地理位置</li>
<li>geopos：查询位置信息</li>
<li>geodist：距离统计</li>
<li>georadius：查询某位置内的其他成员信息</li>
<li>geohash：查询位置的哈希值</li>
<li>zrem：删除地理位置</li>
</ul>
<h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>GEO 是 Redis 3.2 版本中新增的功能，只有升级到 3.2+ 才能使用，GEO 本质上是基于 ZSet 实现的，这点在 Redis 源码找到相关信息，我们可以 GEO 使用实现查找附近的人或者附近的地点，还可以用它来计算两个位置相隔的直线距离。</p>
<h2 id="21-游标迭代器（过滤器）——Scan"><a href="#21-游标迭代器（过滤器）——Scan" class="headerlink" title="21 游标迭代器（过滤器）——Scan"></a>21 游标迭代器（过滤器）——Scan</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wan-ming-zhu/p/18080118">https://www.cnblogs.com/wan-ming-zhu/p/18080118</a></p>
<p>Redis 2.8 时推出了 Scan。</p>
<p>官方文档地址：<a target="_blank" rel="noopener" href="https://redis.io/commands/scan">https://redis.io/commands/scan</a></p>
<p>翻译为中文的含义是：Scan 及它的相关命令可以保证以下查询规则。</p>
<ul>
<li>它可以完整返回开始到结束检索集合中出现的所有元素，也就是在整个查询过程中如果这些元素没有被删除，且符合检索条件，则一定会被查询出来；</li>
<li>它可以保证不会查询出，在开始检索之前删除的那些元素。</li>
</ul>
<p>然后，Scan 命令包含以下缺点：</p>
<ul>
<li>一个元素可能被返回多次，需要客户端来实现去重；</li>
<li>在迭代过程中如果有元素被修改，那么修改的元素能不能被遍历到不确定。 (Elements that were not constantly present in the collection during a full iteration, may be returned or not: it is undefined.)</li>
</ul>
<h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><p>通过本文我们可以知道 Scan 包含以下四个指令：</p>
<ul>
<li>Scan：用于检索当前数据库中所有数据；</li>
<li>HScan：用于检索哈希类型的数据；</li>
<li>SScan：用于检索集合类型中的数据；</li>
<li>ZScan：由于检索有序集合中的数据。</li>
</ul>
<p>Scan 具备以下几个特点：</p>
<ol>
<li>Scan 可以实现 keys 的匹配功能；</li>
<li>Scan 是通过游标进行查询的不会导致 Redis 假死；</li>
<li>Scan 提供了 count 参数，可以规定遍历的数量；</li>
<li>Scan 会把游标返回给客户端，用户客户端继续遍历查询；</li>
<li>Scan 返回的结果可能会有重复数据，需要客户端去重；</li>
<li>单次返回空值且游标不为 0，说明遍历还没结束；</li>
<li>Scan 可以保证在开始检索之前，被删除的元素一定不会被查询出来；</li>
<li>在迭代过程中如果有元素被修改， Scan 不保证能查询出相关的元素。</li>
</ol>
<h2 id="22-优秀的基数统计算法——HyperLogLog"><a href="#22-优秀的基数统计算法——HyperLogLog" class="headerlink" title="22 优秀的基数统计算法——HyperLogLog"></a>22 优秀的基数统计算法——HyperLogLog</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wan-ming-zhu/p/18080102">https://www.cnblogs.com/wan-ming-zhu/p/18080102</a></p>
<h3 id="为什么要使用-HyperLogLog？"><a href="#为什么要使用-HyperLogLog？" class="headerlink" title="为什么要使用 HyperLogLog？"></a>为什么要使用 HyperLogLog？</h3><p>在我们实际开发的过程中，可能会遇到这样一个问题，当我们需要统计一个大型网站的独立访问次数时，该用什么的类型来统计？</p>
<p>如果我们使用 Redis 中的集合来统计，当它每天有数千万级别的访问时，将会是一个巨大的问题。因为这些访问量不能被清空，我们运营人员可能会随时查看这些信息，那么随着时间的推移，这些统计数据所占用的空间会越来越大，逐渐超出我们能承载最大空间。</p>
<p>例如，我们用 IP 来作为独立访问的判断依据，那么我们就要把每个独立 IP 进行存储，以 IP4 来计算，IP4 最多需要 15 个字节来存储信息，例如：110.110.110.110。当有一千万个独立 IP 时，所占用的空间就是 15 bit*10000000 约定于 143MB，但这只是一个页面的统计信息，假如我们有 1 万个这样的页面，那我们就需要 1T 以上的空间来存储这些数据，而且随着 IP6 的普及，这个存储数字会越来越大，那我们就不能用集合的方式来存储了，这个时候我们需要开发新的数据类型 HyperLogLog 来做这件事了。</p>
<h3 id="HyperLogLog-介绍"><a href="#HyperLogLog-介绍" class="headerlink" title="HyperLogLog 介绍"></a>HyperLogLog 介绍</h3><p>HyperLogLog（下文简称为 HLL）是 Redis 2.8.9 版本添加的数据结构，它用于高性能的基数（去重）统计功能，它的缺点就是存在极低的误差率。</p>
<p>HLL 具有以下几个特点：</p>
<ul>
<li>能够使用极少的内存来统计巨量的数据，它只需要 12K 空间就能统计 2^64 的数据；</li>
<li>统计存在一定的误差，误差率整体较低，标准误差为 0.81%；</li>
<li>误差可以被设置辅助计算因子进行降低。</li>
</ul>
<h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><p>HLL 的命令只有 3 个，但都非常的实用，下面分别来看。</p>
<h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; pfadd key "redis"
(integer) 1
127.0.0.1:6379&gt; pfadd key "java" "sql"
(integer) 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>相关语法：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">pfadd key element [element ...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>此命令支持添加一个或多个元素至 HLL 结构中。</p>
<h4 id="统计不重复的元素"><a href="#统计不重复的元素" class="headerlink" title="统计不重复的元素"></a>统计不重复的元素</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; pfadd key "redis"
(integer) 1
127.0.0.1:6379&gt; pfadd key "sql"
(integer) 1
127.0.0.1:6379&gt; pfadd key "redis"
(integer) 0
127.0.0.1:6379&gt; pfcount key
(integer) 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从 pfcount 的结果可以看出，在 HLL 结构中键值为 key 的元素，有 2 个不重复的值：redis 和 sql，可以看出结果还是挺准的。</p>
<p>相关语法：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">pfcount key [key ...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>此命令支持统计一个或多个 HLL 结构。</p>
<h4 id="合并一个或多个-HLL-至新结构"><a href="#合并一个或多个-HLL-至新结构" class="headerlink" title="合并一个或多个 HLL 至新结构"></a>合并一个或多个 HLL 至新结构</h4><p>新增 k 和 k2 合并至新结构 k3 中，代码如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; pfadd k "java" "sql"
(integer) 1
127.0.0.1:6379&gt; pfadd k2 "redis" "sql"
(integer) 1
127.0.0.1:6379&gt; pfmerge k3 k k2
OK
127.0.0.1:6379&gt; pfcount k3
(integer) 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>相关语法：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">pfmerge destkey sourcekey [sourcekey ...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h5 id="pfmerge-使用场景"><a href="#pfmerge-使用场景" class="headerlink" title="pfmerge 使用场景"></a>pfmerge 使用场景</h5><p>当我们需要合并两个或多个同类页面的访问数据时，我们可以使用 pfmerge 来操作。</p>
<h3 id="HLL-算法原理"><a href="#HLL-算法原理" class="headerlink" title="HLL 算法原理"></a>HLL 算法原理</h3><p>HyperLogLog 算法来源于论文 <a target="_blank" rel="noopener" href="https://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf">HyperLogLog the analysis of a near-optimal cardinality estimation algorithm</a>，想要了解 HLL 的原理，先要从伯努利试验说起，伯努利实验说的是抛硬币的事。一次伯努利实验相当于抛硬币，不管抛多少次只要出现一个正面，就称为一次伯努利实验。</p>
<p>我们用 k 来表示每次抛硬币的次数，n 表示第几次抛的硬币，用 k_max 来表示抛硬币的最高次数，最终根据估算发现 n 和 k_max 存在的关系是 n=2^(k_max)，但同时我们也发现了另一个问题当试验次数很小的时候，这种估算方法的误差会很大，例如我们进行以下 3 次实验：</p>
<ul>
<li>第 1 次试验：抛 3 次出现正面，此时 k=3，n=1；</li>
<li>第 2 次试验：抛 2 次出现正面，此时 k=2，n=2；</li>
<li>第 3 次试验：抛 6 次出现正面，此时 k=6，n=3。</li>
</ul>
<p>对于这三组实验来说，k_max=6，n=3，但放入估算公式明显 3≠2^6。为了解决这个问题 HLL 引入了分桶算法和调和平均数来使这个算法更接近真实情况。</p>
<p>分桶算法是指把原来的数据平均分为 m 份，在每段中求平均数在乘以 m，以此来消减因偶然性带来的误差，提高预估的准确性，简单来说就是把一份数据分为多份，把一轮计算，分为多轮计算。</p>
<p>而调和平均数指的是使用平均数的优化算法，而非直接使用平均数。</p>
<blockquote>
<p>例如小明的月工资是 1000 元，而小王的月工资是 100000 元，如果直接取平均数，那小明的平均工资就变成了 (1000+100000)/2=50500 元，这显然是不准确的，而使用调和平均数算法计算的结果是 2/(1⁄1000+1⁄100000)≈1998 元，显然此算法更符合实际平均数。</p>
</blockquote>
<p>所以综合以上情况，在 Redis 中使用 HLL 插入数据，相当于把存储的值经过 hash 之后，再将 hash 值转换为二进制，存入到不同的桶中，这样就可以用很小的空间存储很多的数据，统计时再去相应的位置进行对比很快就能得出结论，这就是 HLL 算法的基本原理，想要更深入的了解算法及其推理过程，可以看去原版的论文。</p>
<h2 id="23-内存淘汰机制与算法"><a href="#23-内存淘汰机制与算法" class="headerlink" title="23 内存淘汰机制与算法"></a>23 内存淘汰机制与算法</h2><p>在本文开始之前，我们先要明白：在 Redis 中，过期策略和内存淘汰策略两个完全不同的概念，但很多人会把两者搞混。</p>
<p>首先，Redis 过期策略指的是 Redis 使用那种策略，来删除已经过期的键值对；而 Redis 内存淘汰机制指的是，当 Redis 运行内存已经超过 Redis 设置的最大内存之后，将采用什么策略来删除符合条件的键值对，以此来保障 Redis 高效的运行。</p>
<h3 id="Redis-最大运行内存"><a href="#Redis-最大运行内存" class="headerlink" title="Redis 最大运行内存"></a>Redis 最大运行内存</h3><p>只有在 Redis 的运行内存达到了某个阀值，才会触发内存淘汰机制，这个阀值就是我们设置的最大运行内存，此值在 Redis 的配置文件中可以找到，配置项为 maxmemory。</p>
<p>内存淘汰执行流程，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/内存淘汰执行流程.png" alt="内存淘汰执行流程"></p>
<h4 id="查询最大运行内存"><a href="#查询最大运行内存" class="headerlink" title="查询最大运行内存"></a>查询最大运行内存</h4><p>我们可以使用命令 <code>config get maxmemory</code> 来查看设置的最大运行内存，命令如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; config get maxmemory
1) "maxmemory"
2) "0"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>我们发现此值竟然是 0，这是 64 位操作系统默认的值，当 maxmemory 为 0 时，表示没有内存大小限制。</p>
<blockquote>
<p>小贴士：32 位操作系统，默认的最大内存值是 3GB。</p>
</blockquote>
<h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h3><h4 id="查看-Redis-内存淘汰策略"><a href="#查看-Redis-内存淘汰策略" class="headerlink" title="查看 Redis 内存淘汰策略"></a>查看 Redis 内存淘汰策略</h4><p>我们可以使用 <code>config get maxmemory-policy</code> 命令，来查看当前 Redis 的内存淘汰策略，命令如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; config get maxmemory-policy
1) "maxmemory-policy"
2) "noeviction"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>可以看出此 Redis 使用的是 noeviction 类型的内存淘汰机制，它表示当运行内存超过最大设置内存时，不淘汰任何数据，但新增操作会报错。</p>
<h4 id="内存淘汰策略分类"><a href="#内存淘汰策略分类" class="headerlink" title="内存淘汰策略分类"></a>内存淘汰策略分类</h4><p>早期版本的 Redis 有以下 6 种淘汰策略：</p>
<ul>
<li>noeviction：不淘汰任何数据，当内存不足时，新增操作会报错，Redis 默认内存淘汰策略；</li>
<li>allkeys-lru：淘汰整个键值中最久未使用的键值；</li>
<li>allkeys-random：随机淘汰任意键值;</li>
<li>volatile-lru：淘汰所有设置了过期时间的键值中最久未使用的键值；</li>
<li>volatile-random：随机淘汰设置了过期时间的任意键值；</li>
<li>volatile-ttl：优先淘汰更早过期的键值。</li>
</ul>
<p>在 Redis 4.0 版本中又新增了 2 种淘汰策略：</p>
<ul>
<li>volatile-lfu：淘汰所有设置了过期时间的键值中，最少使用的键值；</li>
<li>allkeys-lfu：淘汰整个键值中最少使用的键值。</li>
</ul>
<p>其中 <code>allkeys-xxx</code> 表示从所有的键值中淘汰数据，而 <code>volatile-xxx</code> 表示从设置了过期键的键值中淘汰数据。</p>
<h4 id="修改-Redis-内存淘汰策略"><a href="#修改-Redis-内存淘汰策略" class="headerlink" title="修改 Redis 内存淘汰策略"></a>修改 Redis 内存淘汰策略</h4><p>设置内存淘汰策略有两种方法，这两种方法各有利弊，需要使用者自己去权衡。</p>
<ul>
<li>方式一：通过”config set maxmemory-policy 策略”命令设置。它的优点是设置之后立即生效，不需要重启 Redis 服务，缺点是重启 Redis 之后，设置就会失效。</li>
<li>方式二：通过修改 Redis 配置文件修改，设置”maxmemory-policy 策略”，它的优点是重启 Redis 服务后配置不会丢失，缺点是必须重启 Redis 服务，设置才能生效。</li>
</ul>
<h3 id="内存淘汰算法"><a href="#内存淘汰算法" class="headerlink" title="内存淘汰算法"></a>内存淘汰算法</h3><p>从内测淘汰策略分类上，我们可以得知，除了随机删除和不删除之外，主要有两种淘汰算法：LRU 算法和 LFU 算法。</p>
<h4 id="LRU-算法"><a href="#LRU-算法" class="headerlink" title="LRU 算法"></a>LRU 算法</h4><p>LRU 全称是 Least Recently Used 译为最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。</p>
<h5 id="1-LRU-算法实现"><a href="#1-LRU-算法实现" class="headerlink" title="1. LRU 算法实现"></a>1. LRU 算法实现</h5><p>LRU 算法需要基于链表结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除链表尾部的元素即可。</p>
<h5 id="2-近-LRU-算法"><a href="#2-近-LRU-算法" class="headerlink" title="2. 近 LRU 算法"></a>2. 近 LRU 算法</h5><p>Redis 使用的是一种近似 LRU 算法，目的是为了更好的节约内存，它的实现方式是给现有的数据结构添加一个额外的字段，用于记录此键值的最后一次访问时间，Redis 内存淘汰时，会使用随机采样的方式来淘汰数据，它是随机取 5 个值（此值可配置），然后淘汰最久没有使用的那个。</p>
<h5 id="3-LRU-算法缺点"><a href="#3-LRU-算法缺点" class="headerlink" title="3. LRU 算法缺点"></a>3. LRU 算法缺点</h5><p>LRU 算法有一个缺点，比如说很久没有使用的一个键值，如果最近被访问了一次，那么它就不会被淘汰，即使它是使用次数最少的缓存，那它也不会被淘汰，因此在 Redis 4.0 之后引入了 LFU 算法，下面我们一起来看。</p>
<h4 id="LFU-算法"><a href="#LFU-算法" class="headerlink" title="LFU 算法"></a>LFU 算法</h4><p>LFU 全称是 Least Frequently Used 翻译为最不常用的，最不常用的算法是根据总访问次数来淘汰数据的，它的核心思想是”如果数据过去被访问多次，那么将来被访问的频率也更高”。</p>
<p>LFU 解决了偶尔被访问一次之后，数据就不会被淘汰的问题，相比于 LRU 算法也更合理一些。</p>
<p>在 Redis 中每个对象头中记录着 LFU 的信息，源码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisObject</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> type<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> encoding<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> lru<span class="token operator">:</span>LRU_BITS<span class="token punctuation">;</span> <span class="token comment">/* LRU time (relative to global lru_clock) or
                            * LFU data (least significant 8 bits frequency
                            * and most significant 16 bits access time). */</span>
    <span class="token keyword">int</span> refcount<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
<span class="token punctuation">}</span> robj<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 Redis 中 LFU 存储分为两部分，16 bit 的 ldt（last decrement time）和 8 bit 的 logc（logistic counter）。</p>
<ul>
<li>logc 是用来存储访问频次，8 bit 能表示的最大整数值为 255，它的值越小表示使用频率越低，越容易淘汰；</li>
<li>ldt 是用来存储上一次 logc 的更新时间。</li>
</ul>
<h3 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h3><p>通过本文我们了解到，Redis 内存淘汰策略和过期回收策略是完全不同的概念，内存淘汰策略是解决 Redis 运行内存过大的问题的，通过与 maxmemory 比较，决定要不要淘汰数据，根据 maxmemory-policy 参数，决定使用何种淘汰策略，在 Redis 4.0 之后已经有 8 种淘汰策略了，默认的策略是 noeviction 当内存超出时不淘汰任何键值，只是新增操作会报错。</p>
<h2 id="24-消息队列——发布订阅模式"><a href="#24-消息队列——发布订阅模式" class="headerlink" title="24 消息队列——发布订阅模式"></a>24 消息队列——发布订阅模式</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wan-ming-zhu/p/18080541">https://www.cnblogs.com/wan-ming-zhu/p/18080541</a></p>
<h3 id="普通订阅与发布"><a href="#普通订阅与发布" class="headerlink" title="普通订阅与发布"></a>普通订阅与发布</h3><p>消息队列有两个重要的角色，一个是发送者，另一个就是订阅者，对应的命令如下：</p>
<ul>
<li>发布消息：publish channel “message”</li>
<li>订阅消息：subscribe channel</li>
</ul>
<p>下面我们来看具体的命令实现。</p>
<h4 id="订阅消息"><a href="#订阅消息" class="headerlink" title="订阅消息"></a>订阅消息</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; subscribe channel #订阅消息channel
Reading messages...
1) "subscribe"
2) "channel"
3) (integer) 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>相关语法：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">subscribe channel [channel ...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>此命令支持订阅一个或多个频道的命令，也就是说一个订阅者可以订阅多个频道。例如，某个客户端订阅了两个频道 channel 和 channel2，当两个发布者分别推送消息后，订阅者的信息输出如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; subscribe channel channel2 #订阅 channel 和 channel2
Reading messages... (press Ctrl-C to quit)
1) "subscribe"
2) "channel"
3) (integer) 1
1) "subscribe"
2) "channel2"
3) (integer) 2
1) "message"
2) "channel" # 收到 channel 消息
3) "message 1."
1) "message"
2) "channel2" # 收到 channel2 消息
3) "message 2."<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出此订阅者可以收到来自两个频道的消息推送。</p>
<h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; publish channel "hello,redis." #发布消息
(integer) 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>相关语法：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">publish channel message<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>最后的返回值表示成功发送给几个订阅方，1 表示成功发给了一个订阅者，这个数字可以是 0~n，这是由订阅者的数量决定的。</p>
<p>例如，当有两个订阅者时，推送的结果为 2，如下代码所示。</p>
<p>订阅者一：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; subscribe channel
Reading messages... (press Ctrl-C to quit)
1) "subscribe"
2) "channel"
3) (integer) 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>订阅者二：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; subscribe channel
Reading messages... (press Ctrl-C to quit)
1) "subscribe"
2) "channel"
3) (integer) 1
```text

发送消息：

```text
127.0.0.1:6379&gt; publish channel "message"
(integer) 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出，此消息已成功发给两个订阅者，结果也变成 2 了。</p>
<h3 id="主题订阅"><a href="#主题订阅" class="headerlink" title="主题订阅"></a>主题订阅</h3><p>面介绍了普通的订阅与发布模式，但如果我要订阅某一个类型的消息就不适用了，例如我要订阅日志类的消息队列，它们的命名都是 logXXX，这个时候就需要使用 Redis 提供的另一个功能 Pattern Subscribe 主题订阅，这种方式可以使用 * 来匹配多个频道。</p>
<p>主题模式的具体实现代码如下，订阅者：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; psubscribe log_* #主题订阅 log_*
1) "psubscribe"
2) "log_*"
3) (integer) 1
1) "pmessage"
2) "log_*"
3) "log_user" #接收到频道 log_user 的消息推送
4) "user message."
1) "pmessage"
2) "log_*"
3) "log_sys" #接收到频道 log_sys 的消息推送
4) "sys message."
1) "pmessage"
2) "log_*"
3) "log_db" #接收到频道 log_db 的消息推送
4) "db message"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从上面的运行结果，可以看出使用命令 psubscribe log_* 可以接收到所有频道包含 log_XXX 的消息。</p>
<p>相关语法：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">psubscribe pattern [pattern ...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>生产者的代码如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; publish log_user "user message."
(integer) 1
127.0.0.1:6379&gt; publish log_sys "sys message."
(integer) 1
127.0.0.1:6379&gt; publish log_db "db message"
(integer) 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>发布订阅模式存在以下两个缺点：</p>
<ul>
<li>无法持久化保存消息，如果 Redis 服务器宕机或重启，那么所有的消息将会丢失；</li>
<li>发布订阅模式是”发后既忘”的工作模式，如果有订阅者离线重连之后不能消费之前的历史消息。</li>
</ul>
<p>然而这些缺点在 Redis 5.0 添加了 Stream 类型之后会被彻底的解决。</p>
<p>除了以上缺点外，发布订阅模式还有另一个需要注意问题：当消费端有一定的消息积压时，也就是生产者发送的消息，消费者消费不过来时，如果超过 32M 或者是 60s 内持续保持在 8M 以上，消费端会被强行断开，这个参数是在配置文件中设置的，默认值是 <code>client-output-buffer-limit pubsub 32mb 8mb 60</code>。</p>
<h2 id="25-消息队列的其他实现方式"><a href="#25-消息队列的其他实现方式" class="headerlink" title="25 消息队列的其他实现方式"></a>25 消息队列的其他实现方式</h2><h3 id="List-版消息队列"><a href="#List-版消息队列" class="headerlink" title="List 版消息队列"></a>List 版消息队列</h3><p>lpush 用于生产消息， rpop/brpop 拉取消息。</p>
<p>List 优点：</p>
<ul>
<li>消息可以被持久化，借助 Redis 本身的持久化（AOF、RDB 或者是混合持久化），可以有效的保存数据；</li>
<li>消费者可以积压消息，不会因为客户端的消息过多而被强行断开。</li>
</ul>
<p>List 缺点：</p>
<ul>
<li>消息不能被重复消费，一个消息消费完就会被删除；</li>
<li>没有主题订阅的功能。</li>
</ul>
<h3 id="ZSet-版消息队列"><a href="#ZSet-版消息队列" class="headerlink" title="ZSet 版消息队列"></a>ZSet 版消息队列</h3><p>利用 zadd 和 zrangebyscore 来实现存入和读取。</p>
<p>ZSet 优点：</p>
<ul>
<li>支持消息持久化；</li>
<li>相比于 List 查询更方便，ZSet 可以利用 score 属性很方便的完成检索，而 List 则需要遍历整个元素才能检索到某个值。</li>
</ul>
<p>ZSet 缺点：</p>
<ul>
<li>ZSet 不能存储相同元素的值，也就是如果有消息是重复的，那么只能插入一条信息在有序集合中；</li>
<li>ZSet 是根据 score 值排序的，不能像 List 一样，按照插入顺序来排序；</li>
<li>ZSet 没有向 List 的 brpop 那样的阻塞弹出的功能。</li>
</ul>
<h2 id="26-消息队列终极解决方案——Stream（上）"><a href="#26-消息队列终极解决方案——Stream（上）" class="headerlink" title="26 消息队列终极解决方案——Stream（上）"></a>26 消息队列终极解决方案——Stream（上）</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wan-ming-zhu/p/18080644">https://www.cnblogs.com/wan-ming-zhu/p/18080644</a></p>
<p>在 Redis 5.0 Stream 没出来之前，消息队列的实现方式都有着各自的缺陷，例如：</p>
<ul>
<li>发布订阅模式 PubSub，不能持久化也就无法可靠的保存消息，并且对于离线重连的客户端不能读取历史消息的缺陷；</li>
<li>列表实现消息队列的方式不能重复消费，一个消息消费完就会被删除；</li>
<li>有序集合消息队列的实现方式不能存储相同 value 的消息，并且不能阻塞读取消息。</li>
</ul>
<p>并且以上三种方式在实现消息队列时，只能存储单 value 值，也就是如果你要存储一个对象的情况下，必须先序列化成 JSON 字符串，在读取之后还要反序列化成对象才行，这也给用户的使用带来的不便，基于以上问题，Redis 5.0 便推出了 Stream 类型也是此版本最重要的功能，用于完美地实现消息队列，它借鉴了 Kafka 的设计思路，它支持消息的持久化和消息轨迹的消费，支持 ack 确认消息的模式，让消息队列更加的稳定和可靠。</p>
<p>接下来我们先来了解 Stream 自身的一些特性，然后在综合 Stream 的特性，结合 Java 代码完整的实现一个完美的消息队列示例。</p>
<h3 id="基础使用-1"><a href="#基础使用-1" class="headerlink" title="基础使用"></a>基础使用</h3><p>Stream 既然是一个数据类型，那么和其他数据类型相似，它也有一些自己的操作方法，例如：</p>
<ul>
<li>xadd 添加消息；</li>
<li>xlen 查询消息长度；</li>
<li>xdel 根据消息 ID 删除消息；</li>
<li>del 删除整个 Stream；</li>
<li>xrange 读取区间消息</li>
<li>xread 读取某个消息之后的消息。</li>
</ul>
<p>具体使用如下所述。</p>
<h4 id="添加消息"><a href="#添加消息" class="headerlink" title="添加消息"></a>添加消息</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; xadd key * name redis age 10
"1580880750844-0" #结果返回的是消息 id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>其中 <code>*</code> 表示使用 Redis 的规则：时间戳 + 序号的方式自动生成 ID，用户也可以自己指定 ID。</p>
<p>相关语法：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">xadd key ID field string [field string ...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="查询消息的长度"><a href="#查询消息的长度" class="headerlink" title="查询消息的长度"></a>查询消息的长度</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; xlen key
(integer) 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>相关语法：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">xlen key<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="删除消息"><a href="#删除消息" class="headerlink" title="删除消息"></a>删除消息</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; xadd key * name redis
"1580881585129-0" #消息 ID
127.0.0.1:6379&gt; xlen key
(integer) 1
127.0.0.1:6379&gt; xdel key 1580881585129-0 #删除消息，根据 ID
(integer) 1
127.0.0.1:6379&gt; xlen key
(integer) 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>相关语法：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">xdel key ID [ID ...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>此命令支持删除一条或多条消息，根据消息 ID。</p>
<h4 id="删除整个-Stream"><a href="#删除整个-Stream" class="headerlink" title="删除整个 Stream"></a>删除整个 Stream</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; del key #删除整个 Stream
(integer) 1
127.0.0.1:6379&gt; xlen key
(integer) 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>相关语法：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">del key [key ...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>此命令支持删除一个或多个 Stream。</p>
<h4 id="查询区间消息"><a href="#查询区间消息" class="headerlink" title="查询区间消息"></a>查询区间消息</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; xrange mq - +
1) 1) "1580882060464-0"
   2) 1) "name"
      2) "redis"
      3) "age"
      4) "10"
2) 1) "1580882071524-0"
   2) 1) "name"
      2) "java"
      3) "age"
      4) "20"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中：- 表示第一条消息，+ 表示最后一条消息。</p>
<p>相关语法：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">xrange key start end [COUNT count]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="查询某个消息之后的消息"><a href="#查询某个消息之后的消息" class="headerlink" title="查询某个消息之后的消息"></a>查询某个消息之后的消息</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; xread count 1 streams mq 1580882060464-0
1) 1) "mq"
   2) 1) 1) "1580882071524-0"
         2) 1) "name"
            2) "java"
            3) "age"
            4) "20"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在名称为 mq 的 Stream 中，从消息 ID 为 1580882060464-0 的，往后查询一条消息。</p>
<p>相关语法：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">xread [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>此命令提供了阻塞读的参数 block，我们可以使用它读取从当前数据以后新增数据，命令如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; xread count 1 block 0 streams mq $<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>其中 block 0 表示一直阻塞，$ 表示从最后开始读取，这个时候新开一个命令行插入一条数据，此命令展示的结果如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; xadd mq * name sql age 20 #新窗口添加数据
"1580890737890-0"
#阻塞读取到的新数据
127.0.0.1:6379&gt; xread count 1 block 0 streams mq $
1) 1) "mq"
   2) 1) 1) "1580890737890-0"
         2) 1) "name"
            2) "sql"
            3) "age"
            4) "20"
(36.37s)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h3><p>本文介绍了 Stream 的基础方法，并使用 xadd 存入消息和 xread 循环阻塞读取消息的方式实现了简易版的消息队列，交互流程如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/Stream的基础用法.png" alt="Stream的基础用法"></p>
<h2 id="27-消息队列终极解决方案——Stream（下）"><a href="#27-消息队列终极解决方案——Stream（下）" class="headerlink" title="27 消息队列终极解决方案——Stream（下）"></a>27 消息队列终极解决方案——Stream（下）</h2><p>在开始使用消息分组之前，我们必须手动创建分组才行，以下是几个和 Stream 分组有关的命令，我们先来学习一下它的使用。</p>
<h3 id="消息分组命令"><a href="#消息分组命令" class="headerlink" title="消息分组命令"></a>消息分组命令</h3><h4 id="创建消费者群组"><a href="#创建消费者群组" class="headerlink" title="创建消费者群组"></a>创建消费者群组</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; xgroup create mq group1 0-0 
OK
```text

相关语法：

```text
xgroup create stream-key group-key ID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中：</p>
<ul>
<li>mq 为 Stream 的 key；</li>
<li>group1 为分组的名称；</li>
<li>0-0 表示从第一条消息开始读取。</li>
</ul>
<p>如果要从当前最后一条消息向后读取，使用 <code>$</code> 即可，命令如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; xgroup create mq group2 $
OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h4 id="读取消息"><a href="#读取消息" class="headerlink" title="读取消息"></a>读取消息</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; xreadgroup group group1 c1 count 1 streams mq &gt;
1) 1) "mq"
   2) 1) 1) "1580959593553-0"
         2) 1) "name"
            2) "redis"
            3) "age"
            4) "10"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>相关语法：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">xreadgroup group group-key consumer-key streams stream-key<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>其中：</p>
<ul>
<li><code>&gt;</code> 表示读取下一条消息；</li>
<li>group1 表示分组名称；</li>
<li>c1 表示 consumer（消费者）名称。</li>
</ul>
<p>xreadgroup 命令和 xread 使用类似，也可以设置阻塞读取，命令如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; xreadgroup group group1 c2 streams mq &gt;
1) 1) "mq"
   2) 1) 1) "1580959606181-0"
         2) 1) "name"
            2) "java"
            3) "age"
            4) "20"
127.0.0.1:6379&gt; xreadgroup group group1 c2 streams mq &gt;
(nil) #队列中的消息已经被读取完
127.0.0.1:6379&gt; xreadgroup group group1 c1 count 1 block 0 streams mq &gt; #阻塞读取<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此时打开另一个命令行创建使用 xadd 添加一条消息，阻塞命令执行结果如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; xreadgroup group group1 c1 count 1 block 0 streams mq &gt;
1) 1) "mq"
   2) 1) 1) "1580961475368-0"
         2) 1) "name"
            2) "sql"
            3) "age"
            4) "20"
(86.14s)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="消息消费确认"><a href="#消息消费确认" class="headerlink" title="消息消费确认"></a>消息消费确认</h4><p>接收到消息之后，我们要手动确认一下（ack），命令如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; xack mq group1 1580959593553-0
(integer) 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>相关语法：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">xack key group-key ID [ID ...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>消费确认增加了消息的可靠性，一般在业务处理完成之后，需要执行 ack 确认消息已经被消费完成，整个流程的执行如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/消息消费确认.png" alt="消息消费确认"></p>
<h4 id="查询未确认的消费队列"><a href="#查询未确认的消费队列" class="headerlink" title="查询未确认的消费队列"></a>查询未确认的消费队列</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; xpending mq group1
1) (integer) 1 #未确认（ack）的消息数量为 1 条
2) "1580994063971-0"
3) "1580994063971-0"
4) 1) 1) "c1"
      2) "1"
127.0.0.1:6379&gt; xack  mq group1 1580994063971-0 #消费确认
(integer) 1
127.0.0.1:6379&gt; xpending mq group1
1) (integer) 0 #没有未确认的消息
2) (nil)
3) (nil)
4) (nil)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="xinfo-查询相关命令"><a href="#xinfo-查询相关命令" class="headerlink" title="xinfo 查询相关命令"></a>xinfo 查询相关命令</h4><h5 id="1-查询流信息"><a href="#1-查询流信息" class="headerlink" title="1. 查询流信息"></a>1. 查询流信息</h5><pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; xinfo stream mq
 1) "length"
 2) (integer) 2 #队列中有两个消息
 3) "radix-tree-keys"
 4) (integer) 1
 5) "radix-tree-nodes"
 6) (integer) 2
 7) "groups"
 8) (integer) 1 #一个消费分组
 9) "last-generated-id"
10) "1580959606181-0"
11) "first-entry"
12) 1) "1580959593553-0"
    2) 1) "name"
       2) "redis"
       3) "age"
       4) "10"
13) "last-entry"
14) 1) "1580959606181-0"
    2) 1) "name"
       2) "java"
       3) "age"
       4) "20"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>相关语法：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">xinfo stream stream-key<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h5 id="2-查询消费组消息"><a href="#2-查询消费组消息" class="headerlink" title="2. 查询消费组消息"></a>2. 查询消费组消息</h5><pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; xinfo groups mq
1) 1) "name"
   2) "group1" #消息分组名称
   3) "consumers"
   4) (integer) 1 #一个消费者客户端
   5) "pending"
   6) (integer) 1 #一个未确认消息
   7) "last-delivered-id"
   8) "1580959593553-0" #读取的最后一条消息 ID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>相关语法：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">xinfo groups stream-key<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h5 id="3-查看消费者组成员信息"><a href="#3-查看消费者组成员信息" class="headerlink" title="3. 查看消费者组成员信息"></a>3. 查看消费者组成员信息</h5><pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; xinfo consumers mq group1
1) 1) "name"
   2) "c1" #消费者名称
   3) "pending"
   4) (integer) 0 #未确认消息
   5) "idle"
   6) (integer) 481855<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>相关语法：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">xinfo consumers stream group-key<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="删除消费者"><a href="#删除消费者" class="headerlink" title="删除消费者"></a>删除消费者</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; xgroup delconsumer mq group1 c1
(integer) 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>相关语法：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">xgroup delconsumer stream-key group-key consumer-key<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="删除消费组"><a href="#删除消费组" class="headerlink" title="删除消费组"></a>删除消费组</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; xgroup destroy mq group1
(integer) 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>相关语法：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">xgroup destroy stream-key group-key<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="28-实战：分布式锁详解与代码"><a href="#28-实战：分布式锁详解与代码" class="headerlink" title="28 实战：分布式锁详解与代码"></a>28 实战：分布式锁详解与代码</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wan-ming-zhu/p/18081438">https://www.cnblogs.com/wan-ming-zhu/p/18081438</a></p>
<p>加锁(Redis &gt;= 2.6.12)</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">set lock true ex 30 nx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>释放</p>
<pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token keyword">if</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">then</span> <span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'del'</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token number">0</span> <span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="29-实战：布隆过滤器安装与使用及原理分析"><a href="#29-实战：布隆过滤器安装与使用及原理分析" class="headerlink" title="29 实战：布隆过滤器安装与使用及原理分析"></a>29 实战：布隆过滤器安装与使用及原理分析</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wan-ming-zhu/p/18080491">https://www.cnblogs.com/wan-ming-zhu/p/18080491</a></p>
<p>我们前面有讲到过 HyperLogLog 可以用来做基数统计，但它没提供判断一个值是否存在的查询方法，那我们如何才能查询一个值是否存在于海量数据之中呢？</p>
<p>如果使用传统的方式，例如 SQL 中的传统查询，因为数据量太多，查询效率又低有占用系统的资源，因此我们需要一个优秀的算法和功能来实现这个需求，这是我们今天要讲的——布隆过滤器。</p>
<h3 id="开启布隆过滤器"><a href="#开启布隆过滤器" class="headerlink" title="开启布隆过滤器"></a>开启布隆过滤器</h3><p>在 Redis 中不能直接使用布隆过滤器，但我们可以通过 Redis 4.0 版本之后提供的 modules（扩展模块）的方式引入，本文提供两种方式的开启方式。</p>
<h4 id="方式一：编译方式"><a href="#方式一：编译方式" class="headerlink" title="方式一：编译方式"></a>方式一：编译方式</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/RedisLabsModules/redisbloom.git
<span class="token builtin class-name">cd</span> redisbloom
<span class="token function">make</span> <span class="token comment"># 编译redisbloom</span>

./src/redis-server redis.conf --loadmodule ./src/modules/RedisBloom-master/redisbloom.so<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中 <code>--loadmodule</code> 为加载扩展模块的意思，后面跟的是 redisbloom.so 文件的目录。</p>
<h5 id="方式二：Docker-方式"><a href="#方式二：Docker-方式" class="headerlink" title="方式二：Docker 方式"></a>方式二：Docker 方式</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker pull redislabs/rebloom <span class="token comment"># 拉取镜像</span>
docker run -p6379:6379 redislabs/rebloom <span class="token comment"># 运行容器</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="启动验证"><a href="#启动验证" class="headerlink" title="启动验证"></a>启动验证</h3><p>服务启动之后，我们需要判断布隆过滤器是否正常开启，此时我们只需使用 redis-cli 连接到服务端，输入 bf.add 看有没有命令提示，就可以判断是否正常启动了，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/启动验证布隆过滤器.png" alt="启动验证布隆过滤器"></p>
<p>如果有命令提示则表名 Redis 服务器已经开启了布隆过滤器。</p>
<h3 id="布隆过滤器的使用"><a href="#布隆过滤器的使用" class="headerlink" title="布隆过滤器的使用"></a>布隆过滤器的使用</h3><p>布隆过滤器的命令不是很多，主要包含以下几个：</p>
<ul>
<li>bf.add：添加元素</li>
<li>bf.exists：判断某个元素是否存在</li>
<li>bf.madd：添加多个元素</li>
<li>bf.mexists：判断多个元素是否存在</li>
<li>bf.reserve：设置布隆过滤器的准确率</li>
</ul>
<p>具体使用如下所示：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; bf.add user xiaoming
(integer) 1
127.0.0.1:6379&gt; bf.add user xiaohong
(integer) 1
127.0.0.1:6379&gt; bf.add user laowang
(integer) 1
127.0.0.1:6379&gt; bf.exists user laowang
(integer) 1
127.0.0.1:6379&gt; bf.exists user lao
(integer) 0
127.0.0.1:6379&gt; bf.madd user huahua feifei
1) (integer) 1
2) (integer) 1
127.0.0.1:6379&gt; bf.mexists user feifei laomiao
1) (integer) 1
2) (integer) 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出以上结果没有任何误差，我们再来看一下准确率 bf.reserve 的使用：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; bf.reserve user 0.01 200
(error) ERR item exists #已经存的 key 设置会报错
127.0.0.1:6379&gt; bf.reserve userlist 0.9 10
OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出此命令必须在元素刚开始执行，否则会报错，它有三个参数：key、error_rate 和 initial_size。</p>
<p>其中：</p>
<ul>
<li>error_rate：允许布隆过滤器的错误率，这个值越低过滤器占用空间也就越大，以为此值决定了位数组的大小，位数组是用来存储结果的，它的空间占用的越大（存储的信息越多），错误率就越低，它的默认值是 0.01。</li>
<li>initial_size：布隆过滤器存储的元素大小，实际存储的值大于此值，准确率就会降低，它的默认值是 100。</li>
</ul>
<p>后面原理部分会讲到 error_rate 和 initial_size 对准确率影响的具体原因。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Redis 布隆过滤器的实现，依靠的是它数据结构中的一个位数组，每次存储键值的时候，不是直接把数据存储在数据结构中，因为这样太占空间了，它是利用几个不同的无偏哈希函数，把此元素的 hash 值均匀的存储在位数组中，也就是说，每次添加时会通过几个无偏哈希函数算出它的位置，把这些位置设置成 1 就完成了添加操作。</p>
<p>当进行元素判断时，查询此元素的几个哈希位置上的值是否为 1，如果全部为 1，则表示此值存在，如果有一个值为 0，则表示不存在。因为此位置是通过 hash 计算得来的，所以即使这个位置是 1，并不能确定是那个元素把它标识为 1 的，因此<strong>布隆过滤器查询此值存在时，此值不一定存在，但查询此值不存在时，此值一定不存在。</strong></p>
<p>并且当位数组存储值比较稀疏的时候，查询的准确率越高，而当位数组存储的值越来越多时，误差也会增大。</p>
<p>位数组和 key 之间的关系，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/布隆过滤器位数组和key之间的关系.png" alt="布隆过滤器位数组和key之间的关系"></p>
<h3 id="布隆过滤器使用场景"><a href="#布隆过滤器使用场景" class="headerlink" title="布隆过滤器使用场景"></a>布隆过滤器使用场景</h3><p>它的经典使用场景包括以下几个：</p>
<ul>
<li>垃圾邮件过滤</li>
<li>爬虫里的 URL 去重</li>
<li>判断一个元素在亿级数据中是否存在</li>
</ul>
<p>布隆过滤器在数据库领域的使用也比较广泛，例如：HBase、Cassandra、LevelDB、RocksDB 内部都有使用布隆过滤器。</p>
<h2 id="30-完整案例：实现延迟队列的两种方法"><a href="#30-完整案例：实现延迟队列的两种方法" class="headerlink" title="30 完整案例：实现延迟队列的两种方法"></a>30 完整案例：实现延迟队列的两种方法</h2><p>延迟队列是指把当前要做的事情，往后推迟一段时间再做。</p>
<p>延迟队列在实际工作中和面试中都比较常见，它的实现方式有很多种，然而每种实现方式也都有它的优缺点，接下来我们来看。</p>
<h3 id="延迟队列的使用场景"><a href="#延迟队列的使用场景" class="headerlink" title="延迟队列的使用场景"></a>延迟队列的使用场景</h3><p>延迟队列的常见使用场景有以下几种：</p>
<ul>
<li>超过 30 分钟未支付的订单，将会被取消</li>
<li>外卖商家超过 5 分钟未接单的订单，将会被取消</li>
<li>在平台注册但 30 天内未登录的用户，发短信提醒</li>
</ul>
<p>等类似的应用场景，都可以使用延迟队列来实现。</p>
<h3 id="常见实现方式"><a href="#常见实现方式" class="headerlink" title="常见实现方式"></a>常见实现方式</h3><p>目前市面上延迟队列的实现方式基本分为三类，</p>
<ol>
<li>第一类是通过程序的方式实现，例如 JDK 自带的延迟队列 DelayQueue，</li>
<li>第二类是通过 MQ 框架来实现，例如 RabbitMQ 可以通过 rabbitmq-delayed-message-exchange 插件来实现延迟队列，</li>
<li>第三类就是通过 Redis 的方式来实现延迟队列。Redis 是通过有序集合（ZSet）的方式来实现延迟消息队列的，ZSet 有一个 Score 属性可以用来存储延迟执行的时间。</li>
</ol>
<h2 id="31-实战：定时任务案例"><a href="#31-实战：定时任务案例" class="headerlink" title="31 实战：定时任务案例"></a>31 实战：定时任务案例</h2><p>我在开发的时候曾经遇到了这样一个问题，产品要求给每个在线预约看病的患者，距离预约时间的前一天发送一条提醒推送，以防止患者错过看病的时间。这个时候就要求我们给每个人设置一个定时任务，用前面文章说的延迟队列也可以实现，但延迟队列的实现方式需要开启一个无限循环任务，那有没有其他的实现方式呢？</p>
<p>答案是肯定的，接下来我们就用 Keyspace Notifications（键空间通知）来实现定时任务，<strong>定时任务指的是指定一个时间来执行某个任务，就叫做定时任务。</strong></p>
<h3 id="开启键空间通知"><a href="#开启键空间通知" class="headerlink" title="开启键空间通知"></a>开启键空间通知</h3><p>默认情况下 Redis 服务器端是不开启键空间通知的，需要我们手动开启。</p>
<p>键空间开启分为两种方式：</p>
<ol>
<li><p>命令设置方式</p>
<p> 使用 redis-cli 连接到服务器端之后，输入 <code>config set notify-keyspace-events Ex</code> 命令，可以直接开启键空间通知功能，返回”OK”则表示开启成功</p>
</li>
<li><p>配置文件设置方式</p>
<p> 找到 Redis 的配置文件 redis.conf，设置配置项 <code>notify-keyspace-events Ex</code>，然后重启 Redis 服务器。</p>
</li>
</ol>
<h3 id="配置说明-2"><a href="#配置说明-2" class="headerlink" title="配置说明"></a>配置说明</h3><p>可以看出无论是那种方式，都是设置 <code>notify-keyspace-events Ex</code>，其中 Ex 表示开启键事件通知里面的 key 过期事件。</p>
<p>更多配置项说明如下：</p>
<ul>
<li>K：键空间通知，所有通知以 <code>__keyspace@&lt;db&gt;__</code> 为前缀</li>
<li>E：键事件通知，所有通知以 <code>__keyevent@&lt;db&gt;__</code> 为前缀</li>
<li>g：DEL、EXPIRE、RENAME 等类型无关的通用命令的通知</li>
<li>$：字符串命令的通知</li>
<li>l：列表命令的通知</li>
<li>s：集合命令的通知</li>
<li>h：哈希命令的通知</li>
<li>z：有序集合命令的通知</li>
<li>x：过期事件，每当有过期键被删除时发送</li>
<li>e：驱逐（evict）事件，每当有键因为 maxmemory 政策而被删除时发送</li>
<li>A：参数 <code>g$lshzxe</code> 的别名</li>
</ul>
<p>以上配置项可以自由组合，例如我们订阅列表事件就是 <code>El</code>，但需要注意的是，如果 <code>notify-keyspace-event</code> 的值设置为空，则表示不开启任何通知，有值则表示开启通知。</p>
<h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h3><p>我们要实现定时任务需要使用 Pub/Sub 订阅者和发布者的功能，使用订阅者订阅元素的过期事件，然后再执行固定的任务，这就是定时任务的实现思路。</p>
<p>以本文开头的问题为例，我们是这样实现此定时任务的，首先根据每个患者预约的时间往前推一天，然后再计算出当前时间和目标时间（预约前一天的时间）的毫秒值，把这个值作为元素的过期时间设置到 Redis 中，当这个键过期的时候，我们使用订阅者模式就可以订阅到此信息，然后再发提醒消息给此用户，这样就实现了给每个患者开启一个单独的分布式定时任务的功能。</p>
<p>我们先用命令的模式来模拟一下此功能的实现，首先，我们使用 redis-cli 开启一个客户端，监听 <code>__keyevent@0__:expired</code> 键过期事件，此监听值 <code>__keyevent@0__:expired</code> 为固定的写法，其中 0 表示第一个数据库，我们知道 Redis 中一共有 16 个数据，默认使用的是第 0 个，我们建议新开一个非 0 的数据库专门用来实现定时任务，这样就可以避免很多无效的事件监听。</p>
<p>命令监听如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; psubscribe __keyevent@0__:expired
1) "psubscribe"
2) "__keyevent@0__:expired"
3) (integer) 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>此时我们开启另一个客户端，添加两条测试数据试试，命令如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; set key value ex 3
OK
127.0.0.1:6379&gt; set user xiaoming ex 3
OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>等过去 3 秒钟之后，我们去看监听结果如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; psubscribe __keyevent@0__:expired
1) "psubscribe"
2) "__keyevent@0__:expired"
3) (integer) 1
1) "pmessage" 
2) "__keyevent@0__:expired"
3) "__keyevent@0__:expired"
4) "key" #接收到过期信息 key
1) "pmessage"
2) "__keyevent@0__:expired"
3) "__keyevent@0__:expired"
4) "user" #接收到过期信息 user<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>已经成功的介绍到两条过期信息了。</p>
<h2 id="32-实战：RediSearch-高性能的全文搜索引擎"><a href="#32-实战：RediSearch-高性能的全文搜索引擎" class="headerlink" title="32 实战：RediSearch 高性能的全文搜索引擎"></a>32 实战：RediSearch 高性能的全文搜索引擎</h2><p><a target="_blank" rel="noopener" href="https://github.com/RediSearch/RediSearch">https://github.com/RediSearch/RediSearch</a></p>
<p>RediSearch 是一个高性能的全文搜索引擎，它可以作为一个 Redis Module（扩展模块）运行在 Redis 服务器上。</p>
<p>RediSearch 主要特性如下：</p>
<ul>
<li>基于文档的多个字段全文索引</li>
<li>高性能增量索引</li>
<li>文档排序（由用户在索引时手动提供）</li>
<li>在子查询之间使用 AND 或 NOT 操作符的复杂布尔查询</li>
<li>可选的查询子句</li>
<li>基于前缀的搜索</li>
<li>支持字段权重设置</li>
<li>自动完成建议（带有模糊前缀建议）</li>
<li>精确的短语搜索</li>
<li>在许多语言中基于词干分析的查询扩展</li>
<li>支持用于查询扩展和评分的自定义函数</li>
<li>将搜索限制到特定的文档字段</li>
<li>数字过滤器和范围</li>
<li>使用 Redis 自己的地理命令进行地理过滤</li>
<li>Unicode 支持（需要 UTF-8 字符集）</li>
<li>检索完整的文档内容或只是 ID 的检索</li>
<li>支持文档删除和更新与索引垃圾收集</li>
<li>支持部分更新和条件文档更新</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h4><p>和前面讲到布隆过滤器的引入方式一样，我们可以使用 RediSearch 官方推荐的 Docker 方式来安装并启动 RediSearch 功能，操作命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -p <span class="token number">6379</span>:6379 redislabs/redisearch:latest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>安装完成之后使用 redis-cli 来检查 RediSearch 模块是否加载成功，使用 Docker 启动 redis-cli，命令如下：</p>
<p>``bash<br>docker exec -it myredis redis-cli<br></p><pre class="line-numbers language-none"><code class="language-none">
其中"myredis"为 Redis 服务器的名称，执行结果如下：

```text
127.0.0.1:6379&gt; module list
1) 1) "name"
   2) "ft"
   3) "ver"
   4) (integer) 10610<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>返回数组存在”ft”，表明 RediSearch 模块已经成功加载。<p></p>
<h4 id="源码方式安装"><a href="#源码方式安装" class="headerlink" title="源码方式安装"></a>源码方式安装</h4><p>如果不想使用 Docker，我们也可以使用源码的方式进行安装，安装命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/RedisLabsModules/RediSearch.git
<span class="token builtin class-name">cd</span> RediSearch <span class="token comment"># 进入模块目录</span>
<span class="token function">make</span> all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>安装完成之后，可以使用如下命令启动 Redis 并加载 RediSearch 模块，命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">src/redis-server redis.conf --loadmodule <span class="token punctuation">..</span>/RediSearch/src/redisearch.so<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>我们先使用 redis-cli 来对 RediSearch 进行相关的操作。</p>
<h4 id="创建索引和字段"><a href="#创建索引和字段" class="headerlink" title="创建索引和字段"></a>创建索引和字段</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; ft.create myidx schema title text weight 5.0 desc text
OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>其中”myidx”为索引的ID，此索引包含了两个字段”title”和”desc”，”weight”为权重，默认值为 1.0。</p>
<h4 id="将内容添加到索引"><a href="#将内容添加到索引" class="headerlink" title="将内容添加到索引"></a>将内容添加到索引</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; ft.add myidx doc1 1.0 fields title "He urged her to study English" desc "good idea"
OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>其中”doc1”为文档 ID（docid），”1.0”为评分（score）。</p>
<h4 id="根据关键查询"><a href="#根据关键查询" class="headerlink" title="根据关键查询"></a>根据关键查询</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; ft.search myidx "english" limit 0 10
1) (integer) 1
2) "doc1"
3) 1) "title"
   2) "He urged her to study English"
   3) "desc"
   4) "good idea"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出我们使用 title 字段中的关键字”english”查询出了一条满足查询条件的数据。</p>
<h4 id="中文搜索"><a href="#中文搜索" class="headerlink" title="中文搜索"></a>中文搜索</h4><p>首先我们需要先给索引中，添加一条中文数据，执行命令如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; ft.add myidx doc2 1.0 language "chinese" fields title "Java 14 发布了！新功能速览" desc "Java 14 在 2020.3.17 日发布正式版了，但现在很多公司还在使用 Java 7 或 Java 8"
OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>注意：这里必须要设置语言编码为中文，也就是”language “chinese””，默认是英文编码，如果不设置则无法支持中文查询（无法查出结果）。</p>
<p>我们使用之前的查询方式，命令如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; ft.search myidx "正式版"
1) (integer) 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>我们发现并没有查到任何信息，这是因为我们没有指定搜索的语言，不但保存时候要指定编码，查询时也需要指定，查询命令如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; ft.search myidx "发布了" language "chinese"
1) (integer) 1
2) "doc2"
3) 1) "desc"
   2) "Java 14 \xe5\x9c\xa8 2020.3.17 \xe6\x97\xa5\xe5\x8f\x91\xe5\xb8\x83\xe6\xad\xa3\xe5\xbc\x8f\xe7\x89\x88\xe4\xba\x86\xef\xbc\x8c\xe4\xbd\x86\xe7\x8e\xb0\xe5\x9c\xa8\xe5\xbe\x88\xe5\xa4\x9a\xe5\x85\xac\xe5\x8f\xb8\xe8\xbf\x98\xe5\x9c\xa8\xe4\xbd\xbf\xe7\x94\xa8 Java 7 \xe6\x88\x96 Java 8"
   3) "title"
   4) "Java 14 \xe5\x8f\x91\xe5\xb8\x83\xe4\xba\x86\xef\xbc\x81\xe6\x96\xb0\xe5\x8a\x9f\xe8\x83\xbd\xe9\x80\x9f\xe8\xa7\x88"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从结果可以看出中文信息已经被顺利的查询出来了。</p>
<h4 id="删除索引的数据"><a href="#删除索引的数据" class="headerlink" title="删除索引的数据"></a>删除索引的数据</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; ft.del myidx doc1
(integer) 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>我们使用索引加文档 ID 就可以实现删除数据的功能。</p>
<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><p>我们可以使用”ft.drop”关键字删除整个索引，执行命令如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; ft.drop myidx
OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h4 id="查询索引详细信息"><a href="#查询索引详细信息" class="headerlink" title="查询索引详细信息"></a>查询索引详细信息</h4><p>我们可以使用”ft.info”关键查询索引相关信息，执行命令如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; ft.info myidx
 1) index_name
 2) myidx
 3) index_options
 4) (empty list or set)
 5) fields
 6) 1) 1) title
       2) type
       3) TEXT
       4) WEIGHT
       5) "5"
    2) 1) desc
       2) type
       3) TEXT
       4) WEIGHT
       5) "1"
 7) num_docs
 8) "2"
 9) max_doc_id
10) "2"
11) num_terms
12) "9"
13) num_records
14) "18"
15) inverted_sz_mb
16) "0.000102996826171875"
17) total_inverted_index_blocks
18) "29"
19) offset_vectors_sz_mb
20) "1.71661376953125e-05"
21) doc_table_size_mb
22) "0.000164031982421875"
23) sortable_values_size_mb
24) "0"
25) key_table_size_mb
26) "8.0108642578125e-05"
27) records_per_doc_avg
28) "9"
29) bytes_per_record_avg
30) "6"
31) offsets_per_term_avg
32) "1"
33) offset_bits_per_record_avg
34) "8"
35) gc_stats
36)  1) bytes_collected
     2) "0"
     3) total_ms_run
     4) "16"
     5) total_cycles
     6) "14"
     7) avarage_cycle_time_ms
     8) "1.1428571428571428"
     9) last_run_time_ms
    10) "2"
    11) gc_numeric_trees_missed
    12) "0"
    13) gc_blocks_denied
    14) "0"
37) cursor_stats
38) 1) global_idle
    2) (integer) 0
    3) global_total
    4) (integer) 0
    5) index_capacity
    6) (integer) 128
    7) index_total
    8) (integer) 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中”num_docs”表示存储的数据数量。</p>
<h2 id="33-实战：Redis-性能测试"><a href="#33-实战：Redis-性能测试" class="headerlink" title="33 实战：Redis 性能测试"></a>33 实战：Redis 性能测试</h2><h3 id="为什么需要性能测试？"><a href="#为什么需要性能测试？" class="headerlink" title="为什么需要性能测试？"></a>为什么需要性能测试？</h3><p>性能测试的使用场景有很多，例如以下几个：</p>
<ol>
<li>技术选型，比如测试 Memcached 和 Redis；</li>
<li>对比单机 Redis 和集群 Redis 的吞吐量；</li>
<li>评估不同类型的存储性能，例如集合和有序集合；</li>
<li>对比开启持久化和关闭持久化的吞吐量；</li>
<li>对比调优和未调优的吞吐量；</li>
<li>对比不同 Redis 版本的吞吐量，作为是否升级的一个参考标准。</li>
</ol>
<p>等等，诸如此类的情况，我们都需要进行性能测试。</p>
<h3 id="性能测试的几种方式"><a href="#性能测试的几种方式" class="headerlink" title="性能测试的几种方式"></a>性能测试的几种方式</h3><p>既然性能测试使用场景那么多，那要怎么进行性能测试呢？</p>
<p>目前比较主流的性能测试分为两种：</p>
<ol>
<li>编写代码模拟并发进行性能测试；</li>
<li>使用 redis-benchmark 进行测试。</li>
</ol>
<p>因为自己编写代码进行性能测试的方式不够灵活，且很难短时间内模拟大量的并发数，所有作者并不建议使用这种方式。幸运的是 Redis 本身给我们提供了性能测试工具 redis-benchmark（Redis 基准测试），因此我们本文重点来介绍 redis-benchmark 的使用。</p>
<h3 id="基准测试实战"><a href="#基准测试实战" class="headerlink" title="基准测试实战"></a>基准测试实战</h3><p>redis-benchmark 位于 Redis 的 src 目录下，我们可以使用 <code>./redis-benchmark -h</code> 来查看基准测试的使用，执行结果如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Usage: redis-benchmark <span class="token punctuation">[</span>-h <span class="token operator">&lt;</span>host<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>-p <span class="token operator">&lt;</span>port<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>-c <span class="token operator">&lt;</span>clients<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>-n <span class="token operator">&lt;</span>requests<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>-k <span class="token operator">&lt;</span>boolean<span class="token operator">&gt;</span><span class="token punctuation">]</span>

 -h <span class="token operator">&lt;</span>hostname<span class="token operator">&gt;</span>      Server <span class="token function">hostname</span> <span class="token punctuation">(</span>default <span class="token number">127.0</span>.0.1<span class="token punctuation">)</span>
 -p <span class="token operator">&lt;</span>port<span class="token operator">&gt;</span>          Server port <span class="token punctuation">(</span>default <span class="token number">6379</span><span class="token punctuation">)</span>
 -s <span class="token operator">&lt;</span>socket<span class="token operator">&gt;</span>        Server socket <span class="token punctuation">(</span>overrides <span class="token function">host</span> and port<span class="token punctuation">)</span>
 -a <span class="token operator">&lt;</span>password<span class="token operator">&gt;</span>      Password <span class="token keyword">for</span> Redis Auth
 -c <span class="token operator">&lt;</span>clients<span class="token operator">&gt;</span>       Number of parallel connections <span class="token punctuation">(</span>default <span class="token number">50</span><span class="token punctuation">)</span>
 -n <span class="token operator">&lt;</span>requests<span class="token operator">&gt;</span>      Total number of requests <span class="token punctuation">(</span>default <span class="token number">100000</span><span class="token punctuation">)</span>
 -d <span class="token operator">&lt;</span>size<span class="token operator">&gt;</span>          Data size of SET/GET value <span class="token keyword">in</span> bytes <span class="token punctuation">(</span>default <span class="token number">3</span><span class="token punctuation">)</span>
 --dbnum <span class="token operator">&lt;</span>db<span class="token operator">&gt;</span>       SELECT the specified db number <span class="token punctuation">(</span>default <span class="token number">0</span><span class="token punctuation">)</span>
 -k <span class="token operator">&lt;</span>boolean<span class="token operator">&gt;</span>       <span class="token assign-left variable">1</span><span class="token operator">=</span>keep alive <span class="token assign-left variable">0</span><span class="token operator">=</span>reconnect <span class="token punctuation">(</span>default <span class="token number">1</span><span class="token punctuation">)</span>
 -r <span class="token operator">&lt;</span>keyspacelen<span class="token operator">&gt;</span>   Use random keys <span class="token keyword">for</span> SET/GET/INCR, random values <span class="token keyword">for</span> SADD
  Using this option the benchmark will <span class="token function">expand</span> the string __rand_int__
  inside an argument with a <span class="token number">12</span> digits number <span class="token keyword">in</span> the specified range
  from <span class="token number">0</span> to keyspacelen-1. The substitution changes every <span class="token function">time</span> a <span class="token builtin class-name">command</span>
  is executed. Default tests use this to hit random keys <span class="token keyword">in</span> the
  specified range.
 -P <span class="token operator">&lt;</span>numreq<span class="token operator">&gt;</span>        Pipeline <span class="token operator">&lt;</span>numreq<span class="token operator">&gt;</span> requests. Default <span class="token number">1</span> <span class="token punctuation">(</span>no pipeline<span class="token punctuation">)</span>.
 -e                 If server replies with errors, show them on stdout.
                    <span class="token punctuation">(</span>no <span class="token function">more</span> than <span class="token number">1</span> error per second is displayed<span class="token punctuation">)</span>
 -q                 Quiet. Just show query/sec values
 --csv              Output <span class="token keyword">in</span> CSV <span class="token function">format</span>
 -l                 Loop. Run the tests forever
 -t <span class="token operator">&lt;</span>tests<span class="token operator">&gt;</span>         Only run the comma separated list of tests. The <span class="token builtin class-name">test</span>
                    names are the same as the ones produced as output.
 -I                 Idle mode. Just <span class="token function">open</span> N idle connections and wait.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出 redis-benchmark 支持以下选项：</p>
<ul>
<li><code>-h &lt;hostname&gt;</code>：服务器的主机名（默认值为 127.0.0.1）。</li>
<li><code>-p &lt;port&gt;</code>：服务器的端口号（默认值为 6379）。</li>
<li><code>-s &lt;socket&gt;</code>：服务器的套接字（会覆盖主机名和端口号）。</li>
<li><code>-a &lt;password&gt;</code>：登录 Redis 时进行身份验证的密码。</li>
<li><code>-c &lt;clients&gt;</code>：并发的连接数量（默认值为 50）。</li>
<li><code>-n &lt;requests&gt;</code>：发出的请求总数（默认值为 100000）。</li>
<li><code>-d &lt;size&gt;</code>：SET/GET 命令所操作的值的数据大小，以字节为单位（默认值为 2）。</li>
<li><code>-dbnum &lt;db&gt;</code>：选择用于性能测试的数据库的编号（默认值为 0）。</li>
<li><code>-k &lt;boolean&gt;</code>：1 = 保持连接；0 = 重新连接（默认值为 1）。</li>
<li><code>-r &lt;keyspacelen&gt;</code>：SET/GET/INCR 命令使用随机键，SADD 命令使用随机值。通过这个选项，基准测试会将参数中的 <strong>rand_int</strong> 字符串替换为一个 12 位的整数，这个整数的取值范围从 0 到 keyspacelen-1。每次执行一条命令的时候，用于替换的整数值都会改变。通过这个参数，默认的测试方案会在指定范围之内尝试命中随机键。</li>
<li><code>-P &lt;numreq&gt;</code>：使用管道机制处理 <numreq> 条 Redis 请求。默认值为 1（不使用管道机制）。</numreq></li>
<li><code>-q</code>：静默测试，只显示 QPS 的值。</li>
<li><code>-csv</code>：将测试结果输出为 CSV 格式的文件。</li>
<li><code>-l</code>：循环测试。基准测试会永远运行下去。</li>
<li><code>-t</code> <tests>：基准测试只会运行列表中用逗号分隔的命令。测试命令的名称和结果输出产生的名称相同。</tests></li>
<li><code>-I</code>：空闲模式，只会打开 N 个空闲的连接，然后等待。</li>
</ul>
<p>可以看出 redis-benchmark 带的功能还是比较全的。</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>在安装 Redis 服务端的机器上，我们可以不带任何参数直接执行 <code>./redis-benchmark</code> 执行结果如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>@iZ2ze0nc5n41zomzyqtksmZ:src<span class="token punctuation">]</span>$ ./redis-benchmark
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span> PING_INLINE <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
  <span class="token number">100000</span> requests completed <span class="token keyword">in</span> <span class="token number">1.26</span> seconds
  <span class="token number">50</span> parallel clients
  <span class="token number">3</span> bytes payload
  keep alive: <span class="token number">1</span>

<span class="token number">99.81</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">1</span> milliseconds
<span class="token number">100.00</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">2</span> milliseconds
<span class="token number">79302.14</span> requests per second

<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span> PING_BULK <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
  <span class="token number">100000</span> requests completed <span class="token keyword">in</span> <span class="token number">1.29</span> seconds
  <span class="token number">50</span> parallel clients
  <span class="token number">3</span> bytes payload
  keep alive: <span class="token number">1</span>

<span class="token number">99.83</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">1</span> milliseconds
<span class="token number">100.00</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">1</span> milliseconds
<span class="token number">77459.34</span> requests per second

<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span> SET <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
  <span class="token number">100000</span> requests completed <span class="token keyword">in</span> <span class="token number">1.26</span> seconds
  <span class="token number">50</span> parallel clients
  <span class="token number">3</span> bytes payload
  keep alive: <span class="token number">1</span>

<span class="token number">99.80</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">1</span> milliseconds
<span class="token number">99.99</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">2</span> milliseconds
<span class="token number">100.00</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">2</span> milliseconds
<span class="token number">79239.30</span> requests per second

<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span> GET <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
  <span class="token number">100000</span> requests completed <span class="token keyword">in</span> <span class="token number">1.19</span> seconds
  <span class="token number">50</span> parallel clients
  <span class="token number">3</span> bytes payload
  keep alive: <span class="token number">1</span>

<span class="token number">99.72</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">1</span> milliseconds
<span class="token number">99.95</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">15</span> milliseconds
<span class="token number">100.00</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">16</span> milliseconds
<span class="token number">100.00</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">16</span> milliseconds
<span class="token number">84104.29</span> requests per second

<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span> INCR <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
  <span class="token number">100000</span> requests completed <span class="token keyword">in</span> <span class="token number">1.17</span> seconds
  <span class="token number">50</span> parallel clients
  <span class="token number">3</span> bytes payload
  keep alive: <span class="token number">1</span>

<span class="token number">99.86</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">1</span> milliseconds
<span class="token number">100.00</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">1</span> milliseconds
<span class="token number">85397.09</span> requests per second

<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span> LPUSH <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
  <span class="token number">100000</span> requests completed <span class="token keyword">in</span> <span class="token number">1.22</span> seconds
  <span class="token number">50</span> parallel clients
  <span class="token number">3</span> bytes payload
  keep alive: <span class="token number">1</span>

<span class="token number">99.79</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">1</span> milliseconds
<span class="token number">100.00</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">1</span> milliseconds
<span class="token number">82169.27</span> requests per second

<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span> RPUSH <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
  <span class="token number">100000</span> requests completed <span class="token keyword">in</span> <span class="token number">1.22</span> seconds
  <span class="token number">50</span> parallel clients
  <span class="token number">3</span> bytes payload
  keep alive: <span class="token number">1</span>

<span class="token number">99.71</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">1</span> milliseconds
<span class="token number">100.00</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">1</span> milliseconds
<span class="token number">81900.09</span> requests per second

<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span> LPOP <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
  <span class="token number">100000</span> requests completed <span class="token keyword">in</span> <span class="token number">1.29</span> seconds
  <span class="token number">50</span> parallel clients
  <span class="token number">3</span> bytes payload
  keep alive: <span class="token number">1</span>

<span class="token number">99.78</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">1</span> milliseconds
<span class="token number">99.95</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">13</span> milliseconds
<span class="token number">99.97</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">14</span> milliseconds
<span class="token number">100.00</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">14</span> milliseconds
<span class="token number">77399.38</span> requests per second

<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span> RPOP <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
  <span class="token number">100000</span> requests completed <span class="token keyword">in</span> <span class="token number">1.25</span> seconds
  <span class="token number">50</span> parallel clients
  <span class="token number">3</span> bytes payload
  keep alive: <span class="token number">1</span>

<span class="token number">99.82</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">1</span> milliseconds
<span class="token number">100.00</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">1</span> milliseconds
<span class="token number">80192.46</span> requests per second

<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span> SADD <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
  <span class="token number">100000</span> requests completed <span class="token keyword">in</span> <span class="token number">1.25</span> seconds
  <span class="token number">50</span> parallel clients
  <span class="token number">3</span> bytes payload
  keep alive: <span class="token number">1</span>

<span class="token number">99.74</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">1</span> milliseconds
<span class="token number">100.00</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">1</span> milliseconds
<span class="token number">80192.46</span> requests per second

<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span> HSET <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
  <span class="token number">100000</span> requests completed <span class="token keyword">in</span> <span class="token number">1.21</span> seconds
  <span class="token number">50</span> parallel clients
  <span class="token number">3</span> bytes payload
  keep alive: <span class="token number">1</span>

<span class="token number">99.86</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">1</span> milliseconds
<span class="token number">100.00</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">1</span> milliseconds
<span class="token number">82440.23</span> requests per second

<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span> SPOP <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
  <span class="token number">100000</span> requests completed <span class="token keyword">in</span> <span class="token number">1.22</span> seconds
  <span class="token number">50</span> parallel clients
  <span class="token number">3</span> bytes payload
  keep alive: <span class="token number">1</span>

<span class="token number">99.92</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">1</span> milliseconds
<span class="token number">100.00</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">1</span> milliseconds
<span class="token number">81699.35</span> requests per second

<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span> LPUSH <span class="token punctuation">(</span>needed to benchmark LRANGE<span class="token punctuation">)</span> <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
  <span class="token number">100000</span> requests completed <span class="token keyword">in</span> <span class="token number">1.26</span> seconds
  <span class="token number">50</span> parallel clients
  <span class="token number">3</span> bytes payload
  keep alive: <span class="token number">1</span>

<span class="token number">99.69</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">1</span> milliseconds
<span class="token number">99.95</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">13</span> milliseconds
<span class="token number">99.99</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">14</span> milliseconds
<span class="token number">100.00</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">14</span> milliseconds
<span class="token number">79176.56</span> requests per second

<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span> LRANGE_100 <span class="token punctuation">(</span>first <span class="token number">100</span> elements<span class="token punctuation">)</span> <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
  <span class="token number">100000</span> requests completed <span class="token keyword">in</span> <span class="token number">1.25</span> seconds
  <span class="token number">50</span> parallel clients
  <span class="token number">3</span> bytes payload
  keep alive: <span class="token number">1</span>

<span class="token number">99.57</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">1</span> milliseconds
<span class="token number">99.98</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">2</span> milliseconds
<span class="token number">100.00</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">2</span> milliseconds
<span class="token number">80128.20</span> requests per second

<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span> LRANGE_300 <span class="token punctuation">(</span>first <span class="token number">300</span> elements<span class="token punctuation">)</span> <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
  <span class="token number">100000</span> requests completed <span class="token keyword">in</span> <span class="token number">1.25</span> seconds
  <span class="token number">50</span> parallel clients
  <span class="token number">3</span> bytes payload
  keep alive: <span class="token number">1</span>

<span class="token number">99.91</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">1</span> milliseconds
<span class="token number">100.00</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">1</span> milliseconds
<span class="token number">80064.05</span> requests per second

<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span> LRANGE_500 <span class="token punctuation">(</span>first <span class="token number">450</span> elements<span class="token punctuation">)</span> <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
  <span class="token number">100000</span> requests completed <span class="token keyword">in</span> <span class="token number">1.30</span> seconds
  <span class="token number">50</span> parallel clients
  <span class="token number">3</span> bytes payload
  keep alive: <span class="token number">1</span>

<span class="token number">99.78</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">1</span> milliseconds
<span class="token number">100.00</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">1</span> milliseconds
<span class="token number">76863.95</span> requests per second

<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span> LRANGE_600 <span class="token punctuation">(</span>first <span class="token number">600</span> elements<span class="token punctuation">)</span> <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
  <span class="token number">100000</span> requests completed <span class="token keyword">in</span> <span class="token number">1.20</span> seconds
  <span class="token number">50</span> parallel clients
  <span class="token number">3</span> bytes payload
  keep alive: <span class="token number">1</span>

<span class="token number">99.85</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">1</span> milliseconds
<span class="token number">100.00</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">1</span> milliseconds
<span class="token number">83263.95</span> requests per second

<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span> MSET <span class="token punctuation">(</span><span class="token number">10</span> keys<span class="token punctuation">)</span> <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
  <span class="token number">100000</span> requests completed <span class="token keyword">in</span> <span class="token number">1.27</span> seconds
  <span class="token number">50</span> parallel clients
  <span class="token number">3</span> bytes payload
  keep alive: <span class="token number">1</span>

<span class="token number">99.65</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">1</span> milliseconds
<span class="token number">100.00</span>% <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">1</span> milliseconds
<span class="token number">78740.16</span> requests per second<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出以上都是对常用的方法 Set、Get、Incr 等进行测试，基本能达到每秒 8W 的处理级别。</p>
<h3 id="精简测试"><a href="#精简测试" class="headerlink" title="精简测试"></a>精简测试</h3><p>我们可以使用 <code>./redis-benchmark -t set,get,incr -n 1000000 -q</code> 命令，来对 Redis 服务器进行精简测试，测试结果如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>@iZ2ze0nc5n41zomzyqtksmZ:src<span class="token punctuation">]</span>$ ./redis-benchmark -t set,get,incr -n <span class="token number">1000000</span> -q
SET: <span class="token number">81726.05</span> requests per second
GET: <span class="token number">81466.40</span> requests per second
INCR: <span class="token number">82481.03</span> requests per second<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出以上测试展示的结果非常的精简，这是因为我们设置了 <code>-q</code> 参数，此选项的意思是设置输出结果为精简模式，其中 <code>-t</code> 表示指定测试指令，<code>-n</code> 设置每个指令测试 100w 次。</p>
<h3 id="管道测试"><a href="#管道测试" class="headerlink" title="管道测试"></a>管道测试</h3><p>本课程的前面章节介绍了 Pipeline（管道）的知识，它是用于客户端把命令批量发给服务器端执行的，以此来提高程序的整体执行效率，那接下来我们测试一下 Pipeline 的吞吐量能到达多少，执行命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>@iZ2ze0nc5n41zomzyqtksmZ:src<span class="token punctuation">]</span>$ ./redis-benchmark -t set,get,incr -n <span class="token number">1000000</span> -q -P <span class="token number">10</span>
SET: <span class="token number">628535.50</span> requests per second
GET: <span class="token number">654450.25</span> requests per second
INCR: <span class="token number">647249.19</span> requests per second<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们发现 Pipeline 的测试很快就执行完了，同样是每个指令执行 100w 次，可以看出 Pipeline 的性能几乎是普通命令的 8 倍， <code>-P 10</code> 表示每次执行 10 个 Redis 命令。</p>
<h3 id="基准测试的影响元素"><a href="#基准测试的影响元素" class="headerlink" title="基准测试的影响元素"></a>基准测试的影响元素</h3><p>为什么每次执行 10 个 Redis 命令，Pipeline 的效率为什么达不到普通命令的 10 倍呢？</p>
<p>这是因为基准测试会受到很大外部因素的影响，例如以下几个：</p>
<ol>
<li>网络带宽和网络延迟可能是 Redis 操作最大的性能瓶颈，比如有 10w q/s，平均每个请求负责传输 8 KB 的字符，那我们需要的理论带宽是 7.6 Gbits/s，如果服务器配置的是 1 Gbits/s，那么一定会有很多信息在排队等候传输，因此运行效率可想而知，这也是很多 Redis 生产坏境之所以效率不高的原因；</li>
<li>CPU 可能是 Redis 运行的另一个重要的影响因素，如果 CPU 的计算能力跟不上 Redis 要求的话，也会影响 Redis 的运行效率；</li>
<li>如果 Redis 运行在虚拟设备上，性能也会受影响，因为普通操作在虚拟设备上会有额外的消耗；</li>
<li>普通操作和批量操作（Pipeline）对 Redis 的吞吐量也有很大的影响。</li>
</ol>
<h2 id="34-实战：Redis-慢查询"><a href="#34-实战：Redis-慢查询" class="headerlink" title="34 实战：Redis 慢查询"></a>34 实战：Redis 慢查询</h2><p>Redis 慢查询作用和 MySQL 慢查询作用类似，都是为我们查询出不合理的执行命令，然后让开发人员和运维人员一起来规避这些耗时的命令，从而让服务器更加高效和健康的运行。对于单线程的 Redis 来说，不合理的使用更是致命的，因此掌握 Redis 慢查询技能对我们来说非常的关键。</p>
<h3 id="如何进行慢查询？"><a href="#如何进行慢查询？" class="headerlink" title="如何进行慢查询？"></a>如何进行慢查询？</h3><p>在开始之前，我们先要了解一下 Redis 中和慢查询相关的配置项，Redis 慢查询重要的配置项有以下两个：</p>
<ul>
<li>slowlog-log-slower-than：用于设置慢查询的评定时间，也就是说超过此配置项的命令，将会被当成慢操作记录在慢查询日志中，它执行单位是微秒（1 秒等于 1000000 微秒）；</li>
<li>slowlog-max-len：用来配置慢查询日志的最大记录数。</li>
</ul>
<p>我们先来看它们的默认配置值：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; config get slowlog-log-slower-than #慢查询判断时间
1) "slowlog-log-slower-than"
2) "10000"
127.0.0.1:6379&gt; config get slowlog-max-len #慢查询最大记录条数
1) "slowlog-max-len"
2) "128"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出慢查询的临界值是 10000 微秒，默认保存 128 条慢查询记录。</p>
<h3 id="修改配置项"><a href="#修改配置项" class="headerlink" title="修改配置项"></a>修改配置项</h3><p>slowlog-log-slower-than 和 slowlog-max-len 可以通过 <code>config set xxx</code> 的模式来修改，例如 <code>config set slowlog-max-len 200</code> 设置慢查询最大记录数为 200 条。</p>
<h3 id="慢查询演示"><a href="#慢查询演示" class="headerlink" title="慢查询演示"></a>慢查询演示</h3><p>我们先来设置慢查询的判断时间为 0 微秒，这样所有的执行命令都会被记录，设置命令如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; config set slowlog-log-slower-than 0
OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>接下来我们执行两条插入命令：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; set msg xiaoming
OK
127.0.0.1:6379&gt; set lang java
OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后我们使用 slowlog show 来查询慢日志，结果如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; slowlog get #慢日志查询
1) 1) (integer) 2 #慢日志下标
   2) (integer) 1581994139 #执行时间
   3) (integer) 5 #花费时间 (单位微秒)
   4) 1) "set" #执行的具体命令
      2) "lang"
      3) "java"
   5) "127.0.0.1:47068"
   6) ""
2) 1) (integer) 1
   2) (integer) 1581994131
   3) (integer) 6
   4) 1) "set"
      2) "msg"
      3) "xiaoming"
   5) "127.0.0.1:47068"
   6) ""
3) 1) (integer) 0
   2) (integer) 1581994093
   3) (integer) 5
   4) 1) "config"
      2) "set"
      3) "slowlog-log-slower-than"
      4) "0"
   5) "127.0.0.1:47068"
   6) ""<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>加上本身的设置命令一共有三条”慢操作”记录，按照插入的顺序倒序存入慢查询日志中。</p>
<blockquote>
<p>小贴士：当慢查询日志超过设定的最大存储条数之后，会把最早的执行命令依次舍弃。</p>
</blockquote>
<h3 id="查询指定条数慢日志"><a href="#查询指定条数慢日志" class="headerlink" title="查询指定条数慢日志"></a>查询指定条数慢日志</h3><p>语法：<code>slowlog get n</code>。</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; slowlog get 2 #查询两条
1) 1) (integer) 20
   2) (integer) 1581997567
   3) (integer) 14
   4) 1) "slowlog"
      2) "get"
      3) "4"
   5) "127.0.0.1:47068"
   6) ""
2) 1) (integer) 19
   2) (integer) 1581997544
   3) (integer) 11
   4) 1) "slowlog"
      2) "get"
      3) "3"
   5) "127.0.0.1:47068"
   6) ""
127.0.0.1:6379&gt; slowlog get 3 #查询三条
1) 1) (integer) 22
   2) (integer) 1581997649
   3) (integer) 25
   4) 1) "set"
      2) "msg"
      3) "hi"
   5) "127.0.0.1:47068"
   6) ""
2) 1) (integer) 21
   2) (integer) 1581997613
   3) (integer) 9
   4) 1) "slowlog"
      2) "get"
      3) "2"
   5) "127.0.0.1:47068"
   6) ""
3) 1) (integer) 20
   2) (integer) 1581997567
   3) (integer) 14
   4) 1) "slowlog"
      2) "get"
      3) "4"
   5) "127.0.0.1:47068"
   6) ""<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="获取慢查询队列长度"><a href="#获取慢查询队列长度" class="headerlink" title="获取慢查询队列长度"></a>获取慢查询队列长度</h3><p>语法：<code>slowlog len</code>。</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; slowlog len
(integer) 16<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="清空慢查询日志"><a href="#清空慢查询日志" class="headerlink" title="清空慢查询日志"></a>清空慢查询日志</h3><p>使用 slowlog reset 来清空所有的慢查询日志，执行命令如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; slowlog reset
OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="35-实战：Redis-性能优化方案"><a href="#35-实战：Redis-性能优化方案" class="headerlink" title="35 实战：Redis 性能优化方案"></a>35 实战：Redis 性能优化方案</h2><p>Redis 是基于单线程模型实现的，也就是 Redis 是使用一个线程来处理所有的客户端请求的，尽管 Redis 使用了非阻塞式 IO，并且对各种命令都做了优化（大部分命令操作时间复杂度都是 O(1)），但由于 Redis 是单线程执行的特点，因此它对性能的要求更加苛刻，本文我们将通过一些优化手段，让 Redis 更加高效的运行。</p>
<p>本文我们将使用以下手段，来提升 Redis 的运行速度：</p>
<ol>
<li>缩短键值对的存储长度；</li>
<li>使用 lazy free（延迟删除）特性；</li>
<li>设置键值的过期时间；</li>
<li>禁用耗时长的查询命令；</li>
<li>使用 slowlog 优化耗时命令；</li>
<li>使用 Pipeline 批量操作数据；</li>
<li>避免大量数据同时失效；</li>
<li>客户端使用优化；</li>
<li>限制 Redis 内存大小；</li>
<li>使用物理机而非虚拟机安装 Redis 服务；</li>
<li>检查数据持久化策略；</li>
<li>使用分布式架构来增加读写速度。</li>
</ol>
<h3 id="缩短键值对的存储长度"><a href="#缩短键值对的存储长度" class="headerlink" title="缩短键值对的存储长度"></a>缩短键值对的存储长度</h3><p>键值对的长度是和性能成反比的，比如我们来做一组写入数据的性能测试，执行结果如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据量</th>
<th>key 大小</th>
<th>value 大小</th>
<th>string:set 平均耗时</th>
<th>hash:hset 平均耗时</th>
</tr>
</thead>
<tbody>
<tr>
<td>100w</td>
<td>20byte</td>
<td>512byte</td>
<td>1.13 微秒</td>
<td>10.28 微秒</td>
</tr>
<tr>
<td>100w</td>
<td>20byte</td>
<td>200byte</td>
<td>0.74 微秒</td>
<td>8.08 微秒</td>
</tr>
<tr>
<td>100w</td>
<td>20byte</td>
<td>100byte</td>
<td>0.65 微秒</td>
<td>7.92 微秒</td>
</tr>
<tr>
<td>100w</td>
<td>20byte</td>
<td>50byte</td>
<td>0.59 微秒</td>
<td>6.74 微秒</td>
</tr>
<tr>
<td>100w</td>
<td>20byte</td>
<td>20byte</td>
<td>0.55 微秒</td>
<td>6.60 微秒</td>
</tr>
<tr>
<td>100w</td>
<td>20byte</td>
<td>5byte</td>
<td>0.53 微秒</td>
<td>6.53 微秒</td>
</tr>
</tbody>
</table>
</div>
<p>从以上数据可以看出，在 key 不变的情况下，value 值越大操作效率越慢，因为 Redis 对于同一种数据类型会使用不同的内部编码进行存储，比如字符串的内部编码就有三种：int（整数编码）、raw（优化内存分配的字符串编码）、embstr（动态字符串编码），这是因为 Redis 的作者是想通过不同编码实现效率和空间的平衡，然而数据量越大使用的内部编码就越复杂，而越是复杂的内部编码存储的性能就越低。</p>
<p>这还只是写入时的速度，当键值对内容较大时，还会带来另外几个问题：</p>
<ul>
<li>内容越大需要的持久化时间就越长，需要挂起的时间越长，Redis 的性能就会越低；</li>
<li>内容越大在网络上传输的内容就越多，需要的时间就越长，整体的运行速度就越低；</li>
<li>内容越大占用的内存就越多，就会更频繁地触发内存淘汰机制，从而给 Redis 带来了更多的运行负担。</li>
</ul>
<p>因此在保证完整语义的同时，我们要尽量地缩短键值对的存储长度，必要时要对数据进行序列化和压缩再存储，以 Java 为例，序列化我们可以使用 protostuff 或 kryo，压缩我们可以使用 snappy。</p>
<h3 id="使用-lazy-free-特性"><a href="#使用-lazy-free-特性" class="headerlink" title="使用 lazy free 特性"></a>使用 lazy free 特性</h3><p>lazy free 特性是 Redis 4.0 新增的一个非常实用的功能，它可以理解为惰性删除或延迟删除。意思是在删除的时候提供异步延时释放键值的功能，把键值释放操作放在 BIO（Background I/O）单独的子线程处理中，以减少删除对 Redis 主线程的阻塞，可以有效地避免删除 big key 时带来的性能和可用性问题。</p>
<p>lazy free 对应了 4 种场景，默认都是关闭的：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">lazyfree-lazy-eviction no
lazyfree-lazy-expire no
lazyfree-lazy-server-del no
slave-lazy-flush no<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>它们代表的含义如下：</p>
<ul>
<li><code>lazyfree-lazy-eviction</code>：表示当 Redis 运行内存超过 maxmeory 时，是否开启 lazy free 机制删除；</li>
<li><code>lazyfree-lazy-expire</code>：表示设置了过期时间的键值，当过期之后是否开启 lazy free 机制删除；</li>
<li><code>lazyfree-lazy-server-del</code>：有些指令在处理已存在的键时，会带有一个隐式的 del 键的操作，比如 rename 命令，当目标键已存在，Redis 会先删除目标键，如果这些目标键是一个 big key，就会造成阻塞删除的问题，此配置表示在这种场景中是否开启 lazy free 机制删除；</li>
<li><code>slave-lazy-flush</code>：针对 slave（从节点）进行全量数据同步，slave 在加载 master 的 RDB 文件前，会运行 flushall 来清理自己的数据，它表示此时是否开启 lazy free 机制删除。</li>
</ul>
<p>建议开启其中的 lazyfree-lazy-eviction、lazyfree-lazy-expire、lazyfree-lazy-server-del 等配置，这样就可以有效的提高主线程的执行效率。</p>
<h3 id="设置键值的过期时间"><a href="#设置键值的过期时间" class="headerlink" title="设置键值的过期时间"></a>设置键值的过期时间</h3><p>我们应该根据实际的业务情况，对键值设置合理的过期时间，这样 Redis 会帮你自动清除过期的键值对，以节约对内存的占用，以避免键值过多的堆积，频繁的触发内存淘汰策略。</p>
<h3 id="禁用耗时长的查询命令"><a href="#禁用耗时长的查询命令" class="headerlink" title="禁用耗时长的查询命令"></a>禁用耗时长的查询命令</h3><p>Redis 绝大多数读写命令的时间复杂度都在 O(1) 到 O(N) 之间，在官方文档对每命令都有时间复杂度说明。 <a target="_blank" rel="noopener" href="https://redis.io/commands">https://redis.io/commands</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/KEYS.png" alt="KEYS"></p>
<p>其中 <code>O(1)</code> 表示可以安全使用的，而 <code>O(N)</code> 就应该当心了，N 表示不确定，数据越大查询的速度可能会越慢。因为 Redis 只用一个线程来做数据查询，如果这些指令耗时很长，就会阻塞 Redis，造成大量延时。</p>
<p>要避免 O(N) 命令对 Redis 造成的影响，可以从以下几个方面入手改造：</p>
<ul>
<li>决定禁止使用 <code>keys</code> 命令；</li>
<li>避免一次查询所有的成员，要使用 scan 命令进行分批的，游标式的遍历；</li>
<li>通过机制严格控制 Hash、Set、Sorted Set 等结构的数据大小；</li>
<li>将排序、并集、交集等操作放在客户端执行，以减少 Redis 服务器运行压力；</li>
<li>删除（del）一个大数据的时候，可能会需要很长时间，所以建议用<strong>异步删除的方式 unlink</strong>，它会启动一个新的线程来删除目标数据，而不阻塞 Redis 的主线程。</li>
</ul>
<h3 id="使用-slowlog-优化耗时命令"><a href="#使用-slowlog-优化耗时命令" class="headerlink" title="使用 slowlog 优化耗时命令"></a>使用 slowlog 优化耗时命令</h3><p>我们可以使用 slowlog 功能找出最耗时的 Redis 命令进行相关的优化，以提升 Redis 的运行速度，慢查询有两个重要的配置项：</p>
<ul>
<li>slowlog-log-slower-than：用于设置慢查询的评定时间，也就是说超过此配置项的命令，将会被当成慢操作记录在慢查询日志中，它执行单位是微秒（1 秒等于 1000000 微秒）；</li>
<li>slowlog-max-len：用来配置慢查询日志的最大记录数。</li>
</ul>
<p>我们可以根据实际的业务情况进行相应的配置，其中慢日志是按照插入的顺序倒序存入慢查询日志中，我们可以使用 <code>slowlog get n</code> 来获取相关的慢查询日志，再找到这些慢查询对应的业务进行相关的优化。</p>
<h3 id="使用-Pipeline-批量操作数据"><a href="#使用-Pipeline-批量操作数据" class="headerlink" title="使用 Pipeline 批量操作数据"></a>使用 Pipeline 批量操作数据</h3><p>Pipeline（管道技术）是客户端提供的一种批处理技术，用于一次处理多个 Redis 命令，从而提高整个交互的性能。</p>
<h3 id="避免大量数据同时失效"><a href="#避免大量数据同时失效" class="headerlink" title="避免大量数据同时失效"></a>避免大量数据同时失效</h3><p>Redis 过期键值删除使用的是贪心策略，它每秒会进行 10 次过期扫描，此配置可在 redis.conf 进行配置，默认值是 hz 10，Redis 会随机抽取 20 个值，删除这 20 个键中过期的键，如果过期 key 的比例超过 25%，重复执行此流程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/过期键值删除.png" alt="过期键值删除"></p>
<p>如果在大型系统中有大量缓存在同一时间同时过期，那么会导致 Redis 循环多次持续扫描删除过期字典，直到过期字典中过期键值被删除的比较稀疏为止，而在整个执行过程会导致 Redis 的读写出现明显的卡顿，卡顿的另一种原因是内存管理器需要频繁回收内存页，因此也会消耗一定的 CPU。</p>
<p>为了避免这种卡顿现象的产生，我们需要预防大量的缓存在同一时刻一起过期，最简单的解决方案就是在过期时间的基础上添加一个指定范围的随机数。</p>
<h3 id="客户端使用优化"><a href="#客户端使用优化" class="headerlink" title="客户端使用优化"></a>客户端使用优化</h3><p>在客户端的使用上我们除了要尽量使用 Pipeline 的技术外，还需要注意要尽量使用 Redis 连接池，而不是频繁创建销毁 Redis 连接，这样就可以减少网络传输次数和减少了非必要调用指令。</p>
<h3 id="限制-Redis-内存大小"><a href="#限制-Redis-内存大小" class="headerlink" title="限制 Redis 内存大小"></a>限制 Redis 内存大小</h3><p>在 64 位操作系统中 Redis 的内存大小是没有限制的，也就是配置项 · 是被注释掉的，这样就会导致在物理内存不足时，使用 swap 空间既交换空间，而当操心系统将 Redis 所用的内存分页移至 swap 空间时，将会阻塞 Redis 进程，导致 Redis 出现延迟，从而影响 Redis 的整体性能。因此我们需要限制 Redis 的内存大小为一个固定的值，当 Redis 的运行到达此值时会触发内存淘汰策略，内存淘汰策略在 Redis 4.0 之后有 8 种：</p>
<ul>
<li>noeviction：不淘汰任何数据，当内存不足时，新增操作会报错，Redis 默认内存淘汰策略；</li>
<li>allkeys-lru：淘汰整个键值中最久未使用的键值；</li>
<li>allkeys-random：随机淘汰任意键值;</li>
<li>volatile-lru：淘汰所有设置了过期时间的键值中最久未使用的键值；</li>
<li>volatile-random：随机淘汰设置了过期时间的任意键值；</li>
<li>volatile-ttl：优先淘汰更早过期的键值。</li>
</ul>
<p>在 Redis 4.0 版本中又新增了 2 种淘汰策略：</p>
<ul>
<li>volatile-lfu：淘汰所有设置了过期时间的键值中，最少使用的键值；</li>
<li>allkeys-lfu：淘汰整个键值中最少使用的键值。</li>
</ul>
<p>其中 <code>allkeys-xxx</code> 表示从所有的键值中淘汰数据，而 <code>volatile-xxx</code> 表示从设置了过期键的键值中淘汰数据。</p>
<p>我们可以根据实际的业务情况进行设置，默认的淘汰策略不淘汰任何数据，在新增时会报错。</p>
<h3 id="使用物理机而非虚拟机"><a href="#使用物理机而非虚拟机" class="headerlink" title="使用物理机而非虚拟机"></a>使用物理机而非虚拟机</h3><p>在虚拟机中运行 Redis 服务器，因为和物理机共享一个物理网口，并且一台物理机可能有多个虚拟机在运行，因此在内存占用上和网络延迟方面都会有很糟糕的表现，我们可以通过 <code>./redis-cli --intrinsic-latency 100</code> 命令查看延迟时间，如果对 Redis 的性能有较高要求的话，应尽可能在物理机上直接部署 Redis 服务器。</p>
<p>检查数据持久化策略<br>Redis 的持久化策略是将内存数据复制到硬盘上，这样才可以进行容灾恢复或者数据迁移，但维护此持久化的功能，需要很大的性能开销。</p>
<p>在 Redis 4.0 之后，Redis 有 3 种持久化的方式：</p>
<p>RDB（Redis DataBase，快照方式）将某一个时刻的内存数据，以二进制的方式写入磁盘；<br>AOF（Append Only File，文件追加方式），记录所有的操作命令，并以文本的形式追加到文件中；<br>混合持久化方式，Redis 4.0 之后新增的方式，混合持久化是结合了 RDB 和 AOF 的优点，在写入的时候，先把当前的数据以 RDB 的形式写入文件的开头，再将后续的操作命令以 AOF 的格式存入文件，这样既能保证 Redis 重启时的速度，又能减低数据丢失的风险。<br>RDB 和 AOF 持久化各有利弊，RDB 可能会导致一定时间内的数据丢失，而 AOF 由于文件较大则会影响 Redis 的启动速度，为了能同时拥有 RDB 和 AOF 的优点，Redis 4.0 之后新增了混合持久化的方式，因此我们在必须要进行持久化操作时，应该选择混合持久化的方式。</p>
<h2 id="36-实战：Redis-主从同步"><a href="#36-实战：Redis-主从同步" class="headerlink" title="36 实战：Redis 主从同步"></a>36 实战：Redis 主从同步</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wan-ming-zhu/p/18081637">https://www.cnblogs.com/wan-ming-zhu/p/18081637</a></p>
<p>主从同步（主从复制）是 Redis 高可用服务的基石，也是多机运行中最基础的一个。我们把主要存储数据的节点叫做主节点 (master），把其他通过复制主节点数据的副本节点叫做从节点 (slave），如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/Redis主从同步.png" alt="Redis主从同步"></p>
<p>在 Redis 中一个主节点可以拥有多个从节点，一个从节点也可以是其他服务器的主节点，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/Redis主从从同步.png" alt="Redis主从从同步"></p>
<h3 id="主从同步的优点"><a href="#主从同步的优点" class="headerlink" title="主从同步的优点"></a>主从同步的优点</h3><p>主从同步具有以下三个优点：</p>
<ul>
<li>性能方面：有了主从同步之后，可以把查询任务分配给从服务器，用主服务器来执行写操作，这样极大的提高了程序运行的效率，把所有压力分摊到各个服务器了；</li>
<li>高可用：当有了主从同步之后，当主服务器节点宕机之后，可以很迅速的把从节点提升为主节点，为 Redis 服务器的宕机恢复节省了宝贵的时间；</li>
<li>防止数据丢失：当主服务器磁盘坏掉之后，其他从服务器还保留着相关的数据，不至于数据全部丢失。</li>
</ul>
<p>既然主从同步有这么多的优点，那接下来我们来看如何开启和使用主从同步功能。</p>
<h3 id="开启主从同步"><a href="#开启主从同步" class="headerlink" title="开启主从同步"></a>开启主从同步</h3><h4 id="运行中设置从服务器"><a href="#运行中设置从服务器" class="headerlink" title="运行中设置从服务器"></a>运行中设置从服务器</h4><p>在 Redis 运行过程中，我们可以使用 <code>replicaof host port</code> 命令，把自己设置为目标 IP 的从服务器，执行命令如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; replicaof 127.0.0.1 6380
OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果主服务设置了密码，需要在从服务器输入主服务器的密码，使用 <code>config set masterauth 主服务密码</code> 命令的方式，例如：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6377&gt; config set masterauth pwd654321
OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h5 id="1-执行流程"><a href="#1-执行流程" class="headerlink" title="1. 执行流程"></a>1. 执行流程</h5><p>在执行完 replicaof 命令之后，从服务器的数据会被清空，主服务会把它的数据副本同步给从服务器。</p>
<h5 id="2-测试同步功能"><a href="#2-测试同步功能" class="headerlink" title="2. 测试同步功能"></a>2. 测试同步功能</h5><p>主从服务器设置完同步之后，我们来测试一下主从数据同步，首先我们先在主服务器上执行保存数据操作，再去从服务器查询。</p>
<p>主服务器执行命令：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; set lang redis
OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>从服务执行查询：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; get lang
"redis"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>可以看出数据已经被正常同步过来了。</p>
<h4 id="启动时设置从服务器"><a href="#启动时设置从服务器" class="headerlink" title="启动时设置从服务器"></a>启动时设置从服务器</h4><p>我们可以使用命令 <code>redis-server --port 6380 --replicaof 127.0.0.1 6379</code> 将自己设置成目标服务器的从服务器。</p>
<h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><h4 id="完整数据同步"><a href="#完整数据同步" class="headerlink" title="完整数据同步"></a>完整数据同步</h4><p>当有新的从服务器连接时，为了保障多个数据库的一致性，主服务器会执行一次 bgsave 命令生成一个 RDB 文件，然后再以 Socket 的方式发送给从服务器，从服务器收到 RDB 文件之后再把所有的数据加载到自己的程序中，就完成了一次全量的数据同步。</p>
<h4 id="部分数据同步"><a href="#部分数据同步" class="headerlink" title="部分数据同步"></a>部分数据同步</h4><p>在 Redis 2.8 之前每次从服务器离线再重新上线之前，主服务器会进行一次完整的数据同步，然后这种情况如果发生在离线时间比较短的情况下，只有少量的数据不同步却要同步所有的数据是非常笨拙和不划算的，在 Redis 2.8 这个功能得到了优化。</p>
<p>Redis 2.8 的优化方法是当从服务离线之后，主服务器会把离线之后的写入命令，存储在一个特定大小的队列中，队列是可以保证先进先出的执行顺序的，当从服务器重写恢复上线之后，主服务会判断离线这段时间内的命令是否还在队列中，如果在就直接把队列中的数据发送给从服务器，这样就避免了完整同步的资源浪费。</p>
<blockquote>
<p>小贴士：存储离线命令的队列大小默认是 1MB，使用者可以自行修改队列大小的配置项 repl-backlog-size。</p>
</blockquote>
<h4 id="无盘数据同步"><a href="#无盘数据同步" class="headerlink" title="无盘数据同步"></a>无盘数据同步</h4><p>从前面的内容我们可以得知，在第一次主从连接的时候，会先产生一个 RDB 文件，再把 RDB 文件发送给从服务器，如果主服务器是非固态硬盘的时候，系统的 I/O 操作是非常高的，为了缓解这个问题，Redis 2.8.18 新增了无盘复制功能，无盘复制功能不会在本地创建 RDB 文件，而是会派生出一个子进程，然后由子进程通过 Socket 的方式，直接将 RDB 文件写入到从服务器，这样主服务器就可以在不创建RDB文件的情况下，完成与从服务器的数据同步。</p>
<p>要使用无须复制功能，只需把配置项 <code>repl-diskless-sync</code> 的值设置为 yes 即可，它默认配置值为 no。</p>
<h3 id="查询服务器的角色"><a href="#查询服务器的角色" class="headerlink" title="查询服务器的角色"></a>查询服务器的角色</h3><p>我们使用 role 命令，来查询当前服务器的主从角色信息。</p>
<h4 id="主服务查看"><a href="#主服务查看" class="headerlink" title="主服务查看"></a>主服务查看</h4><p>在主服务器上执行 role 结果如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; role
1) "master"
2) (integer) 546
3) 1) 1) "172.17.0.1"
      2) "6379"
      3) "546"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>master 表示主服务器，底下是从服务器的 IP、端口和连接时间。</p>
<h4 id="从服务器查看"><a href="#从服务器查看" class="headerlink" title="从服务器查看"></a>从服务器查看</h4><p>在从服务器执行 role 命令，执行结果如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; role
1) "slave"
2) "192.168.1.71"
3) (integer) 6380
4) "connected"
5) (integer) 14<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>slave 表示从服务器，底下主服务器的 IP、端口和连接时间。</p>
<h4 id="关闭主从同步"><a href="#关闭主从同步" class="headerlink" title="关闭主从同步"></a>关闭主从同步</h4><p>我们可以使用 <code>replicaof no one</code> 命令来停止从服务器的复制，操作命令如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:6379&gt; role #查询当前角色
1) "slave" #从服务器
2) "192.168.1.71"
3) (integer) 6380
4) "connected"
5) (integer) 14
127.0.0.1:6379&gt; replicaof no one #关闭同步
OK
127.0.0.1:6379&gt; role #查询当前角色
1) "master" #主服务器
2) (integer) 1097
3) (empty list or set)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出执行了 <code>replicaof no one</code> 命令之后，自己就从服务器变成主服务器了。</p>
<blockquote>
<p>小贴士：服务器类型的转换并不会影响数据，这台服务器的数据将会被保留。</p>
</blockquote>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><p>主从同步有一些需要注意的点，我们来看一下。</p>
<h4 id="数据一致性问题"><a href="#数据一致性问题" class="headerlink" title="数据一致性问题"></a>数据一致性问题</h4><p>当从服务器已经完成和主服务的数据同步之后，再新增的命令会以异步的方式发送至从服务器，在这个过程中主从同步会有短暂的数据不一致，如在这个异步同步发生之前主服务器宕机了，会造成数据不一致。</p>
<h4 id="从服务器只读性"><a href="#从服务器只读性" class="headerlink" title="从服务器只读性"></a>从服务器只读性</h4><p>默认在情况下，处于复制模式的主服务器既可以执行写操作也可以执行读操作，而从服务器则只能执行读操作。</p>
<p>可以在从服务器上执行 <code>config set replica-read-only no</code> 命令，使从服务器开启写模式，但需要注意以下几点：</p>
<ul>
<li>在从服务器上写的数据不会同步到主服务器；</li>
<li>当键值相同时主服务器上的数据可以覆盖从服务器；</li>
<li>在进行完整数据同步时，从服务器数据会被清空。</li>
</ul>
<h4 id="复制命令的变化"><a href="#复制命令的变化" class="headerlink" title="复制命令的变化"></a>复制命令的变化</h4><p>Redis 5.0 之前使用的复制命令是 slaveof，在 Redis 5.0 之后复制命令才被改为 replicaof，在高版本（Redis 5+）中我们应该尽量使用 replicaof，因为 slaveof 命令可能会被随时废弃掉。</p>
<h3 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h3><p>本文我们了解了 Redis 多机运行的基础功能主从同步，主从同步可以通过 <code>replicaof host port</code> 命令开启，知道了同步的三种方式：完整数据同步（第一次全量 RDB 同步），部分数据同步（Redis 2.8 对于短时间离线的同步功能优化），无盘同步（非 RDB 生成的方式同步数据），我们也可以使用 <code>replicaof no one</code> 命令来停止从服务器的复制功能。</p>
<h2 id="37-实战：Redis哨兵模式（上）"><a href="#37-实战：Redis哨兵模式（上）" class="headerlink" title="37 实战：Redis哨兵模式（上）"></a>37 实战：Redis哨兵模式（上）</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wan-ming-zhu/p/18081847">https://www.cnblogs.com/wan-ming-zhu/p/18081847</a></p>
<p>上一篇我们讲了主从复制模式，它是属于 Redis 多机运行的基础，但这种模式本身存在一个致命的问题，当主节点奔溃之后，需要人工干预才能恢复 Redis 的正常使用。</p>
<p>例如，我们有 3 台服务器做了主从复制，一个主服务器 A 和两个从服务器 B、C，当 A 发生故障之后，需要人工把 B 服务器设置为主服务器，同时再去 C 服务器设置成从服务器并且从主服务器 B 同步数据，如果是发生在晚上或者从服务器节点很多的情况下，对于人工来说想要立即实现恢复的难度很多，所以我们需要一个自动的工具——Redis Sentinel（哨兵模式）来把手动的过程变成自动的，让 Redis 拥有自动容灾恢复（failover）的能力。</p>
<p>哨兵模式如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/哨兵模式.png" alt="哨兵模式"></p>
<blockquote>
<p>小贴士：Redis Sentinel 的最小分配单位是一主一从。</p>
</blockquote>
<h3 id="Redis-Sentinel-搭建"><a href="#Redis-Sentinel-搭建" class="headerlink" title="Redis Sentinel 搭建"></a>Redis Sentinel 搭建</h3><p>Redis 官方提供了 Redis Sentinel 的功能，它的运行程序保存在 src 目录下。</p>
<p>我们需要使用命令 <code>./src/redis-sentinel sentinel.conf</code> 来启动 Sentinel，可以看出我们在启动它时必须设置一个 sentinel.conf 文件，这个配置文件中必须包含监听的主节点信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sentinel monitor master-name <span class="token function">ip</span> port quorum<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>例如：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sentinel monitor mymaster <span class="token number">127.0</span>.0.1 <span class="token number">6379</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>其中：</p>
<ul>
<li>master-name 表示给监视的主节点起一个名称；</li>
<li>ip 表示主节点的 IP；</li>
<li>port 表示主节点的端口；</li>
<li>quorum 表示确认主节点下线的 Sentinel 数量，如果 quorum 设置为 1 表示只要有一台 Sentinel 判断它下线了，就可以确认它真的下线了。</li>
</ul>
<blockquote>
<p>注意：如果主节点 Redis 服务器有密码，还必须在 sentinel.conf 中添加主节点的密码，不然会导致 Sentinel 不能自动监听到主节点下面的从节点。</p>
</blockquote>
<p>所以如果 Redis 有密码，sentinel.conf 必须包含以下内容：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">sentinel monitor mymaster 127.0.0.1 6379 1
sentinel auth-pass mymaster pwd654321<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>当我们配置好 sentinel.conf 并执行启动命令 <code>./src/redis-sentinel sentinel.conf</code> 之后，Redis Sentinel 就会被启动，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/Sentinel启动.png" alt="Sentinel启动"></p>
<p>从上图可以看出 Sentinel 只需配置监听主节点的信息，它会自动监听对应的从节点。</p>
<h3 id="启动-Sentinel-集群"><a href="#启动-Sentinel-集群" class="headerlink" title="启动 Sentinel 集群"></a>启动 Sentinel 集群</h3><p>上面我们演示了单个 Sentinel 的启动，但生产环境我们不会只启动一台 Sentinel，因为如果启动一台 Sentinel 假如它不幸宕机的话，就不能提供自动容灾的服务了，不符合我们高可用的宗旨，所以我们会在不同的物理机上启动多个 Sentinel 来组成 Sentinel 集群，来保证 Redis 服务的高可用。</p>
<p>启动 Sentinel 集群的方法很简单，和上面启动单台的方式一样，我们只需要把多个 Sentinel 监听到一个主服务器节点，那么多个 Sentinel 就会自动发现彼此，并组成一个 Sentinel 集群。</p>
<p>我们启动第二个 Sentinel 来试一下，执行结果如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>@iZ2ze0nc5n41zomzyqtksmZ:redis2<span class="token punctuation">]</span>$ ./src/redis-sentinel sentinel.conf
<span class="token number">5547</span>:X <span class="token number">19</span> Feb <span class="token number">2020</span> <span class="token number">20</span>:29:30.047 <span class="token comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span>
<span class="token number">5547</span>:X <span class="token number">19</span> Feb <span class="token number">2020</span> <span class="token number">20</span>:29:30.047 <span class="token comment"># Redis version=5.0.5, bits=64, commit=00000000, modified=0, pid=5547, just started</span>
<span class="token number">5547</span>:X <span class="token number">19</span> Feb <span class="token number">2020</span> <span class="token number">20</span>:29:30.047 <span class="token comment"># Configuration loaded</span>
                _._                                                  
           _.-`<span class="token variable"><span class="token variable">`</span>__ <span class="token string">''</span>-._                                             
      _.-<span class="token variable">`</span></span><span class="token variable"><span class="token variable">`</span>    <span class="token variable">`</span></span><span class="token builtin class-name">.</span>  <span class="token variable"><span class="token variable">`</span>_.  <span class="token string">''</span>-._           Redis <span class="token number">5.0</span>.5 <span class="token punctuation">(</span>00000000/0<span class="token punctuation">)</span> <span class="token number">64</span> bit
  .-<span class="token variable">`</span></span><span class="token variable"><span class="token variable">`</span> .-<span class="token variable">`</span></span>`<span class="token variable"><span class="token variable">`</span><span class="token builtin class-name">.</span>  <span class="token variable">`</span></span>`<span class="token variable"><span class="token variable">`</span><span class="token punctuation">\</span>/    _.,_ <span class="token string">''</span>-._                                   
 <span class="token punctuation">(</span>    '      ,       .-<span class="token variable">`</span></span>  <span class="token operator">|</span> <span class="token variable"><span class="token variable">`</span>,    <span class="token punctuation">)</span>     Running <span class="token keyword">in</span> sentinel mode
 <span class="token operator">|</span><span class="token variable">`</span></span>-._<span class="token variable"><span class="token variable">`</span>-<span class="token punctuation">..</span>.-<span class="token variable">`</span></span> __<span class="token punctuation">..</span>.-.`<span class="token variable"><span class="token variable">`</span>-._<span class="token operator">|</span>'<span class="token variable">`</span></span> _.-<span class="token string">'|     Port: 26377
 |    <span class="token variable"><span class="token variable">`</span>-._   <span class="token variable">`</span></span>._    /     _.-'</span>    <span class="token operator">|</span>     PID: <span class="token number">5547</span>
  <span class="token variable"><span class="token variable">`</span>-._    <span class="token variable">`</span></span>-._  <span class="token variable"><span class="token variable">`</span>-./  _.-<span class="token string">'    _.-'</span>                                   
 <span class="token operator">|</span><span class="token variable">`</span></span>-._<span class="token variable"><span class="token variable">`</span>-._    <span class="token variable">`</span></span>-.__.-<span class="token string">'    _.-'</span>_.-<span class="token string">'|                                  
 |    <span class="token variable"><span class="token variable">`</span>-._<span class="token variable">`</span></span>-._        _.-'</span>_.-<span class="token string">'    |           http://redis.io        
  <span class="token variable"><span class="token variable">`</span>-._    <span class="token variable">`</span></span>-._<span class="token variable"><span class="token variable">`</span>-.__.-<span class="token string">'_.-'</span>    _.-'                                   
 <span class="token operator">|</span><span class="token variable">`</span></span>-._<span class="token variable"><span class="token variable">`</span>-._    <span class="token variable">`</span></span>-.__.-'</span>    _.-<span class="token string">'_.-'</span><span class="token operator">|</span>                                  
 <span class="token operator">|</span>    <span class="token variable"><span class="token variable">`</span>-._<span class="token variable">`</span></span>-._        _.-<span class="token string">'_.-'</span>    <span class="token operator">|</span>                                  
  <span class="token variable"><span class="token variable">`</span>-._    <span class="token variable">`</span></span>-._<span class="token variable"><span class="token variable">`</span>-.__.-<span class="token string">'_.-'</span>    _.-'                                   
      <span class="token variable">`</span></span>-._    <span class="token variable"><span class="token variable">`</span>-.__.-<span class="token string">'    _.-'</span>                                       
          <span class="token variable">`</span></span>-._        _.-<span class="token string">'                                           
              `-.__.-'</span>                                               

<span class="token number">5547</span>:X <span class="token number">19</span> Feb <span class="token number">2020</span> <span class="token number">20</span>:29:30.049 <span class="token comment"># WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span>
<span class="token number">5547</span>:X <span class="token number">19</span> Feb <span class="token number">2020</span> <span class="token number">20</span>:29:30.049 <span class="token comment"># Sentinel ID is 6455f2f74614a71ce0a63398b2e48d6cd1cf0d06</span>
<span class="token number">5547</span>:X <span class="token number">19</span> Feb <span class="token number">2020</span> <span class="token number">20</span>:29:30.049 <span class="token comment"># +monitor master mymaster 127.0.0.1 6379 quorum 1</span>
<span class="token number">5547</span>:X <span class="token number">19</span> Feb <span class="token number">2020</span> <span class="token number">20</span>:29:30.049 * +slave slave <span class="token number">127.0</span>.0.1:6377 <span class="token number">127.0</span>.0.1 <span class="token number">6377</span> @ mymaster <span class="token number">127.0</span>.0.1 <span class="token number">6379</span>
<span class="token number">5547</span>:X <span class="token number">19</span> Feb <span class="token number">2020</span> <span class="token number">20</span>:29:30.052 * +slave slave <span class="token number">127.0</span>.0.1:6378 <span class="token number">127.0</span>.0.1 <span class="token number">6378</span> @ mymaster <span class="token number">127.0</span>.0.1 <span class="token number">6379</span>
<span class="token number">5547</span>:X <span class="token number">19</span> Feb <span class="token number">2020</span> <span class="token number">20</span>:29:30.345 * +sentinel sentinel 6455f2f74614a71ce0a63398b2e48d6cd1cf0d08 <span class="token number">127.0</span>.0.1 <span class="token number">26379</span> @ mymaster <span class="token number">127.0</span>.0.1 <span class="token number">6379</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从以上启动命令可以看出，比单机模式多了最后一行发现其他 Sentinel 服务器的命令，说明这两个 Sentinel 已经组成一个集群了。</p>
<p>Sentinel 集群示意图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/Sentinel集群.png" alt="Sentinel集群"></p>
<p>一般情况下 Sentinel 集群的数量取大于 1 的奇数，例如 3、5、7、9，而 quorum 的配置要根据 Sentinel 的数量来发生变化，例如 Sentinel 是 3 台，那么对应的 quorum 最好是 2，如果 Sentinel 是 5 台，那么 quorum 最好是 3，它表示当有 3 台 Sentinel 都确认主节点下线了，就可以确定主节点真的下线了。</p>
<p>与 quorum 参数相关的有两个概念：主观下线和客观下线。</p>
<p>当 Sentinel 集群中，有一个 Sentinel 认为主服务器已经下线时，它会将这个主服务器标记为主观下线（Subjectively Down，SDOWN），然后询问集群中的其他 Sentinel，是否也认为该服务器已下线，当同意主服务器已下线的 Sentinel 数量达到 quorum 参数所指定的数量时，Sentinel 就会将相应的主服务器标记为客观下线（Objectively down，ODOWN），然后开始对其进行故障转移。</p>
<h3 id="自动容灾测试"><a href="#自动容灾测试" class="headerlink" title="自动容灾测试"></a>自动容灾测试</h3><p>前面我们已经搭建了 Redis Sentinel，接下来我们就尝试一下自动容灾的功能，为了模拟故障我们先把主节点手动 kill 掉，执行命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>@iZ2ze0nc5n41zomzyqtksmZ:~<span class="token punctuation">]</span>$ <span class="token function">ps</span> -ef<span class="token operator">|</span><span class="token function">grep</span> redis <span class="token comment">#找到主节点的进程id</span>
root      <span class="token number">5186</span>     <span class="token number">1</span>  <span class="token number">0</span> <span class="token number">16</span>:54 ?        00:00:23 ./src/redis-server *:6377
root      <span class="token number">5200</span>     <span class="token number">1</span>  <span class="token number">0</span> <span class="token number">16</span>:56 ?        00:00:22 ./src/redis-server *:6378
root      <span class="token number">5304</span>  <span class="token number">5287</span>  <span class="token number">0</span> <span class="token number">17</span>:31 pts/2    00:00:00 redis-cli -a pwd654321
root      <span class="token number">5395</span>  <span class="token number">5255</span>  <span class="token number">0</span> <span class="token number">18</span>:26 pts/1    00:00:19 ./src/redis-sentinel *:26379 <span class="token punctuation">[</span>sentinel<span class="token punctuation">]</span>
root      <span class="token number">5547</span>  <span class="token number">5478</span>  <span class="token number">0</span> <span class="token number">20</span>:29 pts/4    00:00:02 ./src/redis-sentinel *:26377 <span class="token punctuation">[</span>sentinel<span class="token punctuation">]</span>
root      <span class="token number">5551</span>  <span class="token number">5517</span>  <span class="token number">0</span> <span class="token number">20</span>:29 pts/5    00:00:00 redis-cli -h <span class="token number">127.0</span>.0.1 -p <span class="token number">26377</span> -a pwd654321
root      <span class="token number">5568</span>  <span class="token number">5371</span>  <span class="token number">0</span> <span class="token number">20</span>:48 pts/0    00:00:00 <span class="token function">grep</span> --color<span class="token operator">=</span>auto redis
root     <span class="token number">28517</span>     <span class="token number">1</span>  <span class="token number">0</span> Feb13 ?        00:15:33 ./src/redis-server *:6379
<span class="token punctuation">[</span>@iZ2ze0nc5n41zomzyqtksmZ:~<span class="token punctuation">]</span>$ <span class="token function">kill</span> -9 <span class="token number">28517</span> <span class="token comment">#关闭主节点服务</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个时候我们在连接上另一台 Redis 服务器，查看当前主从服务器信息，执行命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>@iZ2ze0nc5n41zomzyqtksmZ:~<span class="token punctuation">]</span>$ redis-cli -h <span class="token number">127.0</span>.0.1 -p <span class="token number">6377</span> -a pwd654321 <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>/dev/null
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">7</span>&gt;</span> role
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"master"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">770389</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"127.0.0.1"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"6378"</span>
      <span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"770389"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出之前的从服务 6377 被提升为主服务器了，还剩下一台从服务 6378，而之前的主服务器 6379 被我们手动下线了，可以看出 Sentinel 已经完美的完成的它的故障自动转移的任务。</p>
<h3 id="主服务竞选规则"><a href="#主服务竞选规则" class="headerlink" title="主服务竞选规则"></a>主服务竞选规则</h3><p>上面我们模拟了 Redis Sentinel 自动容灾恢复，那接下来我们来看一下，主服务器竞选的规则和相关设置项。</p>
<h4 id="新主节点竞选优先级设置"><a href="#新主节点竞选优先级设置" class="headerlink" title="新主节点竞选优先级设置"></a>新主节点竞选优先级设置</h4><p>我们可以 redis.conf 中的 replica-priority 选项来设置竞选新主节点的优先级，它的默认值是 100，它的最大值也是 100，这个值越小它的权重就越高，例如从节点 A 的 replica-priority 值为 100，从节点 B 的值为 50，从节点 C 的值为 5，那么在竞选时从节点 C 会作为新的主节点。</p>
<h5 id="新主节点竞选规则"><a href="#新主节点竞选规则" class="headerlink" title="新主节点竞选规则"></a>新主节点竞选规则</h5><p>新主节点的竞选会排除不符合条件的从节点，然后再剩余的从节点按照优先级来挑选。首先来说，存在以下条件的从节点会被排除：</p>
<ol>
<li>排除所有已经下线以及长时间没有回复心跳检测的疑似已下线从服务器；</li>
<li>排除所有长时间没有与主服务器通信，数据状态过时的从服务器；</li>
<li>排除所有优先级（replica-priority）为 0 的服务器。</li>
</ol>
<p>符合条件的从节点竞选顺序：</p>
<ol>
<li>优先级最高的从节点将会作为新主节点；</li>
<li>优先级相等则判断复制偏移量，偏移量最大的从节点获胜；</li>
<li>如果以上两个条件都相同，选择 Redis 运行时随机生成 ID 最小那个为新的主服务器。</li>
</ol>
<h5 id="旧主节点恢复上线"><a href="#旧主节点恢复上线" class="headerlink" title="旧主节点恢复上线"></a>旧主节点恢复上线</h5><p>如果之前的旧主节点恢复上线，会作为从节点运行在主从服务器模式中。</p>
<h3 id="哨兵工作原理"><a href="#哨兵工作原理" class="headerlink" title="哨兵工作原理"></a>哨兵工作原理</h3><p>哨兵的工作原理是这样的，首先每个 Sentinel 会以每秒钟 1 次的频率，向已知的主服务器、从服务器和以及其他 Sentinel 实例，发送一个 PING 命令。</p>
<p>如果最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 所配置的值（默认 30s），那么这个实例会被 Sentinel 标记为主观下线。</p>
<p>如果一个主服务器被标记为主观下线，那么正在监视这个主服务器的所有 Sentinel 节点，要以每秒 1 次的频率确认 主服务器的确进入了主观下线状态。</p>
<p>如果有足够数量（quorum 配置值）的 Sentinel 在指定的时间范围内同意这一判断，那么这个主服务器被标记为客观下线。此时所有的 Sentinel 会按照规则协商自动选出新的主节点。</p>
<blockquote>
<p>注意：一个有效的 PING 回复可以是：+PONG、-LOADING 或者 -MASTERDOWN。如果返回值非以上三种回复，或者在指定时间内没有回复 PING 命令， 那么 Sentinel 认为服务器返回的回复无效(non-valid)。</p>
</blockquote>
<h2 id="38-实战：Redis-哨兵模式（下）"><a href="#38-实战：Redis-哨兵模式（下）" class="headerlink" title="38 实战：Redis 哨兵模式（下）"></a>38 实战：Redis 哨兵模式（下）</h2><h3 id="Sentinel-命令操作"><a href="#Sentinel-命令操作" class="headerlink" title="Sentinel 命令操作"></a>Sentinel 命令操作</h3><p>要使用 Sentinel 实现要连接到 Sentinel 服务器，和连接 Redis 服务相同，我们可以使用 redis-cli 来连接 Sentinel，如下命令所示：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">[@iZ2ze0nc5n41zomzyqtksmZ:~]$ redis-cli -h 127.0.0.1 -p 26379 -a pwd654321
127.0.0.1:26379&gt; ping
PONG<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>其中：</p>
<ul>
<li><code>-h</code> 后面输入的是 Sentinel 的 IP；</li>
<li><code>-p</code> 后面输入的是 Sentinel 的端口，默认是 26379；</li>
<li><code>-a</code> 后面输入的是密码。</li>
</ul>
<p>Sentinel 的端口号可以在 sentinel.conf 里面配置，通过 port 选项设置。</p>
<blockquote>
<p>注意：Sentinel 可以监视多台主节点，而不是只能监视一台服务器。想要监视多台主节点只需要在配置文件中设置多个 <code>sentinel monitor master-name ip port quorum</code> 即可，我们通过 master-name 来区分不同的主节点。</p>
</blockquote>
<h4 id="查询所有被监控的主服务器信息"><a href="#查询所有被监控的主服务器信息" class="headerlink" title="查询所有被监控的主服务器信息"></a>查询所有被监控的主服务器信息</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:26379&gt; sentinel masters
1)  1) "name"
    2) "mymaster"
    3) "ip"
    4) "127.0.0.1"
    5) "port"
    6) "6377"
    7) "runid"
    8) "eb3552c6fc8974f91466c4ada90fe23ef30fd89c"
    9) "flags"
   10) "master"
   11) "link-pending-commands"
   12) "0"
   13) "link-refcount"
   14) "1"
   15) "last-ping-sent"
   16) "0"
   17) "last-ok-ping-reply"
   18) "400"
   19) "last-ping-reply"
   20) "400"
   21) "down-after-milliseconds"
   22) "30000"
   23) "info-refresh"
   24) "5731"
   25) "role-reported"
   26) "master"
   27) "role-reported-time"
   28) "75963321"
   29) "config-epoch"
   30) "7"
   31) "num-slaves"
   32) "2"
   33) "num-other-sentinels"
   34) "1"
   35) "quorum"
   36) "2"
   37) "failover-timeout"
   38) "180000"
   39) "parallel-syncs"
   40) "1"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>相关语法：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">sentinel masters<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>因为我们配置的 Sentinel 只监视了一台主服务器，所以只有一台服务器的信息。</p>
<h4 id="查询某个主节点的信息"><a href="#查询某个主节点的信息" class="headerlink" title="查询某个主节点的信息"></a>查询某个主节点的信息</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:26379&gt; sentinel master mymaster
 1) "name"
 2) "mymaster"
 3) "ip"
 4) "127.0.0.1"
 5) "port"
 6) "6377"
 7) "runid"
 8) "eb3552c6fc8974f91466c4ada90fe23ef30fd89c"
 9) "flags"
10) "master"
11) "link-pending-commands"
12) "0"
13) "link-refcount"
14) "1"
15) "last-ping-sent"
16) "0"
17) "last-ok-ping-reply"
18) "250"
19) "last-ping-reply"
20) "250"
21) "down-after-milliseconds"
22) "30000"
23) "info-refresh"
24) "8191"
25) "role-reported"
26) "master"
27) "role-reported-time"
28) "76096303"
29) "config-epoch"
30) "7"
31) "num-slaves"
32) "2"
33) "num-other-sentinels"
34) "1"
35) "quorum"
36) "2"
37) "failover-timeout"
38) "180000"
39) "parallel-syncs"
40) "1"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>相关语法：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">sentinel master master-name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="查看某个主节点的-IP-和端口"><a href="#查看某个主节点的-IP-和端口" class="headerlink" title="查看某个主节点的 IP 和端口"></a>查看某个主节点的 IP 和端口</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:26379&gt; sentinel get-master-addr-by-name mymaster
1) "127.0.0.1"
2) "6377"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>相关语法：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">sentinel get-master-addr-by-name master-name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="查询从节点的信息"><a href="#查询从节点的信息" class="headerlink" title="查询从节点的信息"></a>查询从节点的信息</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:26379&gt; sentinel slaves mymaster #获取方式一
1)  1) "name"
    2) "127.0.0.1:6379"
    3) "ip"
    4) "127.0.0.1"
    5) "port"
    6) "6379"
    7) "runid"
    8) "14734d6065d745d89f115ca4735e7eeeeaa1a59b"
    9) "flags"
   10) "slave"
   11) "link-pending-commands"
   12) "0"
   13) "link-refcount"
   14) "1"
   15) "last-ping-sent"
   16) "0"
   17) "last-ok-ping-reply"
   18) "389"
   19) "last-ping-reply"
   20) "389"
   21) "down-after-milliseconds"
   22) "30000"
   23) "info-refresh"
   24) "390"
   25) "role-reported"
   26) "slave"
   27) "role-reported-time"
   28) "982798"
   29) "master-link-down-time"
   30) "1582192784000"
   31) "master-link-status"
   32) "err"
   33) "master-host"
   34) "127.0.0.1"
   35) "master-port"
   36) "6377"
   37) "slave-priority"
   38) "100"
   39) "slave-repl-offset"
   40) "1"
2)  1) "name"
    2) "127.0.0.1:6378"
    3) "ip"
    4) "127.0.0.1"
    5) "port"
    6) "6378"
    7) "runid"
    8) "f9d69479ace6c9eb4a6dffa58ebc1ddf3de456e0"
    9) "flags"
   10) "slave"
   11) "link-pending-commands"
   12) "0"
   13) "link-refcount"
   14) "1"
   15) "last-ping-sent"
   16) "0"
   17) "last-ok-ping-reply"
   18) "390"
   19) "last-ping-reply"
   20) "390"
   21) "down-after-milliseconds"
   22) "30000"
   23) "info-refresh"
   24) "4004"
   25) "role-reported"
   26) "slave"
   27) "role-reported-time"
   28) "76212633"
   29) "master-link-down-time"
   30) "0"
   31) "master-link-status"
   32) "ok"
   33) "master-host"
   34) "127.0.0.1"
   35) "master-port"
   36) "6377"
   37) "slave-priority"
   38) "100"
   39) "slave-repl-offset"
   40) "10811245"
127.0.0.1:26379&gt; sentinel replicas mymaster #获取方式二
1)  1) "name"
    2) "127.0.0.1:6379"
    3) "ip"
    4) "127.0.0.1"
    5) "port"
    6) "6379"
    7) "runid"
    8) "14734d6065d745d89f115ca4735e7eeeeaa1a59b"
    9) "flags"
   10) "slave"
   11) "link-pending-commands"
   12) "0"
   13) "link-refcount"
   14) "1"
   15) "last-ping-sent"
   16) "0"
   17) "last-ok-ping-reply"
   18) "100"
   19) "last-ping-reply"
   20) "100"
   21) "down-after-milliseconds"
   22) "30000"
   23) "info-refresh"
   24) "100"
   25) "role-reported"
   26) "slave"
   27) "role-reported-time"
   28) "1071687"
   29) "master-link-down-time"
   30) "1582192873000"
   31) "master-link-status"
   32) "err"
   33) "master-host"
   34) "127.0.0.1"
   35) "master-port"
   36) "6377"
   37) "slave-priority"
   38) "100"
   39) "slave-repl-offset"
   40) "1"
2)  1) "name"
    2) "127.0.0.1:6378"
    3) "ip"
    4) "127.0.0.1"
    5) "port"
    6) "6378"
    7) "runid"
    8) "f9d69479ace6c9eb4a6dffa58ebc1ddf3de456e0"
    9) "flags"
   10) "slave"
   11) "link-pending-commands"
   12) "0"
   13) "link-refcount"
   14) "1"
   15) "last-ping-sent"
   16) "0"
   17) "last-ok-ping-reply"
   18) "100"
   19) "last-ping-reply"
   20) "100"
   21) "down-after-milliseconds"
   22) "30000"
   23) "info-refresh"
   24) "2496"
   25) "role-reported"
   26) "slave"
   27) "role-reported-time"
   28) "76301522"
   29) "master-link-down-time"
   30) "0"
   31) "master-link-status"
   32) "ok"
   33) "master-host"
   34) "127.0.0.1"
   35) "master-port"
   36) "6377"
   37) "slave-priority"
   38) "100"
   39) "slave-repl-offset"
   40) "10823208"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>相关语法：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">sentinel replicas mymaster<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>或</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">sentinel slaves master-name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="查询-Sentinel-集群中的其他-Sentinel-信息"><a href="#查询-Sentinel-集群中的其他-Sentinel-信息" class="headerlink" title="查询 Sentinel 集群中的其他 Sentinel 信息"></a>查询 Sentinel 集群中的其他 Sentinel 信息</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:26379&gt; sentinel sentinels mymaster
1)  1) "name"
    2) "6455f2f74614a71ce0a63398b2e48d6cd1cf0d06"
    3) "ip"
    4) "127.0.0.1"
    5) "port"
    6) "26377"
    7) "runid"
    8) "6455f2f74614a71ce0a63398b2e48d6cd1cf0d06"
    9) "flags"
   10) "sentinel"
   11) "link-pending-commands"
   12) "0"
   13) "link-refcount"
   14) "1"
   15) "last-ping-sent"
   16) "0"
   17) "last-ok-ping-reply"
   18) "571"
   19) "last-ping-reply"
   20) "571"
   21) "down-after-milliseconds"
   22) "30000"
   23) "last-hello-message"
   24) "1043"
   25) "voted-leader"
   26) "?"
   27) "voted-leader-epoch"
   28) "0"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>相关语法：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">sentinel sentinels master-name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="检查可用-Sentinel-的数量"><a href="#检查可用-Sentinel-的数量" class="headerlink" title="检查可用 Sentinel 的数量"></a>检查可用 Sentinel 的数量</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:26379&gt; sentinel ckquorum mymaster
OK 2 usable Sentinels. Quorum and failover authorization can be reached<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>有两个可用的 Sentinel，可用完成仲裁和故障转移授权。</p>
<p>相关语法：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">sentinel ckquorum master-name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="强制故障转移"><a href="#强制故障转移" class="headerlink" title="强制故障转移"></a>强制故障转移</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:26379&gt; sentinel failover mymaster
OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>相关语法：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">sentinel failover master-name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="在线修改配置信息"><a href="#在线修改配置信息" class="headerlink" title="在线修改配置信息"></a>在线修改配置信息</h3><p>在 Redis 2.8.4 之前如果需要修改 Sentinel 的配置文件，例如添加或删除一个监视主节点，需要先停止 Sentinel 服务，再找到配置文件修改之后，重新启动 Sentinel 才行，这样就给我们带来了很多的不便，尤其是生产环境的 Sentinel，正常情况下如果是非致命问题我们是不能手动停止服务的，幸运的是 Redis 2.8.4 之后，我们可以不停机在线修改配置文件了，修改命令有以下几个。</p>
<h4 id="增加监视主节点"><a href="#增加监视主节点" class="headerlink" title="增加监视主节点"></a>增加监视主节点</h4><p>使用 <code>sentinel monitor mymaster IP Port Quorum</code> 命令来添加监视主节点，如下命令所示：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:26379&gt; sentinel monitor mymaster 127.0.0.1 6379 2
OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>OK 表示添加监视主节点成功。</p>
<h4 id="移除主节点的监视"><a href="#移除主节点的监视" class="headerlink" title="移除主节点的监视"></a>移除主节点的监视</h4><p>使用 <code>sentinel remove master-name</code> 命令来实现移除主节点的监视，如下命令所示：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:26379&gt; sentinel remove mymaster
OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>OK 表示操作成功。</p>
<h4 id="修改-quorum-参数"><a href="#修改-quorum-参数" class="headerlink" title="修改 quorum 参数"></a>修改 quorum 参数</h4><p>使用 <code>sentinel set master-name quorum n</code> 来修改 quorum 参数，如下命令所示：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">127.0.0.1:26379&gt; sentinel set mymaster quorum 1
OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>quorum 参数用来表示确认主节点下线的 Sentinel 数量，如果 quorum 设置为 1 表示只要有一台 Sentinel 确认主观下线后，这个主节点就客观（真正地）下线了。</p>
<blockquote>
<p>小贴士：以上所有对配置文件的修改，都会自动被刷新到物理配置文件 sentinel.conf 中。</p>
</blockquote>
<h2 id="39-实战：Redis-集群模式（上）"><a href="#39-实战：Redis-集群模式（上）" class="headerlink" title="39 实战：Redis 集群模式（上）"></a>39 实战：Redis 集群模式（上）</h2><p>Redis Cluster 是 Redis 3.0 版本推出的 Redis 集群方案，它将数据分布在不同的服务区上，以此来降低系统对单主节点的依赖，并且可以大大的提高 Redis 服务的读写性能。</p>
<p>Redis 将所有的数据分为 16384 个 slots（槽），每个节点负责其中的一部分槽位，当有 Redis 客户端连接集群时，会得到一份集群的槽位配置信息，这样它就可以直接把请求命令发送给对应的节点进行处理。</p>
<p>Redis Cluster 是无代理模式去中心化的运行模式，客户端发送的绝大数命令会直接交给相关节点执行，这样大部分情况请求命令无需转发，或仅转发一次的情况下就能完成请求与响应，所以集群单个节点的性能与单机 Redis 服务器的性能是非常接近的，因此在理论情况下，当水平扩展一倍的主节点就相当于请求处理的性能也提高了一倍，所以 Redis Cluster 的性能是非常高的。</p>
<p>Redis Cluster 架构图如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/RedisCluster架构图.png" alt="RedisCluster架构图"></p>
<h3 id="搭建-Redis-Cluster"><a href="#搭建-Redis-Cluster" class="headerlink" title="搭建 Redis Cluster"></a>搭建 Redis Cluster</h3><p>Redis Cluster 的搭建方式有两种，一种是使用 Redis 源码中提供的 create-cluster 工具快速的搭建 Redis 集群环境，另一种是配置文件的方式手动创建 Redis 集群环境。</p>
<h4 id="快速搭建-Redis-Cluster"><a href="#快速搭建-Redis-Cluster" class="headerlink" title="快速搭建 Redis Cluster"></a>快速搭建 Redis Cluster</h4><p>create-cluster 工具在 utils/create-cluster 目录下，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/create-cluster工具.png" alt="create-cluster工具"></p>
<p>使用命令 <code>./create-cluster start</code> 就可以急速创建一个 Redis 集群，执行如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./create-cluster start <span class="token comment"># 创建集群</span>
Starting <span class="token number">30001</span>
Starting <span class="token number">30002</span>
Starting <span class="token number">30003</span>
Starting <span class="token number">30004</span>
Starting <span class="token number">30005</span>
Starting <span class="token number">30006</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来我们需要把以上创建的 6 个节点通过 create 命令组成一个集群，执行如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>@iZ2ze0nc5n41zomzyqtksmZ:create-cluster<span class="token punctuation">]</span>$ ./create-cluster create <span class="token comment"># 组建集群</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> Performing <span class="token builtin class-name">hash</span> slots allocation on <span class="token number">6</span> nodes<span class="token punctuation">..</span>.
Master<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> -<span class="token operator">&gt;</span> Slots <span class="token number">0</span> - <span class="token number">5460</span>
Master<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> -<span class="token operator">&gt;</span> Slots <span class="token number">5461</span> - <span class="token number">10922</span>
Master<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> -<span class="token operator">&gt;</span> Slots <span class="token number">10923</span> - <span class="token number">16383</span>
Adding replica <span class="token number">127.0</span>.0.1:30005 to <span class="token number">127.0</span>.0.1:30001
Adding replica <span class="token number">127.0</span>.0.1:30006 to <span class="token number">127.0</span>.0.1:30002
Adding replica <span class="token number">127.0</span>.0.1:30004 to <span class="token number">127.0</span>.0.1:30003
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> Trying to optimize slaves allocation <span class="token keyword">for</span> anti-affinity
<span class="token punctuation">[</span>WARNING<span class="token punctuation">]</span> Some slaves are <span class="token keyword">in</span> the same <span class="token function">host</span> as their master
M: 445f2a86fe36d397613839d8cc1ae6702c976593 <span class="token number">127.0</span>.0.1:30001
   slots:<span class="token punctuation">[</span><span class="token number">0</span>-5460<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">5461</span> slots<span class="token punctuation">)</span> master
M: 63bb14023c0bf58926738cbf857ea304bff8eb50 <span class="token number">127.0</span>.0.1:30002
   slots:<span class="token punctuation">[</span><span class="token number">5461</span>-10922<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">5462</span> slots<span class="token punctuation">)</span> master
M: 864d4dfe32e3e0b81a64cec8b393bbd26a65cbcc <span class="token number">127.0</span>.0.1:30003
   slots:<span class="token punctuation">[</span><span class="token number">10923</span>-16383<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">5461</span> slots<span class="token punctuation">)</span> master
S: 64828ab44566fc5ad656e831fd33de87be1387a0 <span class="token number">127.0</span>.0.1:30004
   replicates 445f2a86fe36d397613839d8cc1ae6702c976593
S: 0b17b00542706343583aa73149ec5ff63419f140 <span class="token number">127.0</span>.0.1:30005
   replicates 63bb14023c0bf58926738cbf857ea304bff8eb50
S: e35f06ca9b700073472d72001a39ea4dfcb541cd <span class="token number">127.0</span>.0.1:30006
   replicates 864d4dfe32e3e0b81a64cec8b393bbd26a65cbcc
Can I <span class="token builtin class-name">set</span> the above configuration? <span class="token punctuation">(</span>type <span class="token string">'yes'</span> to accept<span class="token punctuation">)</span>: <span class="token function">yes</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> Nodes configuration updated
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> Assign a different config epoch to each node
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> Sending CLUSTER MEET messages to <span class="token function">join</span> the cluster
Waiting <span class="token keyword">for</span> the cluster to <span class="token function">join</span>
<span class="token builtin class-name">.</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> Performing Cluster Check <span class="token punctuation">(</span>using node <span class="token number">127.0</span>.0.1:30001<span class="token punctuation">)</span>
M: 445f2a86fe36d397613839d8cc1ae6702c976593 <span class="token number">127.0</span>.0.1:30001
   slots:<span class="token punctuation">[</span><span class="token number">0</span>-5460<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">5461</span> slots<span class="token punctuation">)</span> master
   <span class="token number">1</span> additional replica<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
M: 864d4dfe32e3e0b81a64cec8b393bbd26a65cbcc <span class="token number">127.0</span>.0.1:30003
   slots:<span class="token punctuation">[</span><span class="token number">10923</span>-16383<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">5461</span> slots<span class="token punctuation">)</span> master
   <span class="token number">1</span> additional replica<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
S: e35f06ca9b700073472d72001a39ea4dfcb541cd <span class="token number">127.0</span>.0.1:30006
   slots: <span class="token punctuation">(</span><span class="token number">0</span> slots<span class="token punctuation">)</span> slave
   replicates 864d4dfe32e3e0b81a64cec8b393bbd26a65cbcc
S: 0b17b00542706343583aa73149ec5ff63419f140 <span class="token number">127.0</span>.0.1:30005
   slots: <span class="token punctuation">(</span><span class="token number">0</span> slots<span class="token punctuation">)</span> slave
   replicates 63bb14023c0bf58926738cbf857ea304bff8eb50
M: 63bb14023c0bf58926738cbf857ea304bff8eb50 <span class="token number">127.0</span>.0.1:30002
   slots:<span class="token punctuation">[</span><span class="token number">5461</span>-10922<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">5462</span> slots<span class="token punctuation">)</span> master
   <span class="token number">1</span> additional replica<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
S: 64828ab44566fc5ad656e831fd33de87be1387a0 <span class="token number">127.0</span>.0.1:30004
   slots: <span class="token punctuation">(</span><span class="token number">0</span> slots<span class="token punctuation">)</span> slave
   replicates 445f2a86fe36d397613839d8cc1ae6702c976593
<span class="token punctuation">[</span>OK<span class="token punctuation">]</span> All nodes agree about slots configuration.
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> Check <span class="token keyword">for</span> <span class="token function">open</span> slots<span class="token punctuation">..</span>.
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> Check slots coverage<span class="token punctuation">..</span>.
<span class="token punctuation">[</span>OK<span class="token punctuation">]</span> All <span class="token number">16384</span> slots covered.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在执行的过程中会询问你是否通过把 30001、30002、30003 作为主节点，把 30004、30005、30006 作为它们的从节点，输入 yes 后会执行完成。</p>
<p>我们可以先使用 redis-cli 连接到集群，命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ redis-cli -c -p <span class="token number">30001</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在使用 nodes 命令来查看集群的节点信息，命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:3000<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span> cluster nodes
864d4dfe32e3e0b81a64cec8b393bbd26a65cbcc <span class="token number">127.0</span>.0.1:30003@40003 master - <span class="token number">0</span> <span class="token number">1585125835078</span> <span class="token number">3</span> connected <span class="token number">10923</span>-16383
e35f06ca9b700073472d72001a39ea4dfcb541cd <span class="token number">127.0</span>.0.1:30006@40006 slave 864d4dfe32e3e0b81a64cec8b393bbd26a65cbcc <span class="token number">0</span> <span class="token number">1585125835078</span> <span class="token number">6</span> connected
0b17b00542706343583aa73149ec5ff63419f140 <span class="token number">127.0</span>.0.1:30005@40005 slave 63bb14023c0bf58926738cbf857ea304bff8eb50 <span class="token number">0</span> <span class="token number">1585125835078</span> <span class="token number">5</span> connected
63bb14023c0bf58926738cbf857ea304bff8eb50 <span class="token number">127.0</span>.0.1:30002@40002 master - <span class="token number">0</span> <span class="token number">1585125834175</span> <span class="token number">2</span> connected <span class="token number">5461</span>-10922
445f2a86fe36d397613839d8cc1ae6702c976593 <span class="token number">127.0</span>.0.1:30001@40001 myself,master - <span class="token number">0</span> <span class="token number">1585125835000</span> <span class="token number">1</span> connected <span class="token number">0</span>-5460
64828ab44566fc5ad656e831fd33de87be1387a0 <span class="token number">127.0</span>.0.1:30004@40004 slave 445f2a86fe36d397613839d8cc1ae6702c976593 <span class="token number">0</span> <span class="token number">1585125835000</span> <span class="token number">4</span> connected<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出 30001、30002、30003 都为主节点，30001 对应的槽位是 0~5460，30002 对应的槽位是 5461~10922，30003 对应的槽位是 10923~16383，总共有槽位 16384 个（0~16383）。</p>
<p>create-cluster 搭建的方式虽然速度很快，但是该方式搭建的集群主从节点数量固定以及槽位分配模式固定，并且安装在同一台服务器上，所以只能用于测试环境。</p>
<p>我们测试完成之后，可以使用以下命令，关闭并清理集群：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./create-cluster stop <span class="token comment"># 关闭集群</span>
Stopping <span class="token number">30001</span>
Stopping <span class="token number">30002</span>
Stopping <span class="token number">30003</span>
Stopping <span class="token number">30004</span>
Stopping <span class="token number">30005</span>
Stopping <span class="token number">30006</span>
$ ./create-cluster clean <span class="token comment"># 清理集群</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="手动搭建-Redis-Cluster"><a href="#手动搭建-Redis-Cluster" class="headerlink" title="手动搭建 Redis Cluster"></a>手动搭建 Redis Cluster</h4><p>由于 create-cluster 本身的限制，在实际生产环境中我们需要使用手动添加配置的方式搭建 Redis 集群，为此我们先要把 Redis 安装包复制到 node1 到 node6 文件中，因为我们要安装 6 个节点，3 主 3 从。</p>
<h5 id="1-设置配置文件"><a href="#1-设置配置文件" class="headerlink" title="1. 设置配置文件"></a>1. 设置配置文件</h5><p>我们需要修改每个节点内的 redis.conf 文件，设置 <code>cluster-enabled yes</code> 表示开启集群模式，并且修改各自的端口，我们继续使用 30001 到 30006，通过 port 3000X 设置。</p>
<h5 id="2-启动各个节点"><a href="#2-启动各个节点" class="headerlink" title="2. 启动各个节点"></a>2. 启动各个节点</h5><p>redis.conf 配置好之后，我们就可以启动所有的节点了，命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /usr/local/soft/mycluster/node1 
./src/redis-server redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h5 id="3-创建集群并分配槽位"><a href="#3-创建集群并分配槽位" class="headerlink" title="3. 创建集群并分配槽位"></a>3. 创建集群并分配槽位</h5><p>之前我们已经启动了 6 个节点，但这些节点都在各自的集群之内并未互联互通，因此接下来我们需要把这些节点串连成一个集群，并为它们指定对应的槽位，执行命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">redis-cli --cluster create <span class="token number">127.0</span>.0.1:30001 <span class="token number">127.0</span>.0.1:30002 <span class="token number">127.0</span>.0.1:30003 <span class="token number">127.0</span>.0.1:30004 <span class="token number">127.0</span>.0.1:30005 <span class="token number">127.0</span>.0.1:30006 --cluster-replicas <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>其中 create 后面跟多个节点，表示把这些节点作为整个集群的节点，而 cluster-replicas 表示给集群中的主节点指定从节点的数量，1 表示为每个主节点设置一个从节点。</p>
<p>在执行了 create 命令之后，系统会为我们指定节点的角色和槽位分配计划，如下所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> Performing <span class="token builtin class-name">hash</span> slots allocation on <span class="token number">6</span> nodes<span class="token punctuation">..</span>.
Master<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> -<span class="token operator">&gt;</span> Slots <span class="token number">0</span> - <span class="token number">5460</span>
Master<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> -<span class="token operator">&gt;</span> Slots <span class="token number">5461</span> - <span class="token number">10922</span>
Master<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> -<span class="token operator">&gt;</span> Slots <span class="token number">10923</span> - <span class="token number">16383</span>
Adding replica <span class="token number">127.0</span>.0.1:30005 to <span class="token number">127.0</span>.0.1:30001
Adding replica <span class="token number">127.0</span>.0.1:30006 to <span class="token number">127.0</span>.0.1:30002
Adding replica <span class="token number">127.0</span>.0.1:30004 to <span class="token number">127.0</span>.0.1:30003
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> Trying to optimize slaves allocation <span class="token keyword">for</span> anti-affinity
<span class="token punctuation">[</span>WARNING<span class="token punctuation">]</span> Some slaves are <span class="token keyword">in</span> the same <span class="token function">host</span> as their master
M: bdd1c913f87eacbdfeabc71befd0d06c913c891c <span class="token number">127.0</span>.0.1:30001
   slots:<span class="token punctuation">[</span><span class="token number">0</span>-5460<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">5461</span> slots<span class="token punctuation">)</span> master
M: bdd1c913f87eacbdfeabc71befd0d06c913c891c <span class="token number">127.0</span>.0.1:30002
   slots:<span class="token punctuation">[</span><span class="token number">5461</span>-10922<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">5462</span> slots<span class="token punctuation">)</span> master
M: bdd1c913f87eacbdfeabc71befd0d06c913c891c <span class="token number">127.0</span>.0.1:30003
   slots:<span class="token punctuation">[</span><span class="token number">10923</span>-16383<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">5461</span> slots<span class="token punctuation">)</span> master
S: bdd1c913f87eacbdfeabc71befd0d06c913c891c <span class="token number">127.0</span>.0.1:30004
   replicates bdd1c913f87eacbdfeabc71befd0d06c913c891c
S: bdd1c913f87eacbdfeabc71befd0d06c913c891c <span class="token number">127.0</span>.0.1:30005
   replicates bdd1c913f87eacbdfeabc71befd0d06c913c891c
S: bdd1c913f87eacbdfeabc71befd0d06c913c891c <span class="token number">127.0</span>.0.1:30006
   replicates bdd1c913f87eacbdfeabc71befd0d06c913c891c
Can I <span class="token builtin class-name">set</span> the above configuration? <span class="token punctuation">(</span>type <span class="token string">'yes'</span> to accept<span class="token punctuation">)</span>: <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从以上信息可以看出，Redis 打算把 30001、30002、30003 设置为主节点，并为他们分配的槽位，30001 对应的槽位是 0~5460，30002 对应的槽位是 5461~10922，30003 对应的槽位是 10923~16383，并且把 30005 设置为 30001 的从节点、30006 设置为 30002 的从节点、30004 设置为 30003 的从节点，我们只需要输入 yes 即可确认并执行分配，如下所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Can I <span class="token builtin class-name">set</span> the above configuration? <span class="token punctuation">(</span>type <span class="token string">'yes'</span> to accept<span class="token punctuation">)</span>: <span class="token function">yes</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> Nodes configuration updated
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> Assign a different config epoch to each node
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> Sending CLUSTER MEET messages to <span class="token function">join</span> the cluster
Waiting <span class="token keyword">for</span> the cluster to <span class="token function">join</span>
<span class="token punctuation">..</span><span class="token punctuation">..</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> Performing Cluster Check <span class="token punctuation">(</span>using node <span class="token number">127.0</span>.0.1:30001<span class="token punctuation">)</span>
M: 887397e6fefe8ad19ea7569e99f5eb8a803e3785 <span class="token number">127.0</span>.0.1:30001
   slots:<span class="token punctuation">[</span><span class="token number">0</span>-5460<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">5461</span> slots<span class="token punctuation">)</span> master
   <span class="token number">1</span> additional replica<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
S: abec9f98f9c01208ba77346959bc35e8e274b6a3 <span class="token number">127.0</span>.0.1:30005
   slots: <span class="token punctuation">(</span><span class="token number">0</span> slots<span class="token punctuation">)</span> slave
   replicates 887397e6fefe8ad19ea7569e99f5eb8a803e3785
S: 1a324d828430f61be6eaca7eb2a90728dd5049de <span class="token number">127.0</span>.0.1:30004
   slots: <span class="token punctuation">(</span><span class="token number">0</span> slots<span class="token punctuation">)</span> slave
   replicates f5958382af41d4e1f5b0217c1413fe19f390b55f
S: dc0702625743c48c75ea935c87813c4060547cef <span class="token number">127.0</span>.0.1:30006
   slots: <span class="token punctuation">(</span><span class="token number">0</span> slots<span class="token punctuation">)</span> slave
   replicates 3da35c40c43b457a113b539259f17e7ed616d13d
M: 3da35c40c43b457a113b539259f17e7ed616d13d <span class="token number">127.0</span>.0.1:30002
   slots:<span class="token punctuation">[</span><span class="token number">5461</span>-10922<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">5462</span> slots<span class="token punctuation">)</span> master
   <span class="token number">1</span> additional replica<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
M: f5958382af41d4e1f5b0217c1413fe19f390b55f <span class="token number">127.0</span>.0.1:30003
   slots:<span class="token punctuation">[</span><span class="token number">10923</span>-16383<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">5461</span> slots<span class="token punctuation">)</span> master
   <span class="token number">1</span> additional replica<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token punctuation">[</span>OK<span class="token punctuation">]</span> All nodes agree about slots configuration.
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> Check <span class="token keyword">for</span> <span class="token function">open</span> slots<span class="token punctuation">..</span>.
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> Check slots coverage<span class="token punctuation">..</span>.
<span class="token punctuation">[</span>OK<span class="token punctuation">]</span> All <span class="token number">16384</span> slots covered.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>显示 OK 表示整个集群就已经成功启动了。</p>
<p>接下来，我们使用 redis-cli 连接并测试一下集群的运行状态，代码如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ redis-cli -c -p <span class="token number">30001</span> <span class="token comment"># 连接到集群</span>
<span class="token number">127.0</span>.0.1:3000<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span> cluster info <span class="token comment"># 查看集群信息</span>
cluster_state:ok <span class="token comment"># 状态正常</span>
cluster_slots_assigned:16384 <span class="token comment"># 槽位数</span>
cluster_slots_ok:16384 <span class="token comment"># 正常的槽位数</span>
cluster_slots_pfail:0 
cluster_slots_fail:0
cluster_known_nodes:6 <span class="token comment"># 集群的节点数</span>
cluster_size:3 <span class="token comment"># 集群主节点数</span>
cluster_current_epoch:6
cluster_my_epoch:1
cluster_stats_messages_ping_sent:130
cluster_stats_messages_pong_sent:127
cluster_stats_messages_sent:257
cluster_stats_messages_ping_received:122
cluster_stats_messages_pong_received:130
cluster_stats_messages_meet_received:5
cluster_stats_messages_received:257<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>相关字段的说明已经标识在上述的代码中了，这里就不再赘述。</p>
<h3 id="动态增删节点"><a href="#动态增删节点" class="headerlink" title="动态增删节点"></a>动态增删节点</h3><p>某些情况下，我们需要根据实际的业务情况，对已经在运行的集群进行动态的添加或删除节点，那我们就需要进行以下操作。</p>
<h4 id="增加主节点"><a href="#增加主节点" class="headerlink" title="增加主节点"></a>增加主节点</h4><h5 id="添加方式一：cluster-meet"><a href="#添加方式一：cluster-meet" class="headerlink" title="添加方式一：cluster meet"></a>添加方式一：cluster meet</h5><p>使用 <code>cluster meet ip:port</code> 命令就可以把一个节点加入到集群中，执行命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:3000<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span> cluster meet <span class="token number">127.0</span>.0.1 <span class="token number">30007</span>
OK
<span class="token number">127.0</span>.0.1:3000<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span> cluster nodes
dc0702625743c48c75ea935c87813c4060547cef <span class="token number">127.0</span>.0.1:30006@40006 slave 3da35c40c43b457a113b539259f17e7ed616d13d <span class="token number">0</span> <span class="token number">1585142916000</span> <span class="token number">6</span> connected
df0190853a53d8e078205d0e2fa56046f20362a7 <span class="token number">127.0</span>.0.1:30007@40007 master - <span class="token number">0</span> <span class="token number">1585142917740</span> <span class="token number">0</span> connected
f5958382af41d4e1f5b0217c1413fe19f390b55f <span class="token number">127.0</span>.0.1:30003@40003 master - <span class="token number">0</span> <span class="token number">1585142916738</span> <span class="token number">3</span> connected <span class="token number">10923</span>-16383
3da35c40c43b457a113b539259f17e7ed616d13d <span class="token number">127.0</span>.0.1:30002@40002 master - <span class="token number">0</span> <span class="token number">1585142913000</span> <span class="token number">2</span> connected <span class="token number">5461</span>-10922
abec9f98f9c01208ba77346959bc35e8e274b6a3 <span class="token number">127.0</span>.0.1:30005@40005 slave 887397e6fefe8ad19ea7569e99f5eb8a803e3785 <span class="token number">0</span> <span class="token number">1585142917000</span> <span class="token number">5</span> connected
887397e6fefe8ad19ea7569e99f5eb8a803e3785 <span class="token number">127.0</span>.0.1:30001@40001 myself,master - <span class="token number">0</span> <span class="token number">1585142915000</span> <span class="token number">1</span> connected <span class="token number">0</span>-5460
1a324d828430f61be6eaca7eb2a90728dd5049de <span class="token number">127.0</span>.0.1:30004@40004 slave f5958382af41d4e1f5b0217c1413fe19f390b55f <span class="token number">0</span> <span class="token number">1585142916000</span> <span class="token number">4</span> connected<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出端口为 30007 的节点并加入到集群中，并设置成了主节点。</p>
<h5 id="添加方式二：add-node"><a href="#添加方式二：add-node" class="headerlink" title="添加方式二：add-node"></a>添加方式二：add-node</h5><p>使用 <code>redis-cli --cluster add-node 添加节点ip:port 集群某节点ip:port</code> 也可以把一个节点添加到集群中，执行命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ redis-cli --cluster add-node <span class="token number">127.0</span>.0.1:30008 <span class="token number">127.0</span>.0.1:30001
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> Adding node <span class="token number">127.0</span>.0.1:30008 to cluster <span class="token number">127.0</span>.0.1:30001
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> Performing Cluster Check <span class="token punctuation">(</span>using node <span class="token number">127.0</span>.0.1:30001<span class="token punctuation">)</span>
M: 887397e6fefe8ad19ea7569e99f5eb8a803e3785 <span class="token number">127.0</span>.0.1:30001
   slots:<span class="token punctuation">[</span><span class="token number">0</span>-5460<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">5461</span> slots<span class="token punctuation">)</span> master
   <span class="token number">1</span> additional replica<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
S: dc0702625743c48c75ea935c87813c4060547cef <span class="token number">127.0</span>.0.1:30006
   slots: <span class="token punctuation">(</span><span class="token number">0</span> slots<span class="token punctuation">)</span> slave
   replicates 3da35c40c43b457a113b539259f17e7ed616d13d
M: df0190853a53d8e078205d0e2fa56046f20362a7 <span class="token number">127.0</span>.0.1:30007
   slots: <span class="token punctuation">(</span><span class="token number">0</span> slots<span class="token punctuation">)</span> master
M: f5958382af41d4e1f5b0217c1413fe19f390b55f <span class="token number">127.0</span>.0.1:30003
   slots:<span class="token punctuation">[</span><span class="token number">10923</span>-16383<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">5461</span> slots<span class="token punctuation">)</span> master
   <span class="token number">1</span> additional replica<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
M: 1d09d26fd755298709efe60278457eaa09cefc26 <span class="token number">127.0</span>.0.1:30008
   slots: <span class="token punctuation">(</span><span class="token number">0</span> slots<span class="token punctuation">)</span> master
M: 3da35c40c43b457a113b539259f17e7ed616d13d <span class="token number">127.0</span>.0.1:30002
   slots:<span class="token punctuation">[</span><span class="token number">5461</span>-10922<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">5462</span> slots<span class="token punctuation">)</span> master
   <span class="token number">1</span> additional replica<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
S: abec9f98f9c01208ba77346959bc35e8e274b6a3 <span class="token number">127.0</span>.0.1:30005
   slots: <span class="token punctuation">(</span><span class="token number">0</span> slots<span class="token punctuation">)</span> slave
   replicates 887397e6fefe8ad19ea7569e99f5eb8a803e3785
S: 1a324d828430f61be6eaca7eb2a90728dd5049de <span class="token number">127.0</span>.0.1:30004
   slots: <span class="token punctuation">(</span><span class="token number">0</span> slots<span class="token punctuation">)</span> slave
   replicates f5958382af41d4e1f5b0217c1413fe19f390b55f
<span class="token punctuation">[</span>OK<span class="token punctuation">]</span> All nodes agree about slots configuration.
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> Check <span class="token keyword">for</span> <span class="token function">open</span> slots<span class="token punctuation">..</span>.
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> Check slots coverage<span class="token punctuation">..</span>.
<span class="token punctuation">[</span>OK<span class="token punctuation">]</span> All <span class="token number">16384</span> slots covered.
<span class="token punctuation">[</span>ERR<span class="token punctuation">]</span> Node <span class="token number">127.0</span>.0.1:30008 is not empty. Either the node already knows other nodes <span class="token punctuation">(</span>check with CLUSTER NODES<span class="token punctuation">)</span> or contains some key <span class="token keyword">in</span> database <span class="token number">0</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从以上结果可以看出 30008 节点也被设置成了主节点。</p>
<h4 id="添加从节点"><a href="#添加从节点" class="headerlink" title="添加从节点"></a>添加从节点</h4><p>使用 cluster replicate nodeId 命令就可以把当前节点设置为目标节点的从节点，执行命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:3000<span class="token operator"><span class="token file-descriptor important">8</span>&gt;</span> cluster replicate df0190853a53d8e078205d0e2fa56046f20362a7
OK
<span class="token number">127.0</span>.0.1:3000<span class="token operator"><span class="token file-descriptor important">8</span>&gt;</span> cluster nodes
df0190853a53d8e078205d0e2fa56046f20362a7 <span class="token number">127.0</span>.0.1:30007@40007 master - <span class="token number">0</span> <span class="token number">1585147827000</span> <span class="token number">0</span> connected
abec9f98f9c01208ba77346959bc35e8e274b6a3 <span class="token number">127.0</span>.0.1:30005@40005 slave 887397e6fefe8ad19ea7569e99f5eb8a803e3785 <span class="token number">0</span> <span class="token number">1585147827000</span> <span class="token number">1</span> connected
1a324d828430f61be6eaca7eb2a90728dd5049de <span class="token number">127.0</span>.0.1:30004@40004 slave f5958382af41d4e1f5b0217c1413fe19f390b55f <span class="token number">0</span> <span class="token number">1585147823000</span> <span class="token number">3</span> connected
887397e6fefe8ad19ea7569e99f5eb8a803e3785 <span class="token number">127.0</span>.0.1:30001@40001 master - <span class="token number">0</span> <span class="token number">1585147826000</span> <span class="token number">1</span> connected <span class="token number">0</span>-5460
dc0702625743c48c75ea935c87813c4060547cef <span class="token number">127.0</span>.0.1:30006@40006 slave 3da35c40c43b457a113b539259f17e7ed616d13d <span class="token number">0</span> <span class="token number">1585147826930</span> <span class="token number">2</span> connected
f5958382af41d4e1f5b0217c1413fe19f390b55f <span class="token number">127.0</span>.0.1:30003@40003 master - <span class="token number">0</span> <span class="token number">1585147826000</span> <span class="token number">3</span> connected <span class="token number">10923</span>-16383
1d09d26fd755298709efe60278457eaa09cefc26 <span class="token number">127.0</span>.0.1:30008@40008 myself,slave df0190853a53d8e078205d0e2fa56046f20362a7 <span class="token number">0</span> <span class="token number">1585147823000</span> <span class="token number">7</span> connected
3da35c40c43b457a113b539259f17e7ed616d13d <span class="token number">127.0</span>.0.1:30002@40002 master - <span class="token number">0</span> <span class="token number">1585147827933</span> <span class="token number">2</span> connected <span class="token number">5461</span>-10922<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出 30008 已经变为 30007 的从节点了。</p>
<h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p>使用 cluster forget nodeId 命令就可以把一个节点从集群中移除。</p>
<p>此命令和 meet 命令不同的时，删除节点需要把使用节点的 Id 进行删除，可以通过 cluster nodes 命令查看所有节点的 Id 信息，其中每一行的最前面的 40 位字母和数组的组合就是该节点的 Id，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/集群节点ID.png" alt="集群节点ID"></p>
<p>执行命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:3000<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span> cluster forget df0190853a53d8e078205d0e2fa56046f20362a7
OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>此时我们使用 cluster nodes 命令查看集群的所有节点信息：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:3000<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span> cluster nodes
dc0702625743c48c75ea935c87813c4060547cef <span class="token number">127.0</span>.0.1:30006@40006 slave 3da35c40c43b457a113b539259f17e7ed616d13d <span class="token number">0</span> <span class="token number">1585143789940</span> <span class="token number">6</span> connected
f5958382af41d4e1f5b0217c1413fe19f390b55f <span class="token number">127.0</span>.0.1:30003@40003 master - <span class="token number">0</span> <span class="token number">1585143791000</span> <span class="token number">3</span> connected <span class="token number">10923</span>-16383
3da35c40c43b457a113b539259f17e7ed616d13d <span class="token number">127.0</span>.0.1:30002@40002 master - <span class="token number">0</span> <span class="token number">1585143789000</span> <span class="token number">2</span> connected <span class="token number">5461</span>-10922
abec9f98f9c01208ba77346959bc35e8e274b6a3 <span class="token number">127.0</span>.0.1:30005@40005 slave 887397e6fefe8ad19ea7569e99f5eb8a803e3785 <span class="token number">0</span> <span class="token number">1585143789000</span> <span class="token number">5</span> connected
887397e6fefe8ad19ea7569e99f5eb8a803e3785 <span class="token number">127.0</span>.0.1:30001@40001 myself,master - <span class="token number">0</span> <span class="token number">1585143786000</span> <span class="token number">1</span> connected <span class="token number">0</span>-5460
1a324d828430f61be6eaca7eb2a90728dd5049de <span class="token number">127.0</span>.0.1:30004@40004 slave f5958382af41d4e1f5b0217c1413fe19f390b55f <span class="token number">0</span> <span class="token number">1585143791945</span> <span class="token number">4</span> connected<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出之前的端口为 30007 的节点已经被我们成功的移除了。</p>
<h2 id="40-实战：Redis-集群模式（下）"><a href="#40-实战：Redis-集群模式（下）" class="headerlink" title="40 实战：Redis 集群模式（下）"></a>40 实战：Redis 集群模式（下）</h2><p>上篇文章我们讲了 Redis 集群的搭建与节点的动态添加和删除，我们这里再来简单的复习一下，其中 30001~30006 是我们最初搭建的集群，而 30007 和 30008 是后面动态添加的主从节点，我们使用 <code>--cluster info</code> 命令来看一下主节点和槽位的分配情况，执行代码如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ redis-cli --cluster info <span class="token number">127.0</span>.0.1:30001
<span class="token number">127.0</span>.0.1:30001 <span class="token punctuation">(</span>887397e6<span class="token punctuation">..</span>.<span class="token punctuation">)</span> -<span class="token operator">&gt;</span> <span class="token number">0</span> keys <span class="token operator">|</span> <span class="token number">5461</span> slots <span class="token operator">|</span> <span class="token number">1</span> slaves.
<span class="token number">127.0</span>.0.1:30007 <span class="token punctuation">(</span>df019085<span class="token punctuation">..</span>.<span class="token punctuation">)</span> -<span class="token operator">&gt;</span> <span class="token number">0</span> keys <span class="token operator">|</span> <span class="token number">0</span> slots <span class="token operator">|</span> <span class="token number">1</span> slaves.
<span class="token number">127.0</span>.0.1:30003 <span class="token punctuation">(</span>f5958382<span class="token punctuation">..</span>.<span class="token punctuation">)</span> -<span class="token operator">&gt;</span> <span class="token number">0</span> keys <span class="token operator">|</span> <span class="token number">5461</span> slots <span class="token operator">|</span> <span class="token number">1</span> slaves.
<span class="token number">127.0</span>.0.1:30002 <span class="token punctuation">(</span>3da35c40<span class="token punctuation">..</span>.<span class="token punctuation">)</span> -<span class="token operator">&gt;</span> <span class="token number">0</span> keys <span class="token operator">|</span> <span class="token number">5462</span> slots <span class="token operator">|</span> <span class="token number">1</span> slaves.
<span class="token punctuation">[</span>OK<span class="token punctuation">]</span> <span class="token number">0</span> keys <span class="token keyword">in</span> <span class="token number">4</span> masters.
<span class="token number">0.00</span> keys per slot on average.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出动态添加的主节点 30007 有一个从节点，但并没有分配任何槽位，这显然是不能满足我们的需求的，只添加了节点，但不处理任何数据，所以我们需要重新分片，让数据存储在所有的主节点上，这样才能发挥集群的最大作用。</p>
<h3 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h3><p>我们可以使用 reshard 命令，对槽位（slots）进行重新分配，执行命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ redis-cli --cluster reshard <span class="token number">127.0</span>.0.1:30007
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> Performing Cluster Check <span class="token punctuation">(</span>using node <span class="token number">127.0</span>.0.1:30007<span class="token punctuation">)</span>
M: df0190853a53d8e078205d0e2fa56046f20362a7 <span class="token number">127.0</span>.0.1:30007
   slots:<span class="token punctuation">[</span><span class="token number">0</span>-1332<span class="token punctuation">]</span>,<span class="token punctuation">[</span><span class="token number">5461</span>-6794<span class="token punctuation">]</span>,<span class="token punctuation">[</span><span class="token number">10923</span>-12255<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">4000</span> slots<span class="token punctuation">)</span> master
   <span class="token number">1</span> additional replica<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
S: dc0702625743c48c75ea935c87813c4060547cef <span class="token number">127.0</span>.0.1:30006
   slots: <span class="token punctuation">(</span><span class="token number">0</span> slots<span class="token punctuation">)</span> slave
   replicates 3da35c40c43b457a113b539259f17e7ed616d13d
M: 3da35c40c43b457a113b539259f17e7ed616d13d <span class="token number">127.0</span>.0.1:30002
   slots:<span class="token punctuation">[</span><span class="token number">6795</span>-10922<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">4128</span> slots<span class="token punctuation">)</span> master
   <span class="token number">1</span> additional replica<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
S: 1a324d828430f61be6eaca7eb2a90728dd5049de <span class="token number">127.0</span>.0.1:30004
   slots: <span class="token punctuation">(</span><span class="token number">0</span> slots<span class="token punctuation">)</span> slave
   replicates f5958382af41d4e1f5b0217c1413fe19f390b55f
S: 1d09d26fd755298709efe60278457eaa09cefc26 <span class="token number">127.0</span>.0.1:30008
   slots: <span class="token punctuation">(</span><span class="token number">0</span> slots<span class="token punctuation">)</span> slave
   replicates df0190853a53d8e078205d0e2fa56046f20362a7
S: abec9f98f9c01208ba77346959bc35e8e274b6a3 <span class="token number">127.0</span>.0.1:30005
   slots: <span class="token punctuation">(</span><span class="token number">0</span> slots<span class="token punctuation">)</span> slave
   replicates 887397e6fefe8ad19ea7569e99f5eb8a803e3785
M: f5958382af41d4e1f5b0217c1413fe19f390b55f <span class="token number">127.0</span>.0.1:30003
   slots:<span class="token punctuation">[</span><span class="token number">12256</span>-16383<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">4128</span> slots<span class="token punctuation">)</span> master
   <span class="token number">1</span> additional replica<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
M: 887397e6fefe8ad19ea7569e99f5eb8a803e3785 <span class="token number">127.0</span>.0.1:30001
   slots:<span class="token punctuation">[</span><span class="token number">1333</span>-5460<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">4128</span> slots<span class="token punctuation">)</span> master
   <span class="token number">1</span> additional replica<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token punctuation">[</span>OK<span class="token punctuation">]</span> All nodes agree about slots configuration.
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> Check <span class="token keyword">for</span> <span class="token function">open</span> slots<span class="token punctuation">..</span>.
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> Check slots coverage<span class="token punctuation">..</span>.
<span class="token punctuation">[</span>OK<span class="token punctuation">]</span> All <span class="token number">16384</span> slots covered.
How many slots <span class="token keyword">do</span> you want to move <span class="token punctuation">(</span>from <span class="token number">1</span> to <span class="token number">16384</span><span class="token punctuation">)</span>?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在执行的过程中，它会询问你打算移动多少个节点，取值范围是 1 到 16384，我们这里输入 4000，意思是移动 4000 个槽位到某个主节点，输入命令之后，执行效果如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">How many slots <span class="token keyword">do</span> you want to move <span class="token punctuation">(</span>from <span class="token number">1</span> to <span class="token number">16384</span><span class="token punctuation">)</span>? <span class="token number">4000</span>
What is the receiving node ID?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>接着它会询问你需要把这些槽位分配到哪个节点上，请输入节点 Id，我们把上面 30007 端口的 Id 输入进去之后，敲击回车，执行效果如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">How many slots <span class="token keyword">do</span> you want to move <span class="token punctuation">(</span>from <span class="token number">1</span> to <span class="token number">16384</span><span class="token punctuation">)</span>? <span class="token number">4000</span>
What is the receiving node ID? df0190853a53d8e078205d0e2fa56046f20362a7
Please enter all the <span class="token builtin class-name">source</span> node IDs.
  Type <span class="token string">'all'</span> to use all the nodes as <span class="token builtin class-name">source</span> nodes <span class="token keyword">for</span> the <span class="token builtin class-name">hash</span> slots.
  Type <span class="token string">'done'</span> once you entered all the <span class="token builtin class-name">source</span> nodes IDs.
Source node <span class="token comment">#1:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此时它会询问你要从那个源节点中进行转移，输入 all 命令表示从所有节点中随机抽取，执行效果如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># ......忽略其他</span>
Moving slot <span class="token number">2656</span> from 887397e6fefe8ad19ea7569e99f5eb8a803e3785
Moving slot <span class="token number">2657</span> from 887397e6fefe8ad19ea7569e99f5eb8a803e3785
Moving slot <span class="token number">2658</span> from 887397e6fefe8ad19ea7569e99f5eb8a803e3785
Moving slot <span class="token number">2659</span> from 887397e6fefe8ad19ea7569e99f5eb8a803e3785
Moving slot <span class="token number">2660</span> from 887397e6fefe8ad19ea7569e99f5eb8a803e3785
Moving slot <span class="token number">2661</span> from 887397e6fefe8ad19ea7569e99f5eb8a803e3785
Moving slot <span class="token number">2662</span> from 887397e6fefe8ad19ea7569e99f5eb8a803e3785
Moving slot <span class="token number">2663</span> from 887397e6fefe8ad19ea7569e99f5eb8a803e3785
Moving slot <span class="token number">2664</span> from 887397e6fefe8ad19ea7569e99f5eb8a803e3785
Moving slot <span class="token number">2665</span> from 887397e6fefe8ad19ea7569e99f5eb8a803e3785
Do you want to proceed with the proposed reshard plan <span class="token punctuation">(</span>yes/no<span class="token punctuation">)</span>?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此时它会把所有要转移的节点信息列举出来，让你确认，你只需要输入 yes 就开始执行转移操作了。</p>
<p>在执行完转移之后，我们使用 cluster slots 命令来查看一下槽位的相关信息，结果如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ redis-cli -c -p <span class="token number">30001</span>
<span class="token number">127.0</span>.0.1:3000<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span> cluster slots <span class="token comment"># 查看集群槽位信息</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1332</span>
   <span class="token number">3</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"127.0.0.1"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">30007</span>
      <span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"df0190853a53d8e078205d0e2fa56046f20362a7"</span>
   <span class="token number">4</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"127.0.0.1"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">30008</span>
      <span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"1d09d26fd755298709efe60278457eaa09cefc26"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">5461</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">6794</span>
   <span class="token number">3</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"127.0.0.1"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">30007</span>
      <span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"df0190853a53d8e078205d0e2fa56046f20362a7"</span>
   <span class="token number">4</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"127.0.0.1"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">30008</span>
      <span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"1d09d26fd755298709efe60278457eaa09cefc26"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">10923</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">12255</span>
   <span class="token number">3</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"127.0.0.1"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">30007</span>
      <span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"df0190853a53d8e078205d0e2fa56046f20362a7"</span>
   <span class="token number">4</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"127.0.0.1"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">30008</span>
      <span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"1d09d26fd755298709efe60278457eaa09cefc26"</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">12256</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">16383</span>
   <span class="token number">3</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"127.0.0.1"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">30003</span>
      <span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"f5958382af41d4e1f5b0217c1413fe19f390b55f"</span>
   <span class="token number">4</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"127.0.0.1"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">30004</span>
      <span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"1a324d828430f61be6eaca7eb2a90728dd5049de"</span>
<span class="token number">5</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">6795</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">10922</span>
   <span class="token number">3</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"127.0.0.1"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">30002</span>
      <span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"3da35c40c43b457a113b539259f17e7ed616d13d"</span>
   <span class="token number">4</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"127.0.0.1"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">30006</span>
      <span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"dc0702625743c48c75ea935c87813c4060547cef"</span>
<span class="token number">6</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1333</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">5460</span>
   <span class="token number">3</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"127.0.0.1"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">30001</span>
      <span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"887397e6fefe8ad19ea7569e99f5eb8a803e3785"</span>
   <span class="token number">4</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"127.0.0.1"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">30005</span>
      <span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"abec9f98f9c01208ba77346959bc35e8e274b6a3"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从结果可以看出 30007 分别从其他三个主节点中抽取了一部分槽位，作为了自己的槽位。</p>
<blockquote>
<p>注意，执行此过程中如果出现 <code>/usr/bin/env: ruby: No such file or directory</code> 错误，表明工具在执行的时候需要依赖 Ruby 环境，可使用命令 <code>yum install ruby</code> 安装 Ruby 环境即可。</p>
</blockquote>
<h3 id="槽位定位算法"><a href="#槽位定位算法" class="headerlink" title="槽位定位算法"></a>槽位定位算法</h3><p>Redis 集群总共的槽位数是 16384 个，每一个主节点负责维护一部分槽以及槽所映射的键值数据，Redis 集群默认会对要存储的 key 值使用 CRC16 算法进行 hash 得到一个整数值，然后用这个整数值对 16384 进行取模来得到具体槽位，公式为：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">slot <span class="token operator">=</span> CRC16<span class="token punctuation">(</span>key<span class="token punctuation">)</span> % <span class="token number">16383</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>在 Redis 集群负载不均衡的情况下，我们可以使用 rebalance 命令重新分配各个节点负责的槽数量，从而使得各个节点的负载压力趋于平衡，从而提高 Redis 集群的整体运行效率。</p>
<p>rebalance 命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ redis-cli --cluster rebalance <span class="token number">127.0</span>.0.1:30007<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>需要注意的是，即使输入 rebalance 命令，但它可能不会执行，当它认为没有必要进行分配时会直接退出，如下所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ redis-cli --cluster rebalance <span class="token number">127.0</span>.0.1:30007
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> Performing Cluster Check <span class="token punctuation">(</span>using node <span class="token number">127.0</span>.0.1:30007<span class="token punctuation">)</span>
<span class="token punctuation">[</span>OK<span class="token punctuation">]</span> All nodes agree about slots configuration.
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> Check <span class="token keyword">for</span> <span class="token function">open</span> slots<span class="token punctuation">..</span>.
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> Check slots coverage<span class="token punctuation">..</span>.
<span class="token punctuation">[</span>OK<span class="token punctuation">]</span> All <span class="token number">16384</span> slots covered.
*** No rebalancing needed<span class="token operator">!</span> All nodes are within the <span class="token number">2.00</span>% threshold.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h3><p>在文章的最后部分，我们来看一下 Redis 集群故障相关的知识点，这样在我们遇到一些故障问题时就不会那么慌张了，并且能为我们处理故障时提供一些帮助。</p>
<h4 id="故障发现"><a href="#故障发现" class="headerlink" title="故障发现"></a>故障发现</h4><p>故障发现里面有两个重要的概念：疑似下线（PFAIL-Possibly Fail）和确定下线（Fail）。</p>
<p>集群中的健康监测是通过定期向集群中的其他节点发送 PING 信息来确认的，如果发送 PING 消息的节点在规定时间内，没有收到返回的 PONG 消息，那么对方节点就会被标记为疑似下线。</p>
<p>一个节点发现某个节点疑似下线，它会将这条信息向整个集群广播，其它节点就会收到这个消息，并且通过 PING 的方式监测某节点是否真的下线了。如果一个节点收到某个节点疑似下线的数量超过集群数量的一半以上，就可以标记该节点为确定下线状态，然后向整个集群广播，强迫其它节点也接收该节点已经下线的事实，并立即对该失联节点进行主从切换。</p>
<p>这就是疑似下线和确认下线的概念，这个概念和哨兵模式里面的主观下线和客观下线的概念比较类似。</p>
<h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><p>当一个节点被集群标识为确认下线之后就可以执行故障转移了，故障转移的执行流程如下：</p>
<ol>
<li>从下线的主节点的所有从节点中，选择一个从节点（选择的方法详见下面”新主节点选举原则”部分）；</li>
<li>从节点会执行 SLAVEOF NO ONE 命令，关闭这个从节点的复制功能，并从从节点转变回主节点，原来同步所得的数据集不会被丢弃；</li>
<li>新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己；</li>
<li>新的主节点向集群广播一条 PONG 消息，这条 PONG 消息是让集群中的其他节点知道此节点已经由从节点变成了主节点，并且这个主节点已经接管了原本由已下线节点负责处理的槽位信息；</li>
<li>新的主节点开始处理相关的命令请求，此故障转移过程完成。</li>
</ol>
<h4 id="新主节点选举原则"><a href="#新主节点选举原则" class="headerlink" title="新主节点选举原则"></a>新主节点选举原则</h4><p>新主节点选举的方法是这样的：</p>
<ol>
<li>集群的纪元（epoch）是一个自增计数器，初始值为0；</li>
<li>而每个主节点都有一次投票的机会，主节点会把这一票投给第一个要求投票的从节点；</li>
<li>当从节点发现自己正在复制的主节点确认下线之后，就会向集群广播一条消息，要求所有有投票权的主节点给此从节点投票；</li>
<li>如果有投票权的主节点还没有给其他人投票的情况下，它会向第一个要求投票的从节点发送一条消息，表示把这一票投给这个从节点；</li>
<li>当从节点收到投票数量大于集群数量的半数以上时，这个从节点就会当选为新的主节点。</li>
</ol>
<p>到这里整个新主节点的选择就完成了。</p>
<h2 id="41-案例：Redis-问题汇总和相关解决方案"><a href="#41-案例：Redis-问题汇总和相关解决方案" class="headerlink" title="41 案例：Redis 问题汇总和相关解决方案"></a>41 案例：Redis 问题汇总和相关解决方案</h2><p>本文收集了一些 Redis 使用中经常遇到的一些问题，和与之相对应的解决方案，这些内容不但会出现在实际工作中，也是面试的高频问题，接下来一起来看。</p>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是指在短时间内，有大量缓存同时过期，导致大量的请求直接查询数据库，从而对数据库造成了巨大的压力，严重情况下可能会导致数据库宕机的情况叫做缓存雪崩。</p>
<p>我们先来看下正常情况下和缓存雪崩时程序的执行流程图，正常情况下系统的执行流程如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/正常情况程序执行流程.png" alt="正常情况程序执行流程"></p>
<p>缓存雪崩的执行流程，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/缓存雪崩的执行流程.png" alt="缓存雪崩的执行流程"></p>
<p>以上对比图可以看出缓存雪崩对系统造成的影响，那如何解决缓存雪崩的问题？</p>
<p>缓存雪崩的常用解决方案有以下几个。</p>
<h4 id="加锁排队"><a href="#加锁排队" class="headerlink" title="加锁排队"></a>加锁排队</h4><p>加锁排队可以起到缓冲的作用，防止大量的请求同时操作数据库，但它的缺点是增加了系统的响应时间，降低了系统的吞吐量，牺牲了一部分用户体验。</p>
<h4 id="随机化过期时间"><a href="#随机化过期时间" class="headerlink" title="随机化过期时间"></a>随机化过期时间</h4><p>为了避免缓存同时过期，可在设置缓存时添加随机时间，这样就可以极大的避免大量的缓存同时失效。</p>
<h4 id="设置二级缓存"><a href="#设置二级缓存" class="headerlink" title="设置二级缓存"></a>设置二级缓存</h4><p>二级缓存指的是除了 Redis 本身的缓存，再设置一层缓存，当 Redis 失效之后，先去查询二级缓存。</p>
<p>例如可以设置一个本地缓存，在 Redis 缓存失效的时候先去查询本地缓存而非查询数据库。</p>
<p>加入二级缓存之后程序执行流程，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/加入二级缓存之后程序执行流程.png" alt="加入二级缓存之后程序执行流程"></p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指查询数据库和缓存都无数据，因为数据库查询无数据，出于容错考虑，不会将结果保存到缓存中，因此每次请求都会去查询数据库，这种情况就叫做缓存穿透。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/缓存穿透执行流程.png" alt="缓存穿透执行流程"></p>
<p>其中红色路径表示缓存穿透的执行路径，可以看出缓存穿透会给数据库造成很大的压力。</p>
<p>缓存穿透的解决方案有以下几个。</p>
<h4 id="使用过滤器"><a href="#使用过滤器" class="headerlink" title="使用过滤器"></a>使用过滤器</h4><p>我们可以使用过滤器来减少对数据库的请求，例如使用我们前面章节所学的布隆过滤器，我们这里简单复习一下布隆过滤器，它的原理是将数据库的数据哈希到 bitmap 中，每次查询之前，先使用布隆过滤器过滤掉一定不存在的无效请求，从而避免了无效请求给数据库带来的查询压力。</p>
<h4 id="缓存空结果"><a href="#缓存空结果" class="headerlink" title="缓存空结果"></a>缓存空结果</h4><p>另一种方式是我们可以把每次从数据库查询的数据都保存到缓存中，为了提高前台用户的使用体验 (解决长时间内查询不到任何信息的情况)，我们可以将空结果的缓存时间设置得短一些，例如 3~5 分钟。</p>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿指的是某个热点缓存，在某一时刻恰好失效了，然后此时刚好有大量的并发请求，此时这些请求将会给数据库造成巨大的压力，这种情况就叫做缓存击穿。</p>
<p>缓存击穿的执行流程如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/缓存击穿的执行流程.png" alt="缓存击穿的执行流程"></p>
<p>它的解决方案有以下 2 个。</p>
<h4 id="加锁排队-1"><a href="#加锁排队-1" class="headerlink" title="加锁排队"></a>加锁排队</h4><p>此处理方式和缓存雪崩加锁排队的方法类似，都是在查询数据库时加锁排队，缓冲操作请求以此来减少服务器的运行压力。</p>
<h4 id="设置永不过期"><a href="#设置永不过期" class="headerlink" title="设置永不过期"></a>设置永不过期</h4><p>对于某些热点缓存，我们可以设置永不过期，这样就能保证缓存的稳定性，但需要注意在数据更改之后，要及时更新此热点缓存，不然就会造成查询结果的误差。</p>
<h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><p>首先来说，缓存预热并不是一个问题，而是使用缓存时的一个优化方案，它可以提高前台用户的使用体验。</p>
<p>缓存预热指的是在系统启动的时候，先把查询结果预存到缓存中，以便用户后面查询时可以直接从缓存中读取，以节约用户的等待时间。</p>
<p>缓存预热的执行流程，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《Redis核心原理与实战》学习笔记/缓存预热的执行流程.png" alt="缓存预热的执行流程"></p>
<p>缓存预热的实现思路有以下三种：</p>
<ol>
<li>把需要缓存的方法写在系统初始化的方法中，这样系统在启动的时候就会自动的加载数据并缓存数据；</li>
<li>把需要缓存的方法挂载到某个页面或后端接口上，手动触发缓存预热；</li>
<li>设置定时任务，定时自动进行缓存预热。</li>
</ol>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://kibazen.cn" rel="external nofollow noreferrer">Kiba Amor</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                    </span>
                <span class="reprint-info">
                    <a href="https://kibazen.cn/redis-he-xin-yuan-li-yu-shi-zhan-xue-xi-bi-ji/">https://kibazen.cn/redis-he-xin-yuan-li-yu-shi-zhan-xue-xi-bi-ji/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY-NC-ND 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://kibazen.cn" target="_blank">Kiba Amor</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Redis/">
                                    <span class="chip bg-color">Redis</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/share/css/share.min.css">
<div id="article-share">

    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/mongodb-gao-shou-ke-xue-xi-bi-ji/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/2.jpg" class="responsive-img" alt="《MongoDB高手课》学习笔记">
                        
                        <span class="card-title">《MongoDB高手课》学习笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2025-07-03
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                    学习笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                        <span class="chip bg-color">极客时间</span>
                    </a>
                    
                    <a href="/tags/MongoDB/">
                        <span class="chip bg-color">MongoDB</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/ddd-si-xiang-jie-du-ji-you-xiu-shi-jian-xue-xi-bi-ji/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/8.jpg" class="responsive-img" alt="《DDD思想解读及优秀实践》学习笔记">
                        
                        <span class="card-title">《DDD思想解读及优秀实践》学习笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2025-02-05
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                    学习笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/">
                        <span class="chip bg-color">领域驱动设计</span>
                    </a>
                    
                    <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                        <span class="chip bg-color">极客时间</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('2'),
            headingSelector: 'h2, h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2025</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">Kiba Amor</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/kibaamor" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:5093911+kibaamor@users.noreply.github.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>













    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

    
    

    

    

	
    

    

    

    
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
