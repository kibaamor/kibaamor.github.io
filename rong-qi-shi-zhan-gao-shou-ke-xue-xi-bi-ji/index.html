<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <meta name="keywords" content="《容器实战高手课》学习笔记, kiba, zen, amor, kibazen, kibaamor, 木叶, 木叶禅">
    <meta name="description" content="You are too concerned with what was and what will be">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>《容器实战高手课》学习笔记 | 木叶禅</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/css/my.css">

    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="木叶禅" type="application/atom+xml">
</head>



   <style>
    body{
       background-image: url(/medias/background.jpg);
       background-repeat:no-repeat;
       background-size:cover;
       background-attachment:fixed;
    }
</style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">木叶禅</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/zengguangxianwen/" class="waves-effect waves-light">
      
      <i class="fas fa-heart" style="zoom: 0.6;"></i>
      
      <span>增广贤文</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/leetcode/" class="waves-effect waves-light">
      
      <i class="fas fa-code" style="zoom: 0.6;"></i>
      
      <span>LeetCode</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/learn/" class="waves-effect waves-light">
      
      <i class="fas fa-book" style="zoom: 0.6;"></i>
      
      <span>学习</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tool/" class="waves-effect waves-light">
      
      <i class="fas fa-toolbox" style="zoom: 0.6;"></i>
      
      <span>工具</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories/" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags/" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about/" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">木叶禅</div>
        <div class="logo-desc">
            
            You are too concerned with what was and what will be
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/zengguangxianwen/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-heart"></i>
			
			增广贤文
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/leetcode/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-code"></i>
			
			LeetCode
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/learn/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-book"></i>
			
			学习
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tool/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-toolbox"></i>
			
			工具
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    
<script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = 'f65e070788a2647953051a7a1b70ada7fd2b3f70cd4d93c977207f5b762987d4';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/17.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">《容器实战高手课》学习笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                                <span class="chip bg-color">极客时间</span>
                            </a>
                        
                            <a href="/tags/docker/">
                                <span class="chip bg-color">docker</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                学习笔记
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-09-02
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2022-09-03
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    27.4k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    106 分
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <blockquote>
<p>课程代码： <a target="_blank" rel="noopener" href="https://github.com/chengyli/training">https://github.com/chengyli/training</a></p>
</blockquote>
<h2 id="开篇词"><a href="#开篇词" class="headerlink" title="开篇词"></a>开篇词</h2><h3 id="开篇词-一个态度两个步骤，成为容器实战高手"><a href="#开篇词-一个态度两个步骤，成为容器实战高手" class="headerlink" title="开篇词 | 一个态度两个步骤，成为容器实战高手"></a>开篇词 | 一个态度两个步骤，成为容器实战高手</h3><p><strong>我们可以结合 Linux 操作系统的主要模块，把容器的知识结构系统地串联起来，同时看到 Namespace 和 Cgroups 带来的特殊性。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《容器实战高手课》学习笔记/容器实战思维导图.jpg" alt="容器实战思维导图.jpg"></p>
<p>在这个容器课程中，每一讲里都会有一些小例子，所以需要你有 <strong>一台安装有 Linux 的机器，或者用 VirtualBox 安装一个虚拟机来跑 Linux。Linux 的版本建议是 CentOS 8 或者是 Ubuntu 20.04。</strong></p>
<p><strong>容器是一个很好的技术窗口，它可以帮助你在这个瞬息万变的计算机世界里看到后面那些”不变”的技术，只有掌握好那些”不变”的技术，你才可以更加从容地去接受技术的瞬息万变。</strong></p>
<h3 id="01-认识容器：容器的基本操作和实现原理"><a href="#01-认识容器：容器的基本操作和实现原理" class="headerlink" title="01 | 认识容器：容器的基本操作和实现原理"></a>01 | 认识容器：容器的基本操作和实现原理</h3><p>说实话，容器这东西一点都不复杂，如果你只是想用的话，那跟着Docker 官网的说明，应该十来分钟就能搞定。</p>
<p>简单来说，它就是个小工具，可以把你想跑的程序，库文件啊，配置文件都一起”打包”。</p>
<p>然后，我们在任何一个计算机的节点上，都可以使用这个打好的包。有了容器，一个命令就能把你想跑的程序跑起来，做到了 <strong>一次打包，就可以到处使用。</strong></p>
<p>今天是咱们整个课程的第一讲，我想和你来聊聊容器背后的实现机制。</p>
<p>当然，空讲原理也没什么感觉，所以我还是会先带着你启动一个容器玩玩，然后咱们再一起来探讨容器里面的两大关键技术—— Namespace 和 Cgroups。基本上理解了这两个概念，你就能彻底搞懂容器的核心原理了。</p>
<h4 id="做个镜像"><a href="#做个镜像" class="headerlink" title="做个镜像"></a>做个镜像</h4><p>话不多说，咱们就先动手玩一玩。启动容器的工具有很多，在这里我们还是使用 Docker 这个最常用的容器管理工具。</p>
<p>如果你之前根本没用过 Docker 的话，那我建议你先去 <a target="_blank" rel="noopener" href="https://docs.docker.com/">官网</a> 看看文档，一些基础的介绍我就不讲了，那些内容你随便在网上一搜就能找到。</p>
<p>安装完 Docker 之后，咱们先来用下面的命令运行一个 httpd 服务。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -d centos/httpd:latest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这命令也很简单，run 的意思就是要启动一个容器， -d 参数里 d 是 Daemon 的首字母，也就是让容器在后台运行。</p>
<p>最后一个参数 centos/httpd:latest 指定了具体要启动哪一个镜像，比如这里咱们启动的是 centos/httpd 这个镜像的 latest 版本。</p>
<p>镜像是 Docker 公司的创举，也是一个伟大的发明。你想想，在没有容器之前，你想安装 httpd 的话，会怎么做？是不是得运行一连串的命令？甚至不同的系统上操作方法也不一样？</p>
<p>但你看，有了容器之后，你只要运行一条命令就搞定了。其实所有的玄机都在这个镜像里面。</p>
<p>镜像这么神奇，那它到底是怎么一回事呢？其实，镜像就是一个特殊的文件系统，</p>
<p><strong>它提供了容器中程序执行需要的所有文件。</strong>具体来说，就是应用程序想启动，需要三类文件：相关的程序可执行文件、库文件和配置文件，这三类文件都被容器打包做好了。</p>
<p>这样，在容器运行的时候就不再依赖宿主机上的文件操作系统类型和配置了，做到了想在哪个节点上运行，就可以在哪个节点上立刻运行。</p>
<p>那么我们怎么来做一个容器镜像呢？</p>
<p>刚才的例子里，我们用的 centos/httpd:latest 这个镜像是 <strong>Docker 镜像库</strong> 里直接提供的。当然，我们也可以自己做一个提供 httpd 服务的容器镜像，这里仍然可以用 Docker 这个工具来自定义镜像。</p>
<p>Docker 为用户自己定义镜像提供了一个叫做 Dockerfile 的文件，在这个 Dockerfile 文件里，你可以设定自己镜像的创建步骤。</p>
<p>如果我们自己来做一个 httpd 的镜像也不难，举个例子，我们可以一起来写一个 Dockerfile，体会一下整个过程。用 Dockerfile build image 的 Dockerfile 和对应的目录我放在 <a target="_blank" rel="noopener" href="http://github.com/chengyli/training/tree/main/image/demo">这里</a> 了。</p>
<p>操作之前，我们首先要理解这个 Dockerfile 做了什么，其实它很简单，只有下面这 5 行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> Dockerfile
FROM centos:8.1.1911
RUN yum <span class="token function">install</span> -y httpd
COPY file1 /var/www/html/
ADD  file2.tar.gz /var/www/html/
CMD <span class="token punctuation">[</span><span class="token string">"/sbin/httpd"</span>, <span class="token string">"-D"</span>, <span class="token string">"FOREGROUND"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们看下它做了哪几件事：在一个 centos 的基准镜像上安装好 httpd 的包，然后在 httpd 提供文件服务的配置目录下，把需要对外提供的文件 file1 和 file2 拷贝过去，最后指定容器启动以后，需要自动启动的 httpd 服务。</p>
<p>有了这个镜像，我们希望容器启动后，就运行这个 httpd 服务，让用户可以下载 file1 还有 file2 这两个文件。</p>
<p>我们具体来看这个 Dockerfile 的每一行，第一个大写的词都是 Dockerfile 专门定义的指令，也就是 FROM、RUN、COPY、ADD、CMD，这些指令都很基础，所以我们不做详细解释了，你可以参考 Dockerfile 的 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/">官方文档</a> 。</p>
<p>我们写完这个 Dockerfile 之后，想要让它变成一个镜像，还需要执行一下 docker build 命令。</p>
<p>下面这个命令中 -f ./Dockerfile 指定 Dockerfile 文件，-t registry/httpd:v1 指定了生成出来的镜像名，它的格式是”name:tag”，这个镜像名也是后面启动容器需要用到的。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker build -t registry/httpd:v1 -f ./Dockerfile <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>docker build 执行成功之后，我们再运行 docker images 这个命令，就可以看到生成的镜像了。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker images
REPOSITORY  TAG   IMAGEID  CREATED   SIZE
registry/httpd  v1  c682fc3d4b9a  <span class="token number">4</span> seconds ago  277MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="启动一个容器-Container"><a href="#启动一个容器-Container" class="headerlink" title="启动一个容器 (Container)"></a>启动一个容器 (Container)</h4><p>做完一个镜像之后，你就可以用这个镜像来启动一个容器了，我们刚才做的镜像名字是 registry/httpd:v1，那么还是用 docker run 这个命令来启动容器。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -d registry/httpd:v1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>容器启动完成后，我们可以用 docker ps 命令来查看这个已经启动的容器：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker <span class="token function">ps</span>
CONTAINER ID      IMAGE        COMMAND     CREATED       STATUS        PORTS               NAMES
c5a9ff78d9c1        registry/httpd:v1   <span class="token string">"/sbin/httpd -D FORE…"</span>   <span class="token number">2</span> seconds ago       Up <span class="token number">2</span> seconds                            loving_jackson<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在前面介绍 Dockerfile 的时候，我们说过做这个镜像是用来提供 HTTP 服务的，也就是让用户可以下载 file1、file2 这两个文件。</p>
<p>那怎样来验证我们建起来的容器是不是正常工作的呢？可以通过这两步来验证：</p>
<ul>
<li>第一步，我们可以进入容器的运行空间，查看 httpd 服务是不是启动了，配置文件是不是正确的。</li>
<li>第二步，对于 HTTP 文件服务，如果我们能用 curl 命令下载文件，就可以证明这个容器提供了我们预期的 httpd 服务。</li>
</ul>
<p>我们先来做第一步验证，我们可以运行 docker exec 这个命令进入容器的运行空间，至于什么是容器的运行空间，它的标准说法是容器的命名空间（Namespace），这个概念我们等会儿再做介绍。</p>
<p>进入容器运行空间之后，我们怎么确认 httpd 的服务进程已经在容器里启动了呢？</p>
<p>我们运行下面这个 docker exec 命令，也就是执行 docker exec c5a9ff78d9c1 ps -ef ，可以看到 httpd 的服务进程正在容器的空间中运行。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker <span class="token builtin class-name">exec</span> c5a9ff78d9c1 <span class="token function">ps</span> -ef
<span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
root         <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">0</span> 01:59 ?        00:00:00 /sbin/httpd -D FOREGROUND
apache       <span class="token number">6</span>     <span class="token number">1</span>  <span class="token number">0</span> 01:59 ?        00:00:00 /sbin/httpd -D FOREGROUND
apache       <span class="token number">7</span>     <span class="token number">1</span>  <span class="token number">0</span> 01:59 ?        00:00:00 /sbin/httpd -D FOREGROUND
apache       <span class="token number">8</span>     <span class="token number">1</span>  <span class="token number">0</span> 01:59 ?        00:00:00 /sbin/httpd -D FOREGROUND
apache       <span class="token number">9</span>     <span class="token number">1</span>  <span class="token number">0</span> 01:59 ?        00:00:00 /sbin/httpd -D FOREGROUND<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里我解释一下，在这个 docker exec 后面紧跟着的 ID 表示容器的 ID，这个 ID 就是我们之前运行 docker ps 查看过那个容器，容器的 ID 值是 c5a9ff78d9c1 。在这个 ID 值的后面，就是我们要在容器空间里运行的 ps -ef 命令。</p>
<p>接下来我们再来确认一下，httpd 提供文件服务的目录中 file1 和 file2 文件是否存在。</p>
<p>我们同样可以用 docker exec 来查看一下容器的文件系统中，httpd 提供文件服务的目录 /var/www/html 是否有这两个文件。</p>
<p>很好，我们可以看到 file1、file2 这两个文件也都放在指定目录中了。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker <span class="token builtin class-name">exec</span> c5a9ff78d9c1 <span class="token function">ls</span> /var/www/html
file1
file2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>到这里我们完成了第一步的验证，进入到容器的运行空间里，验证了 httpd 服务已经启动，配置文件也是正确的。</p>
<p>那下面我们要做第二步的验证，用 curl 命令来验证是否可以从容器的 httpd 服务里下载到文件。</p>
<p>如果要访问 httpd 服务，我们就需要知道这个容器的 IP 地址。容器的网络空间也是独立的，有一个它自己的 IP。我们还是可以用 docker exec 进入到容器的网络空间，查看一下这个容器的 IP。</p>
<p>运行下面的这条 docker exec c5a9ff78d9c1 ip addr 命令，我们可以看到容器里网络接口 eth0 上配置的 IP 是 172.17.0.2 。</p>
<p>这个 IP 目前只能在容器的宿主机上访问，在别的机器上目前是不能访问的。关于容器网络的知识，我们会在后面的课程里介绍。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker <span class="token builtin class-name">exec</span> c5a9ff78d9c1 <span class="token function">ip</span> addr
<span class="token number">1</span>: lo: <span class="token operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class="token number">1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet <span class="token number">127.0</span>.0.1/8 scope <span class="token function">host</span> lo
       valid_lft forever preferred_lft forever
<span class="token number">168</span>: eth0@if169: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">1500</span> qdisc noqueue state UP group default
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid <span class="token number">0</span>
    inet <span class="token number">172.17</span>.0.2/16 brd <span class="token number">172.17</span>.255.255 scope global eth0
       valid_lft forever preferred_lft forever<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>好了，获取了 httpd 服务的 IP 地址之后，我们随便下载一个文件试试，比如选 file2。</p>
<p>我们在宿主机上运行 curl ，就可以下载这个文件了，操作如下。很好，文件下载成功了，这证明了我们这个提供 httpd 服务的容器正常运行了。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">curl</span> -L -O http://172.17.0.2/file2
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
<span class="token number">100</span>     <span class="token number">6</span>  <span class="token number">100</span>     <span class="token number">6</span>    <span class="token number">0</span>     <span class="token number">0</span>   <span class="token number">1500</span>      <span class="token number">0</span> --:--:-- --:--:-- --:--:--  <span class="token number">1500</span>

$ <span class="token function">ls</span>
file2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的步骤完成之后，我们的第二步验证，用 curl 下载 httpd 服务提供的文件也成功了。</p>
<p>好了，我们刚才自己做了容器镜像，用这个镜像启动了容器，并且用 docker exec 命令检查了容器运行空间里的进程、文件和网络设置。</p>
<p>通过这上面的这些操作练习，估计你已经初步感知到，容器的文件系统是独立的，运行的进程环境是独立的，网络的设置也是独立的。但是它们和宿主机上的文件系统，进程环境以及网络感觉都已经分开了。</p>
<p>我想和你说，这个感觉没错，的确是这样。我们刚才启动的容器，已经从宿主机环境里被分隔出来了，就像下面这张图里的描述一样。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《容器实战高手课》学习笔记/认识容器一.jpg" alt="认识容器一.jpg"></p>
<p>从用户使用的角度来看，容器和一台独立的机器或者虚拟机没有什么太大的区别，但是它和虚拟机相比，却没有各种复杂的硬件虚拟层，没有独立的 Linux 内核。</p>
<p>容器所有的进程调度，内存访问，文件的读写都直接跑在宿主机的内核之上，这是怎么做到的呢？</p>
<h4 id="容器是什么"><a href="#容器是什么" class="headerlink" title="容器是什么"></a>容器是什么</h4><p>要回答这个问题，你可以先记住这两个术语 <strong>Namespace 和 Cgroups</strong> 。如果有人问你 Linux 上的容器是什么，最简单直接的回答就是 Namesapce 和 Cgroups。Namespace 和 Cgroups 可以让程序在一个资源可控的独立（隔离）环境中运行，这个就是容器了。</p>
<p>我们现在已经发现：容器的进程、网络还有文件系统都是独立的。那问题来了，容器的独立运行环境到底是怎么创造的呢？这就要提到 Namespace 这个概念了。所以接下来，就先从我们已经有点感觉的 Namespace 开始分析。</p>
<h5 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h5><p>接着前面的例子，我们正好有了一个正在运行的容器，那我们就拿这个运行的容器来看看 Namespace 到底是什么？</p>
<p>在前面我们运行 docker exec c5a9ff78d9c1 ps -ef，看到了 5 个 httpd 进程，而且也只有这 5 个进程。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker <span class="token builtin class-name">exec</span> c5a9ff78d9c1 <span class="token function">ps</span> -ef
<span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
root         <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">0</span> 01:59 ?        00:00:00 /sbin/httpd -D FOREGROUND
apache       <span class="token number">6</span>     <span class="token number">1</span>  <span class="token number">0</span> 01:59 ?        00:00:00 /sbin/httpd -D FOREGROUND
apache       <span class="token number">7</span>     <span class="token number">1</span>  <span class="token number">0</span> 01:59 ?        00:00:00 /sbin/httpd -D FOREGROUND
apache       <span class="token number">8</span>     <span class="token number">1</span>  <span class="token number">0</span> 01:59 ?        00:00:00 /sbin/httpd -D FOREGROUND
apache       <span class="token number">9</span>     <span class="token number">1</span>  <span class="token number">0</span> 01:59 ?        00:00:00 /sbin/httpd -D FOREGROUND<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果我们不用 docker exec，直接在宿主机上运行 ps -ef，就会看到很多进程。如果我们运行一下 grep httpd ，同样可以看到这 5 个 httpd 的进程：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ps</span> -ef <span class="token operator">|</span> <span class="token function">grep</span> httpd
<span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
root     <span class="token number">20731</span> <span class="token number">20684</span>  <span class="token number">0</span> <span class="token number">18</span>:59 ?        00:00:01 /sbin/httpd -D FOREGROUND
<span class="token number">48</span>       <span class="token number">20787</span> <span class="token number">20731</span>  <span class="token number">0</span> <span class="token number">18</span>:59 ?        00:00:00 /sbin/httpd -D FOREGROUND
<span class="token number">48</span>       <span class="token number">20788</span> <span class="token number">20731</span>  <span class="token number">0</span> <span class="token number">18</span>:59 ?        00:00:06 /sbin/httpd -D FOREGROUND
<span class="token number">48</span>       <span class="token number">20789</span> <span class="token number">20731</span>  <span class="token number">0</span> <span class="token number">18</span>:59 ?        00:00:05 /sbin/httpd -D FOREGROUND
<span class="token number">48</span>       <span class="token number">20791</span> <span class="token number">20731</span>  <span class="token number">0</span> <span class="token number">18</span>:59 ?        00:00:05 /sbin/httpd -D FOREGROUN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这两组输出结果到底有什么差别呢，你可以仔细做个对比，最大的不同就是 <strong>进程的 PID 不一样</strong> 。那为什么 PID 会不同呢？或者说，运行 docker exec c5a9ff78d9c1 ps -ef 和 ps -ef 实质的区别在哪里呢？</p>
<p>如果理解了 PID 为何不同，我们就能搞清楚 Linux Namespace 的概念了，为了方便后文的讲解，我们先用下面这张图来梳理一下我们看到的 PID。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《容器实战高手课》学习笔记/认识容器二.jpg" alt="认识容器二"></p>
<p>Linux 在创建容器的时候，就会建出一个 PID Namespace，PID 其实就是进程的编号。这个 PID Namespace，就是指每建立出一个 Namespace，就会单独对进程进行 PID 编号，每个 Namespace 的 PID 编号都从 1 开始。</p>
<p>同时在这个 PID Namespace 中也只能看到 Namespace 中的进程，而且看不到其他 Namespace 里的进程。</p>
<p>这也就是说，如果有另外一个容器，那么它也有自己的一个 PID Namespace，而这两个 PID Namespace 之间是不能看到对方的进程的，这里就体现出了 Namespace 的作用： <strong>相互隔离</strong> 。</p>
<p>而在宿主机上的 Host PID Namespace，它是其他 Namespace 的父亲 Namespace，可以看到在这台机器上的所有进程，不过进程 PID 编号不是 Container PID Namespace 里的编号了，而是把所有在宿主机运行的进程放在一起，再进行编号。</p>
<p>讲了 PID Namespace 之后，我们了解到 <strong>Namespace 其实就是一种隔离机制，主要目的是隔离运行在同一个宿主机上的容器，让这些容器之间不能访问彼此的资源</strong> 。</p>
<p>这种隔离有两个作用： <strong>第一是可以充分地利用系统的资源，也就是说在同一台宿主机上可以运行多个用户的容器；第二是保证了安全性，因为不同用户之间不能访问对方的资源</strong> 。</p>
<p>除了 PID Namespace，还有其他常见的 Namespace 类型，比如我们之前运行了 docker exec c5a9ff78d9c1 ip addr 这个命令去查看容器内部的 IP 地址，这里其实就是在查看 Network Namespace。</p>
<p>在 Network Namespace 中都有一套独立的网络接口比如这里的 lo，eth0，还有独立的 TCP/IP 的协议栈配置。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker <span class="token builtin class-name">exec</span> c5a9ff78d9c1 <span class="token function">ip</span> addr
<span class="token number">1</span>: lo: <span class="token operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class="token number">1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet <span class="token number">127.0</span>.0.1/8 scope <span class="token function">host</span> lo
       valid_lft forever preferred_lft forever
<span class="token number">168</span>: eth0@if169: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">1500</span> qdisc noqueue state UP group default
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid <span class="token number">0</span>
    inet <span class="token number">172.17</span>.0.2/16 brd <span class="token number">172.17</span>.255.255 scope global eth0
       valid_lft forever preferred_lft forever<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们还可以运行 docker exec c5a9ff78d9c1 ls/ 查看容器中的根文件系统（rootfs）。然后，你会发现，它和宿主机上的根文件系统也是不一样的。 <strong>容器中的根文件系统，其实就是我们做的镜像。</strong></p>
<p>那容器自己的根文件系统完全独立于宿主机上的根文件系统，这一点是怎么做到的呢？其实这里依靠的是 <strong>Mount Namespace</strong> ，Mount Namespace 保证了每个容器都有自己独立的文件目录结构。</p>
<p>Namespace 的类型还有很多，我们查看”Linux Programmer’s Manual”，可以看到 Linux 中所有的 Namespace：cgroup/ipc/network/mount/pid/time/user/uts。</p>
<p>在这里呢，你需要记住的是 <strong>Namespace 是 Linux 中实现容器的两大技术之一，它最重要的作用是保证资源的隔离。</strong> 在后面的课程，讲解到具体问题时，我会不断地提到 Namespace 这个概念。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《容器实战高手课》学习笔记/Linux中的Namespace.jpg" alt="Linux中的Namespace"></p>
<p>好了，我们刚才说了 Namespace，这些 Namespace 尽管类型不同，其实都是为了隔离容器资源： <strong>PID Namespace 负责隔离不同容器的进程，Network Namespace 又负责管理网络环境的隔离，Mount Namespace 管理文件系统的隔离。</strong></p>
<p>正是通过这些 Namespace，我们才隔离出一个容器，这里你也可以把它看作是一台”计算机”。</p>
<p>既然是一台”计算机”，你肯定会问这个”计算机”有多少 CPU，有多少 Memory 啊？那么 Linux 如何为这些”计算机”来定义 CPU，定义 Memory 的容量呢？</p>
<h5 id="Cgroups"><a href="#Cgroups" class="headerlink" title="Cgroups"></a>Cgroups</h5><p>想要定义”计算机”各种容量大小，就涉及到支撑容器的第二个技术 <strong>Cgroups （Control Groups）</strong> 了。Cgroups 可以对指定的进程做各种计算机资源的限制，比如限制 CPU 的使用率，内存使用量，IO 设备的流量等等。</p>
<p>Cgroups 究竟有什么好处呢？要知道，在 Cgroups 出现之前，任意一个进程都可以创建出成百上千个线程，可以轻易地消耗完一台计算机的所有 CPU 资源和内存资源。</p>
<p>但是有了 Cgroups 这个技术以后，我们就可以对一个进程或者一组进程的计算机资源的消耗进行限制了。</p>
<p>Cgroups 通过不同的子系统限制了不同的资源，每个子系统限制一种资源。每个子系统限制资源的方式都是类似的，就是把相关的一组进程分配到一个控制组里，然后通过树结构进行管理，每个控制组都设有自己的资源控制参数。</p>
<p>完整的 Cgroups 子系统的介绍，你可以查看 <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/cgroups.7.html">Linux Programmer’s Manual</a> 中 Cgroups 的定义。</p>
<p>这里呢，我们只需要了解几种比较常用的 Cgroups 子系统：</p>
<ul>
<li>CPU 子系统，用来限制一个控制组（一组进程，你可以理解为一个容器里所有的进程）可使用的最大 CPU。</li>
<li>memory 子系统，用来限制一个控制组最大的内存使用量。</li>
<li>pids 子系统，用来限制一个控制组里最多可以运行多少个进程。</li>
<li>cpuset 子系统， 这个子系统来限制一个控制组里的进程可以在哪几个物理 CPU 上运行。</li>
</ul>
<p>因为 memory 子系统的限制参数最简单，所以下面我们就用 memory 子系统为例，一起看看 Cgroups 是怎么对一个容器做资源限制的。</p>
<p>对于启动的每个容器，都会在 Cgroups 子系统下建立一个目录，在 Cgroups 中这个目录也被称作控制组，比如下图里的 <code>docker-&lt;id1&gt;</code> <code>docker-&lt;id2&gt;</code>等。然后我们设置这个控制组的参数，通过这个方式，来限制这个容器的内存资源。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《容器实战高手课》学习笔记/memory子系统举例.jpg" alt="memory子系统举例"></p>
<p>还记得，我们之前用 Docker 创建的那个容器吗？在每个 Cgroups 子系统下，对应这个容器就会有一个目录 docker-<strong>c5a9ff78d9c1</strong>……这个容器的 ID 号，容器中所有的进程都会储存在这个控制组中  cgroup.procs 这个参数里。</p>
<p>你看下面的这些进程号是不是很熟悉呢？没错，它们就是前面我们用 ps 看到的进程号。</p>
<p>我们实际看一下这个例子里的 memory Cgroups，它可以控制 Memory 的使用量。比如说，我们将这个控制组 Memory 的最大用量设置为 2GB。</p>
<p>具体操作是这样的，我们把（<code>2 * 1024 * 1024 * 1024 = 2147483648</code>）这个值，写入 memory Cgroup 控制组中的 memory.limit_in_bytes 里， <strong>这样设置后，cgroup.procs 里面所有进程 Memory 使用量之和，最大也不会超过 2GB。</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">
$ <span class="token builtin class-name">cd</span> /sys/fs/cgroup/memory/system.slice/docker-c5a9ff78d9c1fedd52511e18fdbd26357250719fa0d128349547a50fad7c5de9.scope

$ <span class="token function">cat</span> cgroup.procs
<span class="token number">20731</span>
<span class="token number">20787</span>
<span class="token number">20788</span>
<span class="token number">20789</span>
<span class="token number">20791</span>

$ <span class="token builtin class-name">echo</span> <span class="token number">2147483648</span> <span class="token operator">&gt;</span> memory.limit_in_bytes

$ <span class="token function">cat</span> memory.limit_in_bytes
<span class="token number">2147483648</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>ubuntu 20.04 上 docker 20.10.17 中目录变成了 <code>/sys/fs/cgroup/memory/docker/c5a9ff78d9c1fedd52511e18fdbd26357250719fa0d128349547a50fad7c5de9</code> 。</p>
</blockquote>
<p>刚刚我们通过 memory Cgroups 定义了容器的 memory 可以使用的最大值。其他的子系统稍微复杂一些，但用法也和 memory 类似，我们在后面的课程中会结合具体的实例来详细解释其他的 Cgroups。</p>
<p>这里我们还要提一下 <strong>Cgroups 有 v1 和 v2 两个版本：</strong></p>
<blockquote>
<p>如何检查系统中安装的 cgroup 版本： <a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/471476/how-do-i-check-cgroup-v2-is-installed-on-my-machine">How do I check cgroup v2 is installed on my machine?</a> .</p>
</blockquote>
<p>Cgroups v1 在 Linux 中很早就实现了，各种子系统比较独立，每个进程在各个 Cgroups 子系统中独立配置，可以属于不同的 group。</p>
<p>虽然这样比较灵活，但是也存在问题，会导致 <strong>对同一进程的资源协调比较困难</strong> （比如 memory Cgroup 与 blkio Cgroup 之间就不能协作）。虽然 v1 有缺陷，但是在主流的生产环境中，大部分使用的还是 v1。</p>
<p>Cgroups v2 做了设计改进， <strong>解决了 v1 的问题，使各个子系统可以协调统一地管理资源。</strong></p>
<p>不过 Cgroups v2 在生产环境的应用还很少，因为该版本很多子系统的实现需要较新版本的 Linux 内核，还有无论是主流的 Linux 发行版本还是容器云平台，比如 Kubernetes，对 v2 的支持也刚刚起步。</p>
<p>所以啊，我们在后面 Cgroups 的讲解里呢，主要还是用 <strong>Cgroups v1 这个版本</strong> ，在磁盘 I/O 的这一章中，我们也会介绍一下 Cgroups v2。</p>
<p>好了，上面我们解读了 Namespace 和 Cgroups 两大技术，它们是 Linux 下实现容器的两个基石，后面课程中要讨论的容器相关问题，或多或少都和 Namespace 或者 Cgroups 相关，我们会结合具体问题做深入的分析。</p>
<p>目前呢，你只需要先记住这两个技术的作用，<strong>Namespace 帮助容器来实现各种计算资源的隔离，Cgroups 主要限制的是容器能够使用的某种资源量。</strong></p>
<h4 id="重点总结"><a href="#重点总结" class="headerlink" title="重点总结"></a>重点总结</h4><p>这一讲，我们对容器有了一个大致的认识，包括它的”形”， <strong>一些基本的容器操作</strong> ；还有它的”神”，也就是 <strong>容器实现的原理</strong> 。</p>
<p>启动容器的基本操作是这样的，首先用 Dockerfile 来建立一个容器的镜像，然后再用这个镜像来启动一个容器。</p>
<p>那启动了容器之后，怎么检验它是不是正常工作了呢？</p>
<p>我们可以运行 docker exec 这个命令进入容器的运行空间，查看进程是否启动，检查配置文件是否正确，检验我们设置的服务是否能够正常提供。</p>
<p>我们用 docker exec 命令查看了容器的进程，网络和文件系统，就能体会到容器的文件系统、运行的进程环境和网络的设置都是独立的，所以从用户使用的角度看，容器和一台独立的机器或者虚拟机没有什么太大的区别。</p>
<p>最后，我们一起学习了 Namespace 和 Cgroups，它们是 Linux 的两大技术，用于实现容器的特性。</p>
<p>具体来说， <strong>Namespace 帮助容器实现各种计算资源的隔离，Cgroups 主要对容器使用某种资源量的多少做一个限制。</strong></p>
<p>所以我们在这里可以直接记住： <strong>容器其实就是 Namespace+Cgroups。</strong></p>
<h2 id="容器进程"><a href="#容器进程" class="headerlink" title="容器进程"></a>容器进程</h2><h3 id="02-理解进程（1）：为什么我在容器中不能kill-1号进程？"><a href="#02-理解进程（1）：为什么我在容器中不能kill-1号进程？" class="headerlink" title="02 | 理解进程（1）：为什么我在容器中不能kill 1号进程？"></a>02 | 理解进程（1）：为什么我在容器中不能kill 1号进程？</h3><p>今天，我们正式进入理解进程的模块。我会通过 3 讲内容，带你了解容器 init 进程的特殊之处，还有它需要具备哪些功能，才能保证容器在运行过程中不会出现类似僵尸进程，或者应用程序无法 graceful shutdown 的问题。</p>
<p>那么通过这一讲，我会带你掌握 init 进程和 Linux 信号的核心概念。</p>
<h4 id="问题再现"><a href="#问题再现" class="headerlink" title="问题再现"></a>问题再现</h4><p>接下来，我们一起再现用 kill 1 命令重启容器的问题。</p>
<p>我猜你肯定想问，为什么要在容器中执行 kill 1 或者 kill -9 1 的命令呢？其实这是我们团队里的一位同学提出的问题。</p>
<p>这位同学当时遇到的情况是这样的，他想修改容器镜像里的一个 bug，但因为网路配置的问题，这个同学又不想为了重建 pod 去改变 pod IP。</p>
<p>如果你用过 Kubernetes 的话，你也肯定知道，Kubernetes 上是没有 restart pod 这个命令的。这样看来，他似乎只能让 pod 做个原地重启了。 <strong>当时我首先想到的，就是在容器中使用 kill pid 1 的方式重启容器。</strong></p>
<p>为了模拟这个过程，我们可以进行下面的这段操作。</p>
<p>如果你没有在容器中做过 kill 1 ，你可以下载我在 GitHub 上的这个 <a target="_blank" rel="noopener" href="https://github.com/chengyli/training/tree/main/init_proc/handle_sig">例子</a> ，运行 make image 来做一个容器镜像。</p>
<p>然后，我们用 Docker 构建一个容器，用例子中的 init.sh 脚本作为这个容器的 init 进程。</p>
<p>最后，我们在容器中运行 kill 1 和 kill -9 1 ，看看会发生什么。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker stop sig-proc<span class="token punctuation">;</span>docker <span class="token function">rm</span> sig-proc
$ docker run --name sig-proc -d registry/sig-proc:v1 /init.sh
$ docker <span class="token builtin class-name">exec</span> -it sig-proc <span class="token function">bash</span>
<span class="token punctuation">[</span>root@5cc69036b7b2 /<span class="token punctuation">]</span>$ <span class="token function">ps</span> -ef
<span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
root         <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">0</span> 07:23 ?        00:00:00 /bin/bash /init.sh
root         <span class="token number">8</span>     <span class="token number">1</span>  <span class="token number">0</span> 07:25 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang<span class="token operator">=</span>sleep /usr/bin/sleep <span class="token number">100</span>
root         <span class="token number">9</span>     <span class="token number">0</span>  <span class="token number">6</span> 07:27 pts/0    00:00:00 <span class="token function">bash</span>
root        <span class="token number">22</span>     <span class="token number">9</span>  <span class="token number">0</span> 07:27 pts/0    00:00:00 <span class="token function">ps</span> -ef
<span class="token punctuation">[</span>root@5cc69036b7b2 /<span class="token punctuation">]</span>$ <span class="token function">kill</span> <span class="token number">1</span>
<span class="token punctuation">[</span>root@5cc69036b7b2 /<span class="token punctuation">]</span>$ <span class="token function">kill</span> -9 <span class="token number">1</span>
<span class="token punctuation">[</span>root@5cc69036b7b2 /<span class="token punctuation">]</span>$ <span class="token function">ps</span> -ef
<span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
root         <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">0</span> 07:23 ?        00:00:00 /bin/bash /init.sh
root         <span class="token number">9</span>     <span class="token number">0</span>  <span class="token number">0</span> 07:27 pts/0    00:00:00 <span class="token function">bash</span>
root        <span class="token number">23</span>     <span class="token number">1</span>  <span class="token number">0</span> 07:27 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang<span class="token operator">=</span>sleep /usr/bin/sleep <span class="token number">100</span>
root        <span class="token number">24</span>     <span class="token number">9</span>  <span class="token number">0</span> 07:27 pts/0    00:00:00 <span class="token function">ps</span> -ef<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当我们完成前面的操作，就会发现无论运行 kill 1 （对应 Linux 中的 SIGTERM 信号）还是 kill -9 1（对应 Linux 中的 SIGKILL 信号），都无法让进程终止。</p>
<p>那么问题来了，这两个常常用来终止进程的信号，都对容器中的 init 进程不起作用，这是怎么回事呢？</p>
<p>要解释这个问题，我们就要回到容器的两个最基本概念——init 进程和 Linux 信号中寻找答案。</p>
<h4 id="知识详解"><a href="#知识详解" class="headerlink" title="知识详解"></a>知识详解</h4><h5 id="如何理解-init-进程？"><a href="#如何理解-init-进程？" class="headerlink" title="如何理解 init 进程？"></a>如何理解 init 进程？</h5><p>init 进程的意思并不难理解，你只要认真听我讲完，这块内容基本就不会有问题了。我们下面来看一看。</p>
<p>使用容器的理想境界是 <strong>一个容器只启动一个进程</strong> ，但这在现实应用中有时是做不到的。</p>
<p>比如说，在一个容器中除了主进程之外，我们可能还会启动辅助进程，做监控或者 rotate logs；再比如说，我们需要把原来运行在虚拟机（VM）的程序移到容器里，这些原来跑在虚拟机上的程序本身就是多进程的。</p>
<p>一旦我们启动了多个进程，那么容器里就会出现一个 pid 1，也就是我们常说的 1 号进程或者 init 进程，然后 <strong>由这个进程创建出其他的子进程。</strong></p>
<p>接下来，我带你梳理一下 init 进程是怎么来的。</p>
<p>一个 Linux 操作系统，在系统打开电源，执行 BIOS/boot-loader 之后，就会由 boot-loader 负责加载 Linux 内核。</p>
<p>Linux 内核执行文件一般会放在 /boot 目录下，文件名类似 vmlinuz<em>。在内核完成了操作系统的各种初始化之后，<em>*这个程序需要执行的第一个用户态程就是 init 进程。</em></em></p>
<p>内核代码启动 1 号进程的时候，在没有外面参数指定程序路径的情况下，一般会从几个缺省路径尝试执行 1 号进程的代码。这几个路径都是 Unix 常用的可执行代码路径。</p>
<p>系统启动的时候先是执行内核态的代码，然后在内核中调用 1 号进程的代码，从内核态切换到用户态。</p>
<p>目前主流的 Linux 发行版，无论是 RedHat 系的还是 Debian 系的，都会把 /sbin/init 作为符号链接指向 Systemd。Systemd 是目前最流行的 Linux init 进程，在它之前还有 SysVinit、UpStart 等 Linux init 进程。</p>
<p><strong>但无论是哪种 Linux init 进程，它最基本的功能都是创建出 Linux 系统中其他所有的进程，并且管理这些进程。</strong> 具体在 kernel 里的代码实现如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// init/main.c</span>

<span class="token comment">/*
    * We try each of these until one succeeds.
    *
    * The Bourne shell can be used instead of init if we are
    * trying to recover a really broken machine.
    */</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>execute_command<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ret <span class="token operator">=</span> <span class="token function">run_init_process</span><span class="token punctuation">(</span>execute_command<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ret<span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"Requested init %s failed (error %d)."</span><span class="token punctuation">,</span>
                execute_command<span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">try_to_run_init_process</span><span class="token punctuation">(</span><span class="token string">"/sbin/init"</span><span class="token punctuation">)</span> <span class="token operator">||</span>
    <span class="token operator">!</span><span class="token function">try_to_run_init_process</span><span class="token punctuation">(</span><span class="token string">"/etc/init"</span><span class="token punctuation">)</span> <span class="token operator">||</span>
    <span class="token operator">!</span><span class="token function">try_to_run_init_process</span><span class="token punctuation">(</span><span class="token string">"/bin/init"</span><span class="token punctuation">)</span> <span class="token operator">||</span>
    <span class="token operator">!</span><span class="token function">try_to_run_init_process</span><span class="token punctuation">(</span><span class="token string">"/bin/sh"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"No working init found.  Try passing init= option to kernel. "</span>
        <span class="token string">"See Linux Documentation/admin-guide/init.rst for guidance."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> -l /sbin/init
lrwxrwxrwx <span class="token number">1</span> root root <span class="token number">20</span> Feb  <span class="token number">5</span> 01:07 /sbin/init -<span class="token operator">&gt;</span> /lib/systemd/systemd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在 Linux 上有了容器的概念之后，一旦容器建立了自己的 Pid Namespace（进程命名空间），这个 Namespace 里的进程号也是从 1 开始标记的。所以，容器的 init 进程也被称为 1 号进程。</p>
<p>怎么样，1 号进程是不是不难理解？关于这个知识点，你只需要记住： <strong>1 号进程是第一个用户态的进程，由它直接或者间接创建了 Namespace 中的其他进程。</strong></p>
<h5 id="如何理解-Linux-信号？"><a href="#如何理解-Linux-信号？" class="headerlink" title="如何理解 Linux 信号？"></a>如何理解 Linux 信号？</h5><p>刚才我给你讲了什么是 1 号进程，要想解决”为什么我在容器中不能 kill 1 号进程”这个问题，我们还得看看 kill 命令起到的作用。</p>
<p>我们运行 kill 命令，其实在 Linux 里就是发送一个信号，那么信号到底是什么呢？这就涉及到 Linux 信号的概念了。</p>
<p>其实信号这个概念在很早期的 Unix 系统上就有了。它一般会从 1 开始编号，通常来说，信号编号是 1 到 31，这个编号在所有的 Unix 系统上都是一样的。</p>
<p>在 Linux 上我们可以用 kill -l 来看这些信号的编号和名字，具体的编号和名字我给你列在了下面，你可以看一看。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">kill</span> -l
 <span class="token number">1</span><span class="token punctuation">)</span> SIGHUP      <span class="token number">2</span><span class="token punctuation">)</span> SIGINT    <span class="token number">3</span><span class="token punctuation">)</span> SIGQUIT    <span class="token number">4</span><span class="token punctuation">)</span> SIGILL    <span class="token number">5</span><span class="token punctuation">)</span> SIGTRAP
 <span class="token number">6</span><span class="token punctuation">)</span> SIGABRT     <span class="token number">7</span><span class="token punctuation">)</span> SIGBUS    <span class="token number">8</span><span class="token punctuation">)</span> SIGFPE     <span class="token number">9</span><span class="token punctuation">)</span> SIGKILL  <span class="token number">10</span><span class="token punctuation">)</span> SIGUSR1
<span class="token number">11</span><span class="token punctuation">)</span> SIGSEGV    <span class="token number">12</span><span class="token punctuation">)</span> SIGUSR2  <span class="token number">13</span><span class="token punctuation">)</span> SIGPIPE   <span class="token number">14</span><span class="token punctuation">)</span> SIGALRM  <span class="token number">15</span><span class="token punctuation">)</span> SIGTERM
<span class="token number">16</span><span class="token punctuation">)</span> SIGSTKFLT  <span class="token number">17</span><span class="token punctuation">)</span> SIGCHLD  <span class="token number">18</span><span class="token punctuation">)</span> SIGCONT   <span class="token number">19</span><span class="token punctuation">)</span> SIGSTOP  <span class="token number">20</span><span class="token punctuation">)</span> SIGTSTP
<span class="token number">21</span><span class="token punctuation">)</span> SIGTTIN    <span class="token number">22</span><span class="token punctuation">)</span> SIGTTOU  <span class="token number">23</span><span class="token punctuation">)</span> SIGURG    <span class="token number">24</span><span class="token punctuation">)</span> SIGXCPU  <span class="token number">25</span><span class="token punctuation">)</span> SIGXFSZ
<span class="token number">26</span><span class="token punctuation">)</span> SIGVTALRM  <span class="token number">27</span><span class="token punctuation">)</span> SIGPROF  <span class="token number">28</span><span class="token punctuation">)</span> SIGWINCH  <span class="token number">29</span><span class="token punctuation">)</span> SIGIO    <span class="token number">30</span><span class="token punctuation">)</span> SIGPWR
<span class="token number">31</span><span class="token punctuation">)</span> SIGSYS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>用一句话来概括， <strong>信号（Signal）其实就是 Linux 进程收到的一个通知。</strong> 这些通知产生的源头有很多种，通知的类型也有很多种。</p>
<p>比如下面这几个典型的场景，你可以看一下：</p>
<ul>
<li>如果我们按下键盘”Ctrl+C”，当前运行的进程就会收到一个信号 SIGINT 而退出；</li>
<li>如果我们的代码写得有问题，导致内存访问出错了，当前的进程就会收到另一个信号 SIGSEGV；</li>
<li>我们也可以通过命令 <code>kill &lt;pid&gt;</code>，直接向一个进程发送一个信号，缺省情况下不指定信号的类型，那么这个信号就是 SIGTERM。也可以指定信号类型，比如命令 <code>kill -9 &lt;pid&gt;</code>, 这里的 9，就是编号为 9 的信号，SIGKILL 信号。</li>
</ul>
<p>在这一讲中，我们主要用到 <strong>SIGTERM（15）和 SIGKILL（9）这两个信号</strong> ，所以这里你主要了解这两个信号就可以了，其他信号以后用到时再做介绍。</p>
<p>进程在收到信号后，就会去做相应的处理。怎么处理呢？对于每一个信号，进程对它的处理都有下面三个选择。</p>
<p>第一个选择是 <strong>忽略（Ignore）</strong> ，就是对这个信号不做任何处理，但是有两个信号例外，对于 SIGKILL 和 SIGSTOP 这个两个信号，进程是不能忽略的。这是因为它们的主要作用是为 Linux kernel 和超级用户提供删除任意进程的特权。</p>
<p>第二个选择，就是 <strong>捕获（Catch）</strong> ，这个是指让用户进程可以注册自己针对这个信号的 handler。具体怎么做我们目前暂时涉及不到，你先知道就行，我们在后面课程会进行详细介绍。</p>
<p><strong>对于捕获，SIGKILL 和 SIGSTOP 这两个信号也同样例外，这两个信号不能有用户自己的处理代码，只能执行系统的缺省行为。</strong></p>
<p>还有一个选择是 <strong>缺省行为（Default）</strong> ，Linux 为每个信号都定义了一个缺省的行为，你可以在 Linux 系统中运行 man 7 signal来查看每个信号的缺省行为。</p>
<p>对于大部分的信号而言，应用程序不需要注册自己的 handler，使用系统缺省定义行为就可以了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《容器实战高手课》学习笔记/进程处理信号的三种选择.jpg" alt="进程处理信号的三种选择"></p>
<p>我刚才说了，SIGTERM（15）和 SIGKILL（9）这两个信号是我们重点掌握的。现在我们已经讲解了信号的概念和处理方式，我就拿这两个信号为例，再带你具体分析一下。</p>
<p>首先我们来看 SIGTERM（15），这个信号是 Linux 命令 kill 缺省发出的。前面例子里的命令 kill 1 ，就是通过 kill 向 1 号进程发送一个信号，在没有别的参数时，这个信号类型就默认为 SIGTERM。</p>
<p>SIGTERM 这个信号是可以被捕获的，这里的”捕获”指的就是用户进程可以为这个信号注册自己的 handler，而这个 handler，我们后面会看到，它可以处理进程的 graceful-shutdown 问题。</p>
<p>我们再来了解一下 SIGKILL (9)，这个信号是 Linux 里两个 <strong>特权信号</strong> 之一。什么是特权信号呢？</p>
<p>前面我们已经提到过了，特权信号就是 Linux 为 kernel 和超级用户去删除任意进程所保留的，不能被忽略也不能被捕获。那么进程一旦收到 SIGKILL，就要退出。</p>
<p>在前面的例子里，我们运行的命令 kill -9 1 里的参数”-9”，其实就是指发送编号为 9 的这个 SIGKILL 信号给 1 号进程。</p>
<h4 id="现象解释"><a href="#现象解释" class="headerlink" title="现象解释"></a>现象解释</h4><p>现在，你应该理解 init 进程和 Linux 信号这两个概念了，让我们回到开头的问题上来：”为什么我在容器中不能 kill 1 号进程，甚至 SIGKILL 信号也不行？”</p>
<p>你还记得么，在课程的最开始，我们已经尝试过用 bash 作为容器 1 号进程，这样是无法把 1 号进程杀掉的。那么我们再一起来看一看，用别的编程语言写的 1 号进程是否也杀不掉。</p>
<p>我们现在 <strong>用 C 程序作为 init 进程</strong> ，尝试一下杀掉 1 号进程。和 bash init 进程一样，无论 SIGTERM 信号还是 SIGKILL 信号，在容器里都不能杀死这个 1 号进程。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> c-init-nosig.c
<span class="token comment">#include &lt;stdio.h&gt;</span>
<span class="token comment">#include &lt;unistd.h&gt;</span>
int main<span class="token punctuation">(</span>int argc, char *argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
       printf<span class="token punctuation">(</span><span class="token string">"Process is sleeping<span class="token entity" title="\n">\n</span>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              sleep<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       <span class="token builtin class-name">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker stop sig-proc<span class="token punctuation">;</span>docker <span class="token function">rm</span> sig-proc
$ docker run --name sig-proc -d registry/sig-proc:v1 /c-init-nosig
$ docker <span class="token builtin class-name">exec</span> -it sig-proc <span class="token function">bash</span>

<span class="token punctuation">[</span>root@5d3d42a031b1 /<span class="token punctuation">]</span>$ <span class="token function">ps</span> -ef
<span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
root         <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">0</span> 07:48 ?        00:00:00 /c-init-nosig
root         <span class="token number">6</span>     <span class="token number">0</span>  <span class="token number">5</span> 07:48 pts/0    00:00:00 <span class="token function">bash</span>
root        <span class="token number">19</span>     <span class="token number">6</span>  <span class="token number">0</span> 07:48 pts/0    00:00:00 <span class="token function">ps</span> -ef
<span class="token punctuation">[</span>root@5d3d42a031b1 /<span class="token punctuation">]</span>$ <span class="token function">kill</span> <span class="token number">1</span>
<span class="token punctuation">[</span>root@5d3d42a031b1 /<span class="token punctuation">]</span>$ <span class="token function">kill</span> -9 <span class="token number">1</span>
<span class="token punctuation">[</span>root@5d3d42a031b1 /<span class="token punctuation">]</span>$ <span class="token function">ps</span> -ef
<span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
root         <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">0</span> 07:48 ?        00:00:00 /c-init-nosig
root         <span class="token number">6</span>     <span class="token number">0</span>  <span class="token number">0</span> 07:48 pts/0    00:00:00 <span class="token function">bash</span>
root        <span class="token number">20</span>     <span class="token number">6</span>  <span class="token number">0</span> 07:49 pts/0    00:00:00 <span class="token function">ps</span> -ef<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们是不是这样就可以得出结论——“容器里的 1 号进程，完全忽略了 SIGTERM 和 SIGKILL 信号了”呢？你先别着急，我们再拿其他语言试试。</p>
<p>接下来，我们用 <strong>Golang 程序作为 1 号进程</strong> ，我们再在容器中执行 kill -9 1 和 kill 1 。</p>
<p>这次，我们发现 kill -9 1 这个命令仍然不能杀死 1 号进程，也就是说，SIGKILL 信号和之前的两个测试一样不起作用。</p>
<p><strong>但是，我们执行 kill 1 以后，SIGTERM 这个信号把 init 进程给杀了，容器退出了。</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> go-init.go
package main
<span class="token function">import</span> <span class="token punctuation">(</span>
       <span class="token string">"fmt"</span>
       <span class="token string">"time"</span>
<span class="token punctuation">)</span>
func <span class="token function-name function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       fmt.Println<span class="token punctuation">(</span><span class="token string">"Start app<span class="token entity" title="\n">\n</span>"</span><span class="token punctuation">)</span>
       time.Sleep<span class="token punctuation">(</span>time.Duration<span class="token punctuation">(</span><span class="token number">100000</span><span class="token punctuation">)</span> * time.Millisecond<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker stop sig-proc<span class="token punctuation">;</span>docker <span class="token function">rm</span> sig-proc
$ docker run --name sig-proc -d registry/sig-proc:v1 /go-init
$ docker <span class="token builtin class-name">exec</span> -it sig-proc <span class="token function">bash</span>

<span class="token punctuation">[</span>root@234a23aa597b /<span class="token punctuation">]</span>$ <span class="token function">ps</span> -ef
<span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
root         <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">1</span> 08:04 ?        00:00:00 /go-init
root        <span class="token number">10</span>     <span class="token number">0</span>  <span class="token number">9</span> 08:04 pts/0    00:00:00 <span class="token function">bash</span>
root        <span class="token number">23</span>    <span class="token number">10</span>  <span class="token number">0</span> 08:04 pts/0    00:00:00 <span class="token function">ps</span> -ef
<span class="token punctuation">[</span>root@234a23aa597b /<span class="token punctuation">]</span>$ <span class="token function">kill</span> -9 <span class="token number">1</span>
<span class="token punctuation">[</span>root@234a23aa597b /<span class="token punctuation">]</span>$ <span class="token function">kill</span> <span class="token number">1</span>
<span class="token punctuation">[</span>root@234a23aa597b /<span class="token punctuation">]</span>$
<span class="token punctuation">[</span>~<span class="token punctuation">]</span>$ docker <span class="token function">ps</span>
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于这个测试结果，你是不是反而觉得更加困惑了？</p>
<p>为什么使用不同程序，结果就不一样呢？接下来我们就看看 kill 命令下达之后，Linux 里究竟发生了什么事，我给你系统地梳理一下整个过程。</p>
<p>在我们运行 kill 1 这个命令的时候，希望把 SIGTERM 这个信号发送给 1 号进程，就像下面图里的 <strong>带箭头虚线</strong> 。</p>
<p>在 Linux 实现里，kill 命令调用了 <strong>kill() 的这个系统调用</strong> （所谓系统调用就是内核的调用接口）而进入到了内核函数 sys_kill()， 也就是下图里的 <strong>实线箭头</strong> 。</p>
<p>而内核在决定把信号发送给 1 号进程的时候，会调用 sig_task_ignored() 这个函数来做个判断，这个判断有什么用呢？</p>
<p>它会决定内核在哪些情况下会把发送的这个信号给忽略掉。如果信号被忽略了，那么 init 进程就不能收到指令了。</p>
<p>所以，我们想要知道 init 进程为什么收到或者收不到信号，都要去看看 <strong>sig_task_ignored() 的这个内核函数的实现</strong> 。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《容器实战高手课》学习笔记/sig_task_ignored内核函数实现示意图.jpg" alt="sig_task_ignored内核函数实现示意图"></p>
<p>在 sig_task_ignored() 这个函数中有三个 if{}判断，第一个和第三个 if{}判断和我们的问题没有关系，并且代码有注释，我们就不讨论了。</p>
<p>我们重点来看第二个 if{}。我来给你分析一下，在容器中执行 kill 1 或者 kill -9 1 的时候，这第二个 if{}里的三个子条件是否可以被满足呢？</p>
<p>我们来看下面这串代码，这里表示 <strong>一旦这三个子条件都被满足，那么这个信号就不会发送给进程。</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// kernel/signal.c</span>

<span class="token keyword">static</span> bool <span class="token function">sig_task_ignored</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>t<span class="token punctuation">,</span> <span class="token keyword">int</span> sig<span class="token punctuation">,</span> bool force<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">void</span> __user <span class="token operator">*</span>handler<span class="token punctuation">;</span>
        handler <span class="token operator">=</span> <span class="token function">sig_handler</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* SIGKILL and SIGSTOP may not be sent to the global init */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token function">is_global_init</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">sig_kernel_only</span><span class="token punctuation">(</span>sig<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> true<span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>signal<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> SIGNAL_UNKILLABLE<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
            handler <span class="token operator">==</span> SIG_DFL <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>force <span class="token operator">&amp;&amp;</span> <span class="token function">sig_kernel_only</span><span class="token punctuation">(</span>sig<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> true<span class="token punctuation">;</span>

        <span class="token comment">/* Only allow kernel generated signals to this kthread */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> PF_KTHREAD<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                     <span class="token punctuation">(</span>handler <span class="token operator">==</span> SIG_KTHREAD_KERNEL<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>force<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> true<span class="token punctuation">;</span>

        <span class="token keyword">return</span> <span class="token function">sig_handler_ignored</span><span class="token punctuation">(</span>handler<span class="token punctuation">,</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来，我们就逐一分析一下这三个子条件，我们来说说这个”!(force &amp;&amp; sig_kernel_only(sig))” 。</p>
<p>第一个条件里 force 的值，对于同一个 Namespace 里发出的信号来说，调用值是 0，所以这个条件总是满足的。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/pid_namespaces.7.html">pid_namespaces(7) — Linux manual page</a></p>
</blockquote>
<p>我们再来看一下第二个条件 “handler == SIG_DFL”，第二个条件判断信号的 handler 是否是 SIG_DFL。</p>
<p>那么什么是 SIG_DFL 呢？ <strong>对于每个信号，用户进程如果不注册一个自己的 handler，就会有一个系统缺省的 handler，这个缺省的 handler 就叫作 SIG_DFL。</strong></p>
<p>对于 SIGKILL，我们前面介绍过它是特权信号，是不允许被捕获的，所以它的 handler 就一直是 SIG_DFL。这第二个条件对 SIGKILL 来说总是满足的。</p>
<p>对于 SIGTERM，它是可以被捕获的。也就是说如果用户不注册 handler，那么这个条件对 SIGTERM 也是满足的。</p>
<p>最后再来看一下第三个条件，”t-&gt;signal-&gt;flags &amp; SIGNAL_UNKILLABLE”，这里的条件判断是这样的，进程必须是 SIGNAL_UNKILLABLE 的。</p>
<p>这个 SIGNAL_UNKILLABLE flag 是在哪里置位的呢？</p>
<p>可以参考我们下面的这段代码，在每个 Namespace 的 init 进程建立的时候，就会打上 <strong>SIGNAL_UNKILLABLE</strong> 这个标签，也就是说只要是 1 号进程，就会有这个 flag，这个条件也是满足的。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// kernel/fork.c</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_child_reaper</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">ns_of_pid</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token operator">-&gt;</span>child_reaper <span class="token operator">=</span> p<span class="token punctuation">;</span>
            p<span class="token operator">-&gt;</span>signal<span class="token operator">-&gt;</span>flags <span class="token operator">|=</span> SIGNAL_UNKILLABLE<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token comment">/*
 * is_child_reaper returns true if the pid is the init process
 * of the current namespace. As this one could be checked before
 * pid_ns-&gt;child_reaper is assigned in copy_process, we check
 * with the pid number.
 */</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> bool <span class="token function">is_child_reaper</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pid</span> <span class="token operator">*</span>pid<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">return</span> pid<span class="token operator">-&gt;</span>numbers<span class="token punctuation">[</span>pid<span class="token operator">-&gt;</span>level<span class="token punctuation">]</span><span class="token punctuation">.</span>nr <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们可以看出来，其实 <strong>最关键的一点就是 handler == SIG_DFL 。Linux 内核针对每个 Namespace 里的 init 进程，把只有 default handler 的信号都给忽略了。</strong></p>
<p>如果我们自己注册了信号的 handler（应用程序注册信号 handler 被称作”Catch the Signal”），那么这个信号 handler 就不再是 SIG_DFL 。即使是 init 进程在接收到 SIGTERM 之后也是可以退出的。</p>
<p>不过，由于 SIGKILL 是一个特例，因为 SIGKILL 是不允许被注册用户 handler 的（还有一个不允许注册用户 handler 的信号是 SIGSTOP），那么它只有 SIG_DFL handler。</p>
<p>所以 init 进程是永远不能被 SIGKILL 所杀，但是可以被 SIGTERM 杀死。</p>
<p>说到这里，我们该怎么证实这一点呢？我们可以做下面两件事来验证。</p>
<h5 id="第一件事，你可以查看-1-号进程状态中-SigCgt-Bitmap"><a href="#第一件事，你可以查看-1-号进程状态中-SigCgt-Bitmap" class="headerlink" title="第一件事，你可以查看 1 号进程状态中 SigCgt Bitmap"></a>第一件事，你可以查看 1 号进程状态中 SigCgt Bitmap</h5><p>我们可以看到，在 Golang 程序里，很多信号都注册了自己的 handler，当然也包括了 SIGTERM(15)，也就是 bit 15。</p>
<p>而 C 程序里，缺省状态下，一个信号 handler 都没有注册；bash 程序里注册了两个 handler，bit 2 和 bit 17，也就是 SIGINT 和 SIGCHLD，但是没有注册 SIGTERM。</p>
<p>所以，C 程序和 bash 程序里 SIGTERM 的 handler 是 SIG_DFL（系统缺省行为），那么它们就不能被 SIGTERM 所杀。</p>
<p>具体我们可以看一下这段 /proc 系统的进程状态：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">### golang init</span>
$ <span class="token function">cat</span> /proc/1/status <span class="token operator">|</span> <span class="token function">grep</span> -i SigCgt
SigCgt:     fffffffe7fc1feff

<span class="token comment">### C init</span>
$ <span class="token function">cat</span> /proc/1/status <span class="token operator">|</span> <span class="token function">grep</span> -i SigCgt
SigCgt:     0000000000000000

<span class="token comment">### bash init</span>
$ <span class="token function">cat</span> /proc/1/status <span class="token operator">|</span> <span class="token function">grep</span> -i SigCgt
SigCgt:     0000000000010002<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>SigCgt 掩码位的解释： <a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/85364/how-can-i-check-what-signals-a-process-is-listening-to">How can I check what signals a process is listening to?</a></p>
</blockquote>
<h5 id="第二件事，给-C-程序注册一下-SIGTERM-handler，捕获-SIGTERM"><a href="#第二件事，给-C-程序注册一下-SIGTERM-handler，捕获-SIGTERM" class="headerlink" title="第二件事，给 C 程序注册一下 SIGTERM handler，捕获 SIGTERM"></a>第二件事，给 C 程序注册一下 SIGTERM handler，捕获 SIGTERM</h5><p>我们调用 signal() 系统调用注册 SIGTERM 的 handler，在 handler 里主动退出，再看看容器中 kill 1 的结果。</p>
<p>这次我们就可以看到，<strong>在进程状态的 SigCgt bitmap 里，bit 15 (SIGTERM) 已经置位了。同时，运行 kill 1 也可以把这个 C 程序的 init 进程给杀死了。</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">sig_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> signo<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>signo <span class="token operator">==</span> SIGTERM<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"received SIGTERM\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">signal</span><span class="token punctuation">(</span>SIGTERM<span class="token punctuation">,</span> sig_handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Process is sleeping\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker stop sig-proc<span class="token punctuation">;</span>docker <span class="token function">rm</span> sig-proc
$ docker run --name sig-proc -d registry/sig-proc:v1 /c-init-sig
$ docker <span class="token builtin class-name">exec</span> -it sig-proc <span class="token function">bash</span>

<span class="token punctuation">[</span>root@043f4f717cb5 /<span class="token punctuation">]</span>$ <span class="token function">ps</span> -ef
<span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
root         <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">0</span> 09:05 ?        00:00:00 /c-init-sig
root         <span class="token number">6</span>     <span class="token number">0</span> <span class="token number">18</span> 09:06 pts/0    00:00:00 <span class="token function">bash</span>
root        <span class="token number">19</span>     <span class="token number">6</span>  <span class="token number">0</span> 09:06 pts/0    00:00:00 <span class="token function">ps</span> -ef
<span class="token punctuation">[</span>root@043f4f717cb5 /<span class="token punctuation">]</span>$ <span class="token function">cat</span> /proc/1/status <span class="token operator">|</span> <span class="token function">grep</span> SigCgt
SigCgt: 0000000000004000
<span class="token punctuation">[</span>root@043f4f717cb5 /<span class="token punctuation">]</span>$ <span class="token function">kill</span> <span class="token number">1</span>
$ docker <span class="token function">ps</span>
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>好了，到这里我们可以确定这两点：</p>
<ol>
<li>kill -9 1 在容器中是不工作的，内核阻止了 1 号进程对 SIGKILL 特权信号的响应。</li>
<li>kill 1 分两种情况，如果 1 号进程没有注册 SIGTERM 的 handler，那么对 SIGTERM 信号也不响应，如果注册了 handler，那么就可以响应 SIGTERM 信号。</li>
</ol>
<h4 id="重点总结-1"><a href="#重点总结-1" class="headerlink" title="重点总结"></a>重点总结</h4><p>这一讲我们主要讲了 init 进程。围绕这个知识点，我提出了一个真实发生的问题：”为什么我在容器中不能 kill 1 号进程?”。</p>
<p>想要解决这个问题，我们需要掌握两个基本概念。</p>
<p>第一个概念是 <strong>Linux 1 号进程。它是第一个用户态的进程。它直接或者间接创建了 Namespace 中的其他进程。</strong></p>
<p>第二个概念是 Linux 信号。Linux 有 31 个基本信号，进程在处理大部分信号时有三个选择： <strong>忽略、捕获和缺省行为。其中两个特权信号 SIGKILL 和 SIGSTOP 不能被忽略或者捕获。</strong></p>
<p>只知道基本概念还不行，我们还要去解决问题。我带你尝试了用 bash, C 语言还有 Golang 程序作为容器 init 进程，发现它们对 kill 1 的反应是不同的。</p>
<p>因为信号的最终处理都是在 Linux 内核中进行的，因此，我们需要对 Linux 内核代码进行分析。</p>
<p>容器里 1 号进程对信号处理的两个要点，这也是这一讲里我想让你记住的两句话：</p>
<ol>
<li><strong>在容器中，1 号进程永远不会响应 SIGKILL 和 SIGSTOP 这两个特权信号；</strong></li>
<li><strong>对于其他的信号，如果用户自己注册了 handler，1 号进程可以响应。</strong></li>
</ol>
<h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><p>这一讲的最开始，有这样一个 C 语言的 init 进程，它没有注册任何信号的 handler。如果我们从 Host Namespace 向它发送 SIGTERM，会发生什么情况呢？</p>
<p>答：SIGTERM不能杀掉，但是SIGKILL可以。</p>
<blockquote>
<p>提示：此时 force 为 true 而 sig_kernel_only(SIGTERM) 为 false, sig_kernel_only(SIGKILL) 为 true 。</p>
</blockquote>
<h3 id="03｜理解进程（2）：为什么我的容器里有这么多僵尸进程？"><a href="#03｜理解进程（2）：为什么我的容器里有这么多僵尸进程？" class="headerlink" title="03｜理解进程（2）：为什么我的容器里有这么多僵尸进程？"></a>03｜理解进程（2）：为什么我的容器里有这么多僵尸进程？</h3><p>说起僵尸进程，相信你并不陌生。很多面试官经常会问到这个知识点，用来考察候选人的操作系统背景。通过这个问题，可以了解候选人对 Linux 进程管理和信号处理这些基础知识的理解程度，他的基本功扎不扎实。</p>
<p>所以，今天我们就一起来看看容器里为什么会产生僵尸进程，然后去分析如何怎么解决。</p>
<p>通过这一讲，你就会对僵尸进程的产生原理有一个清晰的认识，也会更深入地理解容器 init 进程的特性。</p>
<h4 id="问题再现-1"><a href="#问题再现-1" class="headerlink" title="问题再现"></a>问题再现</h4><p>我们平时用容器的时候，有的同学会发现，自己的容器运行久了之后，运行 ps 命令会看到一些进程，进程名后面加了 <defunct> 标识。那么你自然会有这样的疑问，这些是什么进程呢？</defunct></p>
<p>你可以自己做个容器镜像来模拟一下，我们先下载这个 <a target="_blank" rel="noopener" href="https://github.com/chengyli/training/tree/main/init_proc/zombie_proc">例子</a> ，运行 make image 之后，再启动容器。</p>
<p>在容器里我们可以看到，1 号进程 fork 出 1000 个子进程。当这些子进程运行结束后，它们的进程名字后面都加了标识。</p>
<p>从它们的 Z stat（进程状态）中我们可以知道，这些都是僵尸进程（Zombie Process）。运行 top 命令，我们也可以看到输出的内容显示有 1000 zombie 进程。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run --name zombie-proc -d registry/zombie-proc:v1
02dec161a9e8b18922bd3599b922dbd087a2ad60c9b34afccde7c91a463bde8a

$ docker <span class="token builtin class-name">exec</span> -it zombie-proc <span class="token function">bash</span>
$ <span class="token function">ps</span> aux
<span class="token environment constant">USER</span>       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         <span class="token number">1</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">4324</span>  <span class="token number">1436</span> ?        Ss   01:23   <span class="token number">0</span>:00 /app-test <span class="token number">1000</span>
root         <span class="token number">6</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        Z    01:23   <span class="token number">0</span>:00 <span class="token punctuation">[</span>app-test<span class="token punctuation">]</span> <span class="token operator">&lt;</span>defunct<span class="token operator">&gt;</span>
root         <span class="token number">7</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        Z    01:23   <span class="token number">0</span>:00 <span class="token punctuation">[</span>app-test<span class="token punctuation">]</span> <span class="token operator">&lt;</span>defunct<span class="token operator">&gt;</span>
root         <span class="token number">8</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        Z    01:23   <span class="token number">0</span>:00 <span class="token punctuation">[</span>app-test<span class="token punctuation">]</span> <span class="token operator">&lt;</span>defunct<span class="token operator">&gt;</span>
root         <span class="token number">9</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        Z    01:23   <span class="token number">0</span>:00 <span class="token punctuation">[</span>app-test<span class="token punctuation">]</span> <span class="token operator">&lt;</span>defunct<span class="token operator">&gt;</span>
root        <span class="token number">10</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        Z    01:23   <span class="token number">0</span>:00 <span class="token punctuation">[</span>app-test<span class="token punctuation">]</span> <span class="token operator">&lt;</span>defunct<span class="token operator">&gt;</span>
…
root       <span class="token number">999</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        Z    01:23   <span class="token number">0</span>:00 <span class="token punctuation">[</span>app-test<span class="token punctuation">]</span> <span class="token operator">&lt;</span>defunct<span class="token operator">&gt;</span>
root      <span class="token number">1000</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        Z    01:23   <span class="token number">0</span>:00 <span class="token punctuation">[</span>app-test<span class="token punctuation">]</span> <span class="token operator">&lt;</span>defunct<span class="token operator">&gt;</span>
root      <span class="token number">1001</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        Z    01:23   <span class="token number">0</span>:00 <span class="token punctuation">[</span>app-test<span class="token punctuation">]</span> <span class="token operator">&lt;</span>defunct<span class="token operator">&gt;</span>
root      <span class="token number">1002</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        Z    01:23   <span class="token number">0</span>:00 <span class="token punctuation">[</span>app-test<span class="token punctuation">]</span> <span class="token operator">&lt;</span>defunct<span class="token operator">&gt;</span>
root      <span class="token number">1003</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        Z    01:23   <span class="token number">0</span>:00 <span class="token punctuation">[</span>app-test<span class="token punctuation">]</span> <span class="token operator">&lt;</span>defunct<span class="token operator">&gt;</span>
root      <span class="token number">1004</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        Z    01:23   <span class="token number">0</span>:00 <span class="token punctuation">[</span>app-test<span class="token punctuation">]</span> <span class="token operator">&lt;</span>defunct<span class="token operator">&gt;</span>
root      <span class="token number">1005</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        Z    01:23   <span class="token number">0</span>:00 <span class="token punctuation">[</span>app-test<span class="token punctuation">]</span> <span class="token operator">&lt;</span>defunct<span class="token operator">&gt;</span>
root      <span class="token number">1023</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>  <span class="token number">12020</span>  <span class="token number">3392</span> pts/0    Ss   01:39   <span class="token number">0</span>:00 <span class="token function">bash</span>

$ <span class="token function">top</span>
<span class="token function">top</span> - 02:18:57 up <span class="token number">31</span> days, <span class="token number">15</span>:17,  <span class="token number">0</span> users,  load average: <span class="token number">0.00</span>, <span class="token number">0.01</span>, <span class="token number">0.00</span>
Tasks: <span class="token number">1003</span> total,   <span class="token number">1</span> running,   <span class="token number">2</span> sleeping,   <span class="token number">0</span> stopped, <span class="token number">1000</span> zombie
…<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>那么问题来了，什么是僵尸进程？它们是怎么产生的？僵尸进程太多会导致什么问题？想要回答这些问题，我们就要从进程状态的源头学习，看看僵尸进程到底处于进程整个生命周期里的哪一环。</p>
<h4 id="知识详解-1"><a href="#知识详解-1" class="headerlink" title="知识详解"></a>知识详解</h4><h5 id="Linux-的进程状态"><a href="#Linux-的进程状态" class="headerlink" title="Linux 的进程状态"></a>Linux 的进程状态</h5><p>无论进程还是线程，在 Linux 内核里其实都是用 task_struct{}这个结构来表示的。它其实就是任务（task），也就是 Linux 里基本的调度单位。为了方便讲解，我们在这里暂且称它为进程。</p>
<p>那一个进程从创建（fork）到退出（exit），这个过程中的状态转化还是很简单的。</p>
<p>下面这个图是 《Linux Kernel Development》这本书里的 Linux 进程状态转化图。</p>
<p>我们从这张图中可以看出来，在进程”活着”的时候就只有两个状态：运行态（TASK_RUNNING）和睡眠态（TASK_INTERRUPTIBLE，TASK_UNINTERRUPTIBLE）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《容器实战高手课》学习笔记/Linux进程状态转化图.jpg" alt="Linux进程状态转化图"></p>
<p>那运行态和睡眠态这两种状态分别是什么意思呢？</p>
<p>运行态的意思是，无论进程是正在运行中（也就是获得了 CPU 资源），还是进程在 run queue 队列里随时可以运行，都处于这个状态。</p>
<p>我们想要查看进程是不是处于运行态，其实也很简单，比如使用 ps 命令，可以看到处于这个状态的进程显示的是 R stat。</p>
<p>睡眠态是指，进程需要等待某个资源而进入的状态，要等待的资源可以是一个信号量（Semaphore）, 或者是磁盘 I/O，这个状态的进程会被放入到 wait queue 队列里。</p>
<p>这个睡眠态具体还包括两个子状态：一个是可以被打断的（TASK_INTERRUPTIBLE），我们用 ps 查看到的进程，显示为 S stat。还有一个是不可被打断的（TASK_UNINTERRUPTIBLE），用 ps 查看进程，就显示为 D stat。</p>
<p>这两个子状态，我们在后面的课程里碰到新的问题时，会再做详细介绍，这里你只要知道这些就行了。</p>
<p>除了上面进程在活的时候的两个状态，进程在调用 do_exit() 退出的时候，还有两个状态。</p>
<p>一个是 EXIT_DEAD，也就是进程在真正结束退出的那一瞬间的状态；第二个是 <strong>EXIT_ZOMBIE 状态，这是进程在 EXIT_DEAD 前的一个状态，而我们今天讨论的僵尸进程，也就是处于这个状态中。</strong></p>
<h5 id="限制容器中进程数目"><a href="#限制容器中进程数目" class="headerlink" title="限制容器中进程数目"></a>限制容器中进程数目</h5><p>理解了 Linux 进程状态之后，我们还需要知道，在 Linux 系统中怎么限制进程数目。因为弄清楚这个问题，我们才能更深入地去理解僵尸进程的危害。</p>
<p>一台 Linux 机器上的进程总数目是有限制的。如果超过这个最大值，那么系统就无法创建出新的进程了，比如你想 SSH 登录到这台机器上就不行了。</p>
<p>这个最大值可以我们在 /proc/sys/kernel/pid_max 这个参数中看到。</p>
<p>Linux 内核在初始化系统的时候，会根据机器 CPU 的数目来设置 pid_max 的值。</p>
<p>比如说，如果机器中 CPU 数目小于等于 32，那么 pid_max 就会被设置为 32768（32K）；如果机器中的 CPU 数目大于 32，那么 pid_max 就被设置为 N*1024 （N 就是 CPU 数目）。</p>
<p>对于 Linux 系统而言，容器就是一组进程的集合。如果容器中的应用创建过多的进程或者出现 bug，就会产生类似 fork bomb 的行为。</p>
<p>这个 fork bomb 就是指在计算机中，通过不断建立新进程来消耗系统中的进程资源，它是一种黑客攻击方式。这样，容器中的进程数就会把整个节点的可用进程总数给消耗完。</p>
<p>这样，不但会使同一个节点上的其他容器无法工作，还会让宿主机本身也无法工作。所以对于每个容器来说，我们都需要限制它的最大进程数目，而这个功能由 pids Cgroup 这个子系统来完成。</p>
<p>而这个功能的实现方法是这样的：pids Cgroup 通过 Cgroup 文件系统的方式向用户提供操作接口，一般它的 Cgroup 文件系统挂载点在 /sys/fs/cgroup/pids。</p>
<p>在一个容器建立之后，创建容器的服务会在 /sys/fs/cgroup/pids 下建立一个子目录，就是一个控制组，控制组里 <strong>最关键的一个文件就是 pids.max</strong> 。我们可以向这个文件写入数值，而这个值就是这个容器中允许的最大进程数目。</p>
<p>我们对这个值做好限制，容器就不会因为创建出过多进程而影响到其他容器和宿主机了。思路讲完了，接下来我们就实际上手试一试。</p>
<p>下面是对一个 Docker 容器的 pids Cgroup 的操作，你可以跟着操作一下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">pwd</span>
/sys/fs/cgroup/pids

$ <span class="token function">df</span> ./
Filesystem     1K-blocks  Used Available Use% Mounted on
cgroup                 <span class="token number">0</span>     <span class="token number">0</span>         <span class="token number">0</span>    - /sys/fs/cgroup/pids

$ docker <span class="token function">ps</span>
CONTAINER ID        IMAGE                      COMMAND                  CREATED             STATUS              PORTS               NAMES
7ecd3aa7fdc1        registry/zombie-proc:v1   <span class="token string">"/app-test 1000"</span>         <span class="token number">37</span> hours ago        Up <span class="token number">37</span> hours                             frosty_yalow

$ <span class="token builtin class-name">pwd</span>
/sys/fs/cgroup/pids/system.slice/docker-7ecd3aa7fdc15a1e183813b1899d5d939beafb11833ad6c8b0432536e5b9871c.scope

$ <span class="token function">ls</span>
cgroup.clone_children  cgroup.procs  notify_on_release  pids.current  pids.events  pids.max  tasks

$ <span class="token builtin class-name">echo</span> <span class="token number">1002</span> <span class="token operator">&gt;</span> pids.max

$ <span class="token function">cat</span> pids.max
<span class="token number">1002</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h4><p>刚才我给你解释了两个基本概念，进程状态和进程数目限制，那我们现在就可以解决容器中的僵尸进程问题了。</p>
<p>在前面 Linux 进程状态的介绍里，我们知道了，僵尸进程是 Linux 进程退出状态的一种。</p>
<p>从内核进程的 do_exit() 函数我们也可以看到，这时候进程 task_struct 里的 mm/shm/sem/files 等文件资源都已经释放了，只留下了一个 stask_struct instance 空壳。</p>
<p>就像下面这段代码显示的一样，从进程对应的 <code>/proc/&lt;pid&gt;</code> 文件目录下，我们也可以看出来，对应的资源都已经没有了。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /proc/6/cmdline
<span class="token function">cat</span> /proc/6/smaps
<span class="token function">cat</span> /proc/6/maps
<span class="token function">ls</span> /proc/6/fd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>并且，这个进程也已经不响应任何的信号了，无论 SIGTERM(15) 还是 SIGKILL(9)。例如上面 pid 6 的僵尸进程，这两个信号都已经被响应了。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">kill</span> -15 <span class="token number">6</span>
$ <span class="token function">kill</span> -9 <span class="token number">6</span>
$ <span class="token function">ps</span> -ef <span class="token operator">|</span> <span class="token function">grep</span> <span class="token number">6</span>
root         <span class="token number">6</span>     <span class="token number">1</span>  <span class="token number">0</span> <span class="token number">13</span>:59 ?        00:00:00 <span class="token punctuation">[</span>app-test<span class="token punctuation">]</span> <span class="token operator">&lt;</span>defunct<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>当多个容器运行在同一个宿主机上的时候，为了避免一个容器消耗完我们整个宿主机进程号资源，我们会配置 pids Cgroup 来限制每个容器的最大进程数目。也就是说，进程数目在每个容器中也是有限的，是一种很宝贵的资源。</p>
<p>既然进程号资源在宿主机上是有限的，显然残留的僵尸进程多了以后，给系统带来最大问题就是它占用了进程号。 <strong>这就意味着，残留的僵尸进程，在容器里仍然占据着进程号资源，很有可能会导致新的进程不能运转。</strong></p>
<p>这里我再次借用开头的那个例子，也就是一个产生了 1000 个僵尸进程的容器，带你理解一下这个例子中进程数的上限。我们可以看一下，1 个 init 进程 +1000 个僵尸进程 +1 个 bash 进程 ，总共就是 1002 个进程。</p>
<p>如果 pids Cgroup 也限制了这个容器的最大进程号的数量，限制为 1002 的话，我们在 pids Cgroup 里可以看到，pids.current == pids.max，也就是已经达到了容器进程号数的上限。</p>
<p>这时候，如果我们在容器里想再启动一个进程，例如运行一下 ls 命令，就会看到 Resource temporarily unavailable 的错误消息。已经退出的无用进程，却阻碍了有用进程的启动，显然这样是不合理的。</p>
<p>具体代码如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">### On host</span>
$ docker <span class="token function">ps</span>
CONTAINER ID        IMAGE                      COMMAND             CREATED             STATUS              PORTS               NAMES
09e6e8e16346        registry/zombie-proc:v1   <span class="token string">"/app-test 1000"</span>    <span class="token number">29</span> minutes ago      Up <span class="token number">29</span> minutes                           peaceful_ritchie

$ <span class="token builtin class-name">pwd</span>
/sys/fs/cgroup/pids/system.slice/docker-09e6e8e1634612580a03dd3496d2efed2cf2a510b9688160b414ce1d1ea3e4ae.scope

$ <span class="token function">cat</span> pids.max
<span class="token number">1002</span>

$ <span class="token function">cat</span> pids.current
<span class="token number">1002</span>

<span class="token comment">### On Container</span>
<span class="token punctuation">[</span>root@09e6e8e16346 /<span class="token punctuation">]</span>$ <span class="token function">ls</span>
bash: fork: retry: Resource temporarily unavailable
bash: fork: retry: Resource temporarily unavailable<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>所以，接下来我们还要看看这些僵尸进程到底是怎么产生的。因为只有理解它的产生机制，我们才能想明白怎么避免僵尸进程的出现。</p>
<p>我们先看一下刚才模拟僵尸进程的那段小程序。这段程序里，父进程在创建完子进程之后就不管了，这就是造成子进程变成僵尸进程的原因。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">int</span> total<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        total <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        total <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"To create %d processes\n"</span><span class="token punctuation">,</span> total<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> total<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        pid_t pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child =&gt; PPID: %d PID: %d\n"</span><span class="token punctuation">,</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                   <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child process eixts\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_SUCCESS<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Parent created child %d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Unable to create child process. %d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Paraent is sleeping\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> EXIT_SUCCESS<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>前面我们通过分析，发现子进程变成僵尸进程的原因在于父进程”不负责”，那找到原因后，我们再想想，如何来解决。</p>
<p>其实解决思路很好理解，就好像熊孩子犯了事儿，你要去找他家长来管教，那子进程在容器里”赖着不走”，我们就需要让父进程出面处理了。</p>
<p>所以，在 Linux 中的进程退出之后，如果进入僵尸状态，我们就需要父进程调用 wait() 这个系统调用，去回收僵尸进程的最后的那些系统资源，比如进程号资源。</p>
<p>那么，我们在刚才那段代码里，主进程进入 sleep(100) 之前，加上一段 wait() 函数调用，就不会出现僵尸进程的残留了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> total<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> status<span class="token punctuation">;</span>
    <span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>而容器中所有进程的最终父进程，就是我们所说的 init 进程，由它负责生成容器中的所有其他进程。因此，容器的 init 进程有责任回收容器中的所有僵尸进程。</p>
<p>前面我们知道了 wait() 系统调用可以回收僵尸进程，但是 wait() 系统调用有一个问题，需要你注意。</p>
<p>wait() 系统调用是一个阻塞的调用，也就是说，如果没有子进程是僵尸进程的话，这个调用就一直不会返回，那么整个进程就会被阻塞住，而不能去做别的事了。</p>
<p>不过这也没有关系，我们还有另一个方法处理。Linux 还提供了一个类似的系统调用 waitpid()，这个调用的参数更多。</p>
<p>其中就有一个参数 WNOHANG，它的含义就是，如果在调用的时候没有僵尸进程，那么函数就马上返回了，而不会像 wait() 调用那样一直等待在那里。</p>
<p>比如社区的一个 <a target="_blank" rel="noopener" href="https://github.com/krallin/tini">容器 init 项目 tini</a> 。在这个例子中，它的主进程里，就是不断在调用带 WNOHANG 参数的 waitpid()，通过这个方式清理容器中所有的僵尸进程。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">reap_zombies</span><span class="token punctuation">(</span><span class="token keyword">const</span> pid_t child_pid<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> <span class="token keyword">const</span> child_exitcode_ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    pid_t current_pid<span class="token punctuation">;</span>
    <span class="token keyword">int</span> current_status<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        current_pid <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>current_status<span class="token punctuation">,</span> WNOHANG<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span>current_pid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">case</span> <span class="token operator">-</span><span class="token number">1</span><span class="token operator">:</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> ECHILD<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">PRINT_TRACE</span><span class="token punctuation">(</span><span class="token string">"No child to wait"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
…
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="重点总结-2"><a href="#重点总结-2" class="headerlink" title="重点总结"></a>重点总结</h4><p>首先，我们先用代码来模拟了这个情况，还原了在一个容器中大量的僵尸进程是如何产生的。为了理解它的产生原理和危害，我们先要掌握两个知识点：</p>
<ul>
<li>Linux 进程状态中，僵尸进程处于 EXIT_ZOMBIE 这个状态；</li>
<li>容器需要对最大进程数做限制。具体方法是这样的，我们可以向 Cgroup 中 pids.max 这个文件写入数值（这个值就是这个容器中允许的最大进程数目）。</li>
</ul>
<p>掌握了基本概念之后，我们找到了僵尸进程的产生原因。父进程在创建完子进程之后就不管了。</p>
<p>所以，我们需要父进程调用 wait() 或者 waitpid() 系统调用来避免僵尸进程产生。</p>
<p>关于本节内容，你只要记住下面三个主要的知识点就可以了：</p>
<ol>
<li>每一个 Linux 进程在退出的时候都会进入一个僵尸状态（EXIT_ZOMBIE）；</li>
<li>僵尸进程如果不清理，就会消耗系统中的进程数资源，最坏的情况是导致新的进程无法启动；</li>
<li>僵尸进程一定需要父进程调用 wait() 或者 waitpid() 系统调用来清理，这也是容器中 init 进程必须具备的一个功能。</li>
</ol>
<h4 id="思考题-1"><a href="#思考题-1" class="headerlink" title="思考题"></a>思考题</h4><p>如果容器的 init 进程创建了子进程 B，B 又创建了自己的子进程 C。如果 C 运行完之后，退出成了僵尸进程，B 进程还在运行，而容器的 init 进程还在不断地调用 waitpid()，那 C 这个僵尸进程可以被回收吗？</p>
<p>C 应该不会被回收，waitpid 仅等待直接 children 的状态变化。</p>
<h3 id="04-理解进程（3）：为什么我在容器中的进程被强制杀死了？"><a href="#04-理解进程（3）：为什么我在容器中的进程被强制杀死了？" class="headerlink" title="04 | 理解进程（3）：为什么我在容器中的进程被强制杀死了？"></a>04 | 理解进程（3）：为什么我在容器中的进程被强制杀死了？</h3><p>今天我们来讲容器中 init 进程的最后一讲，为什么容器中的进程被强制杀死了。理解了这个问题，能够帮助你更好地管理进程，让容器中的进程可以 graceful shutdown。</p>
<p>我先给你说说，为什么进程管理中做到这点很重要。在实际生产环境中，我们有不少应用在退出的时候需要做一些清理工作，比如清理一些远端的链接，或者是清除一些本地的临时数据。</p>
<p>这样的清理工作，可以尽可能避免远端或者本地的错误发生，比如减少丢包等问题的出现。而这些退出清理的工作，通常是在 SIGTERM 这个信号用户注册的 handler 里进行的。</p>
<p>但是，如果我们的进程收到了 SIGKILL，那应用程序就没机会执行这些清理工作了。这就意味着，一旦进程不能 graceful shutdown，就会增加应用的出错率。</p>
<p>所以接下来，我们来重现一下，进程在容器退出时都发生了什么。</p>
<h4 id="场景再现"><a href="#场景再现" class="headerlink" title="场景再现"></a>场景再现</h4><p>在容器平台上，你想要停止一个容器，无论是在 Kubernetes 中去删除一个 pod，或者用 Docker 停止一个容器，最后都会用到 Containerd 这个服务。</p>
<p>而 Containerd 在停止容器的时候，就会向容器的 init 进程发送一个 SIGTERM 信号。</p>
<p>我们会发现，在 init 进程退出之后，容器内的其他进程也都立刻退出了。不过不同的是，init 进程收到的是 SIGTERM 信号，而其他进程收到的是 SIGKILL 信号。</p>
<p>在理解进程的第一讲中，我们提到过 SIGKILL 信号是不能被捕获的（catch）的，也就是用户不能注册自己的 handler，而 SIGTERM 信号却允许用户注册自己的 handler，这样的话差别就很大了。</p>
<p>那么，我们就一起来看看当容器退出的时候，如何才能让容器中的进程都收到 SIGTERM 信号，而不是 SIGKILL 信号。</p>
<p>延续前面课程中处理问题的思路，我们同样可以运行一个简单的容器，来重现这个问题，用这里的 <a target="_blank" rel="noopener" href="https://github.com/chengyli/training/tree/main/init_proc/fwd_sig">代码</a> 执行一下 make image ，然后用 Docker 启动这个容器镜像。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -d --name fwd_sig registry/fwd_sig:v1 /c-init-sig<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>你会发现，在我们用 docker stop 停止这个容器的时候，如果用 strace 工具来监控，就能看到容器里的 init 进程和另外一个进程收到的信号情况。</p>
<p>在下面的例子里，进程号为 15909 的就是容器里的 init 进程，而进程号为 15959 的是容器里另外一个进程。</p>
<p>在命令输出中我们可以看到，<strong>init 进程（15909）收到的是 SIGTERM 信号，而另外一个进程（15959）收到的果然是 SIGKILL 信号。</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ps</span> -ef <span class="token operator">|</span> <span class="token function">grep</span> c-init-sig
root     <span class="token number">15857</span> <span class="token number">14391</span>  <span class="token number">0</span> 06:23 pts/0    00:00:00 docker run -it registry/fwd_sig:v1 /c-init-sig
root     <span class="token number">15909</span> <span class="token number">15879</span>  <span class="token number">0</span> 06:23 pts/0    00:00:00 /c-init-sig
root     <span class="token number">15959</span> <span class="token number">15909</span>  <span class="token number">0</span> 06:23 pts/0    00:00:00 /c-init-sig
root     <span class="token number">16046</span> <span class="token number">14607</span>  <span class="token number">0</span> 06:23 pts/3    00:00:00 <span class="token function">grep</span> --color<span class="token operator">=</span>auto c-init-sig

$ <span class="token function">strace</span> -p <span class="token number">15909</span>
strace: Process <span class="token number">15909</span> attached
restart_syscall<span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token punctuation">..</span>. resuming interrupted <span class="token builtin class-name">read</span> <span class="token punctuation">..</span>.<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">=</span> ? ERESTART_RESTARTBLOCK <span class="token punctuation">(</span>Interrupted by signal<span class="token punctuation">)</span>
--- SIGTERM <span class="token punctuation">{</span>si_signo<span class="token operator">=</span>SIGTERM, <span class="token assign-left variable">si_code</span><span class="token operator">=</span>SI_USER, <span class="token assign-left variable">si_pid</span><span class="token operator">=</span><span class="token number">0</span>, <span class="token assign-left variable">si_uid</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">}</span> ---
write<span class="token punctuation">(</span><span class="token number">1</span>, <span class="token string">"received SIGTERM<span class="token entity" title="\n">\n</span>"</span>, <span class="token number">17</span><span class="token punctuation">)</span>      <span class="token operator">=</span> <span class="token number">17</span>
exit_group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                           <span class="token operator">=</span> ?
+++ exited with <span class="token number">0</span> +++

$ <span class="token function">strace</span> -p <span class="token number">15959</span>
strace: Process <span class="token number">15959</span> attached
restart_syscall<span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token punctuation">..</span>. resuming interrupted <span class="token builtin class-name">read</span> <span class="token punctuation">..</span>.<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">=</span> ?
+++ killed by SIGKILL +++<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="知识详解：信号的两个系统调用"><a href="#知识详解：信号的两个系统调用" class="headerlink" title="知识详解：信号的两个系统调用"></a>知识详解：信号的两个系统调用</h4><p>我们想要理解刚才的例子，就需要搞懂信号背后的两个系统调用，它们分别是 kill() 系统调用和 signal() 系统调用。</p>
<p>这里呢，我们可以结合前面讲过的信号来理解这两个系统调用。在容器 init 进程的第一讲里，我们介绍过信号的基本概念了， <strong>信号就是 Linux 进程收到的一个通知。</strong></p>
<p>等你学完如何使用这两个系统调用之后，就会更清楚 Linux 信号是怎么一回事，遇到容器里信号相关的问题，你就能更好地理清思路了。</p>
<p>我还会再给你举个使用函数的例子，帮助你进一步理解进程是如何实现 graceful shutdown 的。</p>
<p>进程对信号的处理其实就包括两个问题， <strong>一个是进程如何发送信号，另一个是进程收到信号后如何处理。</strong></p>
<p>我们在 Linux 中发送信号的系统调用是 kill()，之前很多例子里面我们用的命令 kill ，它内部的实现就是调用了 kill() 这个函数。</p>
<p>下面是 Linux Programmer’s Manual 里对 kill() 函数的定义。</p>
<p>这个函数有两个参数，一个是 sig，代表需要发送哪个信号，比如 sig 的值是 15 的话，就是指发送 SIGTERM；另一个参数是 pid，也就是指信号需要发送给哪个进程，比如值是 1 的话，就是指发送给进程号是 1 的进程。</p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">NAME
       kill - send signal to a process

SYNOPSIS
       #include &lt;sys/types.h&gt;
       #include &lt;signal.h&gt;
       int kill(pid_t pid, int sig);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们知道了发送信号的系统调用之后，再来看另一个系统调用，也就是 signal() 系统调用这个函数，它可以给信号注册 handler。</p>
<p>下面是 signal() 在 Linux Programmer’s Manual 里的定义，参数 signum 也就是信号的编号，例如数值 15，就是信号 SIGTERM；参数 handler 是一个函数指针参数，用来注册用户的信号 handler。</p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">NAME
       signal - ANSI C signal handling

SYNOPSIS
       #include &lt;signal.h&gt;
       typedef void (*sighandler_t)(int);
       sighandler_t signal(int signum, sighandler_t handler);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在容器 init 进程的第一讲里，我们学过 <strong>进程对每种信号的处理，包括三个选择：调用系统缺省行为、捕获、忽略</strong> 。而这里的选择，其实就是程序中如何去调用 signal() 这个系统调用。</p>
<p>第一个选择就是缺省，如果我们在代码中对某个信号，比如 SIGTERM 信号，不做任何 signal() 相关的系统调用，那么在进程运行的时候，如果接收到信号 SIGTERM，进程就会执行内核中 SIGTERM 信号的缺省代码。</p>
<p>对于 SIGTERM 这个信号来说，它的缺省行为就是进程退出（terminate）。</p>
<p>内核中对不同的信号有不同的缺省行为，一般会采用退出（terminate），暂停（stop），忽略（ignore）这三种行为中的一种。</p>
<p>那第二个选择捕获又是什么意思呢?</p>
<p>捕获指的就是我们在代码中为某个信号，调用 signal() 注册自己的 handler。这样进程在运行的时候，一旦接收到信号，就不会再去执行内核中的缺省代码，而是会执行通过 signal() 注册的 handler。</p>
<p>比如下面这段代码，我们为 SIGTERM 这个信号注册了一个 handler，在 handler 里只是做了一个打印操作。</p>
<p>那么这个程序在运行的时候，如果收到 SIGTERM 信号，它就不会退出了，而是只在屏幕上显示出”received SIGTERM”。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sig_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> signo<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>signo <span class="token operator">==</span> SIGTERM<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"received SIGTERM\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token function">signal</span><span class="token punctuation">(</span>SIGTERM<span class="token punctuation">,</span> sig_handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们再来看看第三个选择，如果要让进程”忽略”一个信号，我们就要通过 signal() 这个系统调用，为这个信号注册一个特殊的 handler，也就是 SIG_IGN 。</p>
<p>比如下面的这段代码，就是为 SIGTERM 这个信号注册SIG_IGN。</p>
<p>这样操作的效果，就是在程序运行的时候，如果收到 SIGTERM 信号，程序既不会退出，也不会在屏幕上输出 log，而是什么反应也没有，就像完全没有收到这个信号一样。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token function">signal</span><span class="token punctuation">(</span>SIGTERM<span class="token punctuation">,</span> SIG_IGN<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>好了，我们通过讲解 signal() 这个系统调用，帮助你回顾了信号处理的三个选择：缺省行为、捕获和忽略。</p>
<p>这里我还想要提醒你一点， <strong>SIGKILL 和 SIGSTOP 信号是两个特权信号，它们不可以被捕获和忽略，这个特点也反映在 signal() 调用上。</strong></p>
<p>我们可以运行下面的 <a target="_blank" rel="noopener" href="https://github.com/chengyli/training/blob/main/init_proc/basic_sig/reg-sigkill.c">这段代码</a> ，如果我们用 signal() 为 SIGKILL 注册 handler，那么它就会返回 SIG_ERR，不允许我们做捕获操作。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> reg_sigkill.c
<span class="token comment">#include &lt;stdio.h&gt;</span>
<span class="token comment">#include &lt;stdlib.h&gt;</span>
<span class="token comment">#include &lt;unistd.h&gt;</span>
<span class="token comment">#include &lt;errno.h&gt;</span>
<span class="token comment">#include &lt;signal.h&gt;</span>
typedef void <span class="token punctuation">(</span>*sighandler_t<span class="token punctuation">)</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span><span class="token punctuation">;</span>
void sig_handler<span class="token punctuation">(</span>int signo<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>signo <span class="token operator">==</span> SIGKILL<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        printf<span class="token punctuation">(</span><span class="token string">"received SIGKILL<span class="token entity" title="\n">\n</span>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        exit<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

int main<span class="token punctuation">(</span>int argc, char *argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
            sighandler_t h_ret<span class="token punctuation">;</span>
            h_ret <span class="token operator">=</span> signal<span class="token punctuation">(</span>SIGKILL, sig_handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>h_ret <span class="token operator">==</span> SIG_ERR<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        perror<span class="token punctuation">(</span><span class="token string">"SIG_ERR"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token builtin class-name">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

$ ./reg_sigkill
SIG_ERR: Invalid argument<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后，我用下面 <a target="_blank" rel="noopener" href="https://github.com/chengyli/training/blob/main/init_proc/basic_sig/basic-sig.c">这段代码</a> 来做个小结。</p>
<p>这段代码里，我们用 signal() 对 SIGTERM 这个信号做了忽略，捕获以及恢复它的缺省行为，并且每一次都用 kill() 系统调用向进程自己发送 SIGTERM 信号，这样做可以确认进程对 SIGTERM 信号的选择。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>

<span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>sighandler_t<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">sig_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> signo<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>signo <span class="token operator">==</span> SIGTERM<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"received SIGTERM\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// Set SIGTERM handler to default</span>
                <span class="token function">signal</span><span class="token punctuation">(</span>SIGTERM<span class="token punctuation">,</span> SIG_DFL<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token comment">//Ignore SIGTERM, and send SIGTERM</span>
        <span class="token comment">// to process itself.</span>
        <span class="token function">signal</span><span class="token punctuation">(</span>SIGTERM<span class="token punctuation">,</span> SIG_IGN<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Ignore SIGTERM\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">kill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> SIGTERM<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//Catch SIGERM, and send SIGTERM</span>
        <span class="token comment">// to process itself.</span>
        <span class="token function">signal</span><span class="token punctuation">(</span>SIGTERM<span class="token punctuation">,</span> sig_handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Catch SIGTERM\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">kill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> SIGTERM<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//Default SIGTERM. In sig_handler, it sets</span>
        <span class="token comment">//SIGTERM handler back to default one.</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Default SIGTERM\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">kill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> SIGTERM<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们一起来总结一下刚才讲的两个系统调用：</p>
<p>先说说 kill() 这个系统调用，它其实很简单，输入两个参数：进程号和信号，就把特定的信号发送给指定的进程了。</p>
<p>再说说 signal() 这个调用，它决定了进程收到特定的信号如何来处理，SIG_DFL 参数把对应信号恢复为缺省 handler，也可以用自定义的函数作为 handler，或者用 SIG_IGN 参数让进程忽略信号。</p>
<p>对于 SIGKILL 信号，如果调用 signal() 函数，为它注册自定义的 handler，系统就会拒绝。</p>
<h4 id="解决问题-1"><a href="#解决问题-1" class="headerlink" title="解决问题"></a>解决问题</h4><p>我们在学习了 kill() 和 signal() 这个两个信号相关的系统调用之后，再回到这一讲最初的问题上，为什么在停止一个容器的时候，容器 init 进程收到的 SIGTERM 信号，而容器中其他进程却会收到 SIGKILL 信号呢？</p>
<p>当 Linux 进程收到 SIGTERM 信号并且使进程退出，这时 Linux 内核对处理进程退出的入口点就是 do_exit() 函数，do_exit() 函数中会释放进程的相关资源，比如内存，文件句柄，信号量等等。</p>
<p>Linux 内核对处理进程退出的入口点就是 do_exit() 函数，do_exit() 函数中会释放进程的相关资源，比如内存，文件句柄，信号量等等。</p>
<p>在做完这些工作之后，它会调用一个 exit_notify() 函数，用来通知和这个进程相关的父子进程等。</p>
<p>对于容器来说，还要考虑 Pid Namespace 里的其他进程。这里调用的就是 zap_pid_ns_processes() 这个函数，而在这个函数中，如果是处于退出状态的 init 进程，它会向 Namespace 中的其他进程都发送一个 SIGKILL 信号。</p>
<p>整个流程如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《容器实战高手课》学习笔记/进程退出流程.jpg" alt="进程退出流程"></p>
<p>你还可以看一下， <a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/d895ec7938c431fe61a731939da76a6461bc6133/kernel/pid_namespace.c#L166">内核代码</a> 是这样的。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
       * The last thread in the cgroup-init thread group is terminating.
       * Find remaining pid_ts in the namespace, signal and wait for them
       * to exit.
       *
       * Note:  This signals each threads in the namespace - even those that
       *        belong to the same thread group, To avoid this, we would have
       *        to walk the entire tasklist looking a processes in this
       *        namespace, but that could be unnecessarily expensive if the
       *        pid namespace has just a few processes. Or we need to
       *        maintain a tasklist for each pid namespace.
       *
       */</span>
   <span class="token function">rcu_read_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token function">read_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tasklist_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
   nr <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
   <span class="token function">idr_for_each_entry_continue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pid_ns<span class="token operator">-&gt;</span>idr<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> nr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           task <span class="token operator">=</span> <span class="token function">pid_task</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> PIDTYPE_PID<span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">__fatal_signal_pending</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span>
                   <span class="token function">group_send_sig_info</span><span class="token punctuation">(</span>SIGKILL<span class="token punctuation">,</span> SEND_SIG_PRIV<span class="token punctuation">,</span> task<span class="token punctuation">,</span> PIDTYPE_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>说到这里，我们也就明白为什么容器 init 进程收到的 SIGTERM 信号，而容器中其他进程却会收到 SIGKILL 信号了。</p>
<p>前面我讲过，SIGKILL 是个特权信号（特权信号是 Linux 为 kernel 和超级用户去删除任意进程所保留的，不能被忽略也不能被捕获）。</p>
<p>所以进程收到这个信号后，就立刻退出了，没有机会调用一些释放资源的 handler 之后，再做退出动作。</p>
<p>而 SIGTERM 是可以被捕获的，用户是可以注册自己的 handler 的。因此，容器中的程序在 stop container 的时候，我们更希望进程收到 SIGTERM 信号而不是 SIGKILL 信号。</p>
<p>那在容器被停止的时候，我们该怎么做，才能让容器中的进程收到 SIGTERM 信号呢？</p>
<p>你可能已经想到了，就是让容器 init 进程来转发 SIGTERM 信号。的确是这样，比如 Docker Container 里使用的 tini 作为 init 进程，tini 的代码中就会调用 sigtimedwait() 这个函数来查看自己收到的信号，然后调用 kill() 把信号发给子进程。</p>
<p>我给你举个具体的例子说明，从下面的这段代码中，我们可以看到除了 SIGCHLD 这个信号外，tini 会把其他所有的信号都转发给它的子进程。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">wait_and_forward_signal</span><span class="token punctuation">(</span>sigset_t <span class="token keyword">const</span><span class="token operator">*</span> <span class="token keyword">const</span> parent_sigset_ptr<span class="token punctuation">,</span> pid_t <span class="token keyword">const</span> child_pid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    siginfo_t sig<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sigtimedwait</span><span class="token punctuation">(</span>parent_sigset_ptr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sig<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ts<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">switch</span> <span class="token punctuation">(</span>errno<span class="token punctuation">)</span> <span class="token punctuation">{</span>
…
            <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">/* There is a signal to handle here */</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span>sig<span class="token punctuation">.</span>si_signo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> SIGCHLD<span class="token operator">:</span>
            <span class="token comment">/* Special-cased, as we don't forward SIGCHLD. Instead, we'll
                * fallthrough to reaping processes.
                */</span>
            <span class="token function">PRINT_DEBUG</span><span class="token punctuation">(</span><span class="token string">"Received SIGCHLD"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
            <span class="token function">PRINT_DEBUG</span><span class="token punctuation">(</span><span class="token string">"Passing signal: '%s'"</span><span class="token punctuation">,</span> <span class="token function">strsignal</span><span class="token punctuation">(</span>sig<span class="token punctuation">.</span>si_signo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">/* Forward anything else */</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">kill</span><span class="token punctuation">(</span>kill_process_group <span class="token operator">?</span> <span class="token operator">-</span>child_pid <span class="token operator">:</span> child_pid<span class="token punctuation">,</span> sig<span class="token punctuation">.</span>si_signo<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> ESRCH<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">PRINT_WARNING</span><span class="token punctuation">(</span><span class="token string">"Child was dead when forwarding signal"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    <span class="token function">PRINT_FATAL</span><span class="token punctuation">(</span><span class="token string">"Unexpected error when forwarding signal: '%s'"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>那么我们在这里明确一下，怎么解决停止容器的时候，容器内应用程序被强制杀死的问题呢？</p>
<p><strong>解决的方法就是在容器的 init 进程中对收到的信号做个转发，发送到容器中的其他子进程，这样容器中的所有进程在停止时，都会收到 SIGTERM，而不是 SIGKILL 信号了。</strong></p>
<h4 id="重点小结"><a href="#重点小结" class="headerlink" title="重点小结"></a>重点小结</h4><p>这一讲我们要解决的问题是让容器中的进程，在容器停止的时候，有机会 graceful shutdown，而不是收到 SIGKILL 信号而被强制杀死。</p>
<p>首先我们通过对 kill() 和 signal() 这个两个系统调用的学习，进一步理解了进程是怎样处理 Linux 信号的，重点是信号在接收处理的三个选择： <strong>忽略，捕获和缺省行为。</strong></p>
<p>通过代码例子，我们知道 SIGTERM 是可以被忽略和捕获的，但是 SIGKILL 是不可以被忽略和捕获的。</p>
<p>了解这一点以后，我们就找到了问题的解决方向，也就是我们需要在停止容器时，让容器中的应用收到 SIGTERM，而不是 SIGKILL。</p>
<p>具体怎么操作呢？我们可以在容器的 init 进程中对收到的信号做个转发，发送到容器中的其他子进程。这样一来，容器中的所有进程在停止容器时，都会收到 SIGTERM，而不是 SIGKILL 信号了。</p>
<p>我认为，解决 init 进程信号的这类问题其实并不难。</p>
<p>我们只需要先梳理一下和这个问题相关的几个知识点，再写个小程序，让它跑在容器里，稍微做几个试验。然后，我们再看一下内核和 Docker 的源代码，就可以很快得出结论了。</p>
<h3 id="05｜容器CPU（1）：怎么限制容器的CPU使用？"><a href="#05｜容器CPU（1）：怎么限制容器的CPU使用？" class="headerlink" title="05｜容器CPU（1）：怎么限制容器的CPU使用？"></a>05｜容器CPU（1）：怎么限制容器的CPU使用？</h3><p>我在第一讲中给你讲过，容器在 Linux 系统中最核心的两个概念是 Namespace 和 Cgroups。我们可以通过 Cgroups 技术限制资源。这个资源可以分为很多类型，比如 CPU，Memory，Storage，Network 等等。而计算资源是最基本的一种资源，所有的容器都需要这种资源。</p>
<p>那么，今天我们就先聊一聊，怎么限制容器的 CPU 使用？</p>
<p>我们拿 Kubernetes 平台做例子，具体来看下面这个 pod/container 里的 spec 定义，在 CPU 资源相关的定义中有两项内容，分别是 <strong>Request CPU</strong> 和 <strong>Limit CPU</strong> 。</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> frontend
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> app
    <span class="token key atrule">image</span><span class="token punctuation">:</span> images.my<span class="token punctuation">-</span>company.example/app<span class="token punctuation">:</span>v4
    <span class="token key atrule">env</span><span class="token punctuation">:</span>
    <span class="token key atrule">resources</span><span class="token punctuation">:</span>
      <span class="token key atrule">requests</span><span class="token punctuation">:</span>
        <span class="token key atrule">memory</span><span class="token punctuation">:</span> <span class="token string">"64Mi"</span>
        <span class="token key atrule">cpu</span><span class="token punctuation">:</span> <span class="token string">"1"</span>
      <span class="token key atrule">limits</span><span class="token punctuation">:</span>
        <span class="token key atrule">memory</span><span class="token punctuation">:</span> <span class="token string">"128Mi"</span>
        <span class="token key atrule">cpu</span><span class="token punctuation">:</span> <span class="token string">"2"</span>
…<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>很多刚刚使用 Kubernetes 的同学，可能一开始并不理解这两个参数有什么作用。</p>
<p>这里我先给你说结论，在 Pod Spec 里的”Request CPU”和”Limit CPU”的值，最后会通过 CPU Cgroup 的配置，来实现控制容器 CPU 资源的作用。</p>
<p>那接下来我会先从进程的 CPU 使用讲起，然后带你在 CPU Cgroup 子系统中建立几个控制组，用这个例子为你讲解 CPU Cgroup 中的三个最重要的参数”cpu.cfs_quota_us””cpu.cfs_period_us””cpu.shares”。</p>
<p>相信理解了这三个参数后，你就会明白我们要怎样限制容器 CPU 的使用了。</p>
<h4 id="如何理解-CPU-使用和-CPU-Cgroup？"><a href="#如何理解-CPU-使用和-CPU-Cgroup？" class="headerlink" title="如何理解 CPU 使用和 CPU Cgroup？"></a>如何理解 CPU 使用和 CPU Cgroup？</h4><p>既然我们需要理解 CPU  Cgroup，那么就有必要先来看一下 Linux 里的 CPU 使用的概念，这是因为 CPU Cgroup 最大的作用就是限制 CPU 使用。</p>
<h5 id="CPU-使用的分类"><a href="#CPU-使用的分类" class="headerlink" title="CPU 使用的分类"></a>CPU 使用的分类</h5><p>如果你想查看 Linux 系统的 CPU 使用的话，会用什么方法呢？最常用的肯定是运行 Top 了。</p>
<p>我们对照下图的 Top 运行界面，在截图第三行，”%Cpu(s)”开头的这一行，你会看到一串数值，也就是”0.0 us, 0.0 sy, 0.0 ni, 99.9 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st”，那么这里的每一项值都是什么含义呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《容器实战高手课》学习笔记/容器CPU1一.png" alt="容器CPU1一"></p>
<p>下面这张图里最长的带箭头横轴，我们可以把它看成一个时间轴。同时，它的上半部分代表 Linux 用户态（User space），下半部分代表内核态（Kernel space）。这里为了方便你理解，我们先假设只有一个 CPU 吧。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《容器实战高手课》学习笔记/容器CPU1二.jpg" alt="容器CPU1二"></p>
<p>我们可以用上面这张图，把这些值挨个解释一下。</p>
<p>假设一个用户程序开始运行了，那么就对应着第一个”us”框，”us”是”user”的缩写，代表 Linux 的用户态 CPU Usage。普通用户程序代码中，只要不是调用系统调用（System Call），这些代码的指令消耗的 CPU 就都属于”us”。</p>
<p>当这个用户程序代码中调用了系统调用，比如说 read() 去读取一个文件，这时候这个用户进程就会从用户态切换到内核态。</p>
<p>内核态 read() 系统调用在读到真正 disk 上的文件前，就会进行一些文件系统层的操作。那么这些代码指令的消耗就属于”sy”，这里就对应上面图里的第二个框。”sy”是 “system”的缩写，代表内核态 CPU 使用。</p>
<p>接下来，这个 read() 系统调用会向 Linux 的 Block Layer 发出一个 I/O Request，触发一个真正的磁盘读取操作。</p>
<p>这时候，这个进程一般会被置为 TASK_UNINTERRUPTIBLE。而 Linux 会把这段时间标示成”wa”，对应图中的第三个框。”wa”是”iowait”的缩写，代表等待 I/O 的时间，这里的 I/O 是指 Disk I/O。</p>
<p>紧接着，当磁盘返回数据时，进程在内核态拿到数据，这里仍旧是内核态的 CPU 使用中的”sy”，也就是图中的第四个框。</p>
<p>然后，进程再从内核态切换回用户态，在用户态得到文件数据，这里进程又回到用户态的 CPU 使用，”us”，对应图中第五个框。</p>
<p>好，这里我们假设一下，这个用户进程在读取数据之后，没事可做就休眠了。并且我们可以进一步假设，这时在这个 CPU 上也没有其他需要运行的进程了，那么系统就会进入”id”这个步骤，也就是第六个框。”id”是”idle”的缩写，代表系统处于空闲状态。</p>
<p>如果这时这台机器在网络收到一个网络数据包，网卡就会发出一个中断（interrupt）。相应地，CPU 会响应中断，然后进入中断服务程序。</p>
<p>这时，CPU 就会进入”hi”，也就是第七个框。”hi”是”hardware irq”的缩写，代表 CPU 处理硬中断的开销。由于我们的中断服务处理需要关闭中断，所以这个硬中断的时间不能太长。</p>
<p>但是，发生中断后的工作是必须要完成的，如果这些工作比较耗时那怎么办呢？Linux 中有一个软中断的概念（softirq），它可以完成这些耗时比较长的工作。</p>
<p>你可以这样理解这个软中断，从网卡收到数据包的大部分工作，都是通过软中断来处理的。那么，CPU 就会进入到第八个框，”si”。这里”si”是”softirq”的缩写，代表 CPU 处理软中断的开销。</p>
<p>这里你要注意，无论是”hi”还是”si”，它们的 CPU 时间都不会计入进程的 CPU 时间。 <strong>这是因为本身它们在处理的时候就不属于任何一个进程。</strong></p>
<p>好了，通过这个场景假设，我们介绍了大部分的 Linux CPU 使用。</p>
<p>不过，我们还剩两个类型的 CPU 使用没讲到，我想给你做个补充，一次性带你做个全面了解。这样以后你解决相关问题时，就不会再犹豫，这些值到底影不影响 CPU Cgroup 中的限制了。下面我给你具体讲一下。</p>
<p>一个是”ni”，是”nice”的缩写，这里表示如果进程的 nice 值是正值（1-19），代表优先级比较低的进程运行时所占用的 CPU。</p>
<p>另外一个是”st”，”st”是”steal”的缩写，是在虚拟机里用的一个 CPU 使用类型，表示有多少时间是被同一个宿主机上的其他虚拟机抢走的。</p>
<p>综合前面的内容，我再用表格为你总结一下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《容器实战高手课》学习笔记/CPUUsage一览表.jpg" alt="CPUUsage一览表"></p>
<h5 id="CPU-Cgroup"><a href="#CPU-Cgroup" class="headerlink" title="CPU Cgroup"></a>CPU Cgroup</h5><p>在第一讲中，我们提到过 Cgroups 是对指定进程做计算机资源限制的，CPU  Cgroup 是 Cgroups 其中的一个 Cgroups 子系统，它是用来限制进程的 CPU 使用的。</p>
<p>对于进程的 CPU 使用, 通过前面的 Linux CPU 使用分类的介绍，我们知道它只包含两部分: 一个是用户态，这里的用户态包含了 us 和 ni；还有一部分是内核态，也就是 sy。</p>
<p>至于 wa、hi、si，这些 I/O 或者中断相关的 CPU 使用，CPU Cgroup 不会去做限制，那么接下来我们就来看看 CPU  Cgoup 是怎么工作的？</p>
<p>每个 Cgroups 子系统都是通过一个虚拟文件系统挂载点的方式，挂到一个缺省的目录下，CPU  Cgroup 一般在 Linux 发行版里会放在 /sys/fs/cgroup/cpu 这个目录下。</p>
<p>在这个子系统的目录下，每个控制组（Control Group） 都是一个子目录，各个控制组之间的关系就是一个树状的层级关系（hierarchy）。</p>
<p>比如说，我们在子系统的最顶层开始建立两个控制组（也就是建立两个目录）group1 和 group2，然后再在 group2 的下面再建立两个控制组 group3 和 group4。</p>
<p>这样操作以后，我们就建立了一个树状的控制组层级，你可以参考下面的示意图。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《容器实战高手课》学习笔记/cgroup树状控制组层级示意图.jpg" alt="cgroup树状控制组层级示意图"></p>
<p>那么我们的每个控制组里，都有哪些 CPU  Cgroup 相关的控制信息呢？这里我们需要看一下每个控制组目录中的内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">pwd</span>
/sys/fs/cgroup/cpu

$ <span class="token function">mkdir</span> group1 group2
$ <span class="token builtin class-name">cd</span> group2
$ <span class="token function">mkdir</span> group3 group4
$ <span class="token builtin class-name">cd</span> group3
$ <span class="token function">ls</span> cpu.*
cpu.cfs_period_us  cpu.cfs_quota_us  cpu.rt_period_us  cpu.rt_runtime_us  cpu.shares  cpu.stat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>考虑到在云平台里呢，大部分程序都不是实时调度的进程，而是普通调度（SCHED_NORMAL）类型进程，那什么是普通调度类型呢？</p>
<p>因为普通调度的算法在 Linux 中目前是 CFS （Completely Fair Scheduler，即完全公平调度器）。为了方便你理解，我们就直接来看 CPU Cgroup 和 CFS 相关的参数，一共有三个。</p>
<p>第一个参数是 <strong>cpu.cfs_period_us</strong> ，它是 CFS 算法的一个调度周期，一般它的值是 100000，以 microseconds 为单位，也就 100ms。</p>
<p>第二个参数是 <strong>cpu.cfs_quota_us</strong> ，它”表示 CFS 算法中，在一个调度周期里这个控制组被允许的运行时间，比如这个值为 50000 时，就是 50ms。</p>
<p>如果用这个值去除以调度周期（也就是 cpu.cfs_period_us），50ms/100ms = 0.5，这样这个控制组被允许使用的 CPU 最大配额就是 0.5 个 CPU。</p>
<p>从这里能够看出，cpu.cfs_quota_us 是一个绝对值。如果这个值是 200000，也就是 200ms，那么它除以 period，也就是 200ms/100ms=2。</p>
<p>你看，结果超过了 1 个 CPU，这就意味着这时控制组需要 2 个 CPU 的资源配额。</p>
<p>我们再来看看第三个参数， <strong>cpu.shares</strong> 。这个值是 CPU  Cgroup 对于控制组之间的 CPU 分配比例，它的缺省值是 1024。</p>
<p>假设我们前面创建的 group3 中的 cpu.shares 是 1024，而 group4 中的 cpu.shares 是 3072，那么 group3:group4=1:3。</p>
<p>这个比例是什么意思呢？我还是举个具体的例子来说明吧。</p>
<p>在一台 4 个 CPU 的机器上，当 group3 和 group4 都需要 4 个 CPU 的时候，它们实际分配到的 CPU 分别是这样的：group3 是 1 个，group4 是 3 个。</p>
<p>我们刚才讲了 CPU Cgroup 里的三个关键参数，接下来我们就通过几个例子来进一步理解一下，<a target="_blank" rel="noopener" href="https://github.com/chengyli/training/tree/main/cpu/cgroup_cpu">代码</a> 你可以在这里找到。</p>
<p>第一个例子，我们启动一个消耗 2 个 CPU（200%）的程序 threads-cpu，然后把这个程序的 pid 加入到 group3 的控制组里：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./threads-cpu/threads-cpu <span class="token number">2</span> <span class="token operator">&amp;</span>
<span class="token builtin class-name">echo</span> <span class="token variable">$!</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/cpu/group2/group3/cgroup.procs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在我们没有修改 cpu.cfs_quota_us 前，用 top 命令可以看到 threads-cpu 这个进程的 CPU  使用是 199%，近似 2 个 CPU。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《容器实战高手课》学习笔记/容器CPU1五.png" alt="容器CPU1五"></p>
<p>然后，我们更新这个控制组里的 cpu.cfs_quota_us，把它设置为 150000（150ms）。把这个值除以 cpu.cfs_period_us，计算过程是 150ms/100ms=1.5, 也就是 1.5 个 CPU，同时我们也把 cpu.shares 设置为 1024。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token number">150000</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/cpu/group2/group3/cpu.cfs_quota_us
<span class="token builtin class-name">echo</span> <span class="token number">1024</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/cpu/group2/group3/cpu.shares<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这时候我们再运行 top，就会发现 threads-cpu 进程的 CPU 使用减小到了 150%。这是因为我们设置的 cpu.cfs_quota_us 起了作用，限制了进程 CPU 的绝对值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《容器实战高手课》学习笔记/容器CPU1六.png" alt="容器CPU1六"></p>
<p>但这时候 cpu.shares 的作用还没有发挥出来，因为 cpu.shares 是几个控制组之间的 CPU 分配比例，而且一定要到整个节点中所有的 CPU 都跑满的时候，它才能发挥作用。</p>
<p>好，下面我们再来运行第二个例子来理解 cpu.shares。我们先把第一个例子里的程序启动，同时按前面的内容，一步步设置好 group3 里 cpu.cfs_quota_us 和 cpu.shares。</p>
<p>group3:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./threads-cpu/threads-cpu <span class="token number">2</span> <span class="token operator">&amp;</span>  <span class="token comment"># 启动一个消耗2个CPU的程序</span>
<span class="token builtin class-name">echo</span> <span class="token variable">$!</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/cpu/group2/group3/cgroup.procs <span class="token comment">#把程序的pid加入到控制组</span>
<span class="token builtin class-name">echo</span> <span class="token number">150000</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/cpu/group2/group3/cpu.cfs_quota_us <span class="token comment">#限制CPU为1.5CPU</span>
<span class="token builtin class-name">echo</span> <span class="token number">1024</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/cpu/group2/group3/cpu.shares<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>设置完成后，我们再启动第二个程序，并且设置好 group4 里的 cpu.cfs_quota_us 和 cpu.shares。</p>
<p>group4:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./threads-cpu/threads-cpu <span class="token number">4</span> <span class="token operator">&amp;</span>  <span class="token comment"># 启动一个消耗4个CPU的程序</span>
<span class="token builtin class-name">echo</span> <span class="token variable">$!</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/cpu/group2/group4/cgroup.procs <span class="token comment">#把程序的pid加入到控制组</span>
<span class="token builtin class-name">echo</span> <span class="token number">350000</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/cpu/group2/group4/cpu.cfs_quota_us  <span class="token comment">#限制CPU为3.5CPU</span>
<span class="token builtin class-name">echo</span> <span class="token number">3072</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/cpu/group2/group4/cpu.shares <span class="token comment"># shares 比例 group4: group3 = 3:1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>好了，现在我们的节点上总共有 4 个 CPU，而 group3 的程序需要消耗 2 个 CPU，group4 里的程序要消耗 4 个 CPU。</p>
<p>即使 cpu.cfs_quota_us 已经限制了进程 CPU 使用的绝对值，group3 的限制是 1.5CPU，group4 是 3.5CPU，1.5+3.5=5，这个结果还是超过了节点上的 4 个 CPU。</p>
<p>好了，说到这里，我们发现在这种情况下，cpu.shares 终于开始起作用了。</p>
<p>在这里 shares 比例是 group4:group3=3:1，在总共 4 个 CPU 的节点上，按照比例，group4 里的进程应该分配到 3 个 CPU，而 group3 里的进程会分配到 1 个 CPU。</p>
<p>我们用 top 可以看一下，结果和我们预期的一样。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《容器实战高手课》学习笔记/容器CPU1七.png" alt="容器CPU1七"></p>
<p>好了，我们对 CPU Cgroup 的参数做一个梳理。</p>
<p>第一点，cpu.cfs_quota_us 和 cpu.cfs_period_us 这两个值决定了 <strong>每个控制组中所有进程的可使用 CPU 资源的最大值。</strong></p>
<p>第二点，cpu.shares 这个值决定了 <strong>CPU Cgroup 子系统下控制组可用 CPU 的相对比例</strong> ，不过只有当系统上 CPU 完全被占满的时候，这个比例才会在各个控制组间起作用。</p>
<h4 id="现象解释-1"><a href="#现象解释-1" class="headerlink" title="现象解释"></a>现象解释</h4><p>在解释了 Linux CPU Usage 和 CPU Cgroup 这两个基本概念之后，我们再回到我们最初的问题 “怎么限制容器的 CPU 使用”。有了基础知识的铺垫，这个问题就比较好解释了。</p>
<p>首先，Kubernetes 会为每个容器都在 CPUCgroup 的子系统中建立一个控制组，然后把容器中进程写入到这个控制组里。</p>
<p>这时候”Limit CPU”就需要为容器设置可用 CPU 的上限。结合前面我们讲的几个参数么，我们就能知道容器的 CPU 上限具体如何计算了。</p>
<p>容器 CPU 的上限由 cpu.cfs_quota_us 除以 cpu.cfs_period_us 得出的值来决定的。而且，在操作系统里，cpu.cfs_period_us 的值一般是个固定值，Kubernetes 不会去修改它，所以我们就是只修改 cpu.cfs_quota_us。</p>
<p>而”Request CPU”就是无论其他容器申请多少 CPU 资源，即使运行时整个节点的 CPU 都被占满的情况下，我的这个容器还是可以保证获得需要的 CPU 数目，那么这个设置具体要怎么实现呢？</p>
<p>显然我们需要设置 cpu.shares 这个参数： <strong>在 CPU Cgroup 中 cpu.shares == 1024 表示 1 个 CPU 的比例，那么 Request CPU 的值就是 n，给 cpu.shares 的赋值对应就是 n*1024。</strong></p>
<h4 id="重点总结-3"><a href="#重点总结-3" class="headerlink" title="重点总结"></a>重点总结</h4><p>首先，我带你了解了 Linux 下 CPU Usage 的种类.</p>
<p>这里你要注意的是 <strong>每个进程的 CPU Usage 只包含用户态（us 或 ni）和内核态（sy）两部分，其他的系统 CPU 开销并不包含在进程的 CPU 使用中，而 CPU Cgroup 只是对进程的 CPU 使用做了限制。</strong></p>
<p>其实这一讲我们开篇的问题”怎么限制容器的 CPU 使用”，这个问题背后隐藏了另一个问题，也就是容器是如何设置它的 CPU Cgroup 中参数值的？想解决这个问题，就要先知道 CPU Cgroup 都有哪些参数。</p>
<p>所以，我详细给你介绍了 CPU Cgroup 中的主要参数，包括这三个： <strong>cpu.cfs_quota_us，cpu.cfs_period_us 还有 cpu.shares。</strong></p>
<p>其中，cpu.cfs_quota_us（一个调度周期里这个控制组被允许的运行时间）除以 cpu.cfs_period_us（用于设置调度周期）得到的这个值决定了 CPU  Cgroup 每个控制组中 CPU 使用的上限值。</p>
<p>你还需要掌握一个 cpu.shares 参数，正是这个值决定了 CPU  Cgroup 子系统下控制组可用 CPU 的相对比例，当系统上 CPU 完全被占满的时候，这个比例才会在各个控制组间起效。</p>
<p>最后，我们明白了 CPU Cgroup 关键参数是什么含义后，Kubernetes 中”Limit CPU”和 “Request CPU”也就很好解释了:</p>
<p><strong>Limit CPU 就是容器所在 Cgroup 控制组中的 CPU 上限值，Request CPU 的值就是控制组中的 cpu.shares 的值。</strong></p>
<h4 id="思考题-2"><a href="#思考题-2" class="headerlink" title="思考题"></a>思考题</h4><p>我们还是按照文档中定义的控制组目录层次结构图，然后按序执行这几个脚本：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/chengyli/training/blob/main/cpu/cgroup_cpu/create_groups.sh">create_groups.sh</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/chengyli/training/blob/main/cpu/cgroup_cpu/update_group1.sh">update_group1.sh</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/chengyli/training/blob/main/cpu/cgroup_cpu/update_group4.sh">update_group4.sh</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/chengyli/training/blob/main/cpu/cgroup_cpu/update_group3.sh">update_group3.sh</a></li>
</ul>
<p>那么，在一个 4 个 CPU 的节点上，group1/group3/group4 里的进程，分别会被分配到多少 CPU 呢?</p>
<p>答：group1:group2是1比1，由于group1 limit是3.5，那group1分到的只能是两个核，剩余的2个核给group3和group4，group4:group3是3比1，那么得出group4与group3各分配的核就是1.5核与0.5核</p>
<h3 id="06｜容器CPU（2）：如何正确地拿到容器CPU的开销？"><a href="#06｜容器CPU（2）：如何正确地拿到容器CPU的开销？" class="headerlink" title="06｜容器CPU（2）：如何正确地拿到容器CPU的开销？"></a>06｜容器CPU（2）：如何正确地拿到容器CPU的开销？</h3><p>无论是容器的所有者还是容器平台的管理者，我们想要精准地对运行着众多容器的云平台做监控，快速排查例如应用的处理能力下降，节点负载过高等问题，就绕不开容器 CPU 开销。因为 CPU 开销的异常，往往是程序异常最明显的一个指标。</p>
<p>在一台物理机器或者虚拟机里，如果你想得到这个节点的 CPU 使用率，最常用的命令就是 top 了吧？top 一下子就能看到整个节点当前的 CPU 使用情况。</p>
<p>那么在容器里，top 命令也可以做到这点吗？想要知道答案，我们还是得实际动手试一试。</p>
<h4 id="问题重现"><a href="#问题重现" class="headerlink" title="问题重现"></a>问题重现</h4><p>实际上，你在使用容器的时候，如果运行 top 命令来查看当前容器总共使用了多少 CPU，你肯定马上就会失望了。</p>
<p>这是因为我们在容器中运行 top 命令，虽然可以看到容器中每个进程的 CPU 使用率，但是 top 中”%Cpu(s)”那一行中显示的数值，并不是这个容器的 CPU 整体使用率，而是容器宿主机的 CPU 使用率。</p>
<p>就像下面的这个例子，我们在一个 12 个 CPU 的宿主机上，启动一个容器，然后在容器里运行 top 命令。</p>
<p>这时我们可以看到，容器里有两个进程 threads-cpu，总共消耗了 200% 的 CPU（2 CPU  Usage），而”%Cpu(s)”那一行的”us cpu”是 58.5%。对于 12CPU 的系统来说，12 * 58.5%=7.02，也就是说这里显示总共消耗了 7 个 CPU，远远大于容器中 2 个 CPU 的消耗。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《容器实战高手课》学习笔记/容器CPU2一.png" alt="容器CPU2一"></p>
<p>这个例子说明，top 这个工具虽然在物理机或者虚拟机上看得到系统 CPU 开销，但是如果是放在容器环境下，运行 top 就无法得到容器中总的 CPU 使用率。那么，我们还有什么其他的办法吗？</p>
<h5 id="进程-CPU-使用率和系统-CPU-使用率"><a href="#进程-CPU-使用率和系统-CPU-使用率" class="headerlink" title="进程 CPU 使用率和系统 CPU 使用率"></a>进程 CPU 使用率和系统 CPU 使用率</h5><p>通过问题重现，我们发现 top 工具主要显示了宿主机系统整体的 CPU 使用率，以及单个进程的 CPU 使用率。既然没有现成的工具可以得到容器 CPU 开销，那我们需要自己开发一个工具来解决问题了。</p>
<p>其实我们自己推导，也没有那么难。我认为，最有效的思路还是从原理上去理解问题。</p>
<p>所以，在解决怎样得到单个容器整体的 CPU 使用率这个问题之前，我们先来学习一下，在 Linux 中到底是如何计算单个进程的 CPU 使用率，还有整个系统的 CPU 使用率的。</p>
<h5 id="进程-CPU-使用率"><a href="#进程-CPU-使用率" class="headerlink" title="进程 CPU 使用率"></a>进程 CPU 使用率</h5><p>Linux 中每个进程的 CPU 使用率，我们都可以用 top 命令查看。</p>
<p>对照我们前面的那张示意图，我们可以发现，每个进程在 top 命令输出中都有对应的一行，然后”%CPU”的那一列就是这个进程的实时 CPU 使用率了。</p>
<p>比如说，100% 就表示这个进程在这个瞬时使用了 1 个 CPU，200% 就是使用了 2 个 CPU。那么这个百分比的数值是怎么得到呢？</p>
<p>最直接的方法，就是从源头开始寻找答案。因为是 top 命令的输出，我们可以去看一下 top 命令的 <a target="_blank" rel="noopener" href="https://gitlab.com/procps-ng/procps/-/blob/newlib/src/top/top.c">源代码</a> 。在代码中你会看到对于每个进程，top 都会从 proc 文件系统中每个进程对应的 stat 文件中读取 2 个数值。我们先来看这个文件，再来解读文件中具体的两个数值。</p>
<p>这个 stat 文件就是 /proc/[pid]/stat ， [pid] 就是替换成具体一个进程的 PID 值。比如 PID 值为 1 的进程，这个文件就是 /proc/1/stat ，那么这个 /proc/[pid]/stat 文件里有什么信息呢？</p>
<p>其实这个 stat 文件实时输出了进程的状态信息，比如进程的运行态（Running 还是 Sleeping）、父进程 PID、进程优先级、进程使用的内存等等总共 50 多项。</p>
<p>完整的 stat 文件内容和格式在 proc 文件系统的 <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man5/proc.5.html">Linux programmer’s manual</a> 里定义了。在这里，我们只需要重点关注这两项数值，stat 文件中的第 14 项 utime 和第 15 项 stime。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《容器实战高手课》学习笔记/proc文件系统中stat文件中utime和stime.png" alt="proc文件系统中stat文件中utime和stime"></p>
<p>那么这两项数值 utime 和 stime 是什么含义呢？utime 是表示进程的用户态部分在 Linux 调度中获得 CPU 的 ticks，stime 是表示进程的内核态部分在 Linux 调度中获得 CPU 的 ticks。</p>
<p>看到这个解释，你可能又冒出一个新问题，疑惑 ticks 是什么? 这个 ticks 就是 Linux 操作系统中的一个时间单位，你可以理解成类似秒，毫秒的概念。</p>
<p>在 Linux 中有个自己的时钟，它会周期性地产生中断。每次中断都会触发 Linux 内核去做一次进程调度，而这一次中断就是一个 tick。因为是周期性的中断，比如 1 秒钟 100 次中断，那么一个 tick 作为一个时间单位看的话，也就是 1/100 秒。</p>
<p>我给你举个例子说明，假如进程的 utime 是 130ticks，就相当于 130 * 1/100=1.3 秒，也就是进程从启动开始在用户态总共运行了 1.3 秒钟。</p>
<p>这里需要你注意，utime 和 stime 都是一个累计值，也就是说从进程启动开始，这两个值就是一直在累积增长的。</p>
<p>那么我们怎么计算，才能知道某一进程在用户态和内核态中，分别获得了多少 CPU 的 ticks 呢？</p>
<p>首先，我们可以假设这个瞬时是 1 秒钟，这 1 秒是 T1 时刻到 T2 时刻之间的，那么这样我们就能获得 T1 时刻的 utime_1 和 stime_1，同时获得 T2 时刻的 utime_2 和 stime_2。</p>
<p>在这 1 秒的瞬时，进程用户态获得的 CPU ticks 就是 (utime_2 - utime_1), 进程内核态获得的 CPU ticks 就是 (stime_2 - stime_1)。</p>
<p>那么我们可以推导出，进程 CPU 总的开销就是用户态加上内核态，也就是在 1 秒瞬时进程总的 CPU ticks 等于 (utime_2 - utime_1) + (stime_2 - stime_1)。</p>
<p>好了，现在我们得到了进程以 ticks 为单位的 CPU 开销，接下来还要做个转化。我们怎样才能把这个值转化成我们熟悉的百分比值呢？其实也不难，我们还是可以去 top 的源代码里得到这个百分比的计算公式。</p>
<p>简单总结一下，这个公式是这样的：</p>
<p><code>进程的 CPU 使用率 =((utime_2 - utime_1) + (stime_2 - stime_1)) * 100.0 / (HZ * et * 1 )</code></p>
<p>接下来，我再给你讲一下，这个公式里每一个部分的含义。</p>
<p>首先， ((utime_2 - utime_1) + (stime_2 - stime_1)) 是瞬时进程总的 CPU ticks。这个我们已经在前面解释过了。</p>
<p>其次，我们来看 100.0，这里乘以 100.0 的目的是产生百分比数值。</p>
<p>最后，我再讲一下  <code>(HZ * et * 1)</code> 。这是被除数这里的三个参数，我给你详细解释一下。</p>
<p>第一个 HZ 是什么意思呢？前面我们介绍 ticks 里说了，ticks 是按照固定频率发生的，在我们的 Linux 系统里 1 秒钟是 100 次，那么 HZ 就是 1 秒钟里 ticks 的次数，这里值是 100。</p>
<p>第二个参数 et 是我们刚才说的那个”瞬时”的时间，也就是得到 utime_1 和 utime_2 这两个值的时间间隔。</p>
<p>第三个”1”, 就更容易理解了，就是 1 个 CPU。那么这三个值相乘，你是不是也知道了它的意思呢？就是在这”瞬时”的时间（et）里，1 个 CPU 所包含的 ticks 数目。</p>
<p>解释了这些参数，我们可以把这个公式简化一下，就是下面这样：</p>
<p><code>进程的 CPU 使用率 =（进程的 ticks/ 单个 CPU 总 ticks）*100.0</code></p>
<p>知道了这个公式，就需要上手来验证一下这个方法对不对，怎么验证呢？我们可以启动一个消耗 CPU 的小程序，然后读取一下进程对应的 /proc/[pid]/stat 中的 utime 和 stime，然后用这个方法来计算一下进程使用率这个百分比值，并且和 top 的输出对比一下，看看是否一致。</p>
<p>先启动一个消耗 200% 的小程序，它的 PID 是 10021，CPU 使用率是 200%。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《容器实战高手课》学习笔记/容器CPU2三.png" alt="容器CPU2三"></p>
<p>然后，我们查看这个进程对应的 stat 文件 /proc/10021/stat，间隔 1 秒钟输出第二次，因为 stat 文件内容很多，我们知道 utime 和 stime 第 14 和 15 项，所以我们这里只截取了前 15 项的输出。这里可以看到，utime_1 = 399，stime_1=0，utime_2=600，stime_2=0。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《容器实战高手课》学习笔记/容器CPU2四.png" alt="容器CPU2四.png"></p>
<p>根据前面的公式，我们计算一下进程 threads-cpu 的 CPU 使用率。套用前面的公式，计算的过程是：<code>((600 - 399) + (0 - 0)) * 100.0 / (100 * 1 * 1) =201</code>，也就是 201%。你会发现这个值和我们运行 top 里的值是一样的。同时，我们也就验证了这个公式是没问题的。</p>
<h5 id="系统-CPU-使用率"><a href="#系统-CPU-使用率" class="headerlink" title="系统 CPU 使用率"></a>系统 CPU 使用率</h5><p>前面我们介绍了 Linux 中如何获取单个进程的 CPU 使用率，下面我们再来看看 Linux 里是怎么计算系统的整体 CPU 使用率的。</p>
<p>其实知道了如何计算单个进程的 CPU 使用率之后，要理解系统整体的 CPU 使用率计算方法就简单多了。</p>
<p>同样，我们要计算 CPU 使用率，首先需要拿到数据，数据源也同样可以从 proc 文件系统里得到，对于整个系统的 CPU 使用率，这个文件就是 /proc/stat。</p>
<p>在 /proc/stat 文件的 cpu 这行有 10 列数据，同样我们可以在 proc 文件系统的 Linux programmer’s manual 里，找到每一列数据的定义，而前 8 列数据正好对应 top 输出中”%Cpu(s)”那一行里的 8 项数据，也就是在上一讲中，我们介绍过的 user/system/nice/idle/iowait/irq/softirq/steal 这 8 项。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《容器实战高手课》学习笔记/容器CPU2五.png" alt="容器CPU2五"></p>
<p>而在 /proc/stat 里的每一项的数值，就是系统自启动开始的 ticks。那么要计算出”瞬时”的 CPU 使用率，首先就要算出这个”瞬时”的 ticks，比如 1 秒钟的”瞬时”，我们可以记录开始时刻 T1 的 ticks, 然后再记录 1 秒钟后 T2 时刻的 ticks，再把这两者相减，就可以得到这 1 秒钟的 ticks 了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《容器实战高手课》学习笔记/容器CPU2六.png" alt="容器CPU2六"></p>
<p>这里我们可以得到，在这 1 秒钟里每个 CPU 使用率的 ticks：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《容器实战高手课》学习笔记/CPU使用率的ticks统计表.jpg" alt="CPU使用率的ticks统计表"></p>
<p>我们想要计算每一种 CPU 使用率的百分比，其实也很简单。我们只需要把所有在这 1 秒里的 ticks 相加得到一个总值，然后拿某一项的 ticks 值，除以这个总值。比如说计算 idle CPU 的使用率就是：</p>
<p><code>（1203 / 0 + 0 + 0 + 1203 + 0 + 0 + 0 + 0）=100%</code></p>
<p>好了，我们现在来整体梳理一下，我们通过 Linux 里的工具，要怎样计算进程的 CPU 使用率和系统的 CPU 使用率。</p>
<p>对于单个进程的 CPU 使用率计算，我们需要读取对应进程的 /proc/[pid]/stat 文件，将进程瞬时用户态和内核态的 ticks 数相加，就能得到进程的总 ticks。</p>
<p>然后我们运用公式 <code>(进程的 ticks / 单个 CPU 总 ticks) * 100.0</code> 计算出进程 CPU 使用率的百分比值。</p>
<p>对于系统的 CPU 使用率，需要读取 /proc/stat 文件，得到瞬时各项 CPU 使用率的 ticks 值，相加得到一个总值，单项值除以总值就是各项 CPU 的使用率。</p>
<h4 id="解决问题-2"><a href="#解决问题-2" class="headerlink" title="解决问题"></a>解决问题</h4><p>前面我们学习了在 Linux 中，top 工具是怎样计算每个进程的 CPU 使用率，以及系统总的 CPU 使用率。现在我们再来看最初的问题：为什么在容器中运行 top 命令不能得到容器中总的 CPU 使用率？</p>
<p>这就比较好解释了，对于系统总的 CPU 使用率，需要读取 /proc/stat 文件，但是这个文件中的各项 CPU ticks 是反映整个节点的，并且这个 /proc/stat 文件也不包含在任意一个 Namespace 里。</p>
<p>那么， <strong>对于 top 命令来说，它只能显示整个节点中各项 CPU 的使用率，不能显示单个容器的各项 CPU 的使用率。</strong> 既然 top 命令不行，我们还有没有办法得到整个容器的 CPU 使用率呢？</p>
<p>我们之前已经学习过了 CPU Cgroup，每个容器都会有一个 CPU Cgroup 的控制组。在这个控制组目录下面有很多参数文件，有的参数可以决定这个控制组里最大的 CPU 可使用率外，除了它们之外，目录下面还有一个可读项 cpuacct.stat。</p>
<p>这里包含了两个统计值，这两个值分别是 <strong>这个控制组里所有进程的内核态 ticks 和用户态的 ticks</strong>，那么我们就可以用前面讲过的公式，也就是计算进程 CPU 使用率的公式，去计算整个容器的 CPU 使用率：</p>
<p><code>CPU 使用率 =((utime_2 - utime_1) + (stime_2 - stime_1)) * 100.0 / (HZ * et * 1 )</code></p>
<p>我们还是以问题重现中的例子说明，也就是最开始启动容器里的那两个容器 threads-cpu 进程。</p>
<p>就像下图显示的这样，整个容器的 CPU 使用率的百分比就是 <code>( (174021 - 173820) + (4 - 4)) * 100.0 / (100 * 1 * 1) = 201</code> , 也就是 201%。 <strong>所以，我们从每个容器的 CPU Cgroup 控制组里的 cpuacct.stat 的统计值中</strong> ，可以比较快地得到整个容器的 CPU 使用率。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《容器实战高手课》学习笔记/容器CPU2八.png" alt="容器CPU2八"></p>
<h4 id="重点总结-4"><a href="#重点总结-4" class="headerlink" title="重点总结"></a>重点总结</h4><p>Linux 里获取 CPU 使用率的工具，比如 top，都是通过读取 proc 文件系统下的 stat 文件来得到 CPU 使用了多少 ticks。而这里的 ticks，是 Linux 操作系统里的一个时间单位，可以理解成类似秒，毫秒的概念。</p>
<p>对于每个进程来说，它的 stat 文件是 /proc/[pid]/stat，里面包含了进程用户态和内核态的 ticks 数目；对于整个节点，它的 stat 文件是 /proc/stat，里面包含了 user/system/nice/idle/iowait 等不同 CPU 开销类型的 ticks。</p>
<p><strong>由于 /proc/stat 文件是整个节点全局的状态文件，不属于任何一个 Namespace，因此在容器中无法通过读取 /proc/stat 文件来获取单个容器的 CPU 使用率。</strong></p>
<p>所以要得到单个容器的 CPU 使用率，我们可以从 CPU Cgroup 每个控制组里的统计文件 cpuacct.stat 中获取。 <code>单个容器 CPU 使用率 =((utime_2 - utime_1) + (stime_2 - stime_1)) * 100.0 / (HZ * et * 1 )</code> 。</p>
<p>得到单个容器的 CPU 的使用率，那么当宿主机上负载变高的时候，就可以很快知道是哪个容器引起的问题。同时，用户在管理自己成百上千的容器的时候，也可以很快发现 CPU 使用率异常的容器，这样就能及早地介入去解决问题。</p>
<h2 id="容器内存"><a href="#容器内存" class="headerlink" title="容器内存"></a>容器内存</h2><h2 id="容器存储"><a href="#容器存储" class="headerlink" title="容器存储"></a>容器存储</h2><h2 id="容器网络"><a href="#容器网络" class="headerlink" title="容器网络"></a>容器网络</h2><h2 id="容器安全"><a href="#容器安全" class="headerlink" title="容器安全"></a>容器安全</h2><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><h2 id="专题加餐"><a href="#专题加餐" class="headerlink" title="专题加餐"></a>专题加餐</h2>
                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://kibazen.cn" rel="external nofollow noreferrer">Kiba Amor</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                    </span>
                <span class="reprint-info">
                    <a href="https://kibazen.cn/rong-qi-shi-zhan-gao-shou-ke-xue-xi-bi-ji/">https://kibazen.cn/rong-qi-shi-zhan-gao-shou-ke-xue-xi-bi-ji/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY-NC-ND 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://kibazen.cn" target="_blank">Kiba Amor</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                                    <span class="chip bg-color">极客时间</span>
                                </a>
                            
                                <a href="/tags/docker/">
                                    <span class="chip bg-color">docker</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="qq,wechat,weibo,douban" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/rong-qi-shi-zhan-gao-shou-ke-xue-xi-bi-ji/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/17.jpg" class="responsive-img" alt="《容器实战高手课》学习笔记">
                        
                        <span class="card-title">《容器实战高手课》学习笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-09-02
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                    学习笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                        <span class="chip bg-color">极客时间</span>
                    </a>
                    
                    <a href="/tags/docker/">
                        <span class="chip bg-color">docker</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/shen-ru-pou-xi-kubernetes-xue-xi-bi-ji/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/21.jpg" class="responsive-img" alt="《深入剖析Kubernetes》学习笔记">
                        
                        <span class="card-title">《深入剖析Kubernetes》学习笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-07-15
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                    学习笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                        <span class="chip bg-color">极客时间</span>
                    </a>
                    
                    <a href="/tags/kubernetes/">
                        <span class="chip bg-color">kubernetes</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (true) {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 木叶禅<br />'
            + '文章作者: Kiba Amor<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者木叶禅所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('2'),
            headingSelector: 'h2, h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2022</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">Kiba Amor</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">1260.5k</span>&nbsp;字
            
            
            
            
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/kibaamor" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>









    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=562236616" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 562236616" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>





    <a href="https://www.zhihu.com/people/kibaamor" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/kibaamor" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    

    

    

	
    

    

    

    
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
