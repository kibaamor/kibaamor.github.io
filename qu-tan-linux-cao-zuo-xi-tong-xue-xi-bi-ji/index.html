<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <meta name="keywords" content="《趣谈Linux操作系统》学习笔记, kiba, zen, amor, kibazen, kibaamor, 木叶, 木叶禅">
    <meta name="description" content="一个普通游戏程序员的博客">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>《趣谈Linux操作系统》学习笔记 | 木叶禅</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/css/my.css">

    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="木叶禅" type="application/atom+xml">
</head>



   <style>
    body{
       background-image: url(/medias/background.jpg);
       background-repeat:no-repeat;
       background-size:cover;
       background-attachment:fixed;
    }
</style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">木叶禅</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/leetcode/" class="waves-effect waves-light">
      
      <i class="fas fa-code" style="zoom: 0.6;"></i>
      
      <span>LeetCode</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/learn/" class="waves-effect waves-light">
      
      <i class="fas fa-book" style="zoom: 0.6;"></i>
      
      <span>学习</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tool/" class="waves-effect waves-light">
      
      <i class="fas fa-toolbox" style="zoom: 0.6;"></i>
      
      <span>工具</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories/" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags/" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about/" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">木叶禅</div>
        <div class="logo-desc">
            
            一个普通游戏程序员的博客
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/leetcode/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-code"></i>
			
			LeetCode
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/learn/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-book"></i>
			
			学习
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tool/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-toolbox"></i>
			
			工具
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    
<script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = 'f65e070788a2647953051a7a1b70ada7fd2b3f70cd4d93c977207f5b762987d4';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/17.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">《趣谈Linux操作系统》学习笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                                <span class="chip bg-color">极客时间</span>
                            </a>
                        
                            <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                                <span class="chip bg-color">操作系统</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                学习笔记
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-11-25
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2021-12-22
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    29.3k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    114 分
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="一、x86架构"><a href="#一、x86架构" class="headerlink" title="一、x86架构"></a>一、x86架构</h2><h3 id="1-1-8086的原理"><a href="#1-1-8086的原理" class="headerlink" title="1.1 8086的原理"></a>1.1 8086的原理</h3><p><img src="/images/《趣谈Linux操作系统》学习笔记/8086CPU.jpeg" alt="8086CPU"></p>
<ol>
<li><p>数据单元</p>
<p> 为了暂存数据，8086处理器内部有8个16位的通用寄存器，分别是AX、BX、CX、DX、SP、BP、SI、DI。这些寄存器主要用于在计算过程中暂存数据。</p>
<p> 其中AX、BX、CX、DX可以分成两个8位的寄存器来使用，分别是AH、AL、BH、BL、CH、CL、DH、DL，其中H就是High（高位），L就是Low（低位）的意思。</p>
</li>
<li><p>控制单元</p>
<p> IP寄存器就是指令指针寄存器（Instruction Pointer Register)，指向代码段中下一条指令的位置。CPU会根据它来不断地将指令从内存的代码段中，加载到CPU的指令队列中，然后交给运算单元去执行。</p>
<p> 如果需要切换进程呢？每个进程都分代码段和数据段，为了指向不同进程的地址空间，有四个16位的段寄存器，分别是CS、DS、SS、ES。</p>
<p> 其中，CS就是代码段寄存器（Code Segment Register），通过它可以找到代码在内存中的位置；DS是数据段的寄存器，通过它可以找到数据在内存中的位置。</p>
<p> SS是栈寄存器（Stack Register）。栈是程序运行中一个特殊的数据结构，数据的存取只能从一端进行，秉承后进先出的原则，push就是入栈，pop就是出栈。</p>
<p> ES为扩展段寄存器。</p>
<p> 在CS和DS中都存放着一个段的起始地址。代码段的偏移量在IP寄存器中，数据段的偏移量会放在通用寄存器中。</p>
<p> 这时候问题来了，CS和DS都是16位的，也就是说，起始地址都是16位的，IP寄存器和通用寄存器都是16位的，偏移量也是16位的，但是8086的地址总线地址是20位。怎么凑够这20位呢？方法就是“起始地址*16+偏移量”，也就是把CS和DS中的值左移4位，变成20位的，加上16位的偏移量，这样就可以得到最终20位的数据地址。</p>
<p> 因为偏移量只能是16位的，所以一个段最大的大小是2^16=64k。</p>
</li>
</ol>
<h3 id="1-2-32位处理器"><a href="#1-2-32位处理器" class="headerlink" title="1.2 32位处理器"></a>1.2 32位处理器</h3><p>在32位处理器中，有32根地址总线，可以访问2^32=4G的内存。</p>
<p>首先，通用寄存器有扩展，可以将8个16位的扩展到8个32位的，但是依然可以保留16位的和8位的使用方式。你可能会问，为什么高16位不分成两个8位使用呢？因为这样就不兼容了呀！</p>
<p>其中，指向下一条指令的指令指针寄存器IP，就会扩展成32位的，同样也兼容16位的。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/32位处理器.jpeg" alt="32位处理器"></p>
<p>而改动比较大，有点不兼容的就是段寄存器（Segment Register）。</p>
<p>CS、SS、DS、ES仍然是16位的，但是不再是段的起始地址。段的起始地址放在内存的某个地方。这个地方是一个表格，表格中的一项一项是段描述符（Segment Descriptor）。这里面才是真正的段的起始地址。而段寄存器里面保存的是在这个表格中的哪一项，称为选择子（Selector）。</p>
<p>这样，将一个从段寄存器直接拿到的段起始地址，就变成了先间接地从段寄存器找到表格中的一项，再从表格中的一项中拿到段起始地址。</p>
<blockquote>
<p>为了快速拿到段起始地址，段寄存器会从内存中拿到CPU的描述符高速缓存器中。</p>
</blockquote>
<p>32位的系统架构下，我们将前一种模式称为实模式（Real Pattern），后一种模式称为保护模式（Protected Pattern）。</p>
<p>当系统刚刚启动的时候，CPU是处于实模式的。</p>
<h3 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3 总结"></a>1.3 总结</h3><p><img src="/images/《趣谈Linux操作系统》学习笔记/x86架构.jpeg" alt="x86架构"></p>
<h2 id="二、系统启动过程"><a href="#二、系统启动过程" class="headerlink" title="二、系统启动过程"></a>二、系统启动过程</h2><p><img src="/images/《趣谈Linux操作系统》学习笔记/x86系统中的1M空间.jpeg" alt="x86系统中的1M空间"></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/quan0311/p/15292110.html">谈谈Linux系统启动流程</a></p>
<ol>
<li><p>系统加电后，CPU 运行在实模式下，且 CS 重置为 0xFFFF ，IP 为 0x0000。</p>
<p> 实模式下，内存地址的计算方式是：<code>段寄存器 * 16 + 偏移量</code> 。所以系统加电后运行的第一条指令在 <code>CS * 16 + IP = 0xFFFF0</code> 。</p>
<blockquote>
<p>实模式只有 1MB 内存寻址空间(X86)。</p>
</blockquote>
</li>
<li><p>在 x86 系统中，内存 <code>0xF0000-0xFFFFF</code> 映射到 BIOS 程序（存储在 ROM 中），BIOS 主要做三件事：</p>
<ol>
<li>检查硬件。</li>
<li>提供基本输入（中断）输出（显存映射）服务。</li>
<li><p>把 MBR（Master Boot Record，主引导记录/扇区）装载到内存 0x7C00 开始的 512 字节大小的内存区域，并设置 CS:IP 为 0x0000:7C00 。</p>
<blockquote>
<p>MBR 指启动盘的第一个扇区，大小 512 字节，并且以 0xAA55 结束。</p>
<p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2015/09/0x7c00.html">为什么主引导记录的内存地址是0x7C00？</a></p>
</blockquote>
</li>
</ol>
</li>
<li><p>MBR中存放的一般是由 Grub2 写入的 boot.img。</p>
</li>
<li><p>boot.img 加载 Grub2 的 core.img 。</p>
<blockquote>
<p>boot.img 由 <a target="_blank" rel="noopener" href="https://github.com/rhboot/grub2/blob/master/grub-core/boot/i386/pc/boot.S">boot.S</a> 编译而成。</p>
<p>core.img 包括 diskroot.img, lzma_decompress.img, kernel.img 以及其他模块。</p>
</blockquote>
</li>
<li><p>硬盘启动时，boot.img 先加载运行 diskroot.img, 再由 diskroot.img 加载 core.img 的其他内容。</p>
</li>
<li><p>diskroot.img 解压运行 lzma_compress.img 。</p>
<blockquote>
<p>diskroot.img 由 <a target="_blank" rel="noopener" href="https://github.com/rhboot/grub2/blob/master/grub-core/boot/i386/pc/diskboot.S">diskboot.S</a> 编译而成。</p>
</blockquote>
</li>
<li><p>lzma_compress.img 首先切换到保护模式。然后再解压运行 grub 内核 kernel.img。</p>
<blockquote>
<p>lzma_compress.img 由 <a target="_blank" rel="noopener" href="https://github.com/rhboot/grub2/blob/master/grub-core/boot/i386/pc/startup_raw.S">startup_raw.S</a> 编译而成。</p>
</blockquote>
<p> 调用 <code>real_to_prot</code> 切换到保护模式需要做三件事：</p>
<ul>
<li>启用分段, 辅助进程管理。在内存里面建立段描述符表，将寄存器里面的段寄存器变成段选择子，指向某个段描述符，这样就能实现不同进程的切换了。</li>
<li>启动分页, 辅助内存管理；将内存分成相等大小的块。</li>
<li>打开其他地址线。打开Gate A20，也就是第21根地址线的控制线。</li>
</ul>
</li>
<li><p>kernel.img 主要做的是根据配置信息，加载用户选择 linux kernel 并传递内核启动参数。</p>
<p> kernel.img 对应的代码是 <a target="_blank" rel="noopener" href="https://github.com/rhboot/grub2/blob/master/grub-core/kern/i386/pc/startup.S">startup.S</a> 以及一堆 c 文件，在 startup.S 中会调用 <code>grub_main</code> ，这是 grub kernel 的主函数。</p>
<p> 将真正的操作系统的 kernel 镜像加载执行，Linux Kernel的启动入口是 <code>start_kernel()</code> 。</p>
</li>
<li><p><code>start_kernel()</code> 中会进行一部分初始化工作，最后调用 <code>rest_init()</code> 来完成其他的初始化工作。</p>
</li>
<li><p><code>rest_init()</code> 中会创建系统 1 号进程 kernel_init ， kernel_init 会执行 ramdisk 中的 init 程序，并切换至用户态，加载驱动后执行真正的根文件系统中的 init 程序。</p>
</li>
<li><p><code>rest_init()</code> 中会创建系统 2 号进程 kthread ，负责所有内核态线程的调度和管理，是内核态所有运行线程的祖先。</p>
</li>
</ol>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/系统启动过程.jpeg" alt="系统启动过程"></p>
<h2 id="三、内核初始化"><a href="#三、内核初始化" class="headerlink" title="三、内核初始化"></a>三、内核初始化</h2><p>内核的启动从入口函数start_kernel()开始。在init/main.c文件中，start_kernel相当于内核的main函数。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/内核初始化.jpeg" alt="内核初始化"></p>
<h3 id="3-1-初始化任务管理"><a href="#3-1-初始化任务管理" class="headerlink" title="3.1 初始化任务管理"></a>3.1 初始化任务管理</h3><p>在操作系统里面，先要有个创始进程，有一行指令set_task_stack_end_magic(&amp;init_task)。这里面有一个参数init_task，它的定义是struct task_struct init_task = INIT_TASK(init_task)。它是系统创建的第一个进程，我们称为 <strong>0号进程</strong> 。这是唯一一个没有通过fork或者kernel_thread产生的进程，是进程列表的第一个。</p>
<h3 id="3-2-初始化中断处理"><a href="#3-2-初始化中断处理" class="headerlink" title="3.2 初始化中断处理"></a>3.2 初始化中断处理</h3><p>对应的函数是trap_init()，里面设置了很多中断门（Interrupt Gate），用于处理各种中断。其中有一个set_system_intr_gate(IA32_SYSCALL_VECTOR, entry_INT80_32)，这是系统调用的中断门。系统调用也是通过发送中断的方式进行的。</p>
<blockquote>
<p>64位的有另外的系统调用方法。</p>
</blockquote>
<h3 id="3-3-初始化内存管理"><a href="#3-3-初始化内存管理" class="headerlink" title="3.3 初始化内存管理"></a>3.3 初始化内存管理</h3><p>对应的，mm_init()就是用来初始化内存管理模块。</p>
<h3 id="3-4-初始化调度模块"><a href="#3-4-初始化调度模块" class="headerlink" title="3.4 初始化调度模块"></a>3.4 初始化调度模块</h3><p>sched_init()就是用于初始化调度模块。</p>
<h3 id="3-5-初始化-rootfs-文件系统"><a href="#3-5-初始化-rootfs-文件系统" class="headerlink" title="3.5 初始化 rootfs 文件系统"></a>3.5 初始化 rootfs 文件系统</h3><p>vfs_caches_init()会用来初始化基于内存的文件系统rootfs。在这个函数里面，会调用mnt_init()-&gt;init_rootfs()。这里面有一行代码，register_filesystem(&amp;rootfs_fs_type)。在VFS虚拟文件系统里面注册了一种类型，我们定义为struct file_system_type rootfs_fs_type。</p>
<h3 id="3-6-其他初始化"><a href="#3-6-其他初始化" class="headerlink" title="3.6 其他初始化"></a>3.6 其他初始化</h3><p>最后，start_kernel()调用的是rest_init()，用来做其他方面的初始化，这里面做了好多的工作。</p>
<h4 id="3-6-1-初始化1号进程"><a href="#3-6-1-初始化1号进程" class="headerlink" title="3.6.1 初始化1号进程"></a>3.6.1 初始化1号进程</h4><p>rest_init的第一大工作是，用kernel_thread(kernel_init, NULL, CLONE_FS)创建第二个进程，这个是 <strong>1号进程</strong> 。</p>
<p>1号进程对于操作系统来讲，有“划时代”的意义。因为它将运行一个用户进程。</p>
<p>x86提供了分层的权限机制，把区域分成了四个Ring，越往里权限越高，越往外权限越低。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/x86提供的分层权限机制.jpg" alt="x86提供的分层权限机制"></p>
<p>操作系统很好地利用了这个机制，将能够访问关键资源的代码放在Ring0，我们称为 <strong>内核态（Kernel Mode）</strong> ；将普通的程序代码放在Ring3，我们称为 <strong>用户态（User Mode）</strong> 。</p>
<ol>
<li><p>从内核态到用户态</p>
<p> 当执行kernel_thread这个函数的时候，系统在内核态。</p>
<p> kernel_thread的参数是一个函数kernel_init，也就是这个进程会运行这个函数。在kernel_init里面，会调用kernel_init_freeable()，里面有这样的代码：</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ramdisk_execute_command<span class="token punctuation">)</span>
    ramdisk_execute_command <span class="token operator">=</span> <span class="token string">"/init"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 先不管ramdisk是啥，我们回到kernel_init里面。这里面有这样的代码块：</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c">    <span class="token keyword">if</span> <span class="token punctuation">(</span>ramdisk_execute_command<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ret <span class="token operator">=</span> <span class="token function">run_init_process</span><span class="token punctuation">(</span>ramdisk_execute_command<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">try_to_run_init_process</span><span class="token punctuation">(</span><span class="token string">"/sbin/init"</span><span class="token punctuation">)</span> <span class="token operator">||</span>
        <span class="token operator">!</span><span class="token function">try_to_run_init_process</span><span class="token punctuation">(</span><span class="token string">"/etc/init"</span><span class="token punctuation">)</span> <span class="token operator">||</span>
        <span class="token operator">!</span><span class="token function">try_to_run_init_process</span><span class="token punctuation">(</span><span class="token string">"/bin/init"</span><span class="token punctuation">)</span> <span class="token operator">||</span>
        <span class="token operator">!</span><span class="token function">try_to_run_init_process</span><span class="token punctuation">(</span><span class="token string">"/bin/sh"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 这就说明，1号进程运行的是一个文件。如果我们打开run_init_process函数，会发现它调用的是do_execve。</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">run_init_process</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>init_filename<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    argv_init<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> init_filename<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">do_execve</span><span class="token punctuation">(</span><span class="token function">getname_kernel</span><span class="token punctuation">(</span>init_filename<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token keyword">const</span> __user <span class="token operator">*</span><span class="token punctuation">)</span>argv_init<span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token keyword">const</span> __user <span class="token operator">*</span><span class="token punctuation">)</span>envp_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> execve是一个系统调用，它的作用是运行一个执行文件。加一个do_的往往是内核系统调用的实现。没错，这就是一个系统调用，它会尝试运行ramdisk的“/init”，或者普通文件系统上的“/sbin/init”“/etc/init”“/bin/init”“/bin/sh”。不同版本的Linux会选择不同的文件启动，但是只要有一个起来了就可以。</p>
</li>
<li><p>如何利用执行init文件的机会，从内核态回到用户态呢？</p>
<p> 从系统调用的过程可以得到启发，“用户态-系统调用-保存寄存器-内核态执行系统调用-恢复寄存器-返回用户态”，然后接着运行。而咱们刚才运行init，是调用do_execve，正是上面的过程的后半部分，从内核态执行系统调用开始。</p>
<p> do_execve-&gt;do_execveat_common-&gt;exec_binprm-&gt;search_binary_handler，这里面会调用这段内容：</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">search_binary_handler</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">linux_binprm</span> <span class="token operator">*</span>bprm<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">struct</span> <span class="token class-name">linux_binfmt</span> <span class="token operator">*</span>fmt<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    retval <span class="token operator">=</span> fmt<span class="token operator">-&gt;</span><span class="token function">load_binary</span><span class="token punctuation">(</span>bprm<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 要运行一个程序，需要加载这个二进制文件，它是有一定格式的。Linux下一个常用的格式是ELF（Executable and Linkable Format，可执行与可链接格式）。于是我们就有了下面这个定义：</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">linux_binfmt</span> elf_format <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>module <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>load_binary <span class="token operator">=</span> load_elf_binary<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>load_shlib <span class="token operator">=</span> load_elf_library<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>core_dump <span class="token operator">=</span> elf_core_dump<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>min_coredump <span class="token operator">=</span> ELF_EXEC_PAGESIZE<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 这其实就是先调用load_elf_binary，最后调用start_thread。</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span>
<span class="token function">start_thread</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span>regs<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> new_ip<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> new_sp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token function">set_user_gs</span><span class="token punctuation">(</span>regs<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
regs<span class="token operator">-&gt;</span>fs    <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
regs<span class="token operator">-&gt;</span>ds    <span class="token operator">=</span> __USER_DS<span class="token punctuation">;</span>
regs<span class="token operator">-&gt;</span>es    <span class="token operator">=</span> __USER_DS<span class="token punctuation">;</span>
regs<span class="token operator">-&gt;</span>ss    <span class="token operator">=</span> __USER_DS<span class="token punctuation">;</span>
regs<span class="token operator">-&gt;</span>cs    <span class="token operator">=</span> __USER_CS<span class="token punctuation">;</span>
regs<span class="token operator">-&gt;</span>ip    <span class="token operator">=</span> new_ip<span class="token punctuation">;</span>
regs<span class="token operator">-&gt;</span>sp    <span class="token operator">=</span> new_sp<span class="token punctuation">;</span>
regs<span class="token operator">-&gt;</span>flags <span class="token operator">=</span> X86_EFLAGS_IF<span class="token punctuation">;</span>
<span class="token function">force_iret</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">EXPORT_SYMBOL_GPL</span><span class="token punctuation">(</span>start_thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> struct pt_regs，看名字里的register，就是寄存器啊！这个结构就是在系统调用的时候，内核中保存用户态运行上下文的，里面将用户态的代码段CS设置为<strong>USER_CS，将用户态的数据段DS设置为</strong>USER_DS，以及指令指针寄存器IP、栈指针寄存器SP。这里相当于补上了原来系统调用里，保存寄存器的一个步骤。</p>
<p> 最后的iret是用于从系统调用中返回。这个时候会恢复寄存器。从哪里恢复呢？按说是从进入系统调用的时候，保存的寄存器里面拿出。好在上面的函数补上了寄存器。CS和指令指针寄存器IP恢复了，指向用户态下一个要执行的语句。DS和函数栈指针SP也被恢复了，指向用户态函数栈的栈顶。所以，下一条指令，就从用户态开始运行了。</p>
</li>
<li><p>ramdisk的作用</p>
<p> init终于从内核到用户态了。一开始到用户态的是ramdisk的init，后来会启动真正根文件系统上的init，成为所有用户态进程的祖先。</p>
<p> 为什么会有ramdisk这个东西呢？内核启动的时候，一般会配置参数：</p>
 <pre class="line-numbers language-text" data-language="text"><code class="language-text">initrd16 /boot/initramfs-3.10.0-862.el7.x86_64.img<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 就是这个东西，这是一个基于内存的文件系统。为啥会有这个呢？</p>
<p> 是因为刚才那个init程序是在文件系统上的，文件系统一定是在一个存储设备上的，例如硬盘。Linux访问存储设备，要有驱动才能访问。如果存储系统数目很有限，那驱动可以直接放到内核里面，反正前面我们加载过内核到内存里了，现在可以直接对存储系统进行访问。</p>
<p> 但是存储系统越来越多了，如果所有市面上的存储系统的驱动都默认放进内核，内核就太大了。这该怎么办呢？</p>
<p> 我们只好先弄一个基于内存的文件系统。内存访问是不需要驱动的，这个就是ramdisk。这个时候，ramdisk是根文件系统。</p>
<p> 然后，我们开始运行ramdisk上的/init。等它运行完了就已经在用户态了。/init这个程序会先根据存储系统的类型加载驱动，有了驱动就可以设置真正的根文件系统了。有了真正的根文件系统，ramdisk上的/init会启动文件系统上的init。</p>
<p> 接下来就是各种系统的初始化。启动系统的服务，启动控制台，用户就可以登录进来了。</p>
<p> 先别忙着高兴，rest_init的第一个大事情才完成。我们仅仅形成了用户态所有进程的祖先。</p>
</li>
</ol>
<h4 id="3-6-2-创建2号进程"><a href="#3-6-2-创建2号进程" class="headerlink" title="3.6.2 创建2号进程"></a>3.6.2 创建2号进程</h4><p>kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES)又一次使用kernel_thread函数创建进程。这里需要指出一点，函数名thread可以翻译成“线程”，这也是操作系统很重要的一个概念。它和进程有什么区别呢？为什么这里创建的是进程，函数名却是线程呢？</p>
<p>从用户态来看，创建进程其实就是立项，也就是启动一个项目。这个项目需要人去执行。有多个人并行执行不同的部分，这就叫 <strong>多线程（Multithreading）</strong> 。如果只有一个人，那它就是这个项目的主线程。</p>
<p>但是从内核态来看，无论是进程，还是线程，我们都可以统称为任务（Task），都使用相同的数据结构，平放在同一个链表中。</p>
<p>这里的函数kthreadd，负责所有内核态的线程的调度和管理，是内核态所有线程运行的祖先。</p>
<h2 id="四、系统调用"><a href="#四、系统调用" class="headerlink" title="四、系统调用"></a>四、系统调用</h2><h3 id="4-1-glibc对系统调用的封装"><a href="#4-1-glibc对系统调用的封装" class="headerlink" title="4.1 glibc对系统调用的封装"></a>4.1 glibc对系统调用的封装</h3><p>在glibc的源代码中，有个文件syscalls.list，里面列着所有glibc的函数对应的系统调用，就像下面这个样子：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text"># File name Caller  Syscall name    Args    Strong name Weak names
open        -       open            Ci:siv  __libc_open __open open<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>另外，glibc还有一个脚本make-syscall.sh，可以根据上面的配置文件，对于每一个封装好的系统调用，生成一个文件。这个文件里面定义了一些宏，例如#define SYSCALL_NAME open。</p>
<p>glibc还有一个文件syscall-template.S，使用上面这个宏，定义了这个系统调用的调用方式。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">T_PSEUDO</span> <span class="token punctuation">(</span>SYSCALL_SYMBOL<span class="token punctuation">,</span> SYSCALL_NAME<span class="token punctuation">,</span> SYSCALL_NARGS<span class="token punctuation">)</span>
    ret
<span class="token function">T_PSEUDO_END</span> <span class="token punctuation">(</span>SYSCALL_SYMBOL<span class="token punctuation">)</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">T_PSEUDO</span><span class="token punctuation">(</span>SYMBOL<span class="token punctuation">,</span> NAME<span class="token punctuation">,</span> N<span class="token punctuation">)</span>       <span class="token function">PSEUDO</span> <span class="token punctuation">(</span>SYMBOL<span class="token punctuation">,</span> NAME<span class="token punctuation">,</span> N<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里的PSEUDO也是一个宏，它的定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">PSEUDO</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> syscall_name<span class="token punctuation">,</span> args<span class="token punctuation">)</span>        </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token punctuation">.</span>text<span class="token punctuation">;</span>                                        </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token function">ENTRY</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span>                                  </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token function">DO_CALL</span> <span class="token punctuation">(</span>syscall_name<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>               </span><span class="token punctuation">\</span>
    <span class="token expression">cmpl $<span class="token operator">-</span><span class="token number">4095</span><span class="token punctuation">,</span> <span class="token operator">%</span>eax<span class="token punctuation">;</span>                          </span><span class="token punctuation">\</span>
    <span class="token expression">jae SYSCALL_ERROR_LABEL</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>里面对于任何一个系统调用，会调用DO_CALL。这也是一个宏，这个宏32位和64位的定义是不一样的。</p>
<h3 id="4-2-32位系统调用过程"><a href="#4-2-32位系统调用过程" class="headerlink" title="4.2 32位系统调用过程"></a>4.2 32位系统调用过程</h3><p>我们先来看32位的情况（i386目录下的sysdep.h文件）。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Linux takes system call arguments in registers:
    syscall number  %eax         call-clobbered
    arg 1           %ebx         call-saved
    arg 2           %ecx         call-clobbered
    arg 3           %edx         call-clobbered
    arg 4           %esi         call-saved
    arg 5           %edi         call-saved
    arg 6           %ebp         call-saved
......
*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">DO_CALL</span><span class="token punctuation">(</span>syscall_name<span class="token punctuation">,</span> args<span class="token punctuation">)</span>                 </span><span class="token punctuation">\</span>
    <span class="token expression">PUSHARGS_</span><span class="token punctuation">##</span><span class="token expression">args                                 </span><span class="token punctuation">\</span>
    <span class="token expression">DOARGS_</span><span class="token punctuation">##</span><span class="token expression">args                                   </span><span class="token punctuation">\</span>
    <span class="token expression">movl $<span class="token function">SYS_ify</span> <span class="token punctuation">(</span>syscall_name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>eax<span class="token punctuation">;</span>             </span><span class="token punctuation">\</span>
    <span class="token expression">ENTER_KERNEL                                    </span><span class="token punctuation">\</span>
    <span class="token expression">POPARGS_</span><span class="token punctuation">##</span><span class="token expression">args</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里，我们将请求参数放在寄存器里面，根据系统调用的名称，得到系统调用号，放在寄存器eax里面，然后执行ENTER_KERNEL。</p>
<p>在Linux的源代码注释里面，我们可以清晰地看到，这些寄存器是如何传递系统调用号和参数的。</p>
<p>这里面的ENTER_KERNEL是什么呢？</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span> <span class="token expression">ENTER_KERNEL <span class="token keyword">int</span> $<span class="token number">0x80</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>int就是interrupt，也就是“中断”的意思。int $0x80就是触发一个软中断，通过它就可以陷入（trap）内核。</p>
<p>在内核启动的时候，还记得有一个trap_init()，其中有这样的代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">set_system_intr_gate</span><span class="token punctuation">(</span>IA32_SYSCALL_VECTOR<span class="token punctuation">,</span> entry_INT80_32<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这是一个软中断的陷入门。当接收到一个系统调用的时候，entry_INT80_32就被调用了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">ENTRY</span><span class="token punctuation">(</span>entry_INT80_32<span class="token punctuation">)</span>
        ASM_CLAC
        pushl   <span class="token operator">%</span>eax                    <span class="token comment">/* pt_regs-&gt;orig_ax */</span>
        SAVE_ALL pt_regs_ax<span class="token operator">=</span>$<span class="token operator">-</span>ENOSYS    <span class="token comment">/* save rest */</span>
        movl    <span class="token operator">%</span>esp<span class="token punctuation">,</span> <span class="token operator">%</span>eax
        call    do_syscall_32_irqs_on
<span class="token punctuation">.</span>Lsyscall_32_done<span class="token operator">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">.</span>Lirq_return<span class="token operator">:</span>
    INTERRUPT_RETURN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过push和SAVE_ALL将当前用户态的寄存器，保存在pt_regs结构里面。</p>
<p>进入内核之前，保存所有的寄存器，然后调用do_syscall_32_irqs_on。它的实现如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token function">do_syscall_32_irqs_on</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span>regs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">thread_info</span> <span class="token operator">*</span>ti <span class="token operator">=</span> <span class="token function">current_thread_info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>regs<span class="token operator">-&gt;</span>orig_ax<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>nr <span class="token operator">&lt;</span> IA32_NR_syscalls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        regs<span class="token operator">-&gt;</span>ax <span class="token operator">=</span> ia32_sys_call_table<span class="token punctuation">[</span>nr<span class="token punctuation">]</span><span class="token punctuation">(</span>
            <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>regs<span class="token operator">-&gt;</span>bx<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>regs<span class="token operator">-&gt;</span>cx<span class="token punctuation">,</span>
            <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>regs<span class="token operator">-&gt;</span>dx<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>regs<span class="token operator">-&gt;</span>si<span class="token punctuation">,</span>
            <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>regs<span class="token operator">-&gt;</span>di<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>regs<span class="token operator">-&gt;</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">syscall_return_slowpath</span><span class="token punctuation">(</span>regs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里，我们看到，将系统调用号从eax里面取出来，然后根据系统调用号，在系统调用表中找到相应的函数进行调用，并将寄存器中保存的参数取出来，作为函数参数。如果仔细比对，就能发现，这些参数所对应的寄存器，和Linux的注释是一样的。</p>
<p>根据宏定义，#define ia32_sys_call_table sys_call_table，系统调用就是放在这个表里面。至于这个表是如何形成的，我们后面讲。</p>
<p>当系统调用结束之后，在entry_INT80_32之后，紧接着调用的是INTERRUPT_RETURN，我们能够找到它的定义，也就是iret。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">INTERRUPT_RETURN                iret</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>iret指令将原来用户态保存的现场恢复回来，包含代码段、指令指针寄存器等。这时候用户态进程恢复执行。</p>
<p>这里我总结一下32位的系统调用是如何执行的。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/32位系统调用执行过程.jpg" alt="32位系统调用执行过程"></p>
<h3 id="4-3-64位系统调用过程"><a href="#4-3-64位系统调用过程" class="headerlink" title="4.3 64位系统调用过程"></a>4.3 64位系统调用过程</h3><p>我们再来看64位的情况（x86_64下的sysdep.h文件）。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* The Linux/x86-64 kernel expects the system call parameters in
   registers according to the following table:
    syscall number  rax
    arg 1           rdi
    arg 2           rsi
    arg 3           rdx
    arg 4           r10
    arg 5           r8
    arg 6           r9
......
*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">DO_CALL</span><span class="token punctuation">(</span>syscall_name<span class="token punctuation">,</span> args<span class="token punctuation">)</span>                       </span><span class="token punctuation">\</span>
  <span class="token expression">lea <span class="token function">SYS_ify</span> <span class="token punctuation">(</span>syscall_name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>rax<span class="token punctuation">;</span>                       </span><span class="token punctuation">\</span>
  <span class="token expression">syscall</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>和之前一样，还是将系统调用名称转换为系统调用号，放到寄存器rax。这里是真正进行调用，不是用中断了，而是改用syscall指令了。并且，通过注释我们也可以知道，传递参数的寄存器也变了。</p>
<p>syscall指令还使用了一种特殊的寄存器，我们叫 <strong>特殊模块寄存器（Model Specific Registers，简称MSR）</strong> 。这种寄存器是CPU为了完成某些特殊控制功能为目的的寄存器，其中就有系统调用。</p>
<p>在系统初始化的时候，trap_init除了初始化上面的中断模式，这里面还会调用cpu_init-&gt;syscall_init。这里面有这样的代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">wrmsrl</span><span class="token punctuation">(</span>MSR_LSTAR<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span>entry_SYSCALL_64<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>rdmsr和wrmsr是用来读写特殊模块寄存器的。MSR_LSTAR就是这样一个特殊的寄存器，当syscall指令调用的时候，会从这个寄存器里面拿出函数地址来调用，也就是调用entry_SYSCALL_64。</p>
<p>在arch/x86/entry/entry_64.S中定义了entry_SYSCALL_64。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">ENTRY</span><span class="token punctuation">(</span>entry_SYSCALL_64<span class="token punctuation">)</span>
    <span class="token comment">/* Construct struct pt_regs on stack */</span>
    pushq   $__USER_DS                      <span class="token comment">/* pt_regs-&gt;ss */</span>
    pushq   <span class="token function">PER_CPU_VAR</span><span class="token punctuation">(</span>rsp_scratch<span class="token punctuation">)</span>        <span class="token comment">/* pt_regs-&gt;sp */</span>
    pushq   <span class="token operator">%</span>r11                            <span class="token comment">/* pt_regs-&gt;flags */</span>
    pushq   $__USER_CS                      <span class="token comment">/* pt_regs-&gt;cs */</span>
    pushq   <span class="token operator">%</span>rcx                            <span class="token comment">/* pt_regs-&gt;ip */</span>
    pushq   <span class="token operator">%</span>rax                            <span class="token comment">/* pt_regs-&gt;orig_ax */</span>
    pushq   <span class="token operator">%</span>rdi                            <span class="token comment">/* pt_regs-&gt;di */</span>
    pushq   <span class="token operator">%</span>rsi                            <span class="token comment">/* pt_regs-&gt;si */</span>
    pushq   <span class="token operator">%</span>rdx                            <span class="token comment">/* pt_regs-&gt;dx */</span>
    pushq   <span class="token operator">%</span>rcx                            <span class="token comment">/* pt_regs-&gt;cx */</span>
    pushq   $<span class="token operator">-</span>ENOSYS                        <span class="token comment">/* pt_regs-&gt;ax */</span>
    pushq   <span class="token operator">%</span>r8                             <span class="token comment">/* pt_regs-&gt;r8 */</span>
    pushq   <span class="token operator">%</span>r9                             <span class="token comment">/* pt_regs-&gt;r9 */</span>
    pushq   <span class="token operator">%</span>r10                            <span class="token comment">/* pt_regs-&gt;r10 */</span>
    pushq   <span class="token operator">%</span>r11                            <span class="token comment">/* pt_regs-&gt;r11 */</span>
    sub     $<span class="token punctuation">(</span><span class="token number">6</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>rsp                    <span class="token comment">/* pt_regs-&gt;bp, bx, r12-15 not saved */</span>
    movq    <span class="token function">PER_CPU_VAR</span><span class="token punctuation">(</span>current_task<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>r11
    testl   $_TIF_WORK_SYSCALL_ENTRY<span class="token operator">|</span>_TIF_ALLWORK_MASK<span class="token punctuation">,</span> <span class="token function">TASK_TI_flags</span><span class="token punctuation">(</span><span class="token operator">%</span>r11<span class="token punctuation">)</span>
    jnz     entry_SYSCALL64_slow_path
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
entry_SYSCALL64_slow_path<span class="token operator">:</span>
    <span class="token comment">/* IRQs are off. */</span>
    SAVE_EXTRA_REGS
    movq    <span class="token operator">%</span>rsp<span class="token punctuation">,</span> <span class="token operator">%</span>rdi
    call    do_syscall_64           <span class="token comment">/* returns with IRQs disabled */</span>
return_from_SYSCALL_64<span class="token operator">:</span>
    RESTORE_EXTRA_REGS
    TRACE_IRQS_IRETQ
    movq    <span class="token function">RCX</span><span class="token punctuation">(</span><span class="token operator">%</span>rsp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>rcx
    movq    <span class="token function">RIP</span><span class="token punctuation">(</span><span class="token operator">%</span>rsp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>r11
    movq    <span class="token function">R11</span><span class="token punctuation">(</span><span class="token operator">%</span>rsp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>r11
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
syscall_return_via_sysret<span class="token operator">:</span>
    <span class="token comment">/* rcx and r11 are already restored (see code above) */</span>
    RESTORE_C_REGS_EXCEPT_RCX_R11
    movq    <span class="token function">RSP</span><span class="token punctuation">(</span><span class="token operator">%</span>rsp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>rsp
    USERGS_SYSRET64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里先保存了很多寄存器到pt_regs结构里面，例如用户态的代码段、数据段、保存参数的寄存器，然后调用entry_SYSCALL64_slow_pat-&gt;do_syscall_64。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">__visible <span class="token keyword">void</span> <span class="token function">do_syscall_64</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span>regs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">thread_info</span> <span class="token operator">*</span>ti <span class="token operator">=</span> <span class="token function">current_thread_info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> nr <span class="token operator">=</span> regs<span class="token operator">-&gt;</span>orig_ax<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token punctuation">(</span>nr <span class="token operator">&amp;</span> __SYSCALL_MASK<span class="token punctuation">)</span> <span class="token operator">&lt;</span> NR_syscalls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            regs<span class="token operator">-&gt;</span>ax <span class="token operator">=</span> sys_call_table<span class="token punctuation">[</span>nr <span class="token operator">&amp;</span> __SYSCALL_MASK<span class="token punctuation">]</span><span class="token punctuation">(</span>
                    regs<span class="token operator">-&gt;</span>di<span class="token punctuation">,</span> regs<span class="token operator">-&gt;</span>si<span class="token punctuation">,</span> regs<span class="token operator">-&gt;</span>dx<span class="token punctuation">,</span>
                    regs<span class="token operator">-&gt;</span>r10<span class="token punctuation">,</span> regs<span class="token operator">-&gt;</span>r8<span class="token punctuation">,</span> regs<span class="token operator">-&gt;</span>r9<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">syscall_return_slowpath</span><span class="token punctuation">(</span>regs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在do_syscall_64里面，从rax里面拿出系统调用号，然后根据系统调用号，在系统调用表sys_call_table中找到相应的函数进行调用，并将寄存器中保存的参数取出来，作为函数参数。如果仔细比对，你就能发现，这些参数所对应的寄存器，和Linux的注释又是一样的。</p>
<p>所以，无论是32位，还是64位，都会到系统调用表sys_call_table这里来。</p>
<p>在研究系统调用表之前，我们看64位的系统调用返回的时候，执行的是USERGS_SYSRET64。定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">USERGS_SYSRET64     </span><span class="token punctuation">\</span>
    <span class="token expression">swapgs<span class="token punctuation">;</span>                 </span><span class="token punctuation">\</span>
    <span class="token expression">sysretq<span class="token punctuation">;</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这里，返回用户态的指令变成了sysretq。</p>
<p>我们这里总结一下64位的系统调用是如何执行的。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/64位系统调用执行过程.jpg" alt="64位系统调用执行过程.jpg"></p>
<h3 id="4-4-系统调用表"><a href="#4-4-系统调用表" class="headerlink" title="4.4 系统调用表"></a>4.4 系统调用表</h3><p>32位的系统调用表定义在面arch/x86/entry/syscalls/syscall_32.tbl文件里。例如open是这样定义的：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">5   i386    open            sys_open  compat_sys_open<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>64位的系统调用定义在另一个文件arch/x86/entry/syscalls/syscall_64.tbl里。例如open是这样定义的：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">2   common  open            sys_open<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>第一列的数字是系统调用号。可以看出，32位和64位的系统调用号是不一样的。第三列是系统调用的名字，第四列是系统调用在内核的实现函数。不过，它们都是以sys_开头。</p>
<p>系统调用在内核中的实现函数要有一个声明。声明往往在include/linux/syscalls.h文件中。例如sys_open是这样声明的：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">asmlinkage <span class="token keyword">long</span> <span class="token function">sys_open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>filename<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> umode_t mode<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>真正的实现这个系统调用，一般在一个.c文件里面，例如sys_open的实现在fs/open.c里面，但是你会发现样子很奇怪。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>open<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> filename<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> flags<span class="token punctuation">,</span> umode_t<span class="token punctuation">,</span> mode<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">force_o_largefile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        flags <span class="token operator">|=</span> O_LARGEFILE<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">do_sys_open</span><span class="token punctuation">(</span>AT_FDCWD<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>SYSCALL_DEFINE3是一个宏系统调用最多六个参数，根据参数的数目选择宏。具体是这样定义的：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">SYSCALL_DEFINE1</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">SYSCALL_DEFINEx</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> _</span><span class="token punctuation">##</span><span class="token expression">name<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">SYSCALL_DEFINE2</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">SYSCALL_DEFINEx</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> _</span><span class="token punctuation">##</span><span class="token expression">name<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">SYSCALL_DEFINEx</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> _</span><span class="token punctuation">##</span><span class="token expression">name<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">SYSCALL_DEFINE4</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">SYSCALL_DEFINEx</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> _</span><span class="token punctuation">##</span><span class="token expression">name<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">SYSCALL_DEFINE5</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">SYSCALL_DEFINEx</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> _</span><span class="token punctuation">##</span><span class="token expression">name<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">SYSCALL_DEFINE6</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">SYSCALL_DEFINEx</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> _</span><span class="token punctuation">##</span><span class="token expression">name<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span>


<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">SYSCALL_DEFINEx</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> sname<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>                          </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">SYSCALL_METADATA</span><span class="token punctuation">(</span>sname<span class="token punctuation">,</span> x<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span>                 </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">__SYSCALL_DEFINEx</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> sname<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span>


<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">__PROTECT</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">asmlinkage_protect</span><span class="token punctuation">(</span>__VA_ARGS__<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">__SYSCALL_DEFINEx</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>                                 </span><span class="token punctuation">\</span>
        <span class="token expression">asmlinkage <span class="token keyword">long</span> sys</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_DECL<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span>       </span><span class="token punctuation">\</span>
                <span class="token expression"><span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">alias</span><span class="token punctuation">(</span><span class="token function">__stringify</span><span class="token punctuation">(</span>SyS</span><span class="token punctuation">##</span><span class="token expression">name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">long</span> SYSC</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_DECL<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </span><span class="token punctuation">\</span>
        <span class="token expression">asmlinkage <span class="token keyword">long</span> SyS</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_LONG<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      </span><span class="token punctuation">\</span>
        <span class="token expression">asmlinkage <span class="token keyword">long</span> SyS</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_LONG<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span>       </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token punctuation">{</span>                                                               </span><span class="token punctuation">\</span>
                <span class="token expression"><span class="token keyword">long</span> ret <span class="token operator">=</span> SYSC</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_CAST<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </span><span class="token punctuation">\</span>
                <span class="token expression"><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_TEST<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">;</span>                         </span><span class="token punctuation">\</span>
                <span class="token expression"><span class="token function">__PROTECT</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> ret<span class="token punctuation">,</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_ARGS<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       </span><span class="token punctuation">\</span>
                <span class="token expression"><span class="token keyword">return</span> ret<span class="token punctuation">;</span>                                             </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token punctuation">}</span>                                                               </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">long</span> SYSC</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_DECL<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果我们把宏展开之后，实现如下，和声明的是一样的。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">asmlinkage <span class="token keyword">long</span> <span class="token function">sys_open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span> filename<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> mode<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">long</span> ret<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">force_o_largefile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        flags <span class="token operator">|=</span> O_LARGEFILE<span class="token punctuation">;</span>

    ret <span class="token operator">=</span> <span class="token function">do_sys_open</span><span class="token punctuation">(</span>AT_FDCWD<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">asmlinkage_protect</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> ret<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>声明和实现都好了。接下来，在编译的过程中，需要根据syscall_32.tbl和syscall_64.tbl生成自己的unistd_32.h和unistd_64.h。生成方式在arch/x86/entry/syscalls/Makefile中。</p>
<p>声明和实现都好了。接下来，在编译的过程中，需要根据syscall_32.tbl和syscall_64.tbl生成自己的unistd_32.h和unistd_64.h。生成方式在arch/x86/entry/syscalls/Makefile中。</p>
<p>这里面会使用两个脚本，其中第一个脚本arch/x86/entry/syscalls/syscallhdr.sh，会在文件中生成#define <strong>NR_open；第二个脚本arch/x86/entry/syscalls/syscalltbl.sh，会在文件中生成</strong>SYSCALL(__NR_open, sys_open)。这样，unistd_32.h和unistd_64.h是对应的系统调用号和系统调用实现函数之间的对应关系。</p>
<p>在文件arch/x86/entry/syscall_32.c，定义了这样一个表，里面include了这个头文件，从而所有的sys_系统调用都在这个表里面了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">__visible <span class="token keyword">const</span> sys_call_ptr_t ia32_sys_call_table<span class="token punctuation">[</span>__NR_syscall_compat_max<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">/*
        * Smells like a compiler bug -- it doesn't work
        * when the &amp; below is removed.
        */</span>
    <span class="token punctuation">[</span><span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> __NR_syscall_compat_max<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>sys_ni_syscall<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;asm/syscalls_32.h&gt;</span></span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同理，在文件arch/x86/entry/syscall_64.c，定义了这样一个表，里面include了这个头文件，这样所有的sys_系统调用就都在这个表里面了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* System call table for x86-64. */</span>
asmlinkage <span class="token keyword">const</span> sys_call_ptr_t sys_call_table<span class="token punctuation">[</span>__NR_syscall_max<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">/*
     * Smells like a compiler bug -- it doesn't work
     * when the &amp; below is removed.
     */</span>
    <span class="token punctuation">[</span><span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> __NR_syscall_max<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>sys_ni_syscall<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;asm/syscalls_64.h&gt;</span></span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="五、进程"><a href="#五、进程" class="headerlink" title="五、进程"></a>五、进程</h2><h3 id="5-1-源码编译"><a href="#5-1-源码编译" class="headerlink" title="5.1 源码编译"></a>5.1 源码编译</h3><p>CPU是不能执行文本文件里面的指令的，这些指令只有人能看懂，CPU能够执行的命令是二进制的，比如“0101”这种，所以这些指令还需要翻译一下，这个翻译的过程就是编译（Compile）。</p>
<p>在Linux下面，二进制的程序也要有严格的格式，这个格式我们称为ELF（Executeable and Linkable Format，可执行与可链接格式）。这个格式可以根据编译的结果不同，分为不同的格式。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/从文本文件编译成二进制格式.jpeg" alt="从文本文件编译成二进制格式"></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc -c -fPIC mylib.c
gcc -c -fPIC test_mylib.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ol>
<li><p>可重定位文件<br> 在编译的时候，先做预处理工作，例如将头文件嵌入到正文中，将定义的宏展开，然后就是真正的编译过程，最终编译成为.o文件，这就是ELF的第一种类型，<strong>可重定位文件（Relocatable File）</strong> 。</p>
<p> <img src="/images/《趣谈Linux操作系统》学习笔记/可重定位文件格式.jpg" alt="可重定位文件格式.jpg"></p>
<p> ELF文件的头是用于描述整个文件的。这个文件格式在内核中有定义，分别为struct elf32_hdr和struct elf64_hdr。</p>
<p> 接下来来看一个一个的section，也叫节。</p>
<ul>
<li>.text：放编译好的二进制可执行代码</li>
<li>.data：已经初始化好的全局变量</li>
<li>.rodata：只读数据，例如字符串常量、const的变量</li>
<li>.bss：未初始化全局变量，运行时会置0</li>
<li>.symtab：符号表，记录的则是函数和变量</li>
<li><p>.strtab：字符串表、字符串常量和变量名</p>
<p>这些节的元数据信息也需要有一个地方保存，就是最后的节头部表（Section Header Table）。在这个表里面，每一个section都有一项，在代码里面也有定义struct elf32_shdr和struct elf64_shdr。在ELF的头里面，有描述这个文件的节头部表的位置，有多少个表项等等信息。</p>
<p>.o里面的位置是不确定的，但是必须是可重新定位的，因为它将来是要做函数库的。有的section，例如.rel.text, .rel.data就与重定位有关。</p>
<p>要想让代码被重用，不能以.o的形式存在，而是要形成库文件，最简单的类型是静态链接库.a文件（Archives），仅仅将一系列对象文件（.o）归档为一个文件，使用命令ar创建。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ar cr libstatic_mylib.a mylib.o<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>虽然这里libstatic_mylib.a里面只有一个.o，但是实际情况可以有多个.o。当有程序要使用这个静态连接库的时候，会将.o文件提取出来，链接到程序中。</p>
</li>
</ul>
</li>
<li><p>可执行文件</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc -o static_test_mylib test_mylib.o -L. -lstatic_mylib<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 在这个命令里，-L表示在当前目录下找.a文件，-lstatic_mylib会自动补全文件名，比如加前缀lib，后缀.a，变成libstatic_mylib.a，找到这个.a文件后，将里面的mylib.o取出来，和test_mylib.o做一个链接，形成二进制执行文件static_test_mylib。</p>
<p> 形成的二进制文件叫可执行文件，是ELF的第二种格式，格式如下：</p>
<p> <img src="/images/《趣谈Linux操作系统》学习笔记/可执行文件格式.jpg" alt="可执行文件格式"></p>
<p> 这个格式和.o文件大致相似，还是分成一个个的section，并且被节头表描述。只不过这些section是多个.o文件合并过的。但是这个时候，这个文件已经是马上就可以加载到内存里面执行的文件了，因而这些section被分成了需要加载到内存里面的代码段、数据段和不需要加载到内存里面的部分，将小的section合成了大的段segment，并且在最前面加一个段头表（Segment Header Table）。在代码里面的定义为struct elf32_phdr和struct elf64_phdr，这里面除了有对于段的描述之外，最重要的是p_vaddr，这个是这个段加载到内存的虚拟地址。</p>
<p> 在ELF头里面，有一项e_entry，也是个虚拟地址，是这个程序运行的入口。</p>
<p> 静态链接库一旦链接进去，代码和变量的section都合并了，因而程序运行的时候，就不依赖于这个库是否存在。但是这样有一个缺点，就是相同的代码段，如果被多个程序使用的话，在内存里面就有多份，而且一旦静态链接库更新了，如果二进制执行文件不重新编译，也不随着更新。</p>
</li>
<li><p>动态链接库</p>
<p> 因而就出现了另一种，<strong>动态链接库（Shared Libraries）</strong>，不仅仅是一组对象文件的简单归档，而是多个对象文件的重新组合，可被多个程序共享。</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c">gcc <span class="token operator">-</span>shared <span class="token operator">-</span>fPIC <span class="token operator">-</span>o libdynamic_mylib<span class="token punctuation">.</span>so mylib<span class="token punctuation">.</span>o<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 当一个动态链接库被链接到一个程序文件中的时候，最后的程序文件并不包括动态链接库中的代码，而仅仅包括对动态链接库的引用，并且不保存动态链接库的全路径，仅仅保存动态链接库的名称。</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c">gcc <span class="token operator">-</span>o dynamic_test_mylib test_mylib<span class="token punctuation">.</span>o <span class="token operator">-</span>L<span class="token punctuation">.</span> <span class="token operator">-</span>ldynamic_mylib<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 当运行这个程序的时候，首先寻找动态链接库，然后加载它。默认情况下，系统在/lib和/usr/lib文件夹下寻找动态链接库。如果找不到就会报错，我们可以设定LD_LIBRARY_PATH环境变量，程序运行时会在此环境变量指定的文件夹下寻找动态链接库。</p>
<p> 动态链接库，就是ELF的第三种类型， <strong>共享对象文件（Shared Object）</strong> 。</p>
<p> 基于动态连接库创建出来的二进制文件格式还是ELF，但是稍有不同。</p>
<p> 首先，多了一个.interp的Segment，这里面是ld-linux.so，这是动态链接器，也就是说，运行时的链接动作都是它做的。</p>
<p> 另外，ELF文件中还多了两个section，一个是.plt，过程链接表（Procedure Linkage Table，PLT），一个是.got.plt，全局偏移量表（Global Offset Table，GOT）。</p>
<p> 它们是怎么工作的，使得程序运行的时候，可以将so文件动态链接到进程空间的呢？</p>
<p> dynamic_test_mylib这个程序要调用libdynamic_mylib.so里的函数。由于是运行时才去找，编译的时候，压根不知道这个函数在哪里，所以就在PLT里面建立一项PLT[x]。这一项也是一些代码，有点像一个本地的代理，在二进制程序dynamic_test_mylib里面，不直接调用libdynamic_mylib.so里的函数，而是调用PLT[x]里面的代理代码，这个代理代码会在运行的时候找真正的函数。</p>
<p> 去哪里找代理代码呢？这就用到了GOT，这里面也会为libdynamic_mylib.so中的函数创建一项GOT[y]。这一项是运行时libdynamic_mylib.so中的函数在内存中真正的地址。</p>
<p> 如果这个地址在，dynamic_test_mylib调用PLT[x]里面的代理代码，代理代码调用GOT表中对应项GOT[y]，调用的就是加载到内存中的libdynamic_mylib.so里面的对应函数了。</p>
<p> 但是GOT怎么知道的呢？对于libdynamic_mylib.so中的函数，GOT一开始就会创建一项GOT[y]，但是这里面没有真正的地址，因为它也不知道，但是它有办法，它又回调PLT，告诉它，你里面的代理代码来找我要libdynamic_mylib.so中函数的真实地址，我不知道，你想想办法吧。</p>
<p> PLT这个时候会转而调用PLT[0]，也即第一项，PLT[0]转而调用GOT[2]，这里面是ld-linux.so的入口函数，这个函数会找到加载到内存中的libdynamic_mylib.so里面的对应函数的地址，然后把这个地址放在GOT[y]里面。下次，PLT[x]的代理函数就能够直接调用了。</p>
</li>
</ol>
<h3 id="5-2-运行程序为进程"><a href="#5-2-运行程序为进程" class="headerlink" title="5.2 运行程序为进程"></a>5.2 运行程序为进程</h3><p>在内核中，有这样一个数据结构，用来定义加载二进制文件的方法。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">linux_binfmt</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">list_head</span> lh<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">module</span> <span class="token operator">*</span>module<span class="token punctuation">;</span>
        <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>load_binary<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">linux_binprm</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>load_shlib<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>core_dump<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">coredump_params</span> <span class="token operator">*</span>cprm<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> min_coredump<span class="token punctuation">;</span>     <span class="token comment">/* minimal dump size */</span>
<span class="token punctuation">}</span> __randomize_layout<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于ELF文件格式，有对应的实现。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">linux_binfmt</span> elf_format <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span>module         <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>load_binary    <span class="token operator">=</span> load_elf_binary<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>load_shlib     <span class="token operator">=</span> load_elf_library<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>core_dump      <span class="token operator">=</span> elf_core_dump<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>min_coredump   <span class="token operator">=</span> ELF_EXEC_PAGESIZE<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>load_elf_binary是不是你很熟悉？没错，我们加载内核镜像的时候，用的也是这种格式。</p>
<p>还记得当时是谁调用的load_elf_binary函数吗？具体是这样的：do_execve-&gt;do_execveat_common-&gt;exec_binprm-&gt;search_binary_handler。</p>
<p>那do_execve又是被谁调用的呢？我们看下面的代码。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>execve<span class="token punctuation">,</span>
        <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> filename<span class="token punctuation">,</span>
        <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token keyword">const</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> argv<span class="token punctuation">,</span>
        <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token keyword">const</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> envp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">do_execve</span><span class="token punctuation">(</span><span class="token function">getname</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">,</span> argv<span class="token punctuation">,</span> envp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>学过了系统调用一节，你会发现，原理是exec这个系统调用最终调用的load_elf_binary。</p>
<p>exec比较特殊，它是一组函数：</p>
<ul>
<li>包含p的函数（execvp, execlp）会在PATH路径下面寻找程序；</li>
<li>不包含p的函数需要输入程序的全路径；</li>
<li>包含v的函数（execv, execvp, execve）以数组的形式接收参数；</li>
<li>包含l的函数（execl, execlp, execle）以列表的形式接收参数；</li>
<li>包含e的函数（execve, execle）以数组的形式接收环境变量。</li>
</ul>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/exec系列函数.jpg" alt="exec系列函数"></p>
<h3 id="5-3-进程树"><a href="#5-3-进程树" class="headerlink" title="5.3 进程树"></a>5.3 进程树</h3><p>既然所有的进程都是从父进程fork过来的，那总归有一个祖宗进程，这就是咱们系统启动的init进程。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/linux进程树.jpeg" alt="linux进程树"></p>
<p>在解析Linux的启动过程的时候，1号进程是/sbin/init。如果在centOS 7里面，我们ls一下，可以看到，这个进程是被软链接到systemd的。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/sbin/init -<span class="token operator">&gt;</span> <span class="token punctuation">..</span>/lib/systemd/systemd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>系统启动之后，init进程会启动很多的daemon进程，为系统运行提供服务，然后就是启动getty，让用户登录，登录后运行shell，用户启动的进程都是通过shell运行的，从而形成了一棵进程树。</p>
<p>我们可以通过ps -ef命令查看当前系统启动的进程，我们会发现有三类进程。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ps</span> -ef
<span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
root         <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?        00:00:29 /usr/lib/systemd/systemd --system --deserialize <span class="token number">21</span>
root         <span class="token number">2</span>     <span class="token number">0</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?        00:00:00 <span class="token punctuation">[</span>kthreadd<span class="token punctuation">]</span>
root         <span class="token number">3</span>     <span class="token number">2</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?        00:00:00 <span class="token punctuation">[</span>ksoftirqd/0<span class="token punctuation">]</span>
root         <span class="token number">5</span>     <span class="token number">2</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?        00:00:00 <span class="token punctuation">[</span>kworker/0:0H<span class="token punctuation">]</span>
root         <span class="token number">9</span>     <span class="token number">2</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?        00:00:40 <span class="token punctuation">[</span>rcu_sched<span class="token punctuation">]</span>
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
root       <span class="token number">337</span>     <span class="token number">2</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?        00:00:01 <span class="token punctuation">[</span>kworker/3:1H<span class="token punctuation">]</span>
root       <span class="token number">380</span>     <span class="token number">1</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?        00:00:00 /usr/lib/systemd/systemd-udevd
root       <span class="token number">415</span>     <span class="token number">1</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?        00:00:01 /sbin/auditd
root       <span class="token number">498</span>     <span class="token number">1</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?        00:00:03 /usr/lib/systemd/systemd-logind
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
root       <span class="token number">852</span>     <span class="token number">1</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?        00:06:25 /usr/sbin/rsyslogd -n
root      <span class="token number">2580</span>     <span class="token number">1</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?        00:00:00 /usr/sbin/sshd -D
root     <span class="token number">29058</span>     <span class="token number">2</span>  <span class="token number">0</span> Jan03 ?        00:00:01 <span class="token punctuation">[</span>kworker/1:2<span class="token punctuation">]</span>
root     <span class="token number">29672</span>     <span class="token number">2</span>  <span class="token number">0</span> Jan04 ?        00:00:09 <span class="token punctuation">[</span>kworker/2:1<span class="token punctuation">]</span>
root     <span class="token number">30467</span>     <span class="token number">1</span>  <span class="token number">0</span> Jan06 ?        00:00:00 /usr/sbin/crond -n
root     <span class="token number">31574</span>     <span class="token number">2</span>  <span class="token number">0</span> Jan08 ?        00:00:01 <span class="token punctuation">[</span>kworker/u128:2<span class="token punctuation">]</span>
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
root     <span class="token number">32792</span>  <span class="token number">2580</span>  <span class="token number">0</span> Jan10 ?        00:00:00 sshd: root@pts/0
root     <span class="token number">32794</span> <span class="token number">32792</span>  <span class="token number">0</span> Jan10 pts/0    00:00:00 -bash
root     <span class="token number">32901</span> <span class="token number">32794</span>  <span class="token number">0</span> 00:01 pts/0    00:00:00 <span class="token function">ps</span> -ef<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>你会发现，PID 1的进程就是我们的init进程systemd，PID 2的进程是内核线程kthreadd，这两个我们在内核启动的时候都见过。其中用户态的不带中括号，内核态的带中括号。</p>
<p>接下来进程号依次增大，但是你会看所有带中括号的内核态的进程，祖先都是2号进程。而用户态的进程，祖先都是1号进程。tty那一列，是问号的，说明不是前台启动的，一般都是后台的服务。</p>
<p>pts的父进程是sshd，bash的父进程是pts，ps -ef这个命令的父进程是bash。这样整个链条都比较清晰了。</p>
<h3 id="5-4-总结"><a href="#5-4-总结" class="headerlink" title="5.4 总结"></a>5.4 总结</h3><p>我们首先通过图右边的文件编译过程，生成so文件和可执行文件，放在硬盘上。下图左边的用户态的进程A执行fork，创建进程B，在进程B的处理逻辑中，执行exec系列系统调用。这个系统调用会通过load_elf_binary方法，将刚才生成的可执行文件，加载到进程B的内存中执行。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/进程从代码到二进制到运行的过程.jpeg" alt="进程从代码到二进制到运行的过程"></p>
<h2 id="六、线程"><a href="#六、线程" class="headerlink" title="六、线程"></a>六、线程</h2><h3 id="6-1-为什么要有线程？"><a href="#6-1-为什么要有线程？" class="headerlink" title="6.1 为什么要有线程？"></a>6.1 为什么要有线程？</h3><p>对于任何一个进程来讲，即便我们没有主动去创建线程，进程也是默认有一个主线程的。线程是负责执行二进制指令的，一行一行执行下去。进程要比线程管的宽多了，除了执行指令之外，内存、文件系统等等都要它来管。</p>
<p><strong>进程相当于一个项目，而线程就是为了完成项目需求，而建立的一个个开发任务。</strong></p>
<p>使用进程实现并行执行的问题也有两个。第一，创建进程占用资源太多；第二，进程之间的通信需要数据在不同的内存空间传来传去，无法共享。</p>
<h3 id="6-2-如何创建线程？"><a href="#6-2-如何创建线程？" class="headerlink" title="6.2 如何创建线程？"></a>6.2 如何创建线程？</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">NUM_OF_TASKS <span class="token number">5</span></span></span>

<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">downloadfile</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>filename<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am downloading the file %s!\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">long</span> downloadtime <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">100</span><span class="token punctuation">;</span>
   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I finish downloading the file within %d minutes!\n"</span><span class="token punctuation">,</span> downloadtime<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>downloadtime<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token keyword">char</span> files<span class="token punctuation">[</span>NUM_OF_TASKS<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">"file1.avi"</span><span class="token punctuation">,</span><span class="token string">"file2.rmvb"</span><span class="token punctuation">,</span><span class="token string">"file3.mp4"</span><span class="token punctuation">,</span><span class="token string">"file4.wmv"</span><span class="token punctuation">,</span><span class="token string">"file5.flv"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
   pthread_t threads<span class="token punctuation">[</span>NUM_OF_TASKS<span class="token punctuation">]</span><span class="token punctuation">;</span>
   <span class="token keyword">int</span> rc<span class="token punctuation">;</span>
   <span class="token keyword">int</span> t<span class="token punctuation">;</span>
   <span class="token keyword">int</span> downloadtime<span class="token punctuation">;</span>

   pthread_attr_t thread_attr<span class="token punctuation">;</span>
   <span class="token function">pthread_attr_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_attr<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token function">pthread_attr_setdetachstate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_attr<span class="token punctuation">,</span>PTHREAD_CREATE_JOINABL<span class="token punctuation">)</span><span class="token punctuation">;</span>

   <span class="token keyword">for</span><span class="token punctuation">(</span>t<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>t<span class="token operator">&lt;</span>NUM_OF_TASKS<span class="token punctuation">;</span>t<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"creating thread %d, please help me to download %s\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> files<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     rc <span class="token operator">=</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>threads<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>thread_attr<span class="token punctuation">,</span> downloadfile<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>files<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>rc<span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ERROR; return code from pthread_create() is %d\n"</span><span class="token punctuation">,</span> rc<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

   <span class="token function">pthread_attr_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_attr<span class="token punctuation">)</span><span class="token punctuation">;</span>

   <span class="token keyword">for</span><span class="token punctuation">(</span>t<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>t<span class="token operator">&lt;</span>NUM_OF_TASKS<span class="token punctuation">;</span>t<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token function">pthread_join</span><span class="token punctuation">(</span>threads<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>downloadtime<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Thread %d downloads the file %s in %d minutes.\n"</span><span class="token punctuation">,</span>t<span class="token punctuation">,</span>files<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">,</span>downloadtime<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

   <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一个运行中的线程可以调用pthread_exit退出线程。这个函数可以传入一个参数转换为(void *)类型。这是线程退出的返回值。</p>
<p>接下来，我们来看主线程。在这里面，我列了五个文件名。接下来声明了一个数组，里面有五个pthread_t类型的线程对象。</p>
<p>接下来，声明一个线程属性pthread_attr_t。我们通过pthread_attr_init初始化这个属性，并且设置属性PTHREAD_CREATE_JOINABLE。这表示将来主线程程等待这个线程的结束，并获取退出时的状态。</p>
<p>接下来是一个循环。对于每一个文件和每一个线程，可以调用pthread_create创建线程。一共有四个参数，第一个参数是线程对象，第二个参数是线程的属性，第三个参数是线程运行函数，第四个参数是线程运行函数的参数。主线程就是通过第四个参数，将自己的任务派给子线程。</p>
<p>任务分配完毕，每个线程下载一个文件，接下来主线程要做的事情就是等待这些子任务完成。当一个线程退出的时候，就会发送信号给其他所有同进程的线程。有一个线程使用pthread_join获取这个线程退出的返回值。线程的返回值通过pthread_join传给主线程，这样子线程就将自己下载文件所耗费的时间，告诉给主线程。</p>
<p>好了，程序写完了，开始编译。多线程程序要依赖于libpthread.so。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc download.c -lpthread<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>总结一下，一个普通线程的创建和运行过程。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/线程的创建和运行过程.jpg" alt="线程的创建和运行过程"></p>
<h3 id="6-3-线程的数据"><a href="#6-3-线程的数据" class="headerlink" title="6.3 线程的数据"></a>6.3 线程的数据</h3><p>我们把线程访问的数据细分成三类。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/线程访问的数据.jpg" alt="线程访问的数据"></p>
<ol>
<li><p>线程栈上的本地数据</p>
<p> 比如函数执行过程中的局部变量。前面我们说过，函数的调用会使用栈的模型，这在线程里面是一样的。只不过每个线程都有自己的栈空间。</p>
<p> 栈的大小可以通过命令ulimit -a查看，默认情况下线程栈大小为8192（8MB）。我们可以使用命令ulimit -s修改。</p>
<p> 对于线程栈，可以通过下面这个函数pthread_attr_t，修改线程栈的大小。</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pthread_attr_setstacksize</span><span class="token punctuation">(</span>pthread_attr_t <span class="token operator">*</span>attr<span class="token punctuation">,</span> size_t stacksize<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 主线程在内存中有一个栈空间，其他线程栈也拥有独立的栈空间。为了避免线程之间的栈空间踩踏，线程栈之间还会有小块区域，用来隔离保护各自的栈空间。一旦另一个线程踏入到这个隔离区，就会引发段错误。</p>
</li>
<li><p>在整个进程里共享的全局数据</p>
<p> 例如全局变量，虽然在不同进程中是隔离的，但是在一个进程中是共享的。</p>
</li>
<li><p>线程私有数据（Thread Specific Data）</p>
<p> 可以通过以下函数创建：</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pthread_key_create</span><span class="token punctuation">(</span>pthread_key_t <span class="token operator">*</span>key<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>destructor<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 可以看到，创建一个key，伴随着一个析构函数。</p>
<p> key一旦被创建，所有线程都可以访问它，但各线程可根据自己的需要往key中填入不同的值，这就相当于提供了一个同名而不同值的全局变量。</p>
<p> 我们可以通过下面的函数设置key对应的value。</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pthread_setspecific</span><span class="token punctuation">(</span>pthread_key_t key<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>value<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 我们还可以通过下面的函数获取key对应的value。</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">pthread_getspecific</span><span class="token punctuation">(</span>pthread_key_t key<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 而等到线程退出的时候，就会调用析构函数释放value。</p>
</li>
</ol>
<h3 id="6-4-数据的保护"><a href="#6-4-数据的保护" class="headerlink" title="6.4 数据的保护"></a>6.4 数据的保护</h3><p>Mutex，全称Mutual Exclusion，中文叫互斥。顾名思义，有你没我，有我没你。它的模式就是在共享数据访问的时候，去申请加把锁，谁先拿到锁，谁就拿到了访问权限，其他人就只好在门外等着，等这个人访问结束，把锁打开，其他人再去争夺，还是遵循谁先拿到谁访问。</p>
<p>使用Mutex，首先要使用pthread_mutex_init函数初始化这个mutex，初始化后，就可以用它来保护共享变量了。</p>
<p>pthread_mutex_lock() 就是去抢那把锁的函数，如果抢到了，就可以执行下一行程序，对共享变量进行访；如果没抢到，就被阻塞在那里等待。</p>
<p>如果不想被阻塞，可以使用pthread_mutex_trylock去抢那把锁，如果抢到了，就可以执行下一行程序，对共享变量进行访问；如果没抢到，不会被阻塞，而是返回一个错误码。</p>
<p>当共享数据访问结束了，别忘了使用pthread_mutex_unlock释放锁，让给其他人使用，最终调用pthread_mutex_destroy销毁掉这把锁。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/Mutex的使用流程.jpg" alt="Mutex的使用流程"></p>
<p>在使用Mutex的时候，有个问题是如果使用pthread_mutex_lock()，那就需要一直在那里等着。如果是pthread_mutex_trylock()，就可以不用等着，去干点儿别的，但是我怎么知道什么时候回来再试一下，是不是轮到我了呢？能不能在轮到我的时候，通知我一下呢？</p>
<p>这其实就是条件变量，也就是说如果没事儿，就让大家歇着，有事儿了就去通知，别让人家没事儿就来问问，浪费大家的时间。</p>
<p>但是当它接到了通知，来操作共享资源的时候，还是需要抢互斥锁，因为可能很多人都受到了通知，都来访问了，所以 <strong>条件变量和互斥锁是配合使用的</strong> 。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/条件变量和互斥锁配合使用流程.jpeg" alt="条件变量和互斥锁配合使用流程"></p>
<h3 id="6-5-总结"><a href="#6-5-总结" class="headerlink" title="6.5 总结"></a>6.5 总结</h3><p><img src="/images/《趣谈Linux操作系统》学习笔记/多线程总结.png" alt="多线程总结"></p>
<h2 id="七、进程数据结构（上）"><a href="#七、进程数据结构（上）" class="headerlink" title="七、进程数据结构（上）"></a>七、进程数据结构（上）</h2><p>在Linux里面，无论是进程，还是线程，到了内核里面，我们统一都叫任务（Task），由一个统一的结构task_struct进行管理。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/Linux中的任务.jpeg" alt="Linux中的任务"></p>
<p>Linux内核有一个链表，将所有的task_struct串起来。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">list_head</span>        tasks<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>接下来，我们来看每一个任务都应该包含哪些字段。</p>
<h3 id="7-1-任务ID"><a href="#7-1-任务ID" class="headerlink" title="7.1 任务ID"></a>7.1 任务ID</h3><p>每一个任务都应该有一个ID，作为这个任务的唯一标识。到时候排期啊、下发任务啊等等，都按ID来，就不会产生歧义。</p>
<p>task_struct里面涉及任务ID的，有下面几个：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">pid_t pid<span class="token punctuation">;</span>
pid_t tgid<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>group_leader<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>你可能觉得奇怪，既然是ID，有一个就足以做唯一标识了，这个怎么看起来这么麻烦？这是因为，上面的进程和线程到了内核这里，统一变成了任务，这就带来两个问题。</p>
<ol>
<li><p>任务展示</p>
<p> 前面我们学习命令行的时候，知道ps命令可以展示出所有的进程。但是如果你是这个命令的实现者，到了内核，按照上面的任务列表把这些命令都显示出来，把所有的线程全都平摊开来显示给用户。用户肯定觉得既复杂又困惑。复杂在于，列表这么长；困惑在于，里面出现了很多并不是自己创建的线程。</p>
</li>
<li><p>给任务下发指令</p>
<p> 可以通过kill来给进程发信号，通知进程退出。如果发给了其中一个线程，我们就不能只退出这个线程，而是应该退出整个进程。当然，有时候，我们希望只给某个线程发信号。</p>
<p> 所以在内核中，它们虽然都是任务，但是应该加以区分。其中，pid是process id，tgid是thread group ID。</p>
<p> 任何一个进程，如果只有主线程，那pid是自己，tgid是自己，group_leader指向的还是自己。</p>
<p> 但是，如果一个进程创建了其他线程，那就会有所变化了。线程有自己的pid，tgid就是进程的主线程的pid，group_leader指向的就是进程的主线程。</p>
<p> 好了，有了tgid，我们就知道tast_struct代表的是一个进程还是代表一个线程了。</p>
</li>
</ol>
<h3 id="7-2-信号处理"><a href="#7-2-信号处理" class="headerlink" title="7.2 信号处理"></a>7.2 信号处理</h3><p>task_struct里面关于信号处理的字段。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Signal handlers: */</span>
<span class="token keyword">struct</span> <span class="token class-name">signal_struct</span>    <span class="token operator">*</span>signal<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">sighand_struct</span>   <span class="token operator">*</span>sighand<span class="token punctuation">;</span>
sigset_t                blocked<span class="token punctuation">;</span>
sigset_t                real_blocked<span class="token punctuation">;</span>
sigset_t                saved_sigmask<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">sigpending</span>       pending<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span>           sas_ss_sp<span class="token punctuation">;</span>
size_t                  sas_ss_size<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span>            sas_ss_flags<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里定义了哪些信号被阻塞暂不处理（blocked），哪些信号尚等待处理（pending），哪些信号正在通过信号处理函数进行处理（sighand）。处理的结果可以是忽略，可以是结束进程等等。</p>
<p>信号处理函数默认使用用户态的函数栈，当然也可以开辟新的栈专门用于信号处理，这就是sas_ss_xxx这三个变量的作用。</p>
<p>上面我说了下发信号的时候，需要区分进程和线程。从这里我们其实也能看出一些端倪。</p>
<p>task_struct里面有一个struct sigpending pending。如果我们进入struct signal_struct *signal去看的话，还有一个struct sigpending shared_pending。它们一个是本任务的，一个是线程组共享的。</p>
<h3 id="7-3-任务状态"><a href="#7-3-任务状态" class="headerlink" title="7.3 任务状态"></a>7.3 任务状态</h3><p>在task_struct里面，涉及任务状态的是下面这几个变量：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">volatile</span> <span class="token keyword">long</span> state<span class="token punctuation">;</span>    <span class="token comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span>
<span class="token keyword">int</span> exit_state<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> flags<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>state（状态）可以取的值定义在include/linux/sched.h头文件中。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Used in tsk-&gt;state: */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">TASK_RUNNING                    <span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">TASK_INTERRUPTIBLE              <span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">TASK_UNINTERRUPTIBLE            <span class="token number">2</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">__TASK_STOPPED                  <span class="token number">4</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">__TASK_TRACED                   <span class="token number">8</span></span></span>
<span class="token comment">/* Used in tsk-&gt;exit_state: */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">EXIT_DEAD                       <span class="token number">16</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">EXIT_ZOMBIE                     <span class="token number">32</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">EXIT_TRACE</span>                      <span class="token punctuation">(</span>EXIT_ZOMBIE <span class="token operator">|</span> EXIT_DEAD<span class="token punctuation">)</span></span></span>
<span class="token comment">/* Used in tsk-&gt;state again: */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">TASK_DEAD                       <span class="token number">64</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">TASK_WAKEKILL                   <span class="token number">128</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">TASK_WAKING                     <span class="token number">256</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">TASK_PARKED                     <span class="token number">512</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">TASK_NOLOAD                     <span class="token number">1024</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">TASK_NEW                        <span class="token number">2048</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">TASK_STATE_MAX                  <span class="token number">4096</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从定义的数值很容易看出来，flags是通过bitset的方式设置的也就是说，当前是什么状态，哪一位就置一。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/任务状态.jpeg" alt="任务状态"></p>
<p>TASK_RUNNING并不是说进程正在运行，而是表示进程在时刻准备运行的状态。当处于这个状态的进程获得时间片的时候，就是在运行中；如果没有获得时间片，就说明它被其他进程抢占了，在等待再次分配时间片。</p>
<p>在运行中的进程，一旦要进行一些I/O操作，需要等待I/O完毕，这个时候会释放CPU，进入睡眠状态。</p>
<p>在Linux中，有两种睡眠状态。</p>
<ol>
<li><p>TASK_INTERRUPTIBLE，可中断的睡眠状态。</p>
<p> 这是一种浅睡眠的状态，也就是说，虽然在睡眠，等待I/O完成，但是这个时候一个信号来的时候，进程还是要被唤醒。只不过唤醒后，不是继续刚才的操作，而是进行信号处理。当然程序员可以根据自己的意愿，来写信号处理函数，例如收到某些信号，就放弃等待这个I/O操作完成，直接退出，也可也收到某些信息，继续等待。</p>
</li>
<li><p>TASK_UNINTERRUPTIBLE，不可中断的睡眠状态。</p>
<p> 这是一种深度睡眠状态，不可被信号唤醒，只能死等I/O操作完成。一旦I/O操作因为特殊原因不能完成，这个时候，谁也叫不醒这个进程了。你可能会说，我kill它呢？别忘了，kill本身也是一个信号，既然这个状态不可被信号唤醒，kill信号也被忽略了。除非重启电脑，没有其他办法。</p>
<p> 因此，这其实是一个比较危险的事情，除非程序员极其有把握，不然还是不要设置成TASK_UNINTERRUPTIBLE。</p>
</li>
</ol>
<p>于是，我们就有了一种新的进程睡眠状态，TASK_KILLABLE，可以终止的新睡眠状态。进程处于这种状态中，它的运行原理类似TASK_UNINTERRUPTIBLE，只不过可以响应致命信号。</p>
<p>从定义可以看出，TASK_WAKEKILL用于在接收到致命信号时唤醒进程，而TASK_KILLABLE相当于这两位都设置了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">TASK_KILLABLE</span>           <span class="token punctuation">(</span>TASK_WAKEKILL <span class="token operator">|</span> TASK_UNINTERRUPTIBLE<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>TASK_STOPPED是在进程接收到SIGSTOP、SIGTTIN、SIGTSTP或者SIGTTOU信号之后进入该状态。</p>
<p>TASK_TRACED表示进程被debugger等进程监视，进程执行被调试程序所停止。当一个进程被另外的进程所监视，每一个信号都会让进程进入该状态。</p>
<p>一旦一个进程要结束，先进入的是EXIT_ZOMBIE状态，但是这个时候它的父进程还没有使用wait()等系统调用来获知它的终止信息，此时进程就成了僵尸进程。</p>
<p>EXIT_DEAD是进程的最终状态。</p>
<p>EXIT_ZOMBIE和EXIT_DEAD也可以用于exit_state。</p>
<p>上面的进程状态和进程的运行、调度有关系，还有其他的一些状态，我们称为标志。放在flags字段中，这些字段都被定义称为宏，以PF开头。我这里举几个例子。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">PF_EXITING      <span class="token number">0x00000004</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">PF_VCPU         <span class="token number">0x00000010</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">PF_FORKNOEXEC   <span class="token number">0x00000040</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li><strong>PF_EXITING</strong> 表示正在退出。当有这个flag的时候，在函数find_alive_thread中，找活着的线程，遇到有这个flag的，就直接跳过。</li>
<li><strong>PF_VCPU</strong> 表示进程运行在虚拟CPU上。在函数account_system_time中，统计进程的系统运行时间，如果有这个flag，就调用account_guest_time，按照客户机的时间进行统计。</li>
<li><strong>PF_FORKNOEXEC</strong> 表示fork完了，还没有exec。在_do_fork函数里面调用copy_process，这个时候把flag设置为PF_FORKNOEXEC。当exec中调用了load_elf_binary的时候，又把这个flag去掉。</li>
</ul>
<h3 id="7-4-进程调度"><a href="#7-4-进程调度" class="headerlink" title="7.4 进程调度"></a>7.4 进程调度</h3><p>进程的状态切换往往涉及调度，下面这些字段都是用于调度的。为了让你理解task_struct进程管理的全貌，我先在这里列一下，咱们后面会有单独的章节讲解，这里你只要大概看一下里面的注释就好了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//是否在运行队列上</span>
<span class="token keyword">int</span>                         on_rq<span class="token punctuation">;</span>
<span class="token comment">//优先级</span>
<span class="token keyword">int</span>                         prio<span class="token punctuation">;</span>
<span class="token keyword">int</span>                         static_prio<span class="token punctuation">;</span>
<span class="token keyword">int</span>                         normal_prio<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span>                rt_priority<span class="token punctuation">;</span>
<span class="token comment">//调度器类</span>
<span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span>    <span class="token operator">*</span>sched_class<span class="token punctuation">;</span>
<span class="token comment">//调度实体</span>
<span class="token keyword">struct</span> <span class="token class-name">sched_entity</span>         se<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">sched_rt_entity</span>      rt<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">sched_dl_entity</span>      dl<span class="token punctuation">;</span>
<span class="token comment">//调度策略</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span>                policy<span class="token punctuation">;</span>
<span class="token comment">//可以使用哪些CPU</span>
<span class="token keyword">int</span>                         nr_cpus_allowed<span class="token punctuation">;</span>
cpumask_t                   cpus_allowed<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">sched_info</span>           sched_info<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="7-5-总结"><a href="#7-5-总结" class="headerlink" title="7.5 总结"></a>7.5 总结</h3><p>画一个图总结一下。这个图是进程管理task_struct的的结构图。其中红色的部分是今天讲的部分，你可以对着这张图说出它们的含义。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/进程管理task_struct的结构图（上）.jpeg" alt="进程管理task_struct的结构图（上）"></p>
<h2 id="八、进程数据结构（中）"><a href="#八、进程数据结构（中）" class="headerlink" title="八、进程数据结构（中）"></a>八、进程数据结构（中）</h2><h3 id="8-1-运行统计信息"><a href="#8-1-运行统计信息" class="headerlink" title="8.1 运行统计信息"></a>8.1 运行统计信息</h3><p>在进程的运行过程中，会有一些统计量，具体你可以看下面的列表。这里面有进程在用户态和内核态消耗的时间、上下文切换的次数等等。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">u64             utime<span class="token punctuation">;</span><span class="token comment">//用户态消耗的CPU时间</span>
u64             stime<span class="token punctuation">;</span><span class="token comment">//内核态消耗的CPU时间</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span>   nvcsw<span class="token punctuation">;</span><span class="token comment">//自愿(voluntary)上下文切换计数</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span>   nivcsw<span class="token punctuation">;</span><span class="token comment">//非自愿(involuntary)上下文切换计数</span>
u64             start_time<span class="token punctuation">;</span><span class="token comment">//进程启动时间，不包含睡眠时间</span>
u64             real_start_time<span class="token punctuation">;</span><span class="token comment">//进程启动时间，包含睡眠时间</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="8-2-进程亲缘关系"><a href="#8-2-进程亲缘关系" class="headerlink" title="8.2 进程亲缘关系"></a>8.2 进程亲缘关系</h3><p>从我们之前讲的创建进程的过程，可以看出，任何一个进程都有父进程。所以，整个进程其实就是一棵进程树。而拥有同一父进程的所有进程都具有兄弟关系。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> __rcu <span class="token operator">*</span>real_parent<span class="token punctuation">;</span> <span class="token comment">/* real parent process */</span>
<span class="token keyword">struct</span> <span class="token class-name">task_struct</span> __rcu <span class="token operator">*</span>parent<span class="token punctuation">;</span> <span class="token comment">/* recipient of SIGCHLD, wait4() reports */</span>
<span class="token keyword">struct</span> <span class="token class-name">list_head</span> children<span class="token punctuation">;</span>      <span class="token comment">/* list of my children */</span>
<span class="token keyword">struct</span> <span class="token class-name">list_head</span> sibling<span class="token punctuation">;</span>       <span class="token comment">/* linkage in my parent's children list */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>parent指向其父进程。当它终止时，必须向它的父进程发送信号。</li>
<li>children表示链表的头部。链表中的所有元素都是它的子进程。</li>
<li>sibling用于把当前进程插入到兄弟链表中。</li>
</ul>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/进程亲缘关系.jpeg" alt="进程亲缘关系"></p>
<p>通常情况下，real_parent和parent是一样的，但是也会有另外的情况存在。例如，bash创建一个进程，那进程的parent和real_parent就都是bash。如果在bash上使用GDB来debug一个进程，这个时候GDB是real_parent，bash是这个进程的parent。</p>
<h3 id="8-3-进程权限"><a href="#8-3-进程权限" class="headerlink" title="8.3 进程权限"></a>8.3 进程权限</h3><p>在Linux里面，对于进程权限的定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Objective and real subjective task credentials (COW): */</span>
<span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">cred</span> __rcu         <span class="token operator">*</span>real_cred<span class="token punctuation">;</span>
<span class="token comment">/* Effective (overridable) subjective task credentials (COW): */</span>
<span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">cred</span> __rcu         <span class="token operator">*</span>cred<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个结构的注释里，有两个名词比较拗口，Objective和Subjective。事实上，所谓的权限，就是我能操纵谁，谁能操纵我。</p>
<p>“谁能操作我”，很显然，这个时候我就是被操作的对象，就是Objective，那个想操作我的就是Subjective。“我能操作谁”，这个时候我就是Subjective，那个要被我操作的就是Objectvie。</p>
<p>“操作”，就是一个对象对另一个对象进行某些动作。当动作要实施的时候，就要审核权限，当两边的权限匹配上了，就可以实施操作。其中，real_cred就是说明谁能操作我这个进程，而cred就是说明我这个进程能够操作谁。</p>
<p>这里cred的定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">cred</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        kuid_t          uid<span class="token punctuation">;</span>            <span class="token comment">/* real UID of the task */</span>
        kgid_t          gid<span class="token punctuation">;</span>            <span class="token comment">/* real GID of the task */</span>
        kuid_t          suid<span class="token punctuation">;</span>           <span class="token comment">/* saved UID of the task */</span>
        kgid_t          sgid<span class="token punctuation">;</span>           <span class="token comment">/* saved GID of the task */</span>
        kuid_t          euid<span class="token punctuation">;</span>           <span class="token comment">/* effective UID of the task */</span>
        kgid_t          egid<span class="token punctuation">;</span>           <span class="token comment">/* effective GID of the task */</span>
        kuid_t          fsuid<span class="token punctuation">;</span>          <span class="token comment">/* UID for VFS ops */</span>
        kgid_t          fsgid<span class="token punctuation">;</span>          <span class="token comment">/* GID for VFS ops */</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        kernel_cap_t    cap_inheritable<span class="token punctuation">;</span> <span class="token comment">/* caps our children can inherit */</span>
        kernel_cap_t    cap_permitted<span class="token punctuation">;</span>  <span class="token comment">/* caps we're permitted */</span>
        kernel_cap_t    cap_effective<span class="token punctuation">;</span>  <span class="token comment">/* caps we can actually use */</span>
        kernel_cap_t    cap_bset<span class="token punctuation">;</span>       <span class="token comment">/* capability bounding set */</span>
        kernel_cap_t    cap_ambient<span class="token punctuation">;</span>    <span class="token comment">/* Ambient capability set */</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span> __randomize_layout<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从这里的定义可以看出，大部分是关于 <strong>用户和用户所属的用户组信息</strong> 。</p>
<ol>
<li><p>第一个是uid和gid，注释是real user/group id。一般情况下，谁启动的进程，就是谁的ID。但是权限审核的时候，往往不比较这两个，也就是说不大起作用。</p>
</li>
<li><p>第二个是euid和egid，注释是effective user/group id。一看这个名字，就知道这个是起“作用”的。当这个进程要操作消息队列、共享内存、信号量等对象的时候，其实就是在比较这个用户和组是否有权限。</p>
</li>
<li><p>第三个是fsuid和fsgid，也就是filesystem user/group id。这个是对文件操作会审核的权限。</p>
</li>
</ol>
<p>一般说来，fsuid、euid，和uid是一样的，fsgid、egid，和gid也是一样的。因为谁启动的进程，就应该审核启动的用户到底有没有这个权限。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/进程权限举例.jpeg" alt="进程权限举例"></p>
<p>例如，用户A想玩一个游戏，这个游戏的程序是用户B安装的。游戏这个程序文件的权限为rwxr–r—。A是没有权限运行这个程序的，因而用户B要给用户A权限才行。用户B说没问题，都是朋友嘛，于是用户B就给这个程序设定了所有的用户都能执行的权限rwxr-xr-x，说兄弟你玩吧。</p>
<p>例如，用户A想玩一个游戏，这个游戏的程序是用户B安装的。游戏这个程序文件的权限为rwxr–r—。A是没有权限运行这个程序的，因而用户B要给用户A权限才行。用户B说没问题，都是朋友嘛，于是用户B就给这个程序设定了所有的用户都能执行的权限rwxr-xr-x，说兄弟你玩吧。</p>
<p>于是，用户A就获得了运行这个游戏的权限。当游戏运行起来之后，游戏进程的uid、euid、fsuid都是用户A。看起来没有问题，玩的很开心。</p>
<p>用户A好不容易通过一关，想保存通关数据的时候，发现坏了，这个游戏的玩家数据是保存在另一个文件里面的。这个文件权限rw———-，只给用户B开了写入权限，而游戏进程的euid和fsuid都是用户A，当然写不进去了。完了，这一局白玩儿了。</p>
<p>那怎么解决这个问题呢？我们可以通过chmod u+s program命令，给这个游戏程序设置set-user-ID的标识位，把游戏的权限变成rwsr-xr-x。这个时候，用户A再启动这个游戏的时候，创建的进程uid当然还是用户A，但是euid和fsuid就不是用户A了，因为看到了set-user-id标识，就改为文件的所有者的ID，也就是说，euid和fsuid都改成用户B了，这样就能够将通关结果保存下来。</p>
<p>在Linux里面，一个进程可以随时通过setuid设置用户ID，所以，游戏程序的用户B的ID还会保存在一个地方，这就是suid和sgid，也就是saved uid和save gid。这样就可以很方便地使用setuid，通过设置uid或者suid来改变权限。</p>
<p>除了以用户和用户组控制权限，Linux还有另一个机制就是 <strong>capabilities</strong> 。</p>
<p>原来控制进程的权限，要么是高权限的root用户，要么是一般权限的普通用户，这时候的问题是，root用户权限太大，而普通用户权限太小。有时候一个普通用户想做一点高权限的事情，必须给他整个root的权限。这个太不安全了。</p>
<p>于是，我们引入新的机制capabilities，用位图表示权限，在capability.h可以找到定义的权限。我这里列举几个。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">CAP_CHOWN            <span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">CAP_KILL             <span class="token number">5</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">CAP_NET_BIND_SERVICE <span class="token number">10</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">CAP_NET_RAW          <span class="token number">13</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">CAP_SYS_MODULE       <span class="token number">16</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">CAP_SYS_RAWIO        <span class="token number">17</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">CAP_SYS_BOOT         <span class="token number">22</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">CAP_SYS_TIME         <span class="token number">25</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">CAP_AUDIT_READ       <span class="token number">37</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">CAP_LAST_CAP         CAP_AUDIT_READ</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于普通用户运行的进程，当有这个权限的时候，就能做这些操作；没有的时候，就不能做，这样粒度要小很多。</p>
<p>cap_permitted表示进程能够使用的权限。但是真正起作用的是cap_effective。cap_permitted中可以包含cap_effective中没有的权限。一个进程可以在必要的时候，放弃自己的某些权限，这样更加安全。假设自己因为代码漏洞被攻破了，但是如果啥也干不了，就没办法进一步突破。</p>
<p>cap_inheritable表示当可执行文件的扩展属性设置了inheritable位时，调用exec执行该程序会继承调用者的inheritable集合，并将其加入到permitted集合。但在非root用户下执行exec时，通常不会保留inheritable集合，但是往往又是非root用户，才想保留权限，所以非常鸡肋。</p>
<p>cap_bset，也就是capability bounding set，是系统中所有进程允许保留的权限。如果这个集合中不存在某个权限，那么系统中的所有进程都没有这个权限。即使以超级用户权限执行的进程，也是一样的。</p>
<p>这样有很多好处。例如，系统启动以后，将加载内核模块的权限去掉，那所有进程都不能加载内核模块。这样，即便这台机器被攻破，也做不了太多有害的事情。</p>
<p>cap_ambient是比较新加入内核的，就是为了解决cap_inheritable鸡肋的状况，也就是，非root用户进程使用exec执行一个程序的时候，如何保留权限的问题。当执行exec的时候，cap_ambient会被添加到cap_permitted中，同时设置到cap_effective中。</p>
<h3 id="8-4-内存管理"><a href="#8-4-内存管理" class="headerlink" title="8.4 内存管理"></a>8.4 内存管理</h3><p>每个进程都有自己独立的虚拟内存空间，这需要有一个数据结构来表示，就是mm_struct。这个我们在内存管理那一节详细讲述。这里你先有个印象。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">mm_struct</span>                <span class="token operator">*</span>mm<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">mm_struct</span>                <span class="token operator">*</span>active_mm<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="8-5-文件与文件系统"><a href="#8-5-文件与文件系统" class="headerlink" title="8.5 文件与文件系统"></a>8.5 文件与文件系统</h3><p>每个进程有一个文件系统的数据结构，还有一个打开文件的数据结构。这个我们放到文件系统那一节详细讲述。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Filesystem information: */</span>
<span class="token keyword">struct</span> <span class="token class-name">fs_struct</span>                <span class="token operator">*</span>fs<span class="token punctuation">;</span>
<span class="token comment">/* Open file information: */</span>
<span class="token keyword">struct</span> <span class="token class-name">files_struct</span>             <span class="token operator">*</span>files<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="8-6-总结"><a href="#8-6-总结" class="headerlink" title="8.6 总结"></a>8.6 总结</h3><p>这一节，我们终于把进程管理复杂的数据结构基本讲完了，请你重点记住以下两点：</p>
<ul>
<li>进程亲缘关系维护的数据结构，是一种很有参考价值的实现方式，在内核中会多个地方出现类似的结构；</li>
<li>进程权限中setuid的原理，这一点比较难理解，但是很重要，面试经常会考。</li>
</ul>
<p>你可以对着下面这张图，看看自己是否真的理解了，进程树是如何组织的，以及如何控制进程的权限的。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/进程管理task_struct的结构图（中）.jpeg" alt="进程管理task_struct的结构图（中）"></p>
<h2 id="九、进程数据结构（下）"><a href="#九、进程数据结构（下）" class="headerlink" title="九、进程数据结构（下）"></a>九、进程数据结构（下）</h2><p>在程序执行过程中，一旦调用到系统调用，就需要进入内核继续执行。那如何将用户态的执行和内核态的执行串起来呢？</p>
<p>这就需要以下两个重要的成员变量：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">thread_info</span>  thread_info<span class="token punctuation">;</span>
<span class="token keyword">void</span>                <span class="token operator">*</span>stack<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="9-1-用户态函数栈"><a href="#9-1-用户态函数栈" class="headerlink" title="9.1 用户态函数栈"></a>9.1 用户态函数栈</h3><p>在用户态中，程序的执行往往是一个函数调用另一个函数。函数调用都是通过栈来进行的。</p>
<p>在进程的内存空间里面，栈是一个从高地址到低地址，往下增长的结构，也就是上面是栈底，下面是栈顶，入栈和出栈的操作都是从下面的栈顶开始的。</p>
<blockquote>
<p>以下栈操作，都是在进程的内存空间里面进行的。</p>
</blockquote>
<h4 id="9-1-1-32位操作系统"><a href="#9-1-1-32位操作系统" class="headerlink" title="9.1.1 32位操作系统"></a>9.1.1 32位操作系统</h4><p><img src="/images/《趣谈Linux操作系统》学习笔记/32位操作系统用户态函数栈.jpg" alt="32位操作系统用户态函数栈"></p>
<p>在CPU里，ESP（Extended Stack Pointer）是栈顶指针寄存器，入栈操作Push和出栈操作Pop指令，会自动调整ESP的值。另外有一个寄存器EBP（Extended Base Pointer），是栈基地址指针寄存器，指向当前栈帧的最底部。</p>
<p>例如，A调用B，A的栈里面包含A函数的局部变量，然后是调用B的时候要传给它的参数，然后返回A的地址，这个地址也应该入栈，这就形成了A的栈帧。接下来就是B的栈帧部分了，先保存的是A栈帧的栈底位置，也就是EBP。因为在B函数里面获取A传进来的参数，就是通过这个指针获取的，接下来保存的是B的局部变量等等。</p>
<p>当B返回的时候，返回值会保存在EAX寄存器中，从栈中弹出返回地址，将指令跳转回去，参数也从栈中弹出，然后继续执行A。</p>
<h4 id="9-1-2-64位操作系统"><a href="#9-1-2-64位操作系统" class="headerlink" title="9.1.2 64位操作系统"></a>9.1.2 64位操作系统</h4><p>对于64位操作系统，模式多少有些不一样。因为64位操作系统的寄存器数目比较多。rax用于保存函数调用的返回结果。栈顶指针寄存器变成了rsp，指向栈顶位置。堆栈的Pop和Push操作会自动调整rsp，栈基指针寄存器变成了rbp，指向当前栈帧的起始位置。</p>
<p>改变比较多的是参数传递。rdi、rsi、rdx、rcx、r8、r9这6个寄存器，用于传递存储函数调用时的6个参数。如果超过6的时候，还是需要放到栈里面。</p>
<p>然而，前6个参数有时候需要进行寻址，但是如果在寄存器里面，是没有地址的，因而还是会放到栈里面，只不过放到栈里面的操作是被调用函数做的。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/64位操作系统用户态函数栈.jpg" alt="64位操作系统用户态函数栈"></p>
<h3 id="9-2-内核态函数栈"><a href="#9-2-内核态函数栈" class="headerlink" title="9.2 内核态函数栈"></a>9.2 内核态函数栈</h3><p>接下来，我们通过系统调用，从进程的内存空间到内核中了。内核中也有各种各样的函数调用来调用去的，也需要这样一个机制，这该怎么办呢？</p>
<p>这时候，上面的成员变量stack，也就是内核栈，就派上了用场。</p>
<p>Linux给每个task都分配了内核栈。在32位系统上arch/x86/include/asm/page_32_types.h，是这样定义的：一个PAGE_SIZE是4K，左移一位就是乘以2，也就是8K。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">THREAD_SIZE_ORDER   <span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">THREAD_SIZE</span>         <span class="token punctuation">(</span>PAGE_SIZE <span class="token operator">&lt;&lt;</span> THREAD_SIZE_ORDER<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>内核栈在64位系统上arch/x86/include/asm/page_64_types.h，是这样定义的：在PAGE_SIZE的基础上左移两位，也即16K，并且要求起始地址必须是8192的整数倍。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_KASAN</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">KASAN_STACK_ORDER <span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">KASAN_STACK_ORDER <span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">THREAD_SIZE_ORDER</span>   <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">+</span> KASAN_STACK_ORDER<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">THREAD_SIZE</span>         <span class="token punctuation">(</span>PAGE_SIZE <span class="token operator">&lt;&lt;</span> THREAD_SIZE_ORDER<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>内核栈是一个非常特殊的结构，如下图所示：</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/内核栈结构.jpeg" alt="内核栈结构"></p>
<p>这段空间的最低位置，是一个thread_info结构。这个结构是对task_struct结构的补充。因为task_struct结构庞大但是通用，不同的体系结构就需要保存不同的东西，所以往往与体系结构有关的，都放在thread_info里面。</p>
<p>在内核代码里面有这样一个union，将thread_info和stack放在一起，在include/linux/sched.h文件中就有。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">union</span> thread_union <span class="token punctuation">{</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">CONFIG_THREAD_INFO_IN_TASK</span></span>
    <span class="token keyword">struct</span> <span class="token class-name">thread_info</span> thread_info<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> stack<span class="token punctuation">[</span>THREAD_SIZE<span class="token operator">/</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个union就是这样定义的，开头是thread_info，后面是stack。</p>
<p>在内核栈的最高地址端，存放的是另一个结构pt_regs，定义如下。其中，32位和64位的定义不一样。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__i386__</span></span>
<span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> bx<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> cx<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> dx<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> si<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> di<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> bp<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ax<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ds<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> es<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> fs<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> gs<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> orig_ax<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ip<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> cs<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sp<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ss<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
<span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> r15<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> r14<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> r13<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> r12<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> bp<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> bx<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> r11<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> r10<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> r9<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> r8<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ax<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> cx<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> dx<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> si<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> di<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> orig_ax<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ip<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> cs<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sp<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ss<span class="token punctuation">;</span>
<span class="token comment">/* top of stack page */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当系统调用从用户态到内核态的时候，首先要做的第一件事情，就是将用户态运行过程中的CPU上下文保存起来，其实主要就是保存在这个结构的寄存器变量里。这样当从内核系统调用返回的时候，才能让进程在刚才的地方接着运行下去。</p>
<p>如果我们对比系统调用那一节的内容，你会发现系统调用的时候，压栈的值的顺序和struct pt_regs中寄存器定义的顺序是一样的。</p>
<p>在内核中，CPU的寄存器ESP或者RSP，已经指向内核栈的栈顶，在内核态里的调用都有和用户态相似的过程。</p>
<h3 id="9-3-通过task-struct找内核栈"><a href="#9-3-通过task-struct找内核栈" class="headerlink" title="9.3 通过task_struct找内核栈"></a>9.3 通过task_struct找内核栈</h3><p>如果有一个task_struct的stack指针在手，你可以通过下面的函数找到这个线程内核栈：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">task_stack_page</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>task<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> task<span class="token operator">-&gt;</span>stack<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>从task_struct如何得到相应的pt_regs呢？我们可以通过下面的函数：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * TOP_OF_KERNEL_STACK_PADDING reserves 8 bytes on top of the ring0 stack.
 * This is necessary to guarantee that the entire "struct pt_regs"
 * is accessible even if the CPU haven't stored the SS/ESP registers
 * on the stack (interrupt gate does not save these registers
 * when switching to the same priv ring).
 * Therefore beware: accessing the ss/esp fields of the
 * "struct pt_regs" is possible, but they may contain the
 * completely wrong values.
 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">task_pt_regs</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span>                                      </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">{</span>                                                              </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">unsigned</span> <span class="token keyword">long</span> __ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token function">task_stack_page</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span> </span><span class="token punctuation">\</span>
    <span class="token expression">__ptr <span class="token operator">+=</span> THREAD_SIZE <span class="token operator">-</span> TOP_OF_KERNEL_STACK_PADDING<span class="token punctuation">;</span>         </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span><span class="token punctuation">)</span>__ptr<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                              </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">}</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>你会发现，这是先从task_struct找到内核栈的开始位置。然后这个位置加上THREAD_SIZE就到了最后的位置，然后转换为struct pt_regs，再减一，就相当于减少了一个pt_regs的位置，就到了这个结构的首地址。</p>
<p>这里面有一个TOP_OF_KERNEL_STACK_PADDING，这个的定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_X86_32</span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_VM86</span></span>
<span class="token macro property"><span class="token directive-hash">#</span>  <span class="token directive keyword">define</span> <span class="token expression">TOP_OF_KERNEL_STACK_PADDING <span class="token number">16</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">else</span></span>
<span class="token macro property"><span class="token directive-hash">#</span>  <span class="token directive keyword">define</span> <span class="token expression">TOP_OF_KERNEL_STACK_PADDING <span class="token number">8</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span> <span class="token expression">TOP_OF_KERNEL_STACK_PADDING <span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也就是说，32位机器上是8，其他是0。这是为什么呢？因为压栈pt_regs有两种情况。我们知道，CPU用ring来区分权限，从而Linux可以区分内核态和用户态。</p>
<p>因此，第一种情况，我们拿涉及从用户态到内核态的变化的系统调用来说。因为涉及权限的改变，会压栈保存SS、ESP寄存器的，这两个寄存器共占用8个byte。</p>
<p>另一种情况是，不涉及权限的变化，就不会压栈这8个byte。这样就会使得两种情况不兼容。如果没有压栈还访问，就会报错，所以还不如预留在这里，保证安全。在64位上，修改了这个问题，变成了定长的。</p>
<p>好了，现在如果你task_struct在手，就能够轻松得到内核栈和内核寄存器。</p>
<h3 id="9-4-通过内核栈找task-struct"><a href="#9-4-通过内核栈找task-struct" class="headerlink" title="9.4 通过内核栈找task_struct"></a>9.4 通过内核栈找task_struct</h3><p>那如果一个当前在某个CPU上执行的进程，想知道自己的task_struct在哪里，又该怎么办呢？</p>
<p>这个艰巨的任务要交给thread_info这个结构。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">thread_info</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span>  <span class="token operator">*</span>task<span class="token punctuation">;</span>      <span class="token comment">/* main task structure */</span>
    __u32               flags<span class="token punctuation">;</span>      <span class="token comment">/* low level flags */</span>
    __u32               status<span class="token punctuation">;</span>     <span class="token comment">/* thread synchronous flags */</span>
    __u32               cpu<span class="token punctuation">;</span>        <span class="token comment">/* current CPU */</span>
    mm_segment_t        addr_limit<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        sig_on_uaccess_error<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        uaccess_err<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">/* uaccess failed */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面有个成员变量task指向task_struct，所以我们常用current_thread_info()-&gt;task来获取task_struct。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">thread_info</span> <span class="token operator">*</span><span class="token function">current_thread_info</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">thread_info</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">current_top_of_stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> THREAD_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>而thread_info的位置就是内核栈的最高位置，减去THREAD_SIZE，就到了thread_info的起始地址。</p>
<p>但是现在变成这样了，只剩下一个flags。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">thread_info</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>       flags<span class="token punctuation">;</span>      <span class="token comment">/* low level flags */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>那这时候怎么获取当前运行中的task_struct呢？current_thread_info有了新的实现方式。</p>
<p>在include/linux/thread_info.h中定义了current_thread_info。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;asm/current.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">current_thread_info</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">thread_info</span> <span class="token operator">*</span><span class="token punctuation">)</span>current<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>那current又是什么呢？在arch/x86/include/asm/current.h中定义了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token punctuation">;</span>

<span class="token function">DECLARE_PER_CPU</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token punctuation">,</span> current_task<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> __always_inline <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token function">get_current</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">this_cpu_read_stable</span><span class="token punctuation">(</span>current_task<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">current get_current</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>到这里，你会发现，新的机制里面，每个CPU运行的task_struct不通过thread_info获取了，而是直接放在Per CPU 变量里面了。</p>
<p>多核情况下，CPU是同时运行的，但是它们共同使用其他的硬件资源的时候，我们需要解决多个CPU之间的同步问题。</p>
<p>Per CPU变量是内核中一种重要的同步机制。顾名思义，Per CPU变量就是为每个CPU构造一个变量的副本，这样多个CPU各自操作自己的副本，互不干涉。比如，当前进程的变量current_task就被声明为Per CPU变量。</p>
<p>要使用Per CPU变量，首先要声明这个变量，在arch/x86/include/asm/current.h中有：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">DECLARE_PER_CPU</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token punctuation">,</span> current_task<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后是定义这个变量，在arch/x86/kernel/cpu/common.c中有：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">DEFINE_PER_CPU</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token punctuation">,</span> current_task<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>init_task<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>也就是说，系统刚刚初始化的时候，current_task都指向init_task。</p>
<p>当某个CPU上的进程进行切换的时候，current_task被修改为将要切换到的目标进程。例如，进程切换函数__switch_to就会改变current_task。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">__visible __notrace_funcgraph <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>
<span class="token function">__switch_to</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev_p<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>next_p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">this_cpu_write</span><span class="token punctuation">(</span>current_task<span class="token punctuation">,</span> next_p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> prev_p<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当要获取当前的运行中的task_struct的时候，就需要调用this_cpu_read_stable进行读取。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">this_cpu_read_stable</span><span class="token punctuation">(</span>var<span class="token punctuation">)</span>       <span class="token function">percpu_stable_op</span><span class="token punctuation">(</span></span><span class="token string">"mov"</span><span class="token expression"><span class="token punctuation">,</span> var<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>好了，现在如果你是一个进程，正在某个CPU上运行，就能够轻松得到task_struct了。</p>
<h3 id="9-5-总结"><a href="#9-5-总结" class="headerlink" title="9.5 总结"></a>9.5 总结</h3><p>这一节虽然只介绍了内核栈，但是内容更加重要。如果说task_struct的其他成员变量都是和进程管理有关的，内核栈是和进程运行有关系的。</p>
<p>我这里画了一张图总结一下32位和64位的工作模式，左边是32位的，右边是64位的。</p>
<ul>
<li>在用户态，应用程序进行了至少一次函数调用。32位和64的传递参数的方式稍有不同，32位的就是用函数栈，64位的前6个参数用寄存器，其他的用函数栈。</li>
<li>在内核态，32位和64位都使用内核栈，格式也稍有不同，主要集中在pt_regs结构上。</li>
<li>在内核态，32位和64位的内核栈和task_struct的关联关系不同。32位主要靠thread_info，64位主要靠Per-CPU变量。</li>
</ul>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/32位和64位函数栈.jpeg" alt="32位和64位函数栈"></p>
<h2 id="十、调度（上）"><a href="#十、调度（上）" class="headerlink" title="十、调度（上）"></a>十、调度（上）</h2><p>对于操作系统来讲，它面对的CPU的数量是有限的，干活儿都是它们，但是进程数目远远超过CPU的数目，因而就需要进行进程的调度，有效地分配CPU的时间，既要保证进程的最快响应，也要保证进程之间的公平。这也是一个非常复杂的、需要平衡的事情。</p>
<h3 id="10-1-调度策略与调度类"><a href="#10-1-调度策略与调度类" class="headerlink" title="10.1 调度策略与调度类"></a>10.1 调度策略与调度类</h3><p>在Linux里面，进程大概可以分成两种。</p>
<p>一种称为 <strong>实时进程</strong> ，也就是需要尽快执行返回结果的那种。<br>另一种是 <strong>普通进程</strong> ，大部分的进程其实都是这种。</p>
<p>对于这两种进程，我们的调度策略肯定是不同的。</p>
<p>在task_struct中，有一个成员变量，我们叫调度策略。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> policy<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>它有以下几个定义：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">SCHED_NORMAL        <span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">SCHED_FIFO          <span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">SCHED_RR            <span class="token number">2</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">SCHED_BATCH         <span class="token number">3</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">SCHED_IDLE          <span class="token number">5</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">SCHED_DEADLINE      <span class="token number">6</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>配合调度策略的，还有我们刚才说的优先级，也在task_struct中。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> prio<span class="token punctuation">,</span> static_prio<span class="token punctuation">,</span> normal_prio<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> rt_priority<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>优先级其实就是一个数值，对于实时进程，优先级的范围是0～99；对于普通进程，优先级的范围是100～139。数值越小，优先级越高。从这里可以看出，所有的实时进程都比普通进程优先级要高。</p>
<h3 id="10-2-实时调度策略"><a href="#10-2-实时调度策略" class="headerlink" title="10.2 实时调度策略"></a>10.2 实时调度策略</h3><p>对于调度策略，其中SCHED_FIFO、SCHED_RR、SCHED_DEADLINE是实时进程的调度策略。</p>
<ul>
<li><strong>SCHED_FIFO</strong> 就是先来先服务，可以分配更高的优先级，也就是说，高优先级的进程可以抢占低优先级的进程，而相同优先级的进程，我们遵循先来先得。</li>
<li><strong>SCHED_RR</strong> 轮流调度算法。采用时间片，相同优先级的任务当用完时间片会被放到队列尾部，以保证公平性，而高优先级的任务也是可以抢占低优先级的任务。</li>
<li><strong>SCHED_DEADLINE</strong> 按照任务的deadline进行调度的。当产生一个调度点的时候，DL调度器总是选择其deadline距离当前时间点最近的那个任务，并调度它执行。</li>
</ul>
<h3 id="10-3-普通调度策略"><a href="#10-3-普通调度策略" class="headerlink" title="10.3 普通调度策略"></a>10.3 普通调度策略</h3><p>对于普通进程的调度策略有，SCHED_NORMAL、SCHED_BATCH、SCHED_IDLE。</p>
<ul>
<li><strong>SCHED_NORMAL</strong> 是普通的进程。</li>
<li><strong>SCHED_BATCH</strong> 是后台进程，几乎不需要和前端进行交互。不要影响需要交互的进程，可以降低他的优先级。</li>
<li><strong>SCHED_IDLE</strong> 是特别空闲的时候才跑的进程。</li>
</ul>
<p>上面无论是policy还是priority，都设置了一个变量，变量仅仅表示了应该这样这样干，但事情总要有人去干，谁呢？在task_struct里面，还有这样的成员变量：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> <span class="token operator">*</span>sched_class<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>调度策略的执行逻辑，就封装在这里面，它是真正干活的那个。</p>
<p>sched_class有几种实现：</p>
<ul>
<li>stop_sched_class 优先级最高的任务会使用这种策略，会中断所有其他线程，且不会被其他任务打断；</li>
<li>dl_sched_class就对应上面的deadline调度策略；</li>
<li>rt_sched_class就对应RR算法或者FIFO算法的调度策略，具体调度策略由进程的task_struct-&gt;policy指定；</li>
<li>fair_sched_class就是普通进程的调度策略；</li>
<li>idle_sched_class就是空闲进程的调度策略。</li>
</ul>
<p>这里实时进程的调度策略RR和FIFO相对简单一些，而且由于咱们平时常遇到的都是普通进程，在这里，咱们就重点分析普通进程的调度问题。普通进程使用的调度策略是fair_sched_class，顾名思义，对于普通进程来讲，公平是最重要的。</p>
<h3 id="10-4-完全公平调度算法"><a href="#10-4-完全公平调度算法" class="headerlink" title="10.4 完全公平调度算法"></a>10.4 完全公平调度算法</h3><p>在Linux里面，实现了一个基于CFS的调度算法。CFS全称Completely Fair Scheduling，叫完全公平调度。听起来很“公平”。那这个算法的原理是什么呢？我们来看看。</p>
<p>首先，你需要记录下进程的运行时间。CPU会提供一个时钟，过一段时间就触发一个时钟中断。就像咱们的表滴答一下，这个我们叫Tick。CFS会为每一个进程安排一个虚拟运行时间vruntime。如果一个进程在运行，随着时间的增长，也就是一个个tick的到来，进程的vruntime将不断增大。没有得到执行的进程vruntime不变。</p>
<p>显然，那些vruntime少的，原来受到了不公平的对待，需要给它补上，所以会优先运行这样的进程。</p>
<p>这有点像让你把一筐球平均分到N个口袋里面，你看着哪个少，就多放一些；哪个多了，就先不放。这样经过多轮，虽然不能保证球完全一样多，但是也差不多公平。</p>
<p>你可能会说，不还有优先级呢？如何给优先级高的进程多分时间呢？</p>
<p>这个简单，就相当于N个口袋，优先级高的袋子大，优先级低的袋子小。这样球就不能按照个数分配了，要按照比例来，大口袋的放了一半和小口袋放了一半，里面的球数目虽然差很多，也认为是公平的。</p>
<p>在更新进程运行的统计量的时候，我们其实就可以看出这个逻辑。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * Update the current task's runtime statistics.
 */</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">update_curr</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>curr <span class="token operator">=</span> cfs_rq<span class="token operator">-&gt;</span>curr<span class="token punctuation">;</span>
    u64 now <span class="token operator">=</span> <span class="token function">rq_clock_task</span><span class="token punctuation">(</span><span class="token function">rq_of</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    u64 delta_exec<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    delta_exec <span class="token operator">=</span> now <span class="token operator">-</span> curr<span class="token operator">-&gt;</span>exec_start<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    curr<span class="token operator">-&gt;</span>exec_start <span class="token operator">=</span> now<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    curr<span class="token operator">-&gt;</span>sum_exec_runtime <span class="token operator">+=</span> delta_exec<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    curr<span class="token operator">-&gt;</span>vruntime <span class="token operator">+=</span> <span class="token function">calc_delta_fair</span><span class="token punctuation">(</span>delta_exec<span class="token punctuation">,</span> curr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">update_min_vruntime</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token comment">/*
 * delta /= w
 */</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> u64 <span class="token function">calc_delta_fair</span><span class="token punctuation">(</span>u64 delta<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>se<span class="token operator">-&gt;</span>load<span class="token punctuation">.</span>weight <span class="token operator">!=</span> NICE_0_LOAD<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment">/* delta_exec * weight / lw.weight */</span>
        delta <span class="token operator">=</span> <span class="token function">__calc_delta</span><span class="token punctuation">(</span>delta<span class="token punctuation">,</span> NICE_0_LOAD<span class="token punctuation">,</span> <span class="token operator">&amp;</span>se<span class="token operator">-&gt;</span>load<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> delta<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里得到当前的时间，以及这次的时间片开始的时间，两者相减就是这次运行的时间delta_exec ，但是得到的这个时间其实是实际运行的时间，需要做一定的转化才作为虚拟运行时间vruntime。转化方法如下：</p>
<p><code>虚拟运行时间vruntime += 实际运行时间delta_exec * NICE_0_LOAD/权重</code></p>
<p>这就是说，同样的实际运行时间，给高权重的算少了，低权重的算多了，但是当选取下一个运行进程的时候，还是按照最小的vruntime来的，这样高权重的获得的实际运行时间自然就多了。这就相当于给一个体重(权重)200斤的胖子吃两个馒头，和给一个体重100斤的瘦子吃一个馒头，然后说，你们两个吃的是一样多。这样虽然总体胖子比瘦子多吃了一倍，但是还是公平的。</p>
<h3 id="10-5-调度队列与调度实体"><a href="#10-5-调度队列与调度实体" class="headerlink" title="10.5 调度队列与调度实体"></a>10.5 调度队列与调度实体</h3><p>看来CFS需要一个数据结构来对vruntime进行排序，找出最小的那个。这个能够排序的数据结构不但需要查询的时候，能够快速找到最小的，更新的时候也需要能够快速的调整排序，要知道vruntime可是经常在变的，变了再插入这个数据结构，就需要重新排序。</p>
<p>能够平衡查询和更新速度的是树，在这里使用的是红黑树。</p>
<p>红黑树的的节点是应该包括vruntime的，称为调度实体。</p>
<p>在task_struct中有这样的成员变量：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> se<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">sched_rt_entity</span> rt<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">sched_dl_entity</span> dl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这里有实时调度实体sched_rt_entity，Deadline调度实体sched_dl_entity，以及完全公平算法调度实体sched_entity。</p>
<p>看来不光CFS调度策略需要有这样一个数据结构进行排序，其他的调度策略也同样有自己的数据结构进行排序，因为任何一个策略做调度的时候，都是要区分谁先运行谁后运行。</p>
<p>而进程根据自己是实时的，还是普通的类型，通过这个成员变量，将自己挂在某一个数据结构里面，和其他的进程排序，等待被调度。如果这个进程是个普通进程，则通过sched_entity，将自己挂在这棵红黑树上。</p>
<p>对于普通进程的调度实体定义如下，这里面包含了vruntime和权重load_weight，以及对于运行时间的统计。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">load_weight</span>      load<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span>          run_node<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>        group_node<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>            on_rq<span class="token punctuation">;</span>
    u64                     exec_start<span class="token punctuation">;</span>
    u64                     sum_exec_runtime<span class="token punctuation">;</span>
    u64                     vruntime<span class="token punctuation">;</span>
    u64                     prev_sum_exec_runtime<span class="token punctuation">;</span>
    u64                     nr_migrations<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_statistics</span> statistics<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下图是一个红黑树的例子。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/调度队列红黑树示例.jpeg" alt="调度队列红黑树示例"></p>
<p>所有可运行的进程通过不断地插入操作最终都存储在以时间为顺序的红黑树中，vruntime最小的在树的左侧，vruntime最多的在树的右侧。 CFS调度策略会选择红黑树最左边的叶子节点作为下一个将获得cpu的任务。</p>
<p>每个CPU都有自己的 struct rq 结构，其用于描述在此CPU上所运行的所有进程，其包括一个实时进程队列rt_rq和一个CFS运行队列cfs_rq，在调度时，调度器首先会先去实时进程队列找是否有实时进程需要运行，如果没有才会去CFS运行队列找是否有进行需要运行。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token punctuation">{</span>
    <span class="token comment">/* runqueue lock: */</span>
    raw_spinlock_t lock<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nr_running<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> cpu_load<span class="token punctuation">[</span>CPU_LOAD_IDX_MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">struct</span> <span class="token class-name">load_weight</span> load<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> nr_load_updates<span class="token punctuation">;</span>
    u64 nr_switches<span class="token punctuation">;</span>


    <span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> cfs<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rt_rq</span> rt<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">dl_rq</span> dl<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token operator">*</span>idle<span class="token punctuation">,</span> <span class="token operator">*</span>stop<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于普通进程公平队列cfs_rq，定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* CFS-related fields in a runqueue */</span>
<span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">load_weight</span> load<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nr_running<span class="token punctuation">,</span> h_nr_running<span class="token punctuation">;</span>

    u64 exec_clock<span class="token punctuation">;</span>
    u64 min_vruntime<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">CONFIG_64BIT</span></span>
    u64 min_vruntime_copy<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_root</span> tasks_timeline<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>rb_leftmost<span class="token punctuation">;</span>

    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token operator">*</span>next<span class="token punctuation">,</span> <span class="token operator">*</span>last<span class="token punctuation">,</span> <span class="token operator">*</span>skip<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面rb_root指向的就是红黑树的根节点，这个红黑树在CPU看起来就是一个队列，不断的取下一个应该运行的进程。rb_leftmost指向的是最左面的节点。</p>
<p>到这里终于凑够数据结构了，上面这些数据结构的关系如下图：</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/调度队列与调度实体.jpeg" alt="调度队列与调度实体"></p>
<h3 id="10-6-调度类是如何工作的？"><a href="#10-6-调度类是如何工作的？" class="headerlink" title="10.6 调度类是如何工作的？"></a>10.6 调度类是如何工作的？</h3><p>调度类的定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sched_class</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>enqueue_task<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>dequeue_task<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>yield_task<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">bool</span> <span class="token punctuation">(</span><span class="token operator">*</span>yield_to_task<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> bool preempt<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>check_preempt_curr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>pick_next_task<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span>
                        <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span>
                        <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> <span class="token operator">*</span>rf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>put_prev_task<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>set_curr_task<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>task_tick<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> queued<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>task_fork<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>task_dead<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>switched_from<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>this_rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>switched_to<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>this_rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>prio_changed<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>this_rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>task<span class="token punctuation">,</span> <span class="token keyword">int</span> oldprio<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>get_rr_interval<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span>
                     <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>update_curr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个结构定义了很多种方法，用于在队列上操作任务。这里请大家注意第一个成员变量，是一个指针，指向下一个调度类。</p>
<p>上面我们讲了，调度类分为下面这几种：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> stop_sched_class<span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> dl_sched_class<span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> rt_sched_class<span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> fair_sched_class<span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> idle_sched_class<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>它们其实是放在一个链表上的。这里我们以调度最常见的操作，取下一个任务为例，来解析一下。可以看到，这里面有一个for_each_class循环，沿着上面的顺序，依次调用每个调度类的方法。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * Pick up the highest-prio task:
 */</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>
<span class="token function">pick_next_task</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> <span class="token operator">*</span>rf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> <span class="token operator">*</span>class<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">for_each_class</span><span class="token punctuation">(</span>class<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        p <span class="token operator">=</span> class<span class="token operator">-&gt;</span><span class="token function">pick_next_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> rf<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>p <span class="token operator">==</span> RETRY_TASK<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">goto</span> again<span class="token punctuation">;</span>
            <span class="token keyword">return</span> p<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这就说明，调度的时候是从优先级最高的调度类到优先级低的调度类，依次执行。而对于每种调度类，有自己的实现，例如，CFS就有fair_sched_class。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> fair_sched_class <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>next               <span class="token operator">=</span> <span class="token operator">&amp;</span>idle_sched_class<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>enqueue_task       <span class="token operator">=</span> enqueue_task_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>dequeue_task       <span class="token operator">=</span> dequeue_task_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>yield_task         <span class="token operator">=</span> yield_task_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>yield_to_task      <span class="token operator">=</span> yield_to_task_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>check_preempt_curr <span class="token operator">=</span> check_preempt_wakeup<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>pick_next_task     <span class="token operator">=</span> pick_next_task_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>put_prev_task      <span class="token operator">=</span> put_prev_task_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>set_curr_task      <span class="token operator">=</span> set_curr_task_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>task_tick          <span class="token operator">=</span> task_tick_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>task_fork          <span class="token operator">=</span> task_fork_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>prio_changed       <span class="token operator">=</span> prio_changed_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>switched_from      <span class="token operator">=</span> switched_from_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>switched_to        <span class="token operator">=</span> switched_to_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>get_rr_interval    <span class="token operator">=</span> get_rr_interval_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>update_curr        <span class="token operator">=</span> update_curr_fair<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于同样的pick_next_task选取下一个要运行的任务这个动作，不同的调度类有自己的实现。fair_sched_class的实现是pick_next_task_fair，rt_sched_class的实现是pick_next_task_rt。</p>
<p>我们会发现这两个函数是操作不同的队列，pick_next_task_rt操作的是rt_rq，pick_next_task_fair操作的是cfs_rq。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>
<span class="token function">pick_next_task_rt</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> <span class="token operator">*</span>rf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rt_rq</span> <span class="token operator">*</span>rt_rq <span class="token operator">=</span> <span class="token operator">&amp;</span>rq<span class="token operator">-&gt;</span>rt<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>


<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>
<span class="token function">pick_next_task_fair</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> <span class="token operator">*</span>rf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq <span class="token operator">=</span> <span class="token operator">&amp;</span>rq<span class="token operator">-&gt;</span>cfs<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样整个运行的场景就串起来了，在每个CPU上都有一个队列rq，这个队列里面包含多个子队列，例如rt_rq和cfs_rq，不同的队列有不同的实现方式，cfs_rq就是用红黑树实现的。</p>
<p>当有一天，某个CPU需要找下一个任务执行的时候，会按照优先级依次调用调度类，不同的调度类操作不同的队列。当然rt_sched_class先被调用，它会在rt_rq上找下一个任务，只有找不到的时候，才轮到fair_sched_class被调用，它会在cfs_rq上找下一个任务。这样保证了实时任务的优先级永远大于普通任务。</p>
<p>下面我们仔细看一下sched_class定义的与调度有关的函数。</p>
<ul>
<li>enqueue_task 向就绪队列中添加一个进程，当某个进程进入可运行状态时，调用这个函数；</li>
<li>dequeue_task 将一个进程从就就绪队列中删除；</li>
<li>pick_next_task 选择接下来要运行的进程；</li>
<li>put_prev_task 用另一个进程代替当前运行的进程；</li>
<li>set_curr_task 用于修改调度策略；</li>
<li>task_tick 每次周期性时钟到的时候，这个函数被调用，可能触发调度。</li>
</ul>
<p>在这里面，我们重点看fair_sched_class对于pick_next_task的实现pick_next_task_fair，获取下一个进程。调用路径如下：pick_next_task_fair-&gt;pick_next_entity-&gt;__pick_first_entity。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span><span class="token function">__pick_first_entity</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>left <span class="token operator">=</span> <span class="token function">rb_first_cached</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cfs_rq<span class="token operator">-&gt;</span>tasks_timeline<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>left<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token function">rb_entry</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span><span class="token punctuation">,</span> run_node<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从这个函数的实现可以看出，就是从红黑树里面取最左面的节点。</p>
<h3 id="10-7-总结"><a href="#10-7-总结" class="headerlink" title="10.7 总结"></a>10.7 总结</h3><p>一个CPU上有一个队列，CFS的队列是一棵红黑树，树的每一个节点都是一个sched_entity，每个sched_entity都属于一个task_struct，task_struct里面有指针指向这个进程属于哪个调度类。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/调度总结（上）.jpeg" alt="调度总结（上）"></p>
<p>在调度的时候，依次调用调度类的函数，从CPU的队列中取出下一个进程。上面图中的调度器、上下文切换这一节我们没有讲，下一节我们讲讲基于这些数据结构，如何实现调度。</p>
<h2 id="十一、调度（中）"><a href="#十一、调度（中）" class="headerlink" title="十一、调度（中）"></a>十一、调度（中）</h2><p>所谓进程调度，其实就是一个人在做A项目，在某个时刻，换成做B项目去了。发生这种情况，主要有两种方式。</p>
<p><strong>方式一</strong>：A项目做着做着，发现里面有一条指令sleep，也就是要休息一下，或者在等待某个I/O事件。那没办法了，就要主动让出CPU，然后可以开始做B项目。</p>
<p><strong>方式二</strong>：A项目做着做着，旷日持久，实在受不了了。项目经理介入了，说这个项目A先停停，B项目也要做一下，要不然B项目该投诉了。</p>
<h3 id="11-1-主动调度"><a href="#11-1-主动调度" class="headerlink" title="11.1 主动调度"></a>11.1 主动调度</h3><p>我们这一节先来看方式一，主动调度。</p>
<p>这里我找了几个代码片段。 <strong>第一个片段是Btrfs，等待一个写入</strong> 。 Btrfs（B-Tree）是一种文件系统。</p>
<p>这个片段可以看作写入块设备的一个典型场景。写入需要一段时间，这段时间用不上CPU，还不如主动让给其他进程。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">btrfs_wait_for_no_snapshoting_writes</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">btrfs_root</span> <span class="token operator">*</span>root<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        <span class="token function">prepare_to_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>root<span class="token operator">-&gt;</span>subv_writers<span class="token operator">-&gt;</span>wait<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait<span class="token punctuation">,</span>
                TASK_UNINTERRUPTIBLE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        writers <span class="token operator">=</span> <span class="token function">percpu_counter_sum</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>root<span class="token operator">-&gt;</span>subv_writers<span class="token operator">-&gt;</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>writers<span class="token punctuation">)</span>
            <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">finish_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>root<span class="token operator">-&gt;</span>subv_writers<span class="token operator">-&gt;</span>wait<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>writers<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另外一个例子是， <strong>从Tap网络设备等待一个读取</strong> 。Tap网络设备是虚拟机使用的网络设备。当没有数据到来的时候，它也需要等待，所以也会选择把CPU让给其他进程。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> ssize_t <span class="token function">tap_do_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">tap_queue</span> <span class="token operator">*</span>q<span class="token punctuation">,</span>
               <span class="token keyword">struct</span> <span class="token class-name">iov_iter</span> <span class="token operator">*</span>to<span class="token punctuation">,</span>
               <span class="token keyword">int</span> noblock<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>noblock<span class="token punctuation">)</span>
            <span class="token function">prepare_to_wait</span><span class="token punctuation">(</span><span class="token function">sk_sleep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-&gt;</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait<span class="token punctuation">,</span>
                    TASK_INTERRUPTIBLE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token comment">/* Nothing to read, let's sleep */</span>
        <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来，我们就来看 <strong>schedule函数的调用过程</strong>。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">asmlinkage __visible <span class="token keyword">void</span> __sched <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk <span class="token operator">=</span> current<span class="token punctuation">;</span>

    <span class="token function">sched_submit_work</span><span class="token punctuation">(</span>tsk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        <span class="token function">preempt_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">__schedule</span><span class="token punctuation">(</span>false<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sched_preempt_enable_no_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">need_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这段代码的主要逻辑是在__schedule函数中实现的。这个函数比较复杂，我们分几个部分来讲解。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> __sched notrace <span class="token function">__schedule</span><span class="token punctuation">(</span>bool preempt<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span>switch_count<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> rf<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">;</span>
    <span class="token keyword">int</span> cpu<span class="token punctuation">;</span>

    cpu <span class="token operator">=</span> <span class="token function">smp_processor_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    rq <span class="token operator">=</span> <span class="token function">cpu_rq</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
    prev <span class="token operator">=</span> rq<span class="token operator">-&gt;</span>curr<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先，在当前的CPU上，我们取出任务队列rq。</p>
<p>task_struct *prev指向这个CPU的任务队列上面正在运行的那个进程curr。为啥是prev？因为一旦将来它被切换下来，那它就成了前任了。</p>
<p>接下来代码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">next <span class="token operator">=</span> <span class="token function">pick_next_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">clear_tsk_need_resched</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">clear_preempt_need_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>第二步，获取下一个任务，task_struct <em>next指向下一个任务，这就是 <em>*继任</em></em> 。</p>
<p>pick_next_task的实现如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>
<span class="token function">pick_next_task</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> <span class="token operator">*</span>rf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> <span class="token operator">*</span>class<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
    <span class="token comment">/*
     * Optimization: we know that if all tasks are in the fair class we can call that function directly, but only if the @prev task wasn't of a higher scheduling class, because otherwise those loose the opportunity to pull in more work from other CPUs.
     */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token punctuation">(</span>prev<span class="token operator">-&gt;</span>sched_class <span class="token operator">==</span> <span class="token operator">&amp;</span>idle_sched_class <span class="token operator">||</span>
            prev<span class="token operator">-&gt;</span>sched_class <span class="token operator">==</span> <span class="token operator">&amp;</span>fair_sched_class<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
           rq<span class="token operator">-&gt;</span>nr_running <span class="token operator">==</span> rq<span class="token operator">-&gt;</span>cfs<span class="token punctuation">.</span>h_nr_running<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        p <span class="token operator">=</span> fair_sched_class<span class="token punctuation">.</span><span class="token function">pick_next_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> rf<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>p <span class="token operator">==</span> RETRY_TASK<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">goto</span> again<span class="token punctuation">;</span>
        <span class="token comment">/* Assumes fair_sched_class-&gt;next == idle_sched_class */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span>
            p <span class="token operator">=</span> idle_sched_class<span class="token punctuation">.</span><span class="token function">pick_next_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> rf<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> p<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
again<span class="token operator">:</span>
    <span class="token function">for_each_class</span><span class="token punctuation">(</span>class<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        p <span class="token operator">=</span> class<span class="token operator">-&gt;</span><span class="token function">pick_next_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> rf<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>p <span class="token operator">==</span> RETRY_TASK<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">goto</span> again<span class="token punctuation">;</span>
            <span class="token keyword">return</span> p<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们来看again这里，就是咱们上一节讲的依次调用调度类。但是这里有了一个优化，因为大部分进程是普通进程，所以大部分情况下会调用上面的逻辑，调用的就是fair_sched_class.pick_next_task。</p>
<p>根据上一节对于fair_sched_class的定义，它调用的是pick_next_task_fair，代码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>
<span class="token function">pick_next_task_fair</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> <span class="token operator">*</span>rf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq <span class="token operator">=</span> <span class="token operator">&amp;</span>rq<span class="token operator">-&gt;</span>cfs<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
    <span class="token keyword">int</span> new_tasks<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于CFS调度类，取出相应的队列cfs_rq，这就是我们上一节讲的那棵红黑树。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">        <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>curr <span class="token operator">=</span> cfs_rq<span class="token operator">-&gt;</span>curr<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>curr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>curr<span class="token operator">-&gt;</span>on_rq<span class="token punctuation">)</span>
                <span class="token function">update_curr</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                curr <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">}</span>
        se <span class="token operator">=</span> <span class="token function">pick_next_entity</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> curr<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>取出当前正在运行的任务curr，如果依然是可运行的状态，也即处于进程就绪状态，则调用update_curr更新vruntime。update_curr咱们上一节就见过了，它会根据实际运行时间算出vruntime来。</p>
<p>接着，pick_next_entity从红黑树里面，取最左边的一个节点。这个函数的实现我们上一节也讲过了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">    p <span class="token operator">=</span> <span class="token function">task_of</span><span class="token punctuation">(</span>se<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">!=</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>pse <span class="token operator">=</span> <span class="token operator">&amp;</span>prev<span class="token operator">-&gt;</span>se<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token function">put_prev_entity</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> pse<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">set_next_entity</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> se<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>task_of得到下一个调度实体对应的task_struct，如果发现继任和前任不一样，这就说明有一个更需要运行的进程了，就需要更新红黑树了。前面前任的vruntime更新过了，put_prev_entity放回红黑树，会找到相应的位置，然后set_next_entity将继任者设为当前任务。</p>
<p>第三步，当选出的继任者和前任不同，就要进行上下文切换，继任者进程正式进入运行。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>prev <span class="token operator">!=</span> next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        rq<span class="token operator">-&gt;</span>nr_switches<span class="token operator">++</span><span class="token punctuation">;</span>
        rq<span class="token operator">-&gt;</span>curr <span class="token operator">=</span> next<span class="token punctuation">;</span>
        <span class="token operator">++</span><span class="token operator">*</span>switch_count<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        rq <span class="token operator">=</span> <span class="token function">context_switch</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> next<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rf<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="11-2-进程上下文切换"><a href="#11-2-进程上下文切换" class="headerlink" title="11.2 进程上下文切换"></a>11.2 进程上下文切换</h3><p>上下文切换主要干两件事情，一是切换进程空间，也即虚拟内存；二是切换寄存器和CPU上下文。</p>
<p>我们先来看context_switch的实现。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * context_switch - switch to the new MM and the new thread's register state.
 */</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>
<span class="token function">context_switch</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span>
           <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>next<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> <span class="token operator">*</span>rf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>mm<span class="token punctuation">,</span> <span class="token operator">*</span>oldmm<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    mm <span class="token operator">=</span> next<span class="token operator">-&gt;</span>mm<span class="token punctuation">;</span>
    oldmm <span class="token operator">=</span> prev<span class="token operator">-&gt;</span>active_mm<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">switch_mm_irqs_off</span><span class="token punctuation">(</span>oldmm<span class="token punctuation">,</span> mm<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* Here we just switch the register state and the stack. */</span>
    <span class="token function">switch_to</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">,</span> prev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">barrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">finish_task_switch</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里首先是内存空间的切换，里面涉及内存管理的内容比较多。内存管理后面我们会有专门的章节来讲，这里你先知道有这么一回事就行了。</p>
<p>接下来，我们看switch_to。它就是寄存器和栈的切换，它调用到了__switch_to_asm。这是一段汇编代码，主要用于栈的切换。</p>
<p>对于32位操作系统来讲，切换的是栈顶指针esp。</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">/*
 * %eax: prev task
 * %edx: next task
 */
ENTRY(__switch_to_asm)
......
    /* switch stack */
    movl    %esp, TASK_threadsp(%eax)
    movl    TASK_threadsp(%edx), %esp
......
    jmp     __switch_to
END(__switch_to_asm)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于64位操作系统来讲，切换的是栈顶指针rsp。</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">/*
 * %rdi: prev task
 * %rsi: next task
 */
ENTRY(__switch_to_asm)
......
    /* switch stack */
    movq    %rsp, TASK_threadsp(%rdi)
    movq    TASK_threadsp(%rsi), %rsp
......
    jmp     __switch_to
END(__switch_to_asm)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最终，都返回了__switch_to这个函数。这个函数对于32位和64位操作系统虽然有不同的实现，但里面做的事情是差不多的。所以我这里仅仅列出64位操作系统做的事情。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">__visible __notrace_funcgraph <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>
<span class="token function">__switch_to</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev_p<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>next_p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">thread_struct</span> <span class="token operator">*</span>prev <span class="token operator">=</span> <span class="token operator">&amp;</span>prev_p<span class="token operator">-&gt;</span>thread<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">thread_struct</span> <span class="token operator">*</span>next <span class="token operator">=</span> <span class="token operator">&amp;</span>next_p<span class="token operator">-&gt;</span>thread<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">int</span> cpu <span class="token operator">=</span> <span class="token function">smp_processor_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">tss_struct</span> <span class="token operator">*</span>tss <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">per_cpu</span><span class="token punctuation">(</span>cpu_tss<span class="token punctuation">,</span> cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">load_TLS</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">this_cpu_write</span><span class="token punctuation">(</span>current_task<span class="token punctuation">,</span> next_p<span class="token punctuation">)</span><span class="token punctuation">;</span>


    <span class="token comment">/* Reload esp0 and ss1.  This changes current_thread_info(). */</span>
    <span class="token function">load_sp0</span><span class="token punctuation">(</span>tss<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> prev_p<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面有一个Per CPU的结构体tss。这是个什么呢？</p>
<p>在x86体系结构中，提供了一种以硬件的方式进行进程切换的模式，对于每个进程，x86希望在内存里面维护一个TSS（Task State Segment，任务状态段）结构。这里面有所有的寄存器。</p>
<p>另外，还有一个特殊的寄存器TR（Task Register，任务寄存器），指向某个进程的TSS。更改TR的值，将会触发硬件保存CPU所有寄存器的值到当前进程的TSS中，然后从新进程的TSS中读出所有寄存器值，加载到CPU对应的寄存器中。</p>
<p>下图就是32位的TSS结构。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/32位的TSS结构.png" alt="32位的TSS结构"></p>
<blockquote>
<p>图片来自Intel® 64 and IA-32 Architectures Software Developer’s Manual Combined Volumes</p>
</blockquote>
<p>但是这样有个缺点。我们做进程切换的时候，没必要每个寄存器都切换，这样每个进程一个TSS，就需要全量保存，全量切换，动作太大了。</p>
<p>于是，Linux操作系统想了一个办法。还记得在系统初始化的时候，会调用cpu_init吗？这里面会给每一个CPU关联一个TSS，然后将TR指向这个TSS，然后在操作系统的运行过程中，TR就不切换了，永远指向这个TSS。TSS用数据结构tss_struct表示，在x86_hw_tss中可以看到和上图相应的结构。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">cpu_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> cpu <span class="token operator">=</span> <span class="token function">smp_processor_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>curr <span class="token operator">=</span> current<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">tss_struct</span> <span class="token operator">*</span>t <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">per_cpu</span><span class="token punctuation">(</span>cpu_tss<span class="token punctuation">,</span> cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">load_sp0</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">set_tss_desc</span><span class="token punctuation">(</span>cpu<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">load_TR_desc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">tss_struct</span> <span class="token punctuation">{</span>
    <span class="token comment">/*
     * The hardware state:
     */</span>
    <span class="token keyword">struct</span> <span class="token class-name">x86_hw_tss</span>   x86_tss<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>       io_bitmap<span class="token punctuation">[</span>IO_BITMAP_LONGS <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在Linux中，真的参与进程切换的寄存器很少，主要的就是栈顶寄存器。</p>
<p>于是，在task_struct里面，还有一个我们原来没有注意的成员变量thread。这里面保留了要切换进程的时候需要修改的寄存器。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* CPU-specific state of this task: */</span>
<span class="token keyword">struct</span> <span class="token class-name">thread_struct</span>        thread<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>所谓的进程切换，就是将某个进程的thread_struct里面的寄存器的值，写入到CPU的TR指向的tss_struct，对于CPU来讲，这就算是完成了切换。</p>
<p>例如__switch_to中的load_sp0，就是将下一个进程的thread_struct的sp0的值加载到tss_struct里面去。</p>
<h3 id="11-3-指令指针的保存与恢复"><a href="#11-3-指令指针的保存与恢复" class="headerlink" title="11.3 指令指针的保存与恢复"></a>11.3 指令指针的保存与恢复</h3><p>你是不是觉得，这样真的就完成切换了吗？是的，不信我们来 <strong>盘点</strong> 一下。</p>
<p>从进程A切换到进程B，用户栈要不要切换呢？当然要，其实早就已经切换了，就在切换内存空间的时候。每个进程的用户栈都是独立的，都在内存空间里面。</p>
<p>那内核栈呢？已经在__switch_to里面切换了，也就是将current_task指向当前的task_struct。里面的void *stack指针，指向的就是当前的内核栈。</p>
<p>内核栈的栈顶指针呢？在<strong>switch_to_asm里面已经切换了栈顶指针，并且将栈顶指针在</strong>switch_to加载到了TSS里面。</p>
<p>用户栈的栈顶指针呢？如果当前在内核里面的话，它当然是在内核栈顶部的pt_regs结构里面呀。当从内核返回用户态运行的时候，pt_regs里面有所有当时在用户态的时候运行的上下文信息，就可以开始运行了。</p>
<p>唯一让人不容易理解的是指令指针寄存器，它应该指向下一条指令的，那它是如何切换的呢？这里有点绕，请你仔细看。</p>
<p>这里我先明确一点，进程的调度都最终会调用到__schedule函数。为了方便你记住，我姑且给它起个名字，就叫“ <strong>进程调度第一定律</strong> ”。后面我们会多次用到这个定律，你一定要记住。</p>
<p>我们用最前面的例子仔细分析这个过程。本来一个进程A在用户态是要写一个文件的，写文件的操作用户态没办法完成，就要通过系统调用到达内核态。在这个切换的过程中，用户态的指令指针寄存器是保存在pt_regs里面的，到了内核态，就开始沿着写文件的逻辑一步一步执行，结果发现需要等待，于是就调用__schedule函数。</p>
<p>这个时候，进程A在内核态的指令指针是指向<strong>schedule了。这里请记住，A进程的内核栈会保存这个</strong>schedule的调用，而且知道这是从btrfs_wait_for_no_snapshoting_writes这个函数里面进去的。</p>
<p>__schedule里面经过上面的层层调用，到达了context_switch的最后三行指令（其中barrier语句是一个编译器指令，用于保证switch_to和finish_task_switch的执行顺序，不会因为编译阶段优化而改变，这里咱们可以忽略它）。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">switch_to</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">,</span> prev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">barrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> <span class="token function">finish_task_switch</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>当进程A在内核里面执行switch_to的时候，内核态的指令指针也是指向这一行的。但是在switch_to里面，将寄存器和栈都切换到成了进程B的，唯一没有变的就是指令指针寄存器。当switch_to返回的时候，指令指针寄存器指向了下一条语句finish_task_switch。</p>
<p>但这个时候的finish_task_switch已经不是进程A的finish_task_switch了，而是进程B的finish_task_switch了。</p>
<p>这样合理吗？你怎么知道进程B当时被切换下去的时候，执行到哪里了？恢复B进程执行的时候一定在这里呢？这时候就要用到咱的“进程调度第一定律”了。</p>
<p>当年B进程被别人切换走的时候，也是调用__schedule，也是调用到switch_to，被切换成为C进程的，所以，B进程当年的下一个指令也是finish_task_switch，这就说明指令指针指到这里是没有错的。</p>
<p>接下来，我们要从finish_task_switch完毕后，返回__schedule的调用了。返回到哪里呢？按照函数返回的原理，当然是从内核栈里面去找，是返回到btrfs_wait_for_no_snapshoting_writes吗？当然不是了，因为btrfs_wait_for_no_snapshoting_writes是在A进程的内核栈里面的，它早就被切换走了，应该从B进程的内核栈里面找。</p>
<p>假设，B就是最前面例子里面调用tap_do_read读网卡的进程。它当年调用__schedule的时候，是从tap_do_read这个函数调用进去的。</p>
<p>当然，B进程的内核栈里面放的是tap_do_read。于是，从__schedule返回之后，当然是接着tap_do_read运行，然后在内核运行完毕后，返回用户态。这个时候，B进程内核栈的pt_regs也保存了用户态的指令指针寄存器，就接着在用户态的下一条指令开始运行就可以了。</p>
<p>假设，我们只有一个CPU，从B切换到C，从C又切换到A。在C切换到A的时候，还是按照“进程调度第一定律”，C进程还是会调用__schedule到达switch_to，在里面切换成为A的内核栈，然后运行finish_task_switch。</p>
<p>这个时候运行的finish_task_switch，才是A进程的finish_task_switch。运行完毕从__schedule返回的时候，从内核栈上才知道，当年是从btrfs_wait_for_no_snapshoting_writes调用进去的，因而应该返回btrfs_wait_for_no_snapshoting_writes继续执行，最后内核执行完毕返回用户态，同样恢复pt_regs，恢复用户态的指令指针寄存器，从用户态接着运行。</p>
<p>到这里你是不是有点理解为什么switch_to有三个参数呢？为啥有两个prev呢？其实我们从定义就可以看到。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">switch_to</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">,</span> last<span class="token punctuation">)</span>                 </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span>                                                </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token function">prepare_switch_to</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>                  </span><span class="token punctuation">\</span>
                                                    <span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span>last<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">__switch_to_asm</span><span class="token punctuation">(</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上面的例子中，A切换到B的时候，运行到<strong>switch_to_asm这一行的时候，是在A的内核栈上运行的，prev是A，next是B。但是，A执行完</strong>switch_to_asm之后就被切换走了，当C再次切换到A的时候，运行到<strong>switch_to_asm，是从C的内核栈运行的。这个时候，prev是C，next是A，但是</strong>switch_to_asm里面切换成为了A当时的内核栈。</p>
<p>还记得当年的场景“prev是A，next是B”，__switch_to_asm里面return prev的时候，还没return的时候，prev这个变量里面放的还是C，因而它会把C放到返回结果中。但是，一旦return，就会弹出A当时的内核栈。这个时候，prev变量就变成了A，next变量就变成了B。这就还原了当年的场景，好在返回值里面的last还是C。</p>
<p>通过三个变量switch_to(prev = A, next=B, last=C)，A进程就明白了，我当时被切换走的时候，是切换成B，这次切换回来，是从C回来的。</p>
<h3 id="11-4-总结"><a href="#11-4-总结" class="headerlink" title="11.4 总结"></a>11.4 总结</h3><p>这一节我们讲主动调度的过程，也即一个运行中的进程主动调用<strong>schedule让出CPU。在</strong>schedule里面会做两件事情，第一是选取下一个进程，第二是进行上下文切换。而上下文切换又分用户态进程空间的切换和内核态的切换。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/主动调度.png" alt="主动调度"></p>
<h2 id="十二、调度（下）"><a href="#十二、调度（下）" class="headerlink" title="十二、调度（下）"></a>十二、调度（下）</h2><h3 id="12-1-抢占式调度"><a href="#12-1-抢占式调度" class="headerlink" title="12.1 抢占式调度"></a>12.1 抢占式调度</h3><p>上一节我们讲的主动调度是第一种方式，第二种方式，就是抢占式调度。什么情况下会发生抢占呢？</p>
<p>最常见的现象就是 <strong>一个进程执行时间太长了，是时候切换到另一个进程了</strong> 。那怎么衡量一个进程的运行时间呢？在计算机里面有一个时钟，会过一段时间触发一次时钟中断，通知操作系统，时间又过去一个时钟周期，这是个很好的方式，可以查看是否是需要抢占的时间点。</p>
<p>时钟中断处理函数会调用scheduler_tick()，它的代码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">scheduler_tick</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> cpu <span class="token operator">=</span> <span class="token function">smp_processor_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq <span class="token operator">=</span> <span class="token function">cpu_rq</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>curr <span class="token operator">=</span> rq<span class="token operator">-&gt;</span>curr<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    curr<span class="token operator">-&gt;</span>sched_class<span class="token operator">-&gt;</span><span class="token function">task_tick</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> curr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">cpu_load_update_active</span><span class="token punctuation">(</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">calc_global_load_tick</span><span class="token punctuation">(</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个函数先取出当前cpu的运行队列，然后得到这个队列上当前正在运行中的进程的task_struct，然后调用这个task_struct的调度类的task_tick函数，顾名思义这个函数就是来处理时钟事件的。</p>
<p>如果当前运行的进程是普通进程，调度类为fair_sched_class，调用的处理时钟的函数为task_tick_fair。我们来看一下它的实现。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">task_tick_fair</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token keyword">int</span> queued<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se <span class="token operator">=</span> <span class="token operator">&amp;</span>curr<span class="token operator">-&gt;</span>se<span class="token punctuation">;</span>

    <span class="token function">for_each_sched_entity</span><span class="token punctuation">(</span>se<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cfs_rq <span class="token operator">=</span> <span class="token function">cfs_rq_of</span><span class="token punctuation">(</span>se<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">entity_tick</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> se<span class="token punctuation">,</span> queued<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>根据当前进程的task_struct，找到对应的调度实体sched_entity和cfs_rq队列，调用entity_tick。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span>
<span class="token function">entity_tick</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token keyword">int</span> queued<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">update_curr</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">update_load_avg</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> UPDATE_TG<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">update_cfs_shares</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cfs_rq<span class="token operator">-&gt;</span>nr_running <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token function">check_preempt_tick</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> curr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在entity_tick里面，我们又见到了熟悉的update_curr。它会更新当前进程的vruntime，然后调用check_preempt_tick。顾名思义就是，检查是否是时候被抢占了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span>
<span class="token function">check_preempt_tick</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>curr<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ideal_runtime<span class="token punctuation">,</span> delta_exec<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se<span class="token punctuation">;</span>
    s64 delta<span class="token punctuation">;</span>

    ideal_runtime <span class="token operator">=</span> <span class="token function">sched_slice</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> curr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    delta_exec <span class="token operator">=</span> curr<span class="token operator">-&gt;</span>sum_exec_runtime <span class="token operator">-</span> curr<span class="token operator">-&gt;</span>prev_sum_exec_runtime<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>delta_exec <span class="token operator">&gt;</span> ideal_runtime<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">resched_curr</span><span class="token punctuation">(</span><span class="token function">rq_of</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    se <span class="token operator">=</span> <span class="token function">__pick_first_entity</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
    delta <span class="token operator">=</span> curr<span class="token operator">-&gt;</span>vruntime <span class="token operator">-</span> se<span class="token operator">-&gt;</span>vruntime<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>delta <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>delta <span class="token operator">&gt;</span> ideal_runtime<span class="token punctuation">)</span>
        <span class="token function">resched_curr</span><span class="token punctuation">(</span><span class="token function">rq_of</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>check_preempt_tick先是调用sched_slice函数计算出的ideal_runtime，他是一个调度周期中，这个进程应该运行的实际时间。</p>
<p>sum_exec_runtime指进程总共执行的实际时间，prev_sum_exec_runtime指上次该进程被调度时已经占用的实际时间。每次在调度一个新的进程时都会把它的se-&gt;prev_sum_exec_runtime = se-&gt;sum_exec_runtime，所以sum_exec_runtime-prev_sum_exec_runtime就是这次调度占用实际时间。如果这个时间大于ideal_runtime，则应该被抢占了。</p>
<p>除了这个条件之外，还会通过__pick_first_entity取出红黑树中最小的进程。如果当前进程的vruntime大于红黑树中最小的进程的vruntime，且差值大于ideal_runtime，也应该被抢占了。</p>
<p>当发现当前进程应该被抢占，不能直接把它踢下来，而是把它标记为应该被抢占。为什么呢？因为进程调度第一定律呀，一定要等待正在运行的进程调用__schedule才行啊，所以这里只能先标记一下。</p>
<p>标记一个进程应该被抢占，都是调用resched_curr，它会调用set_tsk_need_resched，标记进程应该被抢占，但是此时此刻，并不真的抢占，而是打上一个标签TIF_NEED_RESCHED。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">set_tsk_need_resched</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">set_tsk_thread_flag</span><span class="token punctuation">(</span>tsk<span class="token punctuation">,</span>TIF_NEED_RESCHED<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>另外一个可能抢占的场景是 <strong>当一个进程被唤醒的时候</strong> 。</p>
<p>我们前面说过，当一个进程在等待一个I/O的时候，会主动放弃CPU。但是当I/O到来的时候，进程往往会被唤醒。这个时候是一个时机。当被唤醒的进程优先级高于CPU上的当前进程，就会触发抢占。try_to_wake_up()调用ttwu_queue将这个唤醒的任务添加到队列当中。ttwu_queue再调用ttwu_do_activate激活这个任务。ttwu_do_activate调用ttwu_do_wakeup。这里面调用了check_preempt_curr检查是否应该发生抢占。如果应该发生抢占，也不是直接踢走当然进程，而也是将当前进程标记为应该被抢占。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">ttwu_do_wakeup</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> wake_flags<span class="token punctuation">,</span>
               <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> <span class="token operator">*</span>rf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">check_preempt_curr</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> p<span class="token punctuation">,</span> wake_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>state <span class="token operator">=</span> TASK_RUNNING<span class="token punctuation">;</span>
    <span class="token function">trace_sched_wakeup</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>到这里，你会发现，抢占问题只做完了一半。就是标识当前运行中的进程应该被抢占了，但是真正的抢占动作并没有发生。</p>
<h3 id="12-2-抢占的时机"><a href="#12-2-抢占的时机" class="headerlink" title="12.2 抢占的时机"></a>12.2 抢占的时机</h3><p>真正的抢占还需要时机，也就是需要那么一个时刻，让正在运行中的进程有机会调用一下__schedule。</p>
<p>你可以想象，不可能某个进程代码运行着，突然要去调用__schedule，代码里面不可能这么写，所以一定要规划几个时机，这个时机分为用户态和内核态。</p>
<h4 id="12-2-1-用户态的抢占时机"><a href="#12-2-1-用户态的抢占时机" class="headerlink" title="12.2.1 用户态的抢占时机"></a>12.2.1 用户态的抢占时机</h4><p>对于用户态的进程来讲，从系统调用中返回的那个时刻，是一个被抢占的时机。</p>
<p>前面讲系统调用的时候，64位的系统调用的链路位do_syscall_64-&gt;syscall_return_slowpath-&gt;prepare_exit_to_usermode-&gt;exit_to_usermode_loop，当时我们还没关注exit_to_usermode_loop这个函数，现在我们来看一下。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">exit_to_usermode_loop</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span>regs<span class="token punctuation">,</span> u32 cached_flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* We have work to do. */</span>
        <span class="token function">local_irq_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>cached_flags <span class="token operator">&amp;</span> _TIF_NEED_RESCHED<span class="token punctuation">)</span>
            <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在我们看到在exit_to_usermode_loop函数中，上面打的标记起了作用，如果被打了_TIF_NEED_RESCHED，调用schedule进行调度，调用的过程和上一节解析的一样，会选择一个进程让出CPU，做上下文切换。</p>
<p>对于用户态的进程来讲，从中断中返回的那个时刻，也是一个被抢占的时机。</p>
<p>在arch/x86/entry/entry_64.S中有中断的处理过程。又是一段汇编语言代码，你重点领会它的意思就行，不要纠结每一行都看懂。</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">common_interrupt:
        ASM_CLAC
        addq    $-0x80, (%rsp)
        interrupt do_IRQ
ret_from_intr:
        popq    %rsp
        testb   $3, CS(%rsp)
        jz      retint_kernel
/* Interrupt came from user space */
GLOBAL(retint_user)
        mov     %rsp,%rdi
        call    prepare_exit_to_usermode
        TRACE_IRQS_IRETQ
        SWAPGS
        jmp     restore_regs_and_iret
/* Returning to kernel space */
retint_kernel:
#ifdef CONFIG_PREEMPT
        bt      $9, EFLAGS(%rsp)
        jnc     1f
0:      cmpl    $0, PER_CPU_VAR(__preempt_count)
        jnz     1f
        call    preempt_schedule_irq
        jmp     0b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>中断处理调用的是do_IRQ函数，中断完毕后分为两种情况，一个是返回用户态，一个是返回内核态。这个通过注释也能看出来。</p>
<p>咱们先来来看返回用户态这一部分，先不管返回内核态的那部分代码，retint_user会调用prepare_exit_to_usermode，最终调用exit_to_usermode_loop，和上面的逻辑一样，发现有标记则调用schedule()。</p>
<h4 id="12-2-2-内核态的抢占时机"><a href="#12-2-2-内核态的抢占时机" class="headerlink" title="12.2.2 内核态的抢占时机"></a>12.2.2 内核态的抢占时机</h4><p>对内核态的执行中，被抢占的时机一般发生在在preempt_enable()中。</p>
<p>在内核态的执行中，有的操作是不能被中断的，所以在进行这些操作之前，总是先调用preempt_disable()关闭抢占，当再次打开的时候，就是一次内核态代码被抢占的机会。</p>
<p>就像下面代码中展示的一样，preempt_enable()会调用preempt_count_dec_and_test()，判断preempt_count和TIF_NEED_RESCHED看是否可以被抢占。如果可以，就调用preempt_schedule-&gt;preempt_schedule_common-&gt;__schedule进行调度。还是满足进程调度第一定律的。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">preempt_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                        </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span>                                            </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token function">preempt_count_dec_and_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">__preempt_schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">preempt_count_dec_and_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token function">preempt_count_sub</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">should_resched</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span></span></span>

<span class="token keyword">static</span> __always_inline bool <span class="token function">should_resched</span><span class="token punctuation">(</span><span class="token keyword">int</span> preempt_offset<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token function">preempt_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> preempt_offset <span class="token operator">&amp;&amp;</span>
            <span class="token function">tif_need_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">tif_need_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">test_thread_flag</span><span class="token punctuation">(</span>TIF_NEED_RESCHED<span class="token punctuation">)</span></span></span>

<span class="token keyword">static</span> <span class="token keyword">void</span> __sched notrace <span class="token function">preempt_schedule_common</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token function">__schedule</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">need_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在内核态也会遇到中断的情况，当中断返回的时候，返回的仍然是内核态。这个时候也是一个执行抢占的时机，现在我们再来上面中断返回的代码中返回内核的那部分代码，调用的是preempt_schedule_irq。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">asmlinkage __visible <span class="token keyword">void</span> __sched <span class="token function">preempt_schedule_irq</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        <span class="token function">preempt_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">local_irq_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">__schedule</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">local_irq_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sched_preempt_enable_no_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">need_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>preempt_schedule_irq调用__schedule进行调度。还是满足进程调度第一定律的。</p>
<h3 id="12-3-总结"><a href="#12-3-总结" class="headerlink" title="12.3 总结"></a>12.3 总结</h3><p>第一条就是总结了进程调度第一定律的核心函数__schedule的执行过程，这是上一节讲的，因为要切换的东西比较多，需要你详细了解每一部分是如何切换的。</p>
<p>第二条总结了标记为可抢占的场景，第三条是所有的抢占发生的时机，这里是真正验证了进程调度第一定律的。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/进程的调度体系.png" alt="进程的调度体系"></p>
<h2 id="十三、进程的创建"><a href="#十三、进程的创建" class="headerlink" title="十三、进程的创建"></a>十三、进程的创建</h2><p>fork是一个系统调用，根据咱们讲过的系统调用的流程，流程的最后会在sys_call_table中找到相应的系统调用sys_fork。</p>
<p>根据SYSCALL_DEFINE0这个宏的定义，下面这段代码就定义了sys_fork。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE0</span><span class="token punctuation">(</span>fork<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> <span class="token function">_do_fork</span><span class="token punctuation">(</span>SIGCHLD<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>sys_fork会调用_do_fork。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">long</span> <span class="token function">_do_fork</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> clone_flags<span class="token punctuation">,</span>
          <span class="token keyword">unsigned</span> <span class="token keyword">long</span> stack_start<span class="token punctuation">,</span>
          <span class="token keyword">unsigned</span> <span class="token keyword">long</span> stack_size<span class="token punctuation">,</span>
          <span class="token keyword">int</span> __user <span class="token operator">*</span>parent_tidptr<span class="token punctuation">,</span>
          <span class="token keyword">int</span> __user <span class="token operator">*</span>child_tidptr<span class="token punctuation">,</span>
          <span class="token keyword">unsigned</span> <span class="token keyword">long</span> tls<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
    <span class="token keyword">int</span> trace <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> nr<span class="token punctuation">;</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    p <span class="token operator">=</span> <span class="token function">copy_process</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> stack_start<span class="token punctuation">,</span> stack_size<span class="token punctuation">,</span>
             child_tidptr<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> trace<span class="token punctuation">,</span> tls<span class="token punctuation">,</span> NUMA_NO_NODE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">pid</span> <span class="token operator">*</span>pid<span class="token punctuation">;</span>
        pid <span class="token operator">=</span> <span class="token function">get_task_pid</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> PIDTYPE_PID<span class="token punctuation">)</span><span class="token punctuation">;</span>
        nr <span class="token operator">=</span> <span class="token function">pid_vnr</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>


        <span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_PARENT_SETTID<span class="token punctuation">)</span>
            <span class="token function">put_user</span><span class="token punctuation">(</span>nr<span class="token punctuation">,</span> parent_tidptr<span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token function">wake_up_new_task</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token function">put_pid</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="13-1-fork的第一件大事：复制结构"><a href="#13-1-fork的第一件大事：复制结构" class="headerlink" title="13.1 fork的第一件大事：复制结构"></a>13.1 fork的第一件大事：复制结构</h3><p>_do_fork里面做的第一件大事就是copy_process。</p>
<p>这里我们再把task_struct的结构图拿出来，对比着看如何一个个复制。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/fork复制结构.png" alt="fork复制结构"></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> __latent_entropy <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token function">copy_process</span><span class="token punctuation">(</span>
                    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> clone_flags<span class="token punctuation">,</span>
                    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> stack_start<span class="token punctuation">,</span>
                    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> stack_size<span class="token punctuation">,</span>
                    <span class="token keyword">int</span> __user <span class="token operator">*</span>child_tidptr<span class="token punctuation">,</span>
                    <span class="token keyword">struct</span> <span class="token class-name">pid</span> <span class="token operator">*</span>pid<span class="token punctuation">,</span>
                    <span class="token keyword">int</span> trace<span class="token punctuation">,</span>
                    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> tls<span class="token punctuation">,</span>
                    <span class="token keyword">int</span> node<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> retval<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    p <span class="token operator">=</span> <span class="token function">dup_task_struct</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>dup_task_struct主要做了下面几件事情：</p>
<ul>
<li>调用alloc_task_struct_node分配一个task_struct结构；</li>
<li>调用alloc_thread_stack_node来创建内核栈，这里面调用__vmalloc_node_range分配一个连续的THREAD_SIZE的内存空间，赋值给task_struct的void *stack成员变量；</li>
<li>调用arch_dup_task_struct(struct task_struct <em>dst, struct task_struct </em>src)，将task_struct进行复制，其实就是调用memcpy；</li>
<li>调用setup_thread_stack设置thread_info。</li>
</ul>
<p>到这里，整个task_struct复制了一份，而且内核栈也创建好了。</p>
<p>我们再接着看copy_process。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">retval <span class="token operator">=</span> <span class="token function">copy_creds</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> clone_flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>轮到权限相关了，copy_creds主要做了下面几件事情：</p>
<ul>
<li>调用prepare_creds，准备一个新的struct cred *new。如何准备呢？其实还是从内存中分配一个新的struct cred结构，然后调用memcpy复制一份父进程的cred；</li>
<li>接着p-&gt;cred = p-&gt;real_cred = get_cred(new)，将新进程的“我能操作谁”和“谁能操作我”两个权限都指向新的cred。</li>
</ul>
<p>接下来，copy_process重新设置进程运行的统计量。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">p<span class="token operator">-&gt;</span>utime <span class="token operator">=</span> p<span class="token operator">-&gt;</span>stime <span class="token operator">=</span> p<span class="token operator">-&gt;</span>gtime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>start_time <span class="token operator">=</span> <span class="token function">ktime_get_ns</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>real_start_time <span class="token operator">=</span> <span class="token function">ktime_get_boot_ns</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>接下来，copy_process开始设置调度相关的变量。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">retval <span class="token operator">=</span> <span class="token function">sched_fork</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>sched_fork主要做了下面几件事情：</p>
<ul>
<li>调用__sched_fork，在这里面将on_rq设为0，初始化sched_entity，将里面的exec_start、sum_exec_runtime、prev_sum_exec_runtime、vruntime都设为0。你还记得吗，这几个变量涉及进程的实际运行时间和虚拟运行时间。是否到时间应该被调度了，就靠它们几个；</li>
<li>设置进程的状态p-&gt;state = TASK_NEW；</li>
<li>初始化优先级prio、normal_prio、static_prio；</li>
<li>设置调度类，如果是普通进程，就设置为p-&gt;sched_class = &amp;fair_sched_class；</li>
<li>调用调度类的task_fork函数，对于CFS来讲，就是调用task_fork_fair。在这个函数里，先调用update_curr，对于当前的进程进行统计量更新，然后把子进程和父进程的vruntime设成一样，最后调用place_entity，初始化sched_entity。这里有一个变量sysctl_sched_child_runs_first，可以设置父进程和子进程谁先运行。如果设置了子进程先运行，即便两个进程的vruntime一样，也要把子进程的sched_entity放在前面，然后调用resched_curr，标记当前运行的进程TIF_NEED_RESCHED，也就是说，把父进程设置为应该被调度，这样下次调度的时候，父进程会被子进程抢占。</li>
</ul>
<p>接下来，copy_process开始初始化与文件和文件系统相关的变量。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">retval <span class="token operator">=</span> <span class="token function">copy_files</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
retval <span class="token operator">=</span> <span class="token function">copy_fs</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>copy_files主要用于复制一个进程打开的文件信息。这些信息用一个结构files_struct来维护，每个打开的文件都有一个文件描述符。在copy_files函数里面调用dup_fd，在这里面会创建一个新的files_struct，然后将所有的文件描述符数组fdtable拷贝一份。</p>
<p>copy_fs主要用于复制一个进程的目录信息。这些信息用一个结构fs_struct来维护。一个进程有自己的根目录和根文件系统root，也有当前目录pwd和当前目录的文件系统，都在fs_struct里面维护。copy_fs函数里面调用copy_fs_struct，创建一个新的fs_struct，并复制原来进程的fs_struct。</p>
<p>接下来，copy_process开始初始化与信号相关的变量。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">init_sigpending</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>pending<span class="token punctuation">)</span><span class="token punctuation">;</span>
retval <span class="token operator">=</span> <span class="token function">copy_sighand</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
retval <span class="token operator">=</span> <span class="token function">copy_signal</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>copy_sighand会分配一个新的sighand_struct。这里最主要的是维护信号处理函数，在copy_sighand里面会调用memcpy，将信号处理函数sighand-&gt;action从父进程复制到子进程。</p>
<p>init_sigpending和copy_signal用于初始化，并且复制用于维护发给这个进程的信号的数据结构。copy_signal函数会分配一个新的signal_struct，并进行初始化。</p>
<p>接下来，copy_process开始复制进程内存空间。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">retval <span class="token operator">=</span> <span class="token function">copy_mm</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>进程都自己的内存空间，用mm_struct结构来表示。copy_mm函数中调用dup_mm，分配一个新的mm_struct结构，调用memcpy复制这个结构。dup_mmap用于复制内存空间中内存映射的部分。前面讲系统调用的时候，我们说过，mmap可以分配大块的内存，其实mmap也可以将一个文件映射到内存中，方便可以像读写内存一样读写文件，这个在内存管理那节我们讲。</p>
<p>接下来，copy_process开始分配pid，设置tid，group_leader，并且建立进程之间的亲缘关系。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">    <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>children<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>sibling<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    p<span class="token operator">-&gt;</span>pid <span class="token operator">=</span> <span class="token function">pid_nr</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_THREAD<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        p<span class="token operator">-&gt;</span>exit_signal <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        p<span class="token operator">-&gt;</span>group_leader <span class="token operator">=</span> current<span class="token operator">-&gt;</span>group_leader<span class="token punctuation">;</span>
        p<span class="token operator">-&gt;</span>tgid <span class="token operator">=</span> current<span class="token operator">-&gt;</span>tgid<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_PARENT<span class="token punctuation">)</span>
            p<span class="token operator">-&gt;</span>exit_signal <span class="token operator">=</span> current<span class="token operator">-&gt;</span>group_leader<span class="token operator">-&gt;</span>exit_signal<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            p<span class="token operator">-&gt;</span>exit_signal <span class="token operator">=</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CSIGNAL<span class="token punctuation">)</span><span class="token punctuation">;</span>
        p<span class="token operator">-&gt;</span>group_leader <span class="token operator">=</span> p<span class="token punctuation">;</span>
        p<span class="token operator">-&gt;</span>tgid <span class="token operator">=</span> p<span class="token operator">-&gt;</span>pid<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span>CLONE_PARENT<span class="token operator">|</span>CLONE_THREAD<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        p<span class="token operator">-&gt;</span>real_parent <span class="token operator">=</span> current<span class="token operator">-&gt;</span>real_parent<span class="token punctuation">;</span>
        p<span class="token operator">-&gt;</span>parent_exec_id <span class="token operator">=</span> current<span class="token operator">-&gt;</span>parent_exec_id<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        p<span class="token operator">-&gt;</span>real_parent <span class="token operator">=</span> current<span class="token punctuation">;</span>
        p<span class="token operator">-&gt;</span>parent_exec_id <span class="token operator">=</span> current<span class="token operator">-&gt;</span>self_exec_id<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>好了，copy_process要结束了，上面图中的组件也初始化的差不多了。</p>
<h3 id="13-2-fork的第二件大事：唤醒新进程"><a href="#13-2-fork的第二件大事：唤醒新进程" class="headerlink" title="13.2 fork的第二件大事：唤醒新进程"></a>13.2 fork的第二件大事：唤醒新进程</h3><p>_do_fork做的第二件大事是wake_up_new_task。新任务刚刚建立，有没有机会抢占别人，获得CPU呢？</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">wake_up_new_task</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> rf<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    p<span class="token operator">-&gt;</span>state <span class="token operator">=</span> TASK_RUNNING<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">activate_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> p<span class="token punctuation">,</span> ENQUEUE_NOCLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>on_rq <span class="token operator">=</span> TASK_ON_RQ_QUEUED<span class="token punctuation">;</span>
    <span class="token function">trace_sched_wakeup_new</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">check_preempt_curr</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> p<span class="token punctuation">,</span> WF_FORK<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先，我们需要将进程的状态设置为TASK_RUNNING。</p>
<p>activate_task函数中会调用enqueue_task。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">enqueue_task</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    p<span class="token operator">-&gt;</span>sched_class<span class="token operator">-&gt;</span><span class="token function">enqueue_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> p<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果是CFS的调度类，则执行相应的enqueue_task_fair。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span>
<span class="token function">enqueue_task_fair</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se <span class="token operator">=</span> <span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>se<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    cfs_rq <span class="token operator">=</span> <span class="token function">cfs_rq_of</span><span class="token punctuation">(</span>se<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">enqueue_entity</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> se<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    cfs_rq<span class="token operator">-&gt;</span>h_nr_running<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在enqueue_task_fair中取出的队列就是cfs_rq，然后调用enqueue_entity。</p>
<p>在enqueue_entity函数里面，会调用update_curr，更新运行的统计量，然后调用__enqueue_entity，将sched_entity加入到红黑树里面，然后将se-&gt;on_rq = 1设置在队列上。</p>
<p>回到enqueue_task_fair后，将这个队列上运行的进程数目加一。然后，wake_up_new_task会调用check_preempt_curr，看是否能够抢占当前进程。</p>
<p>在check_preempt_curr中，会调用相应的调度类的rq-&gt;curr-&gt;sched_class-&gt;check_preempt_curr(rq, p, flags)。对于CFS调度类来讲，调用的是check_preempt_wakeup。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">check_preempt_wakeup</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> wake_flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>curr <span class="token operator">=</span> rq<span class="token operator">-&gt;</span>curr<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se <span class="token operator">=</span> <span class="token operator">&amp;</span>curr<span class="token operator">-&gt;</span>se<span class="token punctuation">,</span> <span class="token operator">*</span>pse <span class="token operator">=</span> <span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>se<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq <span class="token operator">=</span> <span class="token function">task_cfs_rq</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">test_tsk_need_resched</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">find_matching_se</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>se<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pse<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">update_curr</span><span class="token punctuation">(</span><span class="token function">cfs_rq_of</span><span class="token punctuation">(</span>se<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">wakeup_preempt_entity</span><span class="token punctuation">(</span>se<span class="token punctuation">,</span> pse<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">goto</span> preempt<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
preempt<span class="token operator">:</span>
    <span class="token function">resched_curr</span><span class="token punctuation">(</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在check_preempt_wakeup函数中，前面调用task_fork_fair的时候，设置sysctl_sched_child_runs_first了，已经将当前父进程的TIF_NEED_RESCHED设置了，则直接返回。</p>
<p>否则，check_preempt_wakeup还是会调用update_curr更新一次统计量，然后wakeup_preempt_entity将父进程和子进程PK一次，看是不是要抢占，如果要则调用resched_curr标记父进程为TIF_NEED_RESCHED。</p>
<p>如果新创建的进程应该抢占父进程，在什么时间抢占呢？别忘了fork是一个系统调用，从系统调用返回的时候，是抢占的一个好时机，如果父进程判断自己已经被设置为TIF_NEED_RESCHED，就让子进程先跑，抢占自己。</p>
<h3 id="13-3-总结"><a href="#13-3-总结" class="headerlink" title="13.3 总结"></a>13.3 总结</h3><p>fork系统调用的过程咱们就解析完了。它包含两个重要的事件，一个是将task_struct结构复制一份并且初始化，另一个是试图唤醒新创建的子进程。</p>
<p>这个过程我画了一张图，你可以对照着这张图回顾进程创建的过程。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/进程创建的过程.jpeg" alt="进程创建的过程"></p>
<p>这个图的上半部分是复制task_struct结构，你可以对照着右面的task_struct结构图，看这里面的成员是如何一部分一部分的被复制的。图的下半部分是唤醒新创建的子进程，如果条件满足，就会将当前进程设置应该被调度的标识位，就等着当前进程执行__schedule了。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://kibazen.cn" rel="external nofollow noreferrer">Kiba Amor</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                    </span>
                <span class="reprint-info">
                    <a href="https://kibazen.cn/qu-tan-linux-cao-zuo-xi-tong-xue-xi-bi-ji/">https://kibazen.cn/qu-tan-linux-cao-zuo-xi-tong-xue-xi-bi-ji/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY-NC-ND 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://kibazen.cn" target="_blank">Kiba Amor</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                                    <span class="chip bg-color">极客时间</span>
                                </a>
                            
                                <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                                    <span class="chip bg-color">操作系统</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="qq,wechat,weibo,douban" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/qu-tan-linux-cao-zuo-xi-tong-xue-xi-bi-ji/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/17.jpg" class="responsive-img" alt="《趣谈Linux操作系统》学习笔记">
                        
                        <span class="card-title">《趣谈Linux操作系统》学习笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-11-25
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                    学习笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                        <span class="chip bg-color">极客时间</span>
                    </a>
                    
                    <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                        <span class="chip bg-color">操作系统</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/linux-xing-neng-you-hua-shi-zhan-xue-xi-bi-ji/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/7.jpg" class="responsive-img" alt="《Linux性能优化实战》学习笔记">
                        
                        <span class="card-title">《Linux性能优化实战》学习笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-11-04
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                    学习笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/">
                        <span class="chip bg-color">性能分析</span>
                    </a>
                    
                    <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                        <span class="chip bg-color">极客时间</span>
                    </a>
                    
                    <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">
                        <span class="chip bg-color">性能优化</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (true) {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 木叶禅<br />'
            + '文章作者: Kiba Amor<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者木叶禅所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('2'),
            headingSelector: 'h2, h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2021</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">Kiba Amor</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">435.7k</span>&nbsp;字
            
            
            
            
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/kibaamor" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>









    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=562236616" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 562236616" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>





    <a href="https://www.zhihu.com/people/kibaamor" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/kibaamor" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    

    

    

	
    

    

    

    
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
