<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <meta name="keywords" content="《趣谈Linux操作系统》学习笔记, kiba, zen, amor, kibazen, kibaamor, 木叶, 木叶禅">
    <meta name="description" content="一个普通游戏程序员的博客">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>《趣谈Linux操作系统》学习笔记 | 木叶禅</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/css/my.css">

    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="木叶禅" type="application/atom+xml">
</head>



   <style>
    body{
       background-image: url(/medias/background.jpg);
       background-repeat:no-repeat;
       background-size:cover;
       background-attachment:fixed;
    }
</style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">木叶禅</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/leetcode/" class="waves-effect waves-light">
      
      <i class="fas fa-code" style="zoom: 0.6;"></i>
      
      <span>LeetCode</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/learn/" class="waves-effect waves-light">
      
      <i class="fas fa-book" style="zoom: 0.6;"></i>
      
      <span>学习</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tool/" class="waves-effect waves-light">
      
      <i class="fas fa-toolbox" style="zoom: 0.6;"></i>
      
      <span>工具</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories/" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags/" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about/" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">木叶禅</div>
        <div class="logo-desc">
            
            一个普通游戏程序员的博客
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/leetcode/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-code"></i>
			
			LeetCode
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/learn/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-book"></i>
			
			学习
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tool/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-toolbox"></i>
			
			工具
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    
<script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = 'f65e070788a2647953051a7a1b70ada7fd2b3f70cd4d93c977207f5b762987d4';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/17.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">《趣谈Linux操作系统》学习笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                                <span class="chip bg-color">极客时间</span>
                            </a>
                        
                            <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                                <span class="chip bg-color">操作系统</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                学习笔记
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-11-25
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2022-01-04
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    218.4k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    890 分
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="一、系统初始化"><a href="#一、系统初始化" class="headerlink" title="一、系统初始化"></a>一、系统初始化</h2><h3 id="1-x86架构"><a href="#1-x86架构" class="headerlink" title="1. x86架构"></a>1. x86架构</h3><h4 id="1-1-8086的原理"><a href="#1-1-8086的原理" class="headerlink" title="1.1 8086的原理"></a>1.1 8086的原理</h4><p><img src="/images/《趣谈Linux操作系统》学习笔记/8086CPU.jpeg" alt="8086CPU"></p>
<ol>
<li><p>数据单元</p>
<p> 为了暂存数据，8086处理器内部有8个16位的通用寄存器，分别是AX、BX、CX、DX、SP、BP、SI、DI。这些寄存器主要用于在计算过程中暂存数据。</p>
<p> 其中AX、BX、CX、DX可以分成两个8位的寄存器来使用，分别是AH、AL、BH、BL、CH、CL、DH、DL，其中H就是High（高位），L就是Low（低位）的意思。</p>
</li>
<li><p>控制单元</p>
<p> IP寄存器就是指令指针寄存器（Instruction Pointer Register)，指向代码段中下一条指令的位置。CPU会根据它来不断地将指令从内存的代码段中，加载到CPU的指令队列中，然后交给运算单元去执行。</p>
<p> 如果需要切换进程呢？每个进程都分代码段和数据段，为了指向不同进程的地址空间，有四个16位的段寄存器，分别是CS、DS、SS、ES。</p>
<p> 其中，CS就是代码段寄存器（Code Segment Register），通过它可以找到代码在内存中的位置；DS是数据段的寄存器，通过它可以找到数据在内存中的位置。</p>
<p> SS是栈寄存器（Stack Register）。栈是程序运行中一个特殊的数据结构，数据的存取只能从一端进行，秉承后进先出的原则，push就是入栈，pop就是出栈。</p>
<p> ES为扩展段寄存器。</p>
<p> 在CS和DS中都存放着一个段的起始地址。代码段的偏移量在IP寄存器中，数据段的偏移量会放在通用寄存器中。</p>
<p> 这时候问题来了，CS和DS都是16位的，也就是说，起始地址都是16位的，IP寄存器和通用寄存器都是16位的，偏移量也是16位的，但是8086的地址总线地址是20位。怎么凑够这20位呢？方法就是“起始地址*16+偏移量”，也就是把CS和DS中的值左移4位，变成20位的，加上16位的偏移量，这样就可以得到最终20位的数据地址。</p>
<p> 因为偏移量只能是16位的，所以一个段最大的大小是2^16=64k。</p>
</li>
</ol>
<h4 id="1-2-32位处理器"><a href="#1-2-32位处理器" class="headerlink" title="1.2 32位处理器"></a>1.2 32位处理器</h4><p>在32位处理器中，有32根地址总线，可以访问2^32=4G的内存。</p>
<p>首先，通用寄存器有扩展，可以将8个16位的扩展到8个32位的，但是依然可以保留16位的和8位的使用方式。你可能会问，为什么高16位不分成两个8位使用呢？因为这样就不兼容了呀！</p>
<p>其中，指向下一条指令的指令指针寄存器IP，就会扩展成32位的，同样也兼容16位的。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/32位处理器.jpeg" alt="32位处理器"></p>
<p>而改动比较大，有点不兼容的就是段寄存器（Segment Register）。</p>
<p>CS、SS、DS、ES仍然是16位的，但是不再是段的起始地址。段的起始地址放在内存的某个地方。这个地方是一个表格，表格中的一项一项是段描述符（Segment Descriptor）。这里面才是真正的段的起始地址。而段寄存器里面保存的是在这个表格中的哪一项，称为选择子（Selector）。</p>
<p>这样，将一个从段寄存器直接拿到的段起始地址，就变成了先间接地从段寄存器找到表格中的一项，再从表格中的一项中拿到段起始地址。</p>
<blockquote>
<p>为了快速拿到段起始地址，段寄存器会从内存中拿到CPU的描述符高速缓存器中。</p>
</blockquote>
<p>32位的系统架构下，我们将前一种模式称为实模式（Real Pattern），后一种模式称为保护模式（Protected Pattern）。</p>
<p>当系统刚刚启动的时候，CPU是处于实模式的。</p>
<h4 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3 总结"></a>1.3 总结</h4><p><img src="/images/《趣谈Linux操作系统》学习笔记/x86架构.jpeg" alt="x86架构"></p>
<h3 id="2-系统启动过程"><a href="#2-系统启动过程" class="headerlink" title="2. 系统启动过程"></a>2. 系统启动过程</h3><p><img src="/images/《趣谈Linux操作系统》学习笔记/x86系统中的1M空间.jpeg" alt="x86系统中的1M空间"></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/quan0311/p/15292110.html">谈谈Linux系统启动流程</a></p>
<ol>
<li><p>系统加电后，CPU 运行在实模式下，且 CS 重置为 0xFFFF ，IP 为 0x0000。</p>
<p> 实模式下，内存地址的计算方式是：<code>段寄存器 * 16 + 偏移量</code> 。所以系统加电后运行的第一条指令在 <code>CS * 16 + IP = 0xFFFF0</code> 。</p>
<blockquote>
<p>实模式只有 1MB 内存寻址空间(X86)。</p>
</blockquote>
</li>
<li><p>在 x86 系统中，内存 <code>0xF0000-0xFFFFF</code> 映射到 BIOS 程序（存储在 ROM 中），BIOS 主要做三件事：</p>
<ol>
<li>检查硬件。</li>
<li>提供基本输入（中断）输出（显存映射）服务。</li>
<li><p>把 MBR（Master Boot Record，主引导记录/扇区）装载到内存 0x7C00 开始的 512 字节大小的内存区域，并设置 CS:IP 为 0x0000:7C00 。</p>
<blockquote>
<p>MBR 指启动盘的第一个扇区，大小 512 字节，并且以 0xAA55 结束。</p>
<p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2015/09/0x7c00.html">为什么主引导记录的内存地址是0x7C00？</a></p>
</blockquote>
</li>
</ol>
</li>
<li><p>MBR中存放的一般是由 Grub2 写入的 boot.img。</p>
</li>
<li><p>boot.img 加载 Grub2 的 core.img 。</p>
<blockquote>
<p>boot.img 由 <a target="_blank" rel="noopener" href="https://github.com/rhboot/grub2/blob/master/grub-core/boot/i386/pc/boot.S">boot.S</a> 编译而成。</p>
<p>core.img 包括 diskroot.img, lzma_decompress.img, kernel.img 以及其他模块。</p>
</blockquote>
</li>
<li><p>硬盘启动时，boot.img 先加载运行 diskroot.img, 再由 diskroot.img 加载 core.img 的其他内容。</p>
</li>
<li><p>diskroot.img 解压运行 lzma_compress.img 。</p>
<blockquote>
<p>diskroot.img 由 <a target="_blank" rel="noopener" href="https://github.com/rhboot/grub2/blob/master/grub-core/boot/i386/pc/diskboot.S">diskboot.S</a> 编译而成。</p>
</blockquote>
</li>
<li><p>lzma_compress.img 首先切换到保护模式。然后再解压运行 grub 内核 kernel.img。</p>
<blockquote>
<p>lzma_compress.img 由 <a target="_blank" rel="noopener" href="https://github.com/rhboot/grub2/blob/master/grub-core/boot/i386/pc/startup_raw.S">startup_raw.S</a> 编译而成。</p>
</blockquote>
<p> 调用 <code>real_to_prot</code> 切换到保护模式需要做三件事：</p>
<ul>
<li>启用分段, 辅助进程管理。在内存里面建立段描述符表，将寄存器里面的段寄存器变成段选择子，指向某个段描述符，这样就能实现不同进程的切换了。</li>
<li>启动分页, 辅助内存管理；将内存分成相等大小的块。</li>
<li>打开其他地址线。打开Gate A20，也就是第21根地址线的控制线。</li>
</ul>
</li>
<li><p>kernel.img 主要做的是根据配置信息，加载用户选择 linux kernel 并传递内核启动参数。</p>
<p> kernel.img 对应的代码是 <a target="_blank" rel="noopener" href="https://github.com/rhboot/grub2/blob/master/grub-core/kern/i386/pc/startup.S">startup.S</a> 以及一堆 c 文件，在 startup.S 中会调用 <code>grub_main</code> ，这是 grub kernel 的主函数。</p>
<p> 将真正的操作系统的 kernel 镜像加载执行，Linux Kernel的启动入口是 <code>start_kernel()</code> 。</p>
</li>
<li><p><code>start_kernel()</code> 中会进行一部分初始化工作，最后调用 <code>rest_init()</code> 来完成其他的初始化工作。</p>
</li>
<li><p><code>rest_init()</code> 中会创建系统 1 号进程 kernel_init ， kernel_init 会执行 ramdisk 中的 init 程序，并切换至用户态，加载驱动后执行真正的根文件系统中的 init 程序。</p>
</li>
<li><p><code>rest_init()</code> 中会创建系统 2 号进程 kthread ，负责所有内核态线程的调度和管理，是内核态所有运行线程的祖先。</p>
</li>
</ol>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/系统启动过程.jpeg" alt="系统启动过程"></p>
<h3 id="3-内核初始化"><a href="#3-内核初始化" class="headerlink" title="3. 内核初始化"></a>3. 内核初始化</h3><p>内核的启动从入口函数start_kernel()开始。在init/main.c文件中，start_kernel相当于内核的main函数。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/内核初始化.jpeg" alt="内核初始化"></p>
<h4 id="3-1-初始化任务管理"><a href="#3-1-初始化任务管理" class="headerlink" title="3.1 初始化任务管理"></a>3.1 初始化任务管理</h4><p>在操作系统里面，先要有个创始进程，有一行指令set_task_stack_end_magic(&amp;init_task)。这里面有一个参数init_task，它的定义是struct task_struct init_task = INIT_TASK(init_task)。它是系统创建的第一个进程，我们称为 <strong>0号进程</strong> 。这是唯一一个没有通过fork或者kernel_thread产生的进程，是进程列表的第一个。</p>
<h4 id="3-2-初始化中断处理"><a href="#3-2-初始化中断处理" class="headerlink" title="3.2 初始化中断处理"></a>3.2 初始化中断处理</h4><p>对应的函数是trap_init()，里面设置了很多中断门（Interrupt Gate），用于处理各种中断。其中有一个set_system_intr_gate(IA32_SYSCALL_VECTOR, entry_INT80_32)，这是系统调用的中断门。系统调用也是通过发送中断的方式进行的。</p>
<blockquote>
<p>64位的有另外的系统调用方法。</p>
</blockquote>
<h4 id="3-3-初始化内存管理"><a href="#3-3-初始化内存管理" class="headerlink" title="3.3 初始化内存管理"></a>3.3 初始化内存管理</h4><p>对应的，mm_init()就是用来初始化内存管理模块。</p>
<h4 id="3-4-初始化调度模块"><a href="#3-4-初始化调度模块" class="headerlink" title="3.4 初始化调度模块"></a>3.4 初始化调度模块</h4><p>sched_init()就是用于初始化调度模块。</p>
<h4 id="3-5-初始化-rootfs-文件系统"><a href="#3-5-初始化-rootfs-文件系统" class="headerlink" title="3.5 初始化 rootfs 文件系统"></a>3.5 初始化 rootfs 文件系统</h4><p>vfs_caches_init()会用来初始化基于内存的文件系统rootfs。在这个函数里面，会调用mnt_init()-&gt;init_rootfs()。这里面有一行代码，register_filesystem(&amp;rootfs_fs_type)。在VFS虚拟文件系统里面注册了一种类型，我们定义为struct file_system_type rootfs_fs_type。</p>
<h4 id="3-6-其他初始化"><a href="#3-6-其他初始化" class="headerlink" title="3.6 其他初始化"></a>3.6 其他初始化</h4><p>最后，start_kernel()调用的是rest_init()，用来做其他方面的初始化，这里面做了好多的工作。</p>
<h5 id="3-6-1-初始化1号进程"><a href="#3-6-1-初始化1号进程" class="headerlink" title="3.6.1 初始化1号进程"></a>3.6.1 初始化1号进程</h5><p>rest_init的第一大工作是，用kernel_thread(kernel_init, NULL, CLONE_FS)创建第二个进程，这个是 <strong>1号进程</strong> 。</p>
<p>1号进程对于操作系统来讲，有“划时代”的意义。因为它将运行一个用户进程。</p>
<p>x86提供了分层的权限机制，把区域分成了四个Ring，越往里权限越高，越往外权限越低。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/x86提供的分层权限机制.jpg" alt="x86提供的分层权限机制"></p>
<p>操作系统很好地利用了这个机制，将能够访问关键资源的代码放在Ring0，我们称为 <strong>内核态（Kernel Mode）</strong> ；将普通的程序代码放在Ring3，我们称为 <strong>用户态（User Mode）</strong> 。</p>
<ol>
<li><p>从内核态到用户态</p>
<p> 当执行kernel_thread这个函数的时候，系统在内核态。</p>
<p> kernel_thread的参数是一个函数kernel_init，也就是这个进程会运行这个函数。在kernel_init里面，会调用kernel_init_freeable()，里面有这样的代码：</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ramdisk_execute_command<span class="token punctuation">)</span>
    ramdisk_execute_command <span class="token operator">=</span> <span class="token string">"/init"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 先不管ramdisk是啥，我们回到kernel_init里面。这里面有这样的代码块：</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c">    <span class="token keyword">if</span> <span class="token punctuation">(</span>ramdisk_execute_command<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ret <span class="token operator">=</span> <span class="token function">run_init_process</span><span class="token punctuation">(</span>ramdisk_execute_command<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">try_to_run_init_process</span><span class="token punctuation">(</span><span class="token string">"/sbin/init"</span><span class="token punctuation">)</span> <span class="token operator">||</span>
        <span class="token operator">!</span><span class="token function">try_to_run_init_process</span><span class="token punctuation">(</span><span class="token string">"/etc/init"</span><span class="token punctuation">)</span> <span class="token operator">||</span>
        <span class="token operator">!</span><span class="token function">try_to_run_init_process</span><span class="token punctuation">(</span><span class="token string">"/bin/init"</span><span class="token punctuation">)</span> <span class="token operator">||</span>
        <span class="token operator">!</span><span class="token function">try_to_run_init_process</span><span class="token punctuation">(</span><span class="token string">"/bin/sh"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 这就说明，1号进程运行的是一个文件。如果我们打开run_init_process函数，会发现它调用的是do_execve。</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">run_init_process</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>init_filename<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    argv_init<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> init_filename<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">do_execve</span><span class="token punctuation">(</span><span class="token function">getname_kernel</span><span class="token punctuation">(</span>init_filename<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token keyword">const</span> __user <span class="token operator">*</span><span class="token punctuation">)</span>argv_init<span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token keyword">const</span> __user <span class="token operator">*</span><span class="token punctuation">)</span>envp_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> execve是一个系统调用，它的作用是运行一个执行文件。加一个do_的往往是内核系统调用的实现。没错，这就是一个系统调用，它会尝试运行ramdisk的“/init”，或者普通文件系统上的“/sbin/init”“/etc/init”“/bin/init”“/bin/sh”。不同版本的Linux会选择不同的文件启动，但是只要有一个起来了就可以。</p>
</li>
<li><p>如何利用执行init文件的机会，从内核态回到用户态呢？</p>
<p> 从系统调用的过程可以得到启发，“用户态-系统调用-保存寄存器-内核态执行系统调用-恢复寄存器-返回用户态”，然后接着运行。而咱们刚才运行init，是调用do_execve，正是上面的过程的后半部分，从内核态执行系统调用开始。</p>
<p> do_execve-&gt;do_execveat_common-&gt;exec_binprm-&gt;search_binary_handler，这里面会调用这段内容：</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">search_binary_handler</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">linux_binprm</span> <span class="token operator">*</span>bprm<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">struct</span> <span class="token class-name">linux_binfmt</span> <span class="token operator">*</span>fmt<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    retval <span class="token operator">=</span> fmt<span class="token operator">-&gt;</span><span class="token function">load_binary</span><span class="token punctuation">(</span>bprm<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 要运行一个程序，需要加载这个二进制文件，它是有一定格式的。Linux下一个常用的格式是ELF（Executable and Linkable Format，可执行与可链接格式）。于是我们就有了下面这个定义：</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">linux_binfmt</span> elf_format <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>module <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>load_binary <span class="token operator">=</span> load_elf_binary<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>load_shlib <span class="token operator">=</span> load_elf_library<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>core_dump <span class="token operator">=</span> elf_core_dump<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>min_coredump <span class="token operator">=</span> ELF_EXEC_PAGESIZE<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 这其实就是先调用load_elf_binary，最后调用start_thread。</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span>
<span class="token function">start_thread</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span>regs<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> new_ip<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> new_sp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token function">set_user_gs</span><span class="token punctuation">(</span>regs<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
regs<span class="token operator">-&gt;</span>fs    <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
regs<span class="token operator">-&gt;</span>ds    <span class="token operator">=</span> __USER_DS<span class="token punctuation">;</span>
regs<span class="token operator">-&gt;</span>es    <span class="token operator">=</span> __USER_DS<span class="token punctuation">;</span>
regs<span class="token operator">-&gt;</span>ss    <span class="token operator">=</span> __USER_DS<span class="token punctuation">;</span>
regs<span class="token operator">-&gt;</span>cs    <span class="token operator">=</span> __USER_CS<span class="token punctuation">;</span>
regs<span class="token operator">-&gt;</span>ip    <span class="token operator">=</span> new_ip<span class="token punctuation">;</span>
regs<span class="token operator">-&gt;</span>sp    <span class="token operator">=</span> new_sp<span class="token punctuation">;</span>
regs<span class="token operator">-&gt;</span>flags <span class="token operator">=</span> X86_EFLAGS_IF<span class="token punctuation">;</span>
<span class="token function">force_iret</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">EXPORT_SYMBOL_GPL</span><span class="token punctuation">(</span>start_thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> struct pt_regs，看名字里的register，就是寄存器啊！这个结构就是在系统调用的时候，内核中保存用户态运行上下文的，里面将用户态的代码段CS设置为<strong>USER_CS，将用户态的数据段DS设置为</strong>USER_DS，以及指令指针寄存器IP、栈指针寄存器SP。这里相当于补上了原来系统调用里，保存寄存器的一个步骤。</p>
<p> 最后的iret是用于从系统调用中返回。这个时候会恢复寄存器。从哪里恢复呢？按说是从进入系统调用的时候，保存的寄存器里面拿出。好在上面的函数补上了寄存器。CS和指令指针寄存器IP恢复了，指向用户态下一个要执行的语句。DS和函数栈指针SP也被恢复了，指向用户态函数栈的栈顶。所以，下一条指令，就从用户态开始运行了。</p>
</li>
<li><p>ramdisk的作用</p>
<p> init终于从内核到用户态了。一开始到用户态的是ramdisk的init，后来会启动真正根文件系统上的init，成为所有用户态进程的祖先。</p>
<p> 为什么会有ramdisk这个东西呢？内核启动的时候，一般会配置参数：</p>
 <pre class="line-numbers language-text" data-language="text"><code class="language-text">initrd16 /boot/initramfs-3.10.0-862.el7.x86_64.img<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 就是这个东西，这是一个基于内存的文件系统。为啥会有这个呢？</p>
<p> 是因为刚才那个init程序是在文件系统上的，文件系统一定是在一个存储设备上的，例如硬盘。Linux访问存储设备，要有驱动才能访问。如果存储系统数目很有限，那驱动可以直接放到内核里面，反正前面我们加载过内核到内存里了，现在可以直接对存储系统进行访问。</p>
<p> 但是存储系统越来越多了，如果所有市面上的存储系统的驱动都默认放进内核，内核就太大了。这该怎么办呢？</p>
<p> 我们只好先弄一个基于内存的文件系统。内存访问是不需要驱动的，这个就是ramdisk。这个时候，ramdisk是根文件系统。</p>
<p> 然后，我们开始运行ramdisk上的/init。等它运行完了就已经在用户态了。/init这个程序会先根据存储系统的类型加载驱动，有了驱动就可以设置真正的根文件系统了。有了真正的根文件系统，ramdisk上的/init会启动文件系统上的init。</p>
<p> 接下来就是各种系统的初始化。启动系统的服务，启动控制台，用户就可以登录进来了。</p>
<p> 先别忙着高兴，rest_init的第一个大事情才完成。我们仅仅形成了用户态所有进程的祖先。</p>
</li>
</ol>
<h5 id="3-6-2-创建2号进程"><a href="#3-6-2-创建2号进程" class="headerlink" title="3.6.2 创建2号进程"></a>3.6.2 创建2号进程</h5><p>kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES)又一次使用kernel_thread函数创建进程。这里需要指出一点，函数名thread可以翻译成“线程”，这也是操作系统很重要的一个概念。它和进程有什么区别呢？为什么这里创建的是进程，函数名却是线程呢？</p>
<p>从用户态来看，创建进程其实就是立项，也就是启动一个项目。这个项目需要人去执行。有多个人并行执行不同的部分，这就叫 <strong>多线程（Multithreading）</strong> 。如果只有一个人，那它就是这个项目的主线程。</p>
<p>但是从内核态来看，无论是进程，还是线程，我们都可以统称为任务（Task），都使用相同的数据结构，平放在同一个链表中。</p>
<p>这里的函数kthreadd，负责所有内核态的线程的调度和管理，是内核态所有线程运行的祖先。</p>
<h3 id="4-系统调用"><a href="#4-系统调用" class="headerlink" title="4. 系统调用"></a>4. 系统调用</h3><h4 id="4-1-glibc对系统调用的封装"><a href="#4-1-glibc对系统调用的封装" class="headerlink" title="4.1 glibc对系统调用的封装"></a>4.1 glibc对系统调用的封装</h4><p>在glibc的源代码中，有个文件syscalls.list，里面列着所有glibc的函数对应的系统调用，就像下面这个样子：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text"># File name Caller  Syscall name    Args    Strong name Weak names
open        -      open            Ci:siv  __libc_open __open open<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>另外，glibc还有一个脚本make-syscall.sh，可以根据上面的配置文件，对于每一个封装好的系统调用，生成一个文件。这个文件里面定义了一些宏，例如#define SYSCALL_NAME open。</p>
<p>glibc还有一个文件syscall-template.S，使用上面这个宏，定义了这个系统调用的调用方式。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">T_PSEUDO</span> <span class="token punctuation">(</span>SYSCALL_SYMBOL<span class="token punctuation">,</span> SYSCALL_NAME<span class="token punctuation">,</span> SYSCALL_NARGS<span class="token punctuation">)</span>
    ret
<span class="token function">T_PSEUDO_END</span> <span class="token punctuation">(</span>SYSCALL_SYMBOL<span class="token punctuation">)</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">T_PSEUDO</span><span class="token punctuation">(</span>SYMBOL<span class="token punctuation">,</span> NAME<span class="token punctuation">,</span> N<span class="token punctuation">)</span>      <span class="token function">PSEUDO</span> <span class="token punctuation">(</span>SYMBOL<span class="token punctuation">,</span> NAME<span class="token punctuation">,</span> N<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里的PSEUDO也是一个宏，它的定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">PSEUDO</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> syscall_name<span class="token punctuation">,</span> args<span class="token punctuation">)</span>        </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token punctuation">.</span>text<span class="token punctuation">;</span>                                        </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token function">ENTRY</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span>                  </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token function">DO_CALL</span> <span class="token punctuation">(</span>syscall_name<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>            </span><span class="token punctuation">\</span>
    <span class="token expression">cmpl $<span class="token operator">-</span><span class="token number">4095</span><span class="token punctuation">,</span> <span class="token operator">%</span>eax<span class="token punctuation">;</span>              </span><span class="token punctuation">\</span>
    <span class="token expression">jae SYSCALL_ERROR_LABEL</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>里面对于任何一个系统调用，会调用DO_CALL。这也是一个宏，这个宏32位和64位的定义是不一样的。</p>
<h4 id="4-2-32位系统调用过程"><a href="#4-2-32位系统调用过程" class="headerlink" title="4.2 32位系统调用过程"></a>4.2 32位系统调用过程</h4><p>我们先来看32位的情况（i386目录下的sysdep.h文件）。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Linux takes system call arguments in registers:
    syscall number  %eax         call-clobbered
    arg 1         %ebx         call-saved
    arg 2         %ecx         call-clobbered
    arg 3         %edx         call-clobbered
    arg 4         %esi         call-saved
    arg 5         %edi         call-saved
    arg 6         %ebp         call-saved
......
*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">DO_CALL</span><span class="token punctuation">(</span>syscall_name<span class="token punctuation">,</span> args<span class="token punctuation">)</span>     </span><span class="token punctuation">\</span>
    <span class="token expression">PUSHARGS_</span><span class="token punctuation">##</span><span class="token expression">args         </span><span class="token punctuation">\</span>
    <span class="token expression">DOARGS_</span><span class="token punctuation">##</span><span class="token expression">args                           </span><span class="token punctuation">\</span>
    <span class="token expression">movl $<span class="token function">SYS_ify</span> <span class="token punctuation">(</span>syscall_name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>eax<span class="token punctuation">;</span>    </span><span class="token punctuation">\</span>
    <span class="token expression">ENTER_KERNEL                                    </span><span class="token punctuation">\</span>
    <span class="token expression">POPARGS_</span><span class="token punctuation">##</span><span class="token expression">args</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里，我们将请求参数放在寄存器里面，根据系统调用的名称，得到系统调用号，放在寄存器eax里面，然后执行ENTER_KERNEL。</p>
<p>在Linux的源代码注释里面，我们可以清晰地看到，这些寄存器是如何传递系统调用号和参数的。</p>
<p>这里面的ENTER_KERNEL是什么呢？</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span> <span class="token expression">ENTER_KERNEL <span class="token keyword">int</span> $<span class="token number">0x80</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>int就是interrupt，也就是“中断”的意思。int $0x80就是触发一个软中断，通过它就可以陷入（trap）内核。</p>
<p>在内核启动的时候，还记得有一个trap_init()，其中有这样的代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">set_system_intr_gate</span><span class="token punctuation">(</span>IA32_SYSCALL_VECTOR<span class="token punctuation">,</span> entry_INT80_32<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这是一个软中断的陷入门。当接收到一个系统调用的时候，entry_INT80_32就被调用了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">ENTRY</span><span class="token punctuation">(</span>entry_INT80_32<span class="token punctuation">)</span>
        ASM_CLAC
        pushl   <span class="token operator">%</span>eax                    <span class="token comment">/* pt_regs-&gt;orig_ax */</span>
        SAVE_ALL pt_regs_ax<span class="token operator">=</span>$<span class="token operator">-</span>ENOSYS    <span class="token comment">/* save rest */</span>
        movl    <span class="token operator">%</span>esp<span class="token punctuation">,</span> <span class="token operator">%</span>eax
        call    do_syscall_32_irqs_on
<span class="token punctuation">.</span>Lsyscall_32_done<span class="token operator">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">.</span>Lirq_return<span class="token operator">:</span>
    INTERRUPT_RETURN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过push和SAVE_ALL将当前用户态的寄存器，保存在pt_regs结构里面。</p>
<p>进入内核之前，保存所有的寄存器，然后调用do_syscall_32_irqs_on。它的实现如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token function">do_syscall_32_irqs_on</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span>regs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">thread_info</span> <span class="token operator">*</span>ti <span class="token operator">=</span> <span class="token function">current_thread_info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>regs<span class="token operator">-&gt;</span>orig_ax<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>nr <span class="token operator">&lt;</span> IA32_NR_syscalls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        regs<span class="token operator">-&gt;</span>ax <span class="token operator">=</span> ia32_sys_call_table<span class="token punctuation">[</span>nr<span class="token punctuation">]</span><span class="token punctuation">(</span>
            <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>regs<span class="token operator">-&gt;</span>bx<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>regs<span class="token operator">-&gt;</span>cx<span class="token punctuation">,</span>
            <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>regs<span class="token operator">-&gt;</span>dx<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>regs<span class="token operator">-&gt;</span>si<span class="token punctuation">,</span>
            <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>regs<span class="token operator">-&gt;</span>di<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>regs<span class="token operator">-&gt;</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">syscall_return_slowpath</span><span class="token punctuation">(</span>regs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里，我们看到，将系统调用号从eax里面取出来，然后根据系统调用号，在系统调用表中找到相应的函数进行调用，并将寄存器中保存的参数取出来，作为函数参数。如果仔细比对，就能发现，这些参数所对应的寄存器，和Linux的注释是一样的。</p>
<p>根据宏定义，#define ia32_sys_call_table sys_call_table，系统调用就是放在这个表里面。至于这个表是如何形成的，我们后面讲。</p>
<p>当系统调用结束之后，在entry_INT80_32之后，紧接着调用的是INTERRUPT_RETURN，我们能够找到它的定义，也就是iret。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">INTERRUPT_RETURN                iret</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>iret指令将原来用户态保存的现场恢复回来，包含代码段、指令指针寄存器等。这时候用户态进程恢复执行。</p>
<p>这里我总结一下32位的系统调用是如何执行的。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/32位系统调用执行过程.jpg" alt="32位系统调用执行过程"></p>
<h4 id="4-3-64位系统调用过程"><a href="#4-3-64位系统调用过程" class="headerlink" title="4.3 64位系统调用过程"></a>4.3 64位系统调用过程</h4><p>我们再来看64位的情况（x86_64下的sysdep.h文件）。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* The Linux/x86-64 kernel expects the system call parameters in
   registers according to the following table:
    syscall number  rax
    arg 1         rdi
    arg 2         rsi
    arg 3         rdx
    arg 4         r10
    arg 5         r8
    arg 6         r9
......
*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">DO_CALL</span><span class="token punctuation">(</span>syscall_name<span class="token punctuation">,</span> args<span class="token punctuation">)</span>        </span><span class="token punctuation">\</span>
  <span class="token expression">lea <span class="token function">SYS_ify</span> <span class="token punctuation">(</span>syscall_name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>rax<span class="token punctuation">;</span>        </span><span class="token punctuation">\</span>
  <span class="token expression">syscall</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>和之前一样，还是将系统调用名称转换为系统调用号，放到寄存器rax。这里是真正进行调用，不是用中断了，而是改用syscall指令了。并且，通过注释我们也可以知道，传递参数的寄存器也变了。</p>
<p>syscall指令还使用了一种特殊的寄存器，我们叫 <strong>特殊模块寄存器（Model Specific Registers，简称MSR）</strong> 。这种寄存器是CPU为了完成某些特殊控制功能为目的的寄存器，其中就有系统调用。</p>
<p>在系统初始化的时候，trap_init除了初始化上面的中断模式，这里面还会调用cpu_init-&gt;syscall_init。这里面有这样的代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">wrmsrl</span><span class="token punctuation">(</span>MSR_LSTAR<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span>entry_SYSCALL_64<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>rdmsr 和 wrmsr 是用来读写特殊模块寄存器的。MSR_LSTAR就是这样一个特殊的寄存器，当syscall指令调用的时候，会从这个寄存器里面拿出函数地址来调用，也就是调用entry_SYSCALL_64。</p>
<p>在arch/x86/entry/entry_64.S中定义了entry_SYSCALL_64。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">ENTRY</span><span class="token punctuation">(</span>entry_SYSCALL_64<span class="token punctuation">)</span>
    <span class="token comment">/* Construct struct pt_regs on stack */</span>
    pushq   $__USER_DS            <span class="token comment">/* pt_regs-&gt;ss */</span>
    pushq   <span class="token function">PER_CPU_VAR</span><span class="token punctuation">(</span>rsp_scratch<span class="token punctuation">)</span>        <span class="token comment">/* pt_regs-&gt;sp */</span>
    pushq   <span class="token operator">%</span>r11                            <span class="token comment">/* pt_regs-&gt;flags */</span>
    pushq   $__USER_CS            <span class="token comment">/* pt_regs-&gt;cs */</span>
    pushq   <span class="token operator">%</span>rcx                            <span class="token comment">/* pt_regs-&gt;ip */</span>
    pushq   <span class="token operator">%</span>rax                            <span class="token comment">/* pt_regs-&gt;orig_ax */</span>
    pushq   <span class="token operator">%</span>rdi                            <span class="token comment">/* pt_regs-&gt;di */</span>
    pushq   <span class="token operator">%</span>rsi                            <span class="token comment">/* pt_regs-&gt;si */</span>
    pushq   <span class="token operator">%</span>rdx                            <span class="token comment">/* pt_regs-&gt;dx */</span>
    pushq   <span class="token operator">%</span>rcx                            <span class="token comment">/* pt_regs-&gt;cx */</span>
    pushq   $<span class="token operator">-</span>ENOSYS                        <span class="token comment">/* pt_regs-&gt;ax */</span>
    pushq   <span class="token operator">%</span>r8        <span class="token comment">/* pt_regs-&gt;r8 */</span>
    pushq   <span class="token operator">%</span>r9        <span class="token comment">/* pt_regs-&gt;r9 */</span>
    pushq   <span class="token operator">%</span>r10                            <span class="token comment">/* pt_regs-&gt;r10 */</span>
    pushq   <span class="token operator">%</span>r11                            <span class="token comment">/* pt_regs-&gt;r11 */</span>
    sub  $<span class="token punctuation">(</span><span class="token number">6</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>rsp                    <span class="token comment">/* pt_regs-&gt;bp, bx, r12-15 not saved */</span>
    movq    <span class="token function">PER_CPU_VAR</span><span class="token punctuation">(</span>current_task<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>r11
    testl   $_TIF_WORK_SYSCALL_ENTRY<span class="token operator">|</span>_TIF_ALLWORK_MASK<span class="token punctuation">,</span> <span class="token function">TASK_TI_flags</span><span class="token punctuation">(</span><span class="token operator">%</span>r11<span class="token punctuation">)</span>
    jnz  entry_SYSCALL64_slow_path
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
entry_SYSCALL64_slow_path<span class="token operator">:</span>
    <span class="token comment">/* IRQs are off. */</span>
    SAVE_EXTRA_REGS
    movq    <span class="token operator">%</span>rsp<span class="token punctuation">,</span> <span class="token operator">%</span>rdi
    call    do_syscall_64         <span class="token comment">/* returns with IRQs disabled */</span>
return_from_SYSCALL_64<span class="token operator">:</span>
    RESTORE_EXTRA_REGS
    TRACE_IRQS_IRETQ
    movq    <span class="token function">RCX</span><span class="token punctuation">(</span><span class="token operator">%</span>rsp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>rcx
    movq    <span class="token function">RIP</span><span class="token punctuation">(</span><span class="token operator">%</span>rsp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>r11
    movq    <span class="token function">R11</span><span class="token punctuation">(</span><span class="token operator">%</span>rsp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>r11
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
syscall_return_via_sysret<span class="token operator">:</span>
    <span class="token comment">/* rcx and r11 are already restored (see code above) */</span>
    RESTORE_C_REGS_EXCEPT_RCX_R11
    movq    <span class="token function">RSP</span><span class="token punctuation">(</span><span class="token operator">%</span>rsp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>rsp
    USERGS_SYSRET64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里先保存了很多寄存器到pt_regs结构里面，例如用户态的代码段、数据段、保存参数的寄存器，然后调用entry_SYSCALL64_slow_pat-&gt;do_syscall_64。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">__visible <span class="token keyword">void</span> <span class="token function">do_syscall_64</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span>regs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">thread_info</span> <span class="token operator">*</span>ti <span class="token operator">=</span> <span class="token function">current_thread_info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> nr <span class="token operator">=</span> regs<span class="token operator">-&gt;</span>orig_ax<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token punctuation">(</span>nr <span class="token operator">&amp;</span> __SYSCALL_MASK<span class="token punctuation">)</span> <span class="token operator">&lt;</span> NR_syscalls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            regs<span class="token operator">-&gt;</span>ax <span class="token operator">=</span> sys_call_table<span class="token punctuation">[</span>nr <span class="token operator">&amp;</span> __SYSCALL_MASK<span class="token punctuation">]</span><span class="token punctuation">(</span>
                    regs<span class="token operator">-&gt;</span>di<span class="token punctuation">,</span> regs<span class="token operator">-&gt;</span>si<span class="token punctuation">,</span> regs<span class="token operator">-&gt;</span>dx<span class="token punctuation">,</span>
                    regs<span class="token operator">-&gt;</span>r10<span class="token punctuation">,</span> regs<span class="token operator">-&gt;</span>r8<span class="token punctuation">,</span> regs<span class="token operator">-&gt;</span>r9<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">syscall_return_slowpath</span><span class="token punctuation">(</span>regs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在do_syscall_64里面，从rax里面拿出系统调用号，然后根据系统调用号，在系统调用表sys_call_table中找到相应的函数进行调用，并将寄存器中保存的参数取出来，作为函数参数。如果仔细比对，你就能发现，这些参数所对应的寄存器，和Linux的注释又是一样的。</p>
<p>所以，无论是32位，还是64位，都会到系统调用表sys_call_table这里来。</p>
<p>在研究系统调用表之前，我们看64位的系统调用返回的时候，执行的是USERGS_SYSRET64。定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">USERGS_SYSRET64  </span><span class="token punctuation">\</span>
    <span class="token expression">swapgs<span class="token punctuation">;</span>     </span><span class="token punctuation">\</span>
    <span class="token expression">sysretq<span class="token punctuation">;</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这里，返回用户态的指令变成了sysretq。</p>
<p>我们这里总结一下64位的系统调用是如何执行的。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/64位系统调用执行过程.jpg" alt="64位系统调用执行过程"></p>
<h4 id="4-4-系统调用表"><a href="#4-4-系统调用表" class="headerlink" title="4.4 系统调用表"></a>4.4 系统调用表</h4><p>32位的系统调用表定义在面arch/x86/entry/syscalls/syscall_32.tbl文件里。例如open是这样定义的：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">5   i386    open            sys_open  compat_sys_open<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>64位的系统调用定义在另一个文件arch/x86/entry/syscalls/syscall_64.tbl里。例如open是这样定义的：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">2   common  open            sys_open<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>第一列的数字是系统调用号。可以看出，32位和64位的系统调用号是不一样的。第三列是系统调用的名字，第四列是系统调用在内核的实现函数。不过，它们都是以sys_开头。</p>
<p>系统调用在内核中的实现函数要有一个声明。声明往往在include/linux/syscalls.h文件中。例如sys_open是这样声明的：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">asmlinkage <span class="token keyword">long</span> <span class="token function">sys_open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>filename<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> umode_t mode<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>真正的实现这个系统调用，一般在一个.c文件里面，例如sys_open的实现在fs/open.c里面，但是你会发现样子很奇怪。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>open<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> filename<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> flags<span class="token punctuation">,</span> umode_t<span class="token punctuation">,</span> mode<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">force_o_largefile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        flags <span class="token operator">|=</span> O_LARGEFILE<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">do_sys_open</span><span class="token punctuation">(</span>AT_FDCWD<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>SYSCALL_DEFINE3是一个宏系统调用最多六个参数，根据参数的数目选择宏。具体是这样定义的：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">SYSCALL_DEFINE1</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">SYSCALL_DEFINEx</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> _</span><span class="token punctuation">##</span><span class="token expression">name<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">SYSCALL_DEFINE2</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">SYSCALL_DEFINEx</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> _</span><span class="token punctuation">##</span><span class="token expression">name<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">SYSCALL_DEFINEx</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> _</span><span class="token punctuation">##</span><span class="token expression">name<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">SYSCALL_DEFINE4</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">SYSCALL_DEFINEx</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> _</span><span class="token punctuation">##</span><span class="token expression">name<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">SYSCALL_DEFINE5</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">SYSCALL_DEFINEx</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> _</span><span class="token punctuation">##</span><span class="token expression">name<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">SYSCALL_DEFINE6</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">SYSCALL_DEFINEx</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> _</span><span class="token punctuation">##</span><span class="token expression">name<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span>


<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">SYSCALL_DEFINEx</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> sname<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>              </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">SYSCALL_METADATA</span><span class="token punctuation">(</span>sname<span class="token punctuation">,</span> x<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span>     </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">__SYSCALL_DEFINEx</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> sname<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span>


<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">__PROTECT</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">asmlinkage_protect</span><span class="token punctuation">(</span>__VA_ARGS__<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">__SYSCALL_DEFINEx</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>         </span><span class="token punctuation">\</span>
        <span class="token expression">asmlinkage <span class="token keyword">long</span> sys</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_DECL<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span>      </span><span class="token punctuation">\</span>
                <span class="token expression"><span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">alias</span><span class="token punctuation">(</span><span class="token function">__stringify</span><span class="token punctuation">(</span>SyS</span><span class="token punctuation">##</span><span class="token expression">name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">long</span> SYSC</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_DECL<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </span><span class="token punctuation">\</span>
        <span class="token expression">asmlinkage <span class="token keyword">long</span> SyS</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_LONG<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </span><span class="token punctuation">\</span>
        <span class="token expression">asmlinkage <span class="token keyword">long</span> SyS</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_LONG<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span>      </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token punctuation">{</span>                                                </span><span class="token punctuation">\</span>
                <span class="token expression"><span class="token keyword">long</span> ret <span class="token operator">=</span> SYSC</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_CAST<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </span><span class="token punctuation">\</span>
                <span class="token expression"><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_TEST<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">;</span>       </span><span class="token punctuation">\</span>
                <span class="token expression"><span class="token function">__PROTECT</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> ret<span class="token punctuation">,</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_ARGS<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      </span><span class="token punctuation">\</span>
                <span class="token expression"><span class="token keyword">return</span> ret<span class="token punctuation">;</span>            </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token punctuation">}</span>                                                </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">long</span> SYSC</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_DECL<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果我们把宏展开之后，实现如下，和声明的是一样的。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">asmlinkage <span class="token keyword">long</span> <span class="token function">sys_open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span> filename<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> mode<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">long</span> ret<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">force_o_largefile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        flags <span class="token operator">|=</span> O_LARGEFILE<span class="token punctuation">;</span>

    ret <span class="token operator">=</span> <span class="token function">do_sys_open</span><span class="token punctuation">(</span>AT_FDCWD<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">asmlinkage_protect</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> ret<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>声明和实现都好了。接下来，在编译的过程中，需要根据syscall_32.tbl和syscall_64.tbl生成自己的unistd_32.h和unistd_64.h。生成方式在arch/x86/entry/syscalls/Makefile中。</p>
<p>声明和实现都好了。接下来，在编译的过程中，需要根据syscall_32.tbl和syscall_64.tbl生成自己的unistd_32.h和unistd_64.h。生成方式在arch/x86/entry/syscalls/Makefile中。</p>
<p>这里面会使用两个脚本，其中第一个脚本arch/x86/entry/syscalls/syscallhdr.sh，会在文件中生成#define <strong>NR_open；第二个脚本arch/x86/entry/syscalls/syscalltbl.sh，会在文件中生成</strong>SYSCALL(__NR_open, sys_open)。这样，unistd_32.h和unistd_64.h是对应的系统调用号和系统调用实现函数之间的对应关系。</p>
<p>在文件arch/x86/entry/syscall_32.c，定义了这样一个表，里面include了这个头文件，从而所有的sys_系统调用都在这个表里面了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">__visible <span class="token keyword">const</span> sys_call_ptr_t ia32_sys_call_table<span class="token punctuation">[</span>__NR_syscall_compat_max<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">/*
        * Smells like a compiler bug -- it doesn't work
        * when the &amp; below is removed.
        */</span>
    <span class="token punctuation">[</span><span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> __NR_syscall_compat_max<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>sys_ni_syscall<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;asm/syscalls_32.h&gt;</span></span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同理，在文件arch/x86/entry/syscall_64.c，定义了这样一个表，里面include了这个头文件，这样所有的sys_系统调用就都在这个表里面了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* System call table for x86-64. */</span>
asmlinkage <span class="token keyword">const</span> sys_call_ptr_t sys_call_table<span class="token punctuation">[</span>__NR_syscall_max<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">/*
     * Smells like a compiler bug -- it doesn't work
     * when the &amp; below is removed.
     */</span>
    <span class="token punctuation">[</span><span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> __NR_syscall_max<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>sys_ni_syscall<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;asm/syscalls_64.h&gt;</span></span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二、进程管理"><a href="#二、进程管理" class="headerlink" title="二、进程管理"></a>二、进程管理</h2><h3 id="5-进程"><a href="#5-进程" class="headerlink" title="5. 进程"></a>5. 进程</h3><h4 id="5-1-源码编译"><a href="#5-1-源码编译" class="headerlink" title="5.1 源码编译"></a>5.1 源码编译</h4><p>CPU是不能执行文本文件里面的指令的，这些指令只有人能看懂，CPU能够执行的命令是二进制的，比如“0101”这种，所以这些指令还需要翻译一下，这个翻译的过程就是编译（Compile）。</p>
<p>在Linux下面，二进制的程序也要有严格的格式，这个格式我们称为ELF（Executeable and Linkable Format，可执行与可链接格式）。这个格式可以根据编译的结果不同，分为不同的格式。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/从文本文件编译成二进制格式.jpeg" alt="从文本文件编译成二进制格式"></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc -c -fPIC mylib.c
gcc -c -fPIC test_mylib.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ol>
<li><p>可重定位文件<br> 在编译的时候，先做预处理工作，例如将头文件嵌入到正文中，将定义的宏展开，然后就是真正的编译过程，最终编译成为.o文件，这就是ELF的第一种类型，<strong>可重定位文件（Relocatable File）</strong> 。</p>
<p> <img src="/images/《趣谈Linux操作系统》学习笔记/可重定位文件格式.jpg" alt="可重定位文件格式"></p>
<p> ELF文件的头是用于描述整个文件的。这个文件格式在内核中有定义，分别为struct elf32_hdr和struct elf64_hdr。</p>
<p> 接下来来看一个一个的section，也叫节。</p>
<ul>
<li>.text：放编译好的二进制可执行代码</li>
<li>.data：已经初始化好的全局变量</li>
<li>.rodata：只读数据，例如字符串常量、const的变量</li>
<li>.bss：未初始化全局变量，运行时会置0</li>
<li>.symtab：符号表，记录的则是函数和变量</li>
<li><p>.strtab：字符串表、字符串常量和变量名</p>
<p>这些节的元数据信息也需要有一个地方保存，就是最后的节头部表（Section Header Table）。在这个表里面，每一个section都有一项，在代码里面也有定义struct elf32_shdr和struct elf64_shdr。在ELF的头里面，有描述这个文件的节头部表的位置，有多少个表项等等信息。</p>
<p>.o里面的位置是不确定的，但是必须是可重新定位的，因为它将来是要做函数库的。有的section，例如.rel.text, .rel.data就与重定位有关。</p>
<p>要想让代码被重用，不能以.o的形式存在，而是要形成库文件，最简单的类型是静态链接库.a文件（Archives），仅仅将一系列对象文件（.o）归档为一个文件，使用命令ar创建。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ar cr libstatic_mylib.a mylib.o<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>虽然这里libstatic_mylib.a里面只有一个.o，但是实际情况可以有多个.o。当有程序要使用这个静态连接库的时候，会将.o文件提取出来，链接到程序中。</p>
</li>
</ul>
</li>
<li><p>可执行文件</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc -o static_test_mylib test_mylib.o -L. -lstatic_mylib<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 在这个命令里，-L表示在当前目录下找.a文件，-lstatic_mylib会自动补全文件名，比如加前缀lib，后缀.a，变成libstatic_mylib.a，找到这个.a文件后，将里面的mylib.o取出来，和test_mylib.o做一个链接，形成二进制执行文件static_test_mylib。</p>
<p> 形成的二进制文件叫可执行文件，是ELF的第二种格式，格式如下：</p>
<p> <img src="/images/《趣谈Linux操作系统》学习笔记/可执行文件格式.jpg" alt="可执行文件格式"></p>
<p> 这个格式和.o文件大致相似，还是分成一个个的section，并且被节头表描述。只不过这些section是多个.o文件合并过的。但是这个时候，这个文件已经是马上就可以加载到内存里面执行的文件了，因而这些section被分成了需要加载到内存里面的代码段、数据段和不需要加载到内存里面的部分，将小的section合成了大的段segment，并且在最前面加一个段头表（Segment Header Table）。在代码里面的定义为struct elf32_phdr和struct elf64_phdr，这里面除了有对于段的描述之外，最重要的是p_vaddr，这个是这个段加载到内存的虚拟地址。</p>
<p> 在ELF头里面，有一项e_entry，也是个虚拟地址，是这个程序运行的入口。</p>
<p> 静态链接库一旦链接进去，代码和变量的section都合并了，因而程序运行的时候，就不依赖于这个库是否存在。但是这样有一个缺点，就是相同的代码段，如果被多个程序使用的话，在内存里面就有多份，而且一旦静态链接库更新了，如果二进制执行文件不重新编译，也不随着更新。</p>
</li>
<li><p>动态链接库</p>
<p> 因而就出现了另一种，<strong>动态链接库（Shared Libraries）</strong>，不仅仅是一组对象文件的简单归档，而是多个对象文件的重新组合，可被多个程序共享。</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c">gcc <span class="token operator">-</span>shared <span class="token operator">-</span>fPIC <span class="token operator">-</span>o libdynamic_mylib<span class="token punctuation">.</span>so mylib<span class="token punctuation">.</span>o<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 当一个动态链接库被链接到一个程序文件中的时候，最后的程序文件并不包括动态链接库中的代码，而仅仅包括对动态链接库的引用，并且不保存动态链接库的全路径，仅仅保存动态链接库的名称。</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c">gcc <span class="token operator">-</span>o dynamic_test_mylib test_mylib<span class="token punctuation">.</span>o <span class="token operator">-</span>L<span class="token punctuation">.</span> <span class="token operator">-</span>ldynamic_mylib<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 当运行这个程序的时候，首先寻找动态链接库，然后加载它。默认情况下，系统在/lib和/usr/lib文件夹下寻找动态链接库。如果找不到就会报错，我们可以设定LD_LIBRARY_PATH环境变量，程序运行时会在此环境变量指定的文件夹下寻找动态链接库。</p>
<p> 动态链接库，就是ELF的第三种类型， <strong>共享对象文件（Shared Object）</strong> 。</p>
<p> 基于动态连接库创建出来的二进制文件格式还是ELF，但是稍有不同。</p>
<p> 首先，多了一个.interp的Segment，这里面是ld-linux.so，这是动态链接器，也就是说，运行时的链接动作都是它做的。</p>
<p> 另外，ELF文件中还多了两个section，一个是.plt，过程链接表（Procedure Linkage Table，PLT），一个是.got.plt，全局偏移量表（Global Offset Table，GOT）。</p>
<p> 它们是怎么工作的，使得程序运行的时候，可以将so文件动态链接到进程空间的呢？</p>
<p> dynamic_test_mylib这个程序要调用libdynamic_mylib.so里的函数。由于是运行时才去找，编译的时候，压根不知道这个函数在哪里，所以就在PLT里面建立一项PLT[x]。这一项也是一些代码，有点像一个本地的代理，在二进制程序dynamic_test_mylib里面，不直接调用libdynamic_mylib.so里的函数，而是调用PLT[x]里面的代理代码，这个代理代码会在运行的时候找真正的函数。</p>
<p> 去哪里找代理代码呢？这就用到了GOT，这里面也会为libdynamic_mylib.so中的函数创建一项GOT[y]。这一项是运行时libdynamic_mylib.so中的函数在内存中真正的地址。</p>
<p> 如果这个地址在，dynamic_test_mylib调用PLT[x]里面的代理代码，代理代码调用GOT表中对应项GOT[y]，调用的就是加载到内存中的libdynamic_mylib.so里面的对应函数了。</p>
<p> 但是GOT怎么知道的呢？对于libdynamic_mylib.so中的函数，GOT一开始就会创建一项GOT[y]，但是这里面没有真正的地址，因为它也不知道，但是它有办法，它又回调PLT，告诉它，你里面的代理代码来找我要libdynamic_mylib.so中函数的真实地址，我不知道，你想想办法吧。</p>
<p> PLT这个时候会转而调用PLT[0]，也即第一项，PLT[0]转而调用GOT[2]，这里面是ld-linux.so的入口函数，这个函数会找到加载到内存中的libdynamic_mylib.so里面的对应函数的地址，然后把这个地址放在GOT[y]里面。下次，PLT[x]的代理函数就能够直接调用了。</p>
</li>
</ol>
<h4 id="5-2-运行程序为进程"><a href="#5-2-运行程序为进程" class="headerlink" title="5.2 运行程序为进程"></a>5.2 运行程序为进程</h4><p>在内核中，有这样一个数据结构，用来定义加载二进制文件的方法。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">linux_binfmt</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">list_head</span> lh<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">module</span> <span class="token operator">*</span>module<span class="token punctuation">;</span>
        <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>load_binary<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">linux_binprm</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>load_shlib<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>core_dump<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">coredump_params</span> <span class="token operator">*</span>cprm<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> min_coredump<span class="token punctuation">;</span>  <span class="token comment">/* minimal dump size */</span>
<span class="token punctuation">}</span> __randomize_layout<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于ELF文件格式，有对应的实现。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">linux_binfmt</span> elf_format <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span>module   <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>load_binary    <span class="token operator">=</span> load_elf_binary<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>load_shlib  <span class="token operator">=</span> load_elf_library<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>core_dump    <span class="token operator">=</span> elf_core_dump<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>min_coredump   <span class="token operator">=</span> ELF_EXEC_PAGESIZE<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>load_elf_binary是不是你很熟悉？没错，我们加载内核镜像的时候，用的也是这种格式。</p>
<p>还记得当时是谁调用的load_elf_binary函数吗？具体是这样的：do_execve-&gt;do_execveat_common-&gt;exec_binprm-&gt;search_binary_handler。</p>
<p>那do_execve又是被谁调用的呢？我们看下面的代码。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>execve<span class="token punctuation">,</span>
        <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> filename<span class="token punctuation">,</span>
        <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token keyword">const</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> argv<span class="token punctuation">,</span>
        <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token keyword">const</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> envp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">do_execve</span><span class="token punctuation">(</span><span class="token function">getname</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">,</span> argv<span class="token punctuation">,</span> envp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>学过了系统调用一节，你会发现，原理是exec这个系统调用最终调用的load_elf_binary。</p>
<p>exec比较特殊，它是一组函数：</p>
<ul>
<li>包含p的函数（execvp, execlp）会在PATH路径下面寻找程序；</li>
<li>不包含p的函数需要输入程序的全路径；</li>
<li>包含v的函数（execv, execvp, execve）以数组的形式接收参数；</li>
<li>包含l的函数（execl, execlp, execle）以列表的形式接收参数；</li>
<li>包含e的函数（execve, execle）以数组的形式接收环境变量。</li>
</ul>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/exec系列函数.jpg" alt="exec系列函数"></p>
<h4 id="5-3-进程树"><a href="#5-3-进程树" class="headerlink" title="5.3 进程树"></a>5.3 进程树</h4><p>既然所有的进程都是从父进程fork过来的，那总归有一个祖宗进程，这就是咱们系统启动的init进程。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/linux进程树.jpeg" alt="linux进程树"></p>
<p>在解析Linux的启动过程的时候，1号进程是/sbin/init。如果在centOS 7里面，我们ls一下，可以看到，这个进程是被软链接到systemd的。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/sbin/init -<span class="token operator">&gt;</span> <span class="token punctuation">..</span>/lib/systemd/systemd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>系统启动之后，init进程会启动很多的daemon进程，为系统运行提供服务，然后就是启动getty，让用户登录，登录后运行shell，用户启动的进程都是通过shell运行的，从而形成了一棵进程树。</p>
<p>我们可以通过ps -ef命令查看当前系统启动的进程，我们会发现有三类进程。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ps</span> -ef
<span class="token environment constant">UID</span>  PID  <span class="token environment constant">PPID</span>  C STIME TTY        TIME CMD
root         <span class="token number">1</span>   <span class="token number">0</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?  00:00:29 /usr/lib/systemd/systemd --system --deserialize <span class="token number">21</span>
root         <span class="token number">2</span>   <span class="token number">0</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?  00:00:00 <span class="token punctuation">[</span>kthreadd<span class="token punctuation">]</span>
root         <span class="token number">3</span>   <span class="token number">2</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?  00:00:00 <span class="token punctuation">[</span>ksoftirqd/0<span class="token punctuation">]</span>
root         <span class="token number">5</span>   <span class="token number">2</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?  00:00:00 <span class="token punctuation">[</span>kworker/0:0H<span class="token punctuation">]</span>
root         <span class="token number">9</span>   <span class="token number">2</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?  00:00:40 <span class="token punctuation">[</span>rcu_sched<span class="token punctuation">]</span>
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
root       <span class="token number">337</span>   <span class="token number">2</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?  00:00:01 <span class="token punctuation">[</span>kworker/3:1H<span class="token punctuation">]</span>
root       <span class="token number">380</span>   <span class="token number">1</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?  00:00:00 /usr/lib/systemd/systemd-udevd
root       <span class="token number">415</span>   <span class="token number">1</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?  00:00:01 /sbin/auditd
root       <span class="token number">498</span>   <span class="token number">1</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?  00:00:03 /usr/lib/systemd/systemd-logind
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
root       <span class="token number">852</span>   <span class="token number">1</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?  00:06:25 /usr/sbin/rsyslogd -n
root      <span class="token number">2580</span>   <span class="token number">1</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?  00:00:00 /usr/sbin/sshd -D
root     <span class="token number">29058</span>   <span class="token number">2</span>  <span class="token number">0</span> Jan03 ?  00:00:01 <span class="token punctuation">[</span>kworker/1:2<span class="token punctuation">]</span>
root     <span class="token number">29672</span>   <span class="token number">2</span>  <span class="token number">0</span> Jan04 ?  00:00:09 <span class="token punctuation">[</span>kworker/2:1<span class="token punctuation">]</span>
root     <span class="token number">30467</span>   <span class="token number">1</span>  <span class="token number">0</span> Jan06 ?  00:00:00 /usr/sbin/crond -n
root     <span class="token number">31574</span>   <span class="token number">2</span>  <span class="token number">0</span> Jan08 ?  00:00:01 <span class="token punctuation">[</span>kworker/u128:2<span class="token punctuation">]</span>
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
root     <span class="token number">32792</span>  <span class="token number">2580</span>  <span class="token number">0</span> Jan10 ?  00:00:00 sshd: root@pts/0
root     <span class="token number">32794</span> <span class="token number">32792</span>  <span class="token number">0</span> Jan10 pts/0 00:00:00 -bash
root     <span class="token number">32901</span> <span class="token number">32794</span>  <span class="token number">0</span> 00:01 pts/0 00:00:00 <span class="token function">ps</span> -ef<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>你会发现，PID 1的进程就是我们的init进程systemd，PID 2的进程是内核线程kthreadd，这两个我们在内核启动的时候都见过。其中用户态的不带中括号，内核态的带中括号。</p>
<p>接下来进程号依次增大，但是你会看所有带中括号的内核态的进程，祖先都是2号进程。而用户态的进程，祖先都是1号进程。tty那一列，是问号的，说明不是前台启动的，一般都是后台的服务。</p>
<p>pts的父进程是sshd，bash的父进程是pts，ps -ef这个命令的父进程是bash。这样整个链条都比较清晰了。</p>
<h4 id="5-4-总结"><a href="#5-4-总结" class="headerlink" title="5.4 总结"></a>5.4 总结</h4><p>我们首先通过图右边的文件编译过程，生成so文件和可执行文件，放在硬盘上。下图左边的用户态的进程A执行fork，创建进程B，在进程B的处理逻辑中，执行exec系列系统调用。这个系统调用会通过load_elf_binary方法，将刚才生成的可执行文件，加载到进程B的内存中执行。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/进程从代码到二进制到运行的过程.jpeg" alt="进程从代码到二进制到运行的过程"></p>
<h3 id="6-线程"><a href="#6-线程" class="headerlink" title="6. 线程"></a>6. 线程</h3><h4 id="6-1-为什么要有线程？"><a href="#6-1-为什么要有线程？" class="headerlink" title="6.1 为什么要有线程？"></a>6.1 为什么要有线程？</h4><p>对于任何一个进程来讲，即便我们没有主动去创建线程，进程也是默认有一个主线程的。线程是负责执行二进制指令的，一行一行执行下去。进程要比线程管的宽多了，除了执行指令之外，内存、文件系统等等都要它来管。</p>
<p><strong>进程相当于一个项目，而线程就是为了完成项目需求，而建立的一个个开发任务。</strong></p>
<p>使用进程实现并行执行的问题也有两个。第一，创建进程占用资源太多；第二，进程之间的通信需要数据在不同的内存空间传来传去，无法共享。</p>
<h4 id="6-2-如何创建线程？"><a href="#6-2-如何创建线程？" class="headerlink" title="6.2 如何创建线程？"></a>6.2 如何创建线程？</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">NUM_OF_TASKS <span class="token number">5</span></span></span>

<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">downloadfile</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>filename<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am downloading the file %s!\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">long</span> downloadtime <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">100</span><span class="token punctuation">;</span>
   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I finish downloading the file within %d minutes!\n"</span><span class="token punctuation">,</span> downloadtime<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>downloadtime<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token keyword">char</span> files<span class="token punctuation">[</span>NUM_OF_TASKS<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">"file1.avi"</span><span class="token punctuation">,</span><span class="token string">"file2.rmvb"</span><span class="token punctuation">,</span><span class="token string">"file3.mp4"</span><span class="token punctuation">,</span><span class="token string">"file4.wmv"</span><span class="token punctuation">,</span><span class="token string">"file5.flv"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
   pthread_t threads<span class="token punctuation">[</span>NUM_OF_TASKS<span class="token punctuation">]</span><span class="token punctuation">;</span>
   <span class="token keyword">int</span> rc<span class="token punctuation">;</span>
   <span class="token keyword">int</span> t<span class="token punctuation">;</span>
   <span class="token keyword">int</span> downloadtime<span class="token punctuation">;</span>

   pthread_attr_t thread_attr<span class="token punctuation">;</span>
   <span class="token function">pthread_attr_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_attr<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token function">pthread_attr_setdetachstate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_attr<span class="token punctuation">,</span>PTHREAD_CREATE_JOINABL<span class="token punctuation">)</span><span class="token punctuation">;</span>

   <span class="token keyword">for</span><span class="token punctuation">(</span>t<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>t<span class="token operator">&lt;</span>NUM_OF_TASKS<span class="token punctuation">;</span>t<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"creating thread %d, please help me to download %s\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> files<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     rc <span class="token operator">=</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>threads<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>thread_attr<span class="token punctuation">,</span> downloadfile<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>files<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>rc<span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ERROR; return code from pthread_create() is %d\n"</span><span class="token punctuation">,</span> rc<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

   <span class="token function">pthread_attr_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_attr<span class="token punctuation">)</span><span class="token punctuation">;</span>

   <span class="token keyword">for</span><span class="token punctuation">(</span>t<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>t<span class="token operator">&lt;</span>NUM_OF_TASKS<span class="token punctuation">;</span>t<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token function">pthread_join</span><span class="token punctuation">(</span>threads<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>downloadtime<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Thread %d downloads the file %s in %d minutes.\n"</span><span class="token punctuation">,</span>t<span class="token punctuation">,</span>files<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">,</span>downloadtime<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

   <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一个运行中的线程可以调用pthread_exit退出线程。这个函数可以传入一个参数转换为(void *)类型。这是线程退出的返回值。</p>
<p>接下来，我们来看主线程。在这里面，我列了五个文件名。接下来声明了一个数组，里面有五个pthread_t类型的线程对象。</p>
<p>接下来，声明一个线程属性pthread_attr_t。我们通过pthread_attr_init初始化这个属性，并且设置属性PTHREAD_CREATE_JOINABLE。这表示将来主线程程等待这个线程的结束，并获取退出时的状态。</p>
<p>接下来是一个循环。对于每一个文件和每一个线程，可以调用pthread_create创建线程。一共有四个参数，第一个参数是线程对象，第二个参数是线程的属性，第三个参数是线程运行函数，第四个参数是线程运行函数的参数。主线程就是通过第四个参数，将自己的任务派给子线程。</p>
<p>任务分配完毕，每个线程下载一个文件，接下来主线程要做的事情就是等待这些子任务完成。当一个线程退出的时候，就会发送信号给其他所有同进程的线程。有一个线程使用pthread_join获取这个线程退出的返回值。线程的返回值通过pthread_join传给主线程，这样子线程就将自己下载文件所耗费的时间，告诉给主线程。</p>
<p>好了，程序写完了，开始编译。多线程程序要依赖于libpthread.so。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc download.c -lpthread<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>总结一下，一个普通线程的创建和运行过程。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/线程的创建和运行过程.jpg" alt="线程的创建和运行过程"></p>
<h4 id="6-3-线程的数据"><a href="#6-3-线程的数据" class="headerlink" title="6.3 线程的数据"></a>6.3 线程的数据</h4><p>我们把线程访问的数据细分成三类。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/线程访问的数据.jpg" alt="线程访问的数据"></p>
<ol>
<li><p>线程栈上的本地数据</p>
<p> 比如函数执行过程中的局部变量。前面我们说过，函数的调用会使用栈的模型，这在线程里面是一样的。只不过每个线程都有自己的栈空间。</p>
<p> 栈的大小可以通过命令ulimit -a查看，默认情况下线程栈大小为8192（8MB）。我们可以使用命令ulimit -s修改。</p>
<p> 对于线程栈，可以通过下面这个函数pthread_attr_t，修改线程栈的大小。</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pthread_attr_setstacksize</span><span class="token punctuation">(</span>pthread_attr_t <span class="token operator">*</span>attr<span class="token punctuation">,</span> size_t stacksize<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 主线程在内存中有一个栈空间，其他线程栈也拥有独立的栈空间。为了避免线程之间的栈空间踩踏，线程栈之间还会有小块区域，用来隔离保护各自的栈空间。一旦另一个线程踏入到这个隔离区，就会引发段错误。</p>
</li>
<li><p>在整个进程里共享的全局数据</p>
<p> 例如全局变量，虽然在不同进程中是隔离的，但是在一个进程中是共享的。</p>
</li>
<li><p>线程私有数据（Thread Specific Data）</p>
<p> 可以通过以下函数创建：</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pthread_key_create</span><span class="token punctuation">(</span>pthread_key_t <span class="token operator">*</span>key<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>destructor<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 可以看到，创建一个key，伴随着一个析构函数。</p>
<p> key一旦被创建，所有线程都可以访问它，但各线程可根据自己的需要往key中填入不同的值，这就相当于提供了一个同名而不同值的全局变量。</p>
<p> 我们可以通过下面的函数设置key对应的value。</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pthread_setspecific</span><span class="token punctuation">(</span>pthread_key_t key<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>value<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 我们还可以通过下面的函数获取key对应的value。</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">pthread_getspecific</span><span class="token punctuation">(</span>pthread_key_t key<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 而等到线程退出的时候，就会调用析构函数释放value。</p>
</li>
</ol>
<h4 id="6-4-数据的保护"><a href="#6-4-数据的保护" class="headerlink" title="6.4 数据的保护"></a>6.4 数据的保护</h4><p>Mutex，全称Mutual Exclusion，中文叫互斥。顾名思义，有你没我，有我没你。它的模式就是在共享数据访问的时候，去申请加把锁，谁先拿到锁，谁就拿到了访问权限，其他人就只好在门外等着，等这个人访问结束，把锁打开，其他人再去争夺，还是遵循谁先拿到谁访问。</p>
<p>使用Mutex，首先要使用pthread_mutex_init函数初始化这个mutex，初始化后，就可以用它来保护共享变量了。</p>
<p>pthread_mutex_lock() 就是去抢那把锁的函数，如果抢到了，就可以执行下一行程序，对共享变量进行访；如果没抢到，就被阻塞在那里等待。</p>
<p>如果不想被阻塞，可以使用pthread_mutex_trylock去抢那把锁，如果抢到了，就可以执行下一行程序，对共享变量进行访问；如果没抢到，不会被阻塞，而是返回一个错误码。</p>
<p>当共享数据访问结束了，别忘了使用pthread_mutex_unlock释放锁，让给其他人使用，最终调用pthread_mutex_destroy销毁掉这把锁。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/Mutex的使用流程.jpg" alt="Mutex的使用流程"></p>
<p>在使用Mutex的时候，有个问题是如果使用pthread_mutex_lock()，那就需要一直在那里等着。如果是pthread_mutex_trylock()，就可以不用等着，去干点儿别的，但是我怎么知道什么时候回来再试一下，是不是轮到我了呢？能不能在轮到我的时候，通知我一下呢？</p>
<p>这其实就是条件变量，也就是说如果没事儿，就让大家歇着，有事儿了就去通知，别让人家没事儿就来问问，浪费大家的时间。</p>
<p>但是当它接到了通知，来操作共享资源的时候，还是需要抢互斥锁，因为可能很多人都受到了通知，都来访问了，所以 <strong>条件变量和互斥锁是配合使用的</strong> 。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/条件变量和互斥锁配合使用流程.jpeg" alt="条件变量和互斥锁配合使用流程"></p>
<h4 id="6-5-总结"><a href="#6-5-总结" class="headerlink" title="6.5 总结"></a>6.5 总结</h4><p><img src="/images/《趣谈Linux操作系统》学习笔记/多线程总结.png" alt="多线程总结"></p>
<h3 id="7-进程数据结构（上）"><a href="#7-进程数据结构（上）" class="headerlink" title="7. 进程数据结构（上）"></a>7. 进程数据结构（上）</h3><p>在Linux里面，无论是进程，还是线程，到了内核里面，我们统一都叫任务（Task），由一个统一的结构task_struct进行管理。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/Linux中的任务.jpeg" alt="Linux中的任务"></p>
<p>Linux内核有一个链表，将所有的task_struct串起来。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">list_head</span>        tasks<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>接下来，我们来看每一个任务都应该包含哪些字段。</p>
<h4 id="7-1-任务ID"><a href="#7-1-任务ID" class="headerlink" title="7.1 任务ID"></a>7.1 任务ID</h4><p>每一个任务都应该有一个ID，作为这个任务的唯一标识。到时候排期啊、下发任务啊等等，都按ID来，就不会产生歧义。</p>
<p>task_struct里面涉及任务ID的，有下面几个：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">pid_t pid<span class="token punctuation">;</span>
pid_t tgid<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>group_leader<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>你可能觉得奇怪，既然是ID，有一个就足以做唯一标识了，这个怎么看起来这么麻烦？这是因为，上面的进程和线程到了内核这里，统一变成了任务，这就带来两个问题。</p>
<ol>
<li><p>任务展示</p>
<p> 前面我们学习命令行的时候，知道ps命令可以展示出所有的进程。但是如果你是这个命令的实现者，到了内核，按照上面的任务列表把这些命令都显示出来，把所有的线程全都平摊开来显示给用户。用户肯定觉得既复杂又困惑。复杂在于，列表这么长；困惑在于，里面出现了很多并不是自己创建的线程。</p>
</li>
<li><p>给任务下发指令</p>
<p> 可以通过kill来给进程发信号，通知进程退出。如果发给了其中一个线程，我们就不能只退出这个线程，而是应该退出整个进程。当然，有时候，我们希望只给某个线程发信号。</p>
<p> 所以在内核中，它们虽然都是任务，但是应该加以区分。其中，pid是process id，tgid是thread group ID。</p>
<p> 任何一个进程，如果只有主线程，那pid是自己，tgid是自己，group_leader指向的还是自己。</p>
<p> 但是，如果一个进程创建了其他线程，那就会有所变化了。线程有自己的pid，tgid就是进程的主线程的pid，group_leader指向的就是进程的主线程。</p>
<p> 好了，有了tgid，我们就知道tast_struct代表的是一个进程还是代表一个线程了。</p>
</li>
</ol>
<h4 id="7-2-信号处理"><a href="#7-2-信号处理" class="headerlink" title="7.2 信号处理"></a>7.2 信号处理</h4><p>task_struct里面关于信号处理的字段。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Signal handlers: */</span>
<span class="token keyword">struct</span> <span class="token class-name">signal_struct</span>    <span class="token operator">*</span>signal<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">sighand_struct</span>   <span class="token operator">*</span>sighand<span class="token punctuation">;</span>
sigset_t                blocked<span class="token punctuation">;</span>
sigset_t                real_blocked<span class="token punctuation">;</span>
sigset_t                saved_sigmask<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">sigpending</span>      pending<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span>         sas_ss_sp<span class="token punctuation">;</span>
size_t          sas_ss_size<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span>            sas_ss_flags<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里定义了哪些信号被阻塞暂不处理（blocked），哪些信号尚等待处理（pending），哪些信号正在通过信号处理函数进行处理（sighand）。处理的结果可以是忽略，可以是结束进程等等。</p>
<p>信号处理函数默认使用用户态的函数栈，当然也可以开辟新的栈专门用于信号处理，这就是sas_ss_xxx这三个变量的作用。</p>
<p>上面我说了下发信号的时候，需要区分进程和线程。从这里我们其实也能看出一些端倪。</p>
<p>task_struct里面有一个struct sigpending pending。如果我们进入struct signal_struct *signal去看的话，还有一个struct sigpending shared_pending。它们一个是本任务的，一个是线程组共享的。</p>
<h4 id="7-3-任务状态"><a href="#7-3-任务状态" class="headerlink" title="7.3 任务状态"></a>7.3 任务状态</h4><p>在task_struct里面，涉及任务状态的是下面这几个变量：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">volatile</span> <span class="token keyword">long</span> state<span class="token punctuation">;</span>    <span class="token comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span>
<span class="token keyword">int</span> exit_state<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> flags<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>state（状态）可以取的值定义在include/linux/sched.h头文件中。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Used in tsk-&gt;state: */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">TASK_RUNNING                    <span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">TASK_INTERRUPTIBLE        <span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">TASK_UNINTERRUPTIBLE            <span class="token number">2</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">__TASK_STOPPED          <span class="token number">4</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">__TASK_TRACED               <span class="token number">8</span></span></span>
<span class="token comment">/* Used in tsk-&gt;exit_state: */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">EXIT_DEAD                  <span class="token number">16</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">EXIT_ZOMBIE      <span class="token number">32</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">EXIT_TRACE</span>            <span class="token punctuation">(</span>EXIT_ZOMBIE <span class="token operator">|</span> EXIT_DEAD<span class="token punctuation">)</span></span></span>
<span class="token comment">/* Used in tsk-&gt;state again: */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">TASK_DEAD                  <span class="token number">64</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">TASK_WAKEKILL               <span class="token number">128</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">TASK_WAKING      <span class="token number">256</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">TASK_PARKED      <span class="token number">512</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">TASK_NOLOAD      <span class="token number">1024</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">TASK_NEW                        <span class="token number">2048</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">TASK_STATE_MAX          <span class="token number">4096</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从定义的数值很容易看出来，flags是通过bitset的方式设置的也就是说，当前是什么状态，哪一位就置一。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/任务状态.jpeg" alt="任务状态"></p>
<p>TASK_RUNNING并不是说进程正在运行，而是表示进程在时刻准备运行的状态。当处于这个状态的进程获得时间片的时候，就是在运行中；如果没有获得时间片，就说明它被其他进程抢占了，在等待再次分配时间片。</p>
<p>在运行中的进程，一旦要进行一些I/O操作，需要等待I/O完毕，这个时候会释放CPU，进入睡眠状态。</p>
<p>在Linux中，有两种睡眠状态。</p>
<ol>
<li><p>TASK_INTERRUPTIBLE，可中断的睡眠状态。</p>
<p> 这是一种浅睡眠的状态，也就是说，虽然在睡眠，等待I/O完成，但是这个时候一个信号来的时候，进程还是要被唤醒。只不过唤醒后，不是继续刚才的操作，而是进行信号处理。当然程序员可以根据自己的意愿，来写信号处理函数，例如收到某些信号，就放弃等待这个I/O操作完成，直接退出，也可也收到某些信息，继续等待。</p>
</li>
<li><p>TASK_UNINTERRUPTIBLE，不可中断的睡眠状态。</p>
<p> 这是一种深度睡眠状态，不可被信号唤醒，只能死等I/O操作完成。一旦I/O操作因为特殊原因不能完成，这个时候，谁也叫不醒这个进程了。你可能会说，我kill它呢？别忘了，kill本身也是一个信号，既然这个状态不可被信号唤醒，kill信号也被忽略了。除非重启电脑，没有其他办法。</p>
<p> 因此，这其实是一个比较危险的事情，除非程序员极其有把握，不然还是不要设置成TASK_UNINTERRUPTIBLE。</p>
</li>
</ol>
<p>于是，我们就有了一种新的进程睡眠状态，TASK_KILLABLE，可以终止的新睡眠状态。进程处于这种状态中，它的运行原理类似TASK_UNINTERRUPTIBLE，只不过可以响应致命信号。</p>
<p>从定义可以看出，TASK_WAKEKILL用于在接收到致命信号时唤醒进程，而TASK_KILLABLE相当于这两位都设置了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">TASK_KILLABLE</span>         <span class="token punctuation">(</span>TASK_WAKEKILL <span class="token operator">|</span> TASK_UNINTERRUPTIBLE<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>TASK_STOPPED是在进程接收到SIGSTOP、SIGTTIN、SIGTSTP或者SIGTTOU信号之后进入该状态。</p>
<p>TASK_TRACED表示进程被debugger等进程监视，进程执行被调试程序所停止。当一个进程被另外的进程所监视，每一个信号都会让进程进入该状态。</p>
<p>一旦一个进程要结束，先进入的是EXIT_ZOMBIE状态，但是这个时候它的父进程还没有使用wait()等系统调用来获知它的终止信息，此时进程就成了僵尸进程。</p>
<p>EXIT_DEAD是进程的最终状态。</p>
<p>EXIT_ZOMBIE和EXIT_DEAD也可以用于exit_state。</p>
<p>上面的进程状态和进程的运行、调度有关系，还有其他的一些状态，我们称为标志。放在flags字段中，这些字段都被定义称为宏，以PF开头。我这里举几个例子。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">PF_EXITING    <span class="token number">0x00000004</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">PF_VCPU   <span class="token number">0x00000010</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">PF_FORKNOEXEC   <span class="token number">0x00000040</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li><strong>PF_EXITING</strong> 表示正在退出。当有这个flag的时候，在函数find_alive_thread中，找活着的线程，遇到有这个flag的，就直接跳过。</li>
<li><strong>PF_VCPU</strong> 表示进程运行在虚拟CPU上。在函数account_system_time中，统计进程的系统运行时间，如果有这个flag，就调用account_guest_time，按照客户机的时间进行统计。</li>
<li><strong>PF_FORKNOEXEC</strong> 表示fork完了，还没有exec。在_do_fork函数里面调用copy_process，这个时候把flag设置为PF_FORKNOEXEC。当exec中调用了load_elf_binary的时候，又把这个flag去掉。</li>
</ul>
<h4 id="7-4-进程调度"><a href="#7-4-进程调度" class="headerlink" title="7.4 进程调度"></a>7.4 进程调度</h4><p>进程的状态切换往往涉及调度，下面这些字段都是用于调度的。为了让你理解task_struct进程管理的全貌，我先在这里列一下，咱们后面会有单独的章节讲解，这里你只要大概看一下里面的注释就好了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//是否在运行队列上</span>
<span class="token keyword">int</span>       on_rq<span class="token punctuation">;</span>
<span class="token comment">//优先级</span>
<span class="token keyword">int</span>       prio<span class="token punctuation">;</span>
<span class="token keyword">int</span>       static_prio<span class="token punctuation">;</span>
<span class="token keyword">int</span>       normal_prio<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span>                rt_priority<span class="token punctuation">;</span>
<span class="token comment">//调度器类</span>
<span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span>    <span class="token operator">*</span>sched_class<span class="token punctuation">;</span>
<span class="token comment">//调度实体</span>
<span class="token keyword">struct</span> <span class="token class-name">sched_entity</span>   se<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">sched_rt_entity</span>    rt<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">sched_dl_entity</span>    dl<span class="token punctuation">;</span>
<span class="token comment">//调度策略</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span>                policy<span class="token punctuation">;</span>
<span class="token comment">//可以使用哪些CPU</span>
<span class="token keyword">int</span>       nr_cpus_allowed<span class="token punctuation">;</span>
cpumask_t               cpus_allowed<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">sched_info</span>         sched_info<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="7-5-总结"><a href="#7-5-总结" class="headerlink" title="7.5 总结"></a>7.5 总结</h4><p>画一个图总结一下。这个图是进程管理task_struct的的结构图。其中红色的部分是今天讲的部分，你可以对着这张图说出它们的含义。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/进程管理task_struct的结构图（上）.jpeg" alt="进程管理task_struct的结构图（上）"></p>
<h3 id="8-进程数据结构（中）"><a href="#8-进程数据结构（中）" class="headerlink" title="8. 进程数据结构（中）"></a>8. 进程数据结构（中）</h3><h4 id="8-1-运行统计信息"><a href="#8-1-运行统计信息" class="headerlink" title="8.1 运行统计信息"></a>8.1 运行统计信息</h4><p>在进程的运行过程中，会有一些统计量，具体你可以看下面的列表。这里面有进程在用户态和内核态消耗的时间、上下文切换的次数等等。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">u64    utime<span class="token punctuation">;</span><span class="token comment">//用户态消耗的CPU时间</span>
u64    stime<span class="token punctuation">;</span><span class="token comment">//内核态消耗的CPU时间</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span>   nvcsw<span class="token punctuation">;</span><span class="token comment">//自愿(voluntary)上下文切换计数</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span>   nivcsw<span class="token punctuation">;</span><span class="token comment">//非自愿(involuntary)上下文切换计数</span>
u64    start_time<span class="token punctuation">;</span><span class="token comment">//进程启动时间，不包含睡眠时间</span>
u64    real_start_time<span class="token punctuation">;</span><span class="token comment">//进程启动时间，包含睡眠时间</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="8-2-进程亲缘关系"><a href="#8-2-进程亲缘关系" class="headerlink" title="8.2 进程亲缘关系"></a>8.2 进程亲缘关系</h4><p>从我们之前讲的创建进程的过程，可以看出，任何一个进程都有父进程。所以，整个进程其实就是一棵进程树。而拥有同一父进程的所有进程都具有兄弟关系。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> __rcu <span class="token operator">*</span>real_parent<span class="token punctuation">;</span> <span class="token comment">/* real parent process */</span>
<span class="token keyword">struct</span> <span class="token class-name">task_struct</span> __rcu <span class="token operator">*</span>parent<span class="token punctuation">;</span> <span class="token comment">/* recipient of SIGCHLD, wait4() reports */</span>
<span class="token keyword">struct</span> <span class="token class-name">list_head</span> children<span class="token punctuation">;</span>    <span class="token comment">/* list of my children */</span>
<span class="token keyword">struct</span> <span class="token class-name">list_head</span> sibling<span class="token punctuation">;</span>      <span class="token comment">/* linkage in my parent's children list */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>parent指向其父进程。当它终止时，必须向它的父进程发送信号。</li>
<li>children表示链表的头部。链表中的所有元素都是它的子进程。</li>
<li>sibling用于把当前进程插入到兄弟链表中。</li>
</ul>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/进程亲缘关系.jpeg" alt="进程亲缘关系"></p>
<p>通常情况下，real_parent和parent是一样的，但是也会有另外的情况存在。例如，bash创建一个进程，那进程的parent和real_parent就都是bash。如果在bash上使用GDB来debug一个进程，这个时候GDB是real_parent，bash是这个进程的parent。</p>
<h4 id="8-3-进程权限"><a href="#8-3-进程权限" class="headerlink" title="8.3 进程权限"></a>8.3 进程权限</h4><p>在Linux里面，对于进程权限的定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Objective and real subjective task credentials (COW): */</span>
<span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">cred</span> __rcu   <span class="token operator">*</span>real_cred<span class="token punctuation">;</span>
<span class="token comment">/* Effective (overridable) subjective task credentials (COW): */</span>
<span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">cred</span> __rcu   <span class="token operator">*</span>cred<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个结构的注释里，有两个名词比较拗口，Objective和Subjective。事实上，所谓的权限，就是我能操纵谁，谁能操纵我。</p>
<p>“谁能操作我”，很显然，这个时候我就是被操作的对象，就是Objective，那个想操作我的就是Subjective。“我能操作谁”，这个时候我就是Subjective，那个要被我操作的就是Objectvie。</p>
<p>“操作”，就是一个对象对另一个对象进行某些动作。当动作要实施的时候，就要审核权限，当两边的权限匹配上了，就可以实施操作。其中，real_cred就是说明谁能操作我这个进程，而cred就是说明我这个进程能够操作谁。</p>
<p>这里cred的定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">cred</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        kuid_t      uid<span class="token punctuation">;</span>            <span class="token comment">/* real UID of the task */</span>
        kgid_t      gid<span class="token punctuation">;</span>            <span class="token comment">/* real GID of the task */</span>
        kuid_t      suid<span class="token punctuation">;</span>         <span class="token comment">/* saved UID of the task */</span>
        kgid_t      sgid<span class="token punctuation">;</span>         <span class="token comment">/* saved GID of the task */</span>
        kuid_t      euid<span class="token punctuation">;</span>         <span class="token comment">/* effective UID of the task */</span>
        kgid_t      egid<span class="token punctuation">;</span>         <span class="token comment">/* effective GID of the task */</span>
        kuid_t      fsuid<span class="token punctuation">;</span>      <span class="token comment">/* UID for VFS ops */</span>
        kgid_t      fsgid<span class="token punctuation">;</span>      <span class="token comment">/* GID for VFS ops */</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        kernel_cap_t    cap_inheritable<span class="token punctuation">;</span> <span class="token comment">/* caps our children can inherit */</span>
        kernel_cap_t    cap_permitted<span class="token punctuation">;</span>  <span class="token comment">/* caps we're permitted */</span>
        kernel_cap_t    cap_effective<span class="token punctuation">;</span>  <span class="token comment">/* caps we can actually use */</span>
        kernel_cap_t    cap_bset<span class="token punctuation">;</span>      <span class="token comment">/* capability bounding set */</span>
        kernel_cap_t    cap_ambient<span class="token punctuation">;</span>    <span class="token comment">/* Ambient capability set */</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span> __randomize_layout<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从这里的定义可以看出，大部分是关于 <strong>用户和用户所属的用户组信息</strong> 。</p>
<ol>
<li><p>第一个是uid和gid，注释是real user/group id。一般情况下，谁启动的进程，就是谁的ID。但是权限审核的时候，往往不比较这两个，也就是说不大起作用。</p>
</li>
<li><p>第二个是euid和egid，注释是effective user/group id。一看这个名字，就知道这个是起“作用”的。当这个进程要操作消息队列、共享内存、信号量等对象的时候，其实就是在比较这个用户和组是否有权限。</p>
</li>
<li><p>第三个是fsuid和fsgid，也就是filesystem user/group id。这个是对文件操作会审核的权限。</p>
</li>
</ol>
<p>一般说来，fsuid、euid，和uid是一样的，fsgid、egid，和gid也是一样的。因为谁启动的进程，就应该审核启动的用户到底有没有这个权限。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/进程权限举例.jpeg" alt="进程权限举例"></p>
<p>例如，用户A想玩一个游戏，这个游戏的程序是用户B安装的。游戏这个程序文件的权限为rwxr–r—。A是没有权限运行这个程序的，因而用户B要给用户A权限才行。用户B说没问题，都是朋友嘛，于是用户B就给这个程序设定了所有的用户都能执行的权限rwxr-xr-x，说兄弟你玩吧。</p>
<p>于是，用户A就获得了运行这个游戏的权限。当游戏运行起来之后，游戏进程的uid、euid、fsuid都是用户A。看起来没有问题，玩的很开心。</p>
<p>用户A好不容易通过一关，想保存通关数据的时候，发现坏了，这个游戏的玩家数据是保存在另一个文件里面的。这个文件权限rw———-，只给用户B开了写入权限，而游戏进程的euid和fsuid都是用户A，当然写不进去了。完了，这一局白玩儿了。</p>
<p>那怎么解决这个问题呢？我们可以通过chmod u+s program命令，给这个游戏程序设置set-user-ID的标识位，把游戏的权限变成rwsr-xr-x。这个时候，用户A再启动这个游戏的时候，创建的进程uid当然还是用户A，但是euid和fsuid就不是用户A了，因为看到了set-user-id标识，就改为文件的所有者的ID，也就是说，euid和fsuid都改成用户B了，这样就能够将通关结果保存下来。</p>
<p>在Linux里面，一个进程可以随时通过setuid设置用户ID，所以，游戏程序的用户B的ID还会保存在一个地方，这就是suid和sgid，也就是saved uid和save gid。这样就可以很方便地使用setuid，通过设置uid或者suid来改变权限。</p>
<p>除了以用户和用户组控制权限，Linux还有另一个机制就是 <strong>capabilities</strong> 。</p>
<p>原来控制进程的权限，要么是高权限的root用户，要么是一般权限的普通用户，这时候的问题是，root用户权限太大，而普通用户权限太小。有时候一个普通用户想做一点高权限的事情，必须给他整个root的权限。这个太不安全了。</p>
<p>于是，我们引入新的机制capabilities，用位图表示权限，在capability.h可以找到定义的权限。我这里列举几个。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">CAP_CHOWN         <span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">CAP_KILL             <span class="token number">5</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">CAP_NET_BIND_SERVICE <span class="token number">10</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">CAP_NET_RAW    <span class="token number">13</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">CAP_SYS_MODULE     <span class="token number">16</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">CAP_SYS_RAWIO      <span class="token number">17</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">CAP_SYS_BOOT         <span class="token number">22</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">CAP_SYS_TIME         <span class="token number">25</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">CAP_AUDIT_READ     <span class="token number">37</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">CAP_LAST_CAP         CAP_AUDIT_READ</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于普通用户运行的进程，当有这个权限的时候，就能做这些操作；没有的时候，就不能做，这样粒度要小很多。</p>
<p>cap_permitted表示进程能够使用的权限。但是真正起作用的是cap_effective。cap_permitted中可以包含cap_effective中没有的权限。一个进程可以在必要的时候，放弃自己的某些权限，这样更加安全。假设自己因为代码漏洞被攻破了，但是如果啥也干不了，就没办法进一步突破。</p>
<p>cap_inheritable表示当可执行文件的扩展属性设置了inheritable位时，调用exec执行该程序会继承调用者的inheritable集合，并将其加入到permitted集合。但在非root用户下执行exec时，通常不会保留inheritable集合，但是往往又是非root用户，才想保留权限，所以非常鸡肋。</p>
<p>cap_bset，也就是capability bounding set，是系统中所有进程允许保留的权限。如果这个集合中不存在某个权限，那么系统中的所有进程都没有这个权限。即使以超级用户权限执行的进程，也是一样的。</p>
<p>这样有很多好处。例如，系统启动以后，将加载内核模块的权限去掉，那所有进程都不能加载内核模块。这样，即便这台机器被攻破，也做不了太多有害的事情。</p>
<p>cap_ambient是比较新加入内核的，就是为了解决cap_inheritable鸡肋的状况，也就是，非root用户进程使用exec执行一个程序的时候，如何保留权限的问题。当执行exec的时候，cap_ambient会被添加到cap_permitted中，同时设置到cap_effective中。</p>
<h4 id="8-4-内存管理"><a href="#8-4-内存管理" class="headerlink" title="8.4 内存管理"></a>8.4 内存管理</h4><p>每个进程都有自己独立的虚拟内存空间，这需要有一个数据结构来表示，就是mm_struct。这个我们在内存管理那一节详细讲述。这里你先有个印象。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">mm_struct</span>                <span class="token operator">*</span>mm<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">mm_struct</span>                <span class="token operator">*</span>active_mm<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h4 id="8-5-文件与文件系统"><a href="#8-5-文件与文件系统" class="headerlink" title="8.5 文件与文件系统"></a>8.5 文件与文件系统</h4><p>每个进程有一个文件系统的数据结构，还有一个打开文件的数据结构。这个我们放到文件系统那一节详细讲述。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Filesystem information: */</span>
<span class="token keyword">struct</span> <span class="token class-name">fs_struct</span>                <span class="token operator">*</span>fs<span class="token punctuation">;</span>
<span class="token comment">/* Open file information: */</span>
<span class="token keyword">struct</span> <span class="token class-name">files_struct</span>    <span class="token operator">*</span>files<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="8-6-总结"><a href="#8-6-总结" class="headerlink" title="8.6 总结"></a>8.6 总结</h4><p>这一节，我们终于把进程管理复杂的数据结构基本讲完了，请你重点记住以下两点：</p>
<ul>
<li>进程亲缘关系维护的数据结构，是一种很有参考价值的实现方式，在内核中会多个地方出现类似的结构；</li>
<li>进程权限中setuid的原理，这一点比较难理解，但是很重要，面试经常会考。</li>
</ul>
<p>你可以对着下面这张图，看看自己是否真的理解了，进程树是如何组织的，以及如何控制进程的权限的。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/进程管理task_struct的结构图（中）.jpeg" alt="进程管理task_struct的结构图（中）"></p>
<h3 id="9-进程数据结构（下）"><a href="#9-进程数据结构（下）" class="headerlink" title="9. 进程数据结构（下）"></a>9. 进程数据结构（下）</h3><p>在程序执行过程中，一旦调用到系统调用，就需要进入内核继续执行。那如何将用户态的执行和内核态的执行串起来呢？</p>
<p>这就需要以下两个重要的成员变量：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">thread_info</span>  thread_info<span class="token punctuation">;</span>
<span class="token keyword">void</span>                <span class="token operator">*</span>stack<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h4 id="9-1-用户态函数栈"><a href="#9-1-用户态函数栈" class="headerlink" title="9.1 用户态函数栈"></a>9.1 用户态函数栈</h4><p>在用户态中，程序的执行往往是一个函数调用另一个函数。函数调用都是通过栈来进行的。</p>
<p>在进程的内存空间里面，栈是一个从高地址到低地址，往下增长的结构，也就是上面是栈底，下面是栈顶，入栈和出栈的操作都是从下面的栈顶开始的。</p>
<blockquote>
<p>以下栈操作，都是在进程的内存空间里面进行的。</p>
</blockquote>
<h5 id="9-1-1-32位操作系统"><a href="#9-1-1-32位操作系统" class="headerlink" title="9.1.1 32位操作系统"></a>9.1.1 32位操作系统</h5><p><img src="/images/《趣谈Linux操作系统》学习笔记/32位操作系统用户态函数栈.jpg" alt="32位操作系统用户态函数栈"></p>
<p>在CPU里，ESP（Extended Stack Pointer）是栈顶指针寄存器，入栈操作Push和出栈操作Pop指令，会自动调整ESP的值。另外有一个寄存器EBP（Extended Base Pointer），是栈基地址指针寄存器，指向当前栈帧的最底部。</p>
<p>例如，A调用B，A的栈里面包含A函数的局部变量，然后是调用B的时候要传给它的参数，然后返回A的地址，这个地址也应该入栈，这就形成了A的栈帧。接下来就是B的栈帧部分了，先保存的是A栈帧的栈底位置，也就是EBP。因为在B函数里面获取A传进来的参数，就是通过这个指针获取的，接下来保存的是B的局部变量等等。</p>
<p>当B返回的时候，返回值会保存在EAX寄存器中，从栈中弹出返回地址，将指令跳转回去，参数也从栈中弹出，然后继续执行A。</p>
<h5 id="9-1-2-64位操作系统"><a href="#9-1-2-64位操作系统" class="headerlink" title="9.1.2 64位操作系统"></a>9.1.2 64位操作系统</h5><p>对于64位操作系统，模式多少有些不一样。因为64位操作系统的寄存器数目比较多。rax用于保存函数调用的返回结果。栈顶指针寄存器变成了rsp，指向栈顶位置。堆栈的Pop和Push操作会自动调整rsp，栈基指针寄存器变成了rbp，指向当前栈帧的起始位置。</p>
<p>改变比较多的是参数传递。rdi、rsi、rdx、rcx、r8、r9这6个寄存器，用于传递存储函数调用时的6个参数。如果超过6的时候，还是需要放到栈里面。</p>
<p>然而，前6个参数有时候需要进行寻址，但是如果在寄存器里面，是没有地址的，因而还是会放到栈里面，只不过放到栈里面的操作是被调用函数做的。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/64位操作系统用户态函数栈.jpg" alt="64位操作系统用户态函数栈"></p>
<h4 id="9-2-内核态函数栈"><a href="#9-2-内核态函数栈" class="headerlink" title="9.2 内核态函数栈"></a>9.2 内核态函数栈</h4><p>接下来，我们通过系统调用，从进程的内存空间到内核中了。内核中也有各种各样的函数调用来调用去的，也需要这样一个机制，这该怎么办呢？</p>
<p>这时候，上面的成员变量stack，也就是内核栈，就派上了用场。</p>
<p>Linux给每个task都分配了内核栈。在32位系统上arch/x86/include/asm/page_32_types.h，是这样定义的：一个PAGE_SIZE是4K，左移一位就是乘以2，也就是8K。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">THREAD_SIZE_ORDER   <span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">THREAD_SIZE</span>   <span class="token punctuation">(</span>PAGE_SIZE <span class="token operator">&lt;&lt;</span> THREAD_SIZE_ORDER<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>内核栈在64位系统上arch/x86/include/asm/page_64_types.h，是这样定义的：在PAGE_SIZE的基础上左移两位，也即16K，并且要求起始地址必须是8192的整数倍。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_KASAN</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">KASAN_STACK_ORDER <span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">KASAN_STACK_ORDER <span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">THREAD_SIZE_ORDER</span>   <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">+</span> KASAN_STACK_ORDER<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">THREAD_SIZE</span>   <span class="token punctuation">(</span>PAGE_SIZE <span class="token operator">&lt;&lt;</span> THREAD_SIZE_ORDER<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>内核栈是一个非常特殊的结构，如下图所示：</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/内核栈结构.jpeg" alt="内核栈结构"></p>
<p>这段空间的最低位置，是一个thread_info结构。这个结构是对task_struct结构的补充。因为task_struct结构庞大但是通用，不同的体系结构就需要保存不同的东西，所以往往与体系结构有关的，都放在thread_info里面。</p>
<p>在内核代码里面有这样一个union，将thread_info和stack放在一起，在include/linux/sched.h文件中就有。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">union</span> thread_union <span class="token punctuation">{</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">CONFIG_THREAD_INFO_IN_TASK</span></span>
    <span class="token keyword">struct</span> <span class="token class-name">thread_info</span> thread_info<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> stack<span class="token punctuation">[</span>THREAD_SIZE<span class="token operator">/</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个union就是这样定义的，开头是thread_info，后面是stack。</p>
<p>在内核栈的最高地址端，存放的是另一个结构pt_regs，定义如下。其中，32位和64位的定义不一样。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__i386__</span></span>
<span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> bx<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> cx<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> dx<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> si<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> di<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> bp<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ax<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ds<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> es<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> fs<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> gs<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> orig_ax<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ip<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> cs<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sp<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ss<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
<span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> r15<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> r14<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> r13<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> r12<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> bp<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> bx<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> r11<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> r10<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> r9<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> r8<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ax<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> cx<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> dx<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> si<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> di<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> orig_ax<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ip<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> cs<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sp<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ss<span class="token punctuation">;</span>
<span class="token comment">/* top of stack page */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当系统调用从用户态到内核态的时候，首先要做的第一件事情，就是将用户态运行过程中的CPU上下文保存起来，其实主要就是保存在这个结构的寄存器变量里。这样当从内核系统调用返回的时候，才能让进程在刚才的地方接着运行下去。</p>
<p>如果我们对比系统调用那一节的内容，你会发现系统调用的时候，压栈的值的顺序和struct pt_regs中寄存器定义的顺序是一样的。</p>
<p>在内核中，CPU的寄存器ESP或者RSP，已经指向内核栈的栈顶，在内核态里的调用都有和用户态相似的过程。</p>
<h4 id="9-3-通过task-struct找内核栈"><a href="#9-3-通过task-struct找内核栈" class="headerlink" title="9.3 通过task_struct找内核栈"></a>9.3 通过task_struct找内核栈</h4><p>如果有一个task_struct的stack指针在手，你可以通过下面的函数找到这个线程内核栈：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">task_stack_page</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>task<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> task<span class="token operator">-&gt;</span>stack<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>从task_struct如何得到相应的pt_regs呢？我们可以通过下面的函数：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * TOP_OF_KERNEL_STACK_PADDING reserves 8 bytes on top of the ring0 stack.
 * This is necessary to guarantee that the entire "struct pt_regs"
 * is accessible even if the CPU haven't stored the SS/ESP registers
 * on the stack (interrupt gate does not save these registers
 * when switching to the same priv ring).
 * Therefore beware: accessing the ss/esp fields of the
 * "struct pt_regs" is possible, but they may contain the
 * completely wrong values.
 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">task_pt_regs</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span>                    </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">{</span>                                </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">unsigned</span> <span class="token keyword">long</span> __ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token function">task_stack_page</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span> </span><span class="token punctuation">\</span>
    <span class="token expression">__ptr <span class="token operator">+=</span> THREAD_SIZE <span class="token operator">-</span> TOP_OF_KERNEL_STACK_PADDING<span class="token punctuation">;</span>   </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span><span class="token punctuation">)</span>__ptr<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">}</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>你会发现，这是先从task_struct找到内核栈的开始位置。然后这个位置加上THREAD_SIZE就到了最后的位置，然后转换为struct pt_regs，再减一，就相当于减少了一个pt_regs的位置，就到了这个结构的首地址。</p>
<p>这里面有一个TOP_OF_KERNEL_STACK_PADDING，这个的定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_X86_32</span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_VM86</span></span>
<span class="token macro property"><span class="token directive-hash">#</span>  <span class="token directive keyword">define</span> <span class="token expression">TOP_OF_KERNEL_STACK_PADDING <span class="token number">16</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">else</span></span>
<span class="token macro property"><span class="token directive-hash">#</span>  <span class="token directive keyword">define</span> <span class="token expression">TOP_OF_KERNEL_STACK_PADDING <span class="token number">8</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span> <span class="token expression">TOP_OF_KERNEL_STACK_PADDING <span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也就是说，32位机器上是8，其他是0。这是为什么呢？因为压栈pt_regs有两种情况。我们知道，CPU用ring来区分权限，从而Linux可以区分内核态和用户态。</p>
<p>因此，第一种情况，我们拿涉及从用户态到内核态的变化的系统调用来说。因为涉及权限的改变，会压栈保存SS、ESP寄存器的，这两个寄存器共占用8个byte。</p>
<p>另一种情况是，不涉及权限的变化，就不会压栈这8个byte。这样就会使得两种情况不兼容。如果没有压栈还访问，就会报错，所以还不如预留在这里，保证安全。在64位上，修改了这个问题，变成了定长的。</p>
<p>好了，现在如果你task_struct在手，就能够轻松得到内核栈和内核寄存器。</p>
<h4 id="9-4-通过内核栈找task-struct"><a href="#9-4-通过内核栈找task-struct" class="headerlink" title="9.4 通过内核栈找task_struct"></a>9.4 通过内核栈找task_struct</h4><p>那如果一个当前在某个CPU上执行的进程，想知道自己的task_struct在哪里，又该怎么办呢？</p>
<p>这个艰巨的任务要交给thread_info这个结构。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">thread_info</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span>  <span class="token operator">*</span>task<span class="token punctuation">;</span>    <span class="token comment">/* main task structure */</span>
    __u32            flags<span class="token punctuation">;</span>    <span class="token comment">/* low level flags */</span>
    __u32            status<span class="token punctuation">;</span>  <span class="token comment">/* thread synchronous flags */</span>
    __u32            cpu<span class="token punctuation">;</span>        <span class="token comment">/* current CPU */</span>
    mm_segment_t        addr_limit<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        sig_on_uaccess_error<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        uaccess_err<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">/* uaccess failed */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面有个成员变量task指向task_struct，所以我们常用current_thread_info()-&gt;task来获取task_struct。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">thread_info</span> <span class="token operator">*</span><span class="token function">current_thread_info</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">thread_info</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">current_top_of_stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> THREAD_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>而thread_info的位置就是内核栈的最高位置，减去THREAD_SIZE，就到了thread_info的起始地址。</p>
<p>但是现在变成这样了，只剩下一个flags。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">thread_info</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>      flags<span class="token punctuation">;</span>    <span class="token comment">/* low level flags */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>那这时候怎么获取当前运行中的task_struct呢？current_thread_info有了新的实现方式。</p>
<p>在include/linux/thread_info.h中定义了current_thread_info。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;asm/current.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">current_thread_info</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">thread_info</span> <span class="token operator">*</span><span class="token punctuation">)</span>current<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>那current又是什么呢？在arch/x86/include/asm/current.h中定义了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token punctuation">;</span>

<span class="token function">DECLARE_PER_CPU</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token punctuation">,</span> current_task<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> __always_inline <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token function">get_current</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">this_cpu_read_stable</span><span class="token punctuation">(</span>current_task<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">current get_current</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>到这里，你会发现，新的机制里面，每个CPU运行的task_struct不通过thread_info获取了，而是直接放在Per CPU 变量里面了。</p>
<p>多核情况下，CPU是同时运行的，但是它们共同使用其他的硬件资源的时候，我们需要解决多个CPU之间的同步问题。</p>
<p>Per CPU变量是内核中一种重要的同步机制。顾名思义，Per CPU变量就是为每个CPU构造一个变量的副本，这样多个CPU各自操作自己的副本，互不干涉。比如，当前进程的变量current_task就被声明为Per CPU变量。</p>
<p>要使用Per CPU变量，首先要声明这个变量，在arch/x86/include/asm/current.h中有：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">DECLARE_PER_CPU</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token punctuation">,</span> current_task<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后是定义这个变量，在arch/x86/kernel/cpu/common.c中有：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">DEFINE_PER_CPU</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token punctuation">,</span> current_task<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>init_task<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>也就是说，系统刚刚初始化的时候，current_task都指向init_task。</p>
<p>当某个CPU上的进程进行切换的时候，current_task被修改为将要切换到的目标进程。例如，进程切换函数__switch_to就会改变current_task。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">__visible __notrace_funcgraph <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>
<span class="token function">__switch_to</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev_p<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>next_p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">this_cpu_write</span><span class="token punctuation">(</span>current_task<span class="token punctuation">,</span> next_p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> prev_p<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当要获取当前的运行中的task_struct的时候，就需要调用this_cpu_read_stable进行读取。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">this_cpu_read_stable</span><span class="token punctuation">(</span>var<span class="token punctuation">)</span>      <span class="token function">percpu_stable_op</span><span class="token punctuation">(</span></span><span class="token string">"mov"</span><span class="token expression"><span class="token punctuation">,</span> var<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>好了，现在如果你是一个进程，正在某个CPU上运行，就能够轻松得到task_struct了。</p>
<h4 id="9-5-总结"><a href="#9-5-总结" class="headerlink" title="9.5 总结"></a>9.5 总结</h4><p>这一节虽然只介绍了内核栈，但是内容更加重要。如果说task_struct的其他成员变量都是和进程管理有关的，内核栈是和进程运行有关系的。</p>
<p>我这里画了一张图总结一下32位和64位的工作模式，左边是32位的，右边是64位的。</p>
<ul>
<li>在用户态，应用程序进行了至少一次函数调用。32位和64的传递参数的方式稍有不同，32位的就是用函数栈，64位的前6个参数用寄存器，其他的用函数栈。</li>
<li>在内核态，32位和64位都使用内核栈，格式也稍有不同，主要集中在pt_regs结构上。</li>
<li>在内核态，32位和64位的内核栈和task_struct的关联关系不同。32位主要靠thread_info，64位主要靠Per-CPU变量。</li>
</ul>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/32位和64位函数栈.jpeg" alt="32位和64位函数栈"></p>
<h3 id="10-调度（上）"><a href="#10-调度（上）" class="headerlink" title="10. 调度（上）"></a>10. 调度（上）</h3><p>对于操作系统来讲，它面对的CPU的数量是有限的，干活儿都是它们，但是进程数目远远超过CPU的数目，因而就需要进行进程的调度，有效地分配CPU的时间，既要保证进程的最快响应，也要保证进程之间的公平。这也是一个非常复杂的、需要平衡的事情。</p>
<h4 id="10-1-调度策略与调度类"><a href="#10-1-调度策略与调度类" class="headerlink" title="10.1 调度策略与调度类"></a>10.1 调度策略与调度类</h4><p>在Linux里面，进程大概可以分成两种。</p>
<p>一种称为 <strong>实时进程</strong> ，也就是需要尽快执行返回结果的那种。<br>另一种是 <strong>普通进程</strong> ，大部分的进程其实都是这种。</p>
<p>对于这两种进程，我们的调度策略肯定是不同的。</p>
<p>在task_struct中，有一个成员变量，我们叫调度策略。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> policy<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>它有以下几个定义：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">SCHED_NORMAL        <span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">SCHED_FIFO          <span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">SCHED_RR            <span class="token number">2</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">SCHED_BATCH         <span class="token number">3</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">SCHED_IDLE          <span class="token number">5</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">SCHED_DEADLINE      <span class="token number">6</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>配合调度策略的，还有我们刚才说的优先级，也在task_struct中。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> prio<span class="token punctuation">,</span> static_prio<span class="token punctuation">,</span> normal_prio<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> rt_priority<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>优先级其实就是一个数值，对于实时进程，优先级的范围是0～99；对于普通进程，优先级的范围是100～139。数值越小，优先级越高。从这里可以看出，所有的实时进程都比普通进程优先级要高。</p>
<h4 id="10-2-实时调度策略"><a href="#10-2-实时调度策略" class="headerlink" title="10.2 实时调度策略"></a>10.2 实时调度策略</h4><p>对于调度策略，其中SCHED_FIFO、SCHED_RR、SCHED_DEADLINE是实时进程的调度策略。</p>
<ul>
<li><strong>SCHED_FIFO</strong> 就是先来先服务，可以分配更高的优先级，也就是说，高优先级的进程可以抢占低优先级的进程，而相同优先级的进程，我们遵循先来先得。</li>
<li><strong>SCHED_RR</strong> 轮流调度算法。采用时间片，相同优先级的任务当用完时间片会被放到队列尾部，以保证公平性，而高优先级的任务也是可以抢占低优先级的任务。</li>
<li><strong>SCHED_DEADLINE</strong> 按照任务的deadline进行调度的。当产生一个调度点的时候，DL调度器总是选择其deadline距离当前时间点最近的那个任务，并调度它执行。</li>
</ul>
<h4 id="10-3-普通调度策略"><a href="#10-3-普通调度策略" class="headerlink" title="10.3 普通调度策略"></a>10.3 普通调度策略</h4><p>对于普通进程的调度策略有，SCHED_NORMAL、SCHED_BATCH、SCHED_IDLE。</p>
<ul>
<li><strong>SCHED_NORMAL</strong> 是普通的进程。</li>
<li><strong>SCHED_BATCH</strong> 是后台进程，几乎不需要和前端进行交互。不要影响需要交互的进程，可以降低他的优先级。</li>
<li><strong>SCHED_IDLE</strong> 是特别空闲的时候才跑的进程。</li>
</ul>
<p>上面无论是policy还是priority，都设置了一个变量，变量仅仅表示了应该这样这样干，但事情总要有人去干，谁呢？在task_struct里面，还有这样的成员变量：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> <span class="token operator">*</span>sched_class<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>调度策略的执行逻辑，就封装在这里面，它是真正干活的那个。</p>
<p>sched_class有几种实现：</p>
<ul>
<li>stop_sched_class 优先级最高的任务会使用这种策略，会中断所有其他线程，且不会被其他任务打断；</li>
<li>dl_sched_class就对应上面的deadline调度策略；</li>
<li>rt_sched_class就对应RR算法或者FIFO算法的调度策略，具体调度策略由进程的task_struct-&gt;policy指定；</li>
<li>fair_sched_class就是普通进程的调度策略；</li>
<li>idle_sched_class就是空闲进程的调度策略。</li>
</ul>
<p>这里实时进程的调度策略RR和FIFO相对简单一些，而且由于咱们平时常遇到的都是普通进程，在这里，咱们就重点分析普通进程的调度问题。普通进程使用的调度策略是fair_sched_class，顾名思义，对于普通进程来讲，公平是最重要的。</p>
<h4 id="10-4-完全公平调度算法"><a href="#10-4-完全公平调度算法" class="headerlink" title="10.4 完全公平调度算法"></a>10.4 完全公平调度算法</h4><p>在Linux里面，实现了一个基于CFS的调度算法。CFS全称Completely Fair Scheduling，叫完全公平调度。听起来很“公平”。那这个算法的原理是什么呢？我们来看看。</p>
<p>首先，你需要记录下进程的运行时间。CPU会提供一个时钟，过一段时间就触发一个时钟中断。就像咱们的表滴答一下，这个我们叫Tick。CFS会为每一个进程安排一个虚拟运行时间vruntime。如果一个进程在运行，随着时间的增长，也就是一个个tick的到来，进程的vruntime将不断增大。没有得到执行的进程vruntime不变。</p>
<p>显然，那些vruntime少的，原来受到了不公平的对待，需要给它补上，所以会优先运行这样的进程。</p>
<p>这有点像让你把一筐球平均分到N个口袋里面，你看着哪个少，就多放一些；哪个多了，就先不放。这样经过多轮，虽然不能保证球完全一样多，但是也差不多公平。</p>
<p>你可能会说，不还有优先级呢？如何给优先级高的进程多分时间呢？</p>
<p>这个简单，就相当于N个口袋，优先级高的袋子大，优先级低的袋子小。这样球就不能按照个数分配了，要按照比例来，大口袋的放了一半和小口袋放了一半，里面的球数目虽然差很多，也认为是公平的。</p>
<p>在更新进程运行的统计量的时候，我们其实就可以看出这个逻辑。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * Update the current task's runtime statistics.
 */</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">update_curr</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>curr <span class="token operator">=</span> cfs_rq<span class="token operator">-&gt;</span>curr<span class="token punctuation">;</span>
    u64 now <span class="token operator">=</span> <span class="token function">rq_clock_task</span><span class="token punctuation">(</span><span class="token function">rq_of</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    u64 delta_exec<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    delta_exec <span class="token operator">=</span> now <span class="token operator">-</span> curr<span class="token operator">-&gt;</span>exec_start<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    curr<span class="token operator">-&gt;</span>exec_start <span class="token operator">=</span> now<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    curr<span class="token operator">-&gt;</span>sum_exec_runtime <span class="token operator">+=</span> delta_exec<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    curr<span class="token operator">-&gt;</span>vruntime <span class="token operator">+=</span> <span class="token function">calc_delta_fair</span><span class="token punctuation">(</span>delta_exec<span class="token punctuation">,</span> curr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">update_min_vruntime</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token comment">/*
 * delta /= w
 */</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> u64 <span class="token function">calc_delta_fair</span><span class="token punctuation">(</span>u64 delta<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>se<span class="token operator">-&gt;</span>load<span class="token punctuation">.</span>weight <span class="token operator">!=</span> NICE_0_LOAD<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment">/* delta_exec * weight / lw.weight */</span>
        delta <span class="token operator">=</span> <span class="token function">__calc_delta</span><span class="token punctuation">(</span>delta<span class="token punctuation">,</span> NICE_0_LOAD<span class="token punctuation">,</span> <span class="token operator">&amp;</span>se<span class="token operator">-&gt;</span>load<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> delta<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里得到当前的时间，以及这次的时间片开始的时间，两者相减就是这次运行的时间delta_exec ，但是得到的这个时间其实是实际运行的时间，需要做一定的转化才作为虚拟运行时间vruntime。转化方法如下：</p>
<p><code>虚拟运行时间vruntime += 实际运行时间delta_exec * NICE_0_LOAD/权重</code></p>
<p>这就是说，同样的实际运行时间，给高权重的算少了，低权重的算多了，但是当选取下一个运行进程的时候，还是按照最小的vruntime来的，这样高权重的获得的实际运行时间自然就多了。这就相当于给一个体重(权重)200斤的胖子吃两个馒头，和给一个体重100斤的瘦子吃一个馒头，然后说，你们两个吃的是一样多。这样虽然总体胖子比瘦子多吃了一倍，但是还是公平的。</p>
<h4 id="10-5-调度队列与调度实体"><a href="#10-5-调度队列与调度实体" class="headerlink" title="10.5 调度队列与调度实体"></a>10.5 调度队列与调度实体</h4><p>看来CFS需要一个数据结构来对vruntime进行排序，找出最小的那个。这个能够排序的数据结构不但需要查询的时候，能够快速找到最小的，更新的时候也需要能够快速的调整排序，要知道vruntime可是经常在变的，变了再插入这个数据结构，就需要重新排序。</p>
<p>能够平衡查询和更新速度的是树，在这里使用的是红黑树。</p>
<p>红黑树的的节点是应该包括vruntime的，称为调度实体。</p>
<p>在task_struct中有这样的成员变量：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> se<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">sched_rt_entity</span> rt<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">sched_dl_entity</span> dl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这里有实时调度实体sched_rt_entity，Deadline调度实体sched_dl_entity，以及完全公平算法调度实体sched_entity。</p>
<p>看来不光CFS调度策略需要有这样一个数据结构进行排序，其他的调度策略也同样有自己的数据结构进行排序，因为任何一个策略做调度的时候，都是要区分谁先运行谁后运行。</p>
<p>而进程根据自己是实时的，还是普通的类型，通过这个成员变量，将自己挂在某一个数据结构里面，和其他的进程排序，等待被调度。如果这个进程是个普通进程，则通过sched_entity，将自己挂在这棵红黑树上。</p>
<p>对于普通进程的调度实体定义如下，这里面包含了vruntime和权重load_weight，以及对于运行时间的统计。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">load_weight</span>    load<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span>      run_node<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>        group_node<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>            on_rq<span class="token punctuation">;</span>
    u64      exec_start<span class="token punctuation">;</span>
    u64      sum_exec_runtime<span class="token punctuation">;</span>
    u64      vruntime<span class="token punctuation">;</span>
    u64      prev_sum_exec_runtime<span class="token punctuation">;</span>
    u64      nr_migrations<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_statistics</span> statistics<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下图是一个红黑树的例子。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/调度队列红黑树示例.jpeg" alt="调度队列红黑树示例"></p>
<p>所有可运行的进程通过不断地插入操作最终都存储在以时间为顺序的红黑树中，vruntime最小的在树的左侧，vruntime最多的在树的右侧。 CFS调度策略会选择红黑树最左边的叶子节点作为下一个将获得cpu的任务。</p>
<p>每个CPU都有自己的 struct rq 结构，其用于描述在此CPU上所运行的所有进程，其包括一个实时进程队列rt_rq和一个CFS运行队列cfs_rq，在调度时，调度器首先会先去实时进程队列找是否有实时进程需要运行，如果没有才会去CFS运行队列找是否有进行需要运行。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token punctuation">{</span>
    <span class="token comment">/* runqueue lock: */</span>
    raw_spinlock_t lock<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nr_running<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> cpu_load<span class="token punctuation">[</span>CPU_LOAD_IDX_MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">struct</span> <span class="token class-name">load_weight</span> load<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> nr_load_updates<span class="token punctuation">;</span>
    u64 nr_switches<span class="token punctuation">;</span>


    <span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> cfs<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rt_rq</span> rt<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">dl_rq</span> dl<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token operator">*</span>idle<span class="token punctuation">,</span> <span class="token operator">*</span>stop<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于普通进程公平队列cfs_rq，定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* CFS-related fields in a runqueue */</span>
<span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">load_weight</span> load<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nr_running<span class="token punctuation">,</span> h_nr_running<span class="token punctuation">;</span>

    u64 exec_clock<span class="token punctuation">;</span>
    u64 min_vruntime<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">CONFIG_64BIT</span></span>
    u64 min_vruntime_copy<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_root</span> tasks_timeline<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>rb_leftmost<span class="token punctuation">;</span>

    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token operator">*</span>next<span class="token punctuation">,</span> <span class="token operator">*</span>last<span class="token punctuation">,</span> <span class="token operator">*</span>skip<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面rb_root指向的就是红黑树的根节点，这个红黑树在CPU看起来就是一个队列，不断的取下一个应该运行的进程。rb_leftmost指向的是最左面的节点。</p>
<p>到这里终于凑够数据结构了，上面这些数据结构的关系如下图：</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/调度队列与调度实体.jpeg" alt="调度队列与调度实体"></p>
<h4 id="10-6-调度类是如何工作的？"><a href="#10-6-调度类是如何工作的？" class="headerlink" title="10.6 调度类是如何工作的？"></a>10.6 调度类是如何工作的？</h4><p>调度类的定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sched_class</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>enqueue_task<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>dequeue_task<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>yield_task<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">bool</span> <span class="token punctuation">(</span><span class="token operator">*</span>yield_to_task<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> bool preempt<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>check_preempt_curr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>pick_next_task<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span>
                        <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span>
                        <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> <span class="token operator">*</span>rf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>put_prev_task<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>set_curr_task<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>task_tick<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> queued<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>task_fork<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>task_dead<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>switched_from<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>this_rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>switched_to<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>this_rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>prio_changed<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>this_rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>task<span class="token punctuation">,</span> <span class="token keyword">int</span> oldprio<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>get_rr_interval<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span>
                     <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>update_curr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个结构定义了很多种方法，用于在队列上操作任务。这里请大家注意第一个成员变量，是一个指针，指向下一个调度类。</p>
<p>上面我们讲了，调度类分为下面这几种：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> stop_sched_class<span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> dl_sched_class<span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> rt_sched_class<span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> fair_sched_class<span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> idle_sched_class<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>它们其实是放在一个链表上的。这里我们以调度最常见的操作，取下一个任务为例，来解析一下。可以看到，这里面有一个for_each_class循环，沿着上面的顺序，依次调用每个调度类的方法。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * Pick up the highest-prio task:
 */</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>
<span class="token function">pick_next_task</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> <span class="token operator">*</span>rf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> <span class="token operator">*</span>class<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">for_each_class</span><span class="token punctuation">(</span>class<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        p <span class="token operator">=</span> class<span class="token operator">-&gt;</span><span class="token function">pick_next_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> rf<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>p <span class="token operator">==</span> RETRY_TASK<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">goto</span> again<span class="token punctuation">;</span>
            <span class="token keyword">return</span> p<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这就说明，调度的时候是从优先级最高的调度类到优先级低的调度类，依次执行。而对于每种调度类，有自己的实现，例如，CFS就有fair_sched_class。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> fair_sched_class <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>next               <span class="token operator">=</span> <span class="token operator">&amp;</span>idle_sched_class<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>enqueue_task       <span class="token operator">=</span> enqueue_task_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>dequeue_task       <span class="token operator">=</span> dequeue_task_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>yield_task         <span class="token operator">=</span> yield_task_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>yield_to_task      <span class="token operator">=</span> yield_to_task_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>check_preempt_curr <span class="token operator">=</span> check_preempt_wakeup<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>pick_next_task     <span class="token operator">=</span> pick_next_task_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>put_prev_task      <span class="token operator">=</span> put_prev_task_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>set_curr_task      <span class="token operator">=</span> set_curr_task_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>task_tick          <span class="token operator">=</span> task_tick_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>task_fork          <span class="token operator">=</span> task_fork_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>prio_changed       <span class="token operator">=</span> prio_changed_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>switched_from      <span class="token operator">=</span> switched_from_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>switched_to        <span class="token operator">=</span> switched_to_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>get_rr_interval    <span class="token operator">=</span> get_rr_interval_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>update_curr        <span class="token operator">=</span> update_curr_fair<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于同样的pick_next_task选取下一个要运行的任务这个动作，不同的调度类有自己的实现。fair_sched_class的实现是pick_next_task_fair，rt_sched_class的实现是pick_next_task_rt。</p>
<p>我们会发现这两个函数是操作不同的队列，pick_next_task_rt操作的是rt_rq，pick_next_task_fair操作的是cfs_rq。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>
<span class="token function">pick_next_task_rt</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> <span class="token operator">*</span>rf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rt_rq</span> <span class="token operator">*</span>rt_rq <span class="token operator">=</span> <span class="token operator">&amp;</span>rq<span class="token operator">-&gt;</span>rt<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>


<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>
<span class="token function">pick_next_task_fair</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> <span class="token operator">*</span>rf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq <span class="token operator">=</span> <span class="token operator">&amp;</span>rq<span class="token operator">-&gt;</span>cfs<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样整个运行的场景就串起来了，在每个CPU上都有一个队列rq，这个队列里面包含多个子队列，例如rt_rq和cfs_rq，不同的队列有不同的实现方式，cfs_rq就是用红黑树实现的。</p>
<p>当有一天，某个CPU需要找下一个任务执行的时候，会按照优先级依次调用调度类，不同的调度类操作不同的队列。当然rt_sched_class先被调用，它会在rt_rq上找下一个任务，只有找不到的时候，才轮到fair_sched_class被调用，它会在cfs_rq上找下一个任务。这样保证了实时任务的优先级永远大于普通任务。</p>
<p>下面我们仔细看一下sched_class定义的与调度有关的函数。</p>
<ul>
<li>enqueue_task 向就绪队列中添加一个进程，当某个进程进入可运行状态时，调用这个函数；</li>
<li>dequeue_task 将一个进程从就就绪队列中删除；</li>
<li>pick_next_task 选择接下来要运行的进程；</li>
<li>put_prev_task 用另一个进程代替当前运行的进程；</li>
<li>set_curr_task 用于修改调度策略；</li>
<li>task_tick 每次周期性时钟到的时候，这个函数被调用，可能触发调度。</li>
</ul>
<p>在这里面，我们重点看fair_sched_class对于pick_next_task的实现pick_next_task_fair，获取下一个进程。调用路径如下：pick_next_task_fair-&gt;pick_next_entity-&gt;__pick_first_entity。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span><span class="token function">__pick_first_entity</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>left <span class="token operator">=</span> <span class="token function">rb_first_cached</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cfs_rq<span class="token operator">-&gt;</span>tasks_timeline<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>left<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token function">rb_entry</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span><span class="token punctuation">,</span> run_node<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从这个函数的实现可以看出，就是从红黑树里面取最左面的节点。</p>
<h4 id="10-7-总结"><a href="#10-7-总结" class="headerlink" title="10.7 总结"></a>10.7 总结</h4><p>一个CPU上有一个队列，CFS的队列是一棵红黑树，树的每一个节点都是一个sched_entity，每个sched_entity都属于一个task_struct，task_struct里面有指针指向这个进程属于哪个调度类。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/调度总结（上）.jpeg" alt="调度总结（上）"></p>
<p>在调度的时候，依次调用调度类的函数，从CPU的队列中取出下一个进程。上面图中的调度器、上下文切换这一节我们没有讲，下一节我们讲讲基于这些数据结构，如何实现调度。</p>
<h3 id="11-调度（中）"><a href="#11-调度（中）" class="headerlink" title="11. 调度（中）"></a>11. 调度（中）</h3><p>所谓进程调度，其实就是一个人在做A项目，在某个时刻，换成做B项目去了。发生这种情况，主要有两种方式。</p>
<p><strong>方式一</strong>：A项目做着做着，发现里面有一条指令sleep，也就是要休息一下，或者在等待某个I/O事件。那没办法了，就要主动让出CPU，然后可以开始做B项目。</p>
<p><strong>方式二</strong>：A项目做着做着，旷日持久，实在受不了了。项目经理介入了，说这个项目A先停停，B项目也要做一下，要不然B项目该投诉了。</p>
<h4 id="11-1-主动调度"><a href="#11-1-主动调度" class="headerlink" title="11.1 主动调度"></a>11.1 主动调度</h4><p>我们这一节先来看方式一，主动调度。</p>
<p>这里我找了几个代码片段。 <strong>第一个片段是Btrfs，等待一个写入</strong> 。 Btrfs（B-Tree）是一种文件系统。</p>
<p>这个片段可以看作写入块设备的一个典型场景。写入需要一段时间，这段时间用不上CPU，还不如主动让给其他进程。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">btrfs_wait_for_no_snapshoting_writes</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">btrfs_root</span> <span class="token operator">*</span>root<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        <span class="token function">prepare_to_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>root<span class="token operator">-&gt;</span>subv_writers<span class="token operator">-&gt;</span>wait<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait<span class="token punctuation">,</span>
                TASK_UNINTERRUPTIBLE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        writers <span class="token operator">=</span> <span class="token function">percpu_counter_sum</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>root<span class="token operator">-&gt;</span>subv_writers<span class="token operator">-&gt;</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>writers<span class="token punctuation">)</span>
            <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">finish_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>root<span class="token operator">-&gt;</span>subv_writers<span class="token operator">-&gt;</span>wait<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>writers<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另外一个例子是， <strong>从Tap网络设备等待一个读取</strong> 。Tap网络设备是虚拟机使用的网络设备。当没有数据到来的时候，它也需要等待，所以也会选择把CPU让给其他进程。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> ssize_t <span class="token function">tap_do_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">tap_queue</span> <span class="token operator">*</span>q<span class="token punctuation">,</span>
               <span class="token keyword">struct</span> <span class="token class-name">iov_iter</span> <span class="token operator">*</span>to<span class="token punctuation">,</span>
               <span class="token keyword">int</span> noblock<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>noblock<span class="token punctuation">)</span>
            <span class="token function">prepare_to_wait</span><span class="token punctuation">(</span><span class="token function">sk_sleep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-&gt;</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait<span class="token punctuation">,</span>
                    TASK_INTERRUPTIBLE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token comment">/* Nothing to read, let's sleep */</span>
        <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来，我们就来看 <strong>schedule函数的调用过程</strong>。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">asmlinkage __visible <span class="token keyword">void</span> __sched <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk <span class="token operator">=</span> current<span class="token punctuation">;</span>

    <span class="token function">sched_submit_work</span><span class="token punctuation">(</span>tsk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        <span class="token function">preempt_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">__schedule</span><span class="token punctuation">(</span>false<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sched_preempt_enable_no_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">need_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这段代码的主要逻辑是在__schedule函数中实现的。这个函数比较复杂，我们分几个部分来讲解。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> __sched notrace <span class="token function">__schedule</span><span class="token punctuation">(</span>bool preempt<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span>switch_count<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> rf<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">;</span>
    <span class="token keyword">int</span> cpu<span class="token punctuation">;</span>

    cpu <span class="token operator">=</span> <span class="token function">smp_processor_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    rq <span class="token operator">=</span> <span class="token function">cpu_rq</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
    prev <span class="token operator">=</span> rq<span class="token operator">-&gt;</span>curr<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先，在当前的CPU上，我们取出任务队列rq。</p>
<p>task_struct *prev指向这个CPU的任务队列上面正在运行的那个进程curr。为啥是prev？因为一旦将来它被切换下来，那它就成了前任了。</p>
<p>接下来代码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">next <span class="token operator">=</span> <span class="token function">pick_next_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">clear_tsk_need_resched</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">clear_preempt_need_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>第二步，获取下一个任务，<code>task_struct *next</code> 指向下一个任务，这就是 <strong>继任</strong> 。</p>
<p>pick_next_task的实现如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>
<span class="token function">pick_next_task</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> <span class="token operator">*</span>rf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> <span class="token operator">*</span>class<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
    <span class="token comment">/*
     * Optimization: we know that if all tasks are in the fair class we can call that function directly, but only if the @prev task wasn't of a higher scheduling class, because otherwise those loose the opportunity to pull in more work from other CPUs.
     */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token punctuation">(</span>prev<span class="token operator">-&gt;</span>sched_class <span class="token operator">==</span> <span class="token operator">&amp;</span>idle_sched_class <span class="token operator">||</span>
            prev<span class="token operator">-&gt;</span>sched_class <span class="token operator">==</span> <span class="token operator">&amp;</span>fair_sched_class<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
           rq<span class="token operator">-&gt;</span>nr_running <span class="token operator">==</span> rq<span class="token operator">-&gt;</span>cfs<span class="token punctuation">.</span>h_nr_running<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        p <span class="token operator">=</span> fair_sched_class<span class="token punctuation">.</span><span class="token function">pick_next_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> rf<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>p <span class="token operator">==</span> RETRY_TASK<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">goto</span> again<span class="token punctuation">;</span>
        <span class="token comment">/* Assumes fair_sched_class-&gt;next == idle_sched_class */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span>
            p <span class="token operator">=</span> idle_sched_class<span class="token punctuation">.</span><span class="token function">pick_next_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> rf<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> p<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
again<span class="token operator">:</span>
    <span class="token function">for_each_class</span><span class="token punctuation">(</span>class<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        p <span class="token operator">=</span> class<span class="token operator">-&gt;</span><span class="token function">pick_next_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> rf<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>p <span class="token operator">==</span> RETRY_TASK<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">goto</span> again<span class="token punctuation">;</span>
            <span class="token keyword">return</span> p<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们来看again这里，就是咱们上一节讲的依次调用调度类。但是这里有了一个优化，因为大部分进程是普通进程，所以大部分情况下会调用上面的逻辑，调用的就是fair_sched_class.pick_next_task。</p>
<p>根据上一节对于fair_sched_class的定义，它调用的是pick_next_task_fair，代码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>
<span class="token function">pick_next_task_fair</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> <span class="token operator">*</span>rf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq <span class="token operator">=</span> <span class="token operator">&amp;</span>rq<span class="token operator">-&gt;</span>cfs<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
    <span class="token keyword">int</span> new_tasks<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于CFS调度类，取出相应的队列cfs_rq，这就是我们上一节讲的那棵红黑树。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">        <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>curr <span class="token operator">=</span> cfs_rq<span class="token operator">-&gt;</span>curr<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>curr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>curr<span class="token operator">-&gt;</span>on_rq<span class="token punctuation">)</span>
                <span class="token function">update_curr</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                curr <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">}</span>
        se <span class="token operator">=</span> <span class="token function">pick_next_entity</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> curr<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>取出当前正在运行的任务curr，如果依然是可运行的状态，也即处于进程就绪状态，则调用update_curr更新vruntime。update_curr咱们上一节就见过了，它会根据实际运行时间算出vruntime来。</p>
<p>接着，pick_next_entity从红黑树里面，取最左边的一个节点。这个函数的实现我们上一节也讲过了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">    p <span class="token operator">=</span> <span class="token function">task_of</span><span class="token punctuation">(</span>se<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">!=</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>pse <span class="token operator">=</span> <span class="token operator">&amp;</span>prev<span class="token operator">-&gt;</span>se<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token function">put_prev_entity</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> pse<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">set_next_entity</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> se<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>task_of得到下一个调度实体对应的task_struct，如果发现继任和前任不一样，这就说明有一个更需要运行的进程了，就需要更新红黑树了。前面前任的vruntime更新过了，put_prev_entity放回红黑树，会找到相应的位置，然后set_next_entity将继任者设为当前任务。</p>
<p>第三步，当选出的继任者和前任不同，就要进行上下文切换，继任者进程正式进入运行。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>prev <span class="token operator">!=</span> next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        rq<span class="token operator">-&gt;</span>nr_switches<span class="token operator">++</span><span class="token punctuation">;</span>
        rq<span class="token operator">-&gt;</span>curr <span class="token operator">=</span> next<span class="token punctuation">;</span>
        <span class="token operator">++</span><span class="token operator">*</span>switch_count<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        rq <span class="token operator">=</span> <span class="token function">context_switch</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> next<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rf<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="11-2-进程上下文切换"><a href="#11-2-进程上下文切换" class="headerlink" title="11.2 进程上下文切换"></a>11.2 进程上下文切换</h4><p>上下文切换主要干两件事情，一是切换进程空间，也即虚拟内存；二是切换寄存器和CPU上下文。</p>
<p>我们先来看context_switch的实现。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * context_switch - switch to the new MM and the new thread's register state.
 */</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>
<span class="token function">context_switch</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span>
           <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>next<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> <span class="token operator">*</span>rf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>mm<span class="token punctuation">,</span> <span class="token operator">*</span>oldmm<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    mm <span class="token operator">=</span> next<span class="token operator">-&gt;</span>mm<span class="token punctuation">;</span>
    oldmm <span class="token operator">=</span> prev<span class="token operator">-&gt;</span>active_mm<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">switch_mm_irqs_off</span><span class="token punctuation">(</span>oldmm<span class="token punctuation">,</span> mm<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* Here we just switch the register state and the stack. */</span>
    <span class="token function">switch_to</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">,</span> prev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">barrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">finish_task_switch</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里首先是内存空间的切换，里面涉及内存管理的内容比较多。内存管理后面我们会有专门的章节来讲，这里你先知道有这么一回事就行了。</p>
<p>接下来，我们看switch_to。它就是寄存器和栈的切换，它调用到了__switch_to_asm。这是一段汇编代码，主要用于栈的切换。</p>
<p>对于32位操作系统来讲，切换的是栈顶指针esp。</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">/*
 * %eax: prev task
 * %edx: next task
 */
ENTRY(__switch_to_asm)
......
    /* switch stack */
    movl    %esp, TASK_threadsp(%eax)
    movl    TASK_threadsp(%edx), %esp
......
    jmp  __switch_to
END(__switch_to_asm)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于64位操作系统来讲，切换的是栈顶指针rsp。</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">/*
 * %rdi: prev task
 * %rsi: next task
 */
ENTRY(__switch_to_asm)
......
    /* switch stack */
    movq    %rsp, TASK_threadsp(%rdi)
    movq    TASK_threadsp(%rsi), %rsp
......
    jmp  __switch_to
END(__switch_to_asm)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最终，都返回了__switch_to这个函数。这个函数对于32位和64位操作系统虽然有不同的实现，但里面做的事情是差不多的。所以我这里仅仅列出64位操作系统做的事情。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">__visible __notrace_funcgraph <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>
<span class="token function">__switch_to</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev_p<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>next_p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">thread_struct</span> <span class="token operator">*</span>prev <span class="token operator">=</span> <span class="token operator">&amp;</span>prev_p<span class="token operator">-&gt;</span>thread<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">thread_struct</span> <span class="token operator">*</span>next <span class="token operator">=</span> <span class="token operator">&amp;</span>next_p<span class="token operator">-&gt;</span>thread<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">int</span> cpu <span class="token operator">=</span> <span class="token function">smp_processor_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">tss_struct</span> <span class="token operator">*</span>tss <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">per_cpu</span><span class="token punctuation">(</span>cpu_tss<span class="token punctuation">,</span> cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">load_TLS</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">this_cpu_write</span><span class="token punctuation">(</span>current_task<span class="token punctuation">,</span> next_p<span class="token punctuation">)</span><span class="token punctuation">;</span>


    <span class="token comment">/* Reload esp0 and ss1.  This changes current_thread_info(). */</span>
    <span class="token function">load_sp0</span><span class="token punctuation">(</span>tss<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> prev_p<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面有一个Per CPU的结构体tss。这是个什么呢？</p>
<p>在x86体系结构中，提供了一种以硬件的方式进行进程切换的模式，对于每个进程，x86希望在内存里面维护一个TSS（Task State Segment，任务状态段）结构。这里面有所有的寄存器。</p>
<p>另外，还有一个特殊的寄存器TR（Task Register，任务寄存器），指向某个进程的TSS。更改TR的值，将会触发硬件保存CPU所有寄存器的值到当前进程的TSS中，然后从新进程的TSS中读出所有寄存器值，加载到CPU对应的寄存器中。</p>
<p>下图就是32位的TSS结构。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/32位的TSS结构.png" alt="32位的TSS结构"></p>
<blockquote>
<p>图片来自Intel® 64 and IA-32 Architectures Software Developer’s Manual Combined Volumes</p>
</blockquote>
<p>但是这样有个缺点。我们做进程切换的时候，没必要每个寄存器都切换，这样每个进程一个TSS，就需要全量保存，全量切换，动作太大了。</p>
<p>于是，Linux操作系统想了一个办法。还记得在系统初始化的时候，会调用cpu_init吗？这里面会给每一个CPU关联一个TSS，然后将TR指向这个TSS，然后在操作系统的运行过程中，TR就不切换了，永远指向这个TSS。TSS用数据结构tss_struct表示，在x86_hw_tss中可以看到和上图相应的结构。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">cpu_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> cpu <span class="token operator">=</span> <span class="token function">smp_processor_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>curr <span class="token operator">=</span> current<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">tss_struct</span> <span class="token operator">*</span>t <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">per_cpu</span><span class="token punctuation">(</span>cpu_tss<span class="token punctuation">,</span> cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">load_sp0</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">set_tss_desc</span><span class="token punctuation">(</span>cpu<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">load_TR_desc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">tss_struct</span> <span class="token punctuation">{</span>
    <span class="token comment">/*
     * The hardware state:
     */</span>
    <span class="token keyword">struct</span> <span class="token class-name">x86_hw_tss</span>   x86_tss<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>      io_bitmap<span class="token punctuation">[</span>IO_BITMAP_LONGS <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在Linux中，真的参与进程切换的寄存器很少，主要的就是栈顶寄存器。</p>
<p>于是，在task_struct里面，还有一个我们原来没有注意的成员变量thread。这里面保留了要切换进程的时候需要修改的寄存器。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* CPU-specific state of this task: */</span>
<span class="token keyword">struct</span> <span class="token class-name">thread_struct</span>        thread<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>所谓的进程切换，就是将某个进程的thread_struct里面的寄存器的值，写入到CPU的TR指向的tss_struct，对于CPU来讲，这就算是完成了切换。</p>
<p>例如__switch_to中的load_sp0，就是将下一个进程的thread_struct的sp0的值加载到tss_struct里面去。</p>
<h4 id="11-3-指令指针的保存与恢复"><a href="#11-3-指令指针的保存与恢复" class="headerlink" title="11.3 指令指针的保存与恢复"></a>11.3 指令指针的保存与恢复</h4><p>你是不是觉得，这样真的就完成切换了吗？是的，不信我们来 <strong>盘点</strong> 一下。</p>
<p>从进程A切换到进程B，用户栈要不要切换呢？当然要，其实早就已经切换了，就在切换内存空间的时候。每个进程的用户栈都是独立的，都在内存空间里面。</p>
<p>那内核栈呢？已经在__switch_to里面切换了，也就是将current_task指向当前的task_struct。里面的void *stack指针，指向的就是当前的内核栈。</p>
<p>内核栈的栈顶指针呢？在<strong>switch_to_asm里面已经切换了栈顶指针，并且将栈顶指针在</strong>switch_to加载到了TSS里面。</p>
<p>用户栈的栈顶指针呢？如果当前在内核里面的话，它当然是在内核栈顶部的pt_regs结构里面呀。当从内核返回用户态运行的时候，pt_regs里面有所有当时在用户态的时候运行的上下文信息，就可以开始运行了。</p>
<p>唯一让人不容易理解的是指令指针寄存器，它应该指向下一条指令的，那它是如何切换的呢？这里有点绕，请你仔细看。</p>
<p>这里我先明确一点，进程的调度都最终会调用到__schedule函数。为了方便你记住，我姑且给它起个名字，就叫“ <strong>进程调度第一定律</strong> ”。后面我们会多次用到这个定律，你一定要记住。</p>
<p>我们用最前面的例子仔细分析这个过程。本来一个进程A在用户态是要写一个文件的，写文件的操作用户态没办法完成，就要通过系统调用到达内核态。在这个切换的过程中，用户态的指令指针寄存器是保存在pt_regs里面的，到了内核态，就开始沿着写文件的逻辑一步一步执行，结果发现需要等待，于是就调用__schedule函数。</p>
<p>这个时候，进程A在内核态的指令指针是指向<strong>schedule了。这里请记住，A进程的内核栈会保存这个</strong>schedule的调用，而且知道这是从btrfs_wait_for_no_snapshoting_writes这个函数里面进去的。</p>
<p>__schedule里面经过上面的层层调用，到达了context_switch的最后三行指令（其中barrier语句是一个编译器指令，用于保证switch_to和finish_task_switch的执行顺序，不会因为编译阶段优化而改变，这里咱们可以忽略它）。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">switch_to</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">,</span> prev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">barrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> <span class="token function">finish_task_switch</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>当进程A在内核里面执行switch_to的时候，内核态的指令指针也是指向这一行的。但是在switch_to里面，将寄存器和栈都切换到成了进程B的，唯一没有变的就是指令指针寄存器。当switch_to返回的时候，指令指针寄存器指向了下一条语句finish_task_switch。</p>
<p>但这个时候的finish_task_switch已经不是进程A的finish_task_switch了，而是进程B的finish_task_switch了。</p>
<p>这样合理吗？你怎么知道进程B当时被切换下去的时候，执行到哪里了？恢复B进程执行的时候一定在这里呢？这时候就要用到咱的“进程调度第一定律”了。</p>
<p>当年B进程被别人切换走的时候，也是调用__schedule，也是调用到switch_to，被切换成为C进程的，所以，B进程当年的下一个指令也是finish_task_switch，这就说明指令指针指到这里是没有错的。</p>
<p>接下来，我们要从finish_task_switch完毕后，返回__schedule的调用了。返回到哪里呢？按照函数返回的原理，当然是从内核栈里面去找，是返回到btrfs_wait_for_no_snapshoting_writes吗？当然不是了，因为btrfs_wait_for_no_snapshoting_writes是在A进程的内核栈里面的，它早就被切换走了，应该从B进程的内核栈里面找。</p>
<p>假设，B就是最前面例子里面调用tap_do_read读网卡的进程。它当年调用__schedule的时候，是从tap_do_read这个函数调用进去的。</p>
<p>当然，B进程的内核栈里面放的是tap_do_read。于是，从__schedule返回之后，当然是接着tap_do_read运行，然后在内核运行完毕后，返回用户态。这个时候，B进程内核栈的pt_regs也保存了用户态的指令指针寄存器，就接着在用户态的下一条指令开始运行就可以了。</p>
<p>假设，我们只有一个CPU，从B切换到C，从C又切换到A。在C切换到A的时候，还是按照“进程调度第一定律”，C进程还是会调用__schedule到达switch_to，在里面切换成为A的内核栈，然后运行finish_task_switch。</p>
<p>这个时候运行的finish_task_switch，才是A进程的finish_task_switch。运行完毕从__schedule返回的时候，从内核栈上才知道，当年是从btrfs_wait_for_no_snapshoting_writes调用进去的，因而应该返回btrfs_wait_for_no_snapshoting_writes继续执行，最后内核执行完毕返回用户态，同样恢复pt_regs，恢复用户态的指令指针寄存器，从用户态接着运行。</p>
<p>到这里你是不是有点理解为什么switch_to有三个参数呢？为啥有两个prev呢？其实我们从定义就可以看到。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">switch_to</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">,</span> last<span class="token punctuation">)</span>             </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span>                                            </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token function">prepare_switch_to</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>              </span><span class="token punctuation">\</span>
                                                <span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span>last<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">__switch_to_asm</span><span class="token punctuation">(</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上面的例子中，A切换到B的时候，运行到<strong>switch_to_asm这一行的时候，是在A的内核栈上运行的，prev是A，next是B。但是，A执行完</strong>switch_to_asm之后就被切换走了，当C再次切换到A的时候，运行到<strong>switch_to_asm，是从C的内核栈运行的。这个时候，prev是C，next是A，但是</strong>switch_to_asm里面切换成为了A当时的内核栈。</p>
<p>还记得当年的场景“prev是A，next是B”，__switch_to_asm里面return prev的时候，还没return的时候，prev这个变量里面放的还是C，因而它会把C放到返回结果中。但是，一旦return，就会弹出A当时的内核栈。这个时候，prev变量就变成了A，next变量就变成了B。这就还原了当年的场景，好在返回值里面的last还是C。</p>
<p>通过三个变量switch_to(prev = A, next=B, last=C)，A进程就明白了，我当时被切换走的时候，是切换成B，这次切换回来，是从C回来的。</p>
<h4 id="11-4-总结"><a href="#11-4-总结" class="headerlink" title="11.4 总结"></a>11.4 总结</h4><p>这一节我们讲主动调度的过程，也即一个运行中的进程主动调用<strong>schedule让出CPU。在</strong>schedule里面会做两件事情，第一是选取下一个进程，第二是进行上下文切换。而上下文切换又分用户态进程空间的切换和内核态的切换。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/主动调度.png" alt="主动调度"></p>
<h3 id="12-调度（下）"><a href="#12-调度（下）" class="headerlink" title="12. 调度（下）"></a>12. 调度（下）</h3><h4 id="12-1-抢占式调度"><a href="#12-1-抢占式调度" class="headerlink" title="12.1 抢占式调度"></a>12.1 抢占式调度</h4><p>上一节我们讲的主动调度是第一种方式，第二种方式，就是抢占式调度。什么情况下会发生抢占呢？</p>
<p>最常见的现象就是 <strong>一个进程执行时间太长了，是时候切换到另一个进程了</strong> 。那怎么衡量一个进程的运行时间呢？在计算机里面有一个时钟，会过一段时间触发一次时钟中断，通知操作系统，时间又过去一个时钟周期，这是个很好的方式，可以查看是否是需要抢占的时间点。</p>
<p>时钟中断处理函数会调用scheduler_tick()，它的代码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">scheduler_tick</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> cpu <span class="token operator">=</span> <span class="token function">smp_processor_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq <span class="token operator">=</span> <span class="token function">cpu_rq</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>curr <span class="token operator">=</span> rq<span class="token operator">-&gt;</span>curr<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    curr<span class="token operator">-&gt;</span>sched_class<span class="token operator">-&gt;</span><span class="token function">task_tick</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> curr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">cpu_load_update_active</span><span class="token punctuation">(</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">calc_global_load_tick</span><span class="token punctuation">(</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个函数先取出当前cpu的运行队列，然后得到这个队列上当前正在运行中的进程的task_struct，然后调用这个task_struct的调度类的task_tick函数，顾名思义这个函数就是来处理时钟事件的。</p>
<p>如果当前运行的进程是普通进程，调度类为fair_sched_class，调用的处理时钟的函数为task_tick_fair。我们来看一下它的实现。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">task_tick_fair</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token keyword">int</span> queued<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se <span class="token operator">=</span> <span class="token operator">&amp;</span>curr<span class="token operator">-&gt;</span>se<span class="token punctuation">;</span>

    <span class="token function">for_each_sched_entity</span><span class="token punctuation">(</span>se<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cfs_rq <span class="token operator">=</span> <span class="token function">cfs_rq_of</span><span class="token punctuation">(</span>se<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">entity_tick</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> se<span class="token punctuation">,</span> queued<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>根据当前进程的task_struct，找到对应的调度实体sched_entity和cfs_rq队列，调用entity_tick。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span>
<span class="token function">entity_tick</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token keyword">int</span> queued<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">update_curr</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">update_load_avg</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> UPDATE_TG<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">update_cfs_shares</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cfs_rq<span class="token operator">-&gt;</span>nr_running <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token function">check_preempt_tick</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> curr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在entity_tick里面，我们又见到了熟悉的update_curr。它会更新当前进程的vruntime，然后调用check_preempt_tick。顾名思义就是，检查是否是时候被抢占了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span>
<span class="token function">check_preempt_tick</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>curr<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ideal_runtime<span class="token punctuation">,</span> delta_exec<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se<span class="token punctuation">;</span>
    s64 delta<span class="token punctuation">;</span>

    ideal_runtime <span class="token operator">=</span> <span class="token function">sched_slice</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> curr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    delta_exec <span class="token operator">=</span> curr<span class="token operator">-&gt;</span>sum_exec_runtime <span class="token operator">-</span> curr<span class="token operator">-&gt;</span>prev_sum_exec_runtime<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>delta_exec <span class="token operator">&gt;</span> ideal_runtime<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">resched_curr</span><span class="token punctuation">(</span><span class="token function">rq_of</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    se <span class="token operator">=</span> <span class="token function">__pick_first_entity</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
    delta <span class="token operator">=</span> curr<span class="token operator">-&gt;</span>vruntime <span class="token operator">-</span> se<span class="token operator">-&gt;</span>vruntime<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>delta <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>delta <span class="token operator">&gt;</span> ideal_runtime<span class="token punctuation">)</span>
        <span class="token function">resched_curr</span><span class="token punctuation">(</span><span class="token function">rq_of</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>check_preempt_tick先是调用sched_slice函数计算出的ideal_runtime，他是一个调度周期中，这个进程应该运行的实际时间。</p>
<p>sum_exec_runtime指进程总共执行的实际时间，prev_sum_exec_runtime指上次该进程被调度时已经占用的实际时间。每次在调度一个新的进程时都会把它的se-&gt;prev_sum_exec_runtime = se-&gt;sum_exec_runtime，所以sum_exec_runtime-prev_sum_exec_runtime就是这次调度占用实际时间。如果这个时间大于ideal_runtime，则应该被抢占了。</p>
<p>除了这个条件之外，还会通过__pick_first_entity取出红黑树中最小的进程。如果当前进程的vruntime大于红黑树中最小的进程的vruntime，且差值大于ideal_runtime，也应该被抢占了。</p>
<p>当发现当前进程应该被抢占，不能直接把它踢下来，而是把它标记为应该被抢占。为什么呢？因为进程调度第一定律呀，一定要等待正在运行的进程调用__schedule才行啊，所以这里只能先标记一下。</p>
<p>标记一个进程应该被抢占，都是调用resched_curr，它会调用set_tsk_need_resched，标记进程应该被抢占，但是此时此刻，并不真的抢占，而是打上一个标签TIF_NEED_RESCHED。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">set_tsk_need_resched</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">set_tsk_thread_flag</span><span class="token punctuation">(</span>tsk<span class="token punctuation">,</span>TIF_NEED_RESCHED<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>另外一个可能抢占的场景是 <strong>当一个进程被唤醒的时候</strong> 。</p>
<p>我们前面说过，当一个进程在等待一个I/O的时候，会主动放弃CPU。但是当I/O到来的时候，进程往往会被唤醒。这个时候是一个时机。当被唤醒的进程优先级高于CPU上的当前进程，就会触发抢占。try_to_wake_up()调用ttwu_queue将这个唤醒的任务添加到队列当中。ttwu_queue再调用ttwu_do_activate激活这个任务。ttwu_do_activate调用ttwu_do_wakeup。这里面调用了check_preempt_curr检查是否应该发生抢占。如果应该发生抢占，也不是直接踢走当然进程，而也是将当前进程标记为应该被抢占。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">ttwu_do_wakeup</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> wake_flags<span class="token punctuation">,</span>
               <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> <span class="token operator">*</span>rf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">check_preempt_curr</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> p<span class="token punctuation">,</span> wake_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>state <span class="token operator">=</span> TASK_RUNNING<span class="token punctuation">;</span>
    <span class="token function">trace_sched_wakeup</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>到这里，你会发现，抢占问题只做完了一半。就是标识当前运行中的进程应该被抢占了，但是真正的抢占动作并没有发生。</p>
<h4 id="12-2-抢占的时机"><a href="#12-2-抢占的时机" class="headerlink" title="12.2 抢占的时机"></a>12.2 抢占的时机</h4><p>真正的抢占还需要时机，也就是需要那么一个时刻，让正在运行中的进程有机会调用一下__schedule。</p>
<p>你可以想象，不可能某个进程代码运行着，突然要去调用__schedule，代码里面不可能这么写，所以一定要规划几个时机，这个时机分为用户态和内核态。</p>
<h5 id="12-2-1-用户态的抢占时机"><a href="#12-2-1-用户态的抢占时机" class="headerlink" title="12.2.1 用户态的抢占时机"></a>12.2.1 用户态的抢占时机</h5><p>对于用户态的进程来讲，从系统调用中返回的那个时刻，是一个被抢占的时机。</p>
<p>前面讲系统调用的时候，64位的系统调用的链路位do_syscall_64-&gt;syscall_return_slowpath-&gt;prepare_exit_to_usermode-&gt;exit_to_usermode_loop，当时我们还没关注exit_to_usermode_loop这个函数，现在我们来看一下。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">exit_to_usermode_loop</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span>regs<span class="token punctuation">,</span> u32 cached_flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* We have work to do. */</span>
        <span class="token function">local_irq_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>cached_flags <span class="token operator">&amp;</span> _TIF_NEED_RESCHED<span class="token punctuation">)</span>
            <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在我们看到在exit_to_usermode_loop函数中，上面打的标记起了作用，如果被打了_TIF_NEED_RESCHED，调用schedule进行调度，调用的过程和上一节解析的一样，会选择一个进程让出CPU，做上下文切换。</p>
<p>对于用户态的进程来讲，从中断中返回的那个时刻，也是一个被抢占的时机。</p>
<p>在arch/x86/entry/entry_64.S中有中断的处理过程。又是一段汇编语言代码，你重点领会它的意思就行，不要纠结每一行都看懂。</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">common_interrupt:
        ASM_CLAC
        addq    $-0x80, (%rsp)
        interrupt do_IRQ
ret_from_intr:
        popq    %rsp
        testb   $3, CS(%rsp)
        jz    retint_kernel
/* Interrupt came from user space */
GLOBAL(retint_user)
        mov  %rsp,%rdi
        call    prepare_exit_to_usermode
        TRACE_IRQS_IRETQ
        SWAPGS
        jmp  restore_regs_and_iret
/* Returning to kernel space */
retint_kernel:
#ifdef CONFIG_PREEMPT
        bt    $9, EFLAGS(%rsp)
        jnc  1f
0:    cmpl    $0, PER_CPU_VAR(__preempt_count)
        jnz  1f
        call    preempt_schedule_irq
        jmp  0b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>中断处理调用的是do_IRQ函数，中断完毕后分为两种情况，一个是返回用户态，一个是返回内核态。这个通过注释也能看出来。</p>
<p>咱们先来来看返回用户态这一部分，先不管返回内核态的那部分代码，retint_user会调用prepare_exit_to_usermode，最终调用exit_to_usermode_loop，和上面的逻辑一样，发现有标记则调用schedule()。</p>
<h5 id="12-2-2-内核态的抢占时机"><a href="#12-2-2-内核态的抢占时机" class="headerlink" title="12.2.2 内核态的抢占时机"></a>12.2.2 内核态的抢占时机</h5><p>对内核态的执行中，被抢占的时机一般发生在在preempt_enable()中。</p>
<p>在内核态的执行中，有的操作是不能被中断的，所以在进行这些操作之前，总是先调用preempt_disable()关闭抢占，当再次打开的时候，就是一次内核态代码被抢占的机会。</p>
<p>就像下面代码中展示的一样，preempt_enable()会调用preempt_count_dec_and_test()，判断preempt_count和TIF_NEED_RESCHED看是否可以被抢占。如果可以，就调用preempt_schedule-&gt;preempt_schedule_common-&gt;__schedule进行调度。还是满足进程调度第一定律的。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">preempt_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                        </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span>                                            </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token function">preempt_count_dec_and_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">__preempt_schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">preempt_count_dec_and_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token function">preempt_count_sub</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">should_resched</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span></span></span>

<span class="token keyword">static</span> __always_inline bool <span class="token function">should_resched</span><span class="token punctuation">(</span><span class="token keyword">int</span> preempt_offset<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token function">preempt_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> preempt_offset <span class="token operator">&amp;&amp;</span>
            <span class="token function">tif_need_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">tif_need_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">test_thread_flag</span><span class="token punctuation">(</span>TIF_NEED_RESCHED<span class="token punctuation">)</span></span></span>

<span class="token keyword">static</span> <span class="token keyword">void</span> __sched notrace <span class="token function">preempt_schedule_common</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token function">__schedule</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">need_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在内核态也会遇到中断的情况，当中断返回的时候，返回的仍然是内核态。这个时候也是一个执行抢占的时机，现在我们再来上面中断返回的代码中返回内核的那部分代码，调用的是preempt_schedule_irq。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">asmlinkage __visible <span class="token keyword">void</span> __sched <span class="token function">preempt_schedule_irq</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        <span class="token function">preempt_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">local_irq_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">__schedule</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">local_irq_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sched_preempt_enable_no_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">need_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>preempt_schedule_irq调用__schedule进行调度。还是满足进程调度第一定律的。</p>
<h4 id="12-3-总结"><a href="#12-3-总结" class="headerlink" title="12.3 总结"></a>12.3 总结</h4><p>第一条就是总结了进程调度第一定律的核心函数__schedule的执行过程，这是上一节讲的，因为要切换的东西比较多，需要你详细了解每一部分是如何切换的。</p>
<p>第二条总结了标记为可抢占的场景，第三条是所有的抢占发生的时机，这里是真正验证了进程调度第一定律的。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/进程的调度体系.png" alt="进程的调度体系"></p>
<h3 id="13-进程的创建"><a href="#13-进程的创建" class="headerlink" title="13. 进程的创建"></a>13. 进程的创建</h3><p>fork是一个系统调用，根据咱们讲过的系统调用的流程，流程的最后会在sys_call_table中找到相应的系统调用sys_fork。</p>
<p>根据SYSCALL_DEFINE0这个宏的定义，下面这段代码就定义了sys_fork。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE0</span><span class="token punctuation">(</span>fork<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> <span class="token function">_do_fork</span><span class="token punctuation">(</span>SIGCHLD<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>sys_fork会调用_do_fork。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">long</span> <span class="token function">_do_fork</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> clone_flags<span class="token punctuation">,</span>
          <span class="token keyword">unsigned</span> <span class="token keyword">long</span> stack_start<span class="token punctuation">,</span>
          <span class="token keyword">unsigned</span> <span class="token keyword">long</span> stack_size<span class="token punctuation">,</span>
          <span class="token keyword">int</span> __user <span class="token operator">*</span>parent_tidptr<span class="token punctuation">,</span>
          <span class="token keyword">int</span> __user <span class="token operator">*</span>child_tidptr<span class="token punctuation">,</span>
          <span class="token keyword">unsigned</span> <span class="token keyword">long</span> tls<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
    <span class="token keyword">int</span> trace <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> nr<span class="token punctuation">;</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    p <span class="token operator">=</span> <span class="token function">copy_process</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> stack_start<span class="token punctuation">,</span> stack_size<span class="token punctuation">,</span>
             child_tidptr<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> trace<span class="token punctuation">,</span> tls<span class="token punctuation">,</span> NUMA_NO_NODE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">pid</span> <span class="token operator">*</span>pid<span class="token punctuation">;</span>
        pid <span class="token operator">=</span> <span class="token function">get_task_pid</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> PIDTYPE_PID<span class="token punctuation">)</span><span class="token punctuation">;</span>
        nr <span class="token operator">=</span> <span class="token function">pid_vnr</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>


        <span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_PARENT_SETTID<span class="token punctuation">)</span>
            <span class="token function">put_user</span><span class="token punctuation">(</span>nr<span class="token punctuation">,</span> parent_tidptr<span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token function">wake_up_new_task</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token function">put_pid</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="13-1-fork的第一件大事：复制结构"><a href="#13-1-fork的第一件大事：复制结构" class="headerlink" title="13.1 fork的第一件大事：复制结构"></a>13.1 fork的第一件大事：复制结构</h4><p>_do_fork里面做的第一件大事就是copy_process。</p>
<p>这里我们再把task_struct的结构图拿出来，对比着看如何一个个复制。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/fork复制结构.png" alt="fork复制结构"></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> __latent_entropy <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token function">copy_process</span><span class="token punctuation">(</span>
                    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> clone_flags<span class="token punctuation">,</span>
                    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> stack_start<span class="token punctuation">,</span>
                    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> stack_size<span class="token punctuation">,</span>
                    <span class="token keyword">int</span> __user <span class="token operator">*</span>child_tidptr<span class="token punctuation">,</span>
                    <span class="token keyword">struct</span> <span class="token class-name">pid</span> <span class="token operator">*</span>pid<span class="token punctuation">,</span>
                    <span class="token keyword">int</span> trace<span class="token punctuation">,</span>
                    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> tls<span class="token punctuation">,</span>
                    <span class="token keyword">int</span> node<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> retval<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    p <span class="token operator">=</span> <span class="token function">dup_task_struct</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>dup_task_struct主要做了下面几件事情：</p>
<ul>
<li>调用alloc_task_struct_node分配一个task_struct结构；</li>
<li>调用alloc_thread_stack_node来创建内核栈，这里面调用__vmalloc_node_range分配一个连续的THREAD_SIZE的内存空间，赋值给task_struct的void *stack成员变量；</li>
<li>调用arch_dup_task_struct(struct task_struct <em>dst, struct task_struct </em>src)，将task_struct进行复制，其实就是调用memcpy；</li>
<li>调用setup_thread_stack设置thread_info。</li>
</ul>
<p>到这里，整个task_struct复制了一份，而且内核栈也创建好了。</p>
<p>我们再接着看copy_process。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">retval <span class="token operator">=</span> <span class="token function">copy_creds</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> clone_flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>轮到权限相关了，copy_creds主要做了下面几件事情：</p>
<ul>
<li>调用prepare_creds，准备一个新的struct cred *new。如何准备呢？其实还是从内存中分配一个新的struct cred结构，然后调用memcpy复制一份父进程的cred；</li>
<li>接着p-&gt;cred = p-&gt;real_cred = get_cred(new)，将新进程的“我能操作谁”和“谁能操作我”两个权限都指向新的cred。</li>
</ul>
<p>接下来，copy_process重新设置进程运行的统计量。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">p<span class="token operator">-&gt;</span>utime <span class="token operator">=</span> p<span class="token operator">-&gt;</span>stime <span class="token operator">=</span> p<span class="token operator">-&gt;</span>gtime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>start_time <span class="token operator">=</span> <span class="token function">ktime_get_ns</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>real_start_time <span class="token operator">=</span> <span class="token function">ktime_get_boot_ns</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>接下来，copy_process开始设置调度相关的变量。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">retval <span class="token operator">=</span> <span class="token function">sched_fork</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>sched_fork主要做了下面几件事情：</p>
<ul>
<li>调用__sched_fork，在这里面将on_rq设为0，初始化sched_entity，将里面的exec_start、sum_exec_runtime、prev_sum_exec_runtime、vruntime都设为0。你还记得吗，这几个变量涉及进程的实际运行时间和虚拟运行时间。是否到时间应该被调度了，就靠它们几个；</li>
<li>设置进程的状态p-&gt;state = TASK_NEW；</li>
<li>初始化优先级prio、normal_prio、static_prio；</li>
<li>设置调度类，如果是普通进程，就设置为p-&gt;sched_class = &amp;fair_sched_class；</li>
<li>调用调度类的task_fork函数，对于CFS来讲，就是调用task_fork_fair。在这个函数里，先调用update_curr，对于当前的进程进行统计量更新，然后把子进程和父进程的vruntime设成一样，最后调用place_entity，初始化sched_entity。这里有一个变量sysctl_sched_child_runs_first，可以设置父进程和子进程谁先运行。如果设置了子进程先运行，即便两个进程的vruntime一样，也要把子进程的sched_entity放在前面，然后调用resched_curr，标记当前运行的进程TIF_NEED_RESCHED，也就是说，把父进程设置为应该被调度，这样下次调度的时候，父进程会被子进程抢占。</li>
</ul>
<p>接下来，copy_process开始初始化与文件和文件系统相关的变量。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">retval <span class="token operator">=</span> <span class="token function">copy_files</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
retval <span class="token operator">=</span> <span class="token function">copy_fs</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>copy_files主要用于复制一个进程打开的文件信息。这些信息用一个结构files_struct来维护，每个打开的文件都有一个文件描述符。在copy_files函数里面调用dup_fd，在这里面会创建一个新的files_struct，然后将所有的文件描述符数组fdtable拷贝一份。</p>
<p>copy_fs主要用于复制一个进程的目录信息。这些信息用一个结构fs_struct来维护。一个进程有自己的根目录和根文件系统root，也有当前目录pwd和当前目录的文件系统，都在fs_struct里面维护。copy_fs函数里面调用copy_fs_struct，创建一个新的fs_struct，并复制原来进程的fs_struct。</p>
<p>接下来，copy_process开始初始化与信号相关的变量。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">init_sigpending</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>pending<span class="token punctuation">)</span><span class="token punctuation">;</span>
retval <span class="token operator">=</span> <span class="token function">copy_sighand</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
retval <span class="token operator">=</span> <span class="token function">copy_signal</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>copy_sighand会分配一个新的sighand_struct。这里最主要的是维护信号处理函数，在copy_sighand里面会调用memcpy，将信号处理函数sighand-&gt;action从父进程复制到子进程。</p>
<p>init_sigpending和copy_signal用于初始化，并且复制用于维护发给这个进程的信号的数据结构。copy_signal函数会分配一个新的signal_struct，并进行初始化。</p>
<p>接下来，copy_process开始复制进程内存空间。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">retval <span class="token operator">=</span> <span class="token function">copy_mm</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>进程都自己的内存空间，用mm_struct结构来表示。copy_mm函数中调用dup_mm，分配一个新的mm_struct结构，调用memcpy复制这个结构。dup_mmap用于复制内存空间中内存映射的部分。前面讲系统调用的时候，我们说过，mmap可以分配大块的内存，其实mmap也可以将一个文件映射到内存中，方便可以像读写内存一样读写文件，这个在内存管理那节我们讲。</p>
<p>接下来，copy_process开始分配pid，设置tid，group_leader，并且建立进程之间的亲缘关系。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">    <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>children<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>sibling<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    p<span class="token operator">-&gt;</span>pid <span class="token operator">=</span> <span class="token function">pid_nr</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_THREAD<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        p<span class="token operator">-&gt;</span>exit_signal <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        p<span class="token operator">-&gt;</span>group_leader <span class="token operator">=</span> current<span class="token operator">-&gt;</span>group_leader<span class="token punctuation">;</span>
        p<span class="token operator">-&gt;</span>tgid <span class="token operator">=</span> current<span class="token operator">-&gt;</span>tgid<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_PARENT<span class="token punctuation">)</span>
            p<span class="token operator">-&gt;</span>exit_signal <span class="token operator">=</span> current<span class="token operator">-&gt;</span>group_leader<span class="token operator">-&gt;</span>exit_signal<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            p<span class="token operator">-&gt;</span>exit_signal <span class="token operator">=</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CSIGNAL<span class="token punctuation">)</span><span class="token punctuation">;</span>
        p<span class="token operator">-&gt;</span>group_leader <span class="token operator">=</span> p<span class="token punctuation">;</span>
        p<span class="token operator">-&gt;</span>tgid <span class="token operator">=</span> p<span class="token operator">-&gt;</span>pid<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span>CLONE_PARENT<span class="token operator">|</span>CLONE_THREAD<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        p<span class="token operator">-&gt;</span>real_parent <span class="token operator">=</span> current<span class="token operator">-&gt;</span>real_parent<span class="token punctuation">;</span>
        p<span class="token operator">-&gt;</span>parent_exec_id <span class="token operator">=</span> current<span class="token operator">-&gt;</span>parent_exec_id<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        p<span class="token operator">-&gt;</span>real_parent <span class="token operator">=</span> current<span class="token punctuation">;</span>
        p<span class="token operator">-&gt;</span>parent_exec_id <span class="token operator">=</span> current<span class="token operator">-&gt;</span>self_exec_id<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>好了，copy_process要结束了，上面图中的组件也初始化的差不多了。</p>
<h4 id="13-2-fork的第二件大事：唤醒新进程"><a href="#13-2-fork的第二件大事：唤醒新进程" class="headerlink" title="13.2 fork的第二件大事：唤醒新进程"></a>13.2 fork的第二件大事：唤醒新进程</h4><p>_do_fork做的第二件大事是wake_up_new_task。新任务刚刚建立，有没有机会抢占别人，获得CPU呢？</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">wake_up_new_task</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> rf<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    p<span class="token operator">-&gt;</span>state <span class="token operator">=</span> TASK_RUNNING<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">activate_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> p<span class="token punctuation">,</span> ENQUEUE_NOCLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>on_rq <span class="token operator">=</span> TASK_ON_RQ_QUEUED<span class="token punctuation">;</span>
    <span class="token function">trace_sched_wakeup_new</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">check_preempt_curr</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> p<span class="token punctuation">,</span> WF_FORK<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先，我们需要将进程的状态设置为TASK_RUNNING。</p>
<p>activate_task函数中会调用enqueue_task。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">enqueue_task</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    p<span class="token operator">-&gt;</span>sched_class<span class="token operator">-&gt;</span><span class="token function">enqueue_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> p<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果是CFS的调度类，则执行相应的enqueue_task_fair。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span>
<span class="token function">enqueue_task_fair</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se <span class="token operator">=</span> <span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>se<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    cfs_rq <span class="token operator">=</span> <span class="token function">cfs_rq_of</span><span class="token punctuation">(</span>se<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">enqueue_entity</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> se<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    cfs_rq<span class="token operator">-&gt;</span>h_nr_running<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在enqueue_task_fair中取出的队列就是cfs_rq，然后调用enqueue_entity。</p>
<p>在enqueue_entity函数里面，会调用update_curr，更新运行的统计量，然后调用__enqueue_entity，将sched_entity加入到红黑树里面，然后将se-&gt;on_rq = 1设置在队列上。</p>
<p>回到enqueue_task_fair后，将这个队列上运行的进程数目加一。然后，wake_up_new_task会调用check_preempt_curr，看是否能够抢占当前进程。</p>
<p>在check_preempt_curr中，会调用相应的调度类的rq-&gt;curr-&gt;sched_class-&gt;check_preempt_curr(rq, p, flags)。对于CFS调度类来讲，调用的是check_preempt_wakeup。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">check_preempt_wakeup</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> wake_flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>curr <span class="token operator">=</span> rq<span class="token operator">-&gt;</span>curr<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se <span class="token operator">=</span> <span class="token operator">&amp;</span>curr<span class="token operator">-&gt;</span>se<span class="token punctuation">,</span> <span class="token operator">*</span>pse <span class="token operator">=</span> <span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>se<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq <span class="token operator">=</span> <span class="token function">task_cfs_rq</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">test_tsk_need_resched</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">find_matching_se</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>se<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pse<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">update_curr</span><span class="token punctuation">(</span><span class="token function">cfs_rq_of</span><span class="token punctuation">(</span>se<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">wakeup_preempt_entity</span><span class="token punctuation">(</span>se<span class="token punctuation">,</span> pse<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">goto</span> preempt<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
preempt<span class="token operator">:</span>
    <span class="token function">resched_curr</span><span class="token punctuation">(</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在check_preempt_wakeup函数中，前面调用task_fork_fair的时候，设置sysctl_sched_child_runs_first了，已经将当前父进程的TIF_NEED_RESCHED设置了，则直接返回。</p>
<p>否则，check_preempt_wakeup还是会调用update_curr更新一次统计量，然后wakeup_preempt_entity将父进程和子进程PK一次，看是不是要抢占，如果要则调用resched_curr标记父进程为TIF_NEED_RESCHED。</p>
<p>如果新创建的进程应该抢占父进程，在什么时间抢占呢？别忘了fork是一个系统调用，从系统调用返回的时候，是抢占的一个好时机，如果父进程判断自己已经被设置为TIF_NEED_RESCHED，就让子进程先跑，抢占自己。</p>
<h4 id="13-3-总结"><a href="#13-3-总结" class="headerlink" title="13.3 总结"></a>13.3 总结</h4><p>fork系统调用的过程咱们就解析完了。它包含两个重要的事件，一个是将task_struct结构复制一份并且初始化，另一个是试图唤醒新创建的子进程。</p>
<p>这个过程我画了一张图，你可以对照着这张图回顾进程创建的过程。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/进程创建的过程.jpeg" alt="进程创建的过程"></p>
<p>这个图的上半部分是复制task_struct结构，你可以对照着右面的task_struct结构图，看这里面的成员是如何一部分一部分的被复制的。图的下半部分是唤醒新创建的子进程，如果条件满足，就会将当前进程设置应该被调度的标识位，就等着当前进程执行__schedule了。</p>
<h3 id="14-线程的创建"><a href="#14-线程的创建" class="headerlink" title="14. 线程的创建"></a>14. 线程的创建</h3><h4 id="14-1-用户态创建线程"><a href="#14-1-用户态创建线程" class="headerlink" title="14.1 用户态创建线程"></a>14.1 用户态创建线程</h4><p>无论是进程还是线程，在内核里面都是任务。</p>
<p>其实，线程不是一个完全由内核实现的机制，它是由内核态和用户态合作完成的。pthread_create不是一个系统调用，是Glibc库的一个函数，所以我们还要去Glibc里面去找线索。</p>
<p>在nptl/pthread_create.c里面可以找到这个函数：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">__pthread_create_2_1</span> <span class="token punctuation">(</span>pthread_t <span class="token operator">*</span>newthread<span class="token punctuation">,</span> <span class="token keyword">const</span> pthread_attr_t <span class="token operator">*</span>attr<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>start_routine<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span class="token function">versioned_symbol</span> <span class="token punctuation">(</span>libpthread<span class="token punctuation">,</span> __pthread_create_2_1<span class="token punctuation">,</span> pthread_create<span class="token punctuation">,</span> GLIBC_2_1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面我们依次来看这个函数做了些啥。</p>
<p>首先处理的是线程的属性参数。例如前面写程序的时候，我们设置的线程栈大小。如果没有传入线程属性，就取默认值。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">pthread_attr</span> <span class="token operator">*</span>iattr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pthread_attr</span> <span class="token operator">*</span><span class="token punctuation">)</span> attr<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">pthread_attr</span> default_attr<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>iattr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
iattr <span class="token operator">=</span> <span class="token operator">&amp;</span>default_attr<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来，就像在内核里一样，每一个进程或者线程都有一个task_struct结构，在用户态也有一个用于维护线程的结构，就是这个pthread结构。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">pthread</span> <span class="token operator">*</span>pd <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>凡是涉及函数的调用，都要使用到栈。每个线程也有自己的栈。那接下来就是创建线程栈了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> err <span class="token operator">=</span> <span class="token function">ALLOCATE_STACK</span> <span class="token punctuation">(</span>iattr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pd<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>ALLOCATE_STACK是一个宏，我们找到它的定义之后，发现它其实就是一个函数。只是，这个函数有些复杂，所以我这里把主要的代码列一下。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span> <span class="token expression"><span class="token function">ALLOCATE_STACK</span><span class="token punctuation">(</span>attr<span class="token punctuation">,</span> pd<span class="token punctuation">)</span> <span class="token function">allocate_stack</span> <span class="token punctuation">(</span>attr<span class="token punctuation">,</span> pd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>stackaddr<span class="token punctuation">)</span></span></span>


<span class="token keyword">static</span> <span class="token keyword">int</span>
<span class="token function">allocate_stack</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">pthread_attr</span> <span class="token operator">*</span>attr<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">pthread</span> <span class="token operator">*</span><span class="token operator">*</span>pdp<span class="token punctuation">,</span>
                ALLOCATE_STACK_PARMS<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">pthread</span> <span class="token operator">*</span>pd<span class="token punctuation">;</span>
  size_t size<span class="token punctuation">;</span>
  size_t pagesize_m1 <span class="token operator">=</span> <span class="token function">__getpagesize</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  size <span class="token operator">=</span> attr<span class="token operator">-&gt;</span>stacksize<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">/* Allocate some anonymous memory.  If possible use the cache.  */</span>
  size_t guardsize<span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token operator">*</span>mem<span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span> prot <span class="token operator">=</span> <span class="token punctuation">(</span>PROT_READ <span class="token operator">|</span> PROT_WRITE
                   <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">GL</span><span class="token punctuation">(</span>dl_stack_flags<span class="token punctuation">)</span> <span class="token operator">&amp;</span> PF_X<span class="token punctuation">)</span> <span class="token operator">?</span> PROT_EXEC <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* Adjust the stack size for alignment.  */</span>
  size <span class="token operator">&amp;=</span> <span class="token operator">~</span>__static_tls_align_m1<span class="token punctuation">;</span>
  <span class="token comment">/* Make sure the size of the stack is enough for the guard and
  eventually the thread descriptor.  */</span>
  guardsize <span class="token operator">=</span> <span class="token punctuation">(</span>attr<span class="token operator">-&gt;</span>guardsize <span class="token operator">+</span> pagesize_m1<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span>pagesize_m1<span class="token punctuation">;</span>
  size <span class="token operator">+=</span> guardsize<span class="token punctuation">;</span>
  pd <span class="token operator">=</span> <span class="token function">get_cached_stack</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>size<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mem<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>pd <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token comment">/* If a guard page is required, avoid committing memory by first
    allocate with PROT_NONE and then reserve with required permission
    excluding the guard page.  */</span>
    mem <span class="token operator">=</span> <span class="token function">__mmap</span> <span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token punctuation">(</span>guardsize <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> prot <span class="token operator">:</span> PROT_NONE<span class="token punctuation">,</span>
            MAP_PRIVATE <span class="token operator">|</span> MAP_ANONYMOUS <span class="token operator">|</span> MAP_STACK<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* Place the thread descriptor at the end of the stack.  */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">TLS_TCB_AT_TP</span></span>
    pd <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pthread</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> mem <span class="token operator">+</span> size<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">elif</span> <span class="token expression">TLS_DTV_AT_TP</span></span>
    pd <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pthread</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uintptr_t<span class="token punctuation">)</span> mem <span class="token operator">+</span> size <span class="token operator">-</span> __static_tls_size<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span>__static_tls_align_m1<span class="token punctuation">)</span> <span class="token operator">-</span> TLS_PRE_TCB_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token comment">/* Now mprotect the required region excluding the guard area. */</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>guard <span class="token operator">=</span> <span class="token function">guard_position</span> <span class="token punctuation">(</span>mem<span class="token punctuation">,</span> size<span class="token punctuation">,</span> guardsize<span class="token punctuation">,</span> pd<span class="token punctuation">,</span> pagesize_m1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setup_stack_prot</span> <span class="token punctuation">(</span>mem<span class="token punctuation">,</span> size<span class="token punctuation">,</span> guard<span class="token punctuation">,</span> guardsize<span class="token punctuation">,</span> prot<span class="token punctuation">)</span><span class="token punctuation">;</span>
    pd<span class="token operator">-&gt;</span>stackblock <span class="token operator">=</span> mem<span class="token punctuation">;</span>
    pd<span class="token operator">-&gt;</span>stackblock_size <span class="token operator">=</span> size<span class="token punctuation">;</span>
    pd<span class="token operator">-&gt;</span>guardsize <span class="token operator">=</span> guardsize<span class="token punctuation">;</span>
    pd<span class="token operator">-&gt;</span>specific<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> pd<span class="token operator">-&gt;</span>specific_1stblock<span class="token punctuation">;</span>
    <span class="token comment">/* And add to the list of stacks in use.  */</span>
    <span class="token function">stack_list_add</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>pd<span class="token operator">-&gt;</span>list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>stack_used<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token operator">*</span>pdp <span class="token operator">=</span> pd<span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token operator">*</span>stacktop<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">if</span> <span class="token expression">TLS_TCB_AT_TP</span></span>
  <span class="token comment">/* The stack begins before the TCB and the static TLS block.  */</span>
  stacktop <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>pd <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> __static_tls_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">elif</span> <span class="token expression">TLS_DTV_AT_TP</span></span>
  stacktop <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>pd <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">endif</span></span>
  <span class="token operator">*</span>stack <span class="token operator">=</span> stacktop<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们来看一下，allocate_stack主要做了以下这些事情：</p>
<ul>
<li>如果你在线程属性里面设置过栈的大小，需要你把设置的值拿出来；</li>
<li>为了防止栈的访问越界，在栈的末尾会有一块空间guardsize，一旦访问到这里就错误了；</li>
<li>其实线程栈是在进程的堆里面创建的。如果一个进程不断地创建和删除线程，我们不可能不断地去申请和清除线程栈使用的内存块，这样就需要有一个缓存。get_cached_stack就是根据计算出来的size大小，看一看已经有的缓存中，有没有已经能够满足条件的；</li>
<li>如果缓存里面没有，就需要调用<strong>mmap创建一块新的，系统调用那一节我们讲过，如果要在堆里面malloc一块内存，比较大的话，用</strong>mmap；</li>
<li>线程栈也是自顶向下生长的，还记得每个线程要有一个pthread结构，这个结构也是放在栈的空间里面的。在栈底的位置，其实是地址最高位；</li>
<li>计算出guard内存的位置，调用setup_stack_prot设置这块内存的是受保护的；</li>
<li>接下来，开始填充pthread这个结构里面的成员变量stackblock、stackblock_size、guardsize、specific。这里的specific是用于存放Thread Specific Data的，也即属于线程的全局变量；</li>
<li>将这个线程栈放到stack_used链表中，其实管理线程栈总共有两个链表，一个是stack_used，也就是这个栈正被使用；另一个是stack_cache，就是上面说的，一旦线程结束，先缓存起来，不释放，等有其他的线程创建的时候，给其他的线程用。</li>
</ul>
<p>搞定了用户态栈的问题，其实用户态的事情基本搞定了一半。</p>
<h4 id="14-2-内核态创建任务"><a href="#14-2-内核态创建任务" class="headerlink" title="14.2 内核态创建任务"></a>14.2 内核态创建任务</h4><p>接下来，我们接着pthread_create看。其实有了用户态的栈，接着需要解决的就是用户态的程序从哪里开始运行的问题。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">pd<span class="token operator">-&gt;</span>start_routine <span class="token operator">=</span> start_routine<span class="token punctuation">;</span>
pd<span class="token operator">-&gt;</span>arg <span class="token operator">=</span> arg<span class="token punctuation">;</span>
pd<span class="token operator">-&gt;</span>schedpolicy <span class="token operator">=</span> self<span class="token operator">-&gt;</span>schedpolicy<span class="token punctuation">;</span>
pd<span class="token operator">-&gt;</span>schedparam <span class="token operator">=</span> self<span class="token operator">-&gt;</span>schedparam<span class="token punctuation">;</span>
<span class="token comment">/* Pass the descriptor to the caller.  */</span>
<span class="token operator">*</span>newthread <span class="token operator">=</span> <span class="token punctuation">(</span>pthread_t<span class="token punctuation">)</span> pd<span class="token punctuation">;</span>
<span class="token function">atomic_increment</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>__nptl_nthreads<span class="token punctuation">)</span><span class="token punctuation">;</span>
retval <span class="token operator">=</span> <span class="token function">create_thread</span> <span class="token punctuation">(</span>pd<span class="token punctuation">,</span> iattr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>stopped_start<span class="token punctuation">,</span> STACK_VARIABLES_ARGS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>thread_ran<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>start_routine就是咱们给线程的函数，start_routine，start_routine的参数arg，以及调度策略都要赋值给pthread。</p>
<p>接下来__nptl_nthreads加一，说明有多了一个线程。</p>
<p>真正创建线程的是调用create_thread函数，这个函数定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span>
<span class="token function">create_thread</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pthread</span> <span class="token operator">*</span>pd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">pthread_attr</span> <span class="token operator">*</span>attr<span class="token punctuation">,</span>
bool <span class="token operator">*</span>stopped_start<span class="token punctuation">,</span> STACK_VARIABLES_PARMS<span class="token punctuation">,</span> bool <span class="token operator">*</span>thread_ran<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span> clone_flags <span class="token operator">=</span> <span class="token punctuation">(</span>CLONE_VM <span class="token operator">|</span> CLONE_FS <span class="token operator">|</span> CLONE_FILES <span class="token operator">|</span> CLONE_SYSVSEM <span class="token operator">|</span> CLONE_SIGHAND <span class="token operator">|</span> CLONE_THREAD <span class="token operator">|</span> CLONE_SETTLS <span class="token operator">|</span> CLONE_PARENT_SETTID <span class="token operator">|</span> CLONE_CHILD_CLEARTID <span class="token operator">|</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">ARCH_CLONE</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>start_thread<span class="token punctuation">,</span> STACK_VARIABLES_ARGS<span class="token punctuation">,</span> clone_flags<span class="token punctuation">,</span> pd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pd<span class="token operator">-&gt;</span>tid<span class="token punctuation">,</span> tp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pd<span class="token operator">-&gt;</span>tid<span class="token punctuation">)</span>；
  <span class="token comment">/* It's started now, so if we fail below, we'll have to cancel it
and let it clean itself up.  */</span>
  <span class="token operator">*</span>thread_ran <span class="token operator">=</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面有很长的clone_flags，这些咱们原来一直没注意，不过接下来的过程，我们要特别的关注一下这些标志位。</p>
<p>然后就是ARCH_CLONE，其实调用的是__clone。看到这里，你应该就有感觉了，马上就要到系统调用了。</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm"># define ARCH_CLONE __clone


/* The userland implementation is:
   int clone (int (*fn)(void *arg), void *child_stack, int flags, void *arg),
   the kernel entry is:
   int clone (long flags, void *child_stack).


   The parameters are passed in register and on the stack from userland:
   rdi: fn
   rsi: child_stack
   rdx: flags
   rcx: arg
   r8d: TID field in parent
   r9d: thread pointer
%esp+8: TID field in child


   The kernel expects:
   rax: system call number
   rdi: flags
   rsi: child_stack
   rdx: TID field in parent
   r10: TID field in child
   r8:  thread pointer  */

        .text
ENTRY (__clone)
        movq    $-EINVAL,%rax
......
        /* Insert the argument onto the new stack.  */
        subq    $16,%rsi
        movq    %rcx,8(%rsi)


        /* Save the function pointer.  It will be popped off in the
           child in the ebx frobbing below.  */
        movq    %rdi,0(%rsi)


        /* Do the system call.  */
        movq    %rdx, %rdi
        movq    %r8, %rdx
        movq    %r9, %r8
        mov  8(%rsp), %R10_LP
        movl    $SYS_ify(clone),%eax
......
        syscall
......
PSEUDO_END (__clone)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>能看到最后调用了syscall，这一点clone和我们原来熟悉的其他系统调用几乎是一致的。但是，也有少许不一样的地方。</p>
<p>如果在进程的主线程里面调用其他系统调用，当前用户态的栈是指向整个进程的栈，栈顶指针也是指向进程的栈，指令指针也是指向进程的主线程的代码。此时此刻执行到这里，调用clone的时候，用户态的栈、栈顶指针、指令指针和其他系统调用一样，都是指向主线程的。</p>
<p>但是对于线程来说，这些都要变。因为我们希望当clone这个系统调用成功的时候，除了内核里面有这个线程对应的task_struct，当系统调用返回到用户态的时候，用户态的栈应该是线程的栈，栈顶指针应该指向线程的栈，指令指针应该指向线程将要执行的那个函数。</p>
<p>所以这些都需要我们自己做，将线程要执行的函数的参数和指令的位置都压到栈里面，当从内核返回，从栈里弹出来的时候，就从这个函数开始，带着这些参数执行下去。</p>
<p>接下来我们就要进入内核了。内核里面对于clone系统调用的定义是这样的：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE5</span><span class="token punctuation">(</span>clone<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> clone_flags<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> newsp<span class="token punctuation">,</span>
         <span class="token keyword">int</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> parent_tidptr<span class="token punctuation">,</span>
         <span class="token keyword">int</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> child_tidptr<span class="token punctuation">,</span>
         <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> tls<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">_do_fork</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> newsp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> parent_tidptr<span class="token punctuation">,</span> child_tidptr<span class="token punctuation">,</span> tls<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>看到这里，发现了熟悉的面孔_do_fork。</p>
<p>第一个是上面 <strong>复杂的标志位设定</strong> ，我们来看都影响了什么。</p>
<p>对于copy_files，原来是调用dup_fd复制一个files_struct的，现在因为CLONE_FILES标识位变成将原来的files_struct引用计数加一。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">copy_files</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> clone_flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">files_struct</span> <span class="token operator">*</span>oldf<span class="token punctuation">,</span> <span class="token operator">*</span>newf<span class="token punctuation">;</span>
    oldf <span class="token operator">=</span> current<span class="token operator">-&gt;</span>files<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_FILES<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">atomic_inc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>oldf<span class="token operator">-&gt;</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> out<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    newf <span class="token operator">=</span> <span class="token function">dup_fd</span><span class="token punctuation">(</span>oldf<span class="token punctuation">,</span> <span class="token operator">&amp;</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
    tsk<span class="token operator">-&gt;</span>files <span class="token operator">=</span> newf<span class="token punctuation">;</span>
out<span class="token operator">:</span>
    <span class="token keyword">return</span> error<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于copy_fs，原来是调用copy_fs_struct复制一个fs_struct，现在因为CLONE_FS标识位变成将原来的fs_struct的用户数加一。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">copy_fs</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> clone_flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">fs_struct</span> <span class="token operator">*</span>fs <span class="token operator">=</span> current<span class="token operator">-&gt;</span>fs<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_FS<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        fs<span class="token operator">-&gt;</span>users<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    tsk<span class="token operator">-&gt;</span>fs <span class="token operator">=</span> <span class="token function">copy_fs_struct</span><span class="token punctuation">(</span>fs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于copy_sighand，原来是创建一个新的sighand_struct，现在因为CLONE_SIGHAND标识位变成将原来的sighand_struct引用计数加一。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">copy_sighand</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> clone_flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">sighand_struct</span> <span class="token operator">*</span>sig<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_SIGHAND<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">atomic_inc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>current<span class="token operator">-&gt;</span>sighand<span class="token operator">-&gt;</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    sig <span class="token operator">=</span> <span class="token function">kmem_cache_alloc</span><span class="token punctuation">(</span>sighand_cachep<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">atomic_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sig<span class="token operator">-&gt;</span>count<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">memcpy</span><span class="token punctuation">(</span>sig<span class="token operator">-&gt;</span>action<span class="token punctuation">,</span> current<span class="token operator">-&gt;</span>sighand<span class="token operator">-&gt;</span>action<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sig<span class="token operator">-&gt;</span>action<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于copy_signal，原来是创建一个新的signal_struct，现在因为CLONE_THREAD直接返回了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">copy_signal</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> clone_flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">signal_struct</span> <span class="token operator">*</span>sig<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_THREAD<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    sig <span class="token operator">=</span> <span class="token function">kmem_cache_zalloc</span><span class="token punctuation">(</span>signal_cachep<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    tsk<span class="token operator">-&gt;</span>signal <span class="token operator">=</span> sig<span class="token punctuation">;</span>
    <span class="token function">init_sigpending</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sig<span class="token operator">-&gt;</span>shared_pending<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于copy_mm，原来是调用dup_mm复制一个mm_struct，现在因为CLONE_VM标识位而直接指向了原来的mm_struct</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">copy_mm</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> clone_flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>mm<span class="token punctuation">,</span> <span class="token operator">*</span>oldmm<span class="token punctuation">;</span>
    oldmm <span class="token operator">=</span> current<span class="token operator">-&gt;</span>mm<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_VM<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">mmget</span><span class="token punctuation">(</span>oldmm<span class="token punctuation">)</span><span class="token punctuation">;</span>
        mm <span class="token operator">=</span> oldmm<span class="token punctuation">;</span>
        <span class="token keyword">goto</span> good_mm<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    mm <span class="token operator">=</span> <span class="token function">dup_mm</span><span class="token punctuation">(</span>tsk<span class="token punctuation">)</span><span class="token punctuation">;</span>
good_mm<span class="token operator">:</span>
    tsk<span class="token operator">-&gt;</span>mm <span class="token operator">=</span> mm<span class="token punctuation">;</span>
    tsk<span class="token operator">-&gt;</span>active_mm <span class="token operator">=</span> mm<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>第二个就是 <strong>对于亲缘关系的影响</strong> ，毕竟我们要识别多个线程是不是属于一个进程。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">p<span class="token operator">-&gt;</span>pid <span class="token operator">=</span> <span class="token function">pid_nr</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_THREAD<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    p<span class="token operator">-&gt;</span>exit_signal <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>group_leader <span class="token operator">=</span> current<span class="token operator">-&gt;</span>group_leader<span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>tgid <span class="token operator">=</span> current<span class="token operator">-&gt;</span>tgid<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_PARENT<span class="token punctuation">)</span>
        p<span class="token operator">-&gt;</span>exit_signal <span class="token operator">=</span> current<span class="token operator">-&gt;</span>group_leader<span class="token operator">-&gt;</span>exit_signal<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        p<span class="token operator">-&gt;</span>exit_signal <span class="token operator">=</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CSIGNAL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>group_leader <span class="token operator">=</span> p<span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>tgid <span class="token operator">=</span> p<span class="token operator">-&gt;</span>pid<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
    <span class="token comment">/* CLONE_PARENT re-uses the old parent */</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span>CLONE_PARENT<span class="token operator">|</span>CLONE_THREAD<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    p<span class="token operator">-&gt;</span>real_parent <span class="token operator">=</span> current<span class="token operator">-&gt;</span>real_parent<span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>parent_exec_id <span class="token operator">=</span> current<span class="token operator">-&gt;</span>parent_exec_id<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    p<span class="token operator">-&gt;</span>real_parent <span class="token operator">=</span> current<span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>parent_exec_id <span class="token operator">=</span> current<span class="token operator">-&gt;</span>self_exec_id<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从上面的代码可以看出，使用了CLONE_THREAD标识位之后，使得亲缘关系有了一定的变化。</p>
<ul>
<li>如果是新进程，那这个进程的group_leader就是他自己，tgid是它自己的pid，这就完全重打锣鼓另开张了，自己是线程组的头。如果是新线程，group_leader是当前进程的，group_leader，tgid是当前进程的tgid，也就是当前进程的pid，这个时候还是拜原来进程为老大。</li>
<li>如果是新进程，新进程的real_parent是当前的进程，在进程树里面又见一辈人；如果是新线程，线程的real_parent是当前的进程的real_parent，其实是平辈的。</li>
</ul>
<p>第三， <strong>对于信号的处理</strong> ，如何保证发给进程的信号虽然可以被一个线程处理，但是影响范围应该是整个进程的。例如，kill一个进程，则所有线程都要被干掉。如果一个信号是发给一个线程的pthread_kill，则应该只有线程能够收到。</p>
<p>在copy_process的主流程里面，无论是创建进程还是线程，都会初始化struct sigpending pending，也就是每个task_struct，都会有这样一个成员变量。这就是一个信号列表。如果这个task_struct是一个线程，这里面的信号就是发给这个线程的；如果这个task_struct是一个进程，这里面的信号是发给主线程的。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">init_sigpending</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>pending<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>另外，上面copy_signal的时候，我们可以看到，在创建进程的过程中，会初始化signal_struct里面的struct sigpending shared_pending。但是，在创建线程的过程中，连signal_struct都共享了。也就是说，整个进程里的所有线程共享一个shared_pending，这也是一个信号列表，是发给整个进程的，哪个线程处理都一样。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">init_sigpending</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sig<span class="token operator">-&gt;</span>shared_pending<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>至此，clone在内核的调用完毕，要返回系统调用，回到用户态。</p>
<h4 id="14-3-用户态执行线程"><a href="#14-3-用户态执行线程" class="headerlink" title="14.3 用户态执行线程"></a>14.3 用户态执行线程</h4><p>根据__clone的第一个参数，回到用户态也不是直接运行我们指定的那个函数，而是一个通用的start_thread，这是所有线程在用户态的统一入口。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">START_THREAD_DEFN </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>noreturn<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">start_thread</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span></span></span>


START_THREAD_DEFN
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">pthread</span> <span class="token operator">*</span>pd <span class="token operator">=</span> START_THREAD_SELF<span class="token punctuation">;</span>
    <span class="token comment">/* Run the code the user provided.  */</span>
    <span class="token function">THREAD_SETMEM</span> <span class="token punctuation">(</span>pd<span class="token punctuation">,</span> result<span class="token punctuation">,</span> pd<span class="token operator">-&gt;</span><span class="token function">start_routine</span> <span class="token punctuation">(</span>pd<span class="token operator">-&gt;</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* Call destructors for the thread_local TLS variables.  */</span>
    <span class="token comment">/* Run the destructor for the thread-local data.  */</span>
    <span class="token function">__nptl_deallocate_tsd</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__glibc_unlikely</span> <span class="token punctuation">(</span><span class="token function">atomic_decrement_and_test</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>__nptl_nthreads<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment">/* This was the last thread.  */</span>
        <span class="token function">exit</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">__free_tcb</span> <span class="token punctuation">(</span>pd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">__exit_thread</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在start_thread入口函数中，才真正的调用用户提供的函数，在用户的函数执行完毕之后，会释放这个线程相关的数据。例如，线程本地数据thread_local variables，线程数目也减一。如果这是最后一个线程了，就直接退出进程，另外__free_tcb用于释放pthread。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span>
internal_function
<span class="token function">__free_tcb</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pthread</span> <span class="token operator">*</span>pd<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token function">__deallocate_stack</span> <span class="token punctuation">(</span>pd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">void</span>
internal_function
<span class="token function">__deallocate_stack</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pthread</span> <span class="token operator">*</span>pd<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment">/* Remove the thread from the list of threads with user defined
     stacks.  */</span>
  <span class="token function">stack_list_del</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>pd<span class="token operator">-&gt;</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* Not much to do.  Just free the mmap()ed memory.  Note that we do
     not reset the 'used' flag in the 'tid' field.  This is done by
     the kernel.  If no thread has been created yet this field is
     still zero.  */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__glibc_likely</span> <span class="token punctuation">(</span><span class="token operator">!</span> pd<span class="token operator">-&gt;</span>user_stack<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token function">queue_stack</span> <span class="token punctuation">(</span>pd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>free_tcb会调用</strong>deallocate_stack来释放整个线程栈，这个线程栈要从当前使用线程栈的列表stack_used中拿下来，放到缓存的线程栈列表stack_cache中。</p>
<p>好了，整个线程的生命周期到这里就结束了。</p>
<h4 id="14-4-总结"><a href="#14-4-总结" class="headerlink" title="14.4 总结"></a>14.4 总结</h4><p>线程的调用过程解析完毕了，我画了一个图总结一下。这个图对比了创建进程和创建线程在用户态和内核态的不同。</p>
<p>创建进程的话，调用的系统调用是fork，在copy_process函数里面，会将五大结构files_struct、fs_struct、sighand_struct、signal_struct、mm_struct都复制一遍，从此父进程和子进程各用各的数据结构。而创建线程的话，调用的是系统调用clone，在copy_process函数里面， 五大结构仅仅是引用计数加一，也即线程共享进程的数据结构。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/创建进程和创建线程过程对比.jpeg" alt="创建进程和创建线程过程对比"></p>
<h2 id="三、内存管理"><a href="#三、内存管理" class="headerlink" title="三、内存管理"></a>三、内存管理</h2><h3 id="15-内存管理（上）"><a href="#15-内存管理（上）" class="headerlink" title="15. 内存管理（上）"></a>15. 内存管理（上）</h3><p>平时我们说计算机的“计算”两个字，其实说的就是两方面，第一，进程和线程对于CPU的使用；第二，对于内存的管理。</p>
<h4 id="15-1-独享内存空间的原理"><a href="#15-1-独享内存空间的原理" class="headerlink" title="15.1 独享内存空间的原理"></a>15.1 独享内存空间的原理</h4><p>内存都被分成一块一块儿的，都编好了号。</p>
<p>操作系统会给进程分配一个虚拟地址。所有进程看到的这个地址都是一样的，里面的内存都是从0开始编号。</p>
<p>在程序里面，指令写入的地址是虚拟地址。例如，位置为10M的内存区域，操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。</p>
<p>当程序要访问虚拟地址的时候，由内核的数据结构进行转换，转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。</p>
<h4 id="15-2-规划虚拟地址空间"><a href="#15-2-规划虚拟地址空间" class="headerlink" title="15.2 规划虚拟地址空间"></a>15.2 规划虚拟地址空间</h4><p>操作系统的内存管理，主要分为三个方面。</p>
<ul>
<li>第一，物理内存的管理；</li>
<li>第二，虚拟地址的管理；</li>
<li>第三，虚拟地址和物理地址如何映射。</li>
</ul>
<p>接下来，我们都会围绕虚拟地址和物理地址展开。这两个概念有点绕，很多时候你可能会犯糊涂：这个地方，我们用的是虚拟地址呢，还是物理地址呢？所以，请你在学习这一章节的时候，时刻问自己这个问题。</p>
<p>一个程序：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token keyword">int</span> max_length <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span>

<span class="token keyword">char</span> <span class="token operator">*</span> <span class="token function">generate</span><span class="token punctuation">(</span><span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">int</span> i<span class="token punctuation">;</span>
  <span class="token keyword">char</span> <span class="token operator">*</span> buffer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span> <span class="token punctuation">(</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>buffer <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    buffer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">26</span><span class="token operator">+</span><span class="token string">'a'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  buffer<span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'\0'</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> buffer<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> num<span class="token punctuation">;</span>
  <span class="token keyword">char</span> <span class="token operator">*</span> buffer<span class="token punctuation">;</span>

  <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"Input the string length : "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">scanf</span> <span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span><span class="token punctuation">(</span>num <span class="token operator">&gt;</span> max_length<span class="token punctuation">)</span><span class="token punctuation">{</span>
    num <span class="token operator">=</span> max_length<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  buffer <span class="token operator">=</span> <span class="token function">generate</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"Random string is: %s\n"</span><span class="token punctuation">,</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">free</span> <span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个程序比较简单，就是根据用户输入的整数来生成字符串，最长是128。由于字符串的长度不是固定的，因而不能提前知道，需要动态地分配内存，使用malloc函数。当然用完了需要释放内存，这就要使用free函数。</p>
<p>我们来总结一下，这个简单的程序使用哪些内存的几种方式：</p>
<ul>
<li>代码需要放在内存里面；</li>
<li>全局变量，例如max_length；</li>
<li>常量字符串”Input the string length : “；</li>
<li>函数栈，例如局部变量num是作为参数传给generate函数的，这里面涉及了函数调用，局部变量，函数参数等都是保存在函数栈上面的；</li>
<li>堆，malloc分配的内存在堆里面；</li>
<li>这里面涉及对glibc的调用，所以glibc的代码是以so文件的形式存在的，也需要放在内存里面。</li>
</ul>
<p>这就完了吗？还没有呢，别忘了malloc会调用系统调用，进入内核，所以这个程序一旦运行起来，内核部分还需要分配内存：</p>
<ul>
<li>内核的代码要在内存里面；</li>
<li>内核中也有全局变量；</li>
<li>每个进程都要有一个task_struct；</li>
<li>每个进程还有一个内核栈；</li>
<li>在内核里面也有动态分配的内存；</li>
<li>虚拟地址到物理地址的映射表放在哪里？</li>
</ul>
<p>对于内存的访问，用户态的进程使用虚拟地址，这点毫无疑问，内核态的也基本都是使用虚拟地址，只有最后一项容易让人产生疑问。虚拟地址到物理地址的映射表，这个感觉起来是内存管理模块的一部分，这个是“实”是“虚”呢？这个问题先保留，我们暂不讨论，放到内存映射那一节见分晓。</p>
<p>既然都是虚拟地址，我们就先不管映射到物理地址以后是如何布局的，反正现在至少从“虚”的角度来看，这一大片连续的内存空间都是我的了。</p>
<p>首先，这么大的虚拟空间一切二，一部分用来放内核的东西，称为 <strong>内核空间</strong> ，一部分用来放进程的东西，称为 <strong>用户空间</strong> 。用户空间在下，在低地址，内核空间在上，在高地址。这两部分空间的分界线因为32位和64位的不同而不同。</p>
<p>对于普通进程来说，内核空间的那部分虽然虚拟地址在那里，但是不能访问。</p>
<p>我们从最低位开始排起，先是 <strong>Text Segment</strong> 、 <strong>Data Segment</strong> 和 <strong>BSS Segment</strong> 。Text Segment是存放二进制可执行代码的位置，Data Segment存放静态常量，BSS Segment存放未初始化的静态变量。是不是觉得这几个名字很熟悉？没错，咱们前面讲ELF格式的时候提到过，在二进制执行文件里面，就有这三个部分。这里就是把二进制执行文件的三个部分加载到内存里面。</p>
<p>接下来是 <strong>堆（Heap）段</strong> 。堆是往高地址增长的，是用来动态分配内存的区域，malloc就是在这里面分配的。</p>
<p>接下来的区域是 <strong>Memory Mapping Segment</strong> 。这块地址可以用来把文件映射进内存用的，如果二进制的执行文件依赖于某个动态链接库，就是在这个区域里面将so文件映射到了内存中。</p>
<p>再下面就是 <strong>栈（Stack）地址段</strong> 。主线程的函数调用的函数栈就是用这里的。</p>
<p>如果需要进行更高权限的工作，就需要调用系统调用，进入内核。</p>
<p>到了内核里面，无论是从哪个进程进来的，看到的都是同一个内核空间，看到的都是同一个进程列表。虽然内核栈是各用个的，但是如果想知道的话，还是能够知道每个进程的内核栈在哪里的。所以，如果要访问一些公共的数据结构，需要进行锁保护。</p>
<p>内核的代码访问内核的数据结构，大部分的情况下都是使用虚拟地址的，虽然内核代码权限很大，但是能够使用的虚拟地址范围也只能在内核空间，也即内核代码访问内核数据结构（不能访问用户空间）。</p>
<p>在内核里面也会有内核的代码，同样有Text Segment、Data Segment和BSS Segment，别忘了咱们讲内核启动的时候，内核代码也是ELF格式的。</p>
<h3 id="16-内存管理（下）"><a href="#16-内存管理（下）" class="headerlink" title="16. 内存管理（下）"></a>16. 内存管理（下）</h3><p>接下来，我们需要知道，如何将其映射成为物理地址呢？</p>
<p>你可能已经想到了，咱们前面讲x86 CPU的时候，讲过分段机制，咱们规划虚拟空间的时候，也是将空间分成多个段进行保存。</p>
<p>那就直接用分段机制呗。我们来看看分段机制的原理。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/分段机制的原理.jpg" alt="分段机制的原理"></p>
<p>分段机制下的虚拟地址由两部分组成， <strong>段选择子</strong> 和 <strong>段内偏移量</strong> 。段选择子就保存在咱们前面讲过的段寄存器里面。段选择子里面最重要的是段号，用作段表的索引。段表里面保存的是这个段的 <strong>基地址</strong> 、 <strong>段的界限</strong> 和 <strong>特权等级</strong> 等。虚拟地址中的段内偏移量应该位于0和段界限之间。如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。</p>
<p>我们来看看Linux是如何使用这个机制的。</p>
<p>在Linux里面，段表全称 <strong>段描述符表（segment descriptors）</strong> ，放在 <strong>全局描述符表GDT（Global Descriptor Table）</strong> 里面，会有下面的宏来初始化段描述符表里面的表项。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">GDT_ENTRY_INIT</span><span class="token punctuation">(</span>flags<span class="token punctuation">,</span> base<span class="token punctuation">,</span> limit<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">{</span> <span class="token punctuation">{</span> </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>limit<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xffff</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>base<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xffff</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>base<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff0000</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xf0ff</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> </span><span class="token punctuation">\</span>
            <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span>limit<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xf0000</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>base<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff000000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一个段表项由段基地址base、段界限limit，还有一些标识符组成。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">DEFINE_PER_CPU_PAGE_ALIGNED</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">gdt_page</span><span class="token punctuation">,</span> gdt_page<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span>gdt <span class="token operator">=</span> <span class="token punctuation">{</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_X86_64</span></span>
    <span class="token punctuation">[</span>GDT_ENTRY_KERNEL32_CS<span class="token punctuation">]</span>   <span class="token operator">=</span> <span class="token function">GDT_ENTRY_INIT</span><span class="token punctuation">(</span><span class="token number">0xc09b</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0xfffff</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>GDT_ENTRY_KERNEL_CS<span class="token punctuation">]</span>         <span class="token operator">=</span> <span class="token function">GDT_ENTRY_INIT</span><span class="token punctuation">(</span><span class="token number">0xa09b</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0xfffff</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>GDT_ENTRY_KERNEL_DS<span class="token punctuation">]</span>         <span class="token operator">=</span> <span class="token function">GDT_ENTRY_INIT</span><span class="token punctuation">(</span><span class="token number">0xc093</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0xfffff</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>GDT_ENTRY_DEFAULT_USER32_CS<span class="token punctuation">]</span>   <span class="token operator">=</span> <span class="token function">GDT_ENTRY_INIT</span><span class="token punctuation">(</span><span class="token number">0xc0fb</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0xfffff</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>GDT_ENTRY_DEFAULT_USER_DS<span class="token punctuation">]</span>  <span class="token operator">=</span> <span class="token function">GDT_ENTRY_INIT</span><span class="token punctuation">(</span><span class="token number">0xc0f3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0xfffff</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>GDT_ENTRY_DEFAULT_USER_CS<span class="token punctuation">]</span>  <span class="token operator">=</span> <span class="token function">GDT_ENTRY_INIT</span><span class="token punctuation">(</span><span class="token number">0xa0fb</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0xfffff</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
    <span class="token punctuation">[</span>GDT_ENTRY_KERNEL_CS<span class="token punctuation">]</span>         <span class="token operator">=</span> <span class="token function">GDT_ENTRY_INIT</span><span class="token punctuation">(</span><span class="token number">0xc09a</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0xfffff</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>GDT_ENTRY_KERNEL_DS<span class="token punctuation">]</span>         <span class="token operator">=</span> <span class="token function">GDT_ENTRY_INIT</span><span class="token punctuation">(</span><span class="token number">0xc092</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0xfffff</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>GDT_ENTRY_DEFAULT_USER_CS<span class="token punctuation">]</span>  <span class="token operator">=</span> <span class="token function">GDT_ENTRY_INIT</span><span class="token punctuation">(</span><span class="token number">0xc0fa</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0xfffff</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>GDT_ENTRY_DEFAULT_USER_DS<span class="token punctuation">]</span>  <span class="token operator">=</span> <span class="token function">GDT_ENTRY_INIT</span><span class="token punctuation">(</span><span class="token number">0xc0f2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0xfffff</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">EXPORT_PER_CPU_SYMBOL_GPL</span><span class="token punctuation">(</span>gdt_page<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面对于64位的和32位的，都定义了内核代码段、内核数据段、用户代码段和用户数据段。</p>
<p>另外，还会定义下面四个段选择子，指向上面的段描述符表项。这四个段选择子看着是不是有点眼熟？咱们讲内核初始化的时候，启动第一个用户态的进程，就是将这四个值赋值给段寄存器。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">__KERNEL_CS</span>     <span class="token punctuation">(</span>GDT_ENTRY_KERNEL_CS<span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">__KERNEL_DS</span>     <span class="token punctuation">(</span>GDT_ENTRY_KERNEL_DS<span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">__USER_DS</span>       <span class="token punctuation">(</span>GDT_ENTRY_DEFAULT_USER_DS<span class="token operator">*</span><span class="token number">8</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">__USER_CS</span>       <span class="token punctuation">(</span>GDT_ENTRY_DEFAULT_USER_CS<span class="token operator">*</span><span class="token number">8</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过分析，我们发现，所有的段的起始地址都是一样的，都是0。这算哪门子分段嘛！所以，在Linux操作系统中，并没有使用到全部的分段功能。那分段是不是完全没有用处呢？分段可以做权限审核，例如用户态DPL是3，内核态DPL是0。当用户态试图访问内核态的时候，会因为权限不足而报错。</p>
<p>其实Linux倾向于另外一种从虚拟地址到物理地址的转换方式，称为 <strong>分页（Paging）</strong> 。</p>
<p>对于物理内存，操作系统把它分成一块一块大小相同的页，这样更方便管理，例如有的内存页面长时间不用了，可以暂时写到硬盘上，称为 <strong>换出</strong> 。一旦需要的时候，再加载进来，叫作 <strong>换入</strong> 。这样可以扩大可用物理内存的大小，提高物理内存的利用率。</p>
<p>这个换入和换出都是以页为单位的。页面的大小一般为4KB。为了能够定位和访问每个页，需要有个页表，保存每个页的起始地址，再加上在页内的偏移量，组成线性地址，就能对于内存中的每个位置进行访问了。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/分页机制的原理.jpg" alt="分页机制的原理"></p>
<p>32位环境下，虚拟地址空间共4GB。如果分成4KB一个页，那就是1M个页。每个页表项需要4个字节来存储，那么整个4GB空间的映射就需要4MB的内存来存储映射表。如果每个进程都有自己的映射表，100个进程就需要400MB的内存。对于内核来讲，有点大了 。</p>
<p>页表中所有页表项必须提前建好，并且要求是连续的。如果不连续，就没有办法通过虚拟地址里面的页号找到对应的页表项了。</p>
<p>那怎么办呢？我们可以试着将页表再分页，4G的空间需要4M的页表来存储映射。我们把这4M分成1K（1024）个4K，每个4K又能放在一页里面，这样1K个4K就是1K个页，这1K个页也需要一个表进行管理，我们称为页目录表，这个页目录表里面有1K项，每项4个字节，页目录表大小也是4K。</p>
<p>页目录有1K项，用10位就可以表示访问页目录的哪一项。这一项其实对应的是一整页的页表项，也即4K的页表项。每个页表项也是4个字节，因而一整页的页表项是1K个。再用10位就可以表示访问页表项的哪一项，页表项中的一项对应的就是一个页，是存放数据的页，这个页的大小是4K，用12位可以定位这个页内的任何一个位置。</p>
<p>这样加起来正好32位，也就是用前10位定位到页目录表中的一项。将这一项对应的页表取出来共1k项，再用中间10位定位到页表中的一项，将这一项对应的存放数据的页取出来，再用最后12位定位到页中的具体位置访问数据。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/两级分页.jpg" alt="两级分页"></p>
<p>比如说，上面图中，我们假设只给这个进程分配了一个数据页。如果只使用页表，也需要完整的1M个页表项共4M的内存，但是如果使用了页目录，页目录需要1K个全部分配，占用内存4K，但是里面只有一项使用了。到了页表项，只需要分配能够管理那个数据页的页表项页就可以了，也就是说，最多4K，这样内存就节省多了。</p>
<p>当然对于64位的系统，两级肯定不够了，就变成了四级目录，分别是全局页目录项PGD（Page Global Directory）、上层页目录项PUD（Page Upper Directory）、中间页目录项PMD（Page Middle Directory）和页表项PTE（Page Table Entry）。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/四级分页.jpg" alt="四级分页"></p>
<h3 id="17-进程空间管理"><a href="#17-进程空间管理" class="headerlink" title="17. 进程空间管理"></a>17. 进程空间管理</h3><p>来详细看看进程的虚拟内存空间是如何管理的。</p>
<p>32位系统和64位系统的内存布局有的地方相似，有的地方差别比较大。</p>
<h4 id="17-1-用户态和内核态的划分"><a href="#17-1-用户态和内核态的划分" class="headerlink" title="17.1 用户态和内核态的划分"></a>17.1 用户态和内核态的划分</h4><p>task_struct里面有一个struct mm_struct结构来管理内存。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">mm_struct</span>        <span class="token operator">*</span>mm<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在struct mm_struct里面，有这样一个成员变量：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">long</span> task_size<span class="token punctuation">;</span>        <span class="token comment">/* size of task vm space */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>我们之前讲过，整个虚拟内存空间要一分为二，一部分是用户态地址空间，一部分是内核态地址空间，那这两部分的分界线在哪里呢？这就要task_size来定义。</p>
<p>对于32位的系统，内核里面是这样定义TASK_SIZE的：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_X86_32</span></span>
<span class="token comment">/*
 * User space process size: 3GB (default).
 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">TASK_SIZE         PAGE_OFFSET</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">TASK_SIZE_MAX      TASK_SIZE</span></span>
<span class="token comment">/*
config PAGE_OFFSET
        hex
        default 0xC0000000
        depends on X86_32
*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
<span class="token comment">/*
 * User space process size. 47bits minus one guard page.
*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">TASK_SIZE_MAX</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1UL</span> <span class="token operator">&lt;&lt;</span> <span class="token number">47</span><span class="token punctuation">)</span> <span class="token operator">-</span> PAGE_SIZE<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">TASK_SIZE</span>      <span class="token punctuation">(</span><span class="token function">test_thread_flag</span><span class="token punctuation">(</span>TIF_ADDR32<span class="token punctuation">)</span> <span class="token operator">?</span> </span><span class="token punctuation">\</span>
                            <span class="token expression">IA32_PAGE_OFFSET <span class="token operator">:</span> TASK_SIZE_MAX<span class="token punctuation">)</span></span></span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当执行一个新的进程的时候，会做以下的设置：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">current<span class="token operator">-&gt;</span>mm<span class="token operator">-&gt;</span>task_size <span class="token operator">=</span> TASK_SIZE<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>对于32位系统，最大能够寻址2^32=4G，其中用户态虚拟地址空间是3G，内核态是1G。</p>
<p>对于64位系统，虚拟地址只使用了48位。就像代码里面写的一样，1左移了47位，就相当于48位地址空间一半的位置，0x0000800000000000，然后减去一个页，就是0x00007FFFFFFFF000，共128T。同样，内核空间也是128T。内核空间和用户空间之间隔着很大的空隙，以此来进行隔离。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/用户态和内核态的划分.jpg" alt="用户态和内核态的划分"></p>
<h4 id="17-2-用户态布局"><a href="#17-2-用户态布局" class="headerlink" title="17.2 用户态布局"></a>17.2 用户态布局</h4><p>之前我们讲了用户态虚拟空间里面有几类数据，例如代码、全局变量、堆、栈、内存映射区等。在struct mm_struct里面，有下面这些变量定义了这些区域的统计信息和位置。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">long</span> mmap_base<span class="token punctuation">;</span>    <span class="token comment">/* base of mmap area */</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> total_vm<span class="token punctuation">;</span>  <span class="token comment">/* Total pages mapped */</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> locked_vm<span class="token punctuation">;</span>    <span class="token comment">/* Pages that have PG_mlocked set */</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> pinned_vm<span class="token punctuation">;</span>    <span class="token comment">/* Refcount permanently increased */</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> data_vm<span class="token punctuation">;</span>    <span class="token comment">/* VM_WRITE &amp; ~VM_SHARED &amp; ~VM_STACK */</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> exec_vm<span class="token punctuation">;</span>    <span class="token comment">/* VM_EXEC &amp; ~VM_WRITE &amp; ~VM_STACK */</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> stack_vm<span class="token punctuation">;</span>  <span class="token comment">/* VM_STACK */</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> start_code<span class="token punctuation">,</span> end_code<span class="token punctuation">,</span> start_data<span class="token punctuation">,</span> end_data<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> start_brk<span class="token punctuation">,</span> brk<span class="token punctuation">,</span> start_stack<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> arg_start<span class="token punctuation">,</span> arg_end<span class="token punctuation">,</span> env_start<span class="token punctuation">,</span> env_end<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，total_vm是总共映射的页的数目。我们知道，这么大的虚拟地址空间，不可能都有真实内存对应，所以这里是映射的数目。当内存吃紧的时候，有些页可以换出到硬盘上，有的页因为比较重要，不能换出。locked_vm就是被锁定不能换出，pinned_vm是不能换出，也不能移动。</p>
<p>data_vm是存放数据的页的数目，exec_vm是存放可执行文件的页的数目，stack_vm是栈所占的页的数目。</p>
<p>start_code和end_code表示可执行代码的开始和结束位置，start_data和end_data表示已初始化数据的开始位置和结束位置。</p>
<p>start_brk是堆的起始位置，brk是堆当前的结束位置。前面咱们讲过malloc申请一小块内存的话，就是通过改变brk位置实现的。</p>
<p>start_stack是栈的起始位置，栈的结束位置在寄存器的栈顶指针中。</p>
<p>arg_start和arg_end是参数列表的位置， env_start和env_end是环境变量的位置。它们都位于栈中最高地址的地方。</p>
<p>mmap_base表示虚拟地址空间中用于内存映射的起始地址。一般情况下，这个空间是从高地址到低地址增长的。前面咱们讲malloc申请一大块内存的时候，就是通过mmap在这里映射一块区域到物理内存。咱们加载动态链接库so文件，也是在这个区域里面，映射一块区域到so文件。</p>
<p>这下所有用户态的区域的位置基本上都描述清楚了。整个布局就像下面这张图这样。虽然32位和64位的空间相差很大，但是区域的类别和布局是相似的。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/用户态内存布局.jpg" alt="用户态内存布局"></p>
<p>除了位置信息之外，struct mm_struct里面还专门有一个结构vm_area_struct，来描述这些区域的属性。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span>mmap<span class="token punctuation">;</span>        <span class="token comment">/* list of VMAs */</span>
<span class="token keyword">struct</span> <span class="token class-name">rb_root</span> mm_rb<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这里面一个是单链表，用于将这些区域串起来。另外还有一个红黑树。又是这个数据结构，在进程调度的时候我们用的也是红黑树。它的好处就是查找和修改都很快。这里用红黑树，就是为了快速查找一个内存区域，并在需要改变的时候，能够快速修改。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token punctuation">{</span>
    <span class="token comment">/* The first cache line has the info for VMA tree walking. */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> vm_start<span class="token punctuation">;</span>  <span class="token comment">/* Our start address within vm_mm. */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> vm_end<span class="token punctuation">;</span>      <span class="token comment">/* The first byte after our end address within vm_mm. */</span>
    <span class="token comment">/* linked list of VM areas per task, sorted by address */</span>
    <span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span>vm_next<span class="token punctuation">,</span> <span class="token operator">*</span>vm_prev<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> vm_rb<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>vm_mm<span class="token punctuation">;</span>    <span class="token comment">/* The address space we belong to. */</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> anon_vma_chain<span class="token punctuation">;</span> <span class="token comment">/* Serialized by mmap_sem &amp;
                      * page_table_lock */</span>
    <span class="token keyword">struct</span> <span class="token class-name">anon_vma</span> <span class="token operator">*</span>anon_vma<span class="token punctuation">;</span>  <span class="token comment">/* Serialized by page_table_lock */</span>
    <span class="token comment">/* Function pointers to deal with this struct. */</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">vm_operations_struct</span> <span class="token operator">*</span>vm_ops<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span> vm_file<span class="token punctuation">;</span>    <span class="token comment">/* File we map to (can be NULL). */</span>
    <span class="token keyword">void</span> <span class="token operator">*</span> vm_private_data<span class="token punctuation">;</span>  <span class="token comment">/* was vm_pte (shared mem) */</span>
<span class="token punctuation">}</span> __randomize_layout<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>vm_start和vm_end指定了该区域在用户空间中的起始和结束地址。vm_next和vm_prev将这个区域串在链表上。vm_rb将这个区域放在红黑树上。vm_ops里面是对这个内存区域可以做的操作的定义。</p>
<p>虚拟内存区域可以映射到物理内存，也可以映射到文件，映射到物理内存的时候称为匿名映射，anon_vma中，anoy就是anonymous，匿名的意思，映射到文件就需要有vm_file指定被映射的文件。</p>
<p>那这些vm_area_struct是如何和上面的内存区域关联的呢？</p>
<p>这个事情是在load_elf_binary里面实现的。没错，就是它。加载内核的是它，启动第一个用户态进程init的是它，fork完了以后，调用exec运行一个二进制程序的也是它。</p>
<p>当exec运行一个二进制程序的时候，除了解析ELF的格式之外，另外一个重要的事情就是建立内存映射。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">load_elf_binary</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">linux_binprm</span> <span class="token operator">*</span>bprm<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token function">setup_new_exec</span><span class="token punctuation">(</span>bprm<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  retval <span class="token operator">=</span> <span class="token function">setup_arg_pages</span><span class="token punctuation">(</span>bprm<span class="token punctuation">,</span> <span class="token function">randomize_stack_top</span><span class="token punctuation">(</span>STACK_TOP<span class="token punctuation">)</span><span class="token punctuation">,</span>
                 executable_stack<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  error <span class="token operator">=</span> <span class="token function">elf_map</span><span class="token punctuation">(</span>bprm<span class="token operator">-&gt;</span>file<span class="token punctuation">,</span> load_bias <span class="token operator">+</span> vaddr<span class="token punctuation">,</span> elf_ppnt<span class="token punctuation">,</span>
                elf_prot<span class="token punctuation">,</span> elf_flags<span class="token punctuation">,</span> total_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  retval <span class="token operator">=</span> <span class="token function">set_brk</span><span class="token punctuation">(</span>elf_bss<span class="token punctuation">,</span> elf_brk<span class="token punctuation">,</span> bss_prot<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  elf_entry <span class="token operator">=</span> <span class="token function">load_elf_interp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loc<span class="token operator">-&gt;</span>interp_elf_ex<span class="token punctuation">,</span>
                        interpreter<span class="token punctuation">,</span>
                        <span class="token operator">&amp;</span>interp_map_addr<span class="token punctuation">,</span>
                        load_bias<span class="token punctuation">,</span> interp_elf_phdata<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  current<span class="token operator">-&gt;</span>mm<span class="token operator">-&gt;</span>end_code <span class="token operator">=</span> end_code<span class="token punctuation">;</span>
  current<span class="token operator">-&gt;</span>mm<span class="token operator">-&gt;</span>start_code <span class="token operator">=</span> start_code<span class="token punctuation">;</span>
  current<span class="token operator">-&gt;</span>mm<span class="token operator">-&gt;</span>start_data <span class="token operator">=</span> start_data<span class="token punctuation">;</span>
  current<span class="token operator">-&gt;</span>mm<span class="token operator">-&gt;</span>end_data <span class="token operator">=</span> end_data<span class="token punctuation">;</span>
  current<span class="token operator">-&gt;</span>mm<span class="token operator">-&gt;</span>start_stack <span class="token operator">=</span> bprm<span class="token operator">-&gt;</span>p<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>load_elf_binary会完成以下的事情：</p>
<ul>
<li>调用setup_new_exec，设置内存映射区mmap_base；</li>
<li>调用setup_arg_pages，设置栈的vm_area_struct，这里面设置了mm-&gt;arg_start是指向栈底的，current-&gt;mm-&gt;start_stack就是栈底；</li>
<li>elf_map会将ELF文件中的代码部分映射到内存中来；</li>
<li>set_brk设置了堆的vm_area_struct，这里面设置了current-&gt;mm-&gt;start_brk = current-&gt;mm-&gt;brk，也即堆里面还是空的；</li>
<li>load_elf_interp将依赖的so映射到内存中的内存映射区域。</li>
</ul>
<p>最终就形成下面这个内存映射图。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/load_elf_binary建立的内存映射图.jpeg" alt="load_elf_binary建立的内存映射图"></p>
<p>映射完毕后，什么情况下会修改呢？</p>
<p>第一种情况是函数的调用，涉及函数栈的改变，主要是改变栈顶指针。</p>
<p>第二种情况是通过malloc申请一个堆内的空间，当然底层要么执行brk，要么执行mmap。关于内存映射的部分，我们后面的章节讲，这里我们重点看一下brk是怎么做的。</p>
<p>brk系统调用实现的入口是sys_brk函数，就像下面代码定义的一样。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE1</span><span class="token punctuation">(</span>brk<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> brk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> retval<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> newbrk<span class="token punctuation">,</span> oldbrk<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>mm <span class="token operator">=</span> current<span class="token operator">-&gt;</span>mm<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    newbrk <span class="token operator">=</span> <span class="token function">PAGE_ALIGN</span><span class="token punctuation">(</span>brk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    oldbrk <span class="token operator">=</span> <span class="token function">PAGE_ALIGN</span><span class="token punctuation">(</span>mm<span class="token operator">-&gt;</span>brk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldbrk <span class="token operator">==</span> newbrk<span class="token punctuation">)</span>
        <span class="token keyword">goto</span> set_brk<span class="token punctuation">;</span>

    <span class="token comment">/* Always allow shrinking brk. */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>brk <span class="token operator">&lt;=</span> mm<span class="token operator">-&gt;</span>brk<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">do_munmap</span><span class="token punctuation">(</span>mm<span class="token punctuation">,</span> newbrk<span class="token punctuation">,</span> oldbrk<span class="token operator">-</span>newbrk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>uf<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">goto</span> set_brk<span class="token punctuation">;</span>
        <span class="token keyword">goto</span> out<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* Check against existing mmap mappings. */</span>
    next <span class="token operator">=</span> <span class="token function">find_vma</span><span class="token punctuation">(</span>mm<span class="token punctuation">,</span> oldbrk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">&amp;&amp;</span> newbrk <span class="token operator">+</span> PAGE_SIZE <span class="token operator">&gt;</span> <span class="token function">vm_start_gap</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">goto</span> out<span class="token punctuation">;</span>

    <span class="token comment">/* Ok, looks good - let it rip. */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">do_brk</span><span class="token punctuation">(</span>oldbrk<span class="token punctuation">,</span> newbrk<span class="token operator">-</span>oldbrk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>uf<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">goto</span> out<span class="token punctuation">;</span>

set_brk<span class="token operator">:</span>
    mm<span class="token operator">-&gt;</span>brk <span class="token operator">=</span> brk<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> brk<span class="token punctuation">;</span>
out<span class="token operator">:</span>
    retval <span class="token operator">=</span> mm<span class="token operator">-&gt;</span>brk<span class="token punctuation">;</span>
    <span class="token keyword">return</span> retval<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>前面我们讲过了，堆是从低地址向高地址增长的，sys_brk函数的参数brk是新的堆顶位置，而当前的mm-&gt;brk是原来堆顶的位置。</p>
<p>首先要做的第一个事情，将原来的堆顶和现在的堆顶，都按照页对齐地址，然后比较大小。如果两者相同，说明这次增加的堆的量很小，还在一个页里面，不需要另行分配页，直接跳到set_brk那里，设置mm-&gt;brk为新的brk就可以了。</p>
<p>如果发现新旧堆顶不在一个页里面，麻烦了，这下要跨页了。如果发现新堆顶小于旧堆顶，这说明不是新分配内存了，而是释放内存了，释放的还不小，至少释放了一页，于是调用do_munmap将这一页的内存映射去掉。</p>
<p>如果堆将要扩大，就要调用find_vma。如果打开这个函数，看到的是对红黑树的查找，找到的是原堆顶所在的vm_area_struct的下一个vm_area_struct，看当前的堆顶和下一个vm_area_struct之间还能不能分配一个完整的页。如果不能，没办法只好直接退出返回，内存空间都被占满了。</p>
<p>如果还有空间，就调用do_brk进一步分配堆空间，从旧堆顶开始，分配计算出的新旧堆顶之间的页数。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">do_brk</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> addr<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">list_head</span> <span class="token operator">*</span>uf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">do_brk_flags</span><span class="token punctuation">(</span>addr<span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> uf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">do_brk_flags</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> addr<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> request<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">list_head</span> <span class="token operator">*</span>uf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>mm <span class="token operator">=</span> current<span class="token operator">-&gt;</span>mm<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span>vma<span class="token punctuation">,</span> <span class="token operator">*</span>prev<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span><span class="token operator">*</span>rb_link<span class="token punctuation">,</span> <span class="token operator">*</span>rb_parent<span class="token punctuation">;</span>
    pgoff_t pgoff <span class="token operator">=</span> addr <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">;</span>
    <span class="token keyword">int</span> error<span class="token punctuation">;</span>


    len <span class="token operator">=</span> <span class="token function">PAGE_ALIGN</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">find_vma_links</span><span class="token punctuation">(</span>mm<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> addr <span class="token operator">+</span> len<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rb_link<span class="token punctuation">,</span>
                  <span class="token operator">&amp;</span>rb_parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    vma <span class="token operator">=</span> <span class="token function">vma_merge</span><span class="token punctuation">(</span>mm<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> addr <span class="token operator">+</span> len<span class="token punctuation">,</span> flags<span class="token punctuation">,</span>
            <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> pgoff<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> NULL_VM_UFFD_CTX<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>vma<span class="token punctuation">)</span>
        <span class="token keyword">goto</span> out<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    vma <span class="token operator">=</span> <span class="token function">kmem_cache_zalloc</span><span class="token punctuation">(</span>vm_area_cachep<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vma<span class="token operator">-&gt;</span>anon_vma_chain<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vma<span class="token operator">-&gt;</span>vm_mm <span class="token operator">=</span> mm<span class="token punctuation">;</span>
    vma<span class="token operator">-&gt;</span>vm_start <span class="token operator">=</span> addr<span class="token punctuation">;</span>
    vma<span class="token operator">-&gt;</span>vm_end <span class="token operator">=</span> addr <span class="token operator">+</span> len<span class="token punctuation">;</span>
    vma<span class="token operator">-&gt;</span>vm_pgoff <span class="token operator">=</span> pgoff<span class="token punctuation">;</span>
    vma<span class="token operator">-&gt;</span>vm_flags <span class="token operator">=</span> flags<span class="token punctuation">;</span>
    vma<span class="token operator">-&gt;</span>vm_page_prot <span class="token operator">=</span> <span class="token function">vm_get_page_prot</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">vma_link</span><span class="token punctuation">(</span>mm<span class="token punctuation">,</span> vma<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> rb_link<span class="token punctuation">,</span> rb_parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
out<span class="token operator">:</span>
    <span class="token function">perf_event_mmap</span><span class="token punctuation">(</span>vma<span class="token punctuation">)</span><span class="token punctuation">;</span>
    mm<span class="token operator">-&gt;</span>total_vm <span class="token operator">+=</span> len <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">;</span>
    mm<span class="token operator">-&gt;</span>data_vm <span class="token operator">+=</span> len <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> VM_LOCKED<span class="token punctuation">)</span>
        mm<span class="token operator">-&gt;</span>locked_vm <span class="token operator">+=</span> <span class="token punctuation">(</span>len <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vma<span class="token operator">-&gt;</span>vm_flags <span class="token operator">|=</span> VM_SOFTDIRTY<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在do_brk中，调用find_vma_links找到将来的vm_area_struct节点在红黑树的位置，找到它的父节点、前序节点。接下来调用vma_merge，看这个新节点是否能够和现有树中的节点合并。如果地址是连着的，能够合并，则不用创建新的vm_area_struct了，直接跳到out，更新统计值即可；如果不能合并，则创建新的vm_area_struct，既加到anon_vma_chain链表中，也加到红黑树中。</p>
<h4 id="17-3-内核态的布局"><a href="#17-3-内核态的布局" class="headerlink" title="17.3 内核态的布局"></a>17.3 内核态的布局</h4><p>内核态的虚拟空间和某一个进程没有关系，所有进程通过系统调用进入到内核之后，看到的虚拟地址空间都是一样的。</p>
<p>这里强调一下，千万别以为到了内核里面，咱们就会直接使用物理内存地址了，想当然地认为下面讨论的都是物理内存地址，不是的，这里讨论的还是虚拟内存地址，但是由于内核总是涉及管理物理内存，因而总是隐隐约约发生关系，所以这里必须思路清晰，分清楚物理内存地址和虚拟内存地址。</p>
<p>在内核态，32位和64位的布局差别比较大，主要是因为32位内核态空间太小了。</p>
<p>我们来看32位的内核态的布局。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/32位内核态的布局.jpg" alt="32位内核态的布局"></p>
<p>32位的内核态虚拟地址空间一共就1G，占绝大部分的前896M，我们称为 <strong>直接映射区</strong> 。</p>
<p>所谓的直接映射区，就是这一块空间是连续的，和物理内存是非常简单的映射关系，其实就是虚拟内存地址减去3G，就得到物理内存的位置。</p>
<p>在内核里面，有两个宏：</p>
<ul>
<li>__pa(vaddr) 返回与虚拟地址 vaddr 相关的物理地址；</li>
<li>__va(paddr) 则计算出对应于物理地址 paddr 的虚拟地址。</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">__va</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">+</span>PAGE_OFFSET<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">__pa</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>     <span class="token function">__phys_addr</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">__phys_addr</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>      <span class="token function">__phys_addr_nodebug</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">__phys_addr_nodebug</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">-</span> PAGE_OFFSET<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>但是你要注意，这里虚拟地址和物理地址发生了关联关系，在物理内存的开始的896M的空间，会被直接映射到3G至3G+896M的虚拟地址，这样容易给你一种感觉，是这些内存访问起来和物理内存差不多，别这样想，在大部分情况下，对于这一段内存的访问，在内核中，还是会使用虚拟地址的，并且将来也会为这一段空间建设页表，对这段地址的访问也会走上一节我们讲的分页地址的流程，只不过页表里面比较简单，是直接的一一对应而已。</p>
<p>这896M还需要仔细分解。在系统启动的时候，物理内存的前1M已经被占用了，从1M开始加载内核代码段，然后就是内核的全局变量、BSS等，也是ELF里面涵盖的。这样内核的代码段，全局变量，BSS也就会被映射到3G后的虚拟地址空间里面。具体的物理内存布局可以查看/proc/iomem。</p>
<p>在内核运行的过程中，如果碰到系统调用创建进程，会创建task_struct这样的实例，内核的进程管理代码会将实例创建在3G至3G+896M的虚拟空间中，当然也会被放在物理内存里面的前896M里面，相应的页表也会被创建。</p>
<p>在内核运行的过程中，会涉及内核栈的分配，内核的进程管理的代码会将内核栈创建在3G至3G+896M的虚拟空间中，当然也就会被放在物理内存里面的前896M里面，相应的页表也会被创建。</p>
<p>896M这个值在内核中被定义为high_memory，在此之上常称为“高端内存”。这是个很笼统的说法，到底是虚拟内存的3G+896M以上的是高端内存，还是物理内存896M以上的是高端内存呢？</p>
<p>这里仍然需要辨析一下，高端内存是物理内存的概念。它仅仅是内核中的内存管理模块看待物理内存的时候的概念。前面我们也说过，在内核中，除了内存管理模块直接操作物理地址之外，内核的其他模块，仍然要操作虚拟地址，而虚拟地址是需要内存管理模块分配和映射好的。</p>
<p>假设咱们的电脑有2G内存，现在如果内核的其他模块想要访问物理内存1.5G的地方，应该怎么办呢？如果你觉得，我有32位的总线，访问个2G还不小菜一碟，这就错了。</p>
<p>首先，你不能使用物理地址。你需要使用内存管理模块给你分配的虚拟地址，但是虚拟地址的0到3G已经被用户态进程占用去了，你作为内核不能使用。因为你写1.5G的虚拟内存位置，一方面你不知道应该根据哪个进程的页表进行映射；另一方面，就算映射了也不是你真正想访问的物理内存的地方，所以你发现你作为内核，能够使用的虚拟内存地址，只剩下1G减去896M的空间了。</p>
<p>于是，我们可以将剩下的虚拟内存地址分成下面这几个部分。</p>
<ul>
<li>在896M到VMALLOC_START之间有8M的空间。</li>
<li>VMALLOC_START到VMALLOC_END之间称为内核动态映射空间，也即内核想像用户态进程一样malloc申请内存，在内核里面可以使用vmalloc。假设物理内存里面，896M到1.5G之间已经被用户态进程占用了，并且映射关系放在了进程的页表中，内核vmalloc的时候，只能从分配物理内存1.5G开始，就需要使用这一段的虚拟地址进行映射，映射关系放在专门给内核自己用的页表里面。</li>
<li>PKMAP_BASE到FIXADDR_START的空间称为持久内核映射。使用alloc_pages()函数的时候，在物理内存的高端内存得到struct page结构，可以调用kmap将其在映射到这个区域。</li>
<li>FIXADDR_START到FIXADDR_TOP(0xFFFF F000)的空间，称为固定映射区域，主要用于满足特殊需求。</li>
<li>在最后一个区域可以通过kmap_atomic实现临时内核映射。假设用户态的进程要映射一个文件到内存中，先要映射用户态进程空间的一段虚拟地址到物理内存，然后将文件内容写入这个物理内存供用户态进程访问。给用户态进程分配物理内存页可以通过alloc_pages()，分配完毕后，按说将用户态进程虚拟地址和物理内存的映射关系放在用户态进程的页表中，就完事大吉了。这个时候，用户态进程可以通过用户态的虚拟地址，也即0至3G的部分，经过页表映射后访问物理内存，并不需要内核态的虚拟地址里面也划出一块来，映射到这个物理内存页。但是如果要把文件内容写入物理内存，这件事情要内核来干了，这就只好通过kmap_atomic做一个临时映射，写入物理内存完毕后，再kunmap_atomic来解映射即可。</li>
</ul>
<p>32位的内核态布局我们看完了，接下来我们再来看64位的内核布局。</p>
<p>其实64位的内核布局反而简单，因为虚拟空间实在是太大了，根本不需要所谓的高端内存，因为内核是128T，根本不可能有物理内存超过这个值。</p>
<p>64位的内存布局如图所示。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/64位内核态的布局.jpg" alt="64位内核态的布局"></p>
<p>64位的内核主要包含以下几个部分。</p>
<ul>
<li>从0xffff800000000000开始就是内核的部分，只不过一开始有8T的空档区域。</li>
<li>从__PAGE_OFFSET_BASE(0xffff880000000000)开始的64T的虚拟地址空间是直接映射区域，也就是减去PAGE_OFFSET就是物理地址。虚拟地址和物理地址之间的映射在大部分情况下还是会通过建立页表的方式进行映射。</li>
<li>从VMALLOC_START（0xffffc90000000000）开始到VMALLOC_END（0xffffe90000000000）的32T的空间是给vmalloc的。</li>
<li>从VMEMMAP_START（0xffffea0000000000）开始的1T空间用于存放物理页面的描述结构struct page的。</li>
<li>从<strong>START_KERNEL_map（0xffffffff80000000）开始的512M用于存放内核代码段、全局变量、BSS等。这里对应到物理内存开始的位置，减去</strong>START_KERNEL_map就能得到物理内存的地址。这里和直接映射区有点像，但是不矛盾，因为直接映射区之前有8T的空当区域，早就过了内核代码在物理内存中加载的位置。</li>
</ul>
<p>到这里内核中虚拟空间的布局就介绍完了。</p>
<h4 id="17-4-总结"><a href="#17-4-总结" class="headerlink" title="17.4 总结"></a>17.4 总结</h4><p>一个进程要运行起来需要以下的内存结构。</p>
<p>用户态：</p>
<ul>
<li>代码段、全局变量、BSS</li>
<li>函数栈</li>
<li>堆</li>
<li>内存映射区</li>
</ul>
<p>内核态：</p>
<ul>
<li>内核的代码、全局变量、BSS</li>
<li>内核数据结构例如task_struct</li>
<li>内核栈</li>
<li>内核中动态分配的内存</li>
</ul>
<p>我画了一个图，总结一下进程运行状态在32位下对应关系。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/进程运行状态在32位下对应关系.jpeg" alt="进程运行状态在32位下对应关系"></p>
<p>对于64位的对应关系，只是稍有区别，我这里也画了一个图，方便你对比理解。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/进程运行状态在64位下对应关系.jpeg" alt="进程运行状态在64位下对应关系"></p>
<h3 id="18-物理内存管理（上）"><a href="#18-物理内存管理（上）" class="headerlink" title="18. 物理内存管理（上）"></a>18. 物理内存管理（上）</h3><h4 id="18-1-物理内存的组织方式"><a href="#18-1-物理内存的组织方式" class="headerlink" title="18.1 物理内存的组织方式"></a>18.1 物理内存的组织方式</h4><p>前面咱们讲虚拟内存，涉及物理内存的映射的时候，我们总是把内存想象成它是由连续的一页一页的块组成的。我们可以从0开始对物理页编号，这样每个物理页都会有个页号。</p>
<p>由于物理地址是连续的，页也是连续的，每个页大小也是一样的。因而对于任何一个地址，只要直接除一下每页的大小，很容易直接算出在哪一页。每个页有一个结构struct page表示，这个结构也是放在一个数组里面，这样根据页号，很容易通过下标找到相应的struct page结构。</p>
<p>如果是这样，整个物理内存的布局就非常简单、易管理，这就是最经典的 <strong>平坦内存模型（Flat Memory Model）</strong> 。</p>
<p>我们讲x86的工作模式的时候，讲过CPU是通过总线去访问内存的，这就是最经典的内存使用方式。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/CPU是通过总线去访问内存.jpeg" alt="CPU是通过总线去访问内存"></p>
<p>在这种模式下，CPU也会有多个，在总线的一侧。所有的内存条组成一大片内存，在总线的另一侧，所有的CPU访问内存都要过总线，而且距离都是一样的，这种模式称为 <strong>SMP（Symmetric multiprocessing）</strong> ，即对称多处理器。当然，它也有一个显著的缺点，就是总线会成为瓶颈，因为数据都要走它。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/SMP和NUMA.jpeg" alt="SMP和NUMA"></p>
<p>为了提高性能和可扩展性，后来有了一种更高级的模式， <strong>NUMA（Non-uniform memory access）</strong> ，非一致内存访问。在这种模式下，内存不是一整块。每个CPU都有自己的本地内存，CPU访问本地内存不用过总线，因而速度要快很多， <strong>每个CPU和内存在一起，称为一个NUMA节点</strong> 。但是，在本地内存不足的情况下，每个CPU都可以去另外的NUMA节点申请内存，这个时候访问延时就会比较长。</p>
<p>这样，内存被分成了多个节点，每个节点再被分成一个一个的页面。由于页需要全局唯一定位，页还是需要有全局唯一的页号的。但是由于物理内存不是连起来的了，页号也就不再连续了。于是内存模型就变成了非连续内存模型，管理起来就复杂一些。</p>
<p>这里需要指出的是，NUMA往往是非连续内存模型。而非连续内存模型不一定就是NUMA，有时候一大片内存的情况下，也会有物理内存地址不连续的情况。</p>
<p>后来内存技术牛了，可以支持热插拔了。这个时候，不连续成为常态，于是就有了稀疏内存模型。</p>
<h4 id="18-2-节点"><a href="#18-2-节点" class="headerlink" title="18.2 节点"></a>18.2 节点</h4><p>我们主要解析当前的主流场景，NUMA方式。我们首先要能够表示NUMA节点的概念，于是有了下面这个结构typedef struct pglist_data pg_data_t，它里面有以下的成员变量：</p>
<ul>
<li>每一个节点都有自己的ID：node_id；</li>
<li>node_mem_map就是这个节点的struct page数组，用于描述这个节点里面的所有的页；</li>
<li>node_start_pfn是这个节点的起始页号；</li>
<li>node_spanned_pages是这个节点中包含不连续的物理内存地址的页面数；</li>
<li>node_present_pages是真正可用的物理页面的数目。</li>
</ul>
<p>例如，64M物理内存隔着一个4M的空洞，然后是另外的64M物理内存。这样换算成页面数目就是，16K个页面隔着1K个页面，然后是另外16K个页面。这种情况下，node_spanned_pages就是33K个页面，node_present_pages就是32K个页面。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">pglist_data</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">zone</span> node_zones<span class="token punctuation">[</span>MAX_NR_ZONES<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">zonelist</span> node_zonelists<span class="token punctuation">[</span>MAX_ZONELISTS<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> nr_zones<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>node_mem_map<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> node_start_pfn<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> node_present_pages<span class="token punctuation">;</span> <span class="token comment">/* total number of physical pages */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> node_spanned_pages<span class="token punctuation">;</span> <span class="token comment">/* total size of physical page range, including holes */</span>
    <span class="token keyword">int</span> node_id<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span> pg_data_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>每一个节点分成一个个区域zone，放在数组node_zones里面。这个数组的大小为MAX_NR_ZONES。我们来看区域的定义。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span> <span class="token class-name">zone_type</span> <span class="token punctuation">{</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_ZONE_DMA</span></span>
    ZONE_DMA<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_ZONE_DMA32</span></span>
    ZONE_DMA32<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    ZONE_NORMAL<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_HIGHMEM</span></span>
    ZONE_HIGHMEM<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    ZONE_MOVABLE<span class="token punctuation">,</span>
    __MAX_NR_ZONES
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>ZONE_DMA是指可用于作DMA（Direct Memory Access，直接内存存取）的内存。DMA是这样一种机制：要把外设的数据读入内存或把内存的数据传送到外设，原来都要通过CPU控制完成，但是这会占用CPU，影响CPU处理其他事情，所以有了DMA模式。CPU只需向DMA控制器下达指令，让DMA控制器来处理数据的传送，数据传送完毕再把信息反馈给CPU，这样就可以解放CPU。</p>
<p>对于64位系统，有两个DMA区域。除了上面说的ZONE_DMA，还有ZONE_DMA32。在这里你大概理解DMA的原理就可以，不必纠结，我们后面会讲DMA的机制。</p>
<p>ZONE_NORMAL是直接映射区，就是上一节讲的，从物理内存到虚拟内存的内核区域，通过加上一个常量直接映射。</p>
<p>ZONE_HIGHMEM是高端内存区，就是上一节讲的，对于32位系统来说超过896M的地方，对于64位没必要有的一段区域。</p>
<p>ZONE_MOVABLE是可移动区域，通过将物理内存划分为可移动分配区域和不可移动分配区域来避免内存碎片。</p>
<p>这里你需要注意一下，我们刚才对于区域的划分，都是针对物理内存的。</p>
<p>nr_zones表示当前节点的区域的数量。node_zonelists是备用节点和它的内存区域的情况。前面讲NUMA的时候，我们讲了CPU访问内存，本节点速度最快，但是如果本节点内存不够怎么办，还是需要去其他节点进行分配。毕竟，就算在备用节点里面选择，慢了点也比没有强。</p>
<p>既然整个内存被分成了多个节点，那pglist_data应该放在一个数组里面。每个节点一项，就像下面代码里面一样：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">pglist_data</span> <span class="token operator">*</span>node_data<span class="token punctuation">[</span>MAX_NUMNODES<span class="token punctuation">]</span> __read_mostly<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="18-3-区域"><a href="#18-3-区域" class="headerlink" title="18.3 区域"></a>18.3 区域</h4><p>到这里，我们把内存分成了节点，把节点分成了区域。接下来我们来看，一个区域里面是如何组织的。</p>
<p>表示区域的数据结构zone的定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">zone</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">struct</span> <span class="token class-name">pglist_data</span>  <span class="token operator">*</span>zone_pgdat<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">per_cpu_pageset</span> __percpu <span class="token operator">*</span>pageset<span class="token punctuation">;</span>


    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>      zone_start_pfn<span class="token punctuation">;</span>


    <span class="token comment">/*
     * spanned_pages is the total pages spanned by the zone, including
     * holes, which is calculated as:
     *  spanned_pages = zone_end_pfn - zone_start_pfn;
     *
     * present_pages is physical pages existing within the zone, which
     * is calculated as:
     *  present_pages = spanned_pages - absent_pages(pages in holes);
     *
     * managed_pages is present pages managed by the buddy system, which
     * is calculated as (reserved_pages includes pages allocated by the
     * bootmem allocator):
     *  managed_pages = present_pages - reserved_pages;
     *
     */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>      managed_pages<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>      spanned_pages<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>      present_pages<span class="token punctuation">;</span>


    <span class="token keyword">const</span> <span class="token keyword">char</span>      <span class="token operator">*</span>name<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* free areas of different sizes */</span>
    <span class="token keyword">struct</span> <span class="token class-name">free_area</span>    free_area<span class="token punctuation">[</span>MAX_ORDER<span class="token punctuation">]</span><span class="token punctuation">;</span>


    <span class="token comment">/* zone flags, see below */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>      flags<span class="token punctuation">;</span>


    <span class="token comment">/* Primarily protects free_area */</span>
    spinlock_t      lock<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span> ____cacheline_internodealigned_in_<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在一个zone里面，zone_start_pfn表示属于这个zone的第一个页。</p>
<p>如果我们仔细看代码的注释，可以看到，spanned_pages = zone_end_pfn - zone_start_pfn，也即spanned_pages指的是不管中间有没有物理内存空洞，反正就是最后的页号减去起始的页号。</p>
<p>present_pages = spanned_pages - absent_pages(pages in holes)，也即present_pages是这个zone在物理内存中真实存在的所有page数目。</p>
<p>managed_pages = present_pages - reserved_pages，也即managed_pages是这个zone被伙伴系统管理的所有的page数目，伙伴系统的工作机制我们后面会讲。</p>
<p>per_cpu_pageset用于区分冷热页。什么叫冷热页呢？咱们讲x86体系结构的时候讲过，为了让CPU快速访问段描述符，在CPU里面有段描述符缓存。CPU访问这个缓存的速度比内存快得多。同样对于页面来讲，也是这样的。如果一个页被加载到CPU高速缓存里面，这就是一个热页（Hot Page），CPU读起来速度会快很多，如果没有就是冷页（Cold Page）。由于每个CPU都有自己的高速缓存，因而per_cpu_pageset也是每个CPU一个。</p>
<h4 id="18-4-页"><a href="#18-4-页" class="headerlink" title="18.4 页"></a>18.4 页</h4><p>了解了区域zone，接下来我们就到了组成物理内存的基本单位，页的数据结构struct page。这是一个特别复杂的结构，里面有很多的union，union结构是在C语言中被用于同一块内存根据情况保存不同类型数据的一种方式。这里之所以用了union，是因为一个物理页面使用模式有多种。</p>
<p>第一种模式，要用就用一整页。这一整页的内存，或者直接和虚拟地址空间建立映射关系，我们把这种称为 <strong>匿名页（Anonymous Page）</strong> 。或者用于关联一个文件，然后再和虚拟地址空间建立映射关系，这样的文件，我们称为 <strong>内存映射文件（Memory-mapped File）</strong> 。</p>
<ul>
<li>struct address_space *mapping就是用于内存映射，如果是匿名页，最低位为1；如果是映射文件，最低位为0；</li>
<li>pgoff_t index是在映射区的偏移量；</li>
<li>atomic_t _mapcount，每个进程都有自己的页表，这里指有多少个页表项指向了这个页；</li>
<li>struct list_head lru表示这一页应该在一个链表上，例如这个页面被换出，就在换出页的链表中；</li>
<li>compound相关的变量用于复合页（Compound Page），就是将物理上连续的两个或多个页看成一个独立的大页。</li>
</ul>
<p>第二种模式，仅需分配小块内存。有时候，我们不需要一下子分配这么多的内存，例如分配一个task_struct结构，只需要分配小块的内存，去存储这个进程描述结构的对象。为了满足对这种小内存块的需要，Linux系统采用了一种被称为 <strong>slab allocator</strong> 的技术，用于分配称为slab的一小块内存。它的基本原理是从内存管理模块申请一整块页，然后划分成多个小块的存储池，用复杂的队列来维护这些小块的状态（状态包括：被分配了/被放回池子/应该被回收）。</p>
<p>也正是因为slab allocator对于队列的维护过于复杂，后来就有了一种不使用队列的分配器slub allocator，后面我们会解析这个分配器。但是你会发现，它里面还是用了很多slab的字眼，因为它保留了slab的用户接口，可以看成slab allocator的另一种实现。</p>
<p>还有一种小块内存的分配器称为 <strong>slob</strong> ，非常简单，主要使用在小型的嵌入式系统。</p>
<p>如果某一页是用于分割成一小块一小块的内存进行分配的使用模式，则会使用union中的以下变量：</p>
<ul>
<li>s_mem是已经分配了正在使用的slab的第一个对象；</li>
<li>freelist是池子中的空闲对象；</li>
<li>rcu_head是需要释放的列表。</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">address_space</span> <span class="token operator">*</span>mapping<span class="token punctuation">;</span>
        <span class="token keyword">void</span> <span class="token operator">*</span>s_mem<span class="token punctuation">;</span>                <span class="token comment">/* slab first object */</span>
        atomic_t compound_mapcount<span class="token punctuation">;</span> <span class="token comment">/* first tail page */</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        pgoff_t index<span class="token punctuation">;</span>      <span class="token comment">/* Our offset within mapping. */</span>
        <span class="token keyword">void</span> <span class="token operator">*</span>freelist<span class="token punctuation">;</span>   <span class="token comment">/* sl[aou]b first free object */</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token keyword">unsigned</span> counters<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token punctuation">{</span>
            <span class="token keyword">union</span> <span class="token punctuation">{</span>
                atomic_t _mapcount<span class="token punctuation">;</span>
                <span class="token keyword">unsigned</span> <span class="token keyword">int</span> active<span class="token punctuation">;</span>        <span class="token comment">/* SLAB */</span>
                <span class="token keyword">struct</span> <span class="token punctuation">{</span>                    <span class="token comment">/* SLUB */</span>
                    <span class="token keyword">unsigned</span> inuse<span class="token operator">:</span><span class="token number">16</span><span class="token punctuation">;</span>
                    <span class="token keyword">unsigned</span> objects<span class="token operator">:</span><span class="token number">15</span><span class="token punctuation">;</span>
                    <span class="token keyword">unsigned</span> frozen<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token punctuation">;</span>
                <span class="token keyword">int</span> units<span class="token punctuation">;</span>          <span class="token comment">/* SLOB */</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
            atomic_t _refcount<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">list_head</span> lru<span class="token punctuation">;</span>   <span class="token comment">/* Pageout list  */</span>
        <span class="token keyword">struct</span> <span class="token class-name">dev_pagemap</span> <span class="token operator">*</span>pgmap<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token punctuation">{</span>                <span class="token comment">/* slub per cpu partial pages */</span>
            <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>  <span class="token comment">/* Next partial slab */</span>
            <span class="token keyword">int</span> pages<span class="token punctuation">;</span>      <span class="token comment">/* Nr of partial slabs left */</span>
            <span class="token keyword">int</span> pobjects<span class="token punctuation">;</span>      <span class="token comment">/* Approximate # of objects */</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">rcu_head</span> rcu_head<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token punctuation">{</span>
            <span class="token keyword">unsigned</span> <span class="token keyword">long</span> compound_head<span class="token punctuation">;</span> <span class="token comment">/* If bit zero is set */</span>
            <span class="token keyword">unsigned</span> <span class="token keyword">int</span> compound_dtor<span class="token punctuation">;</span>
            <span class="token keyword">unsigned</span> <span class="token keyword">int</span> compound_order<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> private<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>slab_cache<span class="token punctuation">;</span>  <span class="token comment">/* SL[AU]B: Pointer to slab */</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="18-5-页的分配"><a href="#18-5-页的分配" class="headerlink" title="18.5 页的分配"></a>18.5 页的分配</h4><p>对于要分配比较大的内存，例如到分配页级别的，可以使用 <strong>伙伴系统（Buddy System）</strong> 。</p>
<p>Linux中的内存管理的“页”大小为4KB。把所有的空闲页分组为11个页块链表，每个块链表分别包含很多个大小的页块，有1、2、4、8、16、32、64、128、256、512和1024个连续页的页块。最大可以申请1024个连续页，对应4MB大小的连续内存。每个页块的第一个页的物理地址是该页块大小的整数倍。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/伙伴系统.jpeg" alt="伙伴系统"></p>
<p>第i个页块链表中，页块中页的数目为2^i。</p>
<p>在struct zone里面有以下的定义：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">free_area</span>    free_area<span class="token punctuation">[</span>MAX_ORDER<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>MAX_ORDER就是指数。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">MAX_ORDER <span class="token number">11</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当向内核请求分配(2^(i-1)，2^i]数目的页块时，按照2^i页块请求处理。如果对应的页块链表中没有空闲页块，那我们就在更大的页块链表中去找。当分配的页块中有多余的页时，伙伴系统会根据多余的页块大小插入到对应的空闲页块链表中。</p>
<p>例如，要请求一个128个页的页块时，先检查128个页的页块链表是否有空闲块。如果没有，则查256个页的页块链表；如果有空闲块的话，则将256个页的页块分成两份，一份使用，一份插入128个页的页块链表中。如果还是没有，就查512个页的页块链表；如果有的话，就分裂为128、128、256三个页块，一个128的使用，剩余两个插入对应页块链表。</p>
<p>上面这个过程，我们可以在分配页的函数alloc_pages中看到。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>
<span class="token function">alloc_pages</span><span class="token punctuation">(</span>gfp_t gfp_mask<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> order<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">alloc_pages_current</span><span class="token punctuation">(</span>gfp_mask<span class="token punctuation">,</span> order<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">/**
 *  alloc_pages_current - Allocate pages.
 *
 *  @gfp:
 *    %GFP_USER   user allocation,
 *      %GFP_KERNEL kernel allocation,
 *      %GFP_HIGHMEM highmem allocation,
 *      %GFP_FS  don't call back into a file system.
 *      %GFP_ATOMIC don't sleep.
 *  @order: Power of two of allocation size in pages. 0 is a single page.
 *
 *  Allocate a page from the kernel page pool.  When not in
 *  interrupt context and apply the current process NUMA policy.
 *  Returns NULL when no page can be allocated.
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span><span class="token function">alloc_pages_current</span><span class="token punctuation">(</span>gfp_t gfp<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> order<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">mempolicy</span> <span class="token operator">*</span>pol <span class="token operator">=</span> <span class="token operator">&amp;</span>default_policy<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    page <span class="token operator">=</span> <span class="token function">__alloc_pages_nodemask</span><span class="token punctuation">(</span>gfp<span class="token punctuation">,</span> order<span class="token punctuation">,</span>
                <span class="token function">policy_node</span><span class="token punctuation">(</span>gfp<span class="token punctuation">,</span> pol<span class="token punctuation">,</span> <span class="token function">numa_node_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token function">policy_nodemask</span><span class="token punctuation">(</span>gfp<span class="token punctuation">,</span> pol<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> page<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>alloc_pages会调用alloc_pages_current，这里面的注释比较容易看懂了，gfp表示希望在哪个区域中分配这个内存：</p>
<ul>
<li>GFP_USER用于分配一个页映射到用户进程的虚拟地址空间，并且希望直接被内核或者硬件访问，主要用于一个用户进程希望通过内存映射的方式，访问某些硬件的缓存，例如显卡缓存；</li>
<li>GFP_KERNEL用于内核中分配页，主要分配ZONE_NORMAL区域，也即直接映射区；</li>
<li>GFP_HIGHMEM，顾名思义就是主要分配高端区域的内存。</li>
</ul>
<p>另一个参数order，就是表示分配2的order次方个页。</p>
<p>接下来调用__alloc_pages_nodemask。这是伙伴系统的核心方法。它会调用get_page_from_freelist。这里面的逻辑也很容易理解，就是在一个循环中先看当前节点的zone。如果找不到空闲页，则再看备用节点的zone。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>
<span class="token function">get_page_from_freelist</span><span class="token punctuation">(</span>gfp_t gfp_mask<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> order<span class="token punctuation">,</span> <span class="token keyword">int</span> alloc_flags<span class="token punctuation">,</span>
                        <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">alloc_context</span> <span class="token operator">*</span>ac<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">for_next_zone_zonelist_nodemask</span><span class="token punctuation">(</span>zone<span class="token punctuation">,</span> z<span class="token punctuation">,</span> ac<span class="token operator">-&gt;</span>zonelist<span class="token punctuation">,</span> ac<span class="token operator">-&gt;</span>high_zoneidx<span class="token punctuation">,</span> ac<span class="token operator">-&gt;</span>nodemask<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        page <span class="token operator">=</span> <span class="token function">rmqueue</span><span class="token punctuation">(</span>ac<span class="token operator">-&gt;</span>preferred_zoneref<span class="token operator">-&gt;</span>zone<span class="token punctuation">,</span> zone<span class="token punctuation">,</span> order<span class="token punctuation">,</span>
                gfp_mask<span class="token punctuation">,</span> alloc_flags<span class="token punctuation">,</span> ac<span class="token operator">-&gt;</span>migratetype<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>每一个zone，都有伙伴系统维护的各种大小的队列，就像上面伙伴系统原理里讲的那样。这里调用rmqueue就很好理解了，就是找到合适大小的那个队列，把页面取下来。</p>
<p>接下来的调用链是rmqueue-&gt;<strong>rmqueue-&gt;</strong>rmqueue_smallest。在这里，我们能清楚看到伙伴系统的逻辑。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span>
<span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span><span class="token function">__rmqueue_smallest</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">zone</span> <span class="token operator">*</span>zone<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> order<span class="token punctuation">,</span>
                        <span class="token keyword">int</span> migratetype<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> current_order<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">free_area</span> <span class="token operator">*</span>area<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>


    <span class="token comment">/* Find a page of the appropriate size in the preferred list */</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>current_order <span class="token operator">=</span> order<span class="token punctuation">;</span> current_order <span class="token operator">&lt;</span> MAX_ORDER<span class="token punctuation">;</span> <span class="token operator">++</span>current_order<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        area <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>zone<span class="token operator">-&gt;</span>free_area<span class="token punctuation">[</span>current_order<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        page <span class="token operator">=</span> <span class="token function">list_first_entry_or_null</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>area<span class="token operator">-&gt;</span>free_list<span class="token punctuation">[</span>migratetype<span class="token punctuation">]</span><span class="token punctuation">,</span>
                            <span class="token keyword">struct</span> <span class="token class-name">page</span><span class="token punctuation">,</span> lru<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>page<span class="token punctuation">)</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token function">list_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>page<span class="token operator">-&gt;</span>lru<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">rmv_page_order</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span>
        area<span class="token operator">-&gt;</span>nr_free<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token function">expand</span><span class="token punctuation">(</span>zone<span class="token punctuation">,</span> page<span class="token punctuation">,</span> order<span class="token punctuation">,</span> current_order<span class="token punctuation">,</span> area<span class="token punctuation">,</span> migratetype<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">set_pcppage_migratetype</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> migratetype<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> page<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从当前的order，也即指数开始，在伙伴系统的free_area找2^order大小的页块。如果链表的第一个不为空，就找到了；如果为空，就到更大的order的页块链表里面去找。找到以后，除了将页块从链表中取下来，我们还要把多余的的部分放到其他页块链表里面。expand就是干这个事情的。area–就是伙伴系统那个表里面的前一项，前一项里面的页块大小是当前项的页块大小除以2，size右移一位也就是除以2，list_add就是加到链表上，nr_free++就是计数加1。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">expand</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">zone</span> <span class="token operator">*</span>zone<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">,</span>
    <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">free_area</span> <span class="token operator">*</span>area<span class="token punctuation">,</span>
    <span class="token keyword">int</span> migratetype<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> high<span class="token punctuation">;</span>


    <span class="token keyword">while</span> <span class="token punctuation">(</span>high <span class="token operator">&gt;</span> low<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        area<span class="token operator">--</span><span class="token punctuation">;</span>
        high<span class="token operator">--</span><span class="token punctuation">;</span>
        size <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token function">list_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>page<span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">.</span>lru<span class="token punctuation">,</span> <span class="token operator">&amp;</span>area<span class="token operator">-&gt;</span>free_list<span class="token punctuation">[</span>migratetype<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        area<span class="token operator">-&gt;</span>nr_free<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token function">set_page_order</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>page<span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="18-6-总结"><a href="#18-6-总结" class="headerlink" title="18.6 总结"></a>18.6 总结</h4><p>如果有多个CPU，那就有多个节点。每个节点用struct pglist_data表示，放在一个数组里面。</p>
<p>每个节点分为多个区域，每个区域用struct zone表示，也放在一个数组里面。</p>
<p>每个区域分为多个页。为了方便分配，空闲页放在struct free_area里面，使用伙伴系统进行管理和分配，每一页用struct page表示。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/物理内存的组织形式.jpeg" alt="物理内存的组织形式"></p>
<h3 id="19-物理内存管理（下）"><a href="#19-物理内存管理（下）" class="headerlink" title="19. 物理内存管理（下）"></a>19. 物理内存管理（下）</h3><h4 id="19-1-小内存的分配"><a href="#19-1-小内存的分配" class="headerlink" title="19.1 小内存的分配"></a>19.1 小内存的分配</h4><p>前面我们讲过，如果遇到小的对象，会使用slub分配器进行分配。那我们就先来解析它的工作原理。</p>
<p>还记得咱们创建进程的时候，会调用dup_task_struct，它想要试图复制一个task_struct对象，需要先调用alloc_task_struct_node，分配一个task_struct对象。</p>
<p>从这段代码可以看出，它调用了kmem_cache_alloc_node函数，在task_struct的缓存区域task_struct_cachep分配了一块内存。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>task_struct_cachep<span class="token punctuation">;</span>

task_struct_cachep <span class="token operator">=</span> <span class="token function">kmem_cache_create</span><span class="token punctuation">(</span><span class="token string">"task_struct"</span><span class="token punctuation">,</span>
            arch_task_struct_size<span class="token punctuation">,</span> align<span class="token punctuation">,</span>
            SLAB_PANIC<span class="token operator">|</span>SLAB_NOTRACK<span class="token operator">|</span>SLAB_ACCOUNT<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token function">alloc_task_struct_node</span><span class="token punctuation">(</span><span class="token keyword">int</span> node<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">kmem_cache_alloc_node</span><span class="token punctuation">(</span>task_struct_cachep<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">free_task_struct</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">kmem_cache_free</span><span class="token punctuation">(</span>task_struct_cachep<span class="token punctuation">,</span> tsk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在系统初始化的时候，task_struct_cachep会被kmem_cache_create函数创建。这个函数也比较容易看懂，专门用于分配task_struct对象的缓存。这个缓存区的名字就叫task_struct。缓存区中每一块的大小正好等于task_struct的大小，也即arch_task_struct_size。</p>
<p>有了这个缓存区，每次创建task_struct的时候，我们不用到内存里面去分配，先在缓存里面看看有没有直接可用的，这就是 <strong>kmem_cache_alloc_node</strong> 的作用。</p>
<p>当一个进程结束，task_struct也不用直接被销毁，而是放回到缓存中，这就是 <strong>kmem_cache_free</strong> 的作用。这样，新进程创建的时候，我们就可以直接用现成的缓存中的task_struct了。</p>
<p>我们来仔细看看，缓存区struct kmem_cache到底是什么样子。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_cpu</span> __percpu <span class="token operator">*</span>cpu_slab<span class="token punctuation">;</span>
    <span class="token comment">/* Used for retriving partial slabs etc */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> min_partial<span class="token punctuation">;</span>
    <span class="token keyword">int</span> size<span class="token punctuation">;</span>            <span class="token comment">/* The size of an object including meta data */</span>
    <span class="token keyword">int</span> object_size<span class="token punctuation">;</span>        <span class="token comment">/* The size of an object without meta data */</span>
    <span class="token keyword">int</span> offset<span class="token punctuation">;</span>    <span class="token comment">/* Free pointer offset. */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_SLUB_CPU_PARTIAL</span></span>
    <span class="token keyword">int</span> cpu_partial<span class="token punctuation">;</span>        <span class="token comment">/* Number of per cpu partial objects to keep around */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_order_objects</span> oo<span class="token punctuation">;</span>
    <span class="token comment">/* Allocation and freeing of slabs */</span>
    <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_order_objects</span> max<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_order_objects</span> min<span class="token punctuation">;</span>
    gfp_t allocflags<span class="token punctuation">;</span>      <span class="token comment">/* gfp flags to use on each alloc */</span>
    <span class="token keyword">int</span> refcount<span class="token punctuation">;</span>         <span class="token comment">/* Refcount for slab cache destroy */</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>ctor<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>      <span class="token comment">/* Name (only for display!) */</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> list<span class="token punctuation">;</span>  <span class="token comment">/* List of slab caches */</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_node</span> <span class="token operator">*</span>node<span class="token punctuation">[</span>MAX_NUMNODES<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在struct kmem_cache里面，有个变量struct list_head list，这个结构我们已经看到过多次了。我们可以想象一下，对于操作系统来讲，要创建和管理的缓存绝对不止task_struct。难道mm_struct就不需要吗？fs_struct就不需要吗？都需要。因此，所有的缓存最后都会放在一个链表里面，也就是LIST_HEAD(slab_caches)。</p>
<p>对于缓存来讲，其实就是分配了连续几页的大内存块，然后根据缓存对象的大小，切成小内存块。</p>
<p>所以，我们这里有三个kmem_cache_order_objects类型的变量。这里面的order，就是2的order次方个页面的大内存块，objects就是能够存放的缓存对象的数量。</p>
<p>最终，我们将大内存块切分成小内存块，样子就像下面这样。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/将大内存块切分成小内存块.jpeg" alt="将大内存块切分成小内存块"></p>
<p>每一项的结构都是缓存对象后面跟一个下一个空闲对象的指针，这样非常方便将所有的空闲对象链成一个链。其实，这就相当于咱们数据结构里面学的， <strong>用数组实现一个可随机插入和删除的链表</strong> 。</p>
<p>所以，这里面就有三个变量：size是包含这个指针的大小，object_size是纯对象的大小，offset就是把下一个空闲对象的指针存放在这一项里的偏移量。</p>
<p>那这些缓存对象哪些被分配了、哪些在空着，什么情况下整个大内存块都被分配完了，需要向伙伴系统申请几个页形成新的大内存块？这些信息该由谁来维护呢？</p>
<p>接下来就是最重要的两个成员变量出场的时候了。kmem_cache_cpu和kmem_cache_node，它们都是每个NUMA节点上有一个，我们只需要看一个节点里面的情况。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/kmem_cache_cpu和kmem_cache_node.jpeg" alt="kmem_cache_cpu和kmem_cache_node"></p>
<p>在分配缓存块的时候，要分两种路径，<strong>fast path</strong>和<strong>slow path</strong>，也就是<strong>快速通道</strong>和<strong>普通通道</strong>。其中kmem_cache_cpu就是快速通道，kmem_cache_node是普通通道。每次分配的时候，要先从kmem_cache_cpu进行分配。如果kmem_cache_cpu里面没有空闲的块，那就到kmem_cache_node中进行分配；如果还是没有空闲的块，才去伙伴系统分配新的页。</p>
<p>我们来看一下，kmem_cache_cpu里面是如何存放缓存块的。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">kmem_cache_cpu</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>freelist<span class="token punctuation">;</span>        <span class="token comment">/* Pointer to next available object */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> tid<span class="token punctuation">;</span>    <span class="token comment">/* Globally unique transaction id */</span>
    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>    <span class="token comment">/* The slab from which we are allocating */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_SLUB_CPU_PARTIAL</span></span>
    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>partial<span class="token punctuation">;</span>   <span class="token comment">/* Partially allocated frozen slabs */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里，page指向大内存块的第一个页，缓存块就是从里面分配的。freelist指向大内存块里面第一个空闲的项。按照上面说的，这一项会有指针指向下一个空闲的项，最终所有空闲的项会形成一个链表。</p>
<p>partial指向的也是大内存块的第一个页，之所以名字叫partial（部分），就是因为它里面部分被分配出去了，部分是空的。这是一个备用列表，当page满了，就会从这里找。</p>
<p>我们再来看kmem_cache_node的定义。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">kmem_cache_node</span> <span class="token punctuation">{</span>
    spinlock_t list_lock<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_SLUB</span></span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> nr_partial<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> partial<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面也有一个partial，是一个链表。这个链表里存放的是部分空闲的大内存块。这是kmem_cache_cpu里面的partial的备用列表，如果那里没有，就到这里来找。</p>
<p>下面我们就来看看这个分配过程。kmem_cache_alloc_node会调用slab_alloc_node。你还是先重点看这里面的注释，这里面说的就是快速通道和普通通道的概念。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * Inlined fastpath so that allocation functions (kmalloc, kmem_cache_alloc)
 * have the fastpath folded into their functions. So no function call
 * overhead for requests that can be satisfied on the fastpath.
 *
 * The fastpath works by first checking if the lockless freelist can be used.
 * If not then __slab_alloc is called for slow processing.
 *
 * Otherwise we can simply pick the next object from the lockless free list.
 */</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">slab_alloc_node</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>s<span class="token punctuation">,</span>
        gfp_t gfpflags<span class="token punctuation">,</span> <span class="token keyword">int</span> node<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> addr<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>object<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_cpu</span> <span class="token operator">*</span>c<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> tid<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    tid <span class="token operator">=</span> <span class="token function">this_cpu_read</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>cpu_slab<span class="token operator">-&gt;</span>tid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    c <span class="token operator">=</span> <span class="token function">raw_cpu_ptr</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>cpu_slab<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    object <span class="token operator">=</span> c<span class="token operator">-&gt;</span>freelist<span class="token punctuation">;</span>
    page <span class="token operator">=</span> c<span class="token operator">-&gt;</span>page<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>object <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">node_match</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        object <span class="token operator">=</span> <span class="token function">__slab_alloc</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> gfpflags<span class="token punctuation">,</span> node<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">stat</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> ALLOC_SLOWPATH<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> object<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>快速通道很简单，取出cpu_slab也即kmem_cache_cpu的freelist，这就是第一个空闲的项，可以直接返回了。如果没有空闲的了，则只好进入普通通道，调用__slab_alloc。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">___slab_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> gfp_t gfpflags<span class="token punctuation">,</span> <span class="token keyword">int</span> node<span class="token punctuation">,</span>
              <span class="token keyword">unsigned</span> <span class="token keyword">long</span> addr<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_cpu</span> <span class="token operator">*</span>c<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>freelist<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
redo<span class="token operator">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* must check again c-&gt;freelist in case of cpu migration or IRQ */</span>
    freelist <span class="token operator">=</span> c<span class="token operator">-&gt;</span>freelist<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>freelist<span class="token punctuation">)</span>
        <span class="token keyword">goto</span> load_freelist<span class="token punctuation">;</span>

    freelist <span class="token operator">=</span> <span class="token function">get_freelist</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> page<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>freelist<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        c<span class="token operator">-&gt;</span>page <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token function">stat</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> DEACTIVATE_BYPASS<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> new_slab<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

load_freelist<span class="token operator">:</span>
    c<span class="token operator">-&gt;</span>freelist <span class="token operator">=</span> <span class="token function">get_freepointer</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> freelist<span class="token punctuation">)</span><span class="token punctuation">;</span>
    c<span class="token operator">-&gt;</span>tid <span class="token operator">=</span> <span class="token function">next_tid</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>tid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> freelist<span class="token punctuation">;</span>

new_slab<span class="token operator">:</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">slub_percpu_partial</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        page <span class="token operator">=</span> c<span class="token operator">-&gt;</span>page <span class="token operator">=</span> <span class="token function">slub_percpu_partial</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">slub_set_percpu_partial</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> page<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">stat</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> CPU_PARTIAL_ALLOC<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> redo<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    freelist <span class="token operator">=</span> <span class="token function">new_slab_objects</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> gfpflags<span class="token punctuation">,</span> node<span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> freeli<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里，我们首先再次尝试一下kmem_cache_cpu的freelist。为什么呢？万一当前进程被中断，等回来的时候，别人已经释放了一些缓存，说不定又有空间了呢。如果找到了，就跳到load_freelist，在这里将freelist指向下一个空闲项，返回就可以了。</p>
<p>如果freelist还是没有，则跳到new_slab里面去。这里面我们先去kmem_cache_cpu的partial里面看。如果partial不是空的，那就将kmem_cache_cpu的page，也就是快速通道的那一大块内存，替换为partial里面的大块内存。然后redo，重新试下。这次应该就可以成功了。</p>
<p>如果真的还不行，那就要到new_slab_objects了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">new_slab_objects</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> gfp_t flags<span class="token punctuation">,</span>
            <span class="token keyword">int</span> node<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_cpu</span> <span class="token operator">*</span><span class="token operator">*</span>pc<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>freelist<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_cpu</span> <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token operator">*</span>pc<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>

    freelist <span class="token operator">=</span> <span class="token function">get_partial</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> node<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>freelist<span class="token punctuation">)</span>
        <span class="token keyword">return</span> freelist<span class="token punctuation">;</span>

    page <span class="token operator">=</span> <span class="token function">new_slab</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>page<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        c <span class="token operator">=</span> <span class="token function">raw_cpu_ptr</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>cpu_slab<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>page<span class="token punctuation">)</span>
            <span class="token function">flush_slab</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>

        freelist <span class="token operator">=</span> page<span class="token operator">-&gt;</span>freelist<span class="token punctuation">;</span>
        page<span class="token operator">-&gt;</span>freelist <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

        <span class="token function">stat</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> ALLOC_SLAB<span class="token punctuation">)</span><span class="token punctuation">;</span>
        c<span class="token operator">-&gt;</span>page <span class="token operator">=</span> page<span class="token punctuation">;</span>
        <span class="token operator">*</span>pc <span class="token operator">=</span> c<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span>
        freelist <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> freelist<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里面，get_partial会根据node id，找到相应的kmem_cache_node，然后调用get_partial_node，开始在这个节点进行分配。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * Try to allocate a partial slab from a specific node.
 */</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">get_partial_node</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_node</span> <span class="token operator">*</span>n<span class="token punctuation">,</span>
                <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_cpu</span> <span class="token operator">*</span>c<span class="token punctuation">,</span> gfp_t flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">,</span> <span class="token operator">*</span>page2<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>object <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> available <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> objects<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">list_for_each_entry_safe</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> page2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token operator">-&gt;</span>partial<span class="token punctuation">,</span> lru<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">void</span> <span class="token operator">*</span>t<span class="token punctuation">;</span>

        t <span class="token operator">=</span> <span class="token function">acquire_slab</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> n<span class="token punctuation">,</span> page<span class="token punctuation">,</span> object <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>objects<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>t<span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>

        available <span class="token operator">+=</span> objects<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>object<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            c<span class="token operator">-&gt;</span>page <span class="token operator">=</span> page<span class="token punctuation">;</span>
            <span class="token function">stat</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> ALLOC_FROM_PARTIAL<span class="token punctuation">)</span><span class="token punctuation">;</span>
            object <span class="token operator">=</span> t<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">put_cpu_partial</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> page<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">stat</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> CPU_PARTIAL_NODE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">kmem_cache_has_cpu_partial</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
            <span class="token operator">||</span> available <span class="token operator">&gt;</span> <span class="token function">slub_cpu_partial</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> object<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>acquire_slab会从kmem_cache_node的partial链表中拿下一大块内存来，并且将freelist，也就是第一块空闲的缓存块，赋值给t。并且当第一轮循环的时候，将kmem_cache_cpu的page指向取下来的这一大块内存，返回的object就是这块内存里面的第一个缓存块t。如果kmem_cache_cpu也有一个partial，就会进行第二轮，再次取下一大块内存来，这次调用put_cpu_partial，放到kmem_cache_cpu的partial里面。</p>
<p>如果kmem_cache_node里面也没有空闲的内存，这就说明原来分配的页里面都放满了，就要回到new_slab_objects函数，里面new_slab函数会调用allocate_slab。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span><span class="token function">allocate_slab</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> gfp_t flags<span class="token punctuation">,</span> <span class="token keyword">int</span> node<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_order_objects</span> oo <span class="token operator">=</span> s<span class="token operator">-&gt;</span>oo<span class="token punctuation">;</span>
    gfp_t alloc_gfp<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>start<span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
    <span class="token keyword">int</span> idx<span class="token punctuation">,</span> order<span class="token punctuation">;</span>
    bool shuffle<span class="token punctuation">;</span>

    flags <span class="token operator">&amp;=</span> gfp_allowed_mask<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    page <span class="token operator">=</span> <span class="token function">alloc_slab_page</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> alloc_gfp<span class="token punctuation">,</span> node<span class="token punctuation">,</span> oo<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>page<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        oo <span class="token operator">=</span> s<span class="token operator">-&gt;</span>min<span class="token punctuation">;</span>
        alloc_gfp <span class="token operator">=</span> flags<span class="token punctuation">;</span>
        <span class="token comment">/*
         * Allocation may have failed due to fragmentation.
         * Try a lower order alloc if possible
         */</span>
        page <span class="token operator">=</span> <span class="token function">alloc_slab_page</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> alloc_gfp<span class="token punctuation">,</span> node<span class="token punctuation">,</span> oo<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>page<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">goto</span> out<span class="token punctuation">;</span>
        <span class="token function">stat</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> ORDER_FALLBACK<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> page<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里，我们看到了alloc_slab_page分配页面。分配的时候，要按kmem_cache_order_objects里面的order来。如果第一次分配不成功，说明内存已经很紧张了，那就换成min版本的kmem_cache_order_objects。</p>
<p>好了，这个复杂的层层分配机制，我们就讲到这里，你理解到这里也就够用了。</p>
<h4 id="19-2-页面换出"><a href="#19-2-页面换出" class="headerlink" title="19.2 页面换出"></a>19.2 页面换出</h4><p>另一个物理内存管理必须要处理的事情就是，页面换出。每个进程都有自己的虚拟地址空间，无论是32位还是64位，虚拟地址空间都非常大，物理内存不可能有这么多的空间放得下。所以，一般情况下，页面只有在被使用的时候，才会放在物理内存中。如果过了一段时间不被使用，即便用户进程并没有释放它，物理内存管理也有责任做一定的干预。例如，将这些物理内存中的页面换出到硬盘上去；将空出的物理内存，交给活跃的进程去使用。</p>
<p>什么情况下会触发页面换出呢？</p>
<p>可以想象，最常见的情况就是，分配内存的时候，发现没有地方了，就试图回收一下。例如，咱们解析申请一个页面的时候，会调用get_page_from_freelist，接下来的调用链为get_page_from_freelist-&gt;node_reclaim-&gt;__node_reclaim-&gt;shrink_node，通过这个调用链可以看出，页面换出也是以内存节点为单位的。</p>
<p>当然还有一种情况，就是作为内存管理系统应该主动去做的，而不能等真的出了事儿再做，这就是内核线程<strong>kswapd</strong>。这个内核线程，在系统初始化的时候就被创建。这样它会进入一个无限循环，直到系统停止。在这个循环中，如果内存使用没有那么紧张，那它就可以放心睡大觉；如果内存紧张了，就需要去检查一下内存，看看是否需要换出一些内存页。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * The background pageout daemon, started as a kernel thread
 * from the init process.
 *
 * This basically trickles out pages so that we have _some_
 * free memory available even if there is no other activity
 * that frees anything up. This is needed for things like routing
 * etc, where we otherwise might have all activity going on in
 * asynchronous contexts that cannot page things out.
 *
 * If there are applications that are active memory-allocators
 * (most normal use), this basically shouldn't matter.
 */</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">kswapd</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> alloc_order<span class="token punctuation">,</span> reclaim_order<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> classzone_idx <span class="token operator">=</span> MAX_NR_ZONES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    pg_data_t <span class="token operator">*</span>pgdat <span class="token operator">=</span> <span class="token punctuation">(</span>pg_data_t<span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk <span class="token operator">=</span> current<span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token function">kswapd_try_to_sleep</span><span class="token punctuation">(</span>pgdat<span class="token punctuation">,</span> alloc_order<span class="token punctuation">,</span> reclaim_order<span class="token punctuation">,</span>
                    classzone_idx<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        reclaim_order <span class="token operator">=</span> <span class="token function">balance_pgdat</span><span class="token punctuation">(</span>pgdat<span class="token punctuation">,</span> alloc_order<span class="token punctuation">,</span> classzone_idx<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里的调用链是balance_pgdat-&gt;kswapd_shrink_node-&gt;shrink_node，是以内存节点为单位的，最后也是调用shrink_node。</p>
<p>shrink_node会调用shrink_node_memcg。这里面有一个循环处理页面的列表，看这个函数的注释，其实和上面我们想表达的内存换出是一样的。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * This is a basic per-node page freer.  Used by both kswapd and direct reclaim.
 */</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">shrink_node_memcg</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pglist_data</span> <span class="token operator">*</span>pgdat<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">mem_cgroup</span> <span class="token operator">*</span>memcg<span class="token punctuation">,</span>
                  <span class="token keyword">struct</span> <span class="token class-name">scan_control</span> <span class="token operator">*</span>sc<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span>lru_pages<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> nr<span class="token punctuation">[</span>NR_LRU_LISTS<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">enum</span> <span class="token class-name">lru_list</span> lru<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>nr<span class="token punctuation">[</span>LRU_INACTIVE_ANON<span class="token punctuation">]</span> <span class="token operator">||</span> nr<span class="token punctuation">[</span>LRU_ACTIVE_FILE<span class="token punctuation">]</span> <span class="token operator">||</span>
                    nr<span class="token punctuation">[</span>LRU_INACTIVE_FILE<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> nr_anon<span class="token punctuation">,</span> nr_file<span class="token punctuation">,</span> percentage<span class="token punctuation">;</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> nr_scanned<span class="token punctuation">;</span>

        <span class="token function">for_each_evictable_lru</span><span class="token punctuation">(</span>lru<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nr<span class="token punctuation">[</span>lru<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                nr_to_scan <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>nr<span class="token punctuation">[</span>lru<span class="token punctuation">]</span><span class="token punctuation">,</span> SWAP_CLUSTER_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>
                nr<span class="token punctuation">[</span>lru<span class="token punctuation">]</span> <span class="token operator">-=</span> nr_to_scan<span class="token punctuation">;</span>

                nr_reclaimed <span class="token operator">+=</span> <span class="token function">shrink_list</span><span class="token punctuation">(</span>lru<span class="token punctuation">,</span> nr_to_scan<span class="token punctuation">,</span>
                                lruvec<span class="token punctuation">,</span> memcg<span class="token punctuation">,</span> sc<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面有个lru列表。从下面的定义，我们可以想象，所有的页面都被挂在LRU列表中。LRU是Least Recent Use，也就是最近最少使用。也就是说，这个列表里面会按照活跃程度进行排序，这样就容易把不怎么用的内存页拿出来做处理。</p>
<p>内存页总共分两类，一类是<strong>匿名页</strong>，和虚拟地址空间进行关联；一类是<strong>内存映射</strong>，不但和虚拟地址空间关联，还和文件管理关联。</p>
<p>它们每一类都有两个列表，一个是active，一个是inactive。顾名思义，active就是比较活跃的，inactive就是不怎么活跃的。这两个里面的页会变化，过一段时间，活跃的可能变为不活跃，不活跃的可能变为活跃。如果要换出内存，那就是从不活跃的列表中找出最不活跃的，换出到硬盘上。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span> <span class="token class-name">lru_list</span> <span class="token punctuation">{</span>
    LRU_INACTIVE_ANON <span class="token operator">=</span> LRU_BASE<span class="token punctuation">,</span>
    LRU_ACTIVE_ANON <span class="token operator">=</span> LRU_BASE <span class="token operator">+</span> LRU_ACTIVE<span class="token punctuation">,</span>
    LRU_INACTIVE_FILE <span class="token operator">=</span> LRU_BASE <span class="token operator">+</span> LRU_FILE<span class="token punctuation">,</span>
    LRU_ACTIVE_FILE <span class="token operator">=</span> LRU_BASE <span class="token operator">+</span> LRU_FILE <span class="token operator">+</span> LRU_ACTIVE<span class="token punctuation">,</span>
    LRU_UNEVICTABLE<span class="token punctuation">,</span>
    NR_LRU_LISTS
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">for_each_evictable_lru</span><span class="token punctuation">(</span>lru<span class="token punctuation">)</span> <span class="token keyword">for</span> <span class="token punctuation">(</span>lru <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> lru <span class="token operator">&lt;=</span> LRU_ACTIVE_FILE<span class="token punctuation">;</span> lru<span class="token operator">++</span><span class="token punctuation">)</span></span></span>

<span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">shrink_list</span><span class="token punctuation">(</span><span class="token keyword">enum</span> <span class="token class-name">lru_list</span> lru<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> nr_to_scan<span class="token punctuation">,</span>
                 <span class="token keyword">struct</span> <span class="token class-name">lruvec</span> <span class="token operator">*</span>lruvec<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">mem_cgroup</span> <span class="token operator">*</span>memcg<span class="token punctuation">,</span>
                 <span class="token keyword">struct</span> <span class="token class-name">scan_control</span> <span class="token operator">*</span>sc<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_active_lru</span><span class="token punctuation">(</span>lru<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">inactive_list_is_low</span><span class="token punctuation">(</span>lruvec<span class="token punctuation">,</span> <span class="token function">is_file_lru</span><span class="token punctuation">(</span>lru<span class="token punctuation">)</span><span class="token punctuation">,</span>
                     memcg<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> true<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token function">shrink_active_list</span><span class="token punctuation">(</span>nr_to_scan<span class="token punctuation">,</span> lruvec<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> lru<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token function">shrink_inactive_list</span><span class="token punctuation">(</span>nr_to_scan<span class="token punctuation">,</span> lruvec<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> lru<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从上面的代码可以看出，shrink_list会先缩减活跃页面列表，再压缩不活跃的页面列表。对于不活跃列表的缩减，shrink_inactive_list就需要对页面进行回收；对于匿名页来讲，需要分配swap，将内存页写入文件系统；对于内存映射关联了文件的，我们需要将在内存中对于文件的修改写回到文件中。</p>
<h4 id="19-3-总结"><a href="#19-3-总结" class="headerlink" title="19.3 总结"></a>19.3 总结</h4><p>对于物理内存来讲，从下层到上层的关系及分配模式如下：</p>
<ul>
<li>物理内存分NUMA节点，分别进行管理；</li>
<li>每个NUMA节点分成多个内存区域；</li>
<li>每个内存区域分成多个物理页面；</li>
<li>伙伴系统将多个连续的页面作为一个大的内存块分配给上层；</li>
<li>kswapd负责物理页面的换入换出；</li>
<li>Slub Allocator将从伙伴系统申请的大内存块切成小块，分配给其他系统。</li>
</ul>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/物理内存的管理.jpeg" alt="物理内存的管理"></p>
<h3 id="20-用户态内存映射"><a href="#20-用户态内存映射" class="headerlink" title="20. 用户态内存映射"></a>20. 用户态内存映射</h3><h4 id="20-1-mmap的原理"><a href="#20-1-mmap的原理" class="headerlink" title="20.1 mmap的原理"></a>20.1 mmap的原理</h4><p>在虚拟地址空间那一节，我们知道，每一个进程都有一个列表vm_area_struct，指向虚拟地址空间的不同的内存块，这个变量的名字叫mmap。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span>mmap<span class="token punctuation">;</span>        <span class="token comment">/* list of VMAs */</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token punctuation">{</span>
    <span class="token comment">/*
     * For areas with an address space and backing store,
     * linkage into the address_space-&gt;i_mmap interval tree.
     */</span>
    <span class="token keyword">struct</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> rb<span class="token punctuation">;</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> rb_subtree_last<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> shared<span class="token punctuation">;</span>

    <span class="token comment">/*
     * A file's MAP_PRIVATE vma can be in both i_mmap tree and anon_vma
     * list, after a COW of one of the file pages.  A MAP_SHARED vma
     * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack
     * or brk vma (with NULL file) can only be in an anon_vma list.
     */</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> anon_vma_chain<span class="token punctuation">;</span> <span class="token comment">/* Serialized by mmap_sem &amp;
                      * page_table_lock */</span>
    <span class="token keyword">struct</span> <span class="token class-name">anon_vma</span> <span class="token operator">*</span>anon_vma<span class="token punctuation">;</span>  <span class="token comment">/* Serialized by page_table_lock */</span>

    <span class="token comment">/* Function pointers to deal with this struct. */</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">vm_operations_struct</span> <span class="token operator">*</span>vm_ops<span class="token punctuation">;</span>
    <span class="token comment">/* Information about our backing store: */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> vm_pgoff<span class="token punctuation">;</span>  <span class="token comment">/* Offset (within vm_file) in PAGE_SIZE
                       units */</span>
    <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span> vm_file<span class="token punctuation">;</span>    <span class="token comment">/* File we map to (can be NULL). */</span>
    <span class="token keyword">void</span> <span class="token operator">*</span> vm_private_data<span class="token punctuation">;</span>  <span class="token comment">/* was vm_pte (shared mem) */</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其实内存映射不仅仅是物理内存和虚拟内存之间的映射，还包括将文件中的内容映射到虚拟内存空间。这个时候，访问内存空间就能够访问到文件里面的数据。而仅有物理内存和虚拟内存的映射，是一种特殊情况。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/将文件中的内容映射到虚拟内存空间.jpg" alt="将文件中的内容映射到虚拟内存空间"></p>
<p>前面咱们讲堆的时候讲过，如果我们要申请小块内存，就用brk。brk函数之前已经解析过了，这里就不多说了。如果申请一大块内存，就要用mmap。对于堆的申请来讲，mmap是映射内存空间到物理内存。</p>
<p>另外，如果一个进程想映射一个文件到自己的虚拟内存空间，也要通过mmap系统调用。这个时候mmap是映射内存空间到物理内存再到文件。可见mmap这个系统调用是核心，我们现在来看mmap这个系统调用。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE6</span><span class="token punctuation">(</span>mmap<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> addr<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> len<span class="token punctuation">,</span>
                <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> prot<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> flags<span class="token punctuation">,</span>
                <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        error <span class="token operator">=</span> <span class="token function">sys_mmap_pgoff</span><span class="token punctuation">(</span>addr<span class="token punctuation">,</span> len<span class="token punctuation">,</span> prot<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> off <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token function">SYSCALL_DEFINE6</span><span class="token punctuation">(</span>mmap_pgoff<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> addr<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> len<span class="token punctuation">,</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> prot<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> flags<span class="token punctuation">,</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> pgoff<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    file <span class="token operator">=</span> <span class="token function">fget</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    retval <span class="token operator">=</span> <span class="token function">vm_mmap_pgoff</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> len<span class="token punctuation">,</span> prot<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> pgoff<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> retval<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果要映射到文件，fd会传进来一个文件描述符，并且mmap_pgoff里面通过fget函数，根据文件描述符获得struct file。struct file表示打开的一个文件。</p>
<p>接下来的调用链是vm_mmap_pgoff-&gt;do_mmap_pgoff-&gt;do_mmap。这里面主要干了两件事情：</p>
<ul>
<li>调用get_unmapped_area找到一个没有映射的区域；</li>
<li>调用mmap_region映射这个区域。</li>
</ul>
<p>我们先来看get_unmapped_area函数。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">long</span>
<span class="token function">get_unmapped_area</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> addr<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">,</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> pgoff<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token punctuation">(</span><span class="token operator">*</span>get_area<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span>
                  <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    get_area <span class="token operator">=</span> current<span class="token operator">-&gt;</span>mm<span class="token operator">-&gt;</span>get_unmapped_area<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>file<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>file<span class="token operator">-&gt;</span>f_op<span class="token operator">-&gt;</span>get_unmapped_area<span class="token punctuation">)</span>
            get_area <span class="token operator">=</span> file<span class="token operator">-&gt;</span>f_op<span class="token operator">-&gt;</span>get_unmapped_area<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面如果是匿名映射，则调用mm_struct里面的get_unmapped_area函数。这个函数其实是arch_get_unmapped_area。它会调用find_vma_prev，在表示虚拟内存区域的vm_area_struct红黑树上找到相应的位置。之所以叫prev，是说这个时候虚拟内存区域还没有建立，找到前一个vm_area_struct。</p>
<p>如果不是匿名映射，而是映射到一个文件，这样在Linux里面，每个打开的文件都有一个struct file结构，里面有一个file_operations，用来表示和这个文件相关的操作。如果是我们熟知的ext4文件系统，调用的是thp_get_unmapped_area。如果我们仔细看这个函数，最终还是调用mm_struct里面的get_unmapped_area函数。殊途同归。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> ext4_file_operations <span class="token operator">=</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">.</span>mmap         <span class="token operator">=</span> ext4_file_mmap
        <span class="token punctuation">.</span>get_unmapped_area <span class="token operator">=</span> thp_get_unmapped_area<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">__thp_get_unmapped_area</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>filp<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">,</span>
                loff_t off<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> addr<span class="token punctuation">;</span>
        loff_t off_end <span class="token operator">=</span> off <span class="token operator">+</span> len<span class="token punctuation">;</span>
        loff_t off_align <span class="token operator">=</span> <span class="token function">round_up</span><span class="token punctuation">(</span>off<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len_pad<span class="token punctuation">;</span>
        len_pad <span class="token operator">=</span> len <span class="token operator">+</span> size<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        addr <span class="token operator">=</span> current<span class="token operator">-&gt;</span>mm<span class="token operator">-&gt;</span><span class="token function">get_unmapped_area</span><span class="token punctuation">(</span>filp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len_pad<span class="token punctuation">,</span>
                                              off <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
        addr <span class="token operator">+=</span> <span class="token punctuation">(</span>off <span class="token operator">-</span> addr<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> addr<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们再来看mmap_region，看它如何映射这个虚拟内存区域。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">mmap_region</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> addr<span class="token punctuation">,</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">,</span> vm_flags_t vm_flags<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> pgoff<span class="token punctuation">,</span>
        <span class="token keyword">struct</span> <span class="token class-name">list_head</span> <span class="token operator">*</span>uf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>mm <span class="token operator">=</span> current<span class="token operator">-&gt;</span>mm<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span>vma<span class="token punctuation">,</span> <span class="token operator">*</span>prev<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span><span class="token operator">*</span>rb_link<span class="token punctuation">,</span> <span class="token operator">*</span>rb_parent<span class="token punctuation">;</span>


    <span class="token comment">/*
     * Can we just expand an old mapping?
     */</span>
    vma <span class="token operator">=</span> <span class="token function">vma_merge</span><span class="token punctuation">(</span>mm<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> addr <span class="token operator">+</span> len<span class="token punctuation">,</span> vm_flags<span class="token punctuation">,</span>
            <span class="token constant">NULL</span><span class="token punctuation">,</span> file<span class="token punctuation">,</span> pgoff<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> NULL_VM_UFFD_CTX<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>vma<span class="token punctuation">)</span>
        <span class="token keyword">goto</span> out<span class="token punctuation">;</span>


    <span class="token comment">/*
     * Determine the object being mapped and call the appropriate
     * specific mapper. the address has already been validated, but
     * not unmapped, but the maps are removed from the list.
     */</span>
    vma <span class="token operator">=</span> <span class="token function">kmem_cache_zalloc</span><span class="token punctuation">(</span>vm_area_cachep<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vma<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        error <span class="token operator">=</span> <span class="token operator">-</span>ENOMEM<span class="token punctuation">;</span>
        <span class="token keyword">goto</span> unacct_error<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


    vma<span class="token operator">-&gt;</span>vm_mm <span class="token operator">=</span> mm<span class="token punctuation">;</span>
    vma<span class="token operator">-&gt;</span>vm_start <span class="token operator">=</span> addr<span class="token punctuation">;</span>
    vma<span class="token operator">-&gt;</span>vm_end <span class="token operator">=</span> addr <span class="token operator">+</span> len<span class="token punctuation">;</span>
    vma<span class="token operator">-&gt;</span>vm_flags <span class="token operator">=</span> vm_flags<span class="token punctuation">;</span>
    vma<span class="token operator">-&gt;</span>vm_page_prot <span class="token operator">=</span> <span class="token function">vm_get_page_prot</span><span class="token punctuation">(</span>vm_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vma<span class="token operator">-&gt;</span>vm_pgoff <span class="token operator">=</span> pgoff<span class="token punctuation">;</span>
    <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vma<span class="token operator">-&gt;</span>anon_vma_chain<span class="token punctuation">)</span><span class="token punctuation">;</span>


    <span class="token keyword">if</span> <span class="token punctuation">(</span>file<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        vma<span class="token operator">-&gt;</span>vm_file <span class="token operator">=</span> <span class="token function">get_file</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
        error <span class="token operator">=</span> <span class="token function">call_mmap</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> vma<span class="token punctuation">)</span><span class="token punctuation">;</span>
        addr <span class="token operator">=</span> vma<span class="token operator">-&gt;</span>vm_start<span class="token punctuation">;</span>
        vm_flags <span class="token operator">=</span> vma<span class="token operator">-&gt;</span>vm_flags<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">vma_link</span><span class="token punctuation">(</span>mm<span class="token punctuation">,</span> vma<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> rb_link<span class="token punctuation">,</span> rb_parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> addr<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>还记得咱们刚找到了虚拟内存区域的前一个vm_area_struct，我们首先要看，是否能够基于它进行扩展，也即调用vma_merge，和前一个vm_area_struct合并到一起。</p>
<p>如果不能，就需要调用kmem_cache_zalloc，在Slub里面创建一个新的vm_area_struct对象，设置起始和结束位置，将它加入队列。如果是映射到文件，则设置vm_file为目标文件，调用call_mmap。其实就是调用file_operations的mmap函数。对于ext4文件系统，调用的是ext4_file_mmap。从这个函数的参数可以看出，这一刻文件和内存开始发生关系了。这里我们将vm_area_struct的内存操作设置为文件系统操作，也就是说，读写内存其实就是读写文件系统。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">call_mmap</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span>vma<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> file<span class="token operator">-&gt;</span>f_op<span class="token operator">-&gt;</span><span class="token function">mmap</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> vma<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ext4_file_mmap</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span>vma<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
      vma<span class="token operator">-&gt;</span>vm_ops <span class="token operator">=</span> <span class="token operator">&amp;</span>ext4_file_vm_ops<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们再回到mmap_region函数。最终，vma_link函数将新创建的vm_area_struct挂在了mm_struct里面的红黑树上。</p>
<p>这个时候，从内存到文件的映射关系，至少要在逻辑层面建立起来。那从文件到内存的映射关系呢？vma_link还做了另外一件事情，就是__vma_link_file。这个东西要用于建立这层映射关系。</p>
<p>对于打开的文件，会有一个结构struct file来表示。它有个成员指向struct address_space结构，这里面有棵变量名为i_mmap的红黑树，vm_area_struct就挂在这棵树上。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">address_space</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">inode</span>        <span class="token operator">*</span>host<span class="token punctuation">;</span>            <span class="token comment">/* owner: inode, block_device */</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_root</span>    i_mmap<span class="token punctuation">;</span>      <span class="token comment">/* tree of private and shared mappings */</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">address_space_operations</span> <span class="token operator">*</span>a_ops<span class="token punctuation">;</span>   <span class="token comment">/* methods */</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">__vma_link_file</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span>vma<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">;</span>

    file <span class="token operator">=</span> vma<span class="token operator">-&gt;</span>vm_file<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>file<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">address_space</span> <span class="token operator">*</span>mapping <span class="token operator">=</span> file<span class="token operator">-&gt;</span>f_mapping<span class="token punctuation">;</span>
        <span class="token function">vma_interval_tree_insert</span><span class="token punctuation">(</span>vma<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mapping<span class="token operator">-&gt;</span>i_mmap<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>到这里，内存映射的内容要告一段落了。你可能会困惑，好像还没和物理内存发生任何关系，还是在虚拟内存里面折腾呀？</p>
<p>对的，因为到目前为止，我们还没有开始真正访问内存呀！这个时候，内存管理并不直接分配物理内存，因为物理内存相对于虚拟地址空间太宝贵了，只有等你真正用的那一刻才会开始分配。</p>
<h4 id="20-2-用户态缺页异常"><a href="#20-2-用户态缺页异常" class="headerlink" title="20.2 用户态缺页异常"></a>20.2 用户态缺页异常</h4><p>一旦开始访问虚拟内存的某个地址，如果我们发现，并没有对应的物理页，那就触发缺页中断，调用do_page_fault。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">dotraplinkage <span class="token keyword">void</span> notrace
<span class="token function">do_page_fault</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span>regs<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> error_code<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> address <span class="token operator">=</span> <span class="token function">read_cr2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Get the faulting address */</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">__do_page_fault</span><span class="token punctuation">(</span>regs<span class="token punctuation">,</span> error_code<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span class="token comment">/*
 * This routine handles page faults.  It determines the address,
 * and the problem, and then passes it off to one of the appropriate
 * routines.
 */</span>
<span class="token keyword">static</span> noinline <span class="token keyword">void</span>
<span class="token function">__do_page_fault</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span>regs<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> error_code<span class="token punctuation">,</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> address<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span>vma<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>mm<span class="token punctuation">;</span>
    tsk <span class="token operator">=</span> current<span class="token punctuation">;</span>
    mm <span class="token operator">=</span> tsk<span class="token operator">-&gt;</span>mm<span class="token punctuation">;</span>


    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token function">fault_in_kernel_space</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">vmalloc_fault</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    vma <span class="token operator">=</span> <span class="token function">find_vma</span><span class="token punctuation">(</span>mm<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    fault <span class="token operator">=</span> <span class="token function">handle_mm_fault</span><span class="token punctuation">(</span>vma<span class="token punctuation">,</span> address<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在__do_page_fault里面，先要判断缺页中断是否发生在内核。如果发生在内核则调用vmalloc_fault，这就和咱们前面学过的虚拟内存的布局对应上了。在内核里面，vmalloc区域需要内核页表映射到物理页。咱们这里把内核的这部分放放，接着看用户空间的部分。</p>
<p>接下来在用户空间里面，找到你访问的那个地址所在的区域vm_area_struct，然后调用handle_mm_fault来映射这个区域。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">__handle_mm_fault</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span>vma<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> address<span class="token punctuation">,</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">vm_fault</span> vmf <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span>vma <span class="token operator">=</span> vma<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>address <span class="token operator">=</span> address <span class="token operator">&amp;</span> PAGE_MASK<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>flags <span class="token operator">=</span> flags<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>pgoff <span class="token operator">=</span> <span class="token function">linear_page_index</span><span class="token punctuation">(</span>vma<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">.</span>gfp_mask <span class="token operator">=</span> <span class="token function">__get_fault_gfp_mask</span><span class="token punctuation">(</span>vma<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>mm <span class="token operator">=</span> vma<span class="token operator">-&gt;</span>vm_mm<span class="token punctuation">;</span>
    pgd_t <span class="token operator">*</span>pgd<span class="token punctuation">;</span>
    p4d_t <span class="token operator">*</span>p4d<span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>

    pgd <span class="token operator">=</span> <span class="token function">pgd_offset</span><span class="token punctuation">(</span>mm<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>
    p4d <span class="token operator">=</span> <span class="token function">p4d_alloc</span><span class="token punctuation">(</span>mm<span class="token punctuation">,</span> pgd<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    vmf<span class="token punctuation">.</span>pud <span class="token operator">=</span> <span class="token function">pud_alloc</span><span class="token punctuation">(</span>mm<span class="token punctuation">,</span> p4d<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    vmf<span class="token punctuation">.</span>pmd <span class="token operator">=</span> <span class="token function">pmd_alloc</span><span class="token punctuation">(</span>mm<span class="token punctuation">,</span> vmf<span class="token punctuation">.</span>pud<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> <span class="token function">handle_pte_fault</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vmf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>到这里，终于看到了我们熟悉的PGD、P4G、PUD、PMD、PTE，这就是前面讲页表的时候，讲述的四级页表的概念，因为暂且不考虑五级页表，我们暂时忽略P4G。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/四级页表.jpg" alt="四级页表"></p>
<p>pgd_t 用于全局页目录项，pud_t 用于上层页目录项，pmd_t 用于中间页目录项，pte_t 用于直接页表项。</p>
<p>每个进程都有独立的地址空间，为了这个进程独立完成映射，每个进程都有独立的进程页表，这个页表的最顶级的pgd存放在task_struct中的mm_struct的pgd变量里面。</p>
<p>在一个进程新创建的时候，会调用fork，对于内存的部分会调用copy_mm，里面调用dup_mm。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * Allocate a new mm structure and copy contents from the
 * mm structure of the passed in task structure.
 */</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span><span class="token function">dup_mm</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>mm<span class="token punctuation">,</span> <span class="token operator">*</span>oldmm <span class="token operator">=</span> current<span class="token operator">-&gt;</span>mm<span class="token punctuation">;</span>
    mm <span class="token operator">=</span> <span class="token function">allocate_mm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">memcpy</span><span class="token punctuation">(</span>mm<span class="token punctuation">,</span> oldmm<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>mm<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">mm_init</span><span class="token punctuation">(</span>mm<span class="token punctuation">,</span> tsk<span class="token punctuation">,</span> mm<span class="token operator">-&gt;</span>user_ns<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">goto</span> fail_nomem<span class="token punctuation">;</span>
    err <span class="token operator">=</span> <span class="token function">dup_mmap</span><span class="token punctuation">(</span>mm<span class="token punctuation">,</span> oldmm<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> mm<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里，除了创建一个新的mm_struct，并且通过memcpy将它和父进程的弄成一模一样之外，我们还需要调用mm_init进行初始化。接下来，mm_init调用mm_alloc_pgd，分配全局页目录项，赋值给mm_struct的pdg成员变量。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">mm_alloc_pgd</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>mm<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    mm<span class="token operator">-&gt;</span>pgd <span class="token operator">=</span> <span class="token function">pgd_alloc</span><span class="token punctuation">(</span>mm<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>pgd_alloc里面除了分配PDG之外，还做了很重要的一个事情，就是调用pgd_ctor。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">pgd_ctor</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>mm<span class="token punctuation">,</span> pgd_t <span class="token operator">*</span>pgd<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">/* If the pgd points to a shared pagetable level (either the
       ptes in non-PAE, or shared PMD in PAE), then just copy the
       references from swapper_pg_dir. */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>CONFIG_PGTABLE_LEVELS <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">||</span>
        <span class="token punctuation">(</span>CONFIG_PGTABLE_LEVELS <span class="token operator">==</span> <span class="token number">3</span> <span class="token operator">&amp;&amp;</span> SHARED_KERNEL_PMD<span class="token punctuation">)</span> <span class="token operator">||</span>
        CONFIG_PGTABLE_LEVELS <span class="token operator">&gt;=</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">clone_pgd_range</span><span class="token punctuation">(</span>pgd <span class="token operator">+</span> KERNEL_PGD_BOUNDARY<span class="token punctuation">,</span>
                swapper_pg_dir <span class="token operator">+</span> KERNEL_PGD_BOUNDARY<span class="token punctuation">,</span>
                KERNEL_PGD_PTRS<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>pgd_ctor干了什么事情呢？我们注意看里面的注释，它拷贝了对于swapper_pg_dir的引用。swapper_pg_dir是内核页表的最顶级的全局页目录。</p>
<p>一个进程的虚拟地址空间包含用户态和内核态两部分。为了从虚拟地址空间映射到物理页面，页表也分为用户地址空间的页表和内核页表，这就和上面遇到的vmalloc有关系了。在内核里面，映射靠内核页表，这里内核页表会拷贝一份到进程的页表。至于swapper_pg_dir是什么，怎么初始化的，怎么工作的，我们还是先放一放，放到下一节统一讨论。</p>
<p>至此，一个进程fork完毕之后，有了内核页表，有了自己顶级的pgd，但是对于用户地址空间来讲，还完全没有映射过。这需要等到这个进程在某个CPU上运行，并且对内存访问的那一刻了。</p>
<p>当这个进程被调度到某个CPU上运行的时候，咱们在 <strong>调度（上）</strong> 那一节讲过，要调用context_switch进行上下文切换。对于内存方面的切换会调用switch_mm_irqs_off，这里面会调用 load_new_mm_cr3。</p>
<p>cr3是CPU的一个寄存器，它会指向当前进程的顶级pgd。如果CPU的指令要访问进程的虚拟内存，它就会自动从cr3里面得到pgd在物理内存的地址，然后根据里面的页表解析虚拟内存的地址为物理内存，从而访问真正的物理内存上的数据。</p>
<p>这里需要注意两点。第一点，cr3里面存放当前进程的顶级pgd，这个是硬件的要求。cr3里面需要存放pgd在物理内存的地址，不能是虚拟地址。因而load_new_mm_cr3里面会使用__pa，将mm_struct里面的成员变量pdg（mm_struct里面存的都是虚拟地址）变为物理地址，才能加载到cr3里面去。</p>
<p>第二点，用户进程在运行的过程中，访问虚拟内存中的数据，会被cr3里面指向的页表转换为物理地址后，才在物理内存中访问数据，这个过程都是在用户态运行的，地址转换的过程无需进入内核态。</p>
<p>只有访问虚拟内存的时候，发现没有映射多物理内存，页表也没有创建过，才触发缺页异常。进入内核调用do_page_fault，一直调用到<strong>handle_mm_fault，这才有了上面解析到这个函数的时候，我们看到的代码。既然原来没有创建过页表，那只好补上这一课。于是，</strong>handle_mm_fault调用pud_alloc和pmd_alloc，来创建相应的页目录项，最后调用handle_pte_fault来创建页表项。</p>
<p>绕了一大圈，终于将页表整个机制的各个部分串了起来。但是咱们的故事还没讲完，物理的内存还没找到。我们还得接着分析handle_pte_fault的实现。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">handle_pte_fault</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">vm_fault</span> <span class="token operator">*</span>vmf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    pte_t entry<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    vmf<span class="token operator">-&gt;</span>pte <span class="token operator">=</span> <span class="token function">pte_offset_map</span><span class="token punctuation">(</span>vmf<span class="token operator">-&gt;</span>pmd<span class="token punctuation">,</span> vmf<span class="token operator">-&gt;</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vmf<span class="token operator">-&gt;</span>orig_pte <span class="token operator">=</span> <span class="token operator">*</span>vmf<span class="token operator">-&gt;</span>pte<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vmf<span class="token operator">-&gt;</span>pte<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">vma_is_anonymous</span><span class="token punctuation">(</span>vmf<span class="token operator">-&gt;</span>vma<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token function">do_anonymous_page</span><span class="token punctuation">(</span>vmf<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token keyword">return</span> <span class="token function">do_fault</span><span class="token punctuation">(</span>vmf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pte_present</span><span class="token punctuation">(</span>vmf<span class="token operator">-&gt;</span>orig_pte<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">do_swap_page</span><span class="token punctuation">(</span>vmf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面总的来说分了三种情况。如果PTE，也就是页表项，从来没有出现过，那就是新映射的页。如果是匿名页，就是第一种情况，应该映射到一个物理内存页，在这里调用的是do_anonymous_page。如果是映射到文件，调用的就是do_fault，这是第二种情况。如果PTE原来出现过，说明原来页面在物理内存中，后来换出到硬盘了，现在应该换回来，调用的是do_swap_page。</p>
<p>我们来看第一种情况，do_anonymous_page。对于匿名页的映射，我们需要先通过pte_alloc分配一个页表项，然后通过alloc_zeroed_user_highpage_movable分配一个页。之后它会调用alloc_pages_vma，并最终调用__alloc_pages_nodemask。</p>
<p>这个函数你还记得吗？就是咱们伙伴系统的核心函数，专门用来分配物理页面的。do_anonymous_page接下来要调用mk_pte，将页表项指向新分配的物理页，set_pte_at会将页表项塞到页表里面。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">do_anonymous_page</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">vm_fault</span> <span class="token operator">*</span>vmf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span>vma <span class="token operator">=</span> vmf<span class="token operator">-&gt;</span>vma<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">mem_cgroup</span> <span class="token operator">*</span>memcg<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    pte_t entry<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pte_alloc</span><span class="token punctuation">(</span>vma<span class="token operator">-&gt;</span>vm_mm<span class="token punctuation">,</span> vmf<span class="token operator">-&gt;</span>pmd<span class="token punctuation">,</span> vmf<span class="token operator">-&gt;</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> VM_FAULT_OOM<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    page <span class="token operator">=</span> <span class="token function">alloc_zeroed_user_highpage_movable</span><span class="token punctuation">(</span>vma<span class="token punctuation">,</span> vmf<span class="token operator">-&gt;</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    entry <span class="token operator">=</span> <span class="token function">mk_pte</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> vma<span class="token operator">-&gt;</span>vm_page_prot<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>vma<span class="token operator">-&gt;</span>vm_flags <span class="token operator">&amp;</span> VM_WRITE<span class="token punctuation">)</span>
        entry <span class="token operator">=</span> <span class="token function">pte_mkwrite</span><span class="token punctuation">(</span><span class="token function">pte_mkdirty</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    vmf<span class="token operator">-&gt;</span>pte <span class="token operator">=</span> <span class="token function">pte_offset_map_lock</span><span class="token punctuation">(</span>vma<span class="token operator">-&gt;</span>vm_mm<span class="token punctuation">,</span> vmf<span class="token operator">-&gt;</span>pmd<span class="token punctuation">,</span> vmf<span class="token operator">-&gt;</span>address<span class="token punctuation">,</span>
            <span class="token operator">&amp;</span>vmf<span class="token operator">-&gt;</span>ptl<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">set_pte_at</span><span class="token punctuation">(</span>vma<span class="token operator">-&gt;</span>vm_mm<span class="token punctuation">,</span> vmf<span class="token operator">-&gt;</span>address<span class="token punctuation">,</span> vmf<span class="token operator">-&gt;</span>pte<span class="token punctuation">,</span> entry<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>第二种情况映射到文件do_fault，最终我们会调用__do_fault。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">__do_fault</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">vm_fault</span> <span class="token operator">*</span>vmf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span>vma <span class="token operator">=</span> vmf<span class="token operator">-&gt;</span>vma<span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    ret <span class="token operator">=</span> vma<span class="token operator">-&gt;</span>vm_ops<span class="token operator">-&gt;</span><span class="token function">fault</span><span class="token punctuation">(</span>vmf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里调用了struct vm_operations_struct vm_ops的fault函数。还记得咱们上面用mmap映射文件的时候，对于ext4文件系统，vm_ops指向了ext4_file_vm_ops，也就是调用了ext4_filemap_fault。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">vm_operations_struct</span> ext4_file_vm_ops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>fault    <span class="token operator">=</span> ext4_filemap_fault<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>map_pages  <span class="token operator">=</span> filemap_map_pages<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>page_mkwrite   <span class="token operator">=</span> ext4_page_mkwrite<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">ext4_filemap_fault</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">vm_fault</span> <span class="token operator">*</span>vmf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode <span class="token operator">=</span> <span class="token function">file_inode</span><span class="token punctuation">(</span>vmf<span class="token operator">-&gt;</span>vma<span class="token operator">-&gt;</span>vm_file<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    err <span class="token operator">=</span> <span class="token function">filemap_fault</span><span class="token punctuation">(</span>vmf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> err<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>ext4_filemap_fault里面的逻辑我们很容易就能读懂。vm_file就是咱们当时mmap的时候映射的那个文件，然后我们需要调用filemap_fault。对于文件映射来说，一般这个文件会在物理内存里面有页面作为它的缓存，find_get_page就是找那个页。如果找到了，就调用do_async_mmap_readahead，预读一些数据到内存里面；如果没有，就跳到no_cached_page。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">filemap_fault</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">vm_fault</span> <span class="token operator">*</span>vmf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> error<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file <span class="token operator">=</span> vmf<span class="token operator">-&gt;</span>vma<span class="token operator">-&gt;</span>vm_file<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">address_space</span> <span class="token operator">*</span>mapping <span class="token operator">=</span> file<span class="token operator">-&gt;</span>f_mapping<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode <span class="token operator">=</span> mapping<span class="token operator">-&gt;</span>host<span class="token punctuation">;</span>
    pgoff_t offset <span class="token operator">=</span> vmf<span class="token operator">-&gt;</span>pgoff<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    page <span class="token operator">=</span> <span class="token function">find_get_page</span><span class="token punctuation">(</span>mapping<span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>vmf<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> FAULT_FLAG_TRIED<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">do_async_mmap_readahead</span><span class="token punctuation">(</span>vmf<span class="token operator">-&gt;</span>vma<span class="token punctuation">,</span> ra<span class="token punctuation">,</span> file<span class="token punctuation">,</span> page<span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>page<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">goto</span> no_cached_page<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    vmf<span class="token operator">-&gt;</span>page <span class="token operator">=</span> page<span class="token punctuation">;</span>
    <span class="token keyword">return</span> ret <span class="token operator">|</span> VM_FAULT_LOCKED<span class="token punctuation">;</span>
no_cached_page<span class="token operator">:</span>
    error <span class="token operator">=</span> <span class="token function">page_cache_read</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> vmf<span class="token operator">-&gt;</span>gfp_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果没有物理内存中的缓存页，那我们就调用page_cache_read。在这里显示分配一个缓存页，将这一页加到lru表里面，然后在address_space中调用address_space_operations的readpage函数，将文件内容读到内存中。address_space的作用咱们上面也介绍过了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">page_cache_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> pgoff_t offset<span class="token punctuation">,</span> gfp_t gfp_mask<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">address_space</span> <span class="token operator">*</span>mapping <span class="token operator">=</span> file<span class="token operator">-&gt;</span>f_mapping<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    page <span class="token operator">=</span> <span class="token function">__page_cache_alloc</span><span class="token punctuation">(</span>gfp_mask<span class="token operator">|</span>__GFP_COLD<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    ret <span class="token operator">=</span> <span class="token function">add_to_page_cache_lru</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> mapping<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> gfp_mask <span class="token operator">&amp;</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    ret <span class="token operator">=</span> mapping<span class="token operator">-&gt;</span>a_ops<span class="token operator">-&gt;</span><span class="token function">readpage</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> page<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>struct address_space_operations对于ext4文件系统的定义如下所示。这么说来，上面的readpage调用的其实是ext4_readpage。因为我们还没讲到文件系统，这里我们不详细介绍ext4_readpage具体干了什么。你只要知道，最后会调用ext4_read_inline_page，这里面有部分逻辑和内存映射有关就行了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">address_space_operations</span> ext4_aops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>readpage      <span class="token operator">=</span> ext4_readpage<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>readpages    <span class="token operator">=</span> ext4_readpages<span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ext4_read_inline_page</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>kaddr<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    kaddr <span class="token operator">=</span> <span class="token function">kmap_atomic</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ret <span class="token operator">=</span> <span class="token function">ext4_read_inline_data</span><span class="token punctuation">(</span>inode<span class="token punctuation">,</span> kaddr<span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token operator">&amp;</span>iloc<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">flush_dcache_page</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">kunmap_atomic</span><span class="token punctuation">(</span>kaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在ext4_read_inline_page函数里，我们需要先调用kmap_atomic，将物理内存映射到内核的虚拟地址空间，得到内核中的地址kaddr。 我们在前面提到过kmap_atomic，它是用来做临时内核映射的。本来把物理内存映射到用户虚拟地址空间，不需要在内核里面映射一把。但是，现在因为要从文件里面读取数据并写入这个物理页面，又不能使用物理地址，我们只能使用虚拟地址，这就需要在内核里面临时映射一把。临时映射后，ext4_read_inline_data读取文件到这个虚拟地址。读取完毕后，我们取消这个临时映射kunmap_atomic就行了。</p>
<p>至于kmap_atomic的具体实现，我们还是放到内核映射部分再讲。</p>
<p>我们再来看第三种情况，do_swap_page。之前我们讲过物理内存管理，你这里可以回忆一下。如果长时间不用，就要换出到硬盘，也就是swap，现在这部分数据又要访问了，我们还得想办法再次读到内存中来。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">do_swap_page</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">vm_fault</span> <span class="token operator">*</span>vmf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span>vma <span class="token operator">=</span> vmf<span class="token operator">-&gt;</span>vma<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">,</span> <span class="token operator">*</span>swapcache<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">mem_cgroup</span> <span class="token operator">*</span>memcg<span class="token punctuation">;</span>
    swp_entry_t entry<span class="token punctuation">;</span>
    pte_t pte<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    entry <span class="token operator">=</span> <span class="token function">pte_to_swp_entry</span><span class="token punctuation">(</span>vmf<span class="token operator">-&gt;</span>orig_pte<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    page <span class="token operator">=</span> <span class="token function">lookup_swap_cache</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>page<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        page <span class="token operator">=</span> <span class="token function">swapin_readahead</span><span class="token punctuation">(</span>entry<span class="token punctuation">,</span> GFP_HIGHUSER_MOVABLE<span class="token punctuation">,</span> vma<span class="token punctuation">,</span>
                    vmf<span class="token operator">-&gt;</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    swapcache <span class="token operator">=</span> page<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    pte <span class="token operator">=</span> <span class="token function">mk_pte</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> vma<span class="token operator">-&gt;</span>vm_page_prot<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">set_pte_at</span><span class="token punctuation">(</span>vma<span class="token operator">-&gt;</span>vm_mm<span class="token punctuation">,</span> vmf<span class="token operator">-&gt;</span>address<span class="token punctuation">,</span> vmf<span class="token operator">-&gt;</span>pte<span class="token punctuation">,</span> pte<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vmf<span class="token operator">-&gt;</span>orig_pte <span class="token operator">=</span> pte<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">swap_free</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>do_swap_page函数会先查找swap文件有没有缓存页。如果没有，就调用swapin_readahead，将swap文件读到内存中来，形成内存页，并通过mk_pte生成页表项。set_pte_at将页表项插入页表，swap_free将swap文件清理。因为重新加载回内存了，不再需要swap文件了。</p>
<p>swapin_readahead会最终调用swap_readpage，在这里，我们看到了熟悉的readpage函数，也就是说读取普通文件和读取swap文件，过程是一样的，同样需要用kmap_atomic做临时映射。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">swap_readpage</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">,</span> bool do_poll<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">bio</span> <span class="token operator">*</span>bio<span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">swap_info_struct</span> <span class="token operator">*</span>sis <span class="token operator">=</span> <span class="token function">page_swap_info</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span>
    blk_qc_t qc<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">block_device</span> <span class="token operator">*</span>bdev<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>sis<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> SWP_FILE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>swap_file <span class="token operator">=</span> sis<span class="token operator">-&gt;</span>swap_file<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">address_space</span> <span class="token operator">*</span>mapping <span class="token operator">=</span> swap_file<span class="token operator">-&gt;</span>f_mapping<span class="token punctuation">;</span>
        ret <span class="token operator">=</span> mapping<span class="token operator">-&gt;</span>a_ops<span class="token operator">-&gt;</span><span class="token function">readpage</span><span class="token punctuation">(</span>swap_file<span class="token punctuation">,</span> page<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过上面复杂的过程，用户态缺页异常处理完毕了。物理内存中有了页面，页表也建立好了映射。接下来，用户程序在虚拟内存空间里面，可以通过虚拟地址顺利经过页表映射的访问物理页面上的数据了。</p>
<p>为了加快映射速度，我们不需要每次从虚拟地址到物理地址的转换都走一遍页表。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/TLB快表.jpg" alt="TLB快表"></p>
<h4 id="20-3-总结"><a href="#20-3-总结" class="headerlink" title="20.3 总结"></a>20.3 总结</h4><p>总结一下，用户态的内存映射机制包含以下几个部分。</p>
<ul>
<li>用户态内存映射函数mmap，包括用它来做匿名映射和文件映射。</li>
<li>用户态的页表结构，存储位置在mm_struct中。</li>
<li>在用户态访问没有映射的内存会引发缺页异常，分配物理页表、补齐页表。如果是匿名映射则分配物理内存；如果是swap，则将swap文件读入；如果是文件映射，则将文件读入。</li>
</ul>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/用户态的内存映射机制.jpg" alt="用户态的内存映射机制"></p>
<h3 id="21-内核态内存映射"><a href="#21-内核态内存映射" class="headerlink" title="21. 内核态内存映射"></a>21. 内核态内存映射</h3><p>内核态的内存映射机制，主要包含以下几个部分：</p>
<ul>
<li>内核态内存映射函数vmalloc、kmap_atomic是如何工作的；</li>
<li>内核态页表是放在哪里的，如何工作的？swapper_pg_dir是怎么回事；</li>
<li>出现了内核态缺页异常应该怎么办？</li>
</ul>
<h4 id="21-1-内核页表"><a href="#21-1-内核页表" class="headerlink" title="21.1 内核页表"></a>21.1 内核页表</h4><p>和用户态页表不同，在系统初始化的时候，我们就要创建内核页表了。</p>
<p>我们从内核页表的根swapper_pg_dir开始找线索，在arch/x86/include/asm/pgtable_64.h中就能找到它的定义。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">extern</span> pud_t level3_kernel_pgt<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">extern</span> pud_t level3_ident_pgt<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">extern</span> pmd_t level2_kernel_pgt<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">extern</span> pmd_t level2_fixmap_pgt<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">extern</span> pmd_t level2_ident_pgt<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">extern</span> pte_t level1_fixmap_pgt<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">extern</span> pgd_t init_top_pgt<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">swapper_pg_dir init_top_pgt</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>swapper_pg_dir指向内核最顶级的目录pgd，同时出现的还有几个页表目录。我们可以回忆一下，64位系统的虚拟地址空间的布局，其中XXX_ident_pgt对应的是直接映射区，XXX_kernel_pgt对应的是内核代码区，XXX_fixmap_pgt对应的是固定映射区。</p>
<p>它们是在哪里初始化的呢？在汇编语言的文件里面的arch\x86\kernel\head_64.S。这段代码比较难看懂，你只要明白它是干什么的就行了。</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">__INITDATA


NEXT_PAGE(init_top_pgt)
    .quad   level3_ident_pgt - __START_KERNEL_map + _KERNPG_TABLE
    .org    init_top_pgt + PGD_PAGE_OFFSET*8, 0
    .quad   level3_ident_pgt - __START_KERNEL_map + _KERNPG_TABLE
    .org    init_top_pgt + PGD_START_KERNEL*8, 0
    /* (2^48-(2*1024*1024*1024))/(2^39) = 511 */
    .quad   level3_kernel_pgt - __START_KERNEL_map + _PAGE_TABLE

NEXT_PAGE(level3_ident_pgt)
    .quad   level2_ident_pgt - __START_KERNEL_map + _KERNPG_TABLE
    .fill   511, 8, 0
NEXT_PAGE(level2_ident_pgt)
    /* Since I easily can, map the first 1G.
     * Don't set NX because code runs from these pages.
     */
    PMDS(0, __PAGE_KERNEL_IDENT_LARGE_EXEC, PTRS_PER_PMD)

NEXT_PAGE(level3_kernel_pgt)
    .fill   L3_START_KERNEL,8,0
    /* (2^48-(2*1024*1024*1024)-((2^39)*511))/(2^30) = 510 */
    .quad   level2_kernel_pgt - __START_KERNEL_map + _KERNPG_TABLE
    .quad   level2_fixmap_pgt - __START_KERNEL_map + _PAGE_TABLE

NEXT_PAGE(level2_kernel_pgt)
    /*
     * 512 MB kernel mapping. We spend a full page on this pagetable
     * anyway.
     *
     * The kernel code+data+bss must not be bigger than that.
     *
     * (NOTE: at +512MB starts the module area, see MODULES_VADDR.
     *  If you want to increase this then increase MODULES_VADDR
     *  too.)
     */
    PMDS(0, __PAGE_KERNEL_LARGE_EXEC,
        KERNEL_IMAGE_SIZE/PMD_SIZE)

NEXT_PAGE(level2_fixmap_pgt)
    .fill   506,8,0
    .quad   level1_fixmap_pgt - __START_KERNEL_map + _PAGE_TABLE
    /* 8MB reserved for vsyscalls + a 2MB hole = 4 + 1 entries */
    .fill   5,8,0

NEXT_PAGE(level1_fixmap_pgt)
    .fill   51<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>内核页表的顶级目录init_top_pgt，定义在__INITDATA里面。咱们讲过ELF的格式，也讲过虚拟内存空间的布局。它们都有代码段，还有一些初始化了的全局变量，放在.init区域。这些说的就是这个区域。可以看到，页表的根其实是全局变量，这就使得我们初始化的时候，甚至内存管理还没有初始化的时候，很容易就可以定位到。</p>
<p>接下来，定义init_top_pgt包含哪些项，这个汇编代码比较难懂了。你可以简单地认为，quad是声明了一项的内容，org是跳到了某个位置。</p>
<p>所以，init_top_pgt有三项，上来先有一项，指向的是level3_ident_pgt，也即直接映射区页表的三级目录。为什么要减去__START_KERNEL_map呢？因为level3_ident_pgt是定义在内核代码里的，写代码的时候，写的都是虚拟地址，谁写代码的时候也不知道将来加载的物理地址是多少呀，对不对？</p>
<p>因为level3_ident_pgt是在虚拟地址的内核代码段里的，而<strong>START_KERNEL_map正是虚拟地址空间的内核代码段的起始地址，这在讲64位虚拟地址空间的时候都讲过了，要是想不起来就赶紧去回顾一下。这样，level3_ident_pgt减去</strong>START_KERNEL_map才是物理地址。</p>
<p>第一项定义完了以后，接下来我们跳到PGD_PAGE_OFFSET的位置，再定义一项。从定义可以看出，这一项就应该是<strong>PAGE_OFFSET_BASE对应的。</strong>PAGE_OFFSET_BASE是虚拟地址空间里面内核的起始地址。第二项也指向level3_ident_pgt，直接映射区。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">PGD_PAGE_OFFSET <span class="token operator">=</span> <span class="token function">pgd_index</span><span class="token punctuation">(</span>__PAGE_OFFSET_BASE<span class="token punctuation">)</span>
PGD_START_KERNEL <span class="token operator">=</span> <span class="token function">pgd_index</span><span class="token punctuation">(</span>__START_KERNEL_map<span class="token punctuation">)</span>
L3_START_KERNEL <span class="token operator">=</span> <span class="token function">pud_index</span><span class="token punctuation">(</span>__START_KERNEL_map<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>第二项定义完了以后，接下来跳到PGD_START_KERNEL的位置，再定义一项。从定义可以看出，这一项应该是<strong>START_KERNEL_map对应的项，</strong>START_KERNEL_map是虚拟地址空间里面内核代码段的起始地址。第三项指向level3_kernel_pgt，内核代码区。</p>
<p>接下来的代码就很类似了，就是初始化个表项，然后指向下一级目录，最终形成下面这张图。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/内核页表结构.png" alt="内核页表结构"></p>
<p>内核页表定义完了，一开始这里面的页表能够覆盖的内存范围比较小。例如，内核代码区512M，直接映射区1G。这个时候，其实只要能够映射基本的内核代码和数据结构就可以了。可以看出，里面还空着很多项，可以用于将来映射巨大的内核虚拟地址空间，等用到的时候再进行映射。</p>
<p>如果是用户态进程页表，会有mm_struct指向进程顶级目录pgd，对于内核来讲，也定义了一个mm_struct，指向swapper_pg_dir。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> init_mm <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>mm_rb    <span class="token operator">=</span> RB_ROOT<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>pgd        <span class="token operator">=</span> swapper_pg_dir<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>mm_users   <span class="token operator">=</span> <span class="token function">ATOMIC_INIT</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>mm_count   <span class="token operator">=</span> <span class="token function">ATOMIC_INIT</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>mmap_sem   <span class="token operator">=</span> <span class="token function">__RWSEM_INITIALIZER</span><span class="token punctuation">(</span>init_mm<span class="token punctuation">.</span>mmap_sem<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>page_table_lock <span class="token operator">=</span>  <span class="token function">__SPIN_LOCK_UNLOCKED</span><span class="token punctuation">(</span>init_mm<span class="token punctuation">.</span>page_table_lock<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>mmlist  <span class="token operator">=</span> <span class="token function">LIST_HEAD_INIT</span><span class="token punctuation">(</span>init_mm<span class="token punctuation">.</span>mmlist<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>user_ns    <span class="token operator">=</span> <span class="token operator">&amp;</span>init_user_ns<span class="token punctuation">,</span>
    <span class="token function">INIT_MM_CONTEXT</span><span class="token punctuation">(</span>init_mm<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>定义完了内核页表，接下来是初始化内核页表，在系统启动的时候start_kernel会调用setup_arch。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> __init <span class="token function">setup_arch</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>cmdline_p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">/*
     * copy kernel address range established so far and switch
     * to the proper swapper page table
     */</span>
    <span class="token function">clone_pgd_range</span><span class="token punctuation">(</span>swapper_pg_dir   <span class="token operator">+</span> KERNEL_PGD_BOUNDARY<span class="token punctuation">,</span>
            initial_page_table <span class="token operator">+</span> KERNEL_PGD_BOUNDARY<span class="token punctuation">,</span>
            KERNEL_PGD_PTRS<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">load_cr3</span><span class="token punctuation">(</span>swapper_pg_dir<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">__flush_tlb_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    init_mm<span class="token punctuation">.</span>start_code <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> _text<span class="token punctuation">;</span>
    init_mm<span class="token punctuation">.</span>end_code <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> _etext<span class="token punctuation">;</span>
    init_mm<span class="token punctuation">.</span>end_data <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> _edata<span class="token punctuation">;</span>
    init_mm<span class="token punctuation">.</span>brk <span class="token operator">=</span> _brk_end<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">init_mem_mapping</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在setup_arch中，load_cr3(swapper_pg_dir)说明内核页表要开始起作用了，并且刷新了TLB，初始化init_mm的成员变量，最重要的就是init_mem_mapping。最终它会调用kernel_physical_mapping_init。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * Create page table mapping for the physical memory for specific physical
 * addresses. The virtual and physical addresses have to be aligned on PMD level
 * down. It returns the last physical address mapped.
 */</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> __meminit
<span class="token function">kernel_physical_mapping_init</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> paddr_start<span class="token punctuation">,</span>
                 <span class="token keyword">unsigned</span> <span class="token keyword">long</span> paddr_end<span class="token punctuation">,</span>
                 <span class="token keyword">unsigned</span> <span class="token keyword">long</span> page_size_mask<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> vaddr<span class="token punctuation">,</span> vaddr_start<span class="token punctuation">,</span> vaddr_end<span class="token punctuation">,</span> vaddr_next<span class="token punctuation">,</span> paddr_last<span class="token punctuation">;</span>

    paddr_last <span class="token operator">=</span> paddr_end<span class="token punctuation">;</span>
    vaddr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token function">__va</span><span class="token punctuation">(</span>paddr_start<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vaddr_end <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token function">__va</span><span class="token punctuation">(</span>paddr_end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vaddr_start <span class="token operator">=</span> vaddr<span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> vaddr <span class="token operator">&lt;</span> vaddr_end<span class="token punctuation">;</span> vaddr <span class="token operator">=</span> vaddr_next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        pgd_t <span class="token operator">*</span>pgd <span class="token operator">=</span> <span class="token function">pgd_offset_k</span><span class="token punctuation">(</span>vaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        p4d_t <span class="token operator">*</span>p4d<span class="token punctuation">;</span>

        vaddr_next <span class="token operator">=</span> <span class="token punctuation">(</span>vaddr <span class="token operator">&amp;</span> PGDIR_MASK<span class="token punctuation">)</span> <span class="token operator">+</span> PGDIR_SIZE<span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pgd_val</span><span class="token punctuation">(</span><span class="token operator">*</span>pgd<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            p4d <span class="token operator">=</span> <span class="token punctuation">(</span>p4d_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">pgd_page_vaddr</span><span class="token punctuation">(</span><span class="token operator">*</span>pgd<span class="token punctuation">)</span><span class="token punctuation">;</span>
            paddr_last <span class="token operator">=</span> <span class="token function">phys_p4d_init</span><span class="token punctuation">(</span>p4d<span class="token punctuation">,</span> <span class="token function">__pa</span><span class="token punctuation">(</span>vaddr<span class="token punctuation">)</span><span class="token punctuation">,</span>
                           <span class="token function">__pa</span><span class="token punctuation">(</span>vaddr_end<span class="token punctuation">)</span><span class="token punctuation">,</span>
                           page_size_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        p4d <span class="token operator">=</span> <span class="token function">alloc_low_page</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        paddr_last <span class="token operator">=</span> <span class="token function">phys_p4d_init</span><span class="token punctuation">(</span>p4d<span class="token punctuation">,</span> <span class="token function">__pa</span><span class="token punctuation">(</span>vaddr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">__pa</span><span class="token punctuation">(</span>vaddr_end<span class="token punctuation">)</span><span class="token punctuation">,</span>
                       page_size_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">p4d_populate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>init_mm<span class="token punctuation">,</span> <span class="token function">p4d_offset</span><span class="token punctuation">(</span>pgd<span class="token punctuation">,</span> vaddr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>pud_t <span class="token operator">*</span><span class="token punctuation">)</span> p4d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">__flush_tlb_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> paddr_l<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在kernel_physical_mapping_init里，我们先通过__va将物理地址转换为虚拟地址，然后在创建虚拟地址和物理地址的映射页表。</p>
<p>你可能会问，怎么这么麻烦啊？既然对于内核来讲，我们可以用<strong>va和</strong>pa直接在虚拟地址和物理地址之间直接转来转去，为啥还要辛辛苦苦建立页表呢？因为这是CPU和内存的硬件的需求，也就是说，CPU在保护模式下访问虚拟地址的时候，就会用CR3这个寄存器，这个寄存器是CPU定义的，作为操作系统，我们是软件，只能按照硬件的要求来。</p>
<p>你可能又会问了，按照咱们将初始化的时候的过程，系统早早就进入了保护模式，到了setup_arch里面才load_cr3，如果使用cr3是硬件的要求，那之前是怎么办的呢？如果你仔细去看arch\x86\kernel\head_64.S，这里面除了初始化内核页表之外，在这之前，还有另一个页表early_top_pgt。看到关键字early了嘛？这个页表就是专门用在真正的内核页表初始化之前，为了遵循硬件的要求而设置的。早期页表不是我们这节的重点，这里我就不展开多说了。</p>
<h4 id="21-2-vmalloc和kmap-atomic原理"><a href="#21-2-vmalloc和kmap-atomic原理" class="headerlink" title="21.2 vmalloc和kmap_atomic原理"></a>21.2 vmalloc和kmap_atomic原理</h4><p>在用户态可以通过malloc函数分配内存，当然malloc在分配比较大的内存的时候，底层调用的是mmap，当然也可以直接通过mmap做内存映射，在内核里面也有相应的函数。</p>
<p>在虚拟地址空间里面，有个vmalloc区域，从VMALLOC_START开始到VMALLOC_END，可以用于映射一段物理内存。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/**
 *  vmalloc  -  allocate virtually contiguous memory
 *  @size:    allocation size
 *  Allocate enough pages to cover @size from the page level
 *  allocator and map them into contiguous kernel virtual space.
 *
 *  For tight control over page level allocator and protection flags
 *  use __vmalloc() instead.
 */</span>
<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">vmalloc</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">__vmalloc_node_flags</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> NUMA_NO_NODE<span class="token punctuation">,</span>
                    GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">__vmalloc_node</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> align<span class="token punctuation">,</span>
                gfp_t gfp_mask<span class="token punctuation">,</span> pgprot_t prot<span class="token punctuation">,</span>
                <span class="token keyword">int</span> node<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>caller<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">__vmalloc_node_range</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> align<span class="token punctuation">,</span> VMALLOC_START<span class="token punctuation">,</span> VMALLOC_END<span class="token punctuation">,</span>
                gfp_mask<span class="token punctuation">,</span> prot<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> node<span class="token punctuation">,</span> caller<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们再来看内核的临时映射函数kmap_atomic的实现。从下面的代码我们可以看出，如果是32位有高端地址的，就需要调用set_pte通过内核页表进行临时映射；如果是64位没有高端地址的，就调用page_address，里面会调用lowmem_page_address。其实低端内存的映射，会直接使用__va进行临时映射。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">kmap_atomic_prot</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">,</span> pgprot_t prot<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">PageHighMem</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">page_address</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    vaddr <span class="token operator">=</span> <span class="token function">__fix_to_virt</span><span class="token punctuation">(</span>FIX_KMAP_BEGIN <span class="token operator">+</span> idx<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">set_pte</span><span class="token punctuation">(</span>kmap_pte<span class="token operator">-</span>idx<span class="token punctuation">,</span> <span class="token function">mk_pte</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> prot<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>vaddr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">kmap_atomic</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">kmap_atomic_prot</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> kmap_prot<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">lowmem_page_address</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">page_to_virt</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">page_to_virt</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token function">__va</span><span class="token punctuation">(</span><span class="token function">PFN_PHYS</span><span class="token punctuation">(</span><span class="token function">page_to_pfn</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="21-3-内核态缺页异常"><a href="#21-3-内核态缺页异常" class="headerlink" title="21.3 内核态缺页异常"></a>21.3 内核态缺页异常</h4><p>可以看出，kmap_atomic和vmalloc不同。kmap_atomic发现，没有页表的时候，就直接创建页表进行映射了。而vmalloc没有，它只分配了内核的虚拟地址。所以，访问它的时候，会产生缺页异常。</p>
<p>内核态的缺页异常还是会调用do_page_fault，但是会走到咱们上面用户态缺页异常中没有解析的那部分vmalloc_fault。这个函数并不复杂，主要用于关联内核页表项。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * 32-bit:
 *
 *   Handle a fault on the vmalloc or module mapping area
 */</span>
<span class="token keyword">static</span> noinline <span class="token keyword">int</span> <span class="token function">vmalloc_fault</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> address<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> pgd_paddr<span class="token punctuation">;</span>
    pmd_t <span class="token operator">*</span>pmd_k<span class="token punctuation">;</span>
    pte_t <span class="token operator">*</span>pte_k<span class="token punctuation">;</span>

    <span class="token comment">/* Make sure we are in vmalloc area: */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>address <span class="token operator">&gt;=</span> VMALLOC_START <span class="token operator">&amp;&amp;</span> address <span class="token operator">&lt;</span> VMALLOC_END<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token comment">/*
     * Synchronize this task's top level page-table
     * with the 'reference' page table.
     *
     * Do _not_ use "current" here. We might be inside
     * an interrupt in the middle of a task switch..
     */</span>
    pgd_paddr <span class="token operator">=</span> <span class="token function">read_cr3_pa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    pmd_k <span class="token operator">=</span> <span class="token function">vmalloc_sync_one</span><span class="token punctuation">(</span><span class="token function">__va</span><span class="token punctuation">(</span>pgd_paddr<span class="token punctuation">)</span><span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pmd_k<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

    pte_k <span class="token operator">=</span> <span class="token function">pte_offset_kernel</span><span class="token punctuation">(</span>pmd_k<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pte_present</span><span class="token punctuation">(</span><span class="token operator">*</span>pte_k<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="21-4-总结"><a href="#21-4-总结" class="headerlink" title="21.4 总结"></a>21.4 总结</h4><p>物理内存根据NUMA架构分节点。每个节点里面再分区域。每个区域里面再分页。</p>
<p>物理页面通过伙伴系统进行分配。分配的物理页面要变成虚拟地址让上层可以访问，kswapd可以根据物理页面的使用情况对页面进行换入换出。</p>
<p>对于内存的分配需求，可能来自内核态，也可能来自用户态。</p>
<p>对于内核态，kmalloc在分配大内存的时候，以及vmalloc分配不连续物理页的时候，直接使用伙伴系统，分配后转换为虚拟地址，访问的时候需要通过内核页表进行映射。</p>
<p>对于kmem_cache以及kmalloc分配小内存，则使用slub分配器，将伙伴系统分配出来的大块内存切成一小块一小块进行分配。</p>
<p>kmem_cache和kmalloc的部分不会被换出，因为用这两个函数分配的内存多用于保持内核关键的数据结构。内核态中vmalloc分配的部分会被换出，因而当访问的时候，发现不在，就会调用do_page_fault。</p>
<p>对于用户态的内存分配，或者直接调用mmap系统调用分配，或者调用malloc。调用malloc的时候，如果分配小的内存，就用sys_brk系统调用；如果分配大的内存，还是用sys_mmap系统调用。正常情况下，用户态的内存都是可以换出的，因而一旦发现内存中不存在，就会调用do_page_fault。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/内存管理的体系.png" alt="内存管理的体系"></p>
<h2 id="四、文件系统"><a href="#四、文件系统" class="headerlink" title="四、文件系统"></a>四、文件系统</h2><h3 id="22-文件系统"><a href="#22-文件系统" class="headerlink" title="22. 文件系统"></a>22. 文件系统</h3><h4 id="22-1-文件系统的功能规划"><a href="#22-1-文件系统的功能规划" class="headerlink" title="22.1 文件系统的功能规划"></a>22.1 文件系统的功能规划</h4><p>在规划文件系统的时候，需要考虑到以下几点。</p>
<ul>
<li>第一点，文件系统要有严格的组织形式，使得文件能够以块为单位进行存储。</li>
<li>第二点，文件系统中也要有索引区，用来方便查找一个文件分成的多个块都存放在了什么位置。</li>
<li>第三点，如果文件系统中有的文件是热点文件，近期经常被读取和写入，文件系统应该有缓存层。</li>
<li>第四点，文件应该用文件夹的形式组织起来，方便管理和查询。</li>
<li>第五点，Linux内核要在自己的内存里面维护一套数据结构，来保存哪些文件被哪些进程打开和使用。</li>
</ul>
<h4 id="22-2-文件系统相关命令行"><a href="#22-2-文件系统相关命令行" class="headerlink" title="22.2 文件系统相关命令行"></a>22.2 文件系统相关命令行</h4><h4 id="22-3-文件系统相关系统调用"><a href="#22-3-文件系统相关系统调用" class="headerlink" title="22.3 文件系统相关系统调用"></a>22.3 文件系统相关系统调用</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">stat</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">stat</span> <span class="token operator">*</span>statbuf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">fstat</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">stat</span> <span class="token operator">*</span>statbuf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">lstat</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">stat</span> <span class="token operator">*</span>statbuf<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">stat</span> <span class="token punctuation">{</span>
  dev_t  st_dev<span class="token punctuation">;</span>   <span class="token comment">/* ID of device containing file */</span>
  ino_t  st_ino<span class="token punctuation">;</span>   <span class="token comment">/* Inode number */</span>
  mode_t    st_mode<span class="token punctuation">;</span>        <span class="token comment">/* File type and mode */</span>
  nlink_t   st_nlink<span class="token punctuation">;</span>      <span class="token comment">/* Number of hard links */</span>
  uid_t  st_uid<span class="token punctuation">;</span>   <span class="token comment">/* User ID of owner */</span>
  gid_t  st_gid<span class="token punctuation">;</span>   <span class="token comment">/* Group ID of owner */</span>
  dev_t  st_rdev<span class="token punctuation">;</span>        <span class="token comment">/* Device ID (if special file) */</span>
  off_t  st_size<span class="token punctuation">;</span>        <span class="token comment">/* Total size, in bytes */</span>
  blksize_t st_blksize<span class="token punctuation">;</span>  <span class="token comment">/* Block size for filesystem I/O */</span>
  blkcnt_t  st_blocks<span class="token punctuation">;</span>    <span class="token comment">/* Number of 512B blocks allocated */</span>
  <span class="token keyword">struct</span> <span class="token class-name">timespec</span> st_atim<span class="token punctuation">;</span>  <span class="token comment">/* Time of last access */</span>
  <span class="token keyword">struct</span> <span class="token class-name">timespec</span> st_mtim<span class="token punctuation">;</span>  <span class="token comment">/* Time of last modification */</span>
  <span class="token keyword">struct</span> <span class="token class-name">timespec</span> st_ctim<span class="token punctuation">;</span>  <span class="token comment">/* Time of last status change */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>函数stat和lstat返回的是通过文件名查到的状态信息。这两个方法区别在于，stat没有处理符号链接（软链接）的能力。如果一个文件是符号链接，stat会直接返回它所指向的文件的属性，而lstat返回的就是这个符号链接的内容，fstat则是通过文件描述符获取文件对应的属性。</p>
<h3 id="23-硬盘文件系统"><a href="#23-硬盘文件系统" class="headerlink" title="23. 硬盘文件系统"></a>23. 硬盘文件系统</h3><p>这一节我们重点目前Linux下最主流的文件系统格式—— <strong>ext系列</strong> 的文件系统的格式。</p>
<h4 id="23-1-inode与块的存储"><a href="#23-1-inode与块的存储" class="headerlink" title="23.1 inode与块的存储"></a>23.1 inode与块的存储</h4><p>硬盘分成相同大小的单元，我们称为 <strong>块（Block）</strong> 。一块的大小是扇区大小的整数倍，默认是4K。在格式化的时候，这个值是可以设定的。</p>
<p>一大块硬盘被分成了一个个小的块，用来存放文件的数据部分。这样一来，如果我们像存放一个文件，就不用给他分配一块连续的空间了。我们可以分散成一个个小块进行存放。这样就灵活得多，也比较容易添加、删除和插入数据。</p>
<p>但是这也带来一个新的问题，那就是文件的数据存放得太散，找起来就比较困难。有什么办法解决呢？我们是不是可以像图书馆那样，也设立一个索引区域，用来维护“某个文件分成几块、每一块在哪里“等等这些 <strong>基本信息</strong> ?</p>
<p>另外，文件还有 <strong>元数据</strong> 部分，例如名字、权限等，这就需要一个结构<strong>inode</strong>来存放。</p>
<p>什么是inode呢？inode的“i”是index的意思，其实就是“索引”。既然如此，我们每个文件都会对应一个inode；一个文件夹就是一个文件，也对应一个inode。</p>
<p>至于inode里面有哪些信息，其实我们在内核中就有定义。你可以看下面这个数据结构。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">ext4_inode</span> <span class="token punctuation">{</span>
    __le16  i_mode<span class="token punctuation">;</span>         <span class="token comment">/* File mode */</span>
    __le16  i_uid<span class="token punctuation">;</span>          <span class="token comment">/* Low 16 bits of Owner Uid */</span>
    __le32  i_size_lo<span class="token punctuation">;</span>      <span class="token comment">/* Size in bytes */</span>
    __le32  i_atime<span class="token punctuation">;</span>        <span class="token comment">/* Access time */</span>
    __le32  i_ctime<span class="token punctuation">;</span>        <span class="token comment">/* Inode Change time */</span>
    __le32  i_mtime<span class="token punctuation">;</span>        <span class="token comment">/* Modification time */</span>
    __le32  i_dtime<span class="token punctuation">;</span>        <span class="token comment">/* Deletion Time */</span>
    __le16  i_gid<span class="token punctuation">;</span>          <span class="token comment">/* Low 16 bits of Group Id */</span>
    __le16  i_links_count<span class="token punctuation">;</span>  <span class="token comment">/* Links count */</span>
    __le32  i_blocks_lo<span class="token punctuation">;</span>    <span class="token comment">/* Blocks count */</span>
    __le32  i_flags<span class="token punctuation">;</span>        <span class="token comment">/* File flags */</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    __le32  i_block<span class="token punctuation">[</span>EXT4_N_BLOCKS<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">/* Pointers to blocks */</span>
    __le32  i_generation<span class="token punctuation">;</span>   <span class="token comment">/* File version (for NFS) */</span>
    __le32  i_file_acl_lo<span class="token punctuation">;</span>  <span class="token comment">/* File ACL */</span>
    __le32  i_size_high<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从这个数据结构中，我们可以看出，inode里面有文件的读写权限i_mode，属于哪个用户i_uid，哪个组i_gid，大小是多少i_size_io，占用多少个块i_blocks_io。咱们讲ls命令行的时候，列出来的权限、用户、大小这些信息，就是从这里面取出来的。</p>
<p>另外，这里面还有几个与文件相关的时间。i_atime是access time，是最近一次访问文件的时间；i_ctime是change time，是最近一次<strong>更改inode的时间</strong>；i_mtime是modify time，是最近一次<strong>更改文件的时间</strong>。</p>
<p>这里你需要注意区分几个地方。首先，访问了，不代表修改了，也可能只是打开看看，就会改变access time。其次，修改inode，有可能修改的是用户和权限，没有修改数据部分，就会改变change time。只有数据也修改了，才改变modify time。</p>
<p>我们刚才说的“某个文件分成几块、每一块在哪里”，这些在inode里面，应该保存在i_block里面。</p>
<p>具体如何保存的呢？EXT4_N_BLOCKS有如下的定义，计算下来一共有15项。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">EXT4_NDIR_BLOCKS        <span class="token number">12</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">EXT4_IND_BLOCK          EXT4_NDIR_BLOCKS</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">EXT4_DIND_BLOCK</span>         <span class="token punctuation">(</span>EXT4_IND_BLOCK <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">EXT4_TIND_BLOCK</span>         <span class="token punctuation">(</span>EXT4_DIND_BLOCK <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">EXT4_N_BLOCKS</span>           <span class="token punctuation">(</span>EXT4_TIND_BLOCK <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在ext2和ext3中，其中前12项直接保存了块的位置，也就是说，我们可以通过i_block[0-11]，直接得到保存文件内容的块。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/ext3_inode.jpeg" alt="ext3_inode"></p>
<p>但是，如果一个文件比较大，12块放不下。当我们用到i_block[12]的时候，就不能直接放数据块的位置了，要不然i_block很快就会用完了。这该怎么办呢？我们需要想个办法。我们可以让i_block[12]指向一个块，这个块里面不放数据块，而是放数据块的位置，这个块我们称为间接块。也就是说，我们在i_block[12]里面放间接块的位置，通过i_block[12]找到间接块后，间接块里面放数据块的位置，通过间接块可以找到数据块。</p>
<p>如果文件再大一些，i_block[13]会指向一个块，我们可以用二次间接块。二次间接块里面存放了间接块的位置，间接块里面存放了数据块的位置，数据块里面存放的是真正的数据。如果文件再大一些，i_block[14]会指向三次间接块。原理和上面都是一样的，就像一层套一层的俄罗斯套娃，一层一层打开，才能拿到最中心的数据块。</p>
<p>如果你稍微有点经验，现在你应该能够意识到，这里面有一个非常显著的问题，对于大文件来讲，我们要多次读取硬盘才能找到相应的块，这样访问速度就会比较慢。</p>
<p>为了解决这个问题，ext4做了一定的改变。它引入了一个新的概念，叫作<strong>Extents</strong>。</p>
<p>我们来解释一下Extents。比方说，一个文件大小为128M，如果使用4k大小的块进行存储，需要32k个块。如果按照ext2或者ext3那样散着放，数量太大了。但是Extents可以用于存放连续的块，也就是说，我们可以把128M放在一个Extents里面。这样的话，对大文件的读写性能提高了，文件碎片也减少了。</p>
<p>Exents如何来存储呢？它其实会保存成一棵树。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/ext4_inode.jpeg" alt="ext4_inode"></p>
<p>树有一个个的节点，有叶子节点，也有分支节点。每个节点都有一个头，ext4_extent_header可以用来描述某个节点。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">ext4_extent_header</span> <span class="token punctuation">{</span>
    __le16  eh_magic<span class="token punctuation">;</span>       <span class="token comment">/* probably will support different formats */</span>
    __le16  eh_entries<span class="token punctuation">;</span>     <span class="token comment">/* number of valid entries */</span>
    __le16  eh_max<span class="token punctuation">;</span>         <span class="token comment">/* capacity of store in entries */</span>
    __le16  eh_depth<span class="token punctuation">;</span>       <span class="token comment">/* has tree real underlying blocks? */</span>
    __le32  eh_generation<span class="token punctuation">;</span>  <span class="token comment">/* generation of the tree */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>eh_entries表示这个节点里面有多少项。这里的项分两种，如果是叶子节点，这一项会直接指向硬盘上的连续块的地址，我们称为数据节点ext4_extent；如果是分支节点，这一项会指向下一层的分支节点或者叶子节点，我们称为索引节点ext4_extent_idx。这两种类型的项的大小都是12个byte。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * This is the extent on-disk structure.
 * It's used at the bottom of the tree.
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">ext4_extent</span> <span class="token punctuation">{</span>
    __le32  ee_block<span class="token punctuation">;</span>       <span class="token comment">/* first logical block extent covers */</span>
    __le16  ee_len<span class="token punctuation">;</span>         <span class="token comment">/* number of blocks covered by extent */</span>
    __le16  ee_start_hi<span class="token punctuation">;</span>    <span class="token comment">/* high 16 bits of physical block */</span>
    __le32  ee_start_lo<span class="token punctuation">;</span>    <span class="token comment">/* low 32 bits of physical block */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">/*
 * This is index on-disk structure.
 * It's used at all the levels except the bottom.
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">ext4_extent_idx</span> <span class="token punctuation">{</span>
    __le32  ei_block<span class="token punctuation">;</span>   <span class="token comment">/* index covers logical blocks from 'block' */</span>
    __le32  ei_leaf_lo<span class="token punctuation">;</span> <span class="token comment">/* pointer to the physical block of the next *
                         * level. leaf or next index could be there */</span>
    __le16  ei_leaf_hi<span class="token punctuation">;</span> <span class="token comment">/* high 16 bits of physical block */</span>
    __u16   ei_unused<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果文件不大，inode里面的i_block中，可以放得下一个ext4_extent_header和4项ext4_extent。所以这个时候，eh_depth为0，也即inode里面的就是叶子节点，树高度为0。</p>
<p>如果文件比较大，4个extent放不下，就要分裂成为一棵树，eh_depth&gt;0的节点就是索引节点，其中根节点深度最大，在inode中。最底层eh_depth=0的是叶子节点。</p>
<p>除了根节点，其他的节点都保存在一个块4k里面，4k扣除ext4_extent_header的12个byte，剩下的能够放340项，每个extent最大能表示128MB的数据，340个extent会使你的表示的文件达到42.5GB。这已经非常大了，如果再大，我们可以增加树的深度。</p>
<h4 id="23-2-inode位图和块位图"><a href="#23-2-inode位图和块位图" class="headerlink" title="23.2 inode位图和块位图"></a>23.2 inode位图和块位图</h4><p>到这里，我们知道了，硬盘上肯定有一系列的inode和一系列的块排列起来。</p>
<p>在文件系统里面，我们专门弄了一个块来保存inode的位图。在这4k里面，每一位对应一个inode。如果是1，表示这个inode已经被用了；如果是0，则表示没被用。同样，我们也弄了一个块保存block的位图。</p>
<p>接下来，我们来看位图究竟是如何在Linux操作系统里面起作用的。前一节我们讲过，如果创建一个新文件，会调用open函数，并且参数会有O_CREAT。这表示当文件找不到的时候，我们就需要创建一个。open是一个系统调用，在内核里面会调用sys_open，定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>open<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> filename<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> flags<span class="token punctuation">,</span> umode_t<span class="token punctuation">,</span> mode<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">force_o_largefile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        flags <span class="token operator">|=</span> O_LARGEFILE<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token function">do_sys_open</span><span class="token punctuation">(</span>AT_FDCWD<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里我们还是重点看对于inode的操作。其实open一个文件很复杂，下一节我们会详细分析整个过程。</p>
<p>我们来看接下来的调用链：do_sys_open-&gt; do_filp_open-&gt;path_openat-&gt;do_last-&gt;lookup_open。这个调用链的逻辑是，要打开一个文件，先要根据路径找到文件夹。如果发现文件夹下面没有这个文件，同时又设置了O_CREAT，就说明我们要在这个文件夹下面创建一个文件，那我们就需要一个新的inode。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">lookup_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">nameidata</span> <span class="token operator">*</span>nd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">path</span> <span class="token operator">*</span>path<span class="token punctuation">,</span>
        <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span>
        <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">open_flags</span> <span class="token operator">*</span>op<span class="token punctuation">,</span>
        bool got_write<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>opened<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dentry<span class="token operator">-&gt;</span>d_inode <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>open_flag <span class="token operator">&amp;</span> O_CREAT<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    error <span class="token operator">=</span> dir_inode<span class="token operator">-&gt;</span>i_op<span class="token operator">-&gt;</span><span class="token function">create</span><span class="token punctuation">(</span>dir_inode<span class="token punctuation">,</span> dentry<span class="token punctuation">,</span> mode<span class="token punctuation">,</span>
            open_flag <span class="token operator">&amp;</span> O_EXCL<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>想要创建新的inode，我们就要调用dir_inode，也就是文件夹的inode的create函数。它的具体定义是这样的：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">inode_operations</span> ext4_dir_inode_operations <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>create     <span class="token operator">=</span> ext4_create<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>lookup     <span class="token operator">=</span> ext4_lookup<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>link       <span class="token operator">=</span> ext4_link<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>unlink     <span class="token operator">=</span> ext4_unlink<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>symlink    <span class="token operator">=</span> ext4_symlink<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>mkdir      <span class="token operator">=</span> ext4_mkdir<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>rmdir      <span class="token operator">=</span> ext4_rmdir<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>mknod      <span class="token operator">=</span> ext4_mknod<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>tmpfile    <span class="token operator">=</span> ext4_tmpfile<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>rename     <span class="token operator">=</span> ext4_rename2<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>setattr    <span class="token operator">=</span> ext4_setattr<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>getattr    <span class="token operator">=</span> ext4_getattr<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>listxattr  <span class="token operator">=</span> ext4_listxattr<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>get_acl    <span class="token operator">=</span> ext4_get_acl<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>set_acl    <span class="token operator">=</span> ext4_set_acl<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>fiemap     <span class="token operator">=</span> ext4_fiemap<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面定义了，如果文件夹inode要做一些操作，每个操作对应应该调用哪些函数。这里create操作调用的是ext4_create。</p>
<p>接下来的调用链是这样的：ext4_create-&gt;ext4_new_inode_start_handle-&gt;<strong>ext4_new_inode。在</strong>ext4_new_inode函数中，我们会创建新的inode。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token function">__ext4_new_inode</span><span class="token punctuation">(</span>handle_t <span class="token operator">*</span>handle<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>dir<span class="token punctuation">,</span>
                   umode_t mode<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">qstr</span> <span class="token operator">*</span>qstr<span class="token punctuation">,</span>
                   __u32 goal<span class="token punctuation">,</span> uid_t <span class="token operator">*</span>owner<span class="token punctuation">,</span> __u32 i_flags<span class="token punctuation">,</span>
                   <span class="token keyword">int</span> handle_type<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> line_no<span class="token punctuation">,</span>
                   <span class="token keyword">int</span> nblocks<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
inode_bitmap_bh <span class="token operator">=</span> <span class="token function">ext4_read_inode_bitmap</span><span class="token punctuation">(</span>sb<span class="token punctuation">,</span> group<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
ino <span class="token operator">=</span> <span class="token function">ext4_find_next_zero_bit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span>
                          inode_bitmap_bh<span class="token operator">-&gt;</span>b_data<span class="token punctuation">,</span>
                          <span class="token function">EXT4_INODES_PER_GROUP</span><span class="token punctuation">(</span>sb<span class="token punctuation">)</span><span class="token punctuation">,</span> ino<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面一个重要的逻辑就是，从文件系统里面读取inode位图，然后找到下一个为0的inode，就是空闲的inode。</p>
<p>对于block位图，在写入文件的时候，也会有这个过程，我就不展开说了。感兴趣的话，你可以自己去找代码看。</p>
<h4 id="23-3-文件系统的格式"><a href="#23-3-文件系统的格式" class="headerlink" title="23.3 文件系统的格式"></a>23.3 文件系统的格式</h4><p>看起来，我们现在应该能够很顺利地通过inode位图和block位图创建文件了。如果仔细计算一下，其实还是有问题的。</p>
<p>数据块的位图是放在一个块里面的，共4k。每位表示一个数据块，共可以表示 <code>4 * 1024 * 8 = 2^{15}</code> 个数据块。如果每个数据块也是按默认的4K，最大可以表示空间为 <code>2^{15} * 4 * 1024 = 2^{27}</code> 个byte，也就是128M。</p>
<p>也就是说按照上面的格式，如果采用“<strong>一个块的位图+一系列的块</strong>”，外加“<strong>一个块的inode的位图+一系列的inode的结构</strong>”，最多能够表示128M。是不是太小了？现在很多文件都比这个大。我们先把这个结构称为一个<strong>块组</strong>。有N多的块组，就能够表示N大的文件。</p>
<p>对于块组，我们也需要一个数据结构来表示为ext4_group_desc。这里面对于一个块组里的inode位图bg_inode_bitmap_lo、块位图bg_block_bitmap_lo、inode列表bg_inode_table_lo，都有相应的成员变量。</p>
<p>这样一个个块组，就基本构成了我们整个文件系统的结构。因为块组有多个，块组描述符也同样组成一个列表，我们把这些称为<strong>块组描述符表</strong>。</p>
<p>当然，我们还需要有一个数据结构，对整个文件系统的情况进行描述，这个就是<strong>超级块</strong>。ext4_super_block。这里面有整个文件系统一共有多少inode，s_inodes_count；一共有多少块，s_blocks_count_lo，每个块组有多少inode，s_inodes_per_group，每个块组有多少块，s_blocks_per_group等。这些都是这类的全局信息。</p>
<p>对于整个文件系统，别忘了咱们讲系统启动的时候说的。如果是一个启动盘，我们需要预留一块区域作为引导区，所以第一个块组的前面要留1K，用于启动引导区。</p>
<p>最终，整个文件系统格式就是下面这个样子。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/ext4文件系统格式.jpeg" alt="ext4文件系统格式"></p>
<p>超级块和块组描述符表都是全局信息，而且这些数据很重要。如果这些数据丢失了，整个文件系统都打不开了，这比一个文件的一个块损坏更严重。所以，这两部分我们都需要备份，但是采取不同的策略。</p>
<p>默认情况下，超级块和块组描述符表都有副本保存在每一个块组里面。</p>
<p>如果开启了sparse_super特性，超级块和块组描述符表的副本只会保存在块组索引为0、3、5、7的整数幂里。除了块组0中存在一个超级块外，在块组1（$3^0=1$）的第一个块中存在一个副本；在块组3（<code>3^1=3</code>）、块组5（<code>5^1=5</code>）、块组7（<code>7^1=7</code>）、块组9（<code>3^2=9</code>）、块组25（<code>5^2=25</code>）、块组27（<code>3^3=27</code>）的第一个block处也存在一个副本。</p>
<p>对于超级块来讲，由于超级块不是很大，所以就算我们备份多了也没有太多问题。但是，对于块组描述符表来讲，如果每个块组里面都保存一份完整的块组描述符表，一方面很浪费空间；另一个方面，由于一个块组最大128M，而块组描述符表里面有多少项，这就限制了有多少个块组，128M * 块组的总数目是整个文件系统的大小，就被限制住了。</p>
<p>我们的改进的思路就是引入<strong>Meta Block Groups特性</strong>。</p>
<p>首先，块组描述符表不会保存所有块组的描述符了，而是将块组分成多个组，我们称为元块组（Meta Block Group）。每个元块组里面的块组描述符表仅仅包括自己的，一个元块组包含64个块组，这样一个元块组中的块组描述符表最多64项。我们假设一共有256个块组，原来是一个整的块组描述符表，里面有256项，要备份就全备份，现在分成4个元块组，每个元块组里面的块组描述符表就只有64项了，这就小多了，而且四个元块组自己备份自己的。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/元块组.jpeg" alt="元块组"></p>
<p>根据图中，每一个元块组包含64个块组，块组描述符表也是64项，备份三份，在元块组的第一个，第二个和最后一个块组的开始处。</p>
<p>这样化整为零，我们就可以发挥出ext4的48位块寻址的优势了，在超级块ext4_super_block的定义中，我们可以看到块寻址的分为高位和地位，均为32位，其中有用的是48位，2^48个块是1EB，足够用了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">ext4_super_block</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    __le32  s_blocks_count_lo<span class="token punctuation">;</span>      <span class="token comment">/* Blocks count */</span>
    __le32  s_r_blocks_count_lo<span class="token punctuation">;</span>    <span class="token comment">/* Reserved blocks count */</span>
    __le32  s_free_blocks_count_lo<span class="token punctuation">;</span> <span class="token comment">/* Free blocks count */</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    __le32  s_blocks_count_hi<span class="token punctuation">;</span>      <span class="token comment">/* Blocks count */</span>
    __le32  s_r_blocks_count_hi<span class="token punctuation">;</span>    <span class="token comment">/* Reserved blocks count */</span>
    __le32  s_free_blocks_count_hi<span class="token punctuation">;</span> <span class="token comment">/* Free blocks count */</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="23-4-目录的存储格式"><a href="#23-4-目录的存储格式" class="headerlink" title="23.4 目录的存储格式"></a>23.4 目录的存储格式</h4><p>其实目录本身也是个文件，也有inode。inode里面也是指向一些块。和普通文件不同的是，普通文件的块里面保存的是文件数据，而目录文件的块里面保存的是目录里面一项一项的文件信息。这些信息我们称为ext4_dir_entry。从代码来看，有两个版本，在成员来讲几乎没有差别，只不过第二个版本ext4_dir_entry_2是将一个16位的name_len，变成了一个8位的name_len和8位的file_type。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">ext4_dir_entry</span> <span class="token punctuation">{</span>
    __le32  inode<span class="token punctuation">;</span>                  <span class="token comment">/* Inode number */</span>
    __le16  rec_len<span class="token punctuation">;</span>                <span class="token comment">/* Directory entry length */</span>
    __le16  name_len<span class="token punctuation">;</span>               <span class="token comment">/* Name length */</span>
    <span class="token keyword">char</span>    name<span class="token punctuation">[</span>EXT4_NAME_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">/* File name */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">ext4_dir_entry_2</span> <span class="token punctuation">{</span>
    __le32  inode<span class="token punctuation">;</span>                  <span class="token comment">/* Inode number */</span>
    __le16  rec_len<span class="token punctuation">;</span>                <span class="token comment">/* Directory entry length */</span>
    __u8    name_len<span class="token punctuation">;</span>               <span class="token comment">/* Name length */</span>
    __u8    file_type<span class="token punctuation">;</span>
    <span class="token keyword">char</span>    name<span class="token punctuation">[</span>EXT4_NAME_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">/* File name */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在目录文件的块中，最简单的保存格式是列表，就是一项一项地将ext4_dir_entry_2列在哪里。</p>
<p>每一项都会保存这个目录的下一级的文件的文件名和对应的inode，通过这个inode，就能找到真正的文件。第一项是“.”，表示当前目录，第二项是“…”，表示上一级目录，接下来就是一项一项的文件名和inode。</p>
<p>有时候，如果一个目录下面的文件太多的时候，我们想在这个目录下找一个文件，按照列表一个个去找，太慢了，于是我们就添加了索引的模式。</p>
<p>如果在inode中设置EXT4_INDEX_FL标志，则目录文件的块的组织形式将发生变化，变成了下面定义的这个样子：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">dx_root</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">fake_dirent</span> dot<span class="token punctuation">;</span>
    <span class="token keyword">char</span> dot_name<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">fake_dirent</span> dotdot<span class="token punctuation">;</span>
    <span class="token keyword">char</span> dotdot_name<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">dx_root_info</span>
    <span class="token punctuation">{</span>
        __le32 reserved_zero<span class="token punctuation">;</span>
        u8 hash_version<span class="token punctuation">;</span>
        u8 info_length<span class="token punctuation">;</span> <span class="token comment">/* 8 */</span>
        u8 indirect_levels<span class="token punctuation">;</span>
        u8 unused_flags<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    info<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">dx_entry</span> entries<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然，首先出现的还是差不多的，第一项是“.”，表示当前目录；第二项是“…”，表示上一级目录，这两个不变。接下来就开始发生改变了。是一个dx_root_info的结构，其中最重要的成员变量是indirect_levels，表示间接索引的层数。</p>
<p>接下来我们来看索引项dx_entry。这个也很简单，其实就是文件名的哈希值和数据块的一个映射关系。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">dx_entry</span>
<span class="token punctuation">{</span>
    __le32 hash<span class="token punctuation">;</span>
    __le32 block<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果我们要查找一个目录下面的文件名，可以通过名称取哈希。如果哈希能够匹配上，就说明这个文件的信息在相应的块里面。然后打开这个块，如果里面不再是索引，而是索引树的叶子节点的话，那里面还是ext4_dir_entry_2的列表，我们只要一项一项找文件名就行。通过索引树，我们可以将一个目录下面的N多的文件分散到很多的块里面，可以很快地进行查找。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/目录的存储格式.jpeg" alt="目录的存储格式"></p>
<h4 id="23-5-软链接和硬链接的存储格式"><a href="#23-5-软链接和硬链接的存储格式" class="headerlink" title="23.5 软链接和硬链接的存储格式"></a>23.5 软链接和硬链接的存储格式</h4><p>还有一种特殊的文件格式，硬链接（Hard Link）和软链接（Symbolic Link）。在讲操作文件的命令的时候，我们讲过软链接的概念。所谓的链接（Link），我们可以认为是文件的别名，而链接又可分为两种，硬链接与软链接。通过下面的命令可以创建。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ln</span> <span class="token punctuation">[</span>参数<span class="token punctuation">]</span><span class="token punctuation">[</span>源文件或目录<span class="token punctuation">]</span><span class="token punctuation">[</span>目标文件或目录<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>ln -s创建的是软链接，不带-s创建的是硬链接。它们有什么区别呢？在文件系统里面是怎么保存的呢？</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/软链接和硬链接.jpeg" alt="软链接和硬链接"></p>
<p>如图所示，硬链接与原始文件共用一个inode的，但是inode是不跨文件系统的，每个文件系统都有自己的inode列表，因而硬链接是没有办法跨文件系统的。</p>
<p>而软链接不同，软链接相当于重新创建了一个文件。这个文件也有独立的inode，只不过打开这个文件看里面内容的时候，内容指向另外的一个文件。这就很灵活了。我们可以跨文件系统，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</p>
<h4 id="23-6-总结"><a href="#23-6-总结" class="headerlink" title="23.6 总结"></a>23.6 总结</h4><p>为了表示图中上半部分的那个简单的树形结构，在文件系统上的布局就像图的下半部分一样。无论是文件夹还是文件，都有一个inode。inode里面会指向数据块，对于文件夹的数据块，里面是一个表，是下一层的文件名和inode的对应关系，文件的数据块里面存放的才是真正的数据。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/ext文件系统.png" alt="ext文件系统"></p>
<h3 id="24-虚拟文件系统"><a href="#24-虚拟文件系统" class="headerlink" title="24. 虚拟文件系统"></a>24. 虚拟文件系统</h3><p>进程要想往文件系统里面读写数据，需要很多层的组件一起合作。具体是怎么合作的呢？我们一起来看一看。</p>
<ul>
<li>在应用层，进程在进行文件读写操作时，可通过系统调用如sys_open、sys_read、sys_write等。</li>
<li>在内核，每个进程都需要为打开的文件，维护一定的数据结构。</li>
<li>在内核，整个系统打开的文件，也需要维护一定的数据结构。</li>
<li>Linux可以支持多达数十种不同的文件系统。它们的实现各不相同，因此Linux内核向用户空间提供了虚拟文件系统这个统一的接口，来对文件系统进行操作。它提供了常见的文件系统对象模型，例如inode、directory entry、mount等，以及操作这些对象的方法，例如inode operations、directory operations、file operations等。</li>
<li>然后就是对接的是真正的文件系统，例如我们上节讲的ext4文件系统。</li>
<li>为了读写ext4文件系统，要通过块设备I/O层，也即BIO层。这是文件系统层和块设备驱动的接口。</li>
<li>为了加快块设备的读写效率，我们还有一个缓存层。</li>
<li>最下层是块设备驱动程序。</li>
</ul>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/虚拟文件系统.jpg" alt="虚拟文件系统"></p>
<p>接下来我们逐层解析。</p>
<p>在这之前，有一点你需要注意。解析系统调用是了解内核架构最有力的一把钥匙，这里我们只要重点关注这几个最重要的系统调用就可以了：</p>
<ul>
<li>mount系统调用用于挂载文件系统；</li>
<li>open系统调用用于打开或者创建文件，创建要在flags中设置O_CREAT，对于读写要设置flags为O_RDWR；</li>
<li>read系统调用用于读取文件内容；</li>
<li>write系统调用用于写入文件内容。</li>
</ul>
<h4 id="24-1-挂载文件系统"><a href="#24-1-挂载文件系统" class="headerlink" title="24.1 挂载文件系统"></a>24.1 挂载文件系统</h4><p>内核是不是支持某种类型的文件系统，需要我们进行注册才能知道。例如，咱们上一节解析的ext4文件系统，就需要通过register_filesystem进行注册，传入的参数是ext4_fs_type，表示注册的是ext4类型的文件系统。这里面最重要的一个成员变量就是ext4_mount。记住它，这个我们后面还会用。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">register_filesystem</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ext4_fs_type<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">file_system_type</span> ext4_fs_type <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>owner    <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>name      <span class="token operator">=</span> <span class="token string">"ext4"</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>mount    <span class="token operator">=</span> ext4_mount<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>kill_sb    <span class="token operator">=</span> kill_block_super<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>fs_flags   <span class="token operator">=</span> FS_REQUIRES_DEV<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果一种文件系统的类型曾经在内核注册过，这就说明允许你挂载并且使用这个文件系统。</p>
<p>刚才我说了几个需要重点关注的系统调用，那我们就从第一个mount系统调用开始解析。mount系统调用的定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE5</span><span class="token punctuation">(</span>mount<span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> dev_name<span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> dir_name<span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> type<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> flags<span class="token punctuation">,</span> <span class="token keyword">void</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    ret <span class="token operator">=</span> <span class="token function">do_mount</span><span class="token punctuation">(</span>kernel_dev<span class="token punctuation">,</span> dir_name<span class="token punctuation">,</span> kernel_type<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来的调用链为：do_mount-&gt;do_new_mount-&gt;vfs_kern_mount。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">vfsmount</span> <span class="token operator">*</span>
<span class="token function">vfs_kern_mount</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file_system_type</span> <span class="token operator">*</span>type<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    mnt <span class="token operator">=</span> <span class="token function">alloc_vfsmnt</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    root <span class="token operator">=</span> <span class="token function">mount_fs</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> name<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    mnt<span class="token operator">-&gt;</span>mnt<span class="token punctuation">.</span>mnt_root <span class="token operator">=</span> root<span class="token punctuation">;</span>
    mnt<span class="token operator">-&gt;</span>mnt<span class="token punctuation">.</span>mnt_sb <span class="token operator">=</span> root<span class="token operator">-&gt;</span>d_sb<span class="token punctuation">;</span>
    mnt<span class="token operator">-&gt;</span>mnt_mountpoint <span class="token operator">=</span> mnt<span class="token operator">-&gt;</span>mnt<span class="token punctuation">.</span>mnt_root<span class="token punctuation">;</span>
    mnt<span class="token operator">-&gt;</span>mnt_parent <span class="token operator">=</span> mnt<span class="token punctuation">;</span>
    <span class="token function">list_add_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mnt<span class="token operator">-&gt;</span>mnt_instance<span class="token punctuation">,</span> <span class="token operator">&amp;</span>root<span class="token operator">-&gt;</span>d_sb<span class="token operator">-&gt;</span>s_mounts<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">&amp;</span>mnt<span class="token operator">-&gt;</span>mnt<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>vfs_kern_mount先是创建struct mount结构，每个挂载的文件系统都对应于这样一个结构。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">mount</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">hlist_node</span> mnt_hash<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">mount</span> <span class="token operator">*</span>mnt_parent<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span>mnt_mountpoint<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">vfsmount</span> mnt<span class="token punctuation">;</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">rcu_head</span> mnt_rcu<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">llist_node</span> mnt_llist<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> mnt_mounts<span class="token punctuation">;</span>    <span class="token comment">/* list of children, anchored here */</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> mnt_child<span class="token punctuation">;</span>  <span class="token comment">/* and going through their mnt_child */</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> mnt_instance<span class="token punctuation">;</span>  <span class="token comment">/* mount instance on sb-&gt;s_mounts */</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>mnt_devname<span class="token punctuation">;</span>        <span class="token comment">/* Name of device e.g. /dev/dsk/hda1 */</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> mnt_list<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span> __randomize_layout<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">vfsmount</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span>mnt_root<span class="token punctuation">;</span>    <span class="token comment">/* root of the mounted tree */</span>
    <span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span>mnt_sb<span class="token punctuation">;</span> <span class="token comment">/* pointer to superblock */</span>
    <span class="token keyword">int</span> mnt_flags<span class="token punctuation">;</span>
<span class="token punctuation">}</span> __randomize_layout<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，mnt_parent是装载点所在的父文件系统，mnt_mountpoint是装载点在父文件系统中的dentry；struct dentry表示目录，并和目录的inode关联；mnt_root是当前文件系统根目录的dentry，mnt_sb是指向超级块的指针。</p>
<p>接下来，我们来看调用mount_fs挂载文件系统。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span>
<span class="token function">mount_fs</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file_system_type</span> <span class="token operator">*</span>type<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span>root<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span>sb<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    root <span class="token operator">=</span> type<span class="token operator">-&gt;</span><span class="token function">mount</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> name<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    sb <span class="token operator">=</span> root<span class="token operator">-&gt;</span>d_sb<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里调用的是ext4_fs_type的mount函数，也就是咱们上面提到的ext4_mount，从文件系统里面读取超级块。在文件系统的实现中，每个在硬盘上的结构，在内存中也对应相同格式的结构。当所有的数据结构都读到内存里面，内核就可以通过操作这些数据结构，来操作文件系统了。</p>
<p>可以看出来，理解各个数据结构在这里的关系，非常重要。我这里举一个例子，来解析经过mount之后，刚刚那些数据结构之间的关系。</p>
<p>我们假设根文件系统下面有一个目录home，有另外一个文件系统A挂载在这个目录home下面。在文件系统A的根目录下面有另外一个文件夹hello。由于文件系统A已经挂载到了目录home下面，所以我们就有了目录/home/hello，然后有另外一个文件系统B挂在在/home/hello下面。在文件系统B的根目录下面有另外一个文件夹world，在world下面有个文件夹data。由于文件系统B已经挂载到了/home/hello下面，所以我们就有了目录/home/hello/world/data。</p>
<p>为了维护这些关系，操作系统创建了这一系列数据结构。具体你可以看下面的图。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/挂载文件系统举例.jpeg" alt="挂载文件系统举例"></p>
<p>文件系统是树形关系。如果所有的文件夹都是几代单传，那就变成了一条线。你注意看图中的三条斜线。</p>
<p>第一条线是最左边的向左斜的<strong><em>dentry斜线</em></strong>。每一个文件和文件夹都有dentry，用于和inode关联。第二条线是最右面的向右斜的<strong>mount斜线</strong>，因为这个例子涉及两次文件系统的挂载，再加上启动的时候挂载的根文件系统，一共三个mount。第三条线是中间的向右斜的<strong>file斜线</strong>，每个打开的文件都有一个file结构，它里面有两个变量，一个指向相应的mount，一个指向相应的dentry。</p>
<p>我们从最上面往下看。根目录/对应一个dentry，根目录是在根文件系统上的，根文件系统是系统启动的时候挂载的，因而有一个mount结构。这个mount结构的mount point指针和mount root指针都是指向根目录的dentry。根目录对应的file的两个指针，一个指向根目录的dentry，一个指向根目录的挂载结构mount。</p>
<p>我们再来看第二层。下一层目录home对应了两个dentry，而且它们的parent都指向第一层的dentry。这是为什么呢？这是因为文件系统A挂载到了这个目录下。这使得这个目录有两个用处。一方面，home是根文件系统的一个挂载点；另一方面，home是文件系统A的根目录。</p>
<p>因为还有一次挂载，因而又有了一个mount结构。这个mount结构的mount point指针指向作为挂载点的那个dentry。mount root指针指向作为根目录的那个dentry，同时parent指针指向第一层的mount结构。home对应的file的两个指针，一个指向文件系统A根目录的dentry，一个指向文件系统A的挂载结构mount。</p>
<p>我们再来看第三层。目录hello又挂载了一个文件系统B，所以第三层的结构和第二层几乎一样。</p>
<p>接下来是第四层。目录world就是一个普通的目录。只要它的dentry的parent指针指向上一层就可以了。我们来看world对应的file结构。由于挂载点不变，还是指向第三层的mount结构。</p>
<p>接下来是第五层。对于文件data，是一个普通的文件，它的dentry的parent指向第四层的dentry。对于data对应的file结构，由于挂载点不变，还是指向第三层的mount结构。</p>
<h4 id="24-2-打开文件"><a href="#24-2-打开文件" class="headerlink" title="24.2 打开文件"></a>24.2 打开文件</h4><p>在进程里面通过open系统调用打开文件，最终对调用到内核的系统调用实现sys_open。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>open<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> filename<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> flags<span class="token punctuation">,</span> umode_t<span class="token punctuation">,</span> mode<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> <span class="token function">do_sys_open</span><span class="token punctuation">(</span>AT_FDCWD<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">long</span> <span class="token function">do_sys_open</span><span class="token punctuation">(</span><span class="token keyword">int</span> dfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>filename<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> umode_t mode<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    fd <span class="token operator">=</span> <span class="token function">get_unused_fd_flags</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>f <span class="token operator">=</span> <span class="token function">do_filp_open</span><span class="token punctuation">(</span>dfd<span class="token punctuation">,</span> tmp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>op<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">put_unused_fd</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
            fd <span class="token operator">=</span> <span class="token function">PTR_ERR</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">fsnotify_open</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">fd_install</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">putname</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> fd<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要打开一个文件，首先要通过get_unused_fd_flags得到一个没有用的文件描述符。</p>
<p>在每一个进程的task_struct中，有一个指针files，类型是files_struct。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">files_struct</span>  <span class="token operator">*</span>files<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>files_struct里面最重要的是一个文件描述符列表，每打开一个文件，就会在这个列表中分配一项，下标就是文件描述符。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">files_struct</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">struct</span> <span class="token class-name">file</span> __rcu <span class="token operator">*</span> fd_array<span class="token punctuation">[</span>NR_OPEN_DEFAULT<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于任何一个进程，默认情况下，文件描述符0表示stdin标准输入，文件描述符1表示stdout标准输出，文件描述符2表示stderr标准错误输出。另外，再打开的文件，都会从这个列表中找一个空闲位置分配给它。</p>
<p>文件描述符列表的每一项都是一个指向struct file的指针，也就是说，每打开一个文件，都会有一个struct file对应。</p>
<p>do_sys_open中调用do_filp_open，就是创建这个struct file结构，然后fd_install(fd, f)是将文件描述符和这个结构关联起来。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token function">do_filp_open</span><span class="token punctuation">(</span><span class="token keyword">int</span> dfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">filename</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span>
        <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">open_flags</span> <span class="token operator">*</span>op<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">set_nameidata</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>nd<span class="token punctuation">,</span> dfd<span class="token punctuation">,</span> pathname<span class="token punctuation">)</span><span class="token punctuation">;</span>
    filp <span class="token operator">=</span> <span class="token function">path_openat</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>nd<span class="token punctuation">,</span> op<span class="token punctuation">,</span> flags <span class="token operator">|</span> LOOKUP_RCU<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">restore_nameidata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> filp<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>do_filp_open里面首先初始化了struct nameidata这个结构。我们知道，文件都是一串的路径名称，需要逐个解析。这个结构就是解析和查找路径的时候做辅助作用。</p>
<p>在struct nameidata里面有一个关键的成员变量struct path。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">path</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">vfsmount</span> <span class="token operator">*</span>mnt<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span>dentry<span class="token punctuation">;</span>
<span class="token punctuation">}</span> __randomize_layout<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，struct vfsmount和文件系统的挂载有关。另一个struct dentry，除了上面说的用于标识目录之外，还可以表示文件名，还会建立了文件名及其inode之间的关联。</p>
<p>接下来就调用path_openat，主要做了以下几件事情：</p>
<ul>
<li>get_empty_filp生成一个struct file结构；</li>
<li>path_init初始化nameidata，准备开始节点路径查找；</li>
<li>link_path_walk对于路径名逐层进行节点路径查找，这里面有一个大的循环，用“/”分隔逐层处理；</li>
<li>do_last获取文件对应的inode对象，并且初始化file对象。</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token function">path_openat</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">nameidata</span> <span class="token operator">*</span>nd<span class="token punctuation">,</span>
            <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">open_flags</span> <span class="token operator">*</span>op<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    file <span class="token operator">=</span> <span class="token function">get_empty_filp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    s <span class="token operator">=</span> <span class="token function">path_init</span><span class="token punctuation">(</span>nd<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>error <span class="token operator">=</span> <span class="token function">link_path_walk</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> nd<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        <span class="token punctuation">(</span>error <span class="token operator">=</span> <span class="token function">do_last</span><span class="token punctuation">(</span>nd<span class="token punctuation">,</span> file<span class="token punctuation">,</span> op<span class="token punctuation">,</span> <span class="token operator">&amp;</span>opened<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
    <span class="token function">terminate_walk</span><span class="token punctuation">(</span>nd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> file<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例如，文件“/root/hello/world/data”，link_path_walk会解析前面的路径部分“/root/hello/world”，解析完毕的时候nameidata的dentry为路径名的最后一部分的父目录“/root/hello/world”，而nameidata的filename为路径名的最后一部分“data”。</p>
<p>最后一部分的解析和处理，我们交给do_last。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">do_last</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">nameidata</span> <span class="token operator">*</span>nd<span class="token punctuation">,</span>
        <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">open_flags</span> <span class="token operator">*</span>op<span class="token punctuation">,</span>
        <span class="token keyword">int</span> <span class="token operator">*</span>opened<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    error <span class="token operator">=</span> <span class="token function">lookup_fast</span><span class="token punctuation">(</span>nd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>path<span class="token punctuation">,</span> <span class="token operator">&amp;</span>inode<span class="token punctuation">,</span> <span class="token operator">&amp;</span>seq<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    error <span class="token operator">=</span> <span class="token function">lookup_open</span><span class="token punctuation">(</span>nd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>path<span class="token punctuation">,</span> file<span class="token punctuation">,</span> op<span class="token punctuation">,</span> got_write<span class="token punctuation">,</span> opened<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    error <span class="token operator">=</span> <span class="token function">vfs_open</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>nd<span class="token operator">-&gt;</span>path<span class="token punctuation">,</span> file<span class="token punctuation">,</span> <span class="token function">current_cred</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里面，我们需要先查找文件路径最后一部分对应的dentry。如何查找呢？</p>
<p>Linux为了提高目录项对象的处理效率，设计与实现了目录项高速缓存dentry cache，简称dcache。它主要由两个数据结构组成：</p>
<ul>
<li>哈希表dentry_hashtable：dcache中的所有dentry对象都通过d_hash指针链到相应的dentry哈希链表中；</li>
<li>未使用的dentry对象链表s_dentry_lru：dentry对象通过其d_lru指针链入LRU链表中。LRU的意思是最近最少使用，我们已经好几次看到它了。只要有它，就说明长时间不使用，就应该释放了。</li>
</ul>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/目录项高速缓存.jpeg" alt="目录项高速缓存"></p>
<p>这两个列表之间会产生复杂的关系：</p>
<ul>
<li>引用为0：一个在散列表中的dentry变成没有人引用了，就会被加到LRU表中去；</li>
<li>再次被引用：一个在LRU表中的dentry再次被引用了，则从LRU表中移除；</li>
<li>分配：当dentry在散列表中没有找到，则从Slub分配器中分配一个；</li>
<li>过期归还：当LRU表中最长时间没有使用的dentry应该释放回Slub分配器；</li>
<li>文件删除：文件被删除了，相应的dentry应该释放回Slub分配器；</li>
<li>结构复用：当需要分配一个dentry，但是无法分配新的，就从LRU表中取出一个来复用。</li>
</ul>
<p>所以，do_last()在查找dentry的时候，当然先从缓存中查找，调用的是lookup_fast。</p>
<p>如果缓存中没有找到，就需要真的到文件系统里面去找了，lookup_open会创建一个新的dentry，并且调用上一级目录的Inode的inode_operations的lookup函数，对于ext4来讲，调用的是ext4_lookup，会到咱们上一节讲的文件系统里面去找inode。最终找到后将新生成的dentry付给path变量。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">lookup_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">nameidata</span> <span class="token operator">*</span>nd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">path</span> <span class="token operator">*</span>path<span class="token punctuation">,</span>
        <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span>
        <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">open_flags</span> <span class="token operator">*</span>op<span class="token punctuation">,</span>
        bool got_write<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>opened<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    dentry <span class="token operator">=</span> <span class="token function">d_alloc_parallel</span><span class="token punctuation">(</span>dir<span class="token punctuation">,</span> <span class="token operator">&amp;</span>nd<span class="token operator">-&gt;</span>last<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wq<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span>res <span class="token operator">=</span> dir_inode<span class="token operator">-&gt;</span>i_op<span class="token operator">-&gt;</span><span class="token function">lookup</span><span class="token punctuation">(</span>dir_inode<span class="token punctuation">,</span> dentry<span class="token punctuation">,</span>
                     nd<span class="token operator">-&gt;</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    path<span class="token operator">-&gt;</span>dentry <span class="token operator">=</span> dentry<span class="token punctuation">;</span>
    path<span class="token operator">-&gt;</span>mnt <span class="token operator">=</span> nd<span class="token operator">-&gt;</span>path<span class="token punctuation">.</span>mnt<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">inode_operations</span> ext4_dir_inode_operations <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>create <span class="token operator">=</span> ext4_create<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>lookup <span class="token operator">=</span> ext4_lookup<span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>do_last()的最后一步是调用vfs_open真正打开文件。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">vfs_open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">path</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span>
         <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">cred</span> <span class="token operator">*</span>cred<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span>dentry <span class="token operator">=</span> <span class="token function">d_real</span><span class="token punctuation">(</span>path<span class="token operator">-&gt;</span>dentry<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> file<span class="token operator">-&gt;</span>f_flags<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    file<span class="token operator">-&gt;</span>f_path <span class="token operator">=</span> <span class="token operator">*</span>path<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">do_dentry_open</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> <span class="token function">d_backing_inode</span><span class="token punctuation">(</span>dentry<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> cred<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">do_dentry_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>f<span class="token punctuation">,</span>
              <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span>
              <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>open<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
              <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">cred</span> <span class="token operator">*</span>cred<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    f<span class="token operator">-&gt;</span>f_mode <span class="token operator">=</span> <span class="token function">OPEN_FMODE</span><span class="token punctuation">(</span>f<span class="token operator">-&gt;</span>f_flags<span class="token punctuation">)</span> <span class="token operator">|</span> FMODE_LSEEK <span class="token operator">|</span>
                FMODE_PREAD <span class="token operator">|</span> FMODE_PWRITE<span class="token punctuation">;</span>
    <span class="token function">path_get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>f<span class="token operator">-&gt;</span>f_path<span class="token punctuation">)</span><span class="token punctuation">;</span>
    f<span class="token operator">-&gt;</span>f_inode <span class="token operator">=</span> inode<span class="token punctuation">;</span>
    f<span class="token operator">-&gt;</span>f_mapping <span class="token operator">=</span> inode<span class="token operator">-&gt;</span>i_mapping<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    f<span class="token operator">-&gt;</span>f_op <span class="token operator">=</span> <span class="token function">fops_get</span><span class="token punctuation">(</span>inode<span class="token operator">-&gt;</span>i_fop<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    open <span class="token operator">=</span> f<span class="token operator">-&gt;</span>f_op<span class="token operator">-&gt;</span>open<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    error <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>inode<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    f<span class="token operator">-&gt;</span>f_flags <span class="token operator">&amp;=</span> <span class="token operator">~</span><span class="token punctuation">(</span>O_CREAT <span class="token operator">|</span> O_EXCL <span class="token operator">|</span> O_NOCTTY <span class="token operator">|</span> O_TRUNC<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">file_ra_state_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>f<span class="token operator">-&gt;</span>f_ra<span class="token punctuation">,</span> f<span class="token operator">-&gt;</span>f_mapping<span class="token operator">-&gt;</span>host<span class="token operator">-&gt;</span>i_mapping<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>


<span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> ext4_file_operations <span class="token operator">=</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">.</span>open       <span class="token operator">=</span> ext4_file_open<span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>vfs_open里面最终要做的一件事情是，调用f_op-&gt;open，也就是调用ext4_file_open。另外一件重要的事情是将打开文件的所有信息，填写到struct file这个结构里面。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token punctuation">{</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">llist_node</span>   fu_llist<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">rcu_head</span>     fu_rcuhead<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> f_u<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">path</span>             f_path<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">inode</span>            <span class="token operator">*</span>f_inode<span class="token punctuation">;</span>   <span class="token comment">/* cached value */</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span>            <span class="token class-name">file_operations</span>    <span class="token operator">*</span>f_op<span class="token punctuation">;</span>
    spinlock_t              f_lock<span class="token punctuation">;</span>
    <span class="token keyword">enum</span> <span class="token class-name">rw_hint</span>            f_write_hint<span class="token punctuation">;</span>
    atomic_long_t           f_count<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>            f_flags<span class="token punctuation">;</span>
    fmode_t                 f_mode<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">mutex</span>            f_pos_lock<span class="token punctuation">;</span>
    loff_t                  f_pos<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">fown_struct</span>      f_owner<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">cred</span>       <span class="token operator">*</span>f_cred<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">struct</span> <span class="token class-name">address_space</span>    <span class="token operator">*</span>f_mapping<span class="token punctuation">;</span>
    errseq_t                f_wb_err<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="24-3-总结"><a href="#24-3-总结" class="headerlink" title="24.3 总结"></a>24.3 总结</h4><p><img src="/images/《趣谈Linux操作系统》学习笔记/虚拟文件系统总结.png" alt="虚拟文件系统总结"></p>
<p>这张图十分重要，一定要掌握。因为我们后面的字符设备、块设备、管道、进程间通信、网络等等，全部都要用到这里面的知识。希望当你再次遇到它的时候，能够马上说出各个数据结构直接的关系。</p>
<p>这里我带你简单做一个梳理，帮助你理解记忆它。</p>
<p>对于每一个进程，打开的文件都有一个文件描述符，在files_struct里面会有文件描述符数组。每个一个文件描述符是这个数组的下标，里面的内容指向一个file结构，表示打开的文件。这个结构里面有这个文件对应的inode，最重要的是这个文件对应的操作file_operation。如果操作这个文件，就看这个file_operation里面的定义了。</p>
<p>对于每一个打开的文件，都有一个dentry对应，虽然叫作directory entry，但是不仅仅表示文件夹，也表示文件。它最重要的作用就是指向这个文件对应的inode。</p>
<p>如果说file结构是一个文件打开以后才创建的，dentry是放在一个dentry cache里面的，文件关闭了，他依然存在，因而他可以更长期的维护内存中的文件的表示和硬盘上文件的表示之间的关系。</p>
<p>inode结构就表示硬盘上的inode，包括块设备号等。</p>
<p>几乎每一种结构都有自己对应的operation结构，里面都是一些方法，因而当后面遇到对于某种结构进行处理的时候，如果不容易找到相应的处理函数，就先找这个operation结构，就清楚了。</p>
<h3 id="25-文件缓存"><a href="#25-文件缓存" class="headerlink" title="25. 文件缓存"></a>25. 文件缓存</h3><h4 id="25-1-系统调用层和虚拟文件系统层"><a href="#25-1-系统调用层和虚拟文件系统层" class="headerlink" title="25.1 系统调用层和虚拟文件系统层"></a>25.1 系统调用层和虚拟文件系统层</h4><p>文件系统的读写，其实就是调用系统函数read和write。由于读和写的很多逻辑是相似的，这里我们一起来看一下这个过程。</p>
<p>下面的代码就是read和write的系统调用，在内核里面的定义。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>read<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> size_t<span class="token punctuation">,</span> count<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">fd</span> f <span class="token operator">=</span> <span class="token function">fdget_pos</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    loff_t pos <span class="token operator">=</span> <span class="token function">file_pos_read</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ret <span class="token operator">=</span> <span class="token function">vfs_read</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>file<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> count<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>


<span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>write<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span>
        size_t<span class="token punctuation">,</span> count<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">fd</span> f <span class="token operator">=</span> <span class="token function">fdget_pos</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    loff_t pos <span class="token operator">=</span> <span class="token function">file_pos_read</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ret <span class="token operator">=</span> <span class="token function">vfs_write</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>file<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> count<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于read来讲，里面调用vfs_read-&gt;<strong>vfs_read。对于write来讲，里面调用vfs_write-&gt;</strong>vfs_write。</p>
<p>下面是<strong>vfs_read和</strong>vfs_write的代码。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">ssize_t <span class="token function">__vfs_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t count<span class="token punctuation">,</span>
        loff_t <span class="token operator">*</span>pos<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>file<span class="token operator">-&gt;</span>f_op<span class="token operator">-&gt;</span>read<span class="token punctuation">)</span>
        <span class="token keyword">return</span> file<span class="token operator">-&gt;</span>f_op<span class="token operator">-&gt;</span><span class="token function">read</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> count<span class="token punctuation">,</span> pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>file<span class="token operator">-&gt;</span>f_op<span class="token operator">-&gt;</span>read_iter<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">new_sync_read</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> count<span class="token punctuation">,</span> pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

ssize_t <span class="token function">__vfs_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>p<span class="token punctuation">,</span> size_t count<span class="token punctuation">,</span>
         loff_t <span class="token operator">*</span>pos<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>file<span class="token operator">-&gt;</span>f_op<span class="token operator">-&gt;</span>write<span class="token punctuation">)</span>
        <span class="token keyword">return</span> file<span class="token operator">-&gt;</span>f_op<span class="token operator">-&gt;</span><span class="token function">write</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> p<span class="token punctuation">,</span> count<span class="token punctuation">,</span> pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>file<span class="token operator">-&gt;</span>f_op<span class="token operator">-&gt;</span>write_iter<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">new_sync_write</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> p<span class="token punctuation">,</span> count<span class="token punctuation">,</span> pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上一节，我们讲了，每一个打开的文件，都有一个struct file结构。这里面有一个struct file_operations f_op，用于定义对这个文件做的操作。<strong>vfs_read会调用相应文件系统的file_operations里面的read操作，</strong>vfs_write会调用相应文件系统file_operations里的write操作。</p>
<h4 id="25-2-ext4文件系统层"><a href="#25-2-ext4文件系统层" class="headerlink" title="25.2 ext4文件系统层"></a>25.2 ext4文件系统层</h4><p>对于ext4文件系统来讲，内核定义了一个ext4_file_operations。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> ext4_file_operations <span class="token operator">=</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">.</span>read_iter  <span class="token operator">=</span> ext4_file_read_iter<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>write_iter <span class="token operator">=</span> ext4_file_write_iter<span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于ext4没有定义read和write函数，于是会调用ext4_file_read_iter和ext4_file_write_iter。</p>
<p>ext4_file_read_iter会调用generic_file_read_iter，ext4_file_write_iter会调用__generic_file_write_iter。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">ssize_t
<span class="token function">generic_file_read_iter</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kiocb</span> <span class="token operator">*</span>iocb<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">iov_iter</span> <span class="token operator">*</span>iter<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>iocb<span class="token operator">-&gt;</span>ki_flags <span class="token operator">&amp;</span> IOCB_DIRECT<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">struct</span> <span class="token class-name">address_space</span> <span class="token operator">*</span>mapping <span class="token operator">=</span> file<span class="token operator">-&gt;</span>f_mapping<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        retval <span class="token operator">=</span> mapping<span class="token operator">-&gt;</span>a_ops<span class="token operator">-&gt;</span><span class="token function">direct_IO</span><span class="token punctuation">(</span>iocb<span class="token punctuation">,</span> iter<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    retval <span class="token operator">=</span> <span class="token function">generic_file_buffered_read</span><span class="token punctuation">(</span>iocb<span class="token punctuation">,</span> iter<span class="token punctuation">,</span> retval<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

ssize_t <span class="token function">__generic_file_write_iter</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kiocb</span> <span class="token operator">*</span>iocb<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">iov_iter</span> <span class="token operator">*</span>from<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>iocb<span class="token operator">-&gt;</span>ki_flags <span class="token operator">&amp;</span> IOCB_DIRECT<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        written <span class="token operator">=</span> <span class="token function">generic_file_direct_write</span><span class="token punctuation">(</span>iocb<span class="token punctuation">,</span> from<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        written <span class="token operator">=</span> <span class="token function">generic_perform_write</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> from<span class="token punctuation">,</span> iocb<span class="token operator">-&gt;</span>ki_pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>generic_file_read_iter和__generic_file_write_iter有相似的逻辑，就是要区分是否用缓存。</p>
<p>缓存其实就是内存中的一块空间。因为内存比硬盘快的多，Linux为了改进性能，有时候会选择不直接操作硬盘，而是将读写都在内存中，然后批量读取或者写入硬盘。一旦能够命中内存，读写效率就会大幅度提高。</p>
<p>因此，根据是否使用内存做缓存，我们可以把文件的I/O操作分为两种类型。</p>
<p>第一种类型是<strong>缓存I/O</strong>。大多数文件系统的默认I/O操作都是缓存I/O。对于读操作来讲，操作系统会先检查，内核的缓冲区有没有需要的数据。如果已经缓存了，那就直接从缓存中返回；否则从磁盘中读取，然后缓存在操作系统的缓存中。对于写操作来讲，操作系统会先将数据从用户空间复制到内核空间的缓存中。这时对用户程序来说，写操作就已经完成。至于什么时候再写到磁盘中由操作系统决定，除非显式地调用了sync同步命令。</p>
<p>第二种类型是<strong>直接IO</strong>，就是应用程序直接访问磁盘数据，而不经过内核缓冲区，从而减少了在内核缓存和用户程序之间数据复制。</p>
<p>如果在读的逻辑generic_file_read_iter里面，发现设置了IOCB_DIRECT，则会调用address_space的direct_IO的函数，将数据直接读取硬盘。我们在mmap映射文件到内存的时候讲过address_space，它主要用于在内存映射的时候将文件和内存页产生关联。</p>
<p>同样，对于缓存来讲，也需要文件和内存页进行关联，这就要用到address_space。address_space的相关操作定义在struct address_space_operations结构中。对于ext4文件系统来讲， address_space的操作定义在ext4_aops，direct_IO对应的函数是ext4_direct_IO。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">address_space_operations</span> ext4_aops <span class="token operator">=</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">.</span>direct_IO      <span class="token operator">=</span> ext4_direct_IO<span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果在写的逻辑__generic_file_write_iter里面，发现设置了IOCB_DIRECT，则调用generic_file_direct_write，里面同样会调用address_space的direct_IO的函数，将数据直接写入硬盘。</p>
<p>ext4_direct_IO最终会调用到__blockdev_direct_IO-&gt;do_blockdev_direct_IO，这就跨过了缓存层，直接到了文件系统的设备驱动层。由于文件系统是块设备，所以这个调用的是blockdev相关的函数，有关块设备驱动程序的原理我们下一章详细讲，这一节我们就讲到文件系统到块设备的分界线部分。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * This is a library function for use by filesystem drivers.
 */</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> ssize_t
<span class="token function">do_blockdev_direct_IO</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kiocb</span> <span class="token operator">*</span>iocb<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span>
              <span class="token keyword">struct</span> <span class="token class-name">block_device</span> <span class="token operator">*</span>bdev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">iov_iter</span> <span class="token operator">*</span>iter<span class="token punctuation">,</span>
              get_block_t get_block<span class="token punctuation">,</span> dio_iodone_t end_io<span class="token punctuation">,</span>
              dio_submit_t submit_io<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来，我们重点看带缓存的部分如果进行读写。</p>
<h4 id="25-3-带缓存的写入操作"><a href="#25-3-带缓存的写入操作" class="headerlink" title="25.3 带缓存的写入操作"></a>25.3 带缓存的写入操作</h4><p>我们先来看带缓存写入的函数generic_perform_write。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">ssize_t <span class="token function">generic_perform_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span>
                <span class="token keyword">struct</span> <span class="token class-name">iov_iter</span> <span class="token operator">*</span>i<span class="token punctuation">,</span> loff_t pos<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">address_space</span> <span class="token operator">*</span>mapping <span class="token operator">=</span> file<span class="token operator">-&gt;</span>f_mapping<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">address_space_operations</span> <span class="token operator">*</span>a_ops <span class="token operator">=</span> mapping<span class="token operator">-&gt;</span>a_ops<span class="token punctuation">;</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> offset<span class="token punctuation">;</span>   <span class="token comment">/* Offset into pagecache page */</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> bytes<span class="token punctuation">;</span>    <span class="token comment">/* Bytes to write to page */</span>
        status <span class="token operator">=</span> a_ops<span class="token operator">-&gt;</span><span class="token function">write_begin</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> mapping<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> bytes<span class="token punctuation">,</span> flags<span class="token punctuation">,</span>
                        <span class="token operator">&amp;</span>page<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fsdata<span class="token punctuation">)</span><span class="token punctuation">;</span>
        copied <span class="token operator">=</span> <span class="token function">iov_iter_copy_from_user_atomic</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> i<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">flush_dcache_page</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span>
        status <span class="token operator">=</span> a_ops<span class="token operator">-&gt;</span><span class="token function">write_end</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> mapping<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> bytes<span class="token punctuation">,</span> copied<span class="token punctuation">,</span>
                        page<span class="token punctuation">,</span> fsdata<span class="token punctuation">)</span><span class="token punctuation">;</span>
        pos <span class="token operator">+=</span> copied<span class="token punctuation">;</span>
        written <span class="token operator">+=</span> copied<span class="token punctuation">;</span>


        <span class="token function">balance_dirty_pages_ratelimited</span><span class="token punctuation">(</span>mapping<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">iov_iter_count</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个函数里，是一个while循环。我们需要找出这次写入影响的所有的页，然后依次写入。对于每一个循环，主要做四件事情：</p>
<ul>
<li>对于每一页，先调用address_space的write_begin做一些准备；</li>
<li>调用iov_iter_copy_from_user_atomic，将写入的内容从用户态拷贝到内核态的页中；</li>
<li>调用address_space的write_end完成写操作；</li>
<li>调用balance_dirty_pages_ratelimited，看脏页是否太多，需要写回硬盘。所谓脏页，就是写入到缓存，但是还没有写入到硬盘的页面。</li>
</ul>
<p>我们依次来看这四个步骤。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">address_space_operations</span> ext4_aops <span class="token operator">=</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">.</span>write_begin        <span class="token operator">=</span> ext4_write_begin<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>write_end          <span class="token operator">=</span> ext4_write_end<span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>第一步，对于ext4来讲，调用的是ext4_write_begin。</p>
<p>ext4是一种日志文件系统，是为了防止突然断电的时候的数据丢失，引入了<strong>日志（Journal）</strong>模式。日志文件系统比非日志文件系统多了一个Journal区域。文件在ext4中分两部分存储，一部分是文件的元数据，另一部分是数据。元数据和数据的操作日志Journal也是分开管理的。你可以在挂载ext4的时候，选择Journal模式。这种模式在将数据写入文件系统前，必须等待元数据和数据的日志已经落盘才能发挥作用。这样性能比较差，但是最安全。</p>
<p>另一种模式是<strong>order模式</strong>。这个模式不记录数据的日志，只记录元数据的日志，但是在写元数据的日志前，必须先确保数据已经落盘。这个折中，是默认模式。</p>
<p>还有一种模式是<strong>writeback</strong>，不记录数据的日志，仅记录元数据的日志，并且不保证数据比元数据先落盘。这个性能最好，但是最不安全。</p>
<p>在ext4_write_begin，我们能看到对于ext4_journal_start的调用，就是在做日志相关的工作。</p>
<p>在ext4_write_begin中，还做了另外一件重要的事情，就是调用grab_cache_page_write_begin来，得到应该写入的缓存页。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span><span class="token function">grab_cache_page_write_begin</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">address_space</span> <span class="token operator">*</span>mapping<span class="token punctuation">,</span>
                    pgoff_t index<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>
    <span class="token keyword">int</span> fgp_flags <span class="token operator">=</span> FGP_LOCK<span class="token operator">|</span>FGP_WRITE<span class="token operator">|</span>FGP_CREAT<span class="token punctuation">;</span>
    page <span class="token operator">=</span> <span class="token function">pagecache_get_page</span><span class="token punctuation">(</span>mapping<span class="token punctuation">,</span> index<span class="token punctuation">,</span> fgp_flags<span class="token punctuation">,</span>
            <span class="token function">mapping_gfp_mask</span><span class="token punctuation">(</span>mapping<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>page<span class="token punctuation">)</span>
        <span class="token function">wait_for_stable_page</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> page<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在内核中，缓存以页为单位放在内存里面，那我们如何知道，一个文件的哪些数据已经被放到缓存中了呢？每一个打开的文件都有一个struct file结构，每个struct file结构都有一个struct address_space用于关联文件和内存，就是在这个结构里面，有一棵树，用于保存所有与这个文件相关的的缓存页。</p>
<p>我们查找的时候，往往需要根据文件中的偏移量找出相应的页面，而基数树radix tree这种数据结构能够快速根据一个长整型查找到其相应的对象，因而这里缓存页就放在radix基数树里面。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">address_space</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">inode</span>            <span class="token operator">*</span>host<span class="token punctuation">;</span>      <span class="token comment">/* owner: inode, block_device */</span>
    <span class="token keyword">struct</span> <span class="token class-name">radix_tree_root</span>  page_tree<span class="token punctuation">;</span>  <span class="token comment">/* radix tree of all pages */</span>
    spinlock_t              tree_lock<span class="token punctuation">;</span>  <span class="token comment">/* and lock protecting it */</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>pagecache_get_page就是根据pgoff_t index这个长整型，在这棵树里面查找缓存页，如果找不到就会创建一个缓存页。</p>
<p>第二步，调用iov_iter_copy_from_user_atomic。先将分配好的页面调用kmap_atomic映射到内核里面的一个虚拟地址，然后将用户态的数据拷贝到内核态的页面的虚拟地址中，调用kunmap_atomic把内核里面的映射删除。</p>
<p>第三步，调用ext4_write_end完成写入。这里面会调用ext4_journal_stop完成日志的写入，会调用block_write_end-&gt;__block_commit_write-&gt;mark_buffer_dirty，将修改过的缓存标记为脏页。可以看出，其实所谓的完成写入，并没有真正写入硬盘，仅仅是写入缓存后，标记为脏页。</p>
<p>但是这里有一个问题，数据很危险，一旦宕机就没有了，所以需要一种机制，将写入的页面真正写到硬盘中，我们称为回写（Write Back）。</p>
<p>第四步，调用 balance_dirty_pages_ratelimited，是回写脏页的一个很好的时机。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/**
 * balance_dirty_pages_ratelimited - balance dirty memory state
 * @mapping: address_space which was dirtied
 *
 * Processes which are dirtying memory should call in here once for each page
 * which was newly dirtied.  The function will periodically check the system's
 * dirty state and will initiate writeback if needed.
  */</span>
<span class="token keyword">void</span> <span class="token function">balance_dirty_pages_ratelimited</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">address_space</span> <span class="token operator">*</span>mapping<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode <span class="token operator">=</span> mapping<span class="token operator">-&gt;</span>host<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">backing_dev_info</span> <span class="token operator">*</span>bdi <span class="token operator">=</span> <span class="token function">inode_to_bdi</span><span class="token punctuation">(</span>inode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">bdi_writeback</span> <span class="token operator">*</span>wb <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> ratelimit<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>current<span class="token operator">-&gt;</span>nr_dirtied <span class="token operator">&gt;=</span> ratelimit<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">balance_dirty_pages</span><span class="token punctuation">(</span>mapping<span class="token punctuation">,</span> wb<span class="token punctuation">,</span> current<span class="token operator">-&gt;</span>nr_dirtied<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在balance_dirty_pages_ratelimited里面，发现脏页的数目超过了规定的数目，就调用balance_dirty_pages-&gt;wb_start_background_writeback，启动一个背后线程开始回写。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">wb_start_background_writeback</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">bdi_writeback</span> <span class="token operator">*</span>wb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">/*
     * We just wake up the flusher thread. It will perform background
     * writeback as soon as there is no other work to do.
     */</span>
    <span class="token function">wb_wakeup</span><span class="token punctuation">(</span>wb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">wb_wakeup</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">bdi_writeback</span> <span class="token operator">*</span>wb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">spin_lock_bh</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wb<span class="token operator">-&gt;</span>work_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">test_bit</span><span class="token punctuation">(</span>WB_registered<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wb<span class="token operator">-&gt;</span>state<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">mod_delayed_work</span><span class="token punctuation">(</span>bdi_wq<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wb<span class="token operator">-&gt;</span>dwork<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">spin_unlock_bh</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wb<span class="token operator">-&gt;</span>work_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* bdi_wq serves all asynchronous writeback tasks */</span>
<span class="token keyword">struct</span> <span class="token class-name">workqueue_struct</span> <span class="token operator">*</span>bdi_wq<span class="token punctuation">;</span>


<span class="token comment">/**
 * mod_delayed_work - modify delay of or queue a delayed work
 * @wq: workqueue to use
 * @dwork: work to queue
 * @delay: number of jiffies to wait before queueing
 *
 * mod_delayed_work_on() on local CPU.
 */</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> bool <span class="token function">mod_delayed_work</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">workqueue_struct</span> <span class="token operator">*</span>wq<span class="token punctuation">,</span>
                    <span class="token keyword">struct</span> <span class="token class-name">delayed_work</span> <span class="token operator">*</span>dwork<span class="token punctuation">,</span>
                    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> delay<span class="token punctuation">)</span>
<span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过上面的代码，我们可以看出，bdi_wq是一个全局变量，所有回写的任务都挂在这个队列上。mod_delayed_work函数负责将一个回写任务bdi_writeback挂在这个队列上。bdi_writeback有个成员变量struct delayed_work dwork，bdi_writeback就是以delayed_work的身份挂到队列上的，并且把delay设置为0，意思就是一刻不等，马上执行。</p>
<p>那具体这个任务由谁来执行呢？这里的bdi的意思是backing device info，用于描述后端存储相关的信息。每个块设备都会有这样一个结构，并且在初始化块设备的时候，调用bdi_init初始化这个结构，在初始化bdi的时候，也会调用wb_init初始化bdi_writeback。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">wb_init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">bdi_writeback</span> <span class="token operator">*</span>wb<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">backing_dev_info</span> <span class="token operator">*</span>bdi<span class="token punctuation">,</span>
           <span class="token keyword">int</span> blkcg_id<span class="token punctuation">,</span> gfp_t gfp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    wb<span class="token operator">-&gt;</span>bdi <span class="token operator">=</span> bdi<span class="token punctuation">;</span>
    wb<span class="token operator">-&gt;</span>last_old_flush <span class="token operator">=</span> jiffies<span class="token punctuation">;</span>
    <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wb<span class="token operator">-&gt;</span>b_dirty<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wb<span class="token operator">-&gt;</span>b_io<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wb<span class="token operator">-&gt;</span>b_more_io<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wb<span class="token operator">-&gt;</span>b_dirty_time<span class="token punctuation">)</span><span class="token punctuation">;</span>
    wb<span class="token operator">-&gt;</span>bw_time_stamp <span class="token operator">=</span> jiffies<span class="token punctuation">;</span>
    wb<span class="token operator">-&gt;</span>balanced_dirty_ratelimit <span class="token operator">=</span> INIT_BW<span class="token punctuation">;</span>
    wb<span class="token operator">-&gt;</span>dirty_ratelimit <span class="token operator">=</span> INIT_BW<span class="token punctuation">;</span>
    wb<span class="token operator">-&gt;</span>write_bandwidth <span class="token operator">=</span> INIT_BW<span class="token punctuation">;</span>
    wb<span class="token operator">-&gt;</span>avg_write_bandwidth <span class="token operator">=</span> INIT_BW<span class="token punctuation">;</span>
    <span class="token function">spin_lock_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wb<span class="token operator">-&gt;</span>work_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wb<span class="token operator">-&gt;</span>work_list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">INIT_DELAYED_WORK</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wb<span class="token operator">-&gt;</span>dwork<span class="token punctuation">,</span> wb_workfn<span class="token punctuation">)</span><span class="token punctuation">;</span>
    wb<span class="token operator">-&gt;</span>dirty_sleep <span class="token operator">=</span> jiffies<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">__INIT_DELAYED_WORK</span><span class="token punctuation">(</span>_work<span class="token punctuation">,</span> _func<span class="token punctuation">,</span> _tflags<span class="token punctuation">)</span>              </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span>                                                        </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">INIT_WORK</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>_work<span class="token punctuation">)</span><span class="token operator">-&gt;</span>work<span class="token punctuation">,</span> <span class="token punctuation">(</span>_func<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">__setup_timer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>_work<span class="token punctuation">)</span><span class="token operator">-&gt;</span>timer<span class="token punctuation">,</span> delayed_work_timer_fn<span class="token punctuation">,</span>   </span><span class="token punctuation">\</span>
                  <span class="token expression"><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>_work<span class="token punctuation">)</span><span class="token punctuation">,</span>                       </span></span>\<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面最重要的是INIT_DELAYED_WORK。其实就是初始化一个timer，也即定时器，到时候我们就执行wb_workfn这个函数。</p>
<p>接下来的调用链为：wb_workfn-&gt;wb_do_writeback-&gt;wb_writeback-&gt;writeback_sb_inodes-&gt;__writeback_single_inode-&gt;do_writepages，写入页面到硬盘。</p>
<p>在调用write的最后，当发现缓存的数据太多的时候，会触发回写，这仅仅是回写的一种场景。另外还有几种场景也会触发回写：</p>
<ul>
<li>用户主动调用sync，将缓存刷到硬盘上去，最终会调用wakeup_flusher_threads，同步脏页；</li>
<li>当内存十分紧张，以至于无法分配页面的时候，会调用free_more_memory，最终会调用wakeup_flusher_threads，释放脏页；</li>
<li>脏页已经更新了较长时间，时间上超过了timer，需要及时回写，保持内存和磁盘上数据一致性。</li>
</ul>
<h4 id="25-4-带缓存的读操作"><a href="#25-4-带缓存的读操作" class="headerlink" title="25.4 带缓存的读操作"></a>25.4 带缓存的读操作</h4><p>带缓存的写分析完了，接下来，我们看带缓存的读，对应的是函数generic_file_buffered_read。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> ssize_t <span class="token function">generic_file_buffered_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kiocb</span> <span class="token operator">*</span>iocb<span class="token punctuation">,</span>
        <span class="token keyword">struct</span> <span class="token class-name">iov_iter</span> <span class="token operator">*</span>iter<span class="token punctuation">,</span> ssize_t written<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>filp <span class="token operator">=</span> iocb<span class="token operator">-&gt;</span>ki_filp<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">address_space</span> <span class="token operator">*</span>mapping <span class="token operator">=</span> filp<span class="token operator">-&gt;</span>f_mapping<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode <span class="token operator">=</span> mapping<span class="token operator">-&gt;</span>host<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>
        pgoff_t end_index<span class="token punctuation">;</span>
        loff_t isize<span class="token punctuation">;</span>
        page <span class="token operator">=</span> <span class="token function">find_get_page</span><span class="token punctuation">(</span>mapping<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>page<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>iocb<span class="token operator">-&gt;</span>ki_flags <span class="token operator">&amp;</span> IOCB_NOWAIT<span class="token punctuation">)</span>
                <span class="token keyword">goto</span> would_block<span class="token punctuation">;</span>
            <span class="token function">page_cache_sync_readahead</span><span class="token punctuation">(</span>mapping<span class="token punctuation">,</span>
                    ra<span class="token punctuation">,</span> filp<span class="token punctuation">,</span>
                    index<span class="token punctuation">,</span> last_index <span class="token operator">-</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
            page <span class="token operator">=</span> <span class="token function">find_get_page</span><span class="token punctuation">(</span>mapping<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>page <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">goto</span> no_cached_page<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">PageReadahead</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">page_cache_async_readahead</span><span class="token punctuation">(</span>mapping<span class="token punctuation">,</span>
                    ra<span class="token punctuation">,</span> filp<span class="token punctuation">,</span> page<span class="token punctuation">,</span>
                    index<span class="token punctuation">,</span> last_index <span class="token operator">-</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">/*
         * Ok, we have the page, and it's up-to-date, so
         * now we can copy it to user space...
         */</span>
        ret <span class="token operator">=</span> <span class="token function">copy_page_to_iter</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> nr<span class="token punctuation">,</span> iter<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>读取比写入总体而言简单一些，主要涉及预读的问题。</p>
<p>在generic_file_buffered_read函数中，我们需要先找到page cache里面是否有缓存页。如果没有找到，不但读取这一页，还要进行预读，这需要在page_cache_sync_readahead函数中实现。预读完了以后，再试一把查找缓存页，应该能找到了。</p>
<p>如果第一次找缓存页就找到了，我们还是要判断，是不是应该继续预读；如果需要，就调用page_cache_async_readahead发起一个异步预读。</p>
<p>最后，copy_page_to_iter会将内容从内核缓存页拷贝到用户内存空间。</p>
<h4 id="25-5-总结"><a href="#25-5-总结" class="headerlink" title="25.5 总结"></a>25.5 总结</h4><p>在系统调用层我们需要仔细学习read和write。在VFS层调用的是vfs_read和vfs_write并且调用file_operation。在ext4层调用的是ext4_file_read_iter和ext4_file_write_iter。</p>
<p>接下来就是分叉。你需要知道缓存I/O和直接I/O。直接I/O读写的流程是一样的，调用ext4_direct_IO，再往下就调用块设备层了。缓存I/O读写的流程不一样。对于读，从块设备读取到缓存中，然后从缓存中拷贝到用户态。对于写，从用户态拷贝到缓存，设置缓存页为脏，然后启动一个线程写入块设备。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/文件缓存总结.png" alt="文件缓存总结"></p>
<h2 id="五、输入输出系统"><a href="#五、输入输出系统" class="headerlink" title="五、输入输出系统"></a>五、输入输出系统</h2><h3 id="26-输入与输出"><a href="#26-输入与输出" class="headerlink" title="26. 输入与输出"></a>26. 输入与输出</h3><h4 id="26-1-用设备控制器屏蔽设备差异"><a href="#26-1-用设备控制器屏蔽设备差异" class="headerlink" title="26.1 用设备控制器屏蔽设备差异"></a>26.1 用设备控制器屏蔽设备差异</h4><p>CPU并不直接和设备打交道，它们中间有一个叫作设备控制器（Device Control Unit）的组件，例如硬盘有磁盘控制器、USB有USB控制器、显示器有视频控制器等。这些控制器就像代理商一样，它们知道如何应对硬盘、鼠标、键盘、显示器的行为。</p>
<p>控制器其实有点儿像一台小电脑。它有它的芯片，类似小CPU，执行自己的逻辑。它也有它的寄存器。这样CPU就可以通过写这些寄存器，对控制器下发指令，通过读这些寄存器，查看控制器对于设备的操作状态。</p>
<p>CPU对于寄存器的读写，可比直接控制硬件，要标准和轻松很多。</p>
<p>输入输出设备我们大致可以分为两类：<strong>块设备（Block Device）</strong>和<strong>字符设备（Character Device）</strong>。</p>
<ul>
<li>块设备将信息存储在固定大小的块中，每个块都有自己的地址。硬盘就是常见的块设备。</li>
<li>字符设备发送或接受的是字节流。而不用考虑任何块结构，没有办法寻址。鼠标就是常见的字符设备。</li>
</ul>
<p>由于块设备传输的数据量比较大，控制器里往往会有缓冲区。CPU写入缓冲区的数据攒够一部分，才会发给设备。CPU读取的数据，也需要在缓冲区攒够一部分，才拷贝到内存。</p>
<p>CPU如何同控制器的寄存器和数据缓冲区进行通信呢？</p>
<ul>
<li>每个控制寄存器被分配一个I/O端口，我们可以通过特殊的汇编指令（例如in/out类似的指令）操作这些寄存器。</li>
<li>数据缓冲区，可内存映射I/O，可以分配一段内存空间给它，就像读写内存一样读写数据缓冲区。如果你去看内存空间的话，有一个原来我们没有讲过的区域ioremap，就是做这个的。</li>
</ul>
<p>对于CPU来讲，这些外部设备都有自己的大脑，可以自行处理一些事情，但是有个问题是，当你给设备发了一个指令，让它读取一些数据，它读完的时候，怎么通知你呢？</p>
<p>控制器的寄存器一般会有状态标志位，可以通过检测状态标志位，来确定输入或者输出操作是否完成。第一种方式就是<strong>轮询等待</strong>，就是一直查，一直查，直到完成。当然这种方式很不好，于是我们有了第二种方式，就是可以通过<strong>中断</strong>的方式，通知操作系统输入输出操作已经完成。</p>
<p>为了响应中断，我们一般会有一个硬件的中断控制器，当设备完成任务后出发中断到中断控制器，中断控制器就通知CPU，一个中断产生了，CPU需要停下当前手里的事情来处理中断。</p>
<p>中断有两种，一种软中断，例如代码调用INT指令触发，一种是硬件中断，就是硬件通过中断控制器触发的。</p>
<p>有的设备需要读取或者写入大量数据。如果所有过程都让CPU协调的话，就需要占用CPU大量的时间，比方说，磁盘就是这样的。这种类型的设备需要支持DMA功能，也就是说，允许设备在CPU不参与的情况下，能够自行完成对内存的读写。实现DMA机制需要有个DMA控制器帮你的CPU来做协调，就像下面这个图中显示的一样。</p>
<p>CPU只需要对DMA控制器下指令，说它想读取多少数据，放在内存的某个地方就可以了，接下来DMA控制器会发指令给磁盘控制器，读取磁盘上的数据到指定的内存位置，传输完毕之后，DMA控制器发中断通知CPU指令完成，CPU就可以直接用内存里面现成的数据了。还记得咱们讲内存的时候，有个DMA区域，就是这个作用。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/DMA.jpeg" alt="DMA"></p>
<h4 id="26-2-用驱动程序屏蔽设备控制器差异"><a href="#26-2-用驱动程序屏蔽设备控制器差异" class="headerlink" title="26.2 用驱动程序屏蔽设备控制器差异"></a>26.2 用驱动程序屏蔽设备控制器差异</h4><p>虽然代理商机制能够帮我们屏蔽很多设备的细节，但是从上面的描述我们可以看出，由于每种设备的控制器的寄存器、缓冲区等使用模式，指令都不同，所以对于操作系统这家公司来讲，需要有个部门专门对接代理商，向其他部门屏蔽代理商的差异，类似公司的渠道管理部门。</p>
<p>那什么才是操作系统的渠道管理部门呢？就是用来对接各个设备控制器的设备驱动程序。</p>
<p>这里需要注意的是，设备控制器不属于操作系统的一部分，但是设备驱动程序属于操作系统的一部分。操作系统的内核代码可以像调用本地代码一样调用驱动程序的代码，而驱动程序的代码需要发出特殊的面向设备控制器的指令，才能操作设备控制器。</p>
<p>设备驱动程序中是一些面向特殊设备控制器的代码。不同的设备不同。但是对于操作系统其它部分的代码而言，设备驱动程序应该有统一的接口。不同的设备驱动程序，可以以同样的方式接入操作系统，而操作系统的其它部分的代码，也可以无视不同设备的区别，以同样的接口调用设备驱动程序。</p>
<p>接下来两节，我们会讲字符设备驱动程序和块设备驱动程序的模型，从那里我们也可以看出，所有设备驱动程序都要，按照同样的规则，实现同样的方法。</p>
<p>上面咱们说了，设备做完了事情要通过中断来通知操作系统。那操作系统就需要有一个地方处理这个中断，既然设备驱动程序是用来对接设备控制器的，中断处理也应该在设备驱动里面完成。</p>
<p>然而中断的触发最终会到达CPU，会中断操作系统当前运行的程序，所以操作系统也要有一个统一的流程来处理中断，使得不同设备的中断使用统一的流程。</p>
<p>一般的流程是，一个设备驱动程序初始化的时候，要先注册一个该设备的中断处理函数。咱们讲进程切换的时候说过，中断返回的那一刻是进程切换的时机。不知道你还记不记得，中断的时候，触发的函数是do_IRQ。这个函数是中断处理的统一入口。在这个函数里面，我们可以找到设备驱动程序注册的中断处理函数Handler，然后执行它进行中断处理。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/设备使用中断的流程.jpg" alt="设备使用中断的流程"></p>
<p>另外，对于块设备来讲，在驱动程序之上，文件系统之下，还需要一层通用设备层。比如咱们上一章讲的文件系统，里面的逻辑和磁盘设备没有什么关系，可以说是通用的逻辑。在写文件的最底层，我们看到了BIO字眼的函数，但是好像和设备驱动也没有什么关系。是的，因为块设备类型非常多，而Linux操作系统里面一切是文件。我们也不想文件系统以下，就直接对接各种各样的块设备驱动程序，这样会使得文件系统的复杂度非常高。所以，我们在中间加了一层通用块层，将与块设备相关的通用逻辑放在这一层，维护与设备无关的块的大小，然后通用块层下面对接各种各样的驱动程序。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/虚拟文件系统.jpg" alt="虚拟文件系统"></p>
<h4 id="26-3-用文件系统接口屏蔽驱动程序的差异"><a href="#26-3-用文件系统接口屏蔽驱动程序的差异" class="headerlink" title="26.3 用文件系统接口屏蔽驱动程序的差异"></a>26.3 用文件系统接口屏蔽驱动程序的差异</h4><p>上面我们从硬件设备到设备控制器，到驱动程序，到通用块层，到文件系统，层层屏蔽不同的设备的差别，最终到这里涉及对用户使用接口，也要统一。</p>
<p>虽然我们操作设备，都是基于文件系统的接口，也要有一个统一的标准。</p>
<p>首先要统一的是设备名称。所有设备都在/dev/文件夹下面创建一个特殊的设备文件。这个设备特殊文件也有inode，但是它不关联到硬盘或任何其他存储介质上的数据，而是建立了与某个设备驱动程序的连接。</p>
<p>硬盘设备这里有一点绕。假设是/dev/sdb，这是一个设备文件。这个文件本身和硬盘上的文件系统没有任何关系。这个设备本身也不对应硬盘上的任何一个文件，/dev/sdb其实是在一个特殊的文件系统devtmpfs中。但是当我们将/dev/sdb格式化成一个文件系统ext4的时候，就会将它mount到一个路径下面。例如在/mnt/sdb下面。这个时候/dev/sdb还是一个设备文件在特殊文件系统devtmpfs中，而/mnt/sdb下面的文件才是在ext4文件系统中，只不这个设备是在/dev/sdb设备上的。</p>
<p>这里我们只关心设备文件，当我们用ls -l在/dev下面执行的时候，就会有这样的结果。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> -l
crw------- <span class="token number">1</span> root root      <span class="token number">5</span>,   <span class="token number">1</span> Dec <span class="token number">14</span> <span class="token number">19</span>:53 console
crw-r----- <span class="token number">1</span> root kmem      <span class="token number">1</span>,   <span class="token number">1</span> Dec <span class="token number">14</span> <span class="token number">19</span>:53 mem
crw-rw-rw- <span class="token number">1</span> root root      <span class="token number">1</span>,   <span class="token number">3</span> Dec <span class="token number">14</span> <span class="token number">19</span>:53 null
crw-r----- <span class="token number">1</span> root kmem      <span class="token number">1</span>,   <span class="token number">4</span> Dec <span class="token number">14</span> <span class="token number">19</span>:53 port
crw-rw-rw- <span class="token number">1</span> root root      <span class="token number">1</span>,   <span class="token number">8</span> Dec <span class="token number">14</span> <span class="token number">19</span>:53 random
crw--w---- <span class="token number">1</span> root <span class="token function">tty</span>       <span class="token number">4</span>,   <span class="token number">0</span> Dec <span class="token number">14</span> <span class="token number">19</span>:53 tty0
crw--w---- <span class="token number">1</span> root <span class="token function">tty</span>       <span class="token number">4</span>,   <span class="token number">1</span> Dec <span class="token number">14</span> <span class="token number">19</span>:53 tty1
crw-rw-rw- <span class="token number">1</span> root root      <span class="token number">1</span>,   <span class="token number">9</span> Dec <span class="token number">14</span> <span class="token number">19</span>:53 urandom
brw-rw---- <span class="token number">1</span> root disk    <span class="token number">253</span>,   <span class="token number">0</span> Dec <span class="token number">31</span> <span class="token number">19</span>:18 vda
brw-rw---- <span class="token number">1</span> root disk    <span class="token number">253</span>,   <span class="token number">1</span> Dec <span class="token number">31</span> <span class="token number">19</span>:19 vda1
brw-rw---- <span class="token number">1</span> root disk    <span class="token number">253</span>,  <span class="token number">16</span> Dec <span class="token number">14</span> <span class="token number">19</span>:53 vdb
brw-rw---- <span class="token number">1</span> root disk    <span class="token number">253</span>,  <span class="token number">32</span> Jan  <span class="token number">2</span> <span class="token number">11</span>:24 vdc
crw-rw-rw- <span class="token number">1</span> root root      <span class="token number">1</span>,   <span class="token number">5</span> Dec <span class="token number">14</span> <span class="token number">19</span>:53 zero<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于设备文件，ls出来的内容和我们原来讲过的稍有不同。</p>
<p>首先是第一位字符。如果是字符设备文件，则以c开头，如果是块设备文件，则以b开头。其次是这里面的两个号，一个是主设备号，一个是次设备号。主设备号定位设备驱动程序，次设备号作为参数传给启动程序，选择相应的单元。</p>
<p>从上面的列表我们可以看出来，mem、null、random、urandom、zero都是用同样的主设备号1，也就是它们使用同样的字符设备驱动，而vda、vda1、vdb、vdc也是同样的主设备号，也就是它们使用同样的块设备驱动。</p>
<p>有了设备文件，我们就可以使用对于文件的操作命令和API来操作文件了。例如，使用cat命令，可以读取/dev/random 和/dev/urandom的数据流，可以用od命令转换为十六进制后查看。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /dev/urandom <span class="token operator">|</span> od -x<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这里还是要明确一下，如果用文件的操作作用于/dev/sdb的话，会无法操作文件系统上的文件，操作的这个设备。</p>
<p>如果Linux操作系统新添加了一个设备，应该做哪些事情呢？就像咱们使用Windows的时候，如果新添加了一种设备，首先要看这个设备有没有相应的驱动。如果没有就需要安装一个驱动，等驱动安装好了，设备就在Windows的设备列表中显示出来了。</p>
<p>在Linux上面，如果一个新的设备从来没有加载过驱动，也需要安装驱动。Linux的驱动程序已经被写成和操作系统有标准接口的代码，可以看成一个标准的内核模块。在Linux里面，安装驱动程序，其实就是加载一个内核模块。</p>
<p>我们可以用命令lsmod，查看有没有加载过相应的内核模块。这个列表很长，我这里列举了其中一部分。可以看到，这里面有网络和文件系统的驱动。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ lsmod
Module                  Size  Used by
iptable_filter         <span class="token number">12810</span>  <span class="token number">1</span>
bridge                <span class="token number">146976</span>  <span class="token number">1</span> br_netfilter
vfat                   <span class="token number">17461</span>  <span class="token number">0</span>
fat                    <span class="token number">65950</span>  <span class="token number">1</span> vfat
ext4                  <span class="token number">571716</span>  <span class="token number">1</span>
cirrus                 <span class="token number">24383</span>  <span class="token number">1</span>
crct10dif_pclmul       <span class="token number">14307</span>  <span class="token number">0</span>
crct10dif_common       <span class="token number">12595</span>  <span class="token number">1</span> crct10dif_pclmul<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果没有安装过相应的驱动，可以通过insmod安装内核模块。内核模块的后缀一般是ko。</p>
<p>例如，我们要加载openvswitch的驱动，就要通过下面的命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insmod openvswitch.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>一旦有了驱动，我们就可以通过命令mknod在/dev文件夹下面创建设备文件，就像下面这样：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mknod</span> filename <span class="token builtin class-name">type</span> major minor<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>其中filename就是/dev下面的设备名称，type就是c为字符设备，b为块设备，major就是主设备号，minor就是次设备号。一旦执行了这个命令，新创建的设备文件就和上面加载过的驱动关联起来，这个时候就可以通过操作设备文件来操作驱动程序，从而操作设备。</p>
<p>你可能会问，人家Windows都说插上设备后，一旦安装了驱动，就直接在设备列表中出来了，你这里怎么还要人来执行命令创建呀，能不能智能一点？</p>
<p>当然可以，这里就要用到另一个管理设备的文件系统，也就是/sys路径下面的sysfs文件系统。它把实际连接到系统上的设备和总线组成了一个分层的文件系统。这个文件系统是当前系统上实际的设备数的真实反映。</p>
<p>在/sys路径下有下列的文件夹：</p>
<ul>
<li>/sys/devices是内核对系统中所有设备的分层次的表示；</li>
<li>/sys/dev目录下一个char文件夹，一个block文件夹，分别维护一个按字符设备和块设备的主次号码(major:minor)链接到真实的设备(/sys/devices下)的符号链接文件；</li>
<li>/sys/block是系统中当前所有的块设备；</li>
<li>/sys/module有系统中所有模块的信息。</li>
</ul>
<p>有了sysfs以后，我们还需要一个守护进程udev。当一个设备新插入系统的时候，内核会检测到这个设备，并会创建一个内核对象kobject 。 这个对象通过sysfs文件系统展现到用户层，同时内核还向用户空间发送一个热插拔消息。udevd会监听这些消息，在/dev中创建对应的文件。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/守护进程udev.jpg" alt="守护进程udev"></p>
<p>有了文件系统接口之后，我们不但可以通过文件系统的命令行操作设备，也可以通过程序，调用read、write函数，像读写文件一样操作设备。但是有些任务只使用读写很难完成，例如检查特定于设备的功能和属性，超出了通用文件系统的限制。所以，对于设备来讲，还有一种接口称为ioctl，表示输入输出控制接口，是用于配置和修改特定设备属性的通用接口，这个我们后面几节会详细说。</p>
<h4 id="26-4-总结"><a href="#26-4-总结" class="headerlink" title="26.4 总结"></a>26.4 总结</h4><p><img src="/images/《趣谈Linux操作系统》学习笔记/输入输出系统.jpg" alt="输入输出系统"></p>
<h3 id="27-字符设备（上）"><a href="#27-字符设备（上）" class="headerlink" title="27. 字符设备（上）"></a>27. 字符设备（上）</h3><p>先来讲稍微简单一点的字符设备驱动。</p>
<p>这一节，我找了两个比较简单的字符设备驱动来解析一下。一个是输入字符设备，鼠标。代码在drivers/input/mouse/logibm.c这里。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * Logitech Bus Mouse Driver for Linux
 */</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>logibm_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>logibm_exit<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另外一个是输出字符设备，打印机，代码drivers/char/lp.c这里。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * Generic parallel printer driver
 */</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>lp_init_module<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>lp_cleanup_module<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="27-1-内核模块"><a href="#27-1-内核模块" class="headerlink" title="27.1 内核模块"></a>27.1 内核模块</h4><p>设备驱动程序是一个内核模块，以ko的文件形式存在，可以通过insmod加载到内核中。那我们首先来看一下，怎么样才能构建一个内核模块呢？</p>
<p>一个内核模块应该由以下几部分组成。</p>
<p><strong>第一部分，头文件部分。</strong>一般的内核模块，都需要include下面两个头文件：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>第二部分，定义一些函数，用于处理内核模块的主要逻辑。</strong>例如打开、关闭、读取、写入设备的函数或者响应中断的函数。</p>
<p>例如，logibm.c里面就定义了logibm_open。logibm_close就是处理打开和关闭的，定义了logibm_interrupt就是用来响应中断的。再如，lp.c里面就定义了lp_read，lp_write就是处理读写的。</p>
<p><strong>第三部分，定义一个file_operations结构</strong>。前面我们讲过，设备是可以通过文件系统的接口进行访问的。咱们讲文件系统的时候说过，对于某种文件系统的操作，都是放在file_operations里面的。例如ext4就定义了这么一个结构，里面都是ext4_xxx之类的函数。设备要想被文件系统的接口操作，也需要定义这样一个结构。</p>
<p>例如，lp.c里面就定义了这样一个结构。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> lp_fops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>owner          <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>write          <span class="token operator">=</span> lp_write<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>unlocked_ioctl <span class="token operator">=</span> lp_ioctl<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_COMPAT</span></span>
    <span class="token punctuation">.</span>compat_ioctl   <span class="token operator">=</span> lp_compat_ioctl<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token punctuation">.</span>open           <span class="token operator">=</span> lp_open<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>release        <span class="token operator">=</span> lp_release<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_PARPORT_1284</span></span>
    <span class="token punctuation">.</span>read           <span class="token operator">=</span> lp_read<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token punctuation">.</span>llseek         <span class="token operator">=</span> noop_llseek<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在logibm.c里面，我们找不到这样的结构，是因为它属于众多输入设备的一种，而输入设备的操作被统一定义在drivers/input/input.c里面，logibm.c只是定义了一些自己独有的操作。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> input_devices_fileops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>owner      <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>open       <span class="token operator">=</span> input_proc_devices_open<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>poll       <span class="token operator">=</span> input_proc_devices_poll<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>read       <span class="token operator">=</span> seq_read<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>llseek     <span class="token operator">=</span> seq_lseek<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>release    <span class="token operator">=</span> seq_release<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>第四部分，定义整个模块的初始化函数和退出函数</strong>，用于加载和卸载这个ko的时候调用。</p>
<p>例如lp.c就定义了lp_init_module和lp_cleanup_module，logibm.c就定义了logibm_init和logibm_exit。</p>
<p><strong>第五部分，调用module_init和module_exit</strong>，分别指向上面两个初始化函数和退出函数。</p>
<p><strong>第六部分，声明一下lisense，调用MODULE_LICENSE。</strong></p>
<p>有了这六部分，一个内核模块就基本合格了，可以工作了。</p>
<h4 id="27-2-打开字符设备"><a href="#27-2-打开字符设备" class="headerlink" title="27.2 打开字符设备"></a>27.2 打开字符设备</h4><p>字符设备可不是一个普通的内核模块，它有自己独特的行为。接下来，我们就沿着打开一个字符设备的过程，看看字符设备这个内核模块做了哪些特殊的事情。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/打开一个字符设备的过程.jpeg" alt="打开一个字符设备的过程"></p>
<p>要使用一个字符设备，我们首先要把写好的内核模块，通过insmod加载进内核。这个时候，先调用的就是module_init调用的初始化函数。</p>
<p>例如，在lp.c的初始化函数lp_init对应的代码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">lp_init</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">register_chrdev</span> <span class="token punctuation">(</span>LP_MAJOR<span class="token punctuation">,</span> <span class="token string">"lp"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>lp_fops<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printk</span> <span class="token punctuation">(</span>KERN_ERR <span class="token string">"lp: unable to get major %d\n"</span><span class="token punctuation">,</span> LP_MAJOR<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>EIO<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">__register_chrdev</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> major<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> baseminor<span class="token punctuation">,</span>
              <span class="token keyword">unsigned</span> <span class="token keyword">int</span> count<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span>
              <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> <span class="token operator">*</span>fops<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">char_device_struct</span> <span class="token operator">*</span>cd<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">cdev</span> <span class="token operator">*</span>cdev<span class="token punctuation">;</span>
    <span class="token keyword">int</span> err <span class="token operator">=</span> <span class="token operator">-</span>ENOMEM<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    cd <span class="token operator">=</span> <span class="token function">__register_chrdev_region</span><span class="token punctuation">(</span>major<span class="token punctuation">,</span> baseminor<span class="token punctuation">,</span> count<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cdev <span class="token operator">=</span> <span class="token function">cdev_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cdev<span class="token operator">-&gt;</span>owner <span class="token operator">=</span> fops<span class="token operator">-&gt;</span>owner<span class="token punctuation">;</span>
    cdev<span class="token operator">-&gt;</span>ops <span class="token operator">=</span> fops<span class="token punctuation">;</span>
    <span class="token function">kobject_set_name</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cdev<span class="token operator">-&gt;</span>kobj<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    err <span class="token operator">=</span> <span class="token function">cdev_add</span><span class="token punctuation">(</span>cdev<span class="token punctuation">,</span> <span class="token function">MKDEV</span><span class="token punctuation">(</span>cd<span class="token operator">-&gt;</span>major<span class="token punctuation">,</span> baseminor<span class="token punctuation">)</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cd<span class="token operator">-&gt;</span>cdev <span class="token operator">=</span> cdev<span class="token punctuation">;</span>
    <span class="token keyword">return</span> major <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> cd<span class="token operator">-&gt;</span>major<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在字符设备驱动的内核模块加载的时候，最重要的一件事情就是，注册这个字符设备。注册的方式是调用__register_chrdev_region，注册字符设备的主次设备号和名称，然后分配一个struct cdev结构，将cdev的ops成员变量指向这个模块声明的file_operations。然后，cdev_add会将这个字符设备添加到内核中一个叫作struct kobj_map *cdev_map的结构，来统一管理所有字符设备。</p>
<p>其中，MKDEV(cd-&gt;major, baseminor)表示将主设备号和次设备号生成一个dev_t的整数，然后将这个整数dev_t和cdev关联起来。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/**
 * cdev_add() - add a char device to the system
 * @p: the cdev structure for the device
 * @dev: the first device number for which this device is responsible
 * @count: the number of consecutive minor numbers corresponding to this
 *         device
 *
 * cdev_add() adds the device represented by @p to the system, making it
 * live immediately.  A negative error code is returned on failure.
 */</span>
<span class="token keyword">int</span> <span class="token function">cdev_add</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cdev</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> dev_t dev<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> count<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> error<span class="token punctuation">;</span>

    p<span class="token operator">-&gt;</span>dev <span class="token operator">=</span> dev<span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>count <span class="token operator">=</span> count<span class="token punctuation">;</span>

    error <span class="token operator">=</span> <span class="token function">kobj_map</span><span class="token punctuation">(</span>cdev_map<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> count<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span>
             exact_match<span class="token punctuation">,</span> exact_lock<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">kobject_get</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>kobj<span class="token punctuation">.</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在logibm.c中，我们在logibm_init找不到注册字符设备，这是因为input.c里面的初始化函数input_init会调用register_chrdev_region，注册输入的字符设备，会在logibm_init中调用input_register_device，将logibm.c这个字符设备注册到input.c里面去，这就相当于input.c对多个输入字符设备进行统一的管理。</p>
<p>内核模块加载完毕后，接下来要通过mknod在/dev下面创建一个设备文件，只有有了这个设备文件，我们才能通过文件系统的接口，对这个设备文件进行操作。</p>
<p>mknod也是一个系统调用，定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>mknod<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> filename<span class="token punctuation">,</span> umode_t<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> <span class="token keyword">unsigned</span><span class="token punctuation">,</span> dev<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">sys_mknodat</span><span class="token punctuation">(</span>AT_FDCWD<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">SYSCALL_DEFINE4</span><span class="token punctuation">(</span>mknodat<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> dfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> filename<span class="token punctuation">,</span> umode_t<span class="token punctuation">,</span> mode<span class="token punctuation">,</span>
        <span class="token keyword">unsigned</span><span class="token punctuation">,</span> dev<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span>dentry<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">path</span> path<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    dentry <span class="token operator">=</span> <span class="token function">user_path_create</span><span class="token punctuation">(</span>dfd<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> <span class="token operator">&amp;</span>path<span class="token punctuation">,</span> lookup_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>mode <span class="token operator">&amp;</span> S_IFMT<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">case</span> S_IFCHR<span class="token operator">:</span> <span class="token keyword">case</span> S_IFBLK<span class="token operator">:</span>
            error <span class="token operator">=</span> <span class="token function">vfs_mknod</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span>dentry<span class="token operator">-&gt;</span>d_inode<span class="token punctuation">,</span>dentry<span class="token punctuation">,</span>mode<span class="token punctuation">,</span>
                    <span class="token function">new_decode_dev</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们可以在这个系统调用里看到，在文件系统上，顺着路径找到/dev/xxx所在的文件夹，然后为这个新创建的设备文件创建一个dentry。这是维护文件和inode之间的关联关系的结构。</p>
<p>接下来，如果是字符文件S_IFCHR或者设备文件S_IFBLK，我们就调用vfs_mknod。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">vfs_mknod</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>dir<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span>dentry<span class="token punctuation">,</span> umode_t mode<span class="token punctuation">,</span> dev_t dev<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    error <span class="token operator">=</span> dir<span class="token operator">-&gt;</span>i_op<span class="token operator">-&gt;</span><span class="token function">mknod</span><span class="token punctuation">(</span>dir<span class="token punctuation">,</span> dentry<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里需要调用对应的文件系统的inode_operations。应该调用哪个文件系统呢？</p>
<p>如果我们在linux下面执行mount命令，能看到下面这一行：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">devtmpfs on /dev type devtmpfs (rw,nosuid,size=3989584k,nr_inodes=997396,mode=755)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>也就是说，/dev下面的文件系统的名称为devtmpfs，我们可以在内核中找到它。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token function">dev_mount</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file_system_type</span> <span class="token operator">*</span>fs_type<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span>
              <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>dev_name<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_TMPFS</span></span>
    <span class="token keyword">return</span> <span class="token function">mount_single</span><span class="token punctuation">(</span>fs_type<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> data<span class="token punctuation">,</span> shmem_fill_super<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
    <span class="token keyword">return</span> <span class="token function">mount_single</span><span class="token punctuation">(</span>fs_type<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> data<span class="token punctuation">,</span> ramfs_fill_super<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token punctuation">}</span>


<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">file_system_type</span> dev_fs_type <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"devtmpfs"</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>mount <span class="token operator">=</span> dev_mount<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>kill_sb <span class="token operator">=</span> kill_litter_super<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从这里可以看出，devtmpfs在挂载的时候，有两种模式，一种是ramfs，一种是shmem都是基于内存的文件系统。这里你先不用管，基于内存的文件系统具体是怎么回事儿。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">inode_operations</span> ramfs_dir_inode_operations <span class="token operator">=</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">.</span>mknod      <span class="token operator">=</span> ramfs_mknod<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">inode_operations</span> shmem_dir_inode_operations <span class="token operator">=</span> <span class="token punctuation">{</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_TMPFS</span></span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">.</span>mknod      <span class="token operator">=</span> shmem_mknod<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这两个mknod虽然实现不同，但是都会调用到用一个函数init_special_inode。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">init_special_inode</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> umode_t mode<span class="token punctuation">,</span> dev_t rdev<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    inode<span class="token operator">-&gt;</span>i_mode <span class="token operator">=</span> mode<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">S_ISCHR</span><span class="token punctuation">(</span>mode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        inode<span class="token operator">-&gt;</span>i_fop <span class="token operator">=</span> <span class="token operator">&amp;</span>def_chr_fops<span class="token punctuation">;</span>
        inode<span class="token operator">-&gt;</span>i_rdev <span class="token operator">=</span> rdev<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">S_ISBLK</span><span class="token punctuation">(</span>mode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        inode<span class="token operator">-&gt;</span>i_fop <span class="token operator">=</span> <span class="token operator">&amp;</span>def_blk_fops<span class="token punctuation">;</span>
        inode<span class="token operator">-&gt;</span>i_rdev <span class="token operator">=</span> rdev<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">S_ISFIFO</span><span class="token punctuation">(</span>mode<span class="token punctuation">)</span><span class="token punctuation">)</span>
        inode<span class="token operator">-&gt;</span>i_fop <span class="token operator">=</span> <span class="token operator">&amp;</span>pipefifo_fops<span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">S_ISSOCK</span><span class="token punctuation">(</span>mode<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">;</span>   <span class="token comment">/* leave it no_open_fops */</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>显然这个文件是个特殊文件，inode也是特殊的。这里这个inode可以关联字符设备、块设备、FIFO文件、Socket等。我们这里只看字符设备。</p>
<p>这里的inode的file_operations指向一个def_chr_fops，这里面只有一个open，就等着你打开它。</p>
<p>另外，inode的i_rdev指向这个设备的dev_t。还记得cdev_map吗？通过这个dev_t，可以找到我们刚在加载的字符设备cdev。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> def_chr_fops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>open <span class="token operator">=</span> chrdev_open<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>到目前为止，我们只是创建了/dev下面的一个文件，并且和相应的设备号关联起来。但是，我们还没有打开这个/dev下面的设备文件。</p>
<p>现在我们来打开它。打开一个文件的流程，我们在 <strong>文件系统</strong> 那一节讲过了，这里不再重复。最终就像打开字符设备的图中一样，打开文件的进程的task_struct里，有一个数组代表它打开的文件，下标就是文件描述符fd，每一个打开的文件都有一个struct file结构，会指向一个dentry项。dentry可以用来关联inode。这个dentry就是咱们上面mknod的时候创建的。</p>
<p>在进程里面调用open函数，最终对调用到这个特殊的inode的open函数，也就是chrdev_open。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">chrdev_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>filp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> <span class="token operator">*</span>fops<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">cdev</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">cdev</span> <span class="token operator">*</span>new <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    p <span class="token operator">=</span> inode<span class="token operator">-&gt;</span>i_cdev<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">kobject</span> <span class="token operator">*</span>kobj<span class="token punctuation">;</span>
        <span class="token keyword">int</span> idx<span class="token punctuation">;</span>
        kobj <span class="token operator">=</span> <span class="token function">kobj_lookup</span><span class="token punctuation">(</span>cdev_map<span class="token punctuation">,</span> inode<span class="token operator">-&gt;</span>i_rdev<span class="token punctuation">,</span> <span class="token operator">&amp;</span>idx<span class="token punctuation">)</span><span class="token punctuation">;</span>
        new <span class="token operator">=</span> <span class="token function">container_of</span><span class="token punctuation">(</span>kobj<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">cdev</span><span class="token punctuation">,</span> kobj<span class="token punctuation">)</span><span class="token punctuation">;</span>
        p <span class="token operator">=</span> inode<span class="token operator">-&gt;</span>i_cdev<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            inode<span class="token operator">-&gt;</span>i_cdev <span class="token operator">=</span> p <span class="token operator">=</span> new<span class="token punctuation">;</span>
            <span class="token function">list_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>inode<span class="token operator">-&gt;</span>i_devices<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
            new <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    fops <span class="token operator">=</span> <span class="token function">fops_get</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>ops<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">replace_fops</span><span class="token punctuation">(</span>filp<span class="token punctuation">,</span> fops<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>filp<span class="token operator">-&gt;</span>f_op<span class="token operator">-&gt;</span>open<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ret <span class="token operator">=</span> filp<span class="token operator">-&gt;</span>f_op<span class="token operator">-&gt;</span><span class="token function">open</span><span class="token punctuation">(</span>inode<span class="token punctuation">,</span> filp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这个函数里面，我们首先看这个inode的i_cdev，是否已经关联到cdev。如果第一次打开，当然没有。没有没关系，inode里面有i_rdev呀，也就是有dev_t。我们可以通过它在cdev_map中找cdev。咱们上面注册过了，所以肯定能够找到。找到后我们就将inode的i_cdev，关联到找到的cdev new。</p>
<p>找到cdev就好办了。cdev里面有file_operations，这是设备驱动程序自己定义的。我们可以通过它来操作设备驱动程序，把它付给struct file里面的file_operations。这样以后操作文件描述符，就是直接操作设备了。</p>
<p>最后，我们需要调用设备驱动程序的file_operations的open函数，真正打开设备。对于打印机，调用的是lp_open。对于鼠标调用的是input_proc_devices_open，最终会调用到logibm_open。这些多和设备相关，你不必看懂它们。</p>
<h4 id="27-3-写入字符设备"><a href="#27-3-写入字符设备" class="headerlink" title="27.3 写入字符设备"></a>27.3 写入字符设备</h4><p>当我们像打开一个文件一样打开一个字符设备之后，接下来就是对这个设备的读写。对于文件的读写咱们在文件系统那一章详细讲述过，读写的过程是类似的，所以这里我们只解析打印机驱动写入的过程。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/打印机驱动写入的过程.jpeg" alt="打印机驱动写入的过程"></p>
<p>写入一个字符设备，就是用文件系统的标准接口write，参数文件描述符fd，在内核里面调用的sys_write，在sys_write里面根据文件描述符fd得到struct file结构。接下来再调用vfs_write。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">ssize_t <span class="token function">__vfs_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>p<span class="token punctuation">,</span> size_t count<span class="token punctuation">,</span> loff_t <span class="token operator">*</span>pos<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>file<span class="token operator">-&gt;</span>f_op<span class="token operator">-&gt;</span>write<span class="token punctuation">)</span>
        <span class="token keyword">return</span> file<span class="token operator">-&gt;</span>f_op<span class="token operator">-&gt;</span><span class="token function">write</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> p<span class="token punctuation">,</span> count<span class="token punctuation">,</span> pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>file<span class="token operator">-&gt;</span>f_op<span class="token operator">-&gt;</span>write_iter<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">new_sync_write</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> p<span class="token punctuation">,</span> count<span class="token punctuation">,</span> pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们可以看到，在__vfs_write里面，我们会调用struct file结构里的file_operations的write函数。上面我们打开字符设备的时候，已经将struct file结构里面的file_operations指向了设备驱动程序的file_operations结构，所以这里的write函数最终会调用到lp_write。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> ssize_t <span class="token function">lp_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span> file<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span> buf<span class="token punctuation">,</span>
                size_t count<span class="token punctuation">,</span> loff_t <span class="token operator">*</span>ppos<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> minor <span class="token operator">=</span> <span class="token function">iminor</span><span class="token punctuation">(</span><span class="token function">file_inode</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">parport</span> <span class="token operator">*</span>port <span class="token operator">=</span> lp_table<span class="token punctuation">[</span>minor<span class="token punctuation">]</span><span class="token punctuation">.</span>dev<span class="token operator">-&gt;</span>port<span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>kbuf <span class="token operator">=</span> lp_table<span class="token punctuation">[</span>minor<span class="token punctuation">]</span><span class="token punctuation">.</span>lp_buffer<span class="token punctuation">;</span>
    ssize_t retv <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    ssize_t written<span class="token punctuation">;</span>
    size_t copy_size <span class="token operator">=</span> count<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* Need to copy the data from user-space. */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>copy_size <span class="token operator">&gt;</span> LP_BUFFER_SIZE<span class="token punctuation">)</span>
        copy_size <span class="token operator">=</span> LP_BUFFER_SIZE<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_from_user</span> <span class="token punctuation">(</span>kbuf<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> copy_size<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        retv <span class="token operator">=</span> <span class="token operator">-</span>EFAULT<span class="token punctuation">;</span>
        <span class="token keyword">goto</span> out_unlock<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        <span class="token comment">/* Write the data. */</span>
        written <span class="token operator">=</span> <span class="token function">parport_write</span> <span class="token punctuation">(</span>port<span class="token punctuation">,</span> kbuf<span class="token punctuation">,</span> copy_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>written <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            copy_size <span class="token operator">-=</span> written<span class="token punctuation">;</span>
            count <span class="token operator">-=</span> written<span class="token punctuation">;</span>
            buf  <span class="token operator">+=</span> written<span class="token punctuation">;</span>
            retv <span class="token operator">+=</span> written<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">need_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token function">schedule</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


        <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            copy_size <span class="token operator">=</span> count<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>copy_size <span class="token operator">&gt;</span> LP_BUFFER_SIZE<span class="token punctuation">)</span>
                copy_size <span class="token operator">=</span> LP_BUFFER_SIZE<span class="token punctuation">;</span>


            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_from_user</span><span class="token punctuation">(</span>kbuf<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> copy_size<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>retv <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                    retv <span class="token operator">=</span> <span class="token operator">-</span>EFAULT<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个设备驱动程序的写入函数的实现还是比较典型的。先是调用copy_from_user将数据从用户态拷贝到内核态的缓存中，然后调用parport_write写入外部设备。这里还有一个schedule函数，也即写入的过程中，给其他线程抢占CPU的机会。然后，如果count还是大于0，也就是数据还没有写完，那我们就接着copy_from_user，接着parport_write，直到写完为止。</p>
<h4 id="27-4-使用IOCTL控制设备"><a href="#27-4-使用IOCTL控制设备" class="headerlink" title="27.4 使用IOCTL控制设备"></a>27.4 使用IOCTL控制设备</h4><p>对于I/O设备来讲，我们前面也说过，除了读写设备，还会调用ioctl，做一些特殊的I/O操作。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/使用IOCTL控制设备.jpeg" alt="使用IOCTL控制设备"></p>
<p>ioctl也是一个系统调用，它在内核里面的定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>ioctl<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> cmd<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> error<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">fd</span> f <span class="token operator">=</span> <span class="token function">fdget</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    error <span class="token operator">=</span> <span class="token function">do_vfs_ioctl</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>file<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> cmd<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fdput</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> error<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，fd是这个设备的文件描述符，cmd是传给这个设备的命令，arg是命令的参数。其中，对于命令和命令的参数，使用ioctl系统调用的用户和驱动程序的开发人员约定好行为即可。</p>
<p>其实cmd看起来是一个int，其实他的组成比较复杂，它由几部分组成：</p>
<ul>
<li>最低八位为NR，是命令号；</li>
<li>然后八位是TYPE，是类型；</li>
<li>然后十四位是参数的大小；</li>
<li>最高两位是DIR，是方向，表示写入、读出，还是读写。</li>
</ul>
<p>由于组成比较复杂，有一些宏是专门用于组成这个cmd值的。</p>
<p>由于组成比较复杂，有一些宏是专门用于组成这个cmd值的。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * Used to create numbers.
 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">_IO</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span>nr<span class="token punctuation">)</span>        <span class="token function">_IOC</span><span class="token punctuation">(</span>_IOC_NONE<span class="token punctuation">,</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>nr<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">_IOR</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span>nr<span class="token punctuation">,</span>size<span class="token punctuation">)</span>  <span class="token function">_IOC</span><span class="token punctuation">(</span>_IOC_READ<span class="token punctuation">,</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>nr<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token function">_IOC_TYPECHECK</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">_IOW</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span>nr<span class="token punctuation">,</span>size<span class="token punctuation">)</span>  <span class="token function">_IOC</span><span class="token punctuation">(</span>_IOC_WRITE<span class="token punctuation">,</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>nr<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token function">_IOC_TYPECHECK</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">_IOWR</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span>nr<span class="token punctuation">,</span>size<span class="token punctuation">)</span> <span class="token function">_IOC</span><span class="token punctuation">(</span>_IOC_READ<span class="token operator">|</span>_IOC_WRITE<span class="token punctuation">,</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>nr<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token function">_IOC_TYPECHECK</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>

<span class="token comment">/* used to decode ioctl numbers.. */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">_IOC_DIR</span><span class="token punctuation">(</span>nr<span class="token punctuation">)</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>nr<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> _IOC_DIRSHIFT<span class="token punctuation">)</span> <span class="token operator">&amp;</span> _IOC_DIRMASK<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">_IOC_TYPE</span><span class="token punctuation">(</span>nr<span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>nr<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> _IOC_TYPESHIFT<span class="token punctuation">)</span> <span class="token operator">&amp;</span> _IOC_TYPEMASK<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">_IOC_NR</span><span class="token punctuation">(</span>nr<span class="token punctuation">)</span>         <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>nr<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> _IOC_NRSHIFT<span class="token punctuation">)</span> <span class="token operator">&amp;</span> _IOC_NRMASK<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">_IOC_SIZE</span><span class="token punctuation">(</span>nr<span class="token punctuation">)</span>       <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>nr<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> _IOC_SIZESHIFT<span class="token punctuation">)</span> <span class="token operator">&amp;</span> _IOC_SIZEMASK<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在用户程序中，可以通过上面的”Used to create numbers“这些宏，根据参数生成cmd，在驱动程序中，可以通过下面的”used to decode ioctl numbers“这些宏，解析cmd后，执行指令。</p>
<p>ioctl中会调用do_vfs_ioctl，这里面对于已经定义好的cmd，进行相应的处理。如果不是默认定义好的cmd，则执行默认操作。对于普通文件，调用file_ioctl；对于其他文件调用vfs_ioctl。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">do_vfs_ioctl</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>filp<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span>
         <span class="token keyword">unsigned</span> <span class="token keyword">long</span> arg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> error <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> __user <span class="token operator">*</span>argp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> __user <span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode <span class="token operator">=</span> <span class="token function">file_inode</span><span class="token punctuation">(</span>filp<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">switch</span> <span class="token punctuation">(</span>cmd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">case</span> FIONBIO<span class="token operator">:</span>
        error <span class="token operator">=</span> <span class="token function">ioctl_fionbio</span><span class="token punctuation">(</span>filp<span class="token punctuation">,</span> argp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>

    <span class="token keyword">case</span> FIOASYNC<span class="token operator">:</span>
        error <span class="token operator">=</span> <span class="token function">ioctl_fioasync</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> filp<span class="token punctuation">,</span> argp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">case</span> FICLONE<span class="token operator">:</span>
        <span class="token keyword">return</span> <span class="token function">ioctl_file_clone</span><span class="token punctuation">(</span>filp<span class="token punctuation">,</span> arg<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">default</span><span class="token operator">:</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">S_ISREG</span><span class="token punctuation">(</span>inode<span class="token operator">-&gt;</span>i_mode<span class="token punctuation">)</span><span class="token punctuation">)</span>
            error <span class="token operator">=</span> <span class="token function">file_ioctl</span><span class="token punctuation">(</span>filp<span class="token punctuation">,</span> cmd<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            error <span class="token operator">=</span> <span class="token function">vfs_ioctl</span><span class="token punctuation">(</span>filp<span class="token punctuation">,</span> cmd<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> error<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于咱们这里是设备驱动程序，所以调用的是vfs_ioctl。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/**
 * vfs_ioctl - call filesystem specific ioctl methods
 * @filp:   open file to invoke ioctl method on
 * @cmd:    ioctl command to execute
 * @arg:    command-specific argument for ioctl
 *
 * Invokes filesystem specific -&gt;unlocked_ioctl, if one exists; otherwise
 * returns -ENOTTY.
 *
 * Returns 0 on success, -errno on error.
 */</span>
<span class="token keyword">long</span> <span class="token function">vfs_ioctl</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>filp<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> arg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> error <span class="token operator">=</span> <span class="token operator">-</span>ENOTTY<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>filp<span class="token operator">-&gt;</span>f_op<span class="token operator">-&gt;</span>unlocked_ioctl<span class="token punctuation">)</span>
        <span class="token keyword">goto</span> out<span class="token punctuation">;</span>

    error <span class="token operator">=</span> filp<span class="token operator">-&gt;</span>f_op<span class="token operator">-&gt;</span><span class="token function">unlocked_ioctl</span><span class="token punctuation">(</span>filp<span class="token punctuation">,</span> cmd<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>error <span class="token operator">==</span> <span class="token operator">-</span>ENOIOCTLCMD<span class="token punctuation">)</span>
        error <span class="token operator">=</span> <span class="token operator">-</span>ENOTTY<span class="token punctuation">;</span>
 out<span class="token operator">:</span>
    <span class="token keyword">return</span> error<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面调用的是struct file里file_operations的unlocked_ioctl函数。我们前面初始化设备驱动的时候，已经将file_operations指向设备驱动的file_operations了。这里调用的是设备驱动的unlocked_ioctl。对于打印机程序来讲，调用的是lp_ioctl。可以看出来，这里面就是switch语句，它会根据不同的cmd，做不同的操作。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">lp_ioctl</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span>
            <span class="token keyword">unsigned</span> <span class="token keyword">long</span> arg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> minor<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">timeval</span> par_timeout<span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>

    minor <span class="token operator">=</span> <span class="token function">iminor</span><span class="token punctuation">(</span><span class="token function">file_inode</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lp_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>cmd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
        ret <span class="token operator">=</span> <span class="token function">lp_do_ioctl</span><span class="token punctuation">(</span>minor<span class="token punctuation">,</span> cmd<span class="token punctuation">,</span> arg<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> __user <span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lp_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">lp_do_ioctl</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> minor<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> arg<span class="token punctuation">,</span> <span class="token keyword">void</span> __user <span class="token operator">*</span>argp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> status<span class="token punctuation">;</span>
    <span class="token keyword">int</span> retval <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">switch</span> <span class="token punctuation">(</span> cmd <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> LPTIME<span class="token operator">:</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arg <span class="token operator">&gt;</span> UINT_MAX <span class="token operator">/</span> HZ<span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
            <span class="token function">LP_TIME</span><span class="token punctuation">(</span>minor<span class="token punctuation">)</span> <span class="token operator">=</span> arg <span class="token operator">*</span> HZ<span class="token operator">/</span><span class="token number">100</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> LPCHAR<span class="token operator">:</span>
            <span class="token function">LP_CHAR</span><span class="token punctuation">(</span>minor<span class="token punctuation">)</span> <span class="token operator">=</span> arg<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> LPABORT<span class="token operator">:</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arg<span class="token punctuation">)</span>
                <span class="token function">LP_F</span><span class="token punctuation">(</span>minor<span class="token punctuation">)</span> <span class="token operator">|=</span> LP_ABORT<span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                <span class="token function">LP_F</span><span class="token punctuation">(</span>minor<span class="token punctuation">)</span> <span class="token operator">&amp;=</span> <span class="token operator">~</span>LP_ABORT<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> LPABORTOPEN<span class="token operator">:</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arg<span class="token punctuation">)</span>
                <span class="token function">LP_F</span><span class="token punctuation">(</span>minor<span class="token punctuation">)</span> <span class="token operator">|=</span> LP_ABORTOPEN<span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                <span class="token function">LP_F</span><span class="token punctuation">(</span>minor<span class="token punctuation">)</span> <span class="token operator">&amp;=</span> <span class="token operator">~</span>LP_ABORTOPEN<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> LPCAREFUL<span class="token operator">:</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arg<span class="token punctuation">)</span>
                <span class="token function">LP_F</span><span class="token punctuation">(</span>minor<span class="token punctuation">)</span> <span class="token operator">|=</span> LP_CAREFUL<span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                <span class="token function">LP_F</span><span class="token punctuation">(</span>minor<span class="token punctuation">)</span> <span class="token operator">&amp;=</span> <span class="token operator">~</span>LP_CAREFUL<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> LPWAIT<span class="token operator">:</span>
            <span class="token function">LP_WAIT</span><span class="token punctuation">(</span>minor<span class="token punctuation">)</span> <span class="token operator">=</span> arg<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> LPSETIRQ<span class="token operator">:</span>
            <span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> LPGETIRQ<span class="token operator">:</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_to_user</span><span class="token punctuation">(</span>argp<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token function">LP_IRQ</span><span class="token punctuation">(</span>minor<span class="token punctuation">)</span><span class="token punctuation">,</span>
                    <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token operator">-</span>EFAULT<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> LPGETSTATUS<span class="token operator">:</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mutex_lock_interruptible</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lp_table<span class="token punctuation">[</span>minor<span class="token punctuation">]</span><span class="token punctuation">.</span>port_mutex<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token operator">-</span>EINTR<span class="token punctuation">;</span>
            <span class="token function">lp_claim_parport_or_block</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>lp_table<span class="token punctuation">[</span>minor<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            status <span class="token operator">=</span> <span class="token function">r_str</span><span class="token punctuation">(</span>minor<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">lp_release_parport</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>lp_table<span class="token punctuation">[</span>minor<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lp_table<span class="token punctuation">[</span>minor<span class="token punctuation">]</span><span class="token punctuation">.</span>port_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_to_user</span><span class="token punctuation">(</span>argp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token operator">-</span>EFAULT<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> LPRESET<span class="token operator">:</span>
            <span class="token function">lp_reset</span><span class="token punctuation">(</span>minor<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> LPGETFLAGS<span class="token operator">:</span>
            status <span class="token operator">=</span> <span class="token function">LP_F</span><span class="token punctuation">(</span>minor<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_to_user</span><span class="token punctuation">(</span>argp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token operator">-</span>EFAULT<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
            retval <span class="token operator">=</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> retval<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="27-5-总结"><a href="#27-5-总结" class="headerlink" title="27.5 总结"></a>27.5 总结</h4><p>一个字符设备要能够工作，需要三部分配合。</p>
<p>第一，有一个设备驱动程序的ko模块，里面有模块初始化函数、中断处理函数、设备操作函数。这里面封装了对于外部设备的操作。加载设备驱动程序模块的时候，模块初始化函数会被调用。在内核维护所有字符设备驱动的数据结构cdev_map里面注册，我们就可以很容易根据设备号，找到相应的设备驱动程序。</p>
<p>第二，在/dev目录下有一个文件表示这个设备，这个文件在特殊的devtmpfs文件系统上，因而也有相应的dentry和inode。这里的inode是一个特殊的inode，里面有设备号。通过它，我们可以在cdev_map中找到设备驱动程序，里面还有针对字符设备文件的默认操作def_chr_fops。</p>
<p>第三，打开一个字符设备文件和打开一个普通的文件有类似的数据结构，有文件描述符、有struct file、指向字符设备文件的dentry和inode。字符设备文件的相关操作file_operations一开始指向def_chr_fops，在调用def_chr_fops里面的chrdev_open函数的时候，修改为指向设备操作函数，从而读写一个字符设备文件就会直接变成读写外部设备了。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/打印机字符设备.jpeg" alt="打印机字符设备"></p>
<h3 id="28-字符设备（下）"><a href="#28-字符设备（下）" class="headerlink" title="28. 字符设备（下）"></a>28. 字符设备（下）</h3><h4 id="28-1-中断处理机制"><a href="#28-1-中断处理机制" class="headerlink" title="28.1 中断处理机制"></a>28.1 中断处理机制</h4><p>如果一个设备有事情需要通知操作系统，会通过中断和设备驱动程序进行交互，今天我们就来解析中断处理机制。</p>
<p>鼠标就是通过中断，将自己的位置和按键信息，传递给设备驱动程序。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">logibm_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">input_dev</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">request_irq</span><span class="token punctuation">(</span>logibm_irq<span class="token punctuation">,</span> logibm_interrupt<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"logibm"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printk</span><span class="token punctuation">(</span>KERN_ERR <span class="token string">"logibm.c: Can't allocate irq %d\n"</span><span class="token punctuation">,</span> logibm_irq<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>EBUSY<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">outb</span><span class="token punctuation">(</span>LOGIBM_ENABLE_IRQ<span class="token punctuation">,</span> LOGIBM_CONTROL_PORT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> irqreturn_t <span class="token function">logibm_interrupt</span><span class="token punctuation">(</span><span class="token keyword">int</span> irq<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>dev_id<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> dx<span class="token punctuation">,</span> dy<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> buttons<span class="token punctuation">;</span>

    <span class="token function">outb</span><span class="token punctuation">(</span>LOGIBM_READ_X_LOW<span class="token punctuation">,</span> LOGIBM_CONTROL_PORT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    dx <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">inb</span><span class="token punctuation">(</span>LOGIBM_DATA_PORT<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xf</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">outb</span><span class="token punctuation">(</span>LOGIBM_READ_X_HIGH<span class="token punctuation">,</span> LOGIBM_CONTROL_PORT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    dx <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token function">inb</span><span class="token punctuation">(</span>LOGIBM_DATA_PORT<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xf</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token function">outb</span><span class="token punctuation">(</span>LOGIBM_READ_Y_LOW<span class="token punctuation">,</span> LOGIBM_CONTROL_PORT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    dy <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">inb</span><span class="token punctuation">(</span>LOGIBM_DATA_PORT<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xf</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">outb</span><span class="token punctuation">(</span>LOGIBM_READ_Y_HIGH<span class="token punctuation">,</span> LOGIBM_CONTROL_PORT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    buttons <span class="token operator">=</span> <span class="token function">inb</span><span class="token punctuation">(</span>LOGIBM_DATA_PORT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    dy <span class="token operator">|=</span> <span class="token punctuation">(</span>buttons <span class="token operator">&amp;</span> <span class="token number">0xf</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span>
    buttons <span class="token operator">=</span> <span class="token operator">~</span>buttons <span class="token operator">&gt;&gt;</span> <span class="token number">5</span><span class="token punctuation">;</span>

    <span class="token function">input_report_rel</span><span class="token punctuation">(</span>logibm_dev<span class="token punctuation">,</span> REL_X<span class="token punctuation">,</span> dx<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">input_report_rel</span><span class="token punctuation">(</span>logibm_dev<span class="token punctuation">,</span> REL_Y<span class="token punctuation">,</span> dy<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">input_report_key</span><span class="token punctuation">(</span>logibm_dev<span class="token punctuation">,</span> BTN_RIGHT<span class="token punctuation">,</span>  buttons <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">input_report_key</span><span class="token punctuation">(</span>logibm_dev<span class="token punctuation">,</span> BTN_MIDDLE<span class="token punctuation">,</span> buttons <span class="token operator">&amp;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">input_report_key</span><span class="token punctuation">(</span>logibm_dev<span class="token punctuation">,</span> BTN_LEFT<span class="token punctuation">,</span>   buttons <span class="token operator">&amp;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">input_sync</span><span class="token punctuation">(</span>logibm_dev<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">outb</span><span class="token punctuation">(</span>LOGIBM_ENABLE_IRQ<span class="token punctuation">,</span> LOGIBM_CONTROL_PORT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> IRQ_HANDLED<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要处理中断，需要有一个中断处理函数。定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">irqreturn_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>irq_handler_t<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> irq<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span> dev_id<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * enum irqreturn
 * @IRQ_NONE        interrupt was not from this device or was not handled
 * @IRQ_HANDLED     interrupt was handled by this device
 * @IRQ_WAKE_THREAD handler requests to wake the handler thread
 */</span>
<span class="token keyword">enum</span> <span class="token class-name">irqreturn</span> <span class="token punctuation">{</span>
    IRQ_NONE        <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">&lt;&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    IRQ_HANDLED     <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    IRQ_WAKE_THREAD <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，irq是一个整数，是中断信号。dev_id是一个void *的通用指针，主要用于区分同一个中断处理函数对于不同设备的处理。</p>
<p>这里的返回值有三种：IRQ_NONE表示不是我的中断，不归我管；IRQ_HANDLED表示处理完了的中断；IRQ_WAKE_THREAD表示有一个进程正在等待这个中断，中断处理完了，应该唤醒它。</p>
<p>上面的例子中，logibm_interrupt这个中断处理函数，先是获取了x和y的移动坐标，以及左中右的按键，上报上去，然后返回IRQ_HANDLED，这表示处理完毕。</p>
<p>其实，写一个真正生产用的中断处理程序还是很复杂的。当一个中断信号A触发后，正在处理的过程中，这个中断信号A是应该暂时关闭的，这样是为了防止再来一个中断信号A，在当前的中断信号A的处理过程中插一杠子。但是，这个暂时关闭的时间应该多长呢？</p>
<p>如果太短了，应该原子化处理完毕的没有处理完毕，又被另一个中断信号A中断了，很多操作就不正确了；如果太长了，一直关闭着，新的中断信号A进不来，系统就显得很慢。所以，很多中断处理程序将整个中断要做的事情分成两部分，称为上半部和下半部，或者成为关键处理部分和延迟处理部分。在中断处理函数中，仅仅处理关键部分，完成了就将中断信号打开，使得新的中断可以进来，需要比较长时间处理的部分，也即延迟部分，往往通过工作队列等方式慢慢处理。</p>
<p>这个写起来可以是一本书了，推荐你好好读一读《Linux Device Drivers》这本书，这里我就不详细介绍了。</p>
<p>有了中断处理函数，接下来要调用request_irq来注册这个中断处理函数。request_irq有这样几个参数：</p>
<ul>
<li>unsigned int irq是中断信号；</li>
<li>irq_handler_t handler是中断处理函数；</li>
<li>unsigned long flags是一些标识位；</li>
<li>const char *name是设备名称；</li>
<li><code>void *dev</code>这个通用指针应该和中断处理函数的<code>void *dev</code>相对应。</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> __must_check
<span class="token function">request_irq</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> irq<span class="token punctuation">,</span> irq_handler_t handler<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">request_threaded_irq</span><span class="token punctuation">(</span>irq<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> flags<span class="token punctuation">,</span> name<span class="token punctuation">,</span> dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>中断处理函数被注册到哪里去呢？让我们沿着request_irq看下去。request_irq调用的是request_threaded_irq。代码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">request_threaded_irq</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> irq<span class="token punctuation">,</span> irq_handler_t handler<span class="token punctuation">,</span>
             irq_handler_t thread_fn<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> irqflags<span class="token punctuation">,</span>
             <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>devname<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>dev_id<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">irqaction</span> <span class="token operator">*</span>action<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">irq_desc</span> <span class="token operator">*</span>desc<span class="token punctuation">;</span>
    <span class="token keyword">int</span> retval<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    desc <span class="token operator">=</span> <span class="token function">irq_to_desc</span><span class="token punctuation">(</span>irq<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    action <span class="token operator">=</span> <span class="token function">kzalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irqaction</span><span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    action<span class="token operator">-&gt;</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span>
    action<span class="token operator">-&gt;</span>thread_fn <span class="token operator">=</span> thread_fn<span class="token punctuation">;</span>
    action<span class="token operator">-&gt;</span>flags <span class="token operator">=</span> irqflags<span class="token punctuation">;</span>
    action<span class="token operator">-&gt;</span>name <span class="token operator">=</span> devname<span class="token punctuation">;</span>
    action<span class="token operator">-&gt;</span>dev_id <span class="token operator">=</span> dev_id<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    retval <span class="token operator">=</span> <span class="token function">__setup_irq</span><span class="token punctuation">(</span>irq<span class="token punctuation">,</span> desc<span class="token punctuation">,</span> action<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于每一个中断，都有一个对中断的描述结构struct irq_desc。它有一个重要的成员变量是struct irqaction，用于表示处理这个中断的动作。如果我们仔细看这个结构，会发现，它里面有next指针，也就是说，这是一个链表，对于这个中断的所有处理动作，都串在这个链表上。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">irq_desc</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">struct</span> <span class="token class-name">irqaction</span>    <span class="token operator">*</span>action<span class="token punctuation">;</span>    <span class="token comment">/* IRQ action list */</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">struct</span> <span class="token class-name">module</span>       <span class="token operator">*</span>owner<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span>          <span class="token operator">*</span>name<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * struct irqaction - per interrupt action descriptor
 * @handler:    interrupt handler function
 * @name:   name of the device
 * @dev_id: cookie to identify the device
 * @percpu_dev_id:  cookie to identify the device
 * @next:   pointer to the next irqaction for shared interrupts
 * @irq:    interrupt number
 * @flags:  flags (see IRQF_* above)
 * @thread_fn:  interrupt handler function for threaded interrupts
 * @thread: thread pointer for threaded interrupts
 * @secondary:  pointer to secondary irqaction (force threading)
 * @thread_flags:   flags related to @thread
 * @thread_mask:    bitmask for keeping track of @thread activity
 * @dir:    pointer to the proc/irq/NN/name entry
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">irqaction</span> <span class="token punctuation">{</span>
    irq_handler_t           handler<span class="token punctuation">;</span>
    <span class="token keyword">void</span>                    <span class="token operator">*</span>dev_id<span class="token punctuation">;</span>
    <span class="token keyword">void</span> __percpu           <span class="token operator">*</span>percpu_dev_id<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">irqaction</span>        <span class="token operator">*</span>next<span class="token punctuation">;</span>
    irq_handler_t           thread_fn<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span>      <span class="token operator">*</span>thread<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">irqaction</span>        <span class="token operator">*</span>secondary<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>            irq<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>            flags<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>           thread_flags<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>           thread_mask<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span>              <span class="token operator">*</span>name<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">proc_dir_entry</span>   <span class="token operator">*</span>dir<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>每一个中断处理动作的结构struct irqaction，都有以下成员：</p>
<ul>
<li>中断处理函数handler；</li>
<li>void *dev_id为设备id；</li>
<li>irq为中断信号；</li>
<li>如果中断处理函数在单独的线程运行，则有thread_fn是线程的执行函数，thread是线程的task_struct。</li>
</ul>
<p>在request_threaded_irq函数中，irq_to_desc根据中断信号查找中断描述结构。如何查找呢？这就要区分情况。一般情况下，所有的struct irq_desc都放在一个数组里面，我们直接按下标查找就可以了。如果配置了CONFIG_SPARSE_IRQ，那中断号是不连续的，就不适合用数组保存了，</p>
<p>我们可以放在一棵基数树上。我们不是第一次遇到这个数据结构了。这种结构对于从某个整型key找到value速度很快，中断信号irq是这个整数。通过它，我们很快就能定位到对应的struct irq_desc。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_SPARSE_IRQ</span></span>
<span class="token keyword">static</span> <span class="token function">RADIX_TREE</span><span class="token punctuation">(</span>irq_desc_tree<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">irq_desc</span> <span class="token operator">*</span><span class="token function">irq_to_desc</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> irq<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">radix_tree_lookup</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>irq_desc_tree<span class="token punctuation">,</span> irq<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span> <span class="token comment">/* !CONFIG_SPARSE_IRQ */</span></span>
<span class="token keyword">struct</span> <span class="token class-name">irq_desc</span> irq_desc<span class="token punctuation">[</span>NR_IRQS<span class="token punctuation">]</span> __cacheline_aligned_in_smp <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> NR_IRQS<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">irq_desc</span> <span class="token operator">*</span><span class="token function">irq_to_desc</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> irq<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>irq <span class="token operator">&lt;</span> NR_IRQS<span class="token punctuation">)</span> <span class="token operator">?</span> irq_desc <span class="token operator">+</span> irq <span class="token operator">:</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/* !CONFIG_SPARSE_IRQ */</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为什么中断信号会有稀疏，也就是不连续的情况呢？这里需要说明一下，这里的irq并不是真正的、物理的中断信号，而是一个抽象的、虚拟的中断信号。因为物理的中断信号和硬件关联比较大，中断控制器也是各种各样的。</p>
<p>作为内核，我们不可能写程序的时候，适配各种各样的硬件中断控制器，因而就需要有一层中断抽象层。这里虚拟中断信号到中断描述结构的映射，就是抽象中断层的主要逻辑。</p>
<p>下面我们讲真正中断响应的时候，会涉及物理中断信号。可以想象，如果只有一个CPU，一个中断控制器，则基本能够保证从物理中断信号到虚拟中断信号的映射是线性的，这样用数组表示就没啥问题，但是如果有多个CPU，多个中断控制器，每个中断控制器各有各的物理中断信号，就没办法保证虚拟中断信号是连续的，所以就要用到基数树了。</p>
<p>接下来，request_threaded_irq函数分配了一个struct irqaction，并且初始化它，接着调用__setup_irq。在这个函数里面，如果struct irq_desc里面已经有struct irqaction了，我们就将新的struct irqaction挂在链表的末端。如果设定了以单独的线程运行中断处理函数，setup_irq_thread就会创建这个内核线程，wake_up_process会唤醒它。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span>
<span class="token function">__setup_irq</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> irq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">irq_desc</span> <span class="token operator">*</span>desc<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">irqaction</span> <span class="token operator">*</span>new<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">irqaction</span> <span class="token operator">*</span>old<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token operator">*</span>old_ptr<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">,</span> thread_mask <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">,</span> nested<span class="token punctuation">,</span> shared <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    new<span class="token operator">-&gt;</span>irq <span class="token operator">=</span> irq<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/*
     * Create a handler thread when a thread function is supplied
     * and the interrupt does not nest into another interrupt
     * thread.
     */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>new<span class="token operator">-&gt;</span>thread_fn <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>nested<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ret <span class="token operator">=</span> <span class="token function">setup_irq_thread</span><span class="token punctuation">(</span>new<span class="token punctuation">,</span> irq<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    old_ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>desc<span class="token operator">-&gt;</span>action<span class="token punctuation">;</span>
    old <span class="token operator">=</span> <span class="token operator">*</span>old_ptr<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>old<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* add new interrupt at end of irq queue */</span>
        <span class="token keyword">do</span> <span class="token punctuation">{</span>
            thread_mask <span class="token operator">|=</span> old<span class="token operator">-&gt;</span>thread_mask<span class="token punctuation">;</span>
            old_ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>old<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
            old <span class="token operator">=</span> <span class="token operator">*</span>old_ptr<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>old<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token operator">*</span>old_ptr <span class="token operator">=</span> new<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>new<span class="token operator">-&gt;</span>thread<span class="token punctuation">)</span>
        <span class="token function">wake_up_process</span><span class="token punctuation">(</span>new<span class="token operator">-&gt;</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span>
<span class="token function">setup_irq_thread</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irqaction</span> <span class="token operator">*</span>new<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> irq<span class="token punctuation">,</span> bool secondary<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>t<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_param</span> param <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span>sched_priority <span class="token operator">=</span> MAX_USER_RT_PRIO<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>


    t <span class="token operator">=</span> <span class="token function">kthread_create</span><span class="token punctuation">(</span>irq_thread<span class="token punctuation">,</span> new<span class="token punctuation">,</span> <span class="token string">"irq/%d-%s"</span><span class="token punctuation">,</span> irq<span class="token punctuation">,</span> new<span class="token operator">-&gt;</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sched_setscheduler_nocheck</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> SCHED_FIFO<span class="token punctuation">,</span> <span class="token operator">&amp;</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">get_task_struct</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    new<span class="token operator">-&gt;</span>thread <span class="token operator">=</span> t<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>至此为止，request_irq完成了它的使命。总结来说，它就是根据中断信号irq，找到基数树上对应的irq_desc，然后将新的irqaction挂在链表上。</p>
<p>接下来，我们就来看，真正中断来了的时候，会发生一些什么。</p>
<p>真正中断的发生还是要从硬件开始。这里面有四个层次。</p>
<ul>
<li>第一个层次是外部设备给中断控制器发送物理中断信号。</li>
<li>第二个层次是中断控制器将物理中断信号转换成为中断向量interrupt vector，发给各个CPU。</li>
<li>第三个层次是每个CPU都会有一个中断向量表，根据interrupt vector调用一个IRQ处理函数。注意这里的IRQ处理函数还不是咱们上面指定的irq_handler_t，到这一层还是CPU硬件的要求。</li>
<li>第四个层次是在IRQ处理函数中，将interrupt vector转化为抽象中断层的中断信号irq，调用中断信号irq对应的中断描述结构里面的irq_handler_t。</li>
</ul>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/硬件发生中断.png" alt="硬件发生中断"></p>
<p>在这里，我们不解析硬件的部分，我们从CPU收到中断向量开始分析。</p>
<p>CPU收到的中断向量是什么样的呢？这个定义在文件arch/x86/include/asm/irq_vectors.h中。这里面的注释非常好，建议你仔细阅读。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * Linux IRQ vector layout.
 *
 * There are 256 IDT entries (per CPU - each entry is 8 bytes) which can
 * be defined by Linux. They are used as a jump table by the CPU when a
 * given vector is triggered - by a CPU-external, CPU-internal or
 * software-triggered event.
 *
 * Linux sets the kernel code address each entry jumps to early during
 * bootup, and never changes them. This is the general layout of the
 * IDT entries:
 *
 *  Vectors   0 ...  31 : system traps and exceptions - hardcoded events
 *  Vectors  32 ... 127 : device interrupts
 *  Vector  128         : legacy int80 syscall interface
 *  Vectors 129 ... INVALIDATE_TLB_VECTOR_START-1 except 204 : device interrupts
 *  Vectors INVALIDATE_TLB_VECTOR_START ... 255 : special interrupts
 *
 * 64-bit x86 has per CPU IDT tables, 32-bit has one shared IDT table.
 *
 * This file enumerates the exact layout of them:
 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">FIRST_EXTERNAL_VECTOR       <span class="token number">0x20</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">IA32_SYSCALL_VECTOR         <span class="token number">0x80</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">NR_VECTORS                  <span class="token number">256</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">FIRST_SYSTEM_VECTOR         NR_VECTORS</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过这些注释，我们可以看出，CPU能够处理的中断总共256个，用宏NR_VECTOR或者FIRST_SYSTEM_VECTOR表示。</p>
<p>为了处理中断，CPU硬件要求每一个CPU都有一个中断向量表，通过load_idt加载，里面记录着每一个中断对应的处理方法，这个中断向量表定义在文件arch/x86/kernel/traps.c中。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">gate_desc idt_table<span class="token punctuation">[</span>NR_VECTORS<span class="token punctuation">]</span> __page_aligned_bss<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>对于一个CPU可以处理的中断被分为几个部分，第一部分0到31的前32位是系统陷入或者系统异常，这些错误无法屏蔽，一定要处理。</p>
<p>这些中断的处理函数在系统初始化的时候，在start_kernel函数中调用过trap_init()。这个咱们讲系统初始化和系统调用的时候，都大概讲过这个函数，这里还需要仔细看一下。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> __init <span class="token function">trap_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">set_intr_gate</span><span class="token punctuation">(</span>X86_TRAP_DE<span class="token punctuation">,</span> divide_error<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//各种各样的set_intr_gate，不都贴在这里了，只贴一头一尾</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">set_intr_gate</span><span class="token punctuation">(</span>X86_TRAP_XF<span class="token punctuation">,</span> simd_coprocessor_error<span class="token punctuation">)</span><span class="token punctuation">;</span>


    <span class="token comment">/* Reserve all the builtin and the syscall vector: */</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> FIRST_EXTERNAL_VECTOR<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">set_bit</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> used_vectors<span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_X86_32</span></span>
    <span class="token function">set_system_intr_gate</span><span class="token punctuation">(</span>IA32_SYSCALL_VECTOR<span class="token punctuation">,</span> entry_INT80_32<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">set_bit</span><span class="token punctuation">(</span>IA32_SYSCALL_VECTOR<span class="token punctuation">,</span> used_vectors<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>


    <span class="token comment">/*
     * Set the IDT descriptor to a fixed read-only location, so that the
     * "sidt" instruction will not leak the location of the kernel, and
     * to defend the IDT against arbitrary memory write vulnerabilities.
     * It will be reloaded in cpu_init() */</span>
    <span class="token function">__set_fixmap</span><span class="token punctuation">(</span>FIX_RO_IDT<span class="token punctuation">,</span> <span class="token function">__pa_symbol</span><span class="token punctuation">(</span>idt_table<span class="token punctuation">)</span><span class="token punctuation">,</span> PAGE_KERNEL_RO<span class="token punctuation">)</span><span class="token punctuation">;</span>
    idt_descr<span class="token punctuation">.</span>address <span class="token operator">=</span> <span class="token function">fix_to_virt</span><span class="token punctuation">(</span>FIX_RO_IDT<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我这里贴的代码省略了很多，在trap_init函数的一开始，调用了大量的set_intr_gate，最终都会调用_set_gate，代码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">_set_gate</span><span class="token punctuation">(</span><span class="token keyword">int</span> gate<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> type<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span>
                 <span class="token keyword">unsigned</span> dpl<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> ist<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> seg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    gate_desc s<span class="token punctuation">;</span>
    <span class="token function">pack_gate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span> type<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span>addr<span class="token punctuation">,</span> dpl<span class="token punctuation">,</span> ist<span class="token punctuation">,</span> seg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">write_idt_entry</span><span class="token punctuation">(</span>idt_table<span class="token punctuation">,</span> gate<span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从代码可以看出，set_intr_gate其实就是将每个中断都设置了中断处理函数，放在中断向量表idt_table中。</p>
<p>在trap_init中，由于set_intr_gate调用的太多，容易让人眼花缭乱。其实arch/x86/include/asm/traps.h文件中，早就定义好了前32个中断。如果仔细对比一下，你会发现，这些都在trap_init中使用set_intr_gate设置过了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Interrupts/Exceptions */</span>
<span class="token keyword">enum</span> <span class="token punctuation">{</span>
    X86_TRAP_DE <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token comment">/*  0, Divide-by-zero */</span>
    X86_TRAP_DB<span class="token punctuation">,</span>        <span class="token comment">/*  1, Debug */</span>
    X86_TRAP_NMI<span class="token punctuation">,</span>       <span class="token comment">/*  2, Non-maskable Interrupt */</span>
    X86_TRAP_BP<span class="token punctuation">,</span>        <span class="token comment">/*  3, Breakpoint */</span>
    X86_TRAP_OF<span class="token punctuation">,</span>        <span class="token comment">/*  4, Overflow */</span>
    X86_TRAP_BR<span class="token punctuation">,</span>        <span class="token comment">/*  5, Bound Range Exceeded */</span>
    X86_TRAP_UD<span class="token punctuation">,</span>        <span class="token comment">/*  6, Invalid Opcode */</span>
    X86_TRAP_NM<span class="token punctuation">,</span>        <span class="token comment">/*  7, Device Not Available */</span>
    X86_TRAP_DF<span class="token punctuation">,</span>        <span class="token comment">/*  8, Double Fault */</span>
    X86_TRAP_OLD_MF<span class="token punctuation">,</span>    <span class="token comment">/*  9, Coprocessor Segment Overrun */</span>
    X86_TRAP_TS<span class="token punctuation">,</span>        <span class="token comment">/* 10, Invalid TSS */</span>
    X86_TRAP_NP<span class="token punctuation">,</span>        <span class="token comment">/* 11, Segment Not Present */</span>
    X86_TRAP_SS<span class="token punctuation">,</span>        <span class="token comment">/* 12, Stack Segment Fault */</span>
    X86_TRAP_GP<span class="token punctuation">,</span>        <span class="token comment">/* 13, General Protection Fault */</span>
    X86_TRAP_PF<span class="token punctuation">,</span>        <span class="token comment">/* 14, Page Fault */</span>
    X86_TRAP_SPURIOUS<span class="token punctuation">,</span>  <span class="token comment">/* 15, Spurious Interrupt */</span>
    X86_TRAP_MF<span class="token punctuation">,</span>        <span class="token comment">/* 16, x87 Floating-Point Exception */</span>
    X86_TRAP_AC<span class="token punctuation">,</span>        <span class="token comment">/* 17, Alignment Check */</span>
    X86_TRAP_MC<span class="token punctuation">,</span>        <span class="token comment">/* 18, Machine Check */</span>
    X86_TRAP_XF<span class="token punctuation">,</span>        <span class="token comment">/* 19, SIMD Floating-Point Exception */</span>
    X86_TRAP_IRET <span class="token operator">=</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token comment">/* 32, IRET Exception */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们回到trap_init中，当前32个中断都用set_intr_gate设置完毕。在中断向量表idt_table中填完了之后，接下来的for循环，for (i = 0; i &lt; FIRST_EXTERNAL_VECTOR; i++)，将前32个中断都在used_vectors中标记为1，表示这些都设置过中断处理函数了。</p>
<p>接下来，trap_init对单独调用set_intr_gate来设置32位系统调用的中断。IA32_SYSCALL_VECTOR，也即128，单独将used_vectors中的第128位标记为1。</p>
<p>在trap_init的最后，我们将idt_table放在一个固定的虚拟地址上。trap_init结束后，中断向量表中已经填好了前32位，外加一位32位系统调用，其他的都是用于设备中断。</p>
<p>在start_kernel调用完毕trap_init之后，还会调用init_IRQ()来初始化其他的设备中断，最终会调用到native_init_IRQ。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> __init <span class="token function">native_init_IRQ</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    i <span class="token operator">=</span> FIRST_EXTERNAL_VECTOR<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">CONFIG_X86_LOCAL_APIC</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">first_system_vector NR_VECTORS</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token function">for_each_clear_bit_from</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> used_vectors<span class="token punctuation">,</span> first_system_vector<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* IA32_SYSCALL_VECTOR could be used in trap_init already. */</span>
        <span class="token function">set_intr_gate</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> irq_entries_start <span class="token operator">+</span>
                <span class="token number">8</span> <span class="token operator">*</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> FIRST_EXTERNAL_VECTOR<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面从第32个中断开始，到最后NR_VECTORS为止，对于used_vectors中没有标记为1的位置，都会调用set_intr_gate设置中断向量表。</p>
<p>其实used_vectors中没有标记为1的，都是设备中断的部分。</p>
<p>也即所有的设备中断的中断处理函数，在中断向量表里面都会设置为从irq_entries_start开始，偏移量为i - FIRST_EXTERNAL_VECTOR的一项。</p>
<p>看来中断处理函数是定义在irq_entries_start这个表里面的，我们在arch\x86\entry\entry_32.S和arch\x86\entry\entry_64.S都能找到这个函数表的定义。</p>
<p>这又是汇编语言，不需要完全看懂，但是我们还是能看出来，这里面定义了FIRST_SYSTEM_VECTOR - FIRST_EXTERNAL_VECTOR项。每一项都是中断处理函数，会跳到common_interrupt去执行。这里会最终调用do_IRQ，调用完毕后，就从中断返回。这里我们需要区分返回用户态还是内核态。这里会有一个几乎触发抢占，咱们讲进程切换的时候讲过的。</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">ENTRY(irq_entries_start)
    vector=FIRST_EXTERNAL_VECTOR
    .rept (FIRST_SYSTEM_VECTOR - FIRST_EXTERNAL_VECTOR)
    pushl   $(~vector+0x80)         /* Note: always in signed byte range */
    vector=vector+1
    jmp common_interrupt /* 会调用到do_IRQ */
    .align  8
    .endr
END(irq_entries_start)


common_interrupt:
    ASM_CLAC
    addq    $-0x80, (%rsp)          /* Adjust vector to [-256, -1] range */
    interrupt do_IRQ
    /* 0(%rsp): old RSP */
ret_from_intr:
......
    /* Interrupt came from user space */
GLOBAL(retint_user)
......
/* Returning to kernel space */
retint_kernel:
......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样任何一个中断向量到达任何一个CPU，最终都会走到do_IRQ。我们来看do_IRQ的实现。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * do_IRQ handles all normal device IRQ's (the special
 * SMP cross-CPU interrupts have their own specific
 * handlers).
 */</span>
__visible <span class="token keyword">unsigned</span> <span class="token keyword">int</span> __irq_entry <span class="token function">do_IRQ</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span>regs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span>old_regs <span class="token operator">=</span> <span class="token function">set_irq_regs</span><span class="token punctuation">(</span>regs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">irq_desc</span> <span class="token operator">*</span> desc<span class="token punctuation">;</span>
    <span class="token comment">/* high bit used in ret_from_ code  */</span>
    <span class="token keyword">unsigned</span> vector <span class="token operator">=</span> <span class="token operator">~</span>regs<span class="token operator">-&gt;</span>orig_ax<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    desc <span class="token operator">=</span> <span class="token function">__this_cpu_read</span><span class="token punctuation">(</span>vector_irq<span class="token punctuation">[</span>vector<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">handle_irq</span><span class="token punctuation">(</span>desc<span class="token punctuation">,</span> regs<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">set_irq_regs</span><span class="token punctuation">(</span>old_regs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里面，从AX寄存器里面拿到了中断向量vector，但是别忘了中断控制器发送给每个CPU的中断向量都是每个CPU局部的，而抽象中断处理层的虚拟中断信号irq以及它对应的中断描述结构irq_desc是全局的，也即这个CPU的200号的中断向量和另一个CPU的200号中断向量对应的虚拟中断信号irq和中断描述结构irq_desc可能不一样，这就需要一个映射关系。这个映射关系放在Per CPU变量vector_irq里面。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">DECLARE_PER_CPU</span><span class="token punctuation">(</span>vector_irq_t<span class="token punctuation">,</span> vector_irq<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在系统初始化的时候，我们会调用__assign_irq_vector，将虚拟中断信号irq分配到某个CPU上的中断向量。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">__assign_irq_vector</span><span class="token punctuation">(</span><span class="token keyword">int</span> irq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">apic_chip_data</span> <span class="token operator">*</span>d<span class="token punctuation">,</span>
                   <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">cpumask</span> <span class="token operator">*</span>mask<span class="token punctuation">,</span>
                   <span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>irqdata<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> current_vector <span class="token operator">=</span> FIRST_EXTERNAL_VECTOR <span class="token operator">+</span> VECTOR_OFFSET_START<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> current_offset <span class="token operator">=</span> VECTOR_OFFSET_START <span class="token operator">%</span> <span class="token number">16</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> cpu<span class="token punctuation">,</span> vector<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>cpu <span class="token operator">&lt;</span> nr_cpu_ids<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> new_cpu<span class="token punctuation">,</span> offset<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        vector <span class="token operator">=</span> current_vector<span class="token punctuation">;</span>
        offset <span class="token operator">=</span> current_offset<span class="token punctuation">;</span>
next<span class="token operator">:</span>
        vector <span class="token operator">+=</span> <span class="token number">16</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>vector <span class="token operator">&gt;=</span> first_system_vector<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            offset <span class="token operator">=</span> <span class="token punctuation">(</span>offset <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">16</span><span class="token punctuation">;</span>
            vector <span class="token operator">=</span> FIRST_EXTERNAL_VECTOR <span class="token operator">+</span> offset<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">/* If the search wrapped around, try the next cpu */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>current_vector <span class="token operator">==</span> vector<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">goto</span> next_cpu<span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">test_bit</span><span class="token punctuation">(</span>vector<span class="token punctuation">,</span> used_vectors<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">goto</span> next<span class="token punctuation">;</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token comment">/* Found one! */</span>
        current_vector <span class="token operator">=</span> vector<span class="token punctuation">;</span>
        current_offset <span class="token operator">=</span> offset<span class="token punctuation">;</span>
        <span class="token comment">/* Schedule the old vector for cleanup on all cpus */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>d<span class="token operator">-&gt;</span>cfg<span class="token punctuation">.</span>vector<span class="token punctuation">)</span>
            <span class="token function">cpumask_copy</span><span class="token punctuation">(</span>d<span class="token operator">-&gt;</span>old_domain<span class="token punctuation">,</span> d<span class="token operator">-&gt;</span>domain<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">for_each_cpu</span><span class="token punctuation">(</span>new_cpu<span class="token punctuation">,</span> vector_searchmask<span class="token punctuation">)</span>
            <span class="token function">per_cpu</span><span class="token punctuation">(</span>vector_irq<span class="token punctuation">,</span> new_cpu<span class="token punctuation">)</span><span class="token punctuation">[</span>vector<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">irq_to_desc</span><span class="token punctuation">(</span>irq<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> update<span class="token punctuation">;</span>

next_cpu<span class="token operator">:</span>
        <span class="token function">cpumask_or</span><span class="token punctuation">(</span>searched_cpumask<span class="token punctuation">,</span> searched_cpumask<span class="token punctuation">,</span> vector_cpumask<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">cpumask_andnot</span><span class="token punctuation">(</span>vector_cpumask<span class="token punctuation">,</span> mask<span class="token punctuation">,</span> searched_cpumask<span class="token punctuation">)</span><span class="token punctuation">;</span>
        cpu <span class="token operator">=</span> <span class="token function">cpumask_first_and</span><span class="token punctuation">(</span>vector_cpumask<span class="token punctuation">,</span> cpu_online_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里，一旦找到某个向量，就将CPU的此向量对应的向量描述结构irq_desc，设置为虚拟中断信号irq对应的向量描述结构irq_to_desc(irq)。</p>
<p>这样do_IRQ会根据中断向量vector得到对应的irq_desc，然后调用handle_irq。handle_irq会调用generic_handle_irq_desc，里面调用irq_desc的handle_irq。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">generic_handle_irq_desc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_desc</span> <span class="token operator">*</span>desc<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    desc<span class="token operator">-&gt;</span><span class="token function">handle_irq</span><span class="token punctuation">(</span>desc<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里的handle_irq，最终会调用__handle_irq_event_percpu。代码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">irqreturn_t <span class="token function">__handle_irq_event_percpu</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_desc</span> <span class="token operator">*</span>desc<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token operator">*</span>flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    irqreturn_t retval <span class="token operator">=</span> IRQ_NONE<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> irq <span class="token operator">=</span> desc<span class="token operator">-&gt;</span>irq_data<span class="token punctuation">.</span>irq<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">irqaction</span> <span class="token operator">*</span>action<span class="token punctuation">;</span>

    <span class="token function">record_irq_time</span><span class="token punctuation">(</span>desc<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">for_each_action_of_desc</span><span class="token punctuation">(</span>desc<span class="token punctuation">,</span> action<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        irqreturn_t res<span class="token punctuation">;</span>
        res <span class="token operator">=</span> action<span class="token operator">-&gt;</span><span class="token function">handler</span><span class="token punctuation">(</span>irq<span class="token punctuation">,</span> action<span class="token operator">-&gt;</span>dev_id<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> IRQ_WAKE_THREAD<span class="token operator">:</span>
            <span class="token function">__irq_wake_thread</span><span class="token punctuation">(</span>desc<span class="token punctuation">,</span> action<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> IRQ_HANDLED<span class="token operator">:</span>
            <span class="token operator">*</span>flags <span class="token operator">|=</span> action<span class="token operator">-&gt;</span>flags<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        retval <span class="token operator">|=</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> retval<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>__handle_irq_event_percpu里面调用了irq_desc里每个hander，这些hander是我们在所有action列表中注册的，这才是我们设置的那个中断处理函数。如果返回值是IRQ_HANDLED，就说明处理完毕；如果返回值是IRQ_WAKE_THREAD就唤醒线程。</p>
<p>至此，中断的整个过程就结束了。</p>
<h4 id="28-2-总结"><a href="#28-2-总结" class="headerlink" title="28.2 总结"></a>28.2 总结</h4><p>中断是从外部设备发起的，会形成外部中断。外部中断会到达中断控制器，中断控制器会发送中断向量Interrupt Vector给CPU。</p>
<p>对于每一个CPU，都要求有一个idt_table，里面存放了不同的中断向量的处理函数。中断向量表中已经填好了前32位，外加一位32位系统调用，其他的都是用于设备中断。</p>
<p>硬件中断的处理函数是do_IRQ进行统一处理，在这里会让中断向量，通过vector_irq映射为irq_desc。</p>
<p>irq_desc是一个用于描述用户注册的中断处理函数的结构，为了能够根据中断向量得到irq_desc结构，会把这些结构放在一个基数树里面，方便查找。</p>
<p>irq_desc里面有一个成员是irqaction，指向设备驱动程序里面注册的中断处理函数。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/中断的处理过程.png" alt="中断的处理过程"></p>
<h3 id="29-块设备（上）"><a href="#29-块设备（上）" class="headerlink" title="29. 块设备（上）"></a>29. 块设备（上）</h3><h4 id="29-1-打开流程"><a href="#29-1-打开流程" class="headerlink" title="29.1 打开流程"></a>29.1 打开流程</h4><p>块设备一般会被格式化为文件系统，但是，下面的讲述中，你可能会有一点困惑。你会看到各种各样的dentry和inode。块设备涉及三种文件系统，所以你看到的这些dentry和inode可能都不是一回事儿，请注意分辨。</p>
<p>块设备需要mknod吗？对于启动盘，你可能觉得，启动了就在那里了。可是如果我们要插进一块新的USB盘，还是要有这个操作的。</p>
<p>mknod还是会创建在/dev路径下面，这一点和字符设备一样。/dev路径下面是devtmpfs文件系统。<strong>这是块设备遇到的第一个文件系统</strong>。我们会为这个块设备文件，分配一个特殊的inode，这一点和字符设备也是一样的。只不过字符设备走S_ISCHR这个分支，对应inode的file_operations是def_chr_fops；而块设备走S_ISBLK这个分支，对应的inode的file_operations是def_blk_fops。这里要注意，inode里面的i_rdev被设置成了块设备的设备号dev_t，这个我们后面会用到，你先记住有这么一回事儿。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">init_special_inode</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> umode_t mode<span class="token punctuation">,</span> dev_t rdev<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    inode<span class="token operator">-&gt;</span>i_mode <span class="token operator">=</span> mode<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">S_ISCHR</span><span class="token punctuation">(</span>mode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        inode<span class="token operator">-&gt;</span>i_fop <span class="token operator">=</span> <span class="token operator">&amp;</span>def_chr_fops<span class="token punctuation">;</span>
        inode<span class="token operator">-&gt;</span>i_rdev <span class="token operator">=</span> rdev<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">S_ISBLK</span><span class="token punctuation">(</span>mode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        inode<span class="token operator">-&gt;</span>i_fop <span class="token operator">=</span> <span class="token operator">&amp;</span>def_blk_fops<span class="token punctuation">;</span>
        inode<span class="token operator">-&gt;</span>i_rdev <span class="token operator">=</span> rdev<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">S_ISFIFO</span><span class="token punctuation">(</span>mode<span class="token punctuation">)</span><span class="token punctuation">)</span>
        inode<span class="token operator">-&gt;</span>i_fop <span class="token operator">=</span> <span class="token operator">&amp;</span>pipefifo_fops<span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">S_ISSOCK</span><span class="token punctuation">(</span>mode<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">;</span>   <span class="token comment">/* leave it no_open_fops */</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>特殊inode的默认file_operations是def_blk_fops，就像字符设备一样，有打开、读写这个块设备文件，但是我们常规操作不会这样做。我们会将这个块设备文件mount到一个文件夹下面。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> def_blk_fops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>open           <span class="token operator">=</span> blkdev_open<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>release        <span class="token operator">=</span> blkdev_close<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>llseek         <span class="token operator">=</span> block_llseek<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>read_iter      <span class="token operator">=</span> blkdev_read_iter<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>write_iter     <span class="token operator">=</span> blkdev_write_iter<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>mmap           <span class="token operator">=</span> generic_file_mmap<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>fsync          <span class="token operator">=</span> blkdev_fsync<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>unlocked_ioctl <span class="token operator">=</span> block_ioctl<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>splice_read    <span class="token operator">=</span> generic_file_splice_read<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>splice_write   <span class="token operator">=</span> iter_file_splice_write<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>fallocate      <span class="token operator">=</span> blkdev_fallocate<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不过，这里我们还是简单看一下，打开这个块设备的操作blkdev_open。它里面调用的是blkdev_get打开这个块设备，了解到这一点就可以了。</p>
<p>接下来，我们要调用mount，将这个块设备文件挂载到一个文件夹下面。如果这个块设备原来被格式化为一种文件系统的格式，例如ext4，那我们调用的就是ext4相应的mount操作。<strong>这是块设备遇到的第二个文件系统</strong>，也是向这个块设备读写文件，需要基于的主流文件系统。咱们在文件系统那一节解析的对于文件的读写流程，都是基于这个文件系统的。</p>
<p>还记得，咱们注册ext4文件系统的时候，有下面这样的结构：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">file_system_type</span> ext4_fs_type <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>owner      <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>name       <span class="token operator">=</span> <span class="token string">"ext4"</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>mount      <span class="token operator">=</span> ext4_mount<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>kill_sb    <span class="token operator">=</span> kill_block_super<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>fs_flags   <span class="token operator">=</span> FS_REQUIRES_DEV<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在将一个硬盘的块设备mount成为ext4的时候，我们会调用ext4_mount-&gt;mount_bdev。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token function">ext4_mount</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file_system_type</span> <span class="token operator">*</span>fs_type<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>dev_name<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">mount_bdev</span><span class="token punctuation">(</span>fs_type<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> dev_name<span class="token punctuation">,</span> data<span class="token punctuation">,</span> ext4_fill_super<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token function">mount_bdev</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file_system_type</span> <span class="token operator">*</span>fs_type<span class="token punctuation">,</span>
    <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>dev_name<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">,</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>fill_super<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">block_device</span> <span class="token operator">*</span>bdev<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span>s<span class="token punctuation">;</span>
    fmode_t mode <span class="token operator">=</span> FMODE_READ <span class="token operator">|</span> FMODE_EXCL<span class="token punctuation">;</span>
    <span class="token keyword">int</span> error <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> MS_RDONLY<span class="token punctuation">)</span><span class="token punctuation">)</span>
        mode <span class="token operator">|=</span> FMODE_WRITE<span class="token punctuation">;</span>

    bdev <span class="token operator">=</span> <span class="token function">blkdev_get_by_path</span><span class="token punctuation">(</span>dev_name<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> fs_type<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    s <span class="token operator">=</span> <span class="token function">sget</span><span class="token punctuation">(</span>fs_type<span class="token punctuation">,</span> test_bdev_super<span class="token punctuation">,</span> set_bdev_super<span class="token punctuation">,</span> flags <span class="token operator">|</span> MS_NOSEC<span class="token punctuation">,</span> bdev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> <span class="token function">dget</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>s_root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>mount_bdev主要做了两件大事情。第一，blkdev_get_by_path根据/dev/xxx这个名字，找到相应的设备并打开它；第二，sget根据打开的设备文件，填充ext4文件系统的super_block，从而以此为基础，建立一整套咱们在<strong>文件系统</strong>那一章讲的体系。</p>
<p>一旦这套体系建立起来以后，对于文件的读写都是通过ext4文件系统这个体系进行的，创建的inode结构也是指向ext4文件系统的。文件系统那一章我们只解析了这部分，由于没有到达底层，也就没有关注块设备相关的操作。这一章我们重新回过头来，一方面看mount的时候，对于块设备都做了哪些操作，另一方面看读写的时候，到了底层，对于块设备做了哪些操作。</p>
<p>这里我们先来看mount_bdev做的第一件大事情，通过blkdev_get_by_path，根据设备名/dev/xxx，得到struct block_device *bdev。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/**
 * blkdev_get_by_path - open a block device by name
 * @path: path to the block device to open
 * @mode: FMODE_* mask
 * @holder: exclusive holder identifier
 *
 * Open the blockdevice described by the device file at @path.  @mode
 * and @holder are identical to blkdev_get().
 *
 * On success, the returned block_device has reference count of one.
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">block_device</span> <span class="token operator">*</span><span class="token function">blkdev_get_by_path</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> fmode_t mode<span class="token punctuation">,</span>
                    <span class="token keyword">void</span> <span class="token operator">*</span>holder<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">block_device</span> <span class="token operator">*</span>bdev<span class="token punctuation">;</span>
    <span class="token keyword">int</span> err<span class="token punctuation">;</span>

    bdev <span class="token operator">=</span> <span class="token function">lookup_bdev</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    err <span class="token operator">=</span> <span class="token function">blkdev_get</span><span class="token punctuation">(</span>bdev<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> holder<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> bdev<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>blkdev_get_by_path干了两件事情。第一个，lookup_bdev根据设备路径/dev/xxx得到block_device。第二个，打开这个设备，调用blkdev_get。</p>
<p>咱们上面分析过def_blk_fops的默认打开设备函数blkdev_open，它也是调用blkdev_get的。块设备的打开往往不是直接调用设备文件的打开函数，而是调用mount来打开的。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/**
 * lookup_bdev  - lookup a struct block_device by name
 * @pathname:   special file representing the block device
 *
 * Get a reference to the blockdevice at @pathname in the current
 * namespace if possible and return it.  Return ERR_PTR(error)
 * otherwise.
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">block_device</span> <span class="token operator">*</span><span class="token function">lookup_bdev</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">block_device</span> <span class="token operator">*</span>bdev<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">path</span> path<span class="token punctuation">;</span>
    <span class="token keyword">int</span> error<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pathname <span class="token operator">||</span> <span class="token operator">!</span><span class="token operator">*</span>pathname<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">ERR_PTR</span><span class="token punctuation">(</span><span class="token operator">-</span>EINVAL<span class="token punctuation">)</span><span class="token punctuation">;</span>

    error <span class="token operator">=</span> <span class="token function">kern_path</span><span class="token punctuation">(</span>pathname<span class="token punctuation">,</span> LOOKUP_FOLLOW<span class="token punctuation">,</span> <span class="token operator">&amp;</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">ERR_PTR</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>

    inode <span class="token operator">=</span> <span class="token function">d_backing_inode</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span>dentry<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    bdev <span class="token operator">=</span> <span class="token function">bd_acquire</span><span class="token punctuation">(</span>inode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">goto</span> out<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>lookup_bdev这里的pathname是设备的文件名，例如/dev/xxx。这个文件是在devtmpfs文件系统中的，kern_path可以在这个文件系统里面，一直找到它对应的dentry。接下来，d_backing_inode会获得inode。这个inode就是那个init_special_inode生成的特殊inode。</p>
<p>接下来，bd_acquire通过这个特殊的inode，找到struct block_device。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">block_device</span> <span class="token operator">*</span><span class="token function">bd_acquire</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">block_device</span> <span class="token operator">*</span>bdev<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    bdev <span class="token operator">=</span> <span class="token function">bdget</span><span class="token punctuation">(</span>inode<span class="token operator">-&gt;</span>i_rdev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>bdev<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">spin_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bdev_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>inode<span class="token operator">-&gt;</span>i_bdev<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">/*
             * We take an additional reference to bd_inode,
             * and it's released in clear_inode() of inode.
             * So, we can access it via -&gt;i_mapping always
             * without igrab().
             */</span>
            <span class="token function">bdgrab</span><span class="token punctuation">(</span>bdev<span class="token punctuation">)</span><span class="token punctuation">;</span>
            inode<span class="token operator">-&gt;</span>i_bdev <span class="token operator">=</span> bdev<span class="token punctuation">;</span>
            inode<span class="token operator">-&gt;</span>i_mapping <span class="token operator">=</span> bdev<span class="token operator">-&gt;</span>bd_inode<span class="token operator">-&gt;</span>i_mapping<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> bdev<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>bd_acquire中最主要的就是调用bdget，它的参数是特殊inode的i_rdev。这里面在mknod的时候，放的是设备号dev_t。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">block_device</span> <span class="token operator">*</span><span class="token function">bdget</span><span class="token punctuation">(</span>dev_t dev<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">block_device</span> <span class="token operator">*</span>bdev<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">;</span>

        inode <span class="token operator">=</span> <span class="token function">iget5_locked</span><span class="token punctuation">(</span>blockdev_superblock<span class="token punctuation">,</span> <span class="token function">hash</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">,</span>
                        bdev_test<span class="token punctuation">,</span> bdev_set<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>

        bdev <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">BDEV_I</span><span class="token punctuation">(</span>inode<span class="token punctuation">)</span><span class="token operator">-&gt;</span>bdev<span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>inode<span class="token operator">-&gt;</span>i_state <span class="token operator">&amp;</span> I_NEW<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                bdev<span class="token operator">-&gt;</span>bd_contains <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
                bdev<span class="token operator">-&gt;</span>bd_super <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
                bdev<span class="token operator">-&gt;</span>bd_inode <span class="token operator">=</span> inode<span class="token punctuation">;</span>
                bdev<span class="token operator">-&gt;</span>bd_block_size <span class="token operator">=</span> <span class="token function">i_blocksize</span><span class="token punctuation">(</span>inode<span class="token punctuation">)</span><span class="token punctuation">;</span>
                bdev<span class="token operator">-&gt;</span>bd_part_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                bdev<span class="token operator">-&gt;</span>bd_invalidated <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                inode<span class="token operator">-&gt;</span>i_mode <span class="token operator">=</span> S_IFBLK<span class="token punctuation">;</span>
                inode<span class="token operator">-&gt;</span>i_rdev <span class="token operator">=</span> dev<span class="token punctuation">;</span>
                inode<span class="token operator">-&gt;</span>i_bdev <span class="token operator">=</span> bdev<span class="token punctuation">;</span>
                inode<span class="token operator">-&gt;</span>i_data<span class="token punctuation">.</span>a_ops <span class="token operator">=</span> <span class="token operator">&amp;</span>def_blk_aops<span class="token punctuation">;</span>
                <span class="token function">mapping_set_gfp_mask</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>inode<span class="token operator">-&gt;</span>i_data<span class="token punctuation">,</span> GFP_USER<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">spin_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bdev_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">list_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bdev<span class="token operator">-&gt;</span>bd_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>all_bdevs<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bdev_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">unlock_new_inode</span><span class="token punctuation">(</span>inode<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> bdev<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>在bdget中，我们遇到了第三个文件系统，bdev伪文件系统。</strong> bdget函数根据传进来的dev_t，在blockdev_superblock这个文件系统里面找到inode。这里注意，这个inode已经不是devtmpfs文件系统的inode了。blockdev_superblock的初始化在整个系统初始化的时候，会调用bdev_cache_init进行初始化。它的定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span>blockdev_superblock __read_mostly<span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">file_system_type</span> bd_type <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span>name           <span class="token operator">=</span> <span class="token string">"bdev"</span><span class="token punctuation">,</span>
        <span class="token punctuation">.</span>mount          <span class="token operator">=</span> bd_mount<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>kill_sb        <span class="token operator">=</span> kill_anon_super<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> __init <span class="token function">bdev_cache_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">int</span> err<span class="token punctuation">;</span>
        <span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">vfsmount</span> <span class="token operator">*</span>bd_mnt<span class="token punctuation">;</span>

        bdev_cachep <span class="token operator">=</span> <span class="token function">kmem_cache_create</span><span class="token punctuation">(</span><span class="token string">"bdev_cache"</span><span class="token punctuation">,</span>
            <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">bdev_inode</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>
            <span class="token punctuation">(</span>SLAB_HWCACHE_ALIGN<span class="token operator">|</span>SLAB_RECLAIM_ACCOUNT<span class="token operator">|</span>SLAB_MEM_SPREAD<span class="token operator">|</span>SLAB_ACCOUNT<span class="token operator">|</span>SLAB_PANIC<span class="token punctuation">)</span><span class="token punctuation">,</span>
            init_once<span class="token punctuation">)</span><span class="token punctuation">;</span>
        err <span class="token operator">=</span> <span class="token function">register_filesystem</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bd_type<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span>
                <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"Cannot register bdev pseudo-fs"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        bd_mnt <span class="token operator">=</span> <span class="token function">kern_mount</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bd_type<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>bd_mnt<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"Cannot create bdev pseudo-fs"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        blockdev_superblock <span class="token operator">=</span> bd_mnt<span class="token operator">-&gt;</span>mnt_sb<span class="token punctuation">;</span>   <span class="token comment">/* For writeback */</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>所有表示块设备的inode都保存在伪文件系统 bdev中，这些对用户层不可见，主要为了方便块设备的管理。Linux将块设备的block_device和bdev文件系统的块设备的inode，通过struct bdev_inode进行关联。所以，在bdget中，BDEV_I就是通过bdev文件系统的inode，获得整个struct bdev_inode结构的地址，然后取成员bdev，得到block_device。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">bdev_inode</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">block_device</span> bdev<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">inode</span> vfs_inode<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>绕了一大圈，我们终于通过设备文件/dev/xxx，获得了设备的结构block_device。有点儿绕，我们再捋一下。设备文件/dev/xxx在devtmpfs文件系统中，找到devtmpfs文件系统中的inode，里面有dev_t。我们可以通过dev_t，在伪文件系统 bdev中找到对应的inode，然后根据struct bdev_inode找到关联的block_device。</p>
<p>接下来，blkdev_get_by_path开始做第二件事情，在找到block_device之后，要调用blkdev_get打开这个设备。blkdev_get会调用__blkdev_get。</p>
<p>在分析打开一个设备之前，我们先来看block_device这个结构是什么样的。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">block_device</span> <span class="token punctuation">{</span>
    dev_t                   bd_dev<span class="token punctuation">;</span>  <span class="token comment">/* not a kdev_t - it's a search key */</span>
    <span class="token keyword">int</span>                     bd_openers<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span>    bd_super<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">struct</span> <span class="token class-name">block_device</span> <span class="token operator">*</span>   bd_contains<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span>                bd_block_size<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">hd_struct</span> <span class="token operator">*</span>      bd_part<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span>                bd_part_count<span class="token punctuation">;</span>
    <span class="token keyword">int</span>                     bd_invalidated<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">gendisk</span> <span class="token operator">*</span>        bd_disk<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">request_queue</span> <span class="token operator">*</span>  bd_queue<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">backing_dev_info</span> <span class="token operator">*</span>bd_bdi<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>        bd_list<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>你应该能发现，这个结构和其他几个结构有着千丝万缕的联系，比较复杂。这是因为块设备本身就比较复杂。</p>
<p>比方说，我们有一个磁盘/dev/sda，我们既可以把它整个格式化成一个文件系统，也可以把它分成多个分区/dev/sda1、 /dev/sda2，然后把每个分区格式化成不同的文件系统。如果我们访问某个分区的设备文件/dev/sda2，我们应该能知道它是哪个磁盘设备的。按说它们的驱动应该是一样的。如果我们访问整个磁盘的设备文件/dev/sda，我们也应该能知道它分了几个区域，所以就有了下图这个复杂的关系结构。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/super_block结构.png" alt="super_block结构"></p>
<p>struct gendisk是用来描述整个设备的，因而上面的例子中，gendisk只有一个实例，指向/dev/sda。它的定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">gendisk</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> major<span class="token punctuation">;</span>                      <span class="token comment">/* major number of driver */</span>
    <span class="token keyword">int</span> first_minor<span class="token punctuation">;</span>
    <span class="token keyword">int</span> minors<span class="token punctuation">;</span>                     <span class="token comment">/* maximum number of minors, =1 for disks that can't be partitioned. */</span>
    <span class="token keyword">char</span> disk_name<span class="token punctuation">[</span>DISK_NAME_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">/* name of major driver */</span>
    <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>devnode<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">gendisk</span> <span class="token operator">*</span>gd<span class="token punctuation">,</span> umode_t <span class="token operator">*</span>mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">struct</span> <span class="token class-name">disk_part_tbl</span> __rcu <span class="token operator">*</span>part_tbl<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">hd_struct</span> part0<span class="token punctuation">;</span>

    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">block_device_operations</span> <span class="token operator">*</span>fops<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">request_queue</span> <span class="token operator">*</span>queue<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>private_data<span class="token punctuation">;</span>

    <span class="token keyword">int</span> flags<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">kobject</span> <span class="token operator">*</span>slave_dir<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里major是主设备号，first_minor表示第一个分区的从设备号，minors表示分区的数目。</p>
<p>disk_name给出了磁盘块设备的名称。</p>
<p>struct disk_part_tbl结构里是一个struct hd_struct的数组，用于表示各个分区。struct block_device_operations fops指向对于这个块设备的各种操作。struct request_queue queue是表示在这个块设备上的请求队列。</p>
<p>struct hd_struct是用来表示某个分区的，在上面的例子中，有两个hd_struct的实例，分别指向/dev/sda1、 /dev/sda2。它的定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">hd_struct</span> <span class="token punctuation">{</span>
    sector_t start_sect<span class="token punctuation">;</span>
    sector_t nr_sects<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">struct</span> <span class="token class-name">device</span> __dev<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">kobject</span> <span class="token operator">*</span>holder_dir<span class="token punctuation">;</span>
    <span class="token keyword">int</span> policy<span class="token punctuation">,</span> partno<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">partition_meta_info</span> <span class="token operator">*</span>info<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">struct</span> <span class="token class-name">disk_stats</span> dkstats<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">percpu_ref</span> ref<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rcu_head</span> rcu_head<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在hd_struct中，比较重要的成员变量保存了如下的信息：从磁盘的哪个扇区开始，到哪个扇区结束。</p>
<p>而block_device既可以表示整个块设备，也可以表示某个分区，所以对于上面的例子，block_device有三个实例，分别指向/dev/sda1、/dev/sda2、/dev/sda。</p>
<p>block_device的成员变量bd_disk，指向的gendisk就是整个块设备。这三个实例都指向同一个gendisk。bd_part指向的某个分区的hd_struct，bd_contains指向的是整个块设备的block_device。</p>
<p>了解了这些复杂的关系，我们再来看打开设备文件的代码，就会清晰很多。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">__blkdev_get</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">block_device</span> <span class="token operator">*</span>bdev<span class="token punctuation">,</span> fmode_t mode<span class="token punctuation">,</span> <span class="token keyword">int</span> for_part<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">gendisk</span> <span class="token operator">*</span>disk<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">module</span> <span class="token operator">*</span>owner<span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
    <span class="token keyword">int</span> partno<span class="token punctuation">;</span>
    <span class="token keyword">int</span> perm <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>mode <span class="token operator">&amp;</span> FMODE_READ<span class="token punctuation">)</span>
        perm <span class="token operator">|=</span> MAY_READ<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mode <span class="token operator">&amp;</span> FMODE_WRITE<span class="token punctuation">)</span>
        perm <span class="token operator">|=</span> MAY_WRITE<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    disk <span class="token operator">=</span> <span class="token function">get_gendisk</span><span class="token punctuation">(</span>bdev<span class="token operator">-&gt;</span>bd_dev<span class="token punctuation">,</span> <span class="token operator">&amp;</span>partno<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    owner <span class="token operator">=</span> disk<span class="token operator">-&gt;</span>fops<span class="token operator">-&gt;</span>owner<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bdev<span class="token operator">-&gt;</span>bd_openers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        bdev<span class="token operator">-&gt;</span>bd_disk <span class="token operator">=</span> disk<span class="token punctuation">;</span>
        bdev<span class="token operator">-&gt;</span>bd_queue <span class="token operator">=</span> disk<span class="token operator">-&gt;</span>queue<span class="token punctuation">;</span>
        bdev<span class="token operator">-&gt;</span>bd_contains <span class="token operator">=</span> bdev<span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>partno<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            ret <span class="token operator">=</span> <span class="token operator">-</span>ENXIO<span class="token punctuation">;</span>
            bdev<span class="token operator">-&gt;</span>bd_part <span class="token operator">=</span> <span class="token function">disk_get_part</span><span class="token punctuation">(</span>disk<span class="token punctuation">,</span> partno<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>disk<span class="token operator">-&gt;</span>fops<span class="token operator">-&gt;</span>open<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                ret <span class="token operator">=</span> disk<span class="token operator">-&gt;</span>fops<span class="token operator">-&gt;</span><span class="token function">open</span><span class="token punctuation">(</span>bdev<span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ret<span class="token punctuation">)</span>
                <span class="token function">bd_set_size</span><span class="token punctuation">(</span>bdev<span class="token punctuation">,</span><span class="token punctuation">(</span>loff_t<span class="token punctuation">)</span><span class="token function">get_capacity</span><span class="token punctuation">(</span>disk<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>bdev<span class="token operator">-&gt;</span>bd_invalidated<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ret<span class="token punctuation">)</span>
                    <span class="token function">rescan_partitions</span><span class="token punctuation">(</span>disk<span class="token punctuation">,</span> bdev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">struct</span> <span class="token class-name">block_device</span> <span class="token operator">*</span>whole<span class="token punctuation">;</span>
            whole <span class="token operator">=</span> <span class="token function">bdget_disk</span><span class="token punctuation">(</span>disk<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            ret <span class="token operator">=</span> <span class="token function">__blkdev_get</span><span class="token punctuation">(</span>whole<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            bdev<span class="token operator">-&gt;</span>bd_contains <span class="token operator">=</span> whole<span class="token punctuation">;</span>
            bdev<span class="token operator">-&gt;</span>bd_part <span class="token operator">=</span> <span class="token function">disk_get_part</span><span class="token punctuation">(</span>disk<span class="token punctuation">,</span> partno<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token function">bd_set_size</span><span class="token punctuation">(</span>bdev<span class="token punctuation">,</span> <span class="token punctuation">(</span>loff_t<span class="token punctuation">)</span>bdev<span class="token operator">-&gt;</span>bd_part<span class="token operator">-&gt;</span>nr_sects <span class="token operator">&lt;&lt;</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    bdev<span class="token operator">-&gt;</span>bd_openers<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>for_part<span class="token punctuation">)</span>
        bdev<span class="token operator">-&gt;</span>bd_part_count<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在__blkdev_get函数中，我们先调用get_gendisk，根据block_device获取gendisk。具体代码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/**
 * get_gendisk - get partitioning information for a given device
 * @devt: device to get partitioning information for
 * @partno: returned partition index
 *
 * This function gets the structure containing partitioning
 * information for the given device @devt.
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">gendisk</span> <span class="token operator">*</span><span class="token function">get_gendisk</span><span class="token punctuation">(</span>dev_t devt<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>partno<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">gendisk</span> <span class="token operator">*</span>disk <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">MAJOR</span><span class="token punctuation">(</span>devt<span class="token punctuation">)</span> <span class="token operator">!=</span> BLOCK_EXT_MAJOR<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">kobject</span> <span class="token operator">*</span>kobj<span class="token punctuation">;</span>

        kobj <span class="token operator">=</span> <span class="token function">kobj_lookup</span><span class="token punctuation">(</span>bdev_map<span class="token punctuation">,</span> devt<span class="token punctuation">,</span> partno<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>kobj<span class="token punctuation">)</span>
            disk <span class="token operator">=</span> <span class="token function">dev_to_disk</span><span class="token punctuation">(</span><span class="token function">kobj_to_dev</span><span class="token punctuation">(</span>kobj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">hd_struct</span> <span class="token operator">*</span>part<span class="token punctuation">;</span>
        part <span class="token operator">=</span> <span class="token function">idr_find</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ext_devt_idr<span class="token punctuation">,</span> <span class="token function">blk_mangle_minor</span><span class="token punctuation">(</span><span class="token function">MINOR</span><span class="token punctuation">(</span>devt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>part <span class="token operator">&amp;&amp;</span> <span class="token function">get_disk</span><span class="token punctuation">(</span><span class="token function">part_to_disk</span><span class="token punctuation">(</span>part<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token operator">*</span>partno <span class="token operator">=</span> part<span class="token operator">-&gt;</span>partno<span class="token punctuation">;</span>
            disk <span class="token operator">=</span> <span class="token function">part_to_disk</span><span class="token punctuation">(</span>part<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> disk<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们可以想象这里面有两种情况。第一种情况是，block_device是指向整个磁盘设备的。这个时候，我们只需要根据dev_t，在bdev_map中将对应的gendisk拿出来就好。</p>
<p>bdev_map是干什么的呢？前面咱们学习字符设备驱动的时候讲过，任何一个字符设备初始化的时候，都需要调用__register_chrdev_region，注册这个字符设备。对于块设备也是类似的，每一个块设备驱动初始化的时候，都会调用add_disk注册一个gendisk。</p>
<p>这里需要说明一下，<strong>gen的意思是general通用的意思</strong>，也就是说，所有的块设备，不仅仅是硬盘disk，都会用一个gendisk来表示，然后通过调用链add_disk-&gt;device_add_disk-&gt;blk_register_region，将dev_t和一个gendisk关联起来，保存在bdev_map中。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">kobj_map</span> <span class="token operator">*</span>bdev_map<span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">add_disk</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">gendisk</span> <span class="token operator">*</span>disk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">device_add_disk</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> disk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * device_add_disk - add partitioning information to kernel list
 * @parent: parent device for the disk
 * @disk: per-device partitioning information
 *
 * This function registers the partitioning information in @disk
 * with the kernel.
 */</span>
<span class="token keyword">void</span> <span class="token function">device_add_disk</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>parent<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">gendisk</span> <span class="token operator">*</span>disk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token function">blk_register_region</span><span class="token punctuation">(</span><span class="token function">disk_devt</span><span class="token punctuation">(</span>disk<span class="token punctuation">)</span><span class="token punctuation">,</span> disk<span class="token operator">-&gt;</span>minors<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span>
                exact_match<span class="token punctuation">,</span> exact_lock<span class="token punctuation">,</span> disk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token comment">/*
 * Register device numbers dev..(dev+range-1)
 * range must be nonzero
 * The hash chain is sorted on range, so that subranges can override.
 */</span>
<span class="token keyword">void</span> <span class="token function">blk_register_region</span><span class="token punctuation">(</span>dev_t devt<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> range<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">module</span> <span class="token operator">*</span>module<span class="token punctuation">,</span>
             <span class="token keyword">struct</span> <span class="token class-name">kobject</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>probe<span class="token punctuation">)</span><span class="token punctuation">(</span>dev_t<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
             <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>lock<span class="token punctuation">)</span><span class="token punctuation">(</span>dev_t<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">kobj_map</span><span class="token punctuation">(</span>bdev_map<span class="token punctuation">,</span> devt<span class="token punctuation">,</span> range<span class="token punctuation">,</span> module<span class="token punctuation">,</span> probe<span class="token punctuation">,</span> lock<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>get_gendisk要处理的第二种情况是，block_device是指向某个分区的。这个时候我们要先得到hd_struct，然后通过hd_struct，找到对应的整个设备的gendisk，并且把partno设置为分区号。</p>
<p>我们再回到__blkdev_get函数中，得到gendisk。接下来我们可以分两种情况。</p>
<p>如果partno为0，也就是说，打开的是整个设备而不是分区，那我们就调用disk_get_part，获取gendisk中的分区数组，然后调用block_device_operations里面的open函数打开设备。</p>
<p>如果partno不为0，也就是说打开的是分区，那我们就获取整个设备的block_device，赋值给变量struct block_device *whole，然后调用递归__blkdev_get，打开whole代表的整个设备，将bd_contains设置为变量whole。</p>
<p>block_device_operations就是在驱动层了。例如在drivers/scsi/sd.c里面，也就是MODULE_DESCRIPTION(“SCSI disk (sd) driver”)中，就有这样的定义。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">block_device_operations</span> sd_fops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>owner                  <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>open                   <span class="token operator">=</span> sd_open<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>release                <span class="token operator">=</span> sd_release<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>ioctl                  <span class="token operator">=</span> sd_ioctl<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>getgeo                 <span class="token operator">=</span> sd_getgeo<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_COMPAT</span></span>
    <span class="token punctuation">.</span>compat_ioctl           <span class="token operator">=</span> sd_compat_ioctl<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token punctuation">.</span>check_events           <span class="token operator">=</span> sd_check_events<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>revalidate_disk        <span class="token operator">=</span> sd_revalidate_disk<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>unlock_native_capacity <span class="token operator">=</span> sd_unlock_native_capacity<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>pr_ops                 <span class="token operator">=</span> <span class="token operator">&amp;</span>sd_pr_ops<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/**
 *  sd_open - open a scsi disk device
 *  @bdev: Block device of the scsi disk to open
 *  @mode: FMODE_* mask
 *
 *  Returns 0 if successful. Returns a negated errno value in case
 *  of error.
 **/</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sd_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">block_device</span> <span class="token operator">*</span>bdev<span class="token punctuation">,</span> fmode_t mode<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在驱动层打开了磁盘设备之后，我们可以看到，在这个过程中，block_device相应的成员变量该填的都填上了，这才完成了mount_bdev的第一件大事，通过blkdev_get_by_path得到block_device。</p>
<p>接下来就是第二件大事情，我们要通过sget，将block_device塞进superblock里面。注意，调用sget的时候，有一个参数是一个函数set_bdev_super。这里面将block_device设置进了super_block。而sget要做的，就是分配一个super_block，然后调用set_bdev_super这个callback函数。这里的super_block是ext4文件系统的super_block。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">sget</span><span class="token punctuation">(</span>fs_type<span class="token punctuation">,</span> test_bdev_super<span class="token punctuation">,</span> set_bdev_super<span class="token punctuation">,</span> flags <span class="token operator">|</span> MS_NOSEC<span class="token punctuation">,</span> bdev<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">set_bdev_super</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    s<span class="token operator">-&gt;</span>s_bdev <span class="token operator">=</span> data<span class="token punctuation">;</span>
    s<span class="token operator">-&gt;</span>s_dev <span class="token operator">=</span> s<span class="token operator">-&gt;</span>s_bdev<span class="token operator">-&gt;</span>bd_dev<span class="token punctuation">;</span>
    s<span class="token operator">-&gt;</span>s_bdi <span class="token operator">=</span> <span class="token function">bdi_get</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>s_bdev<span class="token operator">-&gt;</span>bd_bdi<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 *  sget    -   find or create a superblock
 *  @type:    filesystem type superblock should belong to
 *  @test:    comparison callback
 *  @set:     setup callback
 *  @flags:   mount flags
 *  @data:    argument to each of them
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span><span class="token function">sget</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file_system_type</span> <span class="token operator">*</span>type<span class="token punctuation">,</span>
            <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>test<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token keyword">int</span> flags<span class="token punctuation">,</span>
            <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> <span class="token function">sget_userns</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> test<span class="token punctuation">,</span> set<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> user_ns<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 *  sget_userns -   find or create a superblock
 *  @type:  filesystem type superblock should belong to
 *  @test:  comparison callback
 *  @set:   setup callback
 *  @flags: mount flags
 *  @user_ns: User namespace for the super_block
 *  @data:  argument to each of them
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span><span class="token function">sget_userns</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file_system_type</span> <span class="token operator">*</span>type<span class="token punctuation">,</span>
            <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>test<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">user_namespace</span> <span class="token operator">*</span>user_ns<span class="token punctuation">,</span>
            <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span>old<span class="token punctuation">;</span>
    <span class="token keyword">int</span> err<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        s <span class="token operator">=</span> <span class="token function">alloc_super</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> <span class="token operator">~</span>MS_SUBMOUNT<span class="token punctuation">)</span><span class="token punctuation">,</span> user_ns<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
    err <span class="token operator">=</span> <span class="token function">set</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    s<span class="token operator">-&gt;</span>s_type <span class="token operator">=</span> type<span class="token punctuation">;</span>
    <span class="token function">strlcpy</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>s_id<span class="token punctuation">,</span> type<span class="token operator">-&gt;</span>name<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>s_id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">list_add_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token operator">-&gt;</span>s_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>super_blocks<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">hlist_add_head</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token operator">-&gt;</span>s_instances<span class="token punctuation">,</span> <span class="token operator">&amp;</span>type<span class="token operator">-&gt;</span>fs_supers<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sb_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">get_filesystem</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">register_shrinker</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token operator">-&gt;</span>s_shrink<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>好了，到此为止，mount中一个块设备的过程就结束了。设备打开了，形成了block_device结构，并且塞到了super_block中。</p>
<p>有了ext4文件系统的super_block之后，接下来对于文件的读写过程，就和文件系统那一章的过程一摸一样了。只要不涉及真正写入设备的代码，super_block中的这个block_device就没啥用处。这也是为什么文件系统那一章，我们丝毫感觉不到它的存在，但是一旦到了底层，就到了block_device起作用的时候了，这个我们下一节仔细分析。</p>
<h4 id="29-2-总结"><a href="#29-2-总结" class="headerlink" title="29.2 总结"></a>29.2 总结</h4><ol>
<li>所有的块设备被一个map结构管理从dev_t到gendisk的映射；</li>
<li>所有的block_device表示的设备或者分区都在bdev文件系统的inode列表中；</li>
<li>mknod创建出来的块设备文件在devtemfs文件系统里面，特殊inode里面有块设备号；</li>
<li>mount一个块设备上的文件系统，调用这个文件系统的mount接口；</li>
<li>通过按照/dev/xxx在文件系统devtmpfs文件系统上搜索到特殊inode，得到块设备号；</li>
<li>根据特殊inode里面的dev_t在bdev文件系统里面找到inode；</li>
<li>根据bdev文件系统上的inode找到对应的block_device，根据dev_t在map中找到gendisk，将两者关联起来；</li>
<li>找到block_device后打开设备，调用和block_device关联的gendisk里面的block_device_operations打开设备；</li>
<li>创建被mount的文件系统的super_block。</li>
</ol>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/块设备打开流程总结.png" alt="块设备打开流程总结"></p>
<h3 id="30-块设备（下）"><a href="#30-块设备（下）" class="headerlink" title="30. 块设备（下）"></a>30. 块设备（下）</h3><p>在<strong>文件系统</strong>那一节，我们讲了文件的写入，到了设备驱动这一层，就没有再往下分析。上一节我们又讲了mount一个块设备，将block_device信息放到了ext4文件系统的super_block里面，有了这些基础，是时候把整个写入的故事串起来了。</p>
<p>还记得咱们在文件系统那一节分析写入流程的时候，对于ext4文件系统，最后调用的是ext4_file_write_iter，它将I/O的调用分成两种情况：</p>
<p>第一是<strong>直接I/O</strong>。最终我们调用的是generic_file_direct_write，这里调用的是mapping-&gt;a_ops-&gt;direct_IO，实际调用的是ext4_direct_IO，往设备层写入数据。</p>
<p>第二种是<strong>缓存I/O</strong>。最终我们会将数据从应用拷贝到内存缓存中，但是这个时候，并不执行真正的I/O操作。它们只将整个页或其中部分标记为脏。写操作由一个timer触发，那个时候，才调用wb_workfn往硬盘写入页面。</p>
<p>接下来的调用链为：wb_workfn-&gt;wb_do_writeback-&gt;wb_writeback-&gt;writeback_sb_inodes-&gt;__writeback_single_inode-&gt;do_writepages。在do_writepages中，我们要调用mapping-&gt;a_ops-&gt;writepages，但实际调用的是ext4_writepages，往设备层写入数据。</p>
<p>这一节，我们就沿着这两种情况分析下去。</p>
<h4 id="30-1-直接I-O如何访问块设备？"><a href="#30-1-直接I-O如何访问块设备？" class="headerlink" title="30.1 直接I/O如何访问块设备？"></a>30.1 直接I/O如何访问块设备？</h4><p>我们先来看第一种情况，直接I/O调用到ext4_direct_IO。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> ssize_t <span class="token function">ext4_direct_IO</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kiocb</span> <span class="token operator">*</span>iocb<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">iov_iter</span> <span class="token operator">*</span>iter<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file <span class="token operator">=</span> iocb<span class="token operator">-&gt;</span>ki_filp<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode <span class="token operator">=</span> file<span class="token operator">-&gt;</span>f_mapping<span class="token operator">-&gt;</span>host<span class="token punctuation">;</span>
    size_t count <span class="token operator">=</span> <span class="token function">iov_iter_count</span><span class="token punctuation">(</span>iter<span class="token punctuation">)</span><span class="token punctuation">;</span>
    loff_t offset <span class="token operator">=</span> iocb<span class="token operator">-&gt;</span>ki_pos<span class="token punctuation">;</span>
    ssize_t ret<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    ret <span class="token operator">=</span> <span class="token function">ext4_direct_IO_write</span><span class="token punctuation">(</span>iocb<span class="token punctuation">,</span> iter<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> ssize_t <span class="token function">ext4_direct_IO_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kiocb</span> <span class="token operator">*</span>iocb<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">iov_iter</span> <span class="token operator">*</span>iter<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file <span class="token operator">=</span> iocb<span class="token operator">-&gt;</span>ki_filp<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode <span class="token operator">=</span> file<span class="token operator">-&gt;</span>f_mapping<span class="token operator">-&gt;</span>host<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">ext4_inode_info</span> <span class="token operator">*</span>ei <span class="token operator">=</span> <span class="token function">EXT4_I</span><span class="token punctuation">(</span>inode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ssize_t ret<span class="token punctuation">;</span>
    loff_t offset <span class="token operator">=</span> iocb<span class="token operator">-&gt;</span>ki_pos<span class="token punctuation">;</span>
    size_t count <span class="token operator">=</span> <span class="token function">iov_iter_count</span><span class="token punctuation">(</span>iter<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    ret <span class="token operator">=</span> <span class="token function">__blockdev_direct_IO</span><span class="token punctuation">(</span>iocb<span class="token punctuation">,</span> inode<span class="token punctuation">,</span> inode<span class="token operator">-&gt;</span>i_sb<span class="token operator">-&gt;</span>s_bdev<span class="token punctuation">,</span> iter<span class="token punctuation">,</span>
                   get_block_func<span class="token punctuation">,</span> ext4_end_io_dio<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span>
                   dio_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
……
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在ext4_direct_IO_write调用__blockdev_direct_IO，有个参数你需要特别注意一下，那就是inode-&gt;i_sb-&gt;s_bdev。通过当前文件的inode，我们可以得到super_block。这个super_block中的s_bdev，就是咱们上一节填进去的那个block_device。</p>
<p>__blockdev_direct_IO会调用do_blockdev_direct_IO，在这里面我们要准备一个struct dio结构和struct dio_submit结构，用来描述将要发生的写入请求。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> ssize_t
<span class="token function">do_blockdev_direct_IO</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kiocb</span> <span class="token operator">*</span>iocb<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span>
              <span class="token keyword">struct</span> <span class="token class-name">block_device</span> <span class="token operator">*</span>bdev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">iov_iter</span> <span class="token operator">*</span>iter<span class="token punctuation">,</span>
              get_block_t get_block<span class="token punctuation">,</span> dio_iodone_t end_io<span class="token punctuation">,</span>
              dio_submit_t submit_io<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> i_blkbits <span class="token operator">=</span> <span class="token function">ACCESS_ONCE</span><span class="token punctuation">(</span>inode<span class="token operator">-&gt;</span>i_blkbits<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> blkbits <span class="token operator">=</span> i_blkbits<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> blocksize_mask <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> blkbits<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    ssize_t retval <span class="token operator">=</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
    size_t count <span class="token operator">=</span> <span class="token function">iov_iter_count</span><span class="token punctuation">(</span>iter<span class="token punctuation">)</span><span class="token punctuation">;</span>
    loff_t offset <span class="token operator">=</span> iocb<span class="token operator">-&gt;</span>ki_pos<span class="token punctuation">;</span>
    loff_t end <span class="token operator">=</span> offset <span class="token operator">+</span> count<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">dio</span> <span class="token operator">*</span>dio<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">dio_submit</span> sdio <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">buffer_head</span> map_bh <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    dio <span class="token operator">=</span> <span class="token function">kmem_cache_alloc</span><span class="token punctuation">(</span>dio_cache<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    dio<span class="token operator">-&gt;</span>flags <span class="token operator">=</span> flags<span class="token punctuation">;</span>
    dio<span class="token operator">-&gt;</span>i_size <span class="token operator">=</span> <span class="token function">i_size_read</span><span class="token punctuation">(</span>inode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    dio<span class="token operator">-&gt;</span>inode <span class="token operator">=</span> inode<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">iov_iter_rw</span><span class="token punctuation">(</span>iter<span class="token punctuation">)</span> <span class="token operator">==</span> WRITE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        dio<span class="token operator">-&gt;</span>op <span class="token operator">=</span> REQ_OP_WRITE<span class="token punctuation">;</span>
        dio<span class="token operator">-&gt;</span>op_flags <span class="token operator">=</span> REQ_SYNC <span class="token operator">|</span> REQ_IDLE<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>iocb<span class="token operator">-&gt;</span>ki_flags <span class="token operator">&amp;</span> IOCB_NOWAIT<span class="token punctuation">)</span>
            dio<span class="token operator">-&gt;</span>op_flags <span class="token operator">|=</span> REQ_NOWAIT<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        dio<span class="token operator">-&gt;</span>op <span class="token operator">=</span> REQ_OP_READ<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    sdio<span class="token punctuation">.</span>blkbits <span class="token operator">=</span> blkbits<span class="token punctuation">;</span>
    sdio<span class="token punctuation">.</span>blkfactor <span class="token operator">=</span> i_blkbits <span class="token operator">-</span> blkbits<span class="token punctuation">;</span>
    sdio<span class="token punctuation">.</span>block_in_file <span class="token operator">=</span> offset <span class="token operator">&gt;&gt;</span> blkbits<span class="token punctuation">;</span>

    sdio<span class="token punctuation">.</span>get_block <span class="token operator">=</span> get_block<span class="token punctuation">;</span>
    dio<span class="token operator">-&gt;</span>end_io <span class="token operator">=</span> end_io<span class="token punctuation">;</span>
    sdio<span class="token punctuation">.</span>submit_io <span class="token operator">=</span> submit_io<span class="token punctuation">;</span>
    sdio<span class="token punctuation">.</span>final_block_in_bio <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    sdio<span class="token punctuation">.</span>next_block_for_io <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

    dio<span class="token operator">-&gt;</span>iocb <span class="token operator">=</span> iocb<span class="token punctuation">;</span>
    dio<span class="token operator">-&gt;</span>refcount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

    sdio<span class="token punctuation">.</span>iter <span class="token operator">=</span> iter<span class="token punctuation">;</span>
    sdio<span class="token punctuation">.</span>final_block_in_request <span class="token operator">=</span>
        <span class="token punctuation">(</span>offset <span class="token operator">+</span> <span class="token function">iov_iter_count</span><span class="token punctuation">(</span>iter<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> blkbits<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    sdio<span class="token punctuation">.</span>pages_in_io <span class="token operator">+=</span> <span class="token function">iov_iter_npages</span><span class="token punctuation">(</span>iter<span class="token punctuation">,</span> INT_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>

    retval <span class="token operator">=</span> <span class="token function">do_direct_IO</span><span class="token punctuation">(</span>dio<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sdio<span class="token punctuation">,</span> <span class="token operator">&amp;</span>map_bh<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>do_direct_IO里面有两层循环，第一层循环是依次处理这次要写入的所有块。对于每一块，取出对应的内存中的页page，在这一块中，有写入的起始地址from和终止地址to，所以，第二层循环就是依次处理from到to的数据，调用submit_page_section，提交到块设备层进行写入。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">do_direct_IO</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dio</span> <span class="token operator">*</span>dio<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dio_submit</span> <span class="token operator">*</span>sdio<span class="token punctuation">,</span>
            <span class="token keyword">struct</span> <span class="token class-name">buffer_head</span> <span class="token operator">*</span>map_bh<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token keyword">unsigned</span> blkbits <span class="token operator">=</span> sdio<span class="token operator">-&gt;</span>blkbits<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">unsigned</span> i_blkbits <span class="token operator">=</span> blkbits <span class="token operator">+</span> sdio<span class="token operator">-&gt;</span>blkfactor<span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>sdio<span class="token operator">-&gt;</span>block_in_file <span class="token operator">&lt;</span> sdio<span class="token operator">-&gt;</span>final_block_in_request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>
        size_t from<span class="token punctuation">,</span> to<span class="token punctuation">;</span>

        page <span class="token operator">=</span> <span class="token function">dio_get_page</span><span class="token punctuation">(</span>dio<span class="token punctuation">,</span> sdio<span class="token punctuation">)</span><span class="token punctuation">;</span>
        from <span class="token operator">=</span> sdio<span class="token operator">-&gt;</span>head <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> sdio<span class="token operator">-&gt;</span>from<span class="token punctuation">;</span>
        to <span class="token operator">=</span> <span class="token punctuation">(</span>sdio<span class="token operator">-&gt;</span>head <span class="token operator">==</span> sdio<span class="token operator">-&gt;</span>tail <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> sdio<span class="token operator">-&gt;</span>to <span class="token operator">:</span> PAGE_SIZE<span class="token punctuation">;</span>
        sdio<span class="token operator">-&gt;</span>head<span class="token operator">++</span><span class="token punctuation">;</span>

        <span class="token keyword">while</span> <span class="token punctuation">(</span>from <span class="token operator">&lt;</span> to<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">unsigned</span> this_chunk_bytes<span class="token punctuation">;</span>  <span class="token comment">/* # of bytes mapped */</span>
            <span class="token keyword">unsigned</span> this_chunk_blocks<span class="token punctuation">;</span> <span class="token comment">/* # of blocks */</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            ret <span class="token operator">=</span> <span class="token function">submit_page_section</span><span class="token punctuation">(</span>dio<span class="token punctuation">,</span> sdio<span class="token punctuation">,</span> page<span class="token punctuation">,</span>
                          from<span class="token punctuation">,</span>
                          this_chunk_bytes<span class="token punctuation">,</span>
                          sdio<span class="token operator">-&gt;</span>next_block_for_io<span class="token punctuation">,</span>
                          map_bh<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            sdio<span class="token operator">-&gt;</span>next_block_for_io <span class="token operator">+=</span> this_chunk_blocks<span class="token punctuation">;</span>
            sdio<span class="token operator">-&gt;</span>block_in_file <span class="token operator">+=</span> this_chunk_blocks<span class="token punctuation">;</span>
            from <span class="token operator">+=</span> this_chunk_bytes<span class="token punctuation">;</span>
            dio<span class="token operator">-&gt;</span>result <span class="token operator">+=</span> this_chunk_bytes<span class="token punctuation">;</span>
            sdio<span class="token operator">-&gt;</span>blocks_available <span class="token operator">-=</span> this_chunk_blocks<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>sdio<span class="token operator">-&gt;</span>block_in_file <span class="token operator">==</span> sdio<span class="token operator">-&gt;</span>final_block_in_request<span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>submit_page_section会调用dio_bio_submit，进而调用submit_bio向块设备层提交数据。其中，参数struct bio是将数据传给块设备的通用传输对象。定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/**
 * submit_bio - submit a bio to the block device layer for I/O
 * @bio: The &amp;struct bio which describes the I/O
 */</span>
blk_qc_t <span class="token function">submit_bio</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">bio</span> <span class="token operator">*</span>bio<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> <span class="token function">generic_make_request</span><span class="token punctuation">(</span>bio<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="30-2-缓存I-O如何访问块设备？"><a href="#30-2-缓存I-O如何访问块设备？" class="headerlink" title="30.2 缓存I/O如何访问块设备？"></a>30.2 缓存I/O如何访问块设备？</h4><p>我们再来看第二种情况，缓存I/O调用到ext4_writepages。这个函数比较长，我们这里只截取最重要的部分来讲解。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ext4_writepages</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">address_space</span> <span class="token operator">*</span>mapping<span class="token punctuation">,</span>
               <span class="token keyword">struct</span> <span class="token class-name">writeback_control</span> <span class="token operator">*</span>wbc<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">struct</span> <span class="token class-name">mpage_da_data</span> mpd<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode <span class="token operator">=</span> mapping<span class="token operator">-&gt;</span>host<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">ext4_sb_info</span> <span class="token operator">*</span>sbi <span class="token operator">=</span> <span class="token function">EXT4_SB</span><span class="token punctuation">(</span>mapping<span class="token operator">-&gt;</span>host<span class="token operator">-&gt;</span>i_sb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    mpd<span class="token punctuation">.</span>do_map <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    mpd<span class="token punctuation">.</span>io_submit<span class="token punctuation">.</span>io_end <span class="token operator">=</span> <span class="token function">ext4_init_io_end</span><span class="token punctuation">(</span>inode<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ret <span class="token operator">=</span> <span class="token function">mpage_prepare_extent_to_map</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mpd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* Submit prepared bio */</span>
    <span class="token function">ext4_io_submit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mpd<span class="token punctuation">.</span>io_submit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里比较重要的一个数据结构是struct mpage_da_data。这里面有文件的inode、要写入的页的偏移量，还有一个重要的struct ext4_io_submit，里面有通用传输对象bio。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">mpage_da_data</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    pgoff_t first_page<span class="token punctuation">;</span> <span class="token comment">/* The first page to write */</span>
    pgoff_t next_page<span class="token punctuation">;</span>  <span class="token comment">/* Current page to examine */</span>
    pgoff_t last_page<span class="token punctuation">;</span>  <span class="token comment">/* Last page to examine */</span>
    <span class="token keyword">struct</span> <span class="token class-name">ext4_map_blocks</span> map<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">ext4_io_submit</span> io_submit<span class="token punctuation">;</span>    <span class="token comment">/* IO submission data */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> do_map<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">ext4_io_submit</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">struct</span> <span class="token class-name">bio</span>      <span class="token operator">*</span>io_bio<span class="token punctuation">;</span>
    ext4_io_end_t       <span class="token operator">*</span>io_end<span class="token punctuation">;</span>
    sector_t        io_next_block<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在ext4_writepages中，mpage_prepare_extent_to_map用于初始化这个struct mpage_da_data结构。接下来的调用链为：mpage_prepare_extent_to_map-&gt;mpage_process_page_bufs-&gt;mpage_submit_page-&gt;ext4_bio_write_page-&gt;io_submit_add_bh。</p>
<p>在io_submit_add_bh中，此时的bio还是空的，因而我们要调用io_submit_init_bio，初始化bio。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">io_submit_init_bio</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ext4_io_submit</span> <span class="token operator">*</span>io<span class="token punctuation">,</span>
                  <span class="token keyword">struct</span> <span class="token class-name">buffer_head</span> <span class="token operator">*</span>bh<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">bio</span> <span class="token operator">*</span>bio<span class="token punctuation">;</span>

    bio <span class="token operator">=</span> <span class="token function">bio_alloc</span><span class="token punctuation">(</span>GFP_NOIO<span class="token punctuation">,</span> BIO_MAX_PAGES<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bio<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>ENOMEM<span class="token punctuation">;</span>
    <span class="token function">wbc_init_bio</span><span class="token punctuation">(</span>io<span class="token operator">-&gt;</span>io_wbc<span class="token punctuation">,</span> bio<span class="token punctuation">)</span><span class="token punctuation">;</span>
    bio<span class="token operator">-&gt;</span>bi_iter<span class="token punctuation">.</span>bi_sector <span class="token operator">=</span> bh<span class="token operator">-&gt;</span>b_blocknr <span class="token operator">*</span> <span class="token punctuation">(</span>bh<span class="token operator">-&gt;</span>b_size <span class="token operator">&gt;&gt;</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    bio<span class="token operator">-&gt;</span>bi_bdev <span class="token operator">=</span> bh<span class="token operator">-&gt;</span>b_bdev<span class="token punctuation">;</span>
    bio<span class="token operator">-&gt;</span>bi_end_io <span class="token operator">=</span> ext4_end_bio<span class="token punctuation">;</span>
    bio<span class="token operator">-&gt;</span>bi_private <span class="token operator">=</span> <span class="token function">ext4_get_io_end</span><span class="token punctuation">(</span>io<span class="token operator">-&gt;</span>io_end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    io<span class="token operator">-&gt;</span>io_bio <span class="token operator">=</span> bio<span class="token punctuation">;</span>
    io<span class="token operator">-&gt;</span>io_next_block <span class="token operator">=</span> bh<span class="token operator">-&gt;</span>b_blocknr<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们再回到ext4_writepages中。在bio初始化完之后，我们要调用ext4_io_submit，提交I/O。在这里我们又是调用submit_bio，向块设备层传输数据。ext4_io_submit的实现如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">ext4_io_submit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ext4_io_submit</span> <span class="token operator">*</span>io<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">bio</span> <span class="token operator">*</span>bio <span class="token operator">=</span> io<span class="token operator">-&gt;</span>io_bio<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>bio<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> io_op_flags <span class="token operator">=</span> io<span class="token operator">-&gt;</span>io_wbc<span class="token operator">-&gt;</span>sync_mode <span class="token operator">==</span> WB_SYNC_ALL <span class="token operator">?</span>
                  REQ_SYNC <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
        io<span class="token operator">-&gt;</span>io_bio<span class="token operator">-&gt;</span>bi_write_hint <span class="token operator">=</span> io<span class="token operator">-&gt;</span>io_end<span class="token operator">-&gt;</span>inode<span class="token operator">-&gt;</span>i_write_hint<span class="token punctuation">;</span>
        <span class="token function">bio_set_op_attrs</span><span class="token punctuation">(</span>io<span class="token operator">-&gt;</span>io_bio<span class="token punctuation">,</span> REQ_OP_WRITE<span class="token punctuation">,</span> io_op_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">submit_bio</span><span class="token punctuation">(</span>io<span class="token operator">-&gt;</span>io_bio<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    io<span class="token operator">-&gt;</span>io_bio <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="30-3-如何向块设备层提交请求？"><a href="#30-3-如何向块设备层提交请求？" class="headerlink" title="30.3 如何向块设备层提交请求？"></a>30.3 如何向块设备层提交请求？</h4><p>既然无论是直接I/O，还是缓存I/O，最后都到了submit_bio里面，我们就来重点分析一下它。</p>
<p>submit_bio会调用generic_make_request。代码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">blk_qc_t <span class="token function">generic_make_request</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">bio</span> <span class="token operator">*</span>bio<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">/*
     * bio_list_on_stack[0] contains bios submitted by the current
     * make_request_fn.
     * bio_list_on_stack[1] contains bios that were submitted before
     * the current make_request_fn, but that haven't been processed
     * yet.
     */</span>
    <span class="token keyword">struct</span> <span class="token class-name">bio_list</span> bio_list_on_stack<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    blk_qc_t ret <span class="token operator">=</span> BLK_QC_T_NONE<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token operator">-&gt;</span>bio_list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">bio_list_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>current<span class="token operator">-&gt;</span>bio_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> bio<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> out<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">bio_list_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bio_list_on_stack<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    current<span class="token operator">-&gt;</span>bio_list <span class="token operator">=</span> bio_list_on_stack<span class="token punctuation">;</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">request_queue</span> <span class="token operator">*</span>q <span class="token operator">=</span> <span class="token function">bdev_get_queue</span><span class="token punctuation">(</span>bio<span class="token operator">-&gt;</span>bi_bdev<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token function">blk_queue_enter</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> bio<span class="token operator">-&gt;</span>bi_opf <span class="token operator">&amp;</span> REQ_NOWAIT<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">struct</span> <span class="token class-name">bio_list</span> lower<span class="token punctuation">,</span> same<span class="token punctuation">;</span>

            <span class="token comment">/* Create a fresh bio_list for all subordinate requests */</span>
            bio_list_on_stack<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> bio_list_on_stack<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token function">bio_list_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bio_list_on_stack<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            ret <span class="token operator">=</span> q<span class="token operator">-&gt;</span><span class="token function">make_request_fn</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> bio<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token function">blk_queue_exit</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">/* sort new bios into those for a lower level
             * and those for the same level
             */</span>
            <span class="token function">bio_list_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lower<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">bio_list_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>same<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bio <span class="token operator">=</span> <span class="token function">bio_list_pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bio_list_on_stack<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">==</span> <span class="token function">bdev_get_queue</span><span class="token punctuation">(</span>bio<span class="token operator">-&gt;</span>bi_bdev<span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token function">bio_list_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>same<span class="token punctuation">,</span> bio<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span>
                    <span class="token function">bio_list_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lower<span class="token punctuation">,</span> bio<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">/* now assemble so we handle the lowest level first */</span>
            <span class="token function">bio_list_merge</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bio_list_on_stack<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>lower<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">bio_list_merge</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bio_list_on_stack<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>same<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">bio_list_merge</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bio_list_on_stack<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>bio_list_on_stack<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        bio <span class="token operator">=</span> <span class="token function">bio_list_pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bio_list_on_stack<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>bio<span class="token punctuation">)</span><span class="token punctuation">;</span>
    current<span class="token operator">-&gt;</span>bio_list <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">/* deactivate */</span>
out<span class="token operator">:</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里的逻辑有点复杂，我们先来看大的逻辑。在do-while中，我们先是获取一个请求队列request_queue，然后调用这个队列的make_request_fn函数。</p>
<h4 id="30-4-块设备队列结构"><a href="#30-4-块设备队列结构" class="headerlink" title="30.4 块设备队列结构"></a>30.4 块设备队列结构</h4><p>如果再来看struct block_device结构和struct gendisk结构，我们会发现，每个块设备都有一个请求队列struct request_queue，用于处理上层发来的请求。</p>
<p>在每个块设备的驱动程序初始化的时候，会生成一个request_queue。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">request_queue</span> <span class="token punctuation">{</span>
    <span class="token comment">/*
     * Together with queue_head for cacheline sharing
     */</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>        queue_head<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">request</span>          <span class="token operator">*</span>last_merge<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">elevator_queue</span>   <span class="token operator">*</span>elevator<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    request_fn_proc         <span class="token operator">*</span>request_fn<span class="token punctuation">;</span>
    make_request_fn         <span class="token operator">*</span>make_request_fn<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在请求队列request_queue上，首先是有一个链表list_head，保存请求request。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">request</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> queuelist<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">struct</span> <span class="token class-name">request_queue</span> <span class="token operator">*</span>q<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">struct</span> <span class="token class-name">bio</span> <span class="token operator">*</span>bio<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">bio</span> <span class="token operator">*</span>biotail<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>每个request包括一个链表的struct bio，有指针指向一头一尾。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">bio</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">bio</span>          <span class="token operator">*</span>bi_next<span class="token punctuation">;</span>   <span class="token comment">/* request queue link */</span>
    <span class="token keyword">struct</span> <span class="token class-name">block_device</span> <span class="token operator">*</span>bi_bdev<span class="token punctuation">;</span>
    blk_status_t        bi_status<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">struct</span> <span class="token class-name">bvec_iter</span>    bi_iter<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">short</span>      bi_vcnt<span class="token punctuation">;</span>    <span class="token comment">/* how many bio_vec's */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">short</span>      bi_max_vecs<span class="token punctuation">;</span>    <span class="token comment">/* max bvl_vecs we can hold */</span>
    atomic_t            __bi_cnt<span class="token punctuation">;</span>   <span class="token comment">/* pin count */</span>
    <span class="token keyword">struct</span> <span class="token class-name">bio_vec</span>      <span class="token operator">*</span>bi_io_vec<span class="token punctuation">;</span> <span class="token comment">/* the actual vec list */</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">bio_vec</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">page</span>     <span class="token operator">*</span>bv_page<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>    bv_len<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>    bv_offset<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在bio中，bi_next是链表中的下一项，struct bio_vec指向一组页面。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/bio结构体.jpeg" alt="bio结构体"></p>
<p>在请求队列request_queue上，还有两个重要的函数，一个是make_request_fn函数，用于生成request；另一个是request_fn函数，用于处理request。</p>
<h4 id="30-5-块设备的初始化"><a href="#30-5-块设备的初始化" class="headerlink" title="30.5 块设备的初始化"></a>30.5 块设备的初始化</h4><p>我们还是以scsi驱动为例。在初始化设备驱动的时候，我们会调用scsi_alloc_queue，把request_fn设置为scsi_request_fn。我们还会调用blk_init_allocated_queue-&gt;blk_queue_make_request，把make_request_fn设置为blk_queue_bio。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/**
 * scsi_alloc_sdev - allocate and setup a scsi_Device
 * @starget: which target to allocate a &amp;scsi_device for
 * @lun: which lun
 * @hostdata: usually NULL and set by -&gt;slave_alloc instead
 *
 * Description:
 *     Allocate, initialize for io, and return a pointer to a scsi_Device.
 *     Stores the @shost, @channel, @id, and @lun in the scsi_Device, and
 *     adds scsi_Device to the appropriate list.
 *
 * Return value:
 *     scsi_Device pointer, or NULL on failure.
 **/</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">scsi_device</span> <span class="token operator">*</span><span class="token function">scsi_alloc_sdev</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">scsi_target</span> <span class="token operator">*</span>starget<span class="token punctuation">,</span>
                       u64 lun<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>hostdata<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">scsi_device</span> <span class="token operator">*</span>sdev<span class="token punctuation">;</span>
    sdev <span class="token operator">=</span> <span class="token function">kzalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>sdev<span class="token punctuation">)</span> <span class="token operator">+</span> shost<span class="token operator">-&gt;</span>transportt<span class="token operator">-&gt;</span>device_size<span class="token punctuation">,</span>
               GFP_ATOMIC<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    sdev<span class="token operator">-&gt;</span>request_queue <span class="token operator">=</span> <span class="token function">scsi_alloc_queue</span><span class="token punctuation">(</span>sdev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">request_queue</span> <span class="token operator">*</span><span class="token function">scsi_alloc_queue</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">scsi_device</span> <span class="token operator">*</span>sdev<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">Scsi_Host</span> <span class="token operator">*</span>shost <span class="token operator">=</span> sdev<span class="token operator">-&gt;</span>host<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">request_queue</span> <span class="token operator">*</span>q<span class="token punctuation">;</span>

    q <span class="token operator">=</span> <span class="token function">blk_alloc_queue_node</span><span class="token punctuation">(</span>GFP_KERNEL<span class="token punctuation">,</span> NUMA_NO_NODE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    q<span class="token operator">-&gt;</span>cmd_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">scsi_cmnd</span><span class="token punctuation">)</span> <span class="token operator">+</span> shost<span class="token operator">-&gt;</span>hostt<span class="token operator">-&gt;</span>cmd_size<span class="token punctuation">;</span>
    q<span class="token operator">-&gt;</span>rq_alloc_data <span class="token operator">=</span> shost<span class="token punctuation">;</span>
    q<span class="token operator">-&gt;</span>request_fn <span class="token operator">=</span> scsi_request_fn<span class="token punctuation">;</span>
    q<span class="token operator">-&gt;</span>init_rq_fn <span class="token operator">=</span> scsi_init_rq<span class="token punctuation">;</span>
    q<span class="token operator">-&gt;</span>exit_rq_fn <span class="token operator">=</span> scsi_exit_rq<span class="token punctuation">;</span>
    q<span class="token operator">-&gt;</span>initialize_rq_fn <span class="token operator">=</span> scsi_initialize_rq<span class="token punctuation">;</span>

    <span class="token comment">//调用blk_queue_make_request(q, blk_queue_bio);</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">blk_init_allocated_queue</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">blk_cleanup_queue</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">__scsi_init_queue</span><span class="token punctuation">(</span>shost<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> q
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在blk_init_allocated_queue中，除了初始化make_request_fn函数，我们还要做一件很重要的事情，就是初始化I/O的电梯算法。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">blk_init_allocated_queue</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">request_queue</span> <span class="token operator">*</span>q<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    q<span class="token operator">-&gt;</span>fq <span class="token operator">=</span> <span class="token function">blk_alloc_flush_queue</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> NUMA_NO_NODE<span class="token punctuation">,</span> q<span class="token operator">-&gt;</span>cmd_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">blk_queue_make_request</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> blk_queue_bio<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* init elevator */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">elevator_init</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>电梯算法有很多种类型，定义为elevator_type。下面我来逐一说一下。</p>
<ol>
<li><p>struct elevator_type elevator_noop</p>
<p> Noop调度算法是最简单的IO调度算法，它将IO请求放入到一个FIFO队列中，然后逐个执行这些IO请求。</p>
</li>
<li><p>struct elevator_type iosched_deadline</p>
<p> Deadline算法要保证每个IO请求在一定的时间内一定要被服务到，以此来避免某个请求饥饿。为了完成这个目标，算法中引入了两类队列，一类队列用来对请求按起始扇区序号进行排序，通过红黑树来组织，我们称为sort_list，按照此队列传输性能会比较高；另一类队列对请求按它们的生成时间进行排序，由链表来组织，称为fifo_list，并且每一个请求都有一个期限值。</p>
</li>
<li><p>struct elevator_type iosched_cfq</p>
<p> 又看到了熟悉的CFQ完全公平调度算法。所有的请求会在多个队列中排序。同一个进程的请求，总是在同一队列中处理。时间片会分配到每个队列，通过轮询算法，我们保证了I/O带宽，以公平的方式，在不同队列之间进行共享。</p>
</li>
</ol>
<p>elevator_init中会根据名称来指定电梯算法，如果没有选择，那就默认使用iosched_cfq。</p>
<h4 id="30-6-请求提交与调度"><a href="#30-6-请求提交与调度" class="headerlink" title="30.6 请求提交与调度"></a>30.6 请求提交与调度</h4><p>接下来，我们回到generic_make_request函数中。调用队列的make_request_fn函数，其实就是调用blk_queue_bio。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> blk_qc_t <span class="token function">blk_queue_bio</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">request_queue</span> <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">bio</span> <span class="token operator">*</span>bio<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">request</span> <span class="token operator">*</span>req<span class="token punctuation">,</span> <span class="token operator">*</span>free<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> request_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token function">elv_merge</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> <span class="token operator">&amp;</span>req<span class="token punctuation">,</span> bio<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> ELEVATOR_BACK_MERGE<span class="token operator">:</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">bio_attempt_back_merge</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> req<span class="token punctuation">,</span> bio<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token function">elv_bio_merged</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> req<span class="token punctuation">,</span> bio<span class="token punctuation">)</span><span class="token punctuation">;</span>
        free <span class="token operator">=</span> <span class="token function">attempt_back_merge</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> req<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>free<span class="token punctuation">)</span>
            <span class="token function">__blk_put_request</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> free<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token function">elv_merged_request</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> req<span class="token punctuation">,</span> ELEVATOR_BACK_MERGE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> out_unlock<span class="token punctuation">;</span>
    <span class="token keyword">case</span> ELEVATOR_FRONT_MERGE<span class="token operator">:</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">bio_attempt_front_merge</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> req<span class="token punctuation">,</span> bio<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token function">elv_bio_merged</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> req<span class="token punctuation">,</span> bio<span class="token punctuation">)</span><span class="token punctuation">;</span>
        free <span class="token operator">=</span> <span class="token function">attempt_front_merge</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> req<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>free<span class="token punctuation">)</span>
            <span class="token function">__blk_put_request</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> free<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token function">elv_merged_request</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> req<span class="token punctuation">,</span> ELEVATOR_FRONT_MERGE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> out_unlock<span class="token punctuation">;</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

get_rq<span class="token operator">:</span>
    req <span class="token operator">=</span> <span class="token function">get_request</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> bio<span class="token operator">-&gt;</span>bi_opf<span class="token punctuation">,</span> bio<span class="token punctuation">,</span> GFP_NOIO<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">blk_init_request_from_bio</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> bio<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">add_acct_request</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> req<span class="token punctuation">,</span> where<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">__blk_run_queue</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
out_unlock<span class="token operator">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> BLK_QC_T_NONE<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>blk_queue_bio首先做的一件事情是调用elv_merge来判断，当前这个bio请求是否能够和目前已有的request合并起来，成为同一批I/O操作，从而提高读取和写入的性能。</p>
<p>判断标准和struct bio的成员struct bvec_iter有关，它里面有两个变量，一个是起始磁盘簇bi_sector，另一个是大小bi_size。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span> <span class="token class-name">elv_merge</span> <span class="token function">elv_merge</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">request_queue</span> <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">request</span> <span class="token operator">*</span><span class="token operator">*</span>req<span class="token punctuation">,</span>
        <span class="token keyword">struct</span> <span class="token class-name">bio</span> <span class="token operator">*</span>bio<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">elevator_queue</span> <span class="token operator">*</span>e <span class="token operator">=</span> q<span class="token operator">-&gt;</span>elevator<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">request</span> <span class="token operator">*</span>__rq<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token operator">-&gt;</span>last_merge <span class="token operator">&amp;&amp;</span> <span class="token function">elv_bio_merge_ok</span><span class="token punctuation">(</span>q<span class="token operator">-&gt;</span>last_merge<span class="token punctuation">,</span> bio<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">enum</span> <span class="token class-name">elv_merge</span> ret <span class="token operator">=</span> <span class="token function">blk_try_merge</span><span class="token punctuation">(</span>q<span class="token operator">-&gt;</span>last_merge<span class="token punctuation">,</span> bio<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">!=</span> ELEVATOR_NO_MERGE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token operator">*</span>req <span class="token operator">=</span> q<span class="token operator">-&gt;</span>last_merge<span class="token punctuation">;</span>
            <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    __rq <span class="token operator">=</span> <span class="token function">elv_rqhash_find</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> bio<span class="token operator">-&gt;</span>bi_iter<span class="token punctuation">.</span>bi_sector<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>__rq <span class="token operator">&amp;&amp;</span> <span class="token function">elv_bio_merge_ok</span><span class="token punctuation">(</span>__rq<span class="token punctuation">,</span> bio<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">*</span>req <span class="token operator">=</span> __rq<span class="token punctuation">;</span>
        <span class="token keyword">return</span> ELEVATOR_BACK_MERGE<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">-&gt;</span>uses_mq <span class="token operator">&amp;&amp;</span> e<span class="token operator">-&gt;</span>type<span class="token operator">-&gt;</span>ops<span class="token punctuation">.</span>mq<span class="token punctuation">.</span>request_merge<span class="token punctuation">)</span>
        <span class="token keyword">return</span> e<span class="token operator">-&gt;</span>type<span class="token operator">-&gt;</span>ops<span class="token punctuation">.</span>mq<span class="token punctuation">.</span><span class="token function">request_merge</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> req<span class="token punctuation">,</span> bio<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>e<span class="token operator">-&gt;</span>uses_mq <span class="token operator">&amp;&amp;</span> e<span class="token operator">-&gt;</span>type<span class="token operator">-&gt;</span>ops<span class="token punctuation">.</span>sq<span class="token punctuation">.</span>elevator_merge_fn<span class="token punctuation">)</span>
        <span class="token keyword">return</span> e<span class="token operator">-&gt;</span>type<span class="token operator">-&gt;</span>ops<span class="token punctuation">.</span>sq<span class="token punctuation">.</span><span class="token function">elevator_merge_fn</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> req<span class="token punctuation">,</span> bio<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> ELEVATOR_NO_MERGE<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>第一次，它先判断和上一次合并的request能不能再次合并，看看能不能赶上马上要走的这部电梯。在blk_try_merge主要做了这样的判断：如果blk_rq_pos(rq) + blk_rq_sectors(rq) == bio-&gt;bi_iter.bi_sector，也就是说这个request的起始地址加上它的大小（其实是这个request的结束地址），如果和bio的起始地址能接得上，那就把bio放在request的最后，我们称为ELEVATOR_BACK_MERGE。</p>
<p>如果blk_rq_pos(rq) - bio_sectors(bio) == bio-&gt;bi_iter.bi_sector，也就是说，这个request的起始地址减去bio的大小等于bio的起始地址，这说明bio放在request的最前面能够接得上，那就把bio放在request的最前面，我们称为ELEVATOR_FRONT_MERGE。否则，那就不合并，我们称为ELEVATOR_NO_MERGE。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span> <span class="token class-name">elv_merge</span> <span class="token function">blk_try_merge</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">request</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">bio</span> <span class="token operator">*</span>bio<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">blk_rq_pos</span><span class="token punctuation">(</span>rq<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">blk_rq_sectors</span><span class="token punctuation">(</span>rq<span class="token punctuation">)</span> <span class="token operator">==</span> bio<span class="token operator">-&gt;</span>bi_iter<span class="token punctuation">.</span>bi_sector<span class="token punctuation">)</span>
        <span class="token keyword">return</span> ELEVATOR_BACK_MERGE<span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">blk_rq_pos</span><span class="token punctuation">(</span>rq<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">bio_sectors</span><span class="token punctuation">(</span>bio<span class="token punctuation">)</span> <span class="token operator">==</span> bio<span class="token operator">-&gt;</span>bi_iter<span class="token punctuation">.</span>bi_sector<span class="token punctuation">)</span>
        <span class="token keyword">return</span> ELEVATOR_FRONT_MERGE<span class="token punctuation">;</span>
    <span class="token keyword">return</span> ELEVATOR_NO_MERGE<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>第二次，如果和上一个合并过的request无法合并，那我们就调用elv_rqhash_find。然后按照bio的起始地址查找request，看有没有能够合并的。如果有的话，因为是按照起始地址找的，应该接在人家的后面，所以是ELEVATOR_BACK_MERGE。</p>
<p>第三次，调用elevator_merge_fn试图合并。对于iosched_cfq，调用的是cfq_merge。在这里面，cfq_find_rq_fmerge会调用elv_rb_find函数，里面的参数是bio的结束地址。我们还是要看，能不能找到可以合并的。如果有的话，因为是按照结束地址找的，应该接在人家前面，所以是ELEVATOR_FRONT_MERGE。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">enum</span> <span class="token class-name">elv_merge</span> <span class="token function">cfq_merge</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">request_queue</span> <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">request</span> <span class="token operator">*</span><span class="token operator">*</span>req<span class="token punctuation">,</span>
             <span class="token keyword">struct</span> <span class="token class-name">bio</span> <span class="token operator">*</span>bio<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">cfq_data</span> <span class="token operator">*</span>cfqd <span class="token operator">=</span> q<span class="token operator">-&gt;</span>elevator<span class="token operator">-&gt;</span>elevator_data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">request</span> <span class="token operator">*</span>__rq<span class="token punctuation">;</span>

    __rq <span class="token operator">=</span> <span class="token function">cfq_find_rq_fmerge</span><span class="token punctuation">(</span>cfqd<span class="token punctuation">,</span> bio<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>__rq <span class="token operator">&amp;&amp;</span> <span class="token function">elv_bio_merge_ok</span><span class="token punctuation">(</span>__rq<span class="token punctuation">,</span> bio<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">*</span>req <span class="token operator">=</span> __rq<span class="token punctuation">;</span>
        <span class="token keyword">return</span> ELEVATOR_FRONT_MERGE<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> ELEVATOR_NO_MERGE<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">request</span> <span class="token operator">*</span>
<span class="token function">cfq_find_rq_fmerge</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cfq_data</span> <span class="token operator">*</span>cfqd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">bio</span> <span class="token operator">*</span>bio<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk <span class="token operator">=</span> current<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">cfq_io_cq</span> <span class="token operator">*</span>cic<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">cfq_queue</span> <span class="token operator">*</span>cfqq<span class="token punctuation">;</span>

    cic <span class="token operator">=</span> <span class="token function">cfq_cic_lookup</span><span class="token punctuation">(</span>cfqd<span class="token punctuation">,</span> tsk<span class="token operator">-&gt;</span>io_context<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cic<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

    cfqq <span class="token operator">=</span> <span class="token function">cic_to_cfqq</span><span class="token punctuation">(</span>cic<span class="token punctuation">,</span> <span class="token function">op_is_sync</span><span class="token punctuation">(</span>bio<span class="token operator">-&gt;</span>bi_opf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cfqq<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">elv_rb_find</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cfqq<span class="token operator">-&gt;</span>sort_list<span class="token punctuation">,</span> <span class="token function">bio_end_sector</span><span class="token punctuation">(</span>bio<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> NUL
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>等从elv_merge返回blk_queue_bio的时候，我们就知道，应该做哪种类型的合并，接着就要进行真的合并。如果没有办法合并，那就调用get_request，创建一个新的request，调用blk_init_request_from_bio，将bio放到新的request里面，然后调用add_acct_request，把新的request加到request_queue队列中。</p>
<p>至此，我们解析完了generic_make_request中最重要的两大逻辑：获取一个请求队列request_queue和调用这个队列的make_request_fn函数。</p>
<p>其实，generic_make_request其他部分也很令人困惑。感觉里面有特别多的struct bio_list，倒腾过来，倒腾过去的。这是因为，很多块设备是有层次的。</p>
<p>比如，我们用两块硬盘组成RAID，两个RAID盘组成LVM，然后我们就可以在LVM上创建一个块设备给用户用，我们称接近用户的块设备为<strong>高层次的块设备</strong>，接近底层的块设备为<strong>低层次（lower）的块设备</strong>。这样，generic_make_request把I/O请求发送给高层次的块设备的时候，会调用高层块设备的make_request_fn，高层块设备又要调用generic_make_request，将请求发送给低层次的块设备。虽然块设备的层次不会太多，但是对于代码generic_make_request来讲，这可是递归的调用，一不小心，就会递归过深，无法正常退出，而且内核栈的大小又非常有限，所以要比较小心。</p>
<p>这里你是否理解了struct bio_list bio_list_on_stack[2]的名字为什么叫stack呢？其实，将栈的操作变成对于队列的操作，队列不在栈里面，会大很多。每次generic_make_request被当前任务调用的时候，将current-&gt;bio_list设置为bio_list_on_stack，并在generic_make_request的一开始就判断current-&gt;bio_list是否为空。如果不为空，说明已经在generic_make_request的调用里面了，就不必调用make_request_fn进行递归了，直接把请求加入到bio_list里面就可以了，这就实现了递归的及时退出。</p>
<p>如果current-&gt;bio_list为空，那我们就将current-&gt;bio_list设置为bio_list_on_stack后，进入do-while循环，做咱们分析过的generic_make_request的两大逻辑。但是，当前的队列调用make_request_fn的时候，在make_request_fn的具体实现中，会生成新的bio。调用更底层的块设备，也会生成新的bio，都会放在bio_list_on_stack的队列中，是一个边处理还边创建的过程。</p>
<p>bio_list_on_stack[1] = bio_list_on_stack[0]这一句在make_request_fn之前，将之前队列里面遗留没有处理的保存下来，接着bio_list_init将bio_list_on_stack[0]设置为空，然后调用make_request_fn，在make_request_fn里面如果有新的bio生成，都会加到bio_list_on_stack[0]这个队列里面来。</p>
<p>make_request_fn执行完毕后，可以想象bio_list_on_stack[0]可能又多了一些bio了，接下来的循环中调用bio_list_pop将bio_list_on_stack[0]积攒的bio拿出来，分别放在两个队列lower和same中，顾名思义，lower就是更低层次的块设备的bio，same是同层次的块设备的bio。</p>
<p>接下来我们能将lower、same以及bio_list_on_stack[1] 都取出来，放在bio_list_on_stack[0]统一进行处理。当然应该lower优先了，因为只有底层的块设备的I/O做完了，上层的块设备的I/O才能做完。</p>
<p>到这里，generic_make_request的逻辑才算解析完毕。对于写入的数据来讲，其实仅仅到将bio请求放在请求队列上，设备驱动程序还没往设备里面写呢。</p>
<h4 id="30-7-请求的处理"><a href="#30-7-请求的处理" class="headerlink" title="30.7 请求的处理"></a>30.7 请求的处理</h4><p>设备驱动程序往设备里面写，调用的是请求队列request_queue的另外一个函数request_fn。对于scsi设备来讲，调用的是scsi_request_fn。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">scsi_request_fn</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">request_queue</span> <span class="token operator">*</span>q<span class="token punctuation">)</span>
    <span class="token function">__releases</span><span class="token punctuation">(</span>q<span class="token operator">-&gt;</span>queue_lock<span class="token punctuation">)</span>
    <span class="token function">__acquires</span><span class="token punctuation">(</span>q<span class="token operator">-&gt;</span>queue_lock<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">scsi_device</span> <span class="token operator">*</span>sdev <span class="token operator">=</span> q<span class="token operator">-&gt;</span>queuedata<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">Scsi_Host</span> <span class="token operator">*</span>shost<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">scsi_cmnd</span> <span class="token operator">*</span>cmd<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">request</span> <span class="token operator">*</span>req<span class="token punctuation">;</span>

    <span class="token comment">/*
     * To start with, we keep looping until the queue is empty, or until
     * the host is no longer able to accept any more requests.
     */</span>
    shost <span class="token operator">=</span> sdev<span class="token operator">-&gt;</span>host<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> rtn<span class="token punctuation">;</span>
        <span class="token comment">/*
         * get next queueable request.  We do this early to make sure
         * that the request is fully prepared even if we cannot
         * accept it.
         */</span>
        req <span class="token operator">=</span> <span class="token function">blk_peek_request</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token comment">/*
         * Remove the request from the request list.
         */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token function">blk_queue_tagged</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">blk_queue_start_tag</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> req<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token function">blk_start_request</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        cmd <span class="token operator">=</span> req<span class="token operator">-&gt;</span>special<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token comment">/*
         * Dispatch the command to the low-level driver.
         */</span>
        cmd<span class="token operator">-&gt;</span>scsi_done <span class="token operator">=</span> scsi_done<span class="token punctuation">;</span>
        rtn <span class="token operator">=</span> <span class="token function">scsi_dispatch_cmd</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里面是一个for无限循环，从request_queue中读取request，然后封装更加底层的指令，给设备控制器下指令，实施真正的I/O操作。</p>
<h4 id="30-8-总结"><a href="#30-8-总结" class="headerlink" title="30.8 总结"></a>30.8 总结</h4><p>对于块设备的I/O操作分为两种，一种是直接I/O，另一种是缓存I/O。无论是哪种I/O，最终都会调用submit_bio提交块设备I/O请求。</p>
<p>对于每一种块设备，都有一个gendisk表示这个设备，它有一个请求队列，这个队列是一系列的request对象。每个request对象里面包含多个BIO对象，指向page cache。所谓的写入块设备，I/O就是将page cache里面的数据写入硬盘。</p>
<p>对于请求队列来讲，还有两个函数，一个函数叫make_request_fn函数，用于将请求放入队列。submit_bio会调用generic_make_request，然后调用这个函数。</p>
<p>另一个函数往往在设备驱动程序里实现，我们叫request_fn函数，它用于从队列里面取出请求来，写入外部设备。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/块设备写入时的request.png" alt="块设备写入时的request"></p>
<h2 id="六、进程间通信"><a href="#六、进程间通信" class="headerlink" title="六、进程间通信"></a>六、进程间通信</h2><h3 id="31-进程间通信"><a href="#31-进程间通信" class="headerlink" title="31. 进程间通信"></a>31. 进程间通信</h3><h4 id="31-1-管道模型"><a href="#31-1-管道模型" class="headerlink" title="31.1 管道模型"></a>31.1 管道模型</h4><p>最最传统的模型就是软件开发的瀑布模型（Waterfall Model）。所谓的瀑布模型，其实就是将整个软件开发过程分成多个阶段，往往是上一个阶段完全做完，才将输出结果交给下一个阶段。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/瀑布模型.png" alt="瀑布模型"></p>
<p>这种模型类似进程间通信的<strong>管道模型</strong>。还记得咱们最初学Linux命令的时候，有下面这样一行命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> -ef <span class="token operator">|</span> <span class="token function">grep</span> 关键字 <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print <span class="token variable">$2</span>}'</span> <span class="token operator">|</span> <span class="token function">xargs</span> <span class="token function">kill</span> -9<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这里面的竖线“|”就是一个管道。它会将前一个命令的输出，作为后一个命令的输入。从管道的这个名称可以看出来，管道是一种单向传输数据的机制，它其实是一段缓存，里面的数据只能从一端写入，从另一端读出。如果想互相通信，我们需要创建两个管道才行。</p>
<p>管道分为两种类型，“|” 表示的管道称为<strong>匿名管道</strong>，意思就是这个类型的管道没有名字，用完了就销毁了。就像上面那个命令里面的一样，竖线代表的管道随着命令的执行自动创建、自动销毁。用户甚至都不知道自己在用管道这种技术，就已经解决了问题。所以这也是面试题里面经常会问的，到时候千万别说这是竖线，而要回答背后的机制，管道。</p>
<p>另外一种类型是<strong>命名管道</strong>。这个类型的管道需要通过mkfifo命令显式地创建。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkfifo</span> hello<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>hello就是这个管道的名称。管道以文件的形式存在，这也符合Linux里面一切皆文件的原则。这个时候，我们ls一下，可以看到，这个文件的类型是p，就是pipe的意思。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> -l
prw-r--r--  <span class="token number">1</span> root root         <span class="token number">0</span> May <span class="token number">21</span> <span class="token number">23</span>:29 hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>接下来，我们可以往管道里面写入东西。例如，写入一个字符串。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"hello world"</span> <span class="token operator">&gt;</span> hello<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个时候，管道里面的内容没有被读出，这个命令就是停在这里的，这说明当一个项目组要把它的输出交接给另一个项目组做输入，当没有交接完毕的时候，前一个项目组是不能撒手不管的。</p>
<p>这个时候，我们就需要重新连接一个终端。在终端中，用下面的命令读取管道里面的内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> <span class="token operator">&lt;</span> hello
hello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>一方面，我们能够看到，管道里面的内容被读取出来，打印到了终端上；另一方面，echo那个命令正常退出了，也即交接完毕，前一个项目组就完成了使命，可以解散了。</p>
<p>我们可以看出，瀑布模型的开发流程效率比较低下，因为团队之间无法频繁地沟通。而且，管道的使用模式，也不适合进程间频繁的交换数据。</p>
<p>于是，我们还得想其他的办法，例如我们是不是可以借鉴传统外企的沟通方式——邮件。邮件有一定的格式，例如抬头，正文，附件等，发送邮件可以建立收件人列表，所有在这个列表中的人，都可以反复的在此邮件基础上回复，达到频繁沟通的目的。</p>
<h4 id="31-2-消息队列模型"><a href="#31-2-消息队列模型" class="headerlink" title="31.2 消息队列模型"></a>31.2 消息队列模型</h4><p><img src="/images/《趣谈Linux操作系统》学习笔记/消息队列模型.png" alt="消息队列模型"></p>
<p>这种模型类似进程间通信的消息队列模型。和管道将信息一股脑儿地从一个进程，倒给另一个进程不同，消息队列有点儿像邮件，发送数据时，会分成一个一个独立的数据单元，也就是消息体，每个消息体都是固定大小的存储块，在字节流上不连续。</p>
<p>这个消息结构的定义我写在下面了。这里面的类型type和正文text没有强制规定，只要消息的发送方和接收方约定好即可。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">struct msg_buffer <span class="token punctuation">{</span>
    long mtype<span class="token punctuation">;</span>
    char mtext<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来，我们需要创建一个消息队列，使用<strong>msgget函数</strong>。这个函数需要有一个参数key，这是消息队列的唯一标识，应该是唯一的。如何保持唯一性呢？这个还是和文件关联。</p>
<p>我们可以指定一个文件，ftok会根据这个文件的inode，生成一个近乎唯一的key。只要在这个消息队列的生命周期内，这个文件不要被删除就可以了。只要不删除，无论什么时刻，再调用ftok，也会得到同样的key。这种key的使用方式在这一章会经常遇到，这是因为它们都属于System V IPC进程间通信机制体系中。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/msg.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">int</span> messagequeueid<span class="token punctuation">;</span>
key_t key<span class="token punctuation">;</span>

<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>key <span class="token operator">=</span> <span class="token function">ftok</span><span class="token punctuation">(</span><span class="token string">"/root/messagequeue/messagequeuekey"</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"ftok error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Message Queue key: %d.\n"</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>messagequeueid <span class="token operator">=</span> <span class="token function">msgget</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> IPC_CREAT<span class="token operator">|</span><span class="token number">0777</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"msgget error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Message queue id: %d.\n"</span><span class="token punctuation">,</span> messagequeueid<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在运行上面这个程序之前，我们先使用命令touch messagequeuekey，创建一个文件，然后多次执行的结果就会像下面这样：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./a.out
Message Queue key: <span class="token number">92536</span>.
Message queue id: <span class="token number">32768</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>System V IPC体系有一个统一的命令行工具：ipcmk，ipcs和ipcrm用于创建、查看和删除IPC对象。</p>
<p>例如，ipcs -q就能看到上面我们创建的消息队列对象。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ipcs -q
------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages
0x00016978 <span class="token number">32768</span>      root       <span class="token number">777</span>        <span class="token number">0</span>            <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来，我们来看如何发送信息。发送消息主要调用<strong>msgsnd函数</strong>。第一个参数是message queue的id，第二个参数是消息的结构体，第三个参数是消息的长度，最后一个参数是flag。这里IPC_NOWAIT表示发送的时候不阻塞，直接返回。</p>
<p>下面的这段程序，getopt_long、do-while循环以及switch，是用来解析命令行参数的。命令行参数的格式定义在long_options里面。每一项的第一个成员“id”“type““message”是参数选项的全称，第二个成员都为1，表示参数选项后面要跟参数，最后一个成员’i’‘t’’m’是参数选项的简称。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/msg.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;getopt.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>

<span class="token keyword">struct</span> <span class="token class-name">msg_buffer</span> <span class="token punctuation">{</span>
    <span class="token keyword">long</span> mtype<span class="token punctuation">;</span>
    <span class="token keyword">char</span> mtext<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> next_option<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> short_options <span class="token operator">=</span> <span class="token string">"i:t:m:"</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">option</span> long_options<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token punctuation">{</span> <span class="token string">"id"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'i'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span> <span class="token string">"type"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'t'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span> <span class="token string">"message"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'m'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> messagequeueid <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">msg_buffer</span> buffer<span class="token punctuation">;</span>
    buffer<span class="token punctuation">.</span>mtype <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span> message <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        next_option <span class="token operator">=</span> <span class="token function">getopt_long</span> <span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> short_options<span class="token punctuation">,</span> long_options<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span>next_option<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token string">'i'</span><span class="token operator">:</span>
            messagequeueid <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token string">'t'</span><span class="token operator">:</span>
            buffer<span class="token punctuation">.</span>mtype <span class="token operator">=</span> <span class="token function">atol</span><span class="token punctuation">(</span>optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token string">'m'</span><span class="token operator">:</span>
            message <span class="token operator">=</span> optarg<span class="token punctuation">;</span>
            len <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&gt;</span> <span class="token number">1024</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"message too long."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token function">memcpy</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span>mtext<span class="token punctuation">,</span> message<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span>next_option <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span>messagequeueid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> buffer<span class="token punctuation">.</span>mtype <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> len <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> message <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">msgsnd</span><span class="token punctuation">(</span>messagequeueid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buffer<span class="token punctuation">,</span> len<span class="token punctuation">,</span> IPC_NOWAIT<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fail to send message."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"arguments error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来，我们可以编译并运行这个发送程序。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc -o send sendmessage.c
./send -i <span class="token number">32768</span> -t <span class="token number">123</span> -m <span class="token string">"hello world"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>接下来，我们再来看如何收消息。收消息主要调用<strong>msgrcv函数</strong>，第一个参数是message queue的id，第二个参数是消息的结构体，第三个参数是可接受的最大长度，第四个参数是消息类型,最后一个参数是flag，这里IPC_NOWAIT表示接收的时候不阻塞，直接返回。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/msg.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;getopt.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>

<span class="token keyword">struct</span> <span class="token class-name">msg_buffer</span> <span class="token punctuation">{</span>
    <span class="token keyword">long</span> mtype<span class="token punctuation">;</span>
    <span class="token keyword">char</span> mtext<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> next_option<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> short_options <span class="token operator">=</span> <span class="token string">"i:t:"</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">option</span> long_options<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token punctuation">{</span> <span class="token string">"id"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'i'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span> <span class="token string">"type"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'t'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> messagequeueid <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">msg_buffer</span> buffer<span class="token punctuation">;</span>
    <span class="token keyword">long</span> type <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        next_option <span class="token operator">=</span> <span class="token function">getopt_long</span> <span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> short_options<span class="token punctuation">,</span> long_options<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span>next_option<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token string">'i'</span><span class="token operator">:</span>
            messagequeueid <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token string">'t'</span><span class="token operator">:</span>
            type <span class="token operator">=</span> <span class="token function">atol</span><span class="token punctuation">(</span>optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span>next_option <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span>messagequeueid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> type <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">msgrcv</span><span class="token punctuation">(</span>messagequeueid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buffer<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">,</span> type<span class="token punctuation">,</span> IPC_NOWAIT<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fail to recv message."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"received message type : %d, text: %s."</span><span class="token punctuation">,</span> buffer<span class="token punctuation">.</span>mtype<span class="token punctuation">,</span> buffer<span class="token punctuation">.</span>mtext<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"arguments error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来，我们可以编译并运行这个发送程序。可以看到，如果有消息，可以正确地读到消息；如果没有，则返回没有消息。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./recv -i <span class="token number">32768</span> -t <span class="token number">123</span>
received message <span class="token builtin class-name">type</span> <span class="token builtin class-name">:</span> <span class="token number">123</span>, text: hello world.
$ ./recv -i <span class="token number">32768</span> -t <span class="token number">123</span>
fail to recv message.: No message of desired <span class="token builtin class-name">type</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>有了消息这种模型，两个进程之间的通信就像咱们平时发邮件一样，你来一封，我回一封，可以频繁沟通了。</p>
<h4 id="31-3-共享内存模型"><a href="#31-3-共享内存模型" class="headerlink" title="31.3 共享内存模型"></a>31.3 共享内存模型</h4><p>但是有时候，项目组之间的沟通需要特别紧密，而且要分享一些比较大的数据。如果使用邮件，就发现，一方面邮件的来去不及时；另外一方面，附件大小也有限制，所以，这个时候，我们经常采取的方式就是，把两个项目组在需要合作的期间，拉到一个会议室进行合作开发，这样大家可以直接交流文档呀，架构图呀，直接在白板上画或者直接扔给对方，就可以直接看到。</p>
<p>可以看出来，共享会议室这种模型，类似进程间通信的<strong>共享内存模型</strong>。前面咱们讲内存管理的时候，知道每个进程都有自己独立的虚拟内存空间，不同的进程的虚拟内存空间映射到不同的物理内存中去。这个进程访问A地址和另一个进程访问A地址，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。</p>
<p>但是，咱们是不是可以变通一下，拿出一块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去。</p>
<p>共享内存也是System V IPC进程间通信机制体系中的，所以从它使用流程可以看到熟悉的面孔。</p>
<p>我们可以创建一个共享内存，调用shmget。在这个体系中，创建一个IPC对象都是xxxget，这里面第一个参数是key，和msgget里面的key一样，都是唯一定位一个共享内存对象，也可以通过关联文件的方式实现唯一性。第二个参数是共享内存的大小。第三个参数如果是IPC_CREAT，同样表示创建一个新的。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">shmget</span><span class="token punctuation">(</span>key_t key<span class="token punctuation">,</span> size_t size<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>创建完毕之后，我们可以通过ipcs命令查看这个共享内存。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ipcs ­­--shmems
------ Shared Memory Segments ------ ­­­­­­­­
key        shmid    owner perms    bytes nattch status
0x00000000 <span class="token number">19398656</span> marc  <span class="token number">600</span>    <span class="token number">1048576</span> <span class="token number">2</span>      dest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来，如果一个进程想要访问这一段共享内存，需要将这个内存加载到自己的虚拟地址空间的某个位置，通过shmat函数，就是attach的意思。其中addr就是要指定attach到这个地方。但是这个地址的设定难度比较大，除非对于内存布局非常熟悉，否则可能会attach到一个非法地址。所以，通常的做法是将addr设为NULL，让内核选一个合适的地址。返回值就是真正被attach的地方。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">shmat</span><span class="token punctuation">(</span><span class="token keyword">int</span> shm_id<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果共享内存使用完毕，可以通过shmdt解除绑定，然后通过shmctl，将cmd设置为IPC_RMID，从而删除这个共享内存对象。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">shmdt</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">shmctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> shm_id<span class="token punctuation">,</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">shmid_ds</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h4 id="31-4-信号量"><a href="#31-4-信号量" class="headerlink" title="31.4 信号量"></a>31.4 信号量</h4><p>需要一种保护机制，使得同一个共享的资源，同时只能被一个进程访问。在System V IPC进程间通信机制体系中，早就想好了应对办法，就是信号量（Semaphore）。因此，信号量和共享内存往往要配合使用。</p>
<p>信号量其实是一个计数器，主要用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</p>
<p>我们可以将信号量初始化为一个数值，来代表某种资源的总体数量。对于信号量来讲，会定义两种原子操作，一个是<strong>P操作</strong>，我们称为<strong>申请资源操作</strong>。这个操作会申请将信号量的数值减去N，表示这些数量被他申请使用了，其他人不能用了。另一个是<strong>V操作</strong>，我们称为<strong>归还资源操作</strong>，这个操作会申请将信号量加上M，表示这些数量已经还给信号量了，其他人可以使用了。</p>
<p>如果想创建一个信号量，我们可以通过semget函数。看，又是xxxget，第一个参数key也是类似的，第二个参数num_sems不是指资源的数量，而是表示可以创建多少个信号量，形成一组信号量，也就是说，如果你有多种资源需要管理，可以创建一个信号量组。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">semget</span><span class="token punctuation">(</span>key_t key<span class="token punctuation">,</span> <span class="token keyword">int</span> num_sems<span class="token punctuation">,</span> <span class="token keyword">int</span> sem_flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>接下来，我们需要初始化信号量的总的资源数量。通过semctl函数，第一个参数semid是这个信号量组的id，第二个参数semnum才是在这个信号量组中某个信号量的id，第三个参数是命令，如果是初始化，则用SETVAL，第四个参数是一个union。如果初始化，应该用里面的val设置资源总量。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">semctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> semid<span class="token punctuation">,</span> <span class="token keyword">int</span> semnum<span class="token punctuation">,</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">union</span> semun args<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">union</span> semun
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> val<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">semid_ds</span> <span class="token operator">*</span>buf<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> <span class="token keyword">int</span> <span class="token operator">*</span>array<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">seminfo</span> <span class="token operator">*</span>__buf<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>无论是P操作还是V操作，我们统一用semop函数。第一个参数还是信号量组的id，一次可以操作多个信号量。第三个参数numops就是有多少个操作，第二个参数将这些操作放在一个数组中。</p>
<p>数组的每一项是一个struct sembuf，里面的第一个成员是这个操作的对象是哪个信号量。</p>
<p>第二个成员就是要对这个信号量做多少改变。如果sem_op &lt; 0，就请求sem_op的绝对值的资源。如果相应的资源数可以满足请求，则将该信号量的值减去sem_op的绝对值，函数成功返回。</p>
<p>当相应的资源数不能满足请求时，就要看sem_flg了。如果把sem_flg设置为IPC_NOWAIT，也就是没有资源也不等待，则semop函数出错返回EAGAIN。如果sem_flg 没有指定IPC_NOWAIT，则进程挂起，直到当相应的资源数可以满足请求。若sem_op &gt; 0，表示进程归还相应的资源数，将 sem_op 的值加到信号量的值上。如果有进程正在休眠等待此信号量，则唤醒它们。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">semop</span><span class="token punctuation">(</span><span class="token keyword">int</span> semid<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sembuf</span> semoparray<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> size_t numops<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">sembuf</span>
<span class="token punctuation">{</span>
  <span class="token keyword">short</span> sem_num<span class="token punctuation">;</span> <span class="token comment">// 信号量组中对应的序号，0～sem_nums-1</span>
  <span class="token keyword">short</span> sem_op<span class="token punctuation">;</span>  <span class="token comment">// 信号量值在一次操作中的改变量</span>
  <span class="token keyword">short</span> sem_flg<span class="token punctuation">;</span> <span class="token comment">// IPC_NOWAIT, SEM_UNDO</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="31-5-信号"><a href="#31-5-信号" class="headerlink" title="31.5 信号"></a>31.5 信号</h4><p>上面讲的进程间通信的方式，都是常规状态下的工作模式，对应到咱们平时的工作交接，收发邮件、联合开发等，其实还有一种异常情况下的工作模式。</p>
<p>例如出现线上系统故障，这个时候，什么流程都来不及了，不可能发邮件，也来不及开会，所有的架构师、开发、运维都要被通知紧急出动。所以，7乘24小时不间断执行的系统都需要有告警系统，一旦出事情，就要通知到人，哪怕是半夜，也要电话叫起来，处理故障。</p>
<p>对应到操作系统中，就是信号。信号没有特别复杂的数据结构，就是用一个代号一样的数字。Linux提供了几十种信号，分别代表不同的意义。信号之间依靠它们的值来区分。这就像咱们看警匪片，对于紧急的行动，都是说，“1号作战任务”开始执行，警察就开始行动了。情况紧急，不能啰里啰嗦了。</p>
<p>信号可以在任何时候发送给某一进程，进程需要为这个信号配置信号处理函数。当某个信号发生的时候，就默认执行这个函数就可以了。这就相当于咱们运维一个系统应急手册，当遇到什么情况，做什么事情，都事先准备好，出了事情照着做就可以了。</p>
<h3 id="32-信号（上）"><a href="#32-信号（上）" class="headerlink" title="32. 信号（上）"></a>32. 信号（上）</h3><p>在Linux操作系统中，为了响应各种各样的事件，也是定义了非常多的信号。我们可以通过kill -l命令，查看所有的信号。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">kill</span> -l
 <span class="token number">1</span><span class="token punctuation">)</span> SIGHUP       <span class="token number">2</span><span class="token punctuation">)</span> SIGINT       <span class="token number">3</span><span class="token punctuation">)</span> SIGQUIT      <span class="token number">4</span><span class="token punctuation">)</span> SIGILL       <span class="token number">5</span><span class="token punctuation">)</span> SIGTRAP
 <span class="token number">6</span><span class="token punctuation">)</span> SIGABRT      <span class="token number">7</span><span class="token punctuation">)</span> SIGBUS       <span class="token number">8</span><span class="token punctuation">)</span> SIGFPE       <span class="token number">9</span><span class="token punctuation">)</span> SIGKILL     <span class="token number">10</span><span class="token punctuation">)</span> SIGUSR1
<span class="token number">11</span><span class="token punctuation">)</span> SIGSEGV     <span class="token number">12</span><span class="token punctuation">)</span> SIGUSR2     <span class="token number">13</span><span class="token punctuation">)</span> SIGPIPE     <span class="token number">14</span><span class="token punctuation">)</span> SIGALRM     <span class="token number">15</span><span class="token punctuation">)</span> SIGTERM
<span class="token number">16</span><span class="token punctuation">)</span> SIGSTKFLT   <span class="token number">17</span><span class="token punctuation">)</span> SIGCHLD     <span class="token number">18</span><span class="token punctuation">)</span> SIGCONT     <span class="token number">19</span><span class="token punctuation">)</span> SIGSTOP     <span class="token number">20</span><span class="token punctuation">)</span> SIGTSTP
<span class="token number">21</span><span class="token punctuation">)</span> SIGTTIN     <span class="token number">22</span><span class="token punctuation">)</span> SIGTTOU     <span class="token number">23</span><span class="token punctuation">)</span> SIGURG      <span class="token number">24</span><span class="token punctuation">)</span> SIGXCPU     <span class="token number">25</span><span class="token punctuation">)</span> SIGXFSZ
<span class="token number">26</span><span class="token punctuation">)</span> SIGVTALRM   <span class="token number">27</span><span class="token punctuation">)</span> SIGPROF     <span class="token number">28</span><span class="token punctuation">)</span> SIGWINCH    <span class="token number">29</span><span class="token punctuation">)</span> SIGIO       <span class="token number">30</span><span class="token punctuation">)</span> SIGPWR
<span class="token number">31</span><span class="token punctuation">)</span> SIGSYS      <span class="token number">34</span><span class="token punctuation">)</span> SIGRTMIN    <span class="token number">35</span><span class="token punctuation">)</span> SIGRTMIN+1  <span class="token number">36</span><span class="token punctuation">)</span> SIGRTMIN+2  <span class="token number">37</span><span class="token punctuation">)</span> SIGRTMIN+3
<span class="token number">38</span><span class="token punctuation">)</span> SIGRTMIN+4  <span class="token number">39</span><span class="token punctuation">)</span> SIGRTMIN+5  <span class="token number">40</span><span class="token punctuation">)</span> SIGRTMIN+6  <span class="token number">41</span><span class="token punctuation">)</span> SIGRTMIN+7  <span class="token number">42</span><span class="token punctuation">)</span> SIGRTMIN+8
<span class="token number">43</span><span class="token punctuation">)</span> SIGRTMIN+9  <span class="token number">44</span><span class="token punctuation">)</span> SIGRTMIN+10 <span class="token number">45</span><span class="token punctuation">)</span> SIGRTMIN+11 <span class="token number">46</span><span class="token punctuation">)</span> SIGRTMIN+12 <span class="token number">47</span><span class="token punctuation">)</span> SIGRTMIN+13
<span class="token number">48</span><span class="token punctuation">)</span> SIGRTMIN+14 <span class="token number">49</span><span class="token punctuation">)</span> SIGRTMIN+15 <span class="token number">50</span><span class="token punctuation">)</span> SIGRTMAX-14 <span class="token number">51</span><span class="token punctuation">)</span> SIGRTMAX-13 <span class="token number">52</span><span class="token punctuation">)</span> SIGRTMAX-12
<span class="token number">53</span><span class="token punctuation">)</span> SIGRTMAX-11 <span class="token number">54</span><span class="token punctuation">)</span> SIGRTMAX-10 <span class="token number">55</span><span class="token punctuation">)</span> SIGRTMAX-9  <span class="token number">56</span><span class="token punctuation">)</span> SIGRTMAX-8  <span class="token number">57</span><span class="token punctuation">)</span> SIGRTMAX-7
<span class="token number">58</span><span class="token punctuation">)</span> SIGRTMAX-6  <span class="token number">59</span><span class="token punctuation">)</span> SIGRTMAX-5  <span class="token number">60</span><span class="token punctuation">)</span> SIGRTMAX-4  <span class="token number">61</span><span class="token punctuation">)</span> SIGRTMAX-3  <span class="token number">62</span><span class="token punctuation">)</span> SIGRTMAX-2
<span class="token number">63</span><span class="token punctuation">)</span> SIGRTMAX-1  <span class="token number">64</span><span class="token punctuation">)</span> SIGRTMAX<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这些信号都是什么作用呢？我们可以通过man 7 signal命令查看，里面会有一个列表。</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">Signal     Value     Action   Comment
──────────────────────────────────────────────────────────────────────
SIGHUP        1       Term    Hangup detected on controlling terminal
                              or death of controlling process
SIGINT        2       Term    Interrupt from keyboard
SIGQUIT       3       Core    Quit from keyboard
SIGILL        4       Core    Illegal Instruction


SIGABRT       6       Core    Abort signal from abort(3)
SIGFPE        8       Core    Floating point exception
SIGKILL       9       Term    Kill signal
SIGSEGV      11       Core    Invalid memory reference
SIGPIPE      13       Term    Broken pipe: write to pipe with no
                              readers
SIGALRM      14       Term    Timer signal from alarm(2)
SIGTERM      15       Term    Termination signal
SIGUSR1   30,10,16    Term    User-defined signal 1
SIGUSR2   31,12,17    Term    User-defined signal 2
……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。</p>
<p>有下面这几种，用户进程对信号的处理方式。</p>
<ol>
<li><p>执行默认操作。</p>
<p> Linux对每种信号都规定了默认操作，例如，上面列表中的Term，就是终止进程的意思。Core的意思是Core Dump，也即终止进程后，通过Core Dump将当前进程的运行状态保存在文件里面，方便程序员事后进行分析问题在哪里。</p>
</li>
<li><p>捕捉信号。</p>
<p> 我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</p>
</li>
<li><p>忽略信号。</p>
<p> 当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即SIGKILL和SEGSTOP，它们用于在任何时候中断或结束某一进程。</p>
</li>
</ol>
<p>接下来，我们来看一下信号处理最常见的流程。这个过程主要是分成两步，第一步是注册信号处理函数。第二步是发送信号。这一节我们主要看第一步。</p>
<p>如果我们不想让某个信号执行默认操作，一种方法就是对特定的信号注册相应的信号处理函数，设置信号处理方式的是<strong>signal函数</strong>。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>sighandler_t<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
sighandler_t <span class="token function">signal</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">,</span> sighandler_t handler<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这其实就是定义一个方法，并且将这个方法和某个信号关联起来。当这个进程遇到这个信号的时候，就执行这个方法。</p>
<p>如果我们在Linux下面执行man signal的话，会发现Linux不建议我们直接用这个方法，而是改用sigaction。定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sigaction</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> <span class="token operator">*</span>act<span class="token punctuation">,</span>
                     <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> <span class="token operator">*</span>oldact<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这两者的区别在哪里呢？其实它还是将信号和一个动作进行关联，只不过这个动作由一个结构struct sigaction表示了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sigaction</span> <span class="token punctuation">{</span>
    __sighandler_t sa_handler<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sa_flags<span class="token punctuation">;</span>
    __sigrestore_t sa_restorer<span class="token punctuation">;</span>
    sigset_t sa_mask<span class="token punctuation">;</span>       <span class="token comment">/* mask last for extensibility */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>和signal类似的是，这里面还是有__sighandler_t。但是，其他成员变量可以让你更加细致地控制信号处理的行为。而signal函数没有给你机会设置这些。这里需要注意的是，<strong>signal不是系统调用，而是glibc封装的一个函数</strong>。这样就像man signal里面写的一样，不同的实现方式，设置的参数会不同，会导致行为的不同。</p>
<p>例如，我们在glibc里面会看到了这样一个实现：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">signal __sysv_signal</span></span>

__sighandler_t
<span class="token function">__sysv_signal</span> <span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">,</span> __sighandler_t handler<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> act<span class="token punctuation">,</span> oact<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  act<span class="token punctuation">.</span>sa_handler <span class="token operator">=</span> handler<span class="token punctuation">;</span>
  <span class="token function">__sigemptyset</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>act<span class="token punctuation">.</span>sa_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
  act<span class="token punctuation">.</span>sa_flags <span class="token operator">=</span> SA_ONESHOT <span class="token operator">|</span> SA_NOMASK <span class="token operator">|</span> SA_INTERRUPT<span class="token punctuation">;</span>
  act<span class="token punctuation">.</span>sa_flags <span class="token operator">&amp;=</span> <span class="token operator">~</span>SA_RESTART<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__sigaction</span> <span class="token punctuation">(</span>sig<span class="token punctuation">,</span> <span class="token operator">&amp;</span>act<span class="token punctuation">,</span> <span class="token operator">&amp;</span>oact<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> SIG_ERR<span class="token punctuation">;</span>
  <span class="token keyword">return</span> oact<span class="token punctuation">.</span>sa_handler<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">weak_alias</span> <span class="token punctuation">(</span>__sysv_signal<span class="token punctuation">,</span> sysv_signal<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里面，sa_flags进行了默认的设置。SA_ONESHOT是什么意思呢？意思就是，这里设置的信号处理函数，仅仅起作用一次。用完了一次后，就设置回默认行为。这其实并不是我们想看到的。毕竟我们一旦安装了一个信号处理函数，肯定希望它一直起作用，直到我显式地关闭它。</p>
<p>另外一个设置就是SA_NOMASK。我们通过__sigemptyset，将sa_mask设置为空。这样的设置表示在这个信号处理函数执行过程中，如果再有其他信号，哪怕相同的信号到来的时候，这个信号处理函数会被中断。如果一个信号处理函数真的被其他信号中断，其实问题也不大，因为当处理完了其他的信号处理函数后，还会回来接着处理这个信号处理函数的，但是对于相同的信号就有点尴尬了，这就需要这个信号处理函数写的比较有技巧了。</p>
<p>例如，对于这个信号的处理过程中，要操作某个数据结构，因为是相同的信号，很可能操作的是同一个实例，这样的话，同步、死锁这些都要想好。其实一般的思路应该是，当某一个信号的信号处理函数运行的时候，我们暂时屏蔽这个信号。后面我们还会仔细分析屏蔽这个动作，屏蔽并不意味着信号一定丢失，而是暂存，这样能够做到信号处理函数对于相同的信号，处理完一个再处理下一个，这样信号处理函数的逻辑要简单得多。</p>
<p>还有一个设置就是设置了SA_INTERRUPT，清除了SA_RESTART。这是什么意思呢？我们知道，信号的到来时间是不可预期的，有可能程序正在调用某个漫长的系统调用的时候（你可以在一台Linux机器上运行man 7 signal命令，在这里找Interruption of system calls and library functions by signal handlers的部分，里面说的非常详细），这个时候一个信号来了，会中断这个系统调用，去执行信号处理函数，那执行完了以后呢？系统调用怎么办呢？</p>
<p>这时候有两种处理方法，一种就是SA_INTERRUPT，也即系统调用被中断了，就不再重试这个系统调用了，而是直接返回一个-EINTR常量，告诉调用方，这个系统调用被信号中断了，但是怎么处理你看着办。如果是这样的话，调用方可以根据自己的逻辑，重新调用或者直接返回，这会使得我们的代码非常复杂，在所有系统调用的返回值判断里面，都要特殊判断一下这个值。</p>
<p>另外一种处理方法是SA_RESTART。这个时候系统调用会被自动重新启动，不需要调用方自己写代码。当然也可能存在问题，例如从终端读入一个字符，这个时候用户在终端输入一个’a’字符，在处理’a’字符的时候被信号中断了，等信号处理完毕，再次读入一个字符的时候，如果用户不再输入，就停在那里了，需要用户再次输入同一个字符。</p>
<p>因而，建议你使用sigaction函数，根据自己的需要定制参数。</p>
<p>接下来，我们来看sigaction具体做了些什么。</p>
<p>还记得在学习系统调用那一节的时候，我们知道，glibc里面有个文件syscalls.list。这里面定义了库函数调用哪些系统调用，在这里我们找到了sigaction。</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">sigaction    -       sigaction       i:ipp   __sigaction     sigaction<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>接下来，在glibc中，<strong>sigaction会调用</strong>libc_sigaction，并最终调用的系统调用是rt_sigaction。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span>
<span class="token function">__sigaction</span> <span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> <span class="token operator">*</span>act<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> <span class="token operator">*</span>oact<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">return</span> <span class="token function">__libc_sigaction</span> <span class="token punctuation">(</span>sig<span class="token punctuation">,</span> act<span class="token punctuation">,</span> oact<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span>
<span class="token function">__libc_sigaction</span> <span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> <span class="token operator">*</span>act<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> <span class="token operator">*</span>oact<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> result<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">kernel_sigaction</span> kact<span class="token punctuation">,</span> koact<span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>act<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      kact<span class="token punctuation">.</span>k_sa_handler <span class="token operator">=</span> act<span class="token operator">-&gt;</span>sa_handler<span class="token punctuation">;</span>
      <span class="token function">memcpy</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>kact<span class="token punctuation">.</span>sa_mask<span class="token punctuation">,</span> <span class="token operator">&amp;</span>act<span class="token operator">-&gt;</span>sa_mask<span class="token punctuation">,</span> <span class="token keyword">sizeof</span> <span class="token punctuation">(</span>sigset_t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      kact<span class="token punctuation">.</span>sa_flags <span class="token operator">=</span> act<span class="token operator">-&gt;</span>sa_flags <span class="token operator">|</span> SA_RESTORER<span class="token punctuation">;</span>

      kact<span class="token punctuation">.</span>sa_restorer <span class="token operator">=</span> <span class="token operator">&amp;</span>restore_rt<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


  result <span class="token operator">=</span> <span class="token function">INLINE_SYSCALL</span> <span class="token punctuation">(</span>rt_sigaction<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span>
                           sig<span class="token punctuation">,</span> act <span class="token operator">?</span> <span class="token operator">&amp;</span>kact <span class="token operator">:</span> <span class="token constant">NULL</span><span class="token punctuation">,</span>
                           oact <span class="token operator">?</span> <span class="token operator">&amp;</span>koact <span class="token operator">:</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> _NSIG <span class="token operator">/</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>oact <span class="token operator">&amp;&amp;</span> result <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      oact<span class="token operator">-&gt;</span>sa_handler <span class="token operator">=</span> koact<span class="token punctuation">.</span>k_sa_handler<span class="token punctuation">;</span>
      <span class="token function">memcpy</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>oact<span class="token operator">-&gt;</span>sa_mask<span class="token punctuation">,</span> <span class="token operator">&amp;</span>koact<span class="token punctuation">.</span>sa_mask<span class="token punctuation">,</span> <span class="token keyword">sizeof</span> <span class="token punctuation">(</span>sigset_t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      oact<span class="token operator">-&gt;</span>sa_flags <span class="token operator">=</span> koact<span class="token punctuation">.</span>sa_flags<span class="token punctuation">;</span>
      oact<span class="token operator">-&gt;</span>sa_restorer <span class="token operator">=</span> koact<span class="token punctuation">.</span>sa_restorer<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这也是很多人看信号处理的内核实现的时候，比较困惑的地方。例如，内核代码注释里面会说，系统调用signal是为了兼容过去，系统调用sigaction也是为了兼容过去，连参数都变成了struct compat_old_sigaction，所以说，我们的库函数虽然调用的是sigaction，到了系统调用层，调用的可不是系统调用sigaction，而是系统调用rt_sigaction。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE4</span><span class="token punctuation">(</span>rt_sigaction<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> sig<span class="token punctuation">,</span>
        <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> act<span class="token punctuation">,</span>
        <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> oact<span class="token punctuation">,</span>
        size_t<span class="token punctuation">,</span> sigsetsize<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">k_sigaction</span> new_sa<span class="token punctuation">,</span> old_sa<span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>act<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_from_user</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>new_sa<span class="token punctuation">.</span>sa<span class="token punctuation">,</span> act<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>new_sa<span class="token punctuation">.</span>sa<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token operator">-</span>EFAULT<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    ret <span class="token operator">=</span> <span class="token function">do_sigaction</span><span class="token punctuation">(</span>sig<span class="token punctuation">,</span> act <span class="token operator">?</span> <span class="token operator">&amp;</span>new_sa <span class="token operator">:</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> oact <span class="token operator">?</span> <span class="token operator">&amp;</span>old_sa <span class="token operator">:</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ret <span class="token operator">&amp;&amp;</span> oact<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_to_user</span><span class="token punctuation">(</span>oact<span class="token punctuation">,</span> <span class="token operator">&amp;</span>old_sa<span class="token punctuation">.</span>sa<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>old_sa<span class="token punctuation">.</span>sa<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token operator">-</span>EFAULT<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
out<span class="token operator">:</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在rt_sigaction里面，我们将用户态的struct sigaction结构，拷贝为内核态的k_sigaction，然后调用do_sigaction。do_sigaction也很简单，还记得进程内核的数据结构里，struct task_struct里面有一个成员sighand，里面有一个action。这是一个数组，下标是信号，内容就是信号处理函数，do_sigaction就是设置sighand里的信号处理函数。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">do_sigaction</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">k_sigaction</span> <span class="token operator">*</span>act<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">k_sigaction</span> <span class="token operator">*</span>oact<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p <span class="token operator">=</span> current<span class="token punctuation">,</span> <span class="token operator">*</span>t<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">k_sigaction</span> <span class="token operator">*</span>k<span class="token punctuation">;</span>
    sigset_t mask<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    k <span class="token operator">=</span> <span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>sighand<span class="token operator">-&gt;</span>action<span class="token punctuation">[</span>sig<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token function">spin_lock_irq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>sighand<span class="token operator">-&gt;</span>siglock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oact<span class="token punctuation">)</span>
        <span class="token operator">*</span>oact <span class="token operator">=</span> <span class="token operator">*</span>k<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>act<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">sigdelsetmask</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>act<span class="token operator">-&gt;</span>sa<span class="token punctuation">.</span>sa_mask<span class="token punctuation">,</span>
                  <span class="token function">sigmask</span><span class="token punctuation">(</span>SIGKILL<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token function">sigmask</span><span class="token punctuation">(</span>SIGSTOP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">*</span>k <span class="token operator">=</span> <span class="token operator">*</span>act<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>

    <span class="token function">spin_unlock_irq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>sighand<span class="token operator">-&gt;</span>siglock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>至此，信号处理函数的注册已经完成了。</p>
<h4 id="32-1-总结"><a href="#32-1-总结" class="headerlink" title="32.1 总结"></a>32.1 总结</h4><p>这一节讲了如何通过API注册一个信号处理函数，整个过程如下图所示。</p>
<ul>
<li>在用户程序里面，有两个函数可以调用，一个是signal，一个是sigaction，推荐使用sigaction。</li>
<li>用户程序调用的是Glibc里面的函数，signal调用的是<strong>sysv_signal，里面默认设置了一些参数，使得signal的功能受到了限制，sigaction调用的是</strong>sigaction，参数用户可以任意设定。</li>
<li>无论是<strong>sysv_signal还是</strong>sigaction，调用的都是统一的一个系统调用rt_sigaction。</li>
<li>在内核中，rt_sigaction调用的是do_sigaction设置信号处理函数。在每一个进程的task_struct里面，都有一个sighand指向struct sighand_struct，里面是一个数组，下标是信号，里面的内容是信号处理函数。</li>
</ul>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/通过API注册一个信号处理函数的过程.png" alt="通过API注册一个信号处理函数的过程"></p>
<h3 id="33-信号（下）"><a href="#33-信号（下）" class="headerlink" title="33. 信号（下）"></a>33. 信号（下）</h3><h4 id="33-1-信号的发送"><a href="#33-1-信号的发送" class="headerlink" title="33.1 信号的发送"></a>33.1 信号的发送</h4><p>有时候，我们在终端输入某些组合键的时候，会给进程发送信号，例如，Ctrl+C产生SIGINT信号，Ctrl+Z产生SIGTSTP信号。</p>
<p>有的时候，硬件异常也会产生信号。比如，执行了除以0的指令，CPU就会产生异常，然后把SIGFPE信号发送给进程。再如，进程访问了非法内存，内存管理模块就会产生异常，然后把信号SIGSEGV发送给进程。</p>
<p>这里同样是硬件产生的，对于中断和信号还是要加以区别。咱们前面讲过，中断要注册中断处理函数，但是中断处理函数是在内核驱动里面的，信号也要注册信号处理函数，信号处理函数是在用户态进程里面的。</p>
<p>对于硬件触发的，无论是中断，还是信号，肯定是先到内核的，然后内核对于中断和信号处理方式不同。一个是完全在内核里面处理完毕，一个是将信号放在对应的进程task_struct里信号相关的数据结构里面，然后等待进程在用户态去处理。当然有些严重的信号，内核会把进程干掉。但是，这也能看出来，中断和信号的严重程度不一样，信号影响的往往是某一个进程，处理慢了，甚至错了，也不过这个进程被干掉，而中断影响的是整个系统。一旦中断处理中有了bug，可能整个Linux都挂了。</p>
<p>有时候，内核在某些情况下，也会给进程发送信号。例如，向读端已关闭的管道写数据时产生SIGPIPE信号，当子进程退出时，我们要给父进程发送SIG_CHLD信号等。</p>
<p>最直接的发送信号的方法就是，通过命令kill来发送信号了。例如，我们都知道的kill -9 pid可以发送信号给一个进程，杀死它。</p>
<p>另外，我们还可以通过kill或者sigqueue系统调用，发送信号给某个进程，也可以通过tkill或者tgkill发送信号给某个线程。虽然方式多种多样，但是最终都是调用了do_send_sig_info函数，将信号放在相应的task_struct的信号数据结构中。</p>
<ul>
<li>kill-&gt;kill_something_info-&gt;kill_pid_info-&gt;group_send_sig_info-&gt;do_send_sig_info</li>
<li>tkill-&gt;do_tkill-&gt;do_send_specific-&gt;do_send_sig_info</li>
<li>tgkill-&gt;do_tkill-&gt;do_send_specific-&gt;do_send_sig_info</li>
<li>rt_sigqueueinfo-&gt;do_rt_sigqueueinfo-&gt;kill_proc_info-&gt;kill_pid_info-&gt;group_send_sig_info-&gt;do_send_sig_info</li>
</ul>
<p>do_send_sig_info会调用send_signal，进而调用__send_signal。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE2</span><span class="token punctuation">(</span>kill<span class="token punctuation">,</span> pid_t<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> sig<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">siginfo</span> info<span class="token punctuation">;</span>

    info<span class="token punctuation">.</span>si_signo <span class="token operator">=</span> sig<span class="token punctuation">;</span>
    info<span class="token punctuation">.</span>si_errno <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    info<span class="token punctuation">.</span>si_code <span class="token operator">=</span> SI_USER<span class="token punctuation">;</span>
    info<span class="token punctuation">.</span>si_pid <span class="token operator">=</span> <span class="token function">task_tgid_vnr</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
    info<span class="token punctuation">.</span>si_uid <span class="token operator">=</span> <span class="token function">from_kuid_munged</span><span class="token punctuation">(</span><span class="token function">current_user_ns</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">current_uid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token function">kill_something_info</span><span class="token punctuation">(</span>sig<span class="token punctuation">,</span> <span class="token operator">&amp;</span>info<span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">__send_signal</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">siginfo</span> <span class="token operator">*</span>info<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>t<span class="token punctuation">,</span>
            <span class="token keyword">int</span> group<span class="token punctuation">,</span> <span class="token keyword">int</span> from_ancestor_ns<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">sigpending</span> <span class="token operator">*</span>pending<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sigqueue</span> <span class="token operator">*</span>q<span class="token punctuation">;</span>
    <span class="token keyword">int</span> override_rlimit<span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> result<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    pending <span class="token operator">=</span> group <span class="token operator">?</span> <span class="token operator">&amp;</span>t<span class="token operator">-&gt;</span>signal<span class="token operator">-&gt;</span>shared_pending <span class="token operator">:</span> <span class="token operator">&amp;</span>t<span class="token operator">-&gt;</span>pending<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">legacy_queue</span><span class="token punctuation">(</span>pending<span class="token punctuation">,</span> sig<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">goto</span> ret<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>sig <span class="token operator">&lt;</span> SIGRTMIN<span class="token punctuation">)</span>
        override_rlimit <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">is_si_special</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span> <span class="token operator">||</span> info<span class="token operator">-&gt;</span>si_code <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        override_rlimit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    q <span class="token operator">=</span> <span class="token function">__sigqueue_alloc</span><span class="token punctuation">(</span>sig<span class="token punctuation">,</span> t<span class="token punctuation">,</span> GFP_ATOMIC <span class="token operator">|</span> __GFP_NOTRACK_FALSE_POSITIVE<span class="token punctuation">,</span>
        override_rlimit<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">list_add_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-&gt;</span>list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pending<span class="token operator">-&gt;</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> info<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> SEND_SIG_NOINFO<span class="token operator">:</span>
            q<span class="token operator">-&gt;</span>info<span class="token punctuation">.</span>si_signo <span class="token operator">=</span> sig<span class="token punctuation">;</span>
            q<span class="token operator">-&gt;</span>info<span class="token punctuation">.</span>si_errno <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            q<span class="token operator">-&gt;</span>info<span class="token punctuation">.</span>si_code <span class="token operator">=</span> SI_USER<span class="token punctuation">;</span>
            q<span class="token operator">-&gt;</span>info<span class="token punctuation">.</span>si_pid <span class="token operator">=</span> <span class="token function">task_tgid_nr_ns</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span>
                            <span class="token function">task_active_pid_ns</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            q<span class="token operator">-&gt;</span>info<span class="token punctuation">.</span>si_uid <span class="token operator">=</span> <span class="token function">from_kuid_munged</span><span class="token punctuation">(</span><span class="token function">current_user_ns</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">current_uid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> SEND_SIG_PRIV<span class="token operator">:</span>
            q<span class="token operator">-&gt;</span>info<span class="token punctuation">.</span>si_signo <span class="token operator">=</span> sig<span class="token punctuation">;</span>
            q<span class="token operator">-&gt;</span>info<span class="token punctuation">.</span>si_errno <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            q<span class="token operator">-&gt;</span>info<span class="token punctuation">.</span>si_code <span class="token operator">=</span> SI_KERNEL<span class="token punctuation">;</span>
            q<span class="token operator">-&gt;</span>info<span class="token punctuation">.</span>si_pid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            q<span class="token operator">-&gt;</span>info<span class="token punctuation">.</span>si_uid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
            <span class="token function">copy_siginfo</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-&gt;</span>info<span class="token punctuation">,</span> info<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>from_ancestor_ns<span class="token punctuation">)</span>
                q<span class="token operator">-&gt;</span>info<span class="token punctuation">.</span>si_pid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token function">userns_fixup_signal_uid</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-&gt;</span>info<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
out_set<span class="token operator">:</span>
    <span class="token function">signalfd_notify</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sigaddset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pending<span class="token operator">-&gt;</span>signal<span class="token punctuation">,</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">complete_signal</span><span class="token punctuation">(</span>sig<span class="token punctuation">,</span> t<span class="token punctuation">,</span> group<span class="token punctuation">)</span><span class="token punctuation">;</span>
ret<span class="token operator">:</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里，我们看到，在学习进程数据结构中task_struct里面的sigpending。在上面的代码里面，我们先是要决定应该用哪个sigpending。这就要看我们发送的信号，是给进程的还是线程的。如果是kill发送的，也就是发送给整个进程的，就应该发送给t-&gt;signal-&gt;shared_pending。这里面是整个进程所有线程共享的信号；如果是tkill发送的，也就是发给某个线程的，就应该发给t-&gt;pending。这里面是这个线程的task_struct独享的。</p>
<p>struct sigpending里面有两个成员，一个是一个集合sigset_t，表示都收到了哪些信号，还有一个链表，也表示收到了哪些信号。它的结构如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sigpending</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> list<span class="token punctuation">;</span>
    sigset_t signal<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果都表示收到了信号，这两者有什么区别呢？我们接着往下看__send_signal里面的代码。接下来，我们要调用legacy_queue。如果满足条件，那就直接退出。那legacy_queue里面判断的是什么条件呢？我们来看它的代码。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">legacy_queue</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sigpending</span> <span class="token operator">*</span>signals<span class="token punctuation">,</span> <span class="token keyword">int</span> sig<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>sig <span class="token operator">&lt;</span> SIGRTMIN<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">sigismember</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>signals<span class="token operator">-&gt;</span>signal<span class="token punctuation">,</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">SIGRTMIN    <span class="token number">32</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">SIGRTMAX    _NSIG</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">_NSIG       <span class="token number">64</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当信号小于SIGRTMIN，也即32的时候，如果我们发现这个信号已经在集合里面了，就直接退出了。这样会造成什么现象呢？就是信号的丢失。例如，我们发送给进程100个SIGUSR1（对应的信号为10），那最终能够被我们的信号处理函数处理的信号有多少呢？这就不好说了，比如总共5个SIGUSR1，分别是A、B、C、D、E。</p>
<p>如果这五个信号来得太密。A来了，但是信号处理函数还没来得及处理，B、C、D、E就都来了。根据上面的逻辑，因为A已经将SIGUSR1放在sigset_t集合中了，因而后面四个都要丢失。 如果是另一种情况，A来了已经被信号处理函数处理了，内核在调用信号处理函数之前，我们会将集合中的标志位清除，这个时候B再来，B还是会进入集合，还是会被处理，也就不会丢。</p>
<p>这样信号能够处理多少，和信号处理函数什么时候被调用，信号多大频率被发送，都有关系，而且从后面的分析，我们可以知道，信号处理函数的调用时间也是不确定的。看小于32的信号如此不靠谱，我们就称它为<strong>不可靠信号</strong>。</p>
<p>如果大于32的信号是什么情况呢？我们接着看。接下来，__sigqueue_alloc会分配一个struct sigqueue对象，然后通过list_add_tail挂在struct sigpending里面的链表上。这样就靠谱多了是不是？如果发送过来100个信号，变成链表上的100项，都不会丢，哪怕相同的信号发送多遍，也处理多遍。因此，大于32的信号我们称为<strong>可靠信号</strong>。当然，队列的长度也是有限制的，如果我们执行ulimit命令，可以看到，这个限制pending signals (-i) 15408。</p>
<p>当信号挂到了task_struct结构之后，最后我们需要调用complete_signal。这里面的逻辑也很简单，就是说，既然这个进程有了一个新的信号，赶紧找一个线程处理一下吧。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">complete_signal</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> group<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">signal_struct</span> <span class="token operator">*</span>signal <span class="token operator">=</span> p<span class="token operator">-&gt;</span>signal<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>t<span class="token punctuation">;</span>

    <span class="token comment">/*
     * Now find a thread we can wake up to take the signal off the queue.
     *
     * If the main thread wants the signal, it gets first crack.
     * Probably the least surprising to the average bear.
     */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">wants_signal</span><span class="token punctuation">(</span>sig<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span>
        t <span class="token operator">=</span> p<span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>group <span class="token operator">||</span> <span class="token function">thread_group_empty</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment">/*
         * There is just one thread and it does not need to be woken.
         * It will dequeue unblocked signals before it runs again.
         */</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">/*
         * Otherwise try to find a suitable thread.
         */</span>
        t <span class="token operator">=</span> signal<span class="token operator">-&gt;</span>curr_target<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">wants_signal</span><span class="token punctuation">(</span>sig<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            t <span class="token operator">=</span> <span class="token function">next_thread</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> signal<span class="token operator">-&gt;</span>curr_target<span class="token punctuation">)</span>
                <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        signal<span class="token operator">-&gt;</span>curr_target <span class="token operator">=</span> t<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/*
     * The signal is already in the shared-pending queue.
     * Tell the chosen thread to wake up and dequeue it.
     */</span>
    <span class="token function">signal_wake_up</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> sig <span class="token operator">==</span> SIGKILL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在找到了一个进程或者线程的task_struct之后，我们要调用signal_wake_up，来企图唤醒它，signal_wake_up会调用signal_wake_up_state。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">signal_wake_up_state</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>t<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> state<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">set_tsk_thread_flag</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> TIF_SIGPENDING<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">wake_up_state</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> state <span class="token operator">|</span> TASK_INTERRUPTIBLE<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">kick_process</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>signal_wake_up_state里面主要做了两件事情。第一，就是给这个线程设置TIF_SIGPENDING，这就说明其实信号的处理和进程的调度是采取这样一种类似的机制。还记得咱们调度的时候是怎么操作的吗？</p>
<p>当发现一个进程应该被调度的时候，我们并不直接把它赶下来，而是设置一个标识位TIF_NEED_RESCHED，表示等待调度，然后等待系统调用结束或者中断处理结束，从内核态返回用户态的时候，调用schedule函数进行调度。信号也是类似的，当信号来的时候，我们并不直接处理这个信号，而是设置一个标识位TIF_SIGPENDING，来表示已经有信号等待处理。同样等待系统调用结束，或者中断处理结束，从内核态返回用户态的时候，再进行信号的处理。</p>
<p>signal_wake_up_state的第二件事情，就是试图唤醒这个进程或者线程。wake_up_state会调用try_to_wake_up方法。这个函数我们讲进程的时候讲过，就是将这个进程或者线程设置为TASK_RUNNING，然后放在运行队列中，这个时候，当随着时钟不断的滴答，迟早会被调用。如果wake_up_state返回0，说明进程或者线程已经是TASK_RUNNING状态了，如果它在另外一个CPU上运行，则调用kick_process发送一个处理器间中断，强制那个进程或者线程重新调度，重新调度完毕后，会返回用户态运行。这是一个时机会检查TIF_SIGPENDING标识位。</p>
<h4 id="33-2-信号的处理"><a href="#33-2-信号的处理" class="headerlink" title="33.2 信号的处理"></a>33.2 信号的处理</h4><p>就是在从系统调用或者中断返回的时候，咱们讲调度的时候讲过，无论是从系统调用返回还是从中断返回，都会调用exit_to_usermode_loop，只不过我们上次主要关注了_TIF_NEED_RESCHED这个标识位，这次我们重点关注<strong>_TIF_SIGPENDING</strong>标识位。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">exit_to_usermode_loop</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span>regs<span class="token punctuation">,</span> u32 cached_flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cached_flags <span class="token operator">&amp;</span> _TIF_NEED_RESCHED<span class="token punctuation">)</span>
            <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token comment">/* deal with pending signal delivery */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cached_flags <span class="token operator">&amp;</span> _TIF_SIGPENDING<span class="token punctuation">)</span>
            <span class="token function">do_signal</span><span class="token punctuation">(</span>regs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>cached_flags <span class="token operator">&amp;</span> EXIT_TO_USERMODE_LOOP_FLAGS<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果在前一个环节中，已经设置了_TIF_SIGPENDING，我们就调用do_signal进行处理。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">do_signal</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span>regs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">ksignal</span> ksig<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">get_signal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ksig<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* Whee! Actually deliver the signal.  */</span>
        <span class="token function">handle_signal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ksig<span class="token punctuation">,</span> regs<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* Did we come from a system call? */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">syscall_get_nr</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> regs<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* Restart the system call - no handlers present */</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token function">syscall_get_error</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> regs<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token operator">-</span>ERESTARTNOHAND<span class="token operator">:</span>
        <span class="token keyword">case</span> <span class="token operator">-</span>ERESTARTSYS<span class="token operator">:</span>
        <span class="token keyword">case</span> <span class="token operator">-</span>ERESTARTNOINTR<span class="token operator">:</span>
            regs<span class="token operator">-&gt;</span>ax <span class="token operator">=</span> regs<span class="token operator">-&gt;</span>orig_ax<span class="token punctuation">;</span>
            regs<span class="token operator">-&gt;</span>ip <span class="token operator">-=</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>

        <span class="token keyword">case</span> <span class="token operator">-</span>ERESTART_RESTARTBLOCK<span class="token operator">:</span>
            regs<span class="token operator">-&gt;</span>ax <span class="token operator">=</span> <span class="token function">get_nr_restart_syscall</span><span class="token punctuation">(</span>regs<span class="token punctuation">)</span><span class="token punctuation">;</span>
            regs<span class="token operator">-&gt;</span>ip <span class="token operator">-=</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">restore_saved_sigmask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>do_signal会调用handle_signal。按说，信号处理就是调用用户提供的信号处理函数，但是这事儿没有看起来这么简单，因为信号处理函数是在用户态的。</p>
<p>咱们又要来回忆系统调用的过程了。这个进程当时在用户态执行到某一行Line A，调用了一个系统调用，在进入内核的那一刻，在内核pt_regs里面保存了用户态执行到了Line A。现在我们从系统调用返回用户态了，按说应该从pt_regs拿出Line A，然后接着Line A执行下去，但是为了响应信号，我们不能回到用户态的时候返回Line A了，而是应该返回信号处理函数的起始地址。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span>
<span class="token function">handle_signal</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ksignal</span> <span class="token operator">*</span>ksig<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span>regs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    bool stepping<span class="token punctuation">,</span> failed<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* Are we from a system call? */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">syscall_get_nr</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> regs<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* If so, check system call restarting.. */</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token function">syscall_get_error</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> regs<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token operator">-</span>ERESTART_RESTARTBLOCK<span class="token operator">:</span>
        <span class="token keyword">case</span> <span class="token operator">-</span>ERESTARTNOHAND<span class="token operator">:</span>
            regs<span class="token operator">-&gt;</span>ax <span class="token operator">=</span> <span class="token operator">-</span>EINTR<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token operator">-</span>ERESTARTSYS<span class="token operator">:</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>ksig<span class="token operator">-&gt;</span>ka<span class="token punctuation">.</span>sa<span class="token punctuation">.</span>sa_flags <span class="token operator">&amp;</span> SA_RESTART<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                regs<span class="token operator">-&gt;</span>ax <span class="token operator">=</span> <span class="token operator">-</span>EINTR<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token comment">/* fallthrough */</span>
        <span class="token keyword">case</span> <span class="token operator">-</span>ERESTARTNOINTR<span class="token operator">:</span>
            regs<span class="token operator">-&gt;</span>ax <span class="token operator">=</span> regs<span class="token operator">-&gt;</span>orig_ax<span class="token punctuation">;</span>
            regs<span class="token operator">-&gt;</span>ip <span class="token operator">-=</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    failed <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">setup_rt_frame</span><span class="token punctuation">(</span>ksig<span class="token punctuation">,</span> regs<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">signal_setup_done</span><span class="token punctuation">(</span>failed<span class="token punctuation">,</span> ksig<span class="token punctuation">,</span> stepping<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个时候，我们就需要干预和自己来定制pt_regs了。这个时候，我们要看，是否从系统调用中返回。如果是从系统调用返回的话，还要区分我们是从系统调用中正常返回，还是在一个非运行状态的系统调用中，因为会被信号中断而返回。</p>
<p>我们这里解析一个最复杂的场景。还记得咱们解析进程调度的时候，我们举的一个例子，就是从一个tap网卡中读取数据。当时我们主要关注schedule那一行，也即如果当发现没有数据的时候，就调用schedule，自己进入等待状态，然后将CPU让给其他进程。具体的代码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> ssize_t <span class="token function">tap_do_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">tap_queue</span> <span class="token operator">*</span>q<span class="token punctuation">,</span>
               <span class="token keyword">struct</span> <span class="token class-name">iov_iter</span> <span class="token operator">*</span>to<span class="token punctuation">,</span>
               <span class="token keyword">int</span> noblock<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>noblock<span class="token punctuation">)</span>
            <span class="token function">prepare_to_wait</span><span class="token punctuation">(</span><span class="token function">sk_sleep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-&gt;</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait<span class="token punctuation">,</span>
                    TASK_INTERRUPTIBLE<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* Read frames from the queue */</span>
        skb <span class="token operator">=</span> <span class="token function">skb_array_consume</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-&gt;</span>skb_array<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>skb<span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>noblock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            ret <span class="token operator">=</span> <span class="token operator">-</span>EAGAIN<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">signal_pending</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            ret <span class="token operator">=</span> <span class="token operator">-</span>ERESTARTSYS<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">/* Nothing to read, let's sleep */</span>
        <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里我们关注和信号相关的部分。这其实是一个信号中断系统调用的典型逻辑。</p>
<p>首先，我们把当前进程或者线程的状态设置为TASK_INTERRUPTIBLE，这样才能是使这个系统调用可以被中断。</p>
<p>其次，可以被中断的系统调用往往是比较慢的调用，并且会因为数据不就绪而通过schedule让出CPU进入等待状态。在发送信号的时候，我们除了设置这个进程和线程的_TIF_SIGPENDING标识位之外，还试图唤醒这个进程或者线程，也就是将它从等待状态中设置为TASK_RUNNING。</p>
<p>当这个进程或者线程再次运行的时候，我们根据进程调度第一定律，从schedule函数中返回，然后再次进入while循环。由于这个进程或者线程是由信号唤醒的，而不是因为数据来了而唤醒的，因而是读不到数据的，但是在signal_pending函数中，我们检测到了_TIF_SIGPENDING标识位，这说明系统调用没有真的做完，于是返回一个错误ERESTARTSYS，然后带着这个错误从系统调用返回。</p>
<p>然后，我们到了exit_to_usermode_loop-&gt;do_signal-&gt;handle_signal。在这里面，当发现出现错误ERESTARTSYS的时候，我们就知道这是从一个没有调用完的系统调用返回的，设置系统调用错误码EINTR。</p>
<p>接下来，我们就开始折腾pt_regs了，主要通过调用setup_rt_frame-&gt;__setup_rt_frame。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">__setup_rt_frame</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">ksignal</span> <span class="token operator">*</span>ksig<span class="token punctuation">,</span>
                sigset_t <span class="token operator">*</span>set<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span>regs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">rt_sigframe</span> __user <span class="token operator">*</span>frame<span class="token punctuation">;</span>
    <span class="token keyword">void</span> __user <span class="token operator">*</span>fp <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> err <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    frame <span class="token operator">=</span> <span class="token function">get_sigframe</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ksig<span class="token operator">-&gt;</span>ka<span class="token punctuation">,</span> regs<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rt_sigframe</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    put_user_try <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token comment">/* Set up to return from userspace.  If provided, use a stub
           already in userspace.  */</span>
        <span class="token comment">/* x86-64 should always use SA_RESTORER. */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ksig<span class="token operator">-&gt;</span>ka<span class="token punctuation">.</span>sa<span class="token punctuation">.</span>sa_flags <span class="token operator">&amp;</span> SA_RESTORER<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">put_user_ex</span><span class="token punctuation">(</span>ksig<span class="token operator">-&gt;</span>ka<span class="token punctuation">.</span>sa<span class="token punctuation">.</span>sa_restorer<span class="token punctuation">,</span> <span class="token operator">&amp;</span>frame<span class="token operator">-&gt;</span>pretcode<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token function">put_user_catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>

    err <span class="token operator">|=</span> <span class="token function">setup_sigcontext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>frame<span class="token operator">-&gt;</span>uc<span class="token punctuation">.</span>uc_mcontext<span class="token punctuation">,</span> fp<span class="token punctuation">,</span> regs<span class="token punctuation">,</span> set<span class="token operator">-&gt;</span>sig<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    err <span class="token operator">|=</span> <span class="token function">__copy_to_user</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>frame<span class="token operator">-&gt;</span>uc<span class="token punctuation">.</span>uc_sigmask<span class="token punctuation">,</span> set<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* Set up registers for signal handler */</span>
    regs<span class="token operator">-&gt;</span>di <span class="token operator">=</span> sig<span class="token punctuation">;</span>
    <span class="token comment">/* In case the signal handler was declared without prototypes */</span>
    regs<span class="token operator">-&gt;</span>ax <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    regs<span class="token operator">-&gt;</span>si <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>frame<span class="token operator">-&gt;</span>info<span class="token punctuation">;</span>
    regs<span class="token operator">-&gt;</span>dx <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>frame<span class="token operator">-&gt;</span>uc<span class="token punctuation">;</span>
    regs<span class="token operator">-&gt;</span>ip <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> ksig<span class="token operator">-&gt;</span>ka<span class="token punctuation">.</span>sa<span class="token punctuation">.</span>sa_handler<span class="token punctuation">;</span>

    regs<span class="token operator">-&gt;</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span>frame<span class="token punctuation">;</span>
    regs<span class="token operator">-&gt;</span>cs <span class="token operator">=</span> __USER_CS<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>frame的类型是rt_sigframe。frame的意思是帧。我们只有在学习栈的时候，提到过栈帧的概念。对的，这个frame就是一个栈帧。</p>
<p>我们在get_sigframe中会得到pt_regs的sp变量，也就是原来这个程序在用户态的栈顶指针，然后get_sigframe中，我们会将sp减去sizeof(struct rt_sigframe)，也就是把这个栈帧塞到了栈里面，然后我们又在__setup_rt_frame中把regs-&gt;sp设置成等于frame。这就相当于强行在程序原来的用户态的栈里面插入了一个栈帧，并在最后将regs-&gt;ip设置为用户定义的信号处理函数sa_handler。这意味着，本来返回用户态应该接着原来的代码执行的，现在不了，要执行sa_handler了。那执行完了以后呢？按照函数栈的规则，弹出上一个栈帧来，也就是弹出了frame。</p>
<p>那如果我们假设sa_handler成功返回了，怎么回到程序原来在用户态运行的地方呢？玄机就在frame里面。要想恢复原来运行的地方，首先，原来的pt_regs不能丢，这个没问题，是在setup_sigcontext里面，将原来的pt_regs保存在了frame中的uc_mcontext里面。</p>
<p>另外，很重要的一点，程序如何跳过去呢？在__setup_rt_frame中，还有一个不引起重视的操作，那就是通过put_user_ex，将sa_restorer放到了frame-&gt;pretcode里面，而且还是按照函数栈的规则。函数栈里面包含了函数执行完跳回去的地址。当sa_handler执行完之后，弹出的函数栈是frame，也就应该跳到sa_restorer的地址。这是什么地址呢？</p>
<p>咱们在sigaction介绍的时候就没有介绍它，在Glibc的__libc_sigaction函数中也没有注意到，它被赋值成了restore_rt。这其实就是sa_handler执行完毕之后，马上要执行的函数。从名字我们就能感觉到，它将恢复原来程序运行的地方。</p>
<p>在Glibc中，我们可以找到它的定义，它竟然调用了一个系统调用，系统调用号为__NR_rt_sigreturn。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">RESTORE</span> <span class="token punctuation">(</span>restore_rt<span class="token punctuation">,</span> __NR_rt_sigreturn<span class="token punctuation">)</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">RESTORE</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> syscall<span class="token punctuation">)</span> <span class="token function">RESTORE2</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> syscall<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span> <span class="token expression"><span class="token function">RESTORE2</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> syscall<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token keyword">asm</span>                                     </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token punctuation">(</span>                                     </span><span class="token punctuation">\</span>
   <span class="token string">".LSTART_"</span> <span class="token expression"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">name</span> </span></span><span class="token string">":\n"</span>               <span class="token punctuation">\</span>
   <span class="token string">"    .type __"</span> <span class="token expression"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">name</span> </span></span><span class="token string">",@function\n"</span>  <span class="token punctuation">\</span>
   <span class="token string">"__"</span> <span class="token expression"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">name</span> </span></span><span class="token string">":\n"</span>                     <span class="token punctuation">\</span>
   <span class="token string">"    movq $"</span> <span class="token expression"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">syscall</span> </span></span><span class="token string">", %rax\n"</span>     <span class="token punctuation">\</span>
   <span class="token string">"    syscall\n"</span>                      <span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们可以在内核里面找到__NR_rt_sigreturn对应的系统调用。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">asmlinkage <span class="token keyword">long</span> <span class="token function">sys_rt_sigreturn</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span>regs <span class="token operator">=</span> <span class="token function">current_pt_regs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rt_sigframe</span> __user <span class="token operator">*</span>frame<span class="token punctuation">;</span>
    sigset_t set<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> uc_flags<span class="token punctuation">;</span>

    frame <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rt_sigframe</span> __user <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>regs<span class="token operator">-&gt;</span>sp <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__copy_from_user</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>set<span class="token punctuation">,</span> <span class="token operator">&amp;</span>frame<span class="token operator">-&gt;</span>uc<span class="token punctuation">.</span>uc_sigmask<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">goto</span> badframe<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__get_user</span><span class="token punctuation">(</span>uc_flags<span class="token punctuation">,</span> <span class="token operator">&amp;</span>frame<span class="token operator">-&gt;</span>uc<span class="token punctuation">.</span>uc_flags<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">goto</span> badframe<span class="token punctuation">;</span>

    <span class="token function">set_current_blocked</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">restore_sigcontext</span><span class="token punctuation">(</span>regs<span class="token punctuation">,</span> <span class="token operator">&amp;</span>frame<span class="token operator">-&gt;</span>uc<span class="token punctuation">.</span>uc_mcontext<span class="token punctuation">,</span> uc_flags<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">goto</span> badframe<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> regs<span class="token operator">-&gt;</span>ax<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里面，我们把上次填充的那个rt_sigframe拿出来，然后restore_sigcontext将pt_regs恢复成为原来用户态的样子。从这个系统调用返回的时候，应用还误以为从上次的系统调用返回的呢。</p>
<p>至此，整个信号处理过程才全部结束。</p>
<h4 id="33-3-总结"><a href="#33-3-总结" class="headerlink" title="33.3 总结"></a>33.3 总结</h4><p>信号的发送与处理是一个复杂的过程，这里来总结一下。</p>
<ol>
<li>假设我们有一个进程A，main函数里面调用系统调用进入内核。</li>
<li>按照系统调用的原理，会将用户态栈的信息保存在pt_regs里面，也即记住原来用户态是运行到了line A的地方。</li>
<li>在内核中执行系统调用读取数据。</li>
<li>当发现没有什么数据可读取的时候，只好进入睡眠状态，并且调用schedule让出CPU，这是进程调度第一定律。</li>
<li>将进程状态设置为TASK_INTERRUPTIBLE，可中断的睡眠状态，也即如果有信号来的话，是可以唤醒它的。</li>
<li>其他的进程或者shell发送一个信号，有四个函数可以调用kill、tkill、tgkill、rt_sigqueueinfo。</li>
<li>四个发送信号的函数，在内核中最终都是调用do_send_sig_info。</li>
<li>do_send_sig_info调用send_signal给进程A发送一个信号，其实就是找到进程A的task_struct，或者加入信号集合，为不可靠信号，或者加入信号链表，为可靠信号。</li>
<li>do_send_sig_info调用signal_wake_up唤醒进程A。</li>
<li>进程A重新进入运行状态TASK_RUNNING，根据进程调度第一定律，一定会接着schedule运行。</li>
<li>进程A被唤醒后，检查是否有信号到来，如果没有，重新循环到一开始，尝试再次读取数据，如果还是没有数据，再次进入TASK_INTERRUPTIBLE，即可中断的睡眠状态。</li>
<li>当发现有信号到来的时候，就返回当前正在执行的系统调用，并返回一个错误表示系统调用被中断了。</li>
<li>系统调用返回的时候，会调用exit_to_usermode_loop。这是一个处理信号的时机。</li>
<li>调用do_signal开始处理信号。</li>
<li>根据信号，得到信号处理函数sa_handler，然后修改pt_regs中的用户态栈的信息，让pt_regs指向sa_handler。同时修改用户态的栈，插入一个栈帧sa_restorer，里面保存了原来的指向line A的pt_regs，并且设置让sa_handler运行完毕后，跳到sa_restorer运行。</li>
<li>返回用户态，由于pt_regs已经设置为sa_handler，则返回用户态执行sa_handler。</li>
<li>sa_handler执行完毕后，信号处理函数就执行完了，接着根据第15步对于用户态栈帧的修改，会跳到sa_restorer运行。</li>
<li>sa_restorer会调用系统调用rt_sigreturn再次进入内核。</li>
<li>在内核中，rt_sigreturn恢复原来的pt_regs，重新指向line A。</li>
<li>从rt_sigreturn返回用户态，还是调用exit_to_usermode_loop。</li>
<li>这次因为pt_regs已经指向line A了，于是就到了进程A中，接着系统调用之后运行，当然这个系统调用返回的是它被中断了，没有执行完的错误。</li>
</ol>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/信号的发送与处理过程.png" alt="信号的发送与处理过程"></p>
<h3 id="34-管道"><a href="#34-管道" class="headerlink" title="34. 管道"></a>34. 管道</h3><p>管道的创建，需要通过下面这个系统调用。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pipe</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在这里，我们创建了一个管道pipe，返回了两个文件描述符，这表示管道的两端，一个是管道的读取端描述符fd[0]，另一个是管道的写入端描述符fd[1]。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/创建管道.png" alt="创建管道"></p>
<p>我们来看在内核里面是如何实现的。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE1</span><span class="token punctuation">(</span>pipe<span class="token punctuation">,</span> <span class="token keyword">int</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> fildes<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">sys_pipe2</span><span class="token punctuation">(</span>fildes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">SYSCALL_DEFINE2</span><span class="token punctuation">(</span>pipe2<span class="token punctuation">,</span> <span class="token keyword">int</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> fildes<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>files<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> fd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> error<span class="token punctuation">;</span>

    error <span class="token operator">=</span> <span class="token function">__do_pipe_flags</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> files<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token function">copy_to_user</span><span class="token punctuation">(</span>fildes<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            error <span class="token operator">=</span> <span class="token operator">-</span>EFAULT<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">fd_install</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> files<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">fd_install</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> files<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> error<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在内核中，主要的逻辑在pipe2系统调用中。这里面要创建一个数组files，用来存放管道的两端的打开文件，另一个数组fd存放管道的两端的文件描述符。如果调用__do_pipe_flags没有错误，那就调用fd_install，将两个fd和两个struct file关联起来。这一点和打开一个文件的过程很像了。</p>
<p>我们来看__do_pipe_flags。这里面调用了create_pipe_files，然后生成了两个fd。从这里可以看出，fd[0]是用于读的，fd[1]是用于写的。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">__do_pipe_flags</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token operator">*</span>files<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> error<span class="token punctuation">;</span>
    <span class="token keyword">int</span> fdw<span class="token punctuation">,</span> fdr<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    error <span class="token operator">=</span> <span class="token function">create_pipe_files</span><span class="token punctuation">(</span>files<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    error <span class="token operator">=</span> <span class="token function">get_unused_fd_flags</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    fdr <span class="token operator">=</span> error<span class="token punctuation">;</span>

    error <span class="token operator">=</span> <span class="token function">get_unused_fd_flags</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    fdw <span class="token operator">=</span> error<span class="token punctuation">;</span>

    fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> fdr<span class="token punctuation">;</span>
    fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> fdw<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>创建一个管道，大部分的逻辑其实都是在create_pipe_files函数里面实现的。这一章第一节的时候，我们说过，命名管道是创建在文件系统上的。从这里我们可以看出，匿名管道，也是创建在文件系统上的，只不过是一种特殊的文件系统，创建一个特殊的文件，对应一个特殊的inode，就是这里面的get_pipe_inode。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">create_pipe_files</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token operator">*</span>res<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> err<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode <span class="token operator">=</span> <span class="token function">get_pipe_inode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>f<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">path</span> path<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    path<span class="token punctuation">.</span>dentry <span class="token operator">=</span> <span class="token function">d_alloc_pseudo</span><span class="token punctuation">(</span>pipe_mnt<span class="token operator">-&gt;</span>mnt_sb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>empty_name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    path<span class="token punctuation">.</span>mnt <span class="token operator">=</span> <span class="token function">mntget</span><span class="token punctuation">(</span>pipe_mnt<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">d_instantiate</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span>dentry<span class="token punctuation">,</span> inode<span class="token punctuation">)</span><span class="token punctuation">;</span>

    f <span class="token operator">=</span> <span class="token function">alloc_file</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>path<span class="token punctuation">,</span> FMODE_WRITE<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pipefifo_fops<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    f<span class="token operator">-&gt;</span>f_flags <span class="token operator">=</span> O_WRONLY <span class="token operator">|</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span>O_NONBLOCK <span class="token operator">|</span> O_DIRECT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    f<span class="token operator">-&gt;</span>private_data <span class="token operator">=</span> inode<span class="token operator">-&gt;</span>i_pipe<span class="token punctuation">;</span>

    res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">alloc_file</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>path<span class="token punctuation">,</span> FMODE_READ<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pipefifo_fops<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">path_get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-&gt;</span>private_data <span class="token operator">=</span> inode<span class="token operator">-&gt;</span>i_pipe<span class="token punctuation">;</span>
    res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-&gt;</span>f_flags <span class="token operator">=</span> O_RDONLY <span class="token operator">|</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> O_NONBLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从get_pipe_inode的实现，我们可以看出，匿名管道来自一个特殊的文件系统pipefs。这个文件系统被挂载后，我们就得到了struct vfsmount *pipe_mnt。然后挂载的文件系统的superblock就变成了：pipe_mnt-&gt;mnt_sb。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">file_system_type</span> pipe_fs_type <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>name       <span class="token operator">=</span> <span class="token string">"pipefs"</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>mount      <span class="token operator">=</span> pipefs_mount<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>kill_sb    <span class="token operator">=</span> kill_anon_super<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">init_pipe_fs</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> err <span class="token operator">=</span> <span class="token function">register_filesystem</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pipe_fs_type<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        pipe_mnt <span class="token operator">=</span> <span class="token function">kern_mount</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pipe_fs_type<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span> <span class="token function">get_pipe_inode</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode <span class="token operator">=</span> <span class="token function">new_inode_pseudo</span><span class="token punctuation">(</span>pipe_mnt<span class="token operator">-&gt;</span>mnt_sb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">pipe_inode_info</span> <span class="token operator">*</span>pipe<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    inode<span class="token operator">-&gt;</span>i_ino <span class="token operator">=</span> <span class="token function">get_next_ino</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    pipe <span class="token operator">=</span> <span class="token function">alloc_pipe_info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    inode<span class="token operator">-&gt;</span>i_pipe <span class="token operator">=</span> pipe<span class="token punctuation">;</span>
    pipe<span class="token operator">-&gt;</span>files <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    pipe<span class="token operator">-&gt;</span>readers <span class="token operator">=</span> pipe<span class="token operator">-&gt;</span>writers <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    inode<span class="token operator">-&gt;</span>i_fop <span class="token operator">=</span> <span class="token operator">&amp;</span>pipefifo_fops<span class="token punctuation">;</span>
    inode<span class="token operator">-&gt;</span>i_state <span class="token operator">=</span> I_DIRTY<span class="token punctuation">;</span>
    inode<span class="token operator">-&gt;</span>i_mode <span class="token operator">=</span> S_IFIFO <span class="token operator">|</span> S_IRUSR <span class="token operator">|</span> S_IWUSR<span class="token punctuation">;</span>
    inode<span class="token operator">-&gt;</span>i_uid <span class="token operator">=</span> <span class="token function">current_fsuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    inode<span class="token operator">-&gt;</span>i_gid <span class="token operator">=</span> <span class="token function">current_fsgid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    inode<span class="token operator">-&gt;</span>i_atime <span class="token operator">=</span> inode<span class="token operator">-&gt;</span>i_mtime <span class="token operator">=</span> inode<span class="token operator">-&gt;</span>i_ctime <span class="token operator">=</span> <span class="token function">current_time</span><span class="token punctuation">(</span>inode<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> inode<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们从new_inode_pseudo函数创建一个inode。这里面开始填写Inode的成员，这里和文件系统的很像。这里值得注意的是struct pipe_inode_info，这个结构里面有个成员是<code>struct pipe_buffer *bufs</code>。我们可以知道，<strong>所谓的匿名管道，其实就是内核里面的一串缓存</strong>。</p>
<p>另外一个需要注意的是pipefifo_fops，将来我们对于文件描述符的操作，在内核里面都是对应这里面的操作。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> pipefifo_fops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>open           <span class="token operator">=</span> fifo_open<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>llseek         <span class="token operator">=</span> no_llseek<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>read_iter      <span class="token operator">=</span> pipe_read<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>write_iter     <span class="token operator">=</span> pipe_write<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>poll           <span class="token operator">=</span> pipe_poll<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>unlocked_ioctl <span class="token operator">=</span> pipe_ioctl<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>release        <span class="token operator">=</span> pipe_release<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>fasync         <span class="token operator">=</span> pipe_fasync<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们回到create_pipe_files函数，创建完了inode，还需创建一个dentry和他对应。dentry和inode对应好了，我们就要开始创建struct file对象了。先创建用于写入的，对应的操作为pipefifo_fops；再创建读取的，对应的操作也为pipefifo_fops。然后把private_data设置为pipe_inode_info。这样从struct file这个层级上，就能直接操作底层的读写操作。</p>
<p>至此，一个匿名管道就创建成功了。如果对于fd[1]写入，调用的是pipe_write，向pipe_buffer里面写入数据；如果对于fd[0]的读入，调用的是pipe_read，也就是从pipe_buffer里面读取数据。</p>
<p>但是这个时候，两个文件描述符都是在一个进程里面的，并没有起到进程间通信的作用，怎么样才能使得管道是跨两个进程的呢？还记得创建进程调用的fork吗？在这里面，创建的子进程会复制父进程的struct files_struct，在这里面fd的数组会复制一份，但是fd指向的struct file对于同一个文件还是只有一份，这样就做到了，两个进程各有两个fd指向同一个struct file的模式，两个进程就可以通过各自的fd写入和读取同一个管道文件实现跨进程通信了。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/管道实现进程间通信.png" alt="管道实现进程间通信"></p>
<p>由于管道只能一端写入，另一端读出，所以上面的这种模式会造成混乱，因为父进程和子进程都可以写入，也都可以读出，通常的方法是父进程关闭读取的fd，只保留写入的fd，而子进程关闭写入的fd，只保留读取的fd，如果需要双向通行，则应该创建两个管道。</p>
<p>一个典型的使用管道在父子进程之间的通信代码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> fds<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pipe</span><span class="token punctuation">(</span>fds<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"pipe error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    pid_t pid<span class="token punctuation">;</span>
    pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">close</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">char</span> msg<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span>
        <span class="token function">write</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> msg<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">close</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">close</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">char</span> msg<span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token function">read</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> msg<span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">close</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"message : %s\n"</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/使用管道进行父子进程之间的通信.png" alt="使用管道进行父子进程之间的通信"></p>
<p>到这里，我们仅仅解析了使用管道进行父子进程之间的通信，但是我们在shell里面的不是这样的。在shell里面运行A|B的时候，A进程和B进程都是shell创建出来的子进程，A和B之间不存在父子关系。</p>
<p>不过，有了上面父子进程之间的管道这个基础，实现A和B之间的管道就方便多了。</p>
<p>我们首先从shell创建子进程A，然后在shell和A之间建立一个管道，其中shell保留读取端，A进程保留写入端，然后shell再创建子进程B。这又是一次fork，所以，shell里面保留的读取端的fd也被复制到了子进程B里面。这个时候，相当于shell和B都保留读取端，只要shell主动关闭读取端，就变成了一管道，写入端在A进程，读取端在B进程。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/使用管道实现shell之间的通信.png" alt="使用管道实现shell之间的通信"></p>
<p>接下来我们要做的事情就是，将这个管道的两端和输入输出关联起来。这就要用到dup2系统调用了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">dup2</span><span class="token punctuation">(</span><span class="token keyword">int</span> oldfd<span class="token punctuation">,</span> <span class="token keyword">int</span> newfd<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个系统调用，将老的文件描述符赋值给新的文件描述符，让newfd的值和oldfd一样。</p>
<p>我们还是回忆一下，在files_struct里面，有这样一个表，下标是fd，内容指向一个打开的文件struct file。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">files_struct</span> <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">file</span> __rcu <span class="token operator">*</span> fd_array<span class="token punctuation">[</span>NR_OPEN_DEFAULT<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在这个表里面，前三项是定下来的，其中第零项STDIN_FILENO表示标准输入，第一项STDOUT_FILENO表示标准输出，第三项STDERR_FILENO表示错误输出。</p>
<p>在A进程中，写入端可以做这样的操作：dup2(fd[1],STDOUT_FILENO)，将STDOUT_FILENO（也即第一项）不再指向标准输出，而是指向创建的管道文件，那么以后往标准输出写入的任何东西，都会写入管道文件。</p>
<p>在B进程中，读取端可以做这样的操作，dup2(fd[0],STDIN_FILENO)，将STDIN_FILENO也即第零项不再指向标准输入，而是指向创建的管道文件，那么以后从标准输入读取的任何东西，都来自于管道文件。</p>
<p>至此，我们才将A|B的功能完成。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/使用管道实现shell之间的通信结果.png" alt="使用管道实现shell之间的通信结果"></p>
<p>为了模拟A|B的情况，我们可以将前面的那一段代码，进一步修改成为下面这样：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> fds<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pipe</span><span class="token punctuation">(</span>fds<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"pipe error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    pid_t pid<span class="token punctuation">;</span>
    pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">dup2</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> STDOUT_FILENO<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">close</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">close</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">execlp</span><span class="token punctuation">(</span><span class="token string">"ps"</span><span class="token punctuation">,</span> <span class="token string">"ps"</span><span class="token punctuation">,</span> <span class="token string">"-ef"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">dup2</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> STDIN_FILENO<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">close</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">close</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">execlp</span><span class="token punctuation">(</span><span class="token string">"grep"</span><span class="token punctuation">,</span> <span class="token string">"grep"</span><span class="token punctuation">,</span> <span class="token string">"systemd"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来，我们来看命名管道。我们在讲命令的时候讲过，命名管道需要事先通过命令mkfifo，进行创建。如果是通过代码创建命名管道，也有一个函数，但是这不是一个系统调用，而是Glibc提供的函数。它的定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span>
<span class="token function">mkfifo</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> mode_t mode<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  dev_t dev <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">__xmknod</span> <span class="token punctuation">(</span>_MKNOD_VER<span class="token punctuation">,</span> path<span class="token punctuation">,</span> mode <span class="token operator">|</span> S_IFIFO<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span>
<span class="token function">__xmknod</span> <span class="token punctuation">(</span><span class="token keyword">int</span> vers<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> mode_t mode<span class="token punctuation">,</span> dev_t <span class="token operator">*</span>dev<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span> k_dev<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">/* We must convert the value to dev_t type used by the kernel.  */</span>
  k_dev <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>dev<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1ULL</span> <span class="token operator">&lt;&lt;</span> <span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">return</span> <span class="token function">INLINE_SYSCALL</span> <span class="token punctuation">(</span>mknodat<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> AT_FDCWD<span class="token punctuation">,</span> path<span class="token punctuation">,</span> mode<span class="token punctuation">,</span>
                         <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span> k_dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Glibc的mkfifo函数会调用mknodat系统调用，还记得咱们学字符设备的时候，创建一个字符设备的时候，也是调用的mknod。这里命名管道也是一个设备，因而我们也用mknod。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE4</span><span class="token punctuation">(</span>mknodat<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> dfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> filename<span class="token punctuation">,</span> umode_t<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> <span class="token keyword">unsigned</span><span class="token punctuation">,</span> dev<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span>dentry<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">path</span> path<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> lookup_flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
retry<span class="token operator">:</span>
    dentry <span class="token operator">=</span> <span class="token function">user_path_create</span><span class="token punctuation">(</span>dfd<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> <span class="token operator">&amp;</span>path<span class="token punctuation">,</span> lookup_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>mode <span class="token operator">&amp;</span> S_IFMT<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">case</span> S_IFIFO<span class="token operator">:</span> <span class="token keyword">case</span> S_IFSOCK<span class="token operator">:</span>
            error <span class="token operator">=</span> <span class="token function">vfs_mknod</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span>dentry<span class="token operator">-&gt;</span>d_inode<span class="token punctuation">,</span>dentry<span class="token punctuation">,</span>mode<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于mknod的解析，我们在字符设备那一节已经解析过了，先是通过user_path_create对于这个管道文件创建一个dentry，然后因为是S_IFIFO，所以调用vfs_mknod。由于这个管道文件是创建在一个普通文件系统上的，假设是在ext4文件上，于是vfs_mknod会调用ext4_dir_inode_operations的mknod，也即会调用ext4_mknod。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">inode_operations</span> ext4_dir_inode_operations <span class="token operator">=</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">.</span>mknod      <span class="token operator">=</span> ext4_mknod<span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ext4_mknod</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>dir<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span>dentry<span class="token punctuation">,</span>
              umode_t mode<span class="token punctuation">,</span> dev_t rdev<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    handle_t <span class="token operator">*</span>handle<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    inode <span class="token operator">=</span> <span class="token function">ext4_new_inode_start_handle</span><span class="token punctuation">(</span>dir<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dentry<span class="token operator">-&gt;</span>d_name<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>
                        <span class="token constant">NULL</span><span class="token punctuation">,</span> EXT4_HT_DIR<span class="token punctuation">,</span> credits<span class="token punctuation">)</span><span class="token punctuation">;</span>
    handle <span class="token operator">=</span> <span class="token function">ext4_journal_current_handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>inode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">init_special_inode</span><span class="token punctuation">(</span>inode<span class="token punctuation">,</span> inode<span class="token operator">-&gt;</span>i_mode<span class="token punctuation">,</span> rdev<span class="token punctuation">)</span><span class="token punctuation">;</span>
        inode<span class="token operator">-&gt;</span>i_op <span class="token operator">=</span> <span class="token operator">&amp;</span>ext4_special_inode_operations<span class="token punctuation">;</span>
        err <span class="token operator">=</span> <span class="token function">ext4_add_nondir</span><span class="token punctuation">(</span>handle<span class="token punctuation">,</span> dentry<span class="token punctuation">,</span> inode<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>err <span class="token operator">&amp;&amp;</span> <span class="token function">IS_DIRSYNC</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token function">ext4_handle_sync</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>handle<span class="token punctuation">)</span>
        <span class="token function">ext4_journal_stop</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">ext4_new_inode_start_handle</span><span class="token punctuation">(</span>dir<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> qstr<span class="token punctuation">,</span> goal<span class="token punctuation">,</span> owner<span class="token punctuation">,</span>   </span><span class="token punctuation">\</span>
                    <span class="token expression">type<span class="token punctuation">,</span> nblocks<span class="token punctuation">)</span>                                  </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token function">__ext4_new_inode</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>dir<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>mode<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>qstr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>goal<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>owner<span class="token punctuation">)</span><span class="token punctuation">,</span>  </span><span class="token punctuation">\</span>
             <span class="token expression"><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>nblocks<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>

<span class="token keyword">void</span> <span class="token function">init_special_inode</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> umode_t mode<span class="token punctuation">,</span> dev_t rdev<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    inode<span class="token operator">-&gt;</span>i_mode <span class="token operator">=</span> mode<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">S_ISCHR</span><span class="token punctuation">(</span>mode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        inode<span class="token operator">-&gt;</span>i_fop <span class="token operator">=</span> <span class="token operator">&amp;</span>def_chr_fops<span class="token punctuation">;</span>
        inode<span class="token operator">-&gt;</span>i_rdev <span class="token operator">=</span> rdev<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">S_ISBLK</span><span class="token punctuation">(</span>mode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        inode<span class="token operator">-&gt;</span>i_fop <span class="token operator">=</span> <span class="token operator">&amp;</span>def_blk_fops<span class="token punctuation">;</span>
        inode<span class="token operator">-&gt;</span>i_rdev <span class="token operator">=</span> rdev<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">S_ISFIFO</span><span class="token punctuation">(</span>mode<span class="token punctuation">)</span><span class="token punctuation">)</span>
        inode<span class="token operator">-&gt;</span>i_fop <span class="token operator">=</span> <span class="token operator">&amp;</span>pipefifo_fops<span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">S_ISSOCK</span><span class="token punctuation">(</span>mode<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">;</span>   <span class="token comment">/* leave it no_open_fops */</span>
    <span class="token keyword">else</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在ext4_mknod中，ext4_new_inode_start_handle会调用__ext4_new_inode，在ext4文件系统上真的创建一个文件，但是会调用init_special_inode，创建一个内存中特殊的inode，这个函数我们在字符设备文件中也遇到过，只不过当时inode的i_fop指向的是def_chr_fops，这次换成管道文件了，inode的i_fop变成指向pipefifo_fops，这一点和匿名管道是一样的。</p>
<p>这样，管道文件就创建完毕了。</p>
<p>接下来，要打开这个管道文件，我们还是会调用文件系统的open函数。还是沿着文件系统的调用方式，一路调用到pipefifo_fops的open函数，也就是fifo_open。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">fifo_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>filp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">pipe_inode_info</span> <span class="token operator">*</span>pipe<span class="token punctuation">;</span>
    bool is_pipe <span class="token operator">=</span> inode<span class="token operator">-&gt;</span>i_sb<span class="token operator">-&gt;</span>s_magic <span class="token operator">==</span> PIPEFS_MAGIC<span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
    filp<span class="token operator">-&gt;</span>f_version <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>inode<span class="token operator">-&gt;</span>i_pipe<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        pipe <span class="token operator">=</span> inode<span class="token operator">-&gt;</span>i_pipe<span class="token punctuation">;</span>
        pipe<span class="token operator">-&gt;</span>files<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        pipe <span class="token operator">=</span> <span class="token function">alloc_pipe_info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        pipe<span class="token operator">-&gt;</span>files <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        inode<span class="token operator">-&gt;</span>i_pipe <span class="token operator">=</span> pipe<span class="token punctuation">;</span>
        <span class="token function">spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>inode<span class="token operator">-&gt;</span>i_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    filp<span class="token operator">-&gt;</span>private_data <span class="token operator">=</span> pipe<span class="token punctuation">;</span>
    filp<span class="token operator">-&gt;</span>f_mode <span class="token operator">&amp;=</span> <span class="token punctuation">(</span>FMODE_READ <span class="token operator">|</span> FMODE_WRITE<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">switch</span> <span class="token punctuation">(</span>filp<span class="token operator">-&gt;</span>f_mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> FMODE_READ<span class="token operator">:</span>
        pipe<span class="token operator">-&gt;</span>r_counter<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pipe<span class="token operator">-&gt;</span>readers<span class="token operator">++</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token function">wake_up_partner</span><span class="token punctuation">(</span>pipe<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>is_pipe <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>pipe<span class="token operator">-&gt;</span>writers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>filp<span class="token operator">-&gt;</span>f_flags <span class="token operator">&amp;</span> O_NONBLOCK<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            filp<span class="token operator">-&gt;</span>f_version <span class="token operator">=</span> pipe<span class="token operator">-&gt;</span>w_counter<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">wait_for_partner</span><span class="token punctuation">(</span>pipe<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pipe<span class="token operator">-&gt;</span>w_counter<span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">goto</span> err_rd<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> FMODE_WRITE<span class="token operator">:</span>
        pipe<span class="token operator">-&gt;</span>w_counter<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pipe<span class="token operator">-&gt;</span>writers<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token function">wake_up_partner</span><span class="token punctuation">(</span>pipe<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>is_pipe <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>pipe<span class="token operator">-&gt;</span>readers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">wait_for_partner</span><span class="token punctuation">(</span>pipe<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pipe<span class="token operator">-&gt;</span>r_counter<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">goto</span> err_wr<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> FMODE_READ <span class="token operator">|</span> FMODE_WRITE<span class="token operator">:</span>
        pipe<span class="token operator">-&gt;</span>readers<span class="token operator">++</span><span class="token punctuation">;</span>
        pipe<span class="token operator">-&gt;</span>writers<span class="token operator">++</span><span class="token punctuation">;</span>
        pipe<span class="token operator">-&gt;</span>r_counter<span class="token operator">++</span><span class="token punctuation">;</span>
        pipe<span class="token operator">-&gt;</span>w_counter<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pipe<span class="token operator">-&gt;</span>readers <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> pipe<span class="token operator">-&gt;</span>writers <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token function">wake_up_partner</span><span class="token punctuation">(</span>pipe<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在fifo_open里面，创建pipe_inode_info，这一点和匿名管道也是一样的。这个结构里面有个成员是<code>struct pipe_buffer *bufs</code>。我们可以知道，<strong>所谓的命名管道，其实是也是内核里面的一串缓存</strong>。</p>
<p>接下来，对于命名管道的写入，我们还是会调用pipefifo_fops的pipe_write函数，向pipe_buffer里面写入数据。对于命名管道的读入，我们还是会调用pipefifo_fops的pipe_read，也就是从pipe_buffer里面读取数据。</p>
<h4 id="34-1-总结"><a href="#34-1-总结" class="headerlink" title="34.1 总结"></a>34.1 总结</h4><p>无论是匿名管道，还是命名管道，在内核都是一个文件。只要是文件就要有一个inode。这里我们又用到了特殊inode、字符设备、块设备，其实都是这种特殊的inode。</p>
<p>在这种特殊的inode里面，file_operations指向管道特殊的pipefifo_fops，这个inode对应内存里面的缓存。</p>
<p>当我们用文件的open函数打开这个管道设备文件的时候，会调用pipefifo_fops里面的方法创建struct file结构，他的inode指向特殊的inode，也对应内存里面的缓存，file_operations也指向管道特殊的pipefifo_fops。</p>
<p>写入一个pipe就是从struct file结构找到缓存写入，读取一个pipe就是从struct file结构找到缓存读出。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/命名管道的创建和打开.png" alt="命名管道的创建和打开"></p>
<h3 id="35-IPC（上）"><a href="#35-IPC（上）" class="headerlink" title="35. IPC（上）"></a>35. IPC（上）</h3><p>有了进程之间共享内存的机制，两个进程可以像访问自己内存中的变量一样，访问共享内存的变量。但是同时问题也来了，当两个进程共享内存了，就会存在同时读写的问题，就需要对于共享的内存进行保护，就需要信号量这样的同步协调机制。这些也都是我们这节需要探讨的问题。下面我们就一一来看。</p>
<p>共享内存和信号量也是System V系列的进程间通信机制，所以很多地方和我们讲过的消息队列有点儿像。为了将共享内存和信号量结合起来使用，我这里定义了一个share.h头文件，里面放了一些共享内存和信号量在每个进程都需要的函数。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/ipc.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/shm.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/ipc.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/sem.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">MAX_NUM <span class="token number">128</span></span></span>

<span class="token keyword">struct</span> <span class="token class-name">shm_data</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> data<span class="token punctuation">[</span>MAX_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> datalength<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">union</span> semun <span class="token punctuation">{</span>
  <span class="token keyword">int</span> val<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">semid_ds</span> <span class="token operator">*</span>buf<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">short</span> <span class="token keyword">int</span> <span class="token operator">*</span>array<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">seminfo</span> <span class="token operator">*</span>__buf<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">get_shmid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">int</span> shmid<span class="token punctuation">;</span>
  key_t key<span class="token punctuation">;</span>

  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>key <span class="token operator">=</span> <span class="token function">ftok</span><span class="token punctuation">(</span><span class="token string">"/root/sharememory/sharememorykey"</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"ftok error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  shmid <span class="token operator">=</span> <span class="token function">shmget</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">shm_data</span><span class="token punctuation">)</span><span class="token punctuation">,</span> IPC_CREAT<span class="token operator">|</span><span class="token number">0777</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> shmid<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">get_semaphoreid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">int</span> semid<span class="token punctuation">;</span>
  key_t key<span class="token punctuation">;</span>

  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>key <span class="token operator">=</span> <span class="token function">ftok</span><span class="token punctuation">(</span><span class="token string">"/root/sharememory/semaphorekey"</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"ftok error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  semid <span class="token operator">=</span> <span class="token function">semget</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> IPC_CREAT<span class="token operator">|</span><span class="token number">0777</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> semid<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">semaphore_init</span> <span class="token punctuation">(</span><span class="token keyword">int</span> semid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">union</span> semun argument<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">short</span> values<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  values<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  argument<span class="token punctuation">.</span>array <span class="token operator">=</span> values<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">semctl</span> <span class="token punctuation">(</span>semid<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> SETALL<span class="token punctuation">,</span> argument<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">semaphore_p</span> <span class="token punctuation">(</span><span class="token keyword">int</span> semid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">sembuf</span> operations<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  operations<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>sem_num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  operations<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>sem_op <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  operations<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>sem_flg <span class="token operator">=</span> SEM_UNDO<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">semop</span> <span class="token punctuation">(</span>semid<span class="token punctuation">,</span> operations<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">semaphore_v</span> <span class="token punctuation">(</span><span class="token keyword">int</span> semid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">sembuf</span> operations<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  operations<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>sem_num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  operations<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>sem_op <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  operations<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>sem_flg <span class="token operator">=</span> SEM_UNDO<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">semop</span> <span class="token punctuation">(</span>semid<span class="token punctuation">,</span> operations<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="35-1-共享内存"><a href="#35-1-共享内存" class="headerlink" title="35.1 共享内存"></a>35.1 共享内存</h4><p>首先，创建之前，我们要有一个key来唯一标识这个共享内存。这个key可以根据文件系统上的一个文件的inode随机生成。</p>
<p>然后，我们需要创建一个共享内存，就像创建一个消息队列差不多，都是使用xxxget来创建。其中，创建共享内存使用的是下面这个函数：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">shmget</span><span class="token punctuation">(</span>key_t key<span class="token punctuation">,</span> size_t size<span class="token punctuation">,</span> <span class="token keyword">int</span> shmflag<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>其中，key就是前面生成的那个key，shmflag如果为IPC_CREAT，就表示新创建，还可以指定读写权限0777。</p>
<p>对于共享内存，需要指定一个大小size，这个一般要申请多大呢？一个最佳实践是，我们将多个进程需要共享的数据放在一个struct里面，然后这里的size就应该是这个struct的大小。这样每一个进程得到这块内存后，只要强制将类型转换为这个struct类型，就能够访问里面的共享数据了。</p>
<p>在这里，我们定义了一个struct shm_data结构。这里面有两个成员，一个是一个整型的数组，一个是数组中元素的个数。</p>
<p>生成了共享内存以后，接下来就是将这个共享内存映射到进程的虚拟地址空间中。我们使用下面这个函数来进行操作。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">shmat</span><span class="token punctuation">(</span><span class="token keyword">int</span>  shm_id<span class="token punctuation">,</span> <span class="token keyword">const</span>  <span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token keyword">int</span> shmflg<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这里面的shm_id，就是上面创建的共享内存的id，addr就是指定映射在某个地方。如果不指定，则内核会自动选择一个地址，作为返回值返回。得到了返回地址以后，我们需要将指针强制类型转换为struct shm_data结构，就可以使用这个指针设置data和datalength了。</p>
<p>当共享内存使用完毕，我们可以通过shmdt解除它到虚拟内存的映射。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">shmdt</span><span class="token punctuation">(</span><span class="token keyword">const</span>  <span class="token keyword">void</span> <span class="token operator">*</span>shmaddr<span class="token punctuation">)</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="35-2-信号量"><a href="#35-2-信号量" class="headerlink" title="35.2 信号量"></a>35.2 信号量</h4><p>信号量以集合的形式存在的。</p>
<p>首先，创建之前，我们同样需要有一个key，来唯一标识这个信号量集合。这个key同样可以根据文件系统上的一个文件的inode随机生成。</p>
<p>然后，我们需要创建一个信号量集合，同样也是使用xxxget来创建，其中创建信号量集合使用的是下面这个函数。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">semget</span><span class="token punctuation">(</span>key_t key<span class="token punctuation">,</span> <span class="token keyword">int</span> nsems<span class="token punctuation">,</span> <span class="token keyword">int</span> semflg<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这里面的key，就是前面生成的那个key，shmflag如果为IPC_CREAT，就表示新创建，还可以指定读写权限0777。</p>
<p>这里，nsems表示这个信号量集合里面有几个信号量，最简单的情况下，我们设置为1。</p>
<p>信号量往往代表某种资源的数量，如果用信号量做互斥，那往往将信号量设置为1。这就是上面代码中semaphore_init函数的作用，这里面调用semctl函数，将这个信号量集合的中的第0个信号量，也即唯一的这个信号量设置为1。</p>
<p>对于信号量，往往要定义两种操作，P操作和V操作。对应上面代码中semaphore_p函数和semaphore_v函数，semaphore_p会调用semop函数将信号量的值减一，表示申请占用一个资源，当发现当前没有资源的时候，进入等待。semaphore_v会调用semop函数将信号量的值加一，表示释放一个资源，释放之后，就允许等待中的其他进程占用这个资源。</p>
<p>我们可以用这个信号量，来保护共享内存中的struct shm_data，使得同时只有一个进程可以操作这个结构。</p>
<p>你是否记得咱们讲线程同步机制的时候，构建了一个老板分配活的场景。这里我们同样构建一个场景，分为producer.c和consumer.c，其中producer也即生产者，负责往struct shm_data塞入数据，而consumer.c负责处理struct shm_data中的数据。</p>
<p>下面我们来看producer.c的代码。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"share.h"</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">void</span> <span class="token operator">*</span>shm <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">shm_data</span> <span class="token operator">*</span>shared <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> shmid <span class="token operator">=</span> <span class="token function">get_shmid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> semid <span class="token operator">=</span> <span class="token function">get_semaphoreid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> i<span class="token punctuation">;</span>

  shm <span class="token operator">=</span> <span class="token function">shmat</span><span class="token punctuation">(</span>shmid<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>shm <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  shared <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">shm_data</span><span class="token operator">*</span><span class="token punctuation">)</span>shm<span class="token punctuation">;</span>
  <span class="token function">memset</span><span class="token punctuation">(</span>shared<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">shm_data</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">semaphore_init</span><span class="token punctuation">(</span>semid<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">semaphore_p</span><span class="token punctuation">(</span>semid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>shared<span class="token operator">-&gt;</span>datalength <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token function">semaphore_v</span><span class="token punctuation">(</span>semid<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"how many integers to caculate : "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>shared<span class="token operator">-&gt;</span>datalength<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>shared<span class="token operator">-&gt;</span>datalength <span class="token operator">&gt;</span> MAX_NUM<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"too many integers."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        shared<span class="token operator">-&gt;</span>datalength <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token function">semaphore_v</span><span class="token punctuation">(</span>semid<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>shared<span class="token operator">-&gt;</span>datalength<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Input the %d integer : "</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>shared<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token function">semaphore_v</span><span class="token punctuation">(</span>semid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里面，get_shmid创建了共享内存，get_semaphoreid创建了信号量集合，然后shmat将共享内存映射到了虚拟地址空间的shm指针指向的位置，然后通过强制类型转换，shared的指针指向放在共享内存里面的struct shm_data结构，然后初始化为0。semaphore_init将信号量进行了初始化。</p>
<p>接着，producer进入了一个无限循环。在这个循环里面，我们先通过semaphore_p申请访问共享内存的权利，如果发现datalength大于零，说明共享内存里面的数据没有被处理过，于是semaphore_v释放权利，先睡一会儿，睡醒了再看。如果发现datalength等于0，说明共享内存里面的数据被处理完了，于是开始往里面放数据。让用户输入多少个数，然后每个数是什么，都放在struct shm_data结构中，然后semaphore_v释放权利，等待其他的进程将这些数拿去处理。</p>
<p>我们再来看consumer的代码。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"share.h"</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">void</span> <span class="token operator">*</span>shm <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">shm_data</span> <span class="token operator">*</span>shared <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> shmid <span class="token operator">=</span> <span class="token function">get_shmid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> semid <span class="token operator">=</span> <span class="token function">get_semaphoreid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> i<span class="token punctuation">;</span>

  shm <span class="token operator">=</span> <span class="token function">shmat</span><span class="token punctuation">(</span>shmid<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>shm <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  shared <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">shm_data</span><span class="token operator">*</span><span class="token punctuation">)</span>shm<span class="token punctuation">;</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">semaphore_p</span><span class="token punctuation">(</span>semid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>shared<span class="token operator">-&gt;</span>datalength <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>shared<span class="token operator">-&gt;</span>datalength<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d+"</span><span class="token punctuation">,</span>shared<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sum <span class="token operator">+=</span> shared<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>shared<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>shared<span class="token operator">-&gt;</span>datalength<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      sum <span class="token operator">+=</span> shared<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>shared<span class="token operator">-&gt;</span>datalength<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"=%d\n"</span><span class="token punctuation">,</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">memset</span><span class="token punctuation">(</span>shared<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">shm_data</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">semaphore_v</span><span class="token punctuation">(</span>semid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">semaphore_v</span><span class="token punctuation">(</span>semid<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"no tasks, waiting.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里面，get_shmid获得producer创建的共享内存，get_semaphoreid获得producer创建的信号量集合，然后shmat将共享内存映射到了虚拟地址空间的shm指针指向的位置，然后通过强制类型转换，shared的指针指向放在共享内存里面的struct shm_data结构。</p>
<p>接着，consumer进入了一个无限循环，在这个循环里面，我们先通过semaphore_p申请访问共享内存的权利，如果发现datalength等于0，就说明没什么活干，需要等待。如果发现datalength大于0，就说明有活干，于是将datalength个整型数字从data数组中取出来求和。最后将struct shm_data清空为0，表示任务处理完毕，通过semaphore_v释放权利。</p>
<p>通过程序创建的共享内存和信号量集合，我们可以通过命令ipcs查看。当然，我们也可以通过ipcrm进行删除。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ipcs
------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages
------ Shared Memory Segments --------
key        shmid      owner      perms      bytes      nattch     status
0x00016988 <span class="token number">32768</span>      root       <span class="token number">777</span>        <span class="token number">516</span>        <span class="token number">0</span>
------ Semaphore Arrays --------
key        semid      owner      perms      nsems
0x00016989 <span class="token number">32768</span>      root       <span class="token number">777</span>        <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面我们来运行一下producer和consumer，可以得到下面的结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./producer
how many integers to caculate <span class="token builtin class-name">:</span> <span class="token number">2</span>
Input the <span class="token number">0</span> integer <span class="token builtin class-name">:</span> <span class="token number">3</span>
Input the <span class="token number">1</span> integer <span class="token builtin class-name">:</span> <span class="token number">4</span>
how many integers to caculate <span class="token builtin class-name">:</span> <span class="token number">4</span>
Input the <span class="token number">0</span> integer <span class="token builtin class-name">:</span> <span class="token number">3</span>
Input the <span class="token number">1</span> integer <span class="token builtin class-name">:</span> <span class="token number">4</span>
Input the <span class="token number">2</span> integer <span class="token builtin class-name">:</span> <span class="token number">5</span>
Input the <span class="token number">3</span> integer <span class="token builtin class-name">:</span> <span class="token number">6</span>
how many integers to caculate <span class="token builtin class-name">:</span> <span class="token number">7</span>
Input the <span class="token number">0</span> integer <span class="token builtin class-name">:</span> <span class="token number">9</span>
Input the <span class="token number">1</span> integer <span class="token builtin class-name">:</span> <span class="token number">8</span>
Input the <span class="token number">2</span> integer <span class="token builtin class-name">:</span> <span class="token number">7</span>
Input the <span class="token number">3</span> integer <span class="token builtin class-name">:</span> <span class="token number">6</span>
Input the <span class="token number">4</span> integer <span class="token builtin class-name">:</span> <span class="token number">5</span>
Input the <span class="token number">5</span> integer <span class="token builtin class-name">:</span> <span class="token number">4</span>
Input the <span class="token number">6</span> integer <span class="token builtin class-name">:</span> <span class="token number">3</span>

$ ./consumer
<span class="token number">3</span>+4<span class="token operator">=</span><span class="token number">7</span>
<span class="token number">3</span>+4+5+6<span class="token operator">=</span><span class="token number">18</span>
<span class="token number">9</span>+8+7+6+5+4+3<span class="token operator">=</span><span class="token number">42</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="35-3-总结"><a href="#35-3-总结" class="headerlink" title="35.3 总结"></a>35.3 总结</h4><p>总结一下。共享内存和信号量的配合机制，如下图所示：</p>
<ul>
<li>无论是共享内存还是信号量，创建与初始化都遵循同样流程，通过ftok得到key，通过xxxget创建对象并生成id；</li>
<li>生产者和消费者都通过shmat将共享内存映射到各自的内存空间，在不同的进程里面映射的位置不同；</li>
<li>为了访问共享内存，需要信号量进行保护，信号量需要通过semctl初始化为某个值；</li>
<li>接下来生产者和消费者要通过semop(-1)来竞争信号量，如果生产者抢到信号量则写入，然后通过semop(+1)释放信号量，如果消费者抢到信号量则读出，然后通过semop(+1)释放信号量；</li>
<li>共享内存使用完毕，可以通过shmdt来解除映射。</li>
</ul>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/共享内存和信号量的配合机制.png" alt="共享内存和信号量的配合机制"></p>
<h3 id="36-IPC（中）"><a href="#36-IPC（中）" class="headerlink" title="36. IPC（中）"></a>36. IPC（中）</h3><p>不知道你有没有注意到，咱们讲消息队列、共享内存、信号量的机制的时候，我们其实能够从中看到一些统一的规律：<strong>它们在使用之前都要生成key，然后通过key得到唯一的id，并且都是通过xxxget函数。</strong></p>
<p>内核里面，这三种进程间通信机制是使用统一的机制管理起来的，都叫ipcxxx。</p>
<p>为了维护这三种进程间通信进制，在内核里面，我们声明了一个有三项的数组。</p>
<p>我们通过这段代码，来具体看一看。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">ipc_namespace</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">struct</span> <span class="token class-name">ipc_ids</span>      ids<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">IPC_SEM_IDS     <span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">IPC_MSG_IDS     <span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">IPC_SHM_IDS     <span class="token number">2</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">sem_ids</span><span class="token punctuation">(</span>ns<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token punctuation">(</span>ns<span class="token punctuation">)</span><span class="token operator">-&gt;</span>ids<span class="token punctuation">[</span>IPC_SEM_IDS<span class="token punctuation">]</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">msg_ids</span><span class="token punctuation">(</span>ns<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token punctuation">(</span>ns<span class="token punctuation">)</span><span class="token operator">-&gt;</span>ids<span class="token punctuation">[</span>IPC_MSG_IDS<span class="token punctuation">]</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">shm_ids</span><span class="token punctuation">(</span>ns<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token punctuation">(</span>ns<span class="token punctuation">)</span><span class="token operator">-&gt;</span>ids<span class="token punctuation">[</span>IPC_SHM_IDS<span class="token punctuation">]</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>根据代码中的定义，第0项用于信号量，第1项用于消息队列，第2项用于共享内存，分别可以通过sem_ids、msg_ids、shm_ids来访问。</p>
<p>这段代码里面有ns，全称叫namespace。可能不容易理解，你现在可以将它认为是将一台Linux服务器逻辑的隔离为多台Linux服务器的机制，它背后的原理是一个相当大的话题，我们需要在容器那一章详细讲述。现在，你就可以简单的认为没有namespace，整个Linux在一个namespace下面，那这些ids也是整个Linux只有一份。</p>
<p>接下来，我们再来看struct ipc_ids里面保存了什么。</p>
<p>首先，in_use表示当前有多少个ipc；其次，seq和next_id用于一起生成ipc唯一的id，因为信号量，共享内存，消息队列，它们三个的id也不能重复；ipcs_idr是一棵基数树，我们又碰到它了，一旦涉及从一个整数查找一个对象，它都是最好的选择。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">ipc_ids</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> in_use<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> seq<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rw_semaphore</span> rwsem<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">idr</span> ipcs_idr<span class="token punctuation">;</span>
    <span class="token keyword">int</span> next_id<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">idr</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">radix_tree_root</span>  idr_rt<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>            idr_next<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也就是说，对于sem_ids、msg_ids、shm_ids各有一棵基数树。那这棵树里面究竟存放了什么，能够统一管理这三类ipc对象呢？</p>
<p>通过下面这个函数ipc_obtain_object_idr，我们可以看出端倪。这个函数根据id，在基数树里面找出来的是struct kern_ipc_perm。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">kern_ipc_perm</span> <span class="token operator">*</span><span class="token function">ipc_obtain_object_idr</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ipc_ids</span> <span class="token operator">*</span>ids<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">kern_ipc_perm</span> <span class="token operator">*</span>out<span class="token punctuation">;</span>
    <span class="token keyword">int</span> lid <span class="token operator">=</span> <span class="token function">ipcid_to_idx</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    out <span class="token operator">=</span> <span class="token function">idr_find</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ids<span class="token operator">-&gt;</span>ipcs_idr<span class="token punctuation">,</span> lid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> out<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果我们看用于表示信号量、消息队列、共享内存的结构，就会发现，这三个结构的第一项都是struct kern_ipc_perm。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sem_array</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">kern_ipc_perm</span>    sem_perm<span class="token punctuation">;</span>   <span class="token comment">/* permissions .. see ipc.h */</span>
    time_t              sem_ctime<span class="token punctuation">;</span>      <span class="token comment">/* create/last semctl() time */</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    pending_alter<span class="token punctuation">;</span>  <span class="token comment">/* pending operations */</span>
                                        <span class="token comment">/* that alter the array */</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    pending_const<span class="token punctuation">;</span>  <span class="token comment">/* pending complex operations */</span>
                                        <span class="token comment">/* that do not alter semvals */</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    list_id<span class="token punctuation">;</span>        <span class="token comment">/* undo requests on this array */</span>
    <span class="token keyword">int</span>                 sem_nsems<span class="token punctuation">;</span>      <span class="token comment">/* no. of semaphores in array */</span>
    <span class="token keyword">int</span>                 complex_count<span class="token punctuation">;</span>  <span class="token comment">/* pending complex operations */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        use_global_lock<span class="token punctuation">;</span><span class="token comment">/* &gt;0: global lock required */</span>

    <span class="token keyword">struct</span> <span class="token class-name">sem</span>      sems<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> __randomize_layout<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">msg_queue</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">kern_ipc_perm</span> q_perm<span class="token punctuation">;</span>
    time_t q_stime<span class="token punctuation">;</span>             <span class="token comment">/* last msgsnd time */</span>
    time_t q_rtime<span class="token punctuation">;</span>             <span class="token comment">/* last msgrcv time */</span>
    time_t q_ctime<span class="token punctuation">;</span>             <span class="token comment">/* last change time */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> q_cbytes<span class="token punctuation">;</span>     <span class="token comment">/* current number of bytes on queue */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> q_qnum<span class="token punctuation">;</span>       <span class="token comment">/* number of messages in queue */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> q_qbytes<span class="token punctuation">;</span>     <span class="token comment">/* max number of bytes on queue */</span>
    pid_t q_lspid<span class="token punctuation">;</span>              <span class="token comment">/* pid of last msgsnd */</span>
    pid_t q_lrpid<span class="token punctuation">;</span>              <span class="token comment">/* last receive pid */</span>

    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> q_messages<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> q_receivers<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> q_senders<span class="token punctuation">;</span>
<span class="token punctuation">}</span> __randomize_layout<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">shmid_kernel</span> <span class="token comment">/* private to the kernel */</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">kern_ipc_perm</span>    shm_perm<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">file</span>         <span class="token operator">*</span>shm_file<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>       shm_nattch<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>       shm_segsz<span class="token punctuation">;</span>
    time_t              shm_atim<span class="token punctuation">;</span>
    time_t              shm_dtim<span class="token punctuation">;</span>
    time_t              shm_ctim<span class="token punctuation">;</span>
    pid_t               shm_cprid<span class="token punctuation">;</span>
    pid_t               shm_lprid<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">user_struct</span>  <span class="token operator">*</span>mlock_user<span class="token punctuation">;</span>

    <span class="token comment">/* The task created the shm object.  NULL if the task is dead. */</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span>  <span class="token operator">*</span>shm_creator<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    shm_clist<span class="token punctuation">;</span>  <span class="token comment">/* list by creator */</span>
<span class="token punctuation">}</span> __randomize_layout<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也就是说，我们完全可以通过struct kern_ipc_perm的指针，通过进行强制类型转换后，得到整个结构。做这件事情的函数如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">sem_array</span> <span class="token operator">*</span><span class="token function">sem_obtain_object</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ipc_namespace</span> <span class="token operator">*</span>ns<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">kern_ipc_perm</span> <span class="token operator">*</span>ipcp <span class="token operator">=</span> <span class="token function">ipc_obtain_object_idr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token function">sem_ids</span><span class="token punctuation">(</span>ns<span class="token punctuation">)</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">container_of</span><span class="token punctuation">(</span>ipcp<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sem_array</span><span class="token punctuation">,</span> sem_perm<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">msg_queue</span> <span class="token operator">*</span><span class="token function">msq_obtain_object</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ipc_namespace</span> <span class="token operator">*</span>ns<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">kern_ipc_perm</span> <span class="token operator">*</span>ipcp <span class="token operator">=</span> <span class="token function">ipc_obtain_object_idr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token function">msg_ids</span><span class="token punctuation">(</span>ns<span class="token punctuation">)</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">container_of</span><span class="token punctuation">(</span>ipcp<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">msg_queue</span><span class="token punctuation">,</span> q_perm<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">shmid_kernel</span> <span class="token operator">*</span><span class="token function">shm_obtain_object</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ipc_namespace</span> <span class="token operator">*</span>ns<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">kern_ipc_perm</span> <span class="token operator">*</span>ipcp <span class="token operator">=</span> <span class="token function">ipc_obtain_object_idr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token function">shm_ids</span><span class="token punctuation">(</span>ns<span class="token punctuation">)</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">container_of</span><span class="token punctuation">(</span>ipcp<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">shmid_kernel</span><span class="token punctuation">,</span> shm_perm<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过这种机制，我们就可以将信号量、消息队列、共享内存抽象为ipc类型进行统一处理。你有没有觉得，这有点儿面向对象编程中抽象类和实现类的意思？没错，如果你试图去了解C++中类的实现机制，其实也是这么干的。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/将信号量、消息队列、共享内存抽象为ipc类型进行统一处理.png" alt="将信号量、消息队列、共享内存抽象为ipc类型进行统一处理"></p>
<p>有了抽象类，接下来我们来看共享内存和信号量的具体实现。</p>
<h4 id="36-1-如何创建共享内存？"><a href="#36-1-如何创建共享内存？" class="headerlink" title="36.1 如何创建共享内存？"></a>36.1 如何创建共享内存？</h4><p>首先，我们来看创建共享内存的的系统调用。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>shmget<span class="token punctuation">,</span> key_t<span class="token punctuation">,</span> key<span class="token punctuation">,</span> size_t<span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> shmflg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">ipc_namespace</span> <span class="token operator">*</span>ns<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">ipc_ops</span> shm_ops <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span>getnew <span class="token operator">=</span> newseg<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>associate <span class="token operator">=</span> shm_security<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>more_checks <span class="token operator">=</span> shm_more_checks<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">ipc_params</span> shm_params<span class="token punctuation">;</span>
    ns <span class="token operator">=</span> current<span class="token operator">-&gt;</span>nsproxy<span class="token operator">-&gt;</span>ipc_ns<span class="token punctuation">;</span>
    shm_params<span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
    shm_params<span class="token punctuation">.</span>flg <span class="token operator">=</span> shmflg<span class="token punctuation">;</span>
    shm_params<span class="token punctuation">.</span>u<span class="token punctuation">.</span>size <span class="token operator">=</span> size<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">ipcget</span><span class="token punctuation">(</span>ns<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token function">shm_ids</span><span class="token punctuation">(</span>ns<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>shm_ops<span class="token punctuation">,</span> <span class="token operator">&amp;</span>shm_params<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面调用了抽象的ipcget、参数分别为共享内存对应的shm_ids、对应的操作shm_ops以及对应的参数shm_params。</p>
<p>如果key设置为IPC_PRIVATE则永远创建新的，如果不是的话，就会调用ipcget_public。ipcget的具体代码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">ipcget</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ipc_namespace</span> <span class="token operator">*</span>ns<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">ipc_ids</span> <span class="token operator">*</span>ids<span class="token punctuation">,</span>
            <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">ipc_ops</span> <span class="token operator">*</span>ops<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">ipc_params</span> <span class="token operator">*</span>params<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>params<span class="token operator">-&gt;</span>key <span class="token operator">==</span> IPC_PRIVATE<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">ipcget_new</span><span class="token punctuation">(</span>ns<span class="token punctuation">,</span> ids<span class="token punctuation">,</span> ops<span class="token punctuation">,</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token function">ipcget_public</span><span class="token punctuation">(</span>ns<span class="token punctuation">,</span> ids<span class="token punctuation">,</span> ops<span class="token punctuation">,</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ipcget_public</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ipc_namespace</span> <span class="token operator">*</span>ns<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">ipc_ids</span> <span class="token operator">*</span>ids<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">ipc_ops</span> <span class="token operator">*</span>ops<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">ipc_params</span> <span class="token operator">*</span>params<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">kern_ipc_perm</span> <span class="token operator">*</span>ipcp<span class="token punctuation">;</span>
    <span class="token keyword">int</span> flg <span class="token operator">=</span> params<span class="token operator">-&gt;</span>flg<span class="token punctuation">;</span>
    <span class="token keyword">int</span> err<span class="token punctuation">;</span>
    ipcp <span class="token operator">=</span> <span class="token function">ipc_findkey</span><span class="token punctuation">(</span>ids<span class="token punctuation">,</span> params<span class="token operator">-&gt;</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ipcp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>flg <span class="token operator">&amp;</span> IPC_CREAT<span class="token punctuation">)</span><span class="token punctuation">)</span>
            err <span class="token operator">=</span> <span class="token operator">-</span>ENOENT<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            err <span class="token operator">=</span> ops<span class="token operator">-&gt;</span><span class="token function">getnew</span><span class="token punctuation">(</span>ns<span class="token punctuation">,</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>flg <span class="token operator">&amp;</span> IPC_CREAT <span class="token operator">&amp;&amp;</span> flg <span class="token operator">&amp;</span> IPC_EXCL<span class="token punctuation">)</span>
            err <span class="token operator">=</span> <span class="token operator">-</span>EEXIST<span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            err <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>ops<span class="token operator">-&gt;</span>more_checks<span class="token punctuation">)</span>
                err <span class="token operator">=</span> ops<span class="token operator">-&gt;</span><span class="token function">more_checks</span><span class="token punctuation">(</span>ipcp<span class="token punctuation">,</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> err<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在ipcget_public中，我们会按照key，去查找struct kern_ipc_perm。如果没有找到，那就看是否设置了IPC_CREAT；如果设置了，就创建一个新的。如果找到了，就将对应的id返回。</p>
<p>我们这里重点看，如何按照参数shm_ops，创建新的共享内存，会调用newseg。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">newseg</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ipc_namespace</span> <span class="token operator">*</span>ns<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">ipc_params</span> <span class="token operator">*</span>params<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    key_t key <span class="token operator">=</span> params<span class="token operator">-&gt;</span>key<span class="token punctuation">;</span>
    <span class="token keyword">int</span> shmflg <span class="token operator">=</span> params<span class="token operator">-&gt;</span>flg<span class="token punctuation">;</span>
    size_t size <span class="token operator">=</span> params<span class="token operator">-&gt;</span>u<span class="token punctuation">.</span>size<span class="token punctuation">;</span>
    <span class="token keyword">int</span> error<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">shmid_kernel</span> <span class="token operator">*</span>shp<span class="token punctuation">;</span>
    size_t numpages <span class="token operator">=</span> <span class="token punctuation">(</span>size <span class="token operator">+</span> PAGE_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">;</span>
    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    vm_flags_t acctflag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    shp <span class="token operator">=</span> <span class="token function">kvmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>shp<span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    shp<span class="token operator">-&gt;</span>shm_perm<span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
    shp<span class="token operator">-&gt;</span>shm_perm<span class="token punctuation">.</span>mode <span class="token operator">=</span> <span class="token punctuation">(</span>shmflg <span class="token operator">&amp;</span> S_IRWXUGO<span class="token punctuation">)</span><span class="token punctuation">;</span>
    shp<span class="token operator">-&gt;</span>mlock_user <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

    shp<span class="token operator">-&gt;</span>shm_perm<span class="token punctuation">.</span>security <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    file <span class="token operator">=</span> <span class="token function">shmem_kernel_file_setup</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> size<span class="token punctuation">,</span> acctflag<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    shp<span class="token operator">-&gt;</span>shm_cprid <span class="token operator">=</span> <span class="token function">task_tgid_vnr</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
    shp<span class="token operator">-&gt;</span>shm_lprid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    shp<span class="token operator">-&gt;</span>shm_atim <span class="token operator">=</span> shp<span class="token operator">-&gt;</span>shm_dtim <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    shp<span class="token operator">-&gt;</span>shm_ctim <span class="token operator">=</span> <span class="token function">get_seconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    shp<span class="token operator">-&gt;</span>shm_segsz <span class="token operator">=</span> size<span class="token punctuation">;</span>
    shp<span class="token operator">-&gt;</span>shm_nattch <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    shp<span class="token operator">-&gt;</span>shm_file <span class="token operator">=</span> file<span class="token punctuation">;</span>
    shp<span class="token operator">-&gt;</span>shm_creator <span class="token operator">=</span> current<span class="token punctuation">;</span>

    error <span class="token operator">=</span> <span class="token function">ipc_addid</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token function">shm_ids</span><span class="token punctuation">(</span>ns<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>shp<span class="token operator">-&gt;</span>shm_perm<span class="token punctuation">,</span> ns<span class="token operator">-&gt;</span>shm_ctlmni<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">list_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>shp<span class="token operator">-&gt;</span>shm_clist<span class="token punctuation">,</span> <span class="token operator">&amp;</span>current<span class="token operator">-&gt;</span>sysvshm<span class="token punctuation">.</span>shm_clist<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">file_inode</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token operator">-&gt;</span>i_ino <span class="token operator">=</span> shp<span class="token operator">-&gt;</span>shm_perm<span class="token punctuation">.</span>id<span class="token punctuation">;</span>

    ns<span class="token operator">-&gt;</span>shm_tot <span class="token operator">+=</span> numpages<span class="token punctuation">;</span>
    error <span class="token operator">=</span> shp<span class="token operator">-&gt;</span>shm_perm<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> error<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>newseg函数的第一步，通过kvmalloc在直接映射区分配一个struct shmid_kernel结构</strong>。这个结构就是用来描述共享内存的。这个结构最开始就是上面说的struct kern_ipc_perm结构。接下来就是填充这个struct shmid_kernel结构，例如key、权限等。</p>
<p><strong>newseg函数的第二步，共享内存需要和文件进行关联</strong>。为什么要做这个呢？我们在讲内存映射的时候讲过，虚拟地址空间可以和物理内存关联，但是物理内存是某个进程独享的。虚拟地址空间也可以映射到一个文件，文件是可以跨进程共享的。</p>
<p>咱们这里的共享内存需要跨进程共享，也应该借鉴文件映射的思路。只不过不应该映射一个硬盘上的文件，而是映射到一个内存文件系统上的文件。mm/shmem.c里面就定义了这样一个基于内存的文件系统。这里你一定要注意区分shmem和shm的区别，前者是一个文件系统，后者是进程通信机制。</p>
<p>在系统初始化的时候，shmem_init注册了shmem文件系统shmem_fs_type，并且挂在到了shm_mnt下面。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> __init <span class="token function">shmem_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> error<span class="token punctuation">;</span>
    error <span class="token operator">=</span> <span class="token function">shmem_init_inodecache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    error <span class="token operator">=</span> <span class="token function">register_filesystem</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>shmem_fs_type<span class="token punctuation">)</span><span class="token punctuation">;</span>
    shm_mnt <span class="token operator">=</span> <span class="token function">kern_mount</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>shmem_fs_type<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">file_system_type</span> shmem_fs_type <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>owner      <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>name       <span class="token operator">=</span> <span class="token string">"tmpfs"</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>mount      <span class="token operator">=</span> shmem_mount<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>kill_sb    <span class="token operator">=</span> kill_litter_super<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>fs_flags   <span class="token operator">=</span> FS_USERNS_MOUNT<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来，newseg函数会调用shmem_kernel_file_setup，其实就是在shmem文件系统里面创建一个文件。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/**
 * shmem_kernel_file_setup - get an unlinked file living in tmpfs which must be kernel internal.
 * @name: name for dentry (to be seen in /proc/&lt;pid&gt;/maps
 * @size: size to be set for the file
 * @flags: VM_NORESERVE suppresses pre-accounting of the entire object size */</span>
<span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token function">shmem_kernel_file_setup</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span> loff_t size<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">__shmem_file_setup</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> size<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> S_PRIVATE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token function">__shmem_file_setup</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span> loff_t size<span class="token punctuation">,</span>
                       <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> i_flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>res<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">path</span> path<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span>sb<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">qstr</span> this<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    this<span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    this<span class="token punctuation">.</span>len <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    this<span class="token punctuation">.</span>hash <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">/* will go */</span>
    sb <span class="token operator">=</span> shm_mnt<span class="token operator">-&gt;</span>mnt_sb<span class="token punctuation">;</span>
    path<span class="token punctuation">.</span>mnt <span class="token operator">=</span> <span class="token function">mntget</span><span class="token punctuation">(</span>shm_mnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
    path<span class="token punctuation">.</span>dentry <span class="token operator">=</span> <span class="token function">d_alloc_pseudo</span><span class="token punctuation">(</span>sb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">d_set_d_op</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span>dentry<span class="token punctuation">,</span> <span class="token operator">&amp;</span>anon_ops<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    inode <span class="token operator">=</span> <span class="token function">shmem_get_inode</span><span class="token punctuation">(</span>sb<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> S_IFREG <span class="token operator">|</span> S_IRWXUGO<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    inode<span class="token operator">-&gt;</span>i_flags <span class="token operator">|=</span> i_flags<span class="token punctuation">;</span>
    <span class="token function">d_instantiate</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span>dentry<span class="token punctuation">,</span> inode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    inode<span class="token operator">-&gt;</span>i_size <span class="token operator">=</span> size<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    res <span class="token operator">=</span> <span class="token function">alloc_file</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>path<span class="token punctuation">,</span> FMODE_WRITE <span class="token operator">|</span> FMODE_READ<span class="token punctuation">,</span>
          <span class="token operator">&amp;</span>shmem_file_operations<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>__shmem_file_setup会创建新的shmem文件对应的dentry和inode，并将它们两个关联起来，然后分配一个struct file结构，来表示新的shmem文件，并且指向独特的shmem_file_operations。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> shmem_file_operations <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>mmap               <span class="token operator">=</span> shmem_mmap<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>get_unmapped_area  <span class="token operator">=</span> shmem_get_unmapped_area<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_TMPFS</span></span>
    <span class="token punctuation">.</span>llseek             <span class="token operator">=</span> shmem_file_llseek<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>read_iter          <span class="token operator">=</span> shmem_file_read_iter<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>write_iter         <span class="token operator">=</span> generic_file_write_iter<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>fsync              <span class="token operator">=</span> noop_fsync<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>splice_read        <span class="token operator">=</span> generic_file_splice_read<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>splice_write       <span class="token operator">=</span> iter_file_splice_write<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>fallocate          <span class="token operator">=</span> shmem_fallocate<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>newseg函数的第三步，通过ipc_addid将新创建的struct shmid_kernel结构挂到shm_ids里面的基数树上，并返回相应的id，并且将struct shmid_kernel挂到当前进程的sysvshm队列中。</strong></p>
<p>至此，共享内存的创建就完成了。</p>
<h4 id="36-2-如何将共享内存映射到虚拟地址空间？"><a href="#36-2-如何将共享内存映射到虚拟地址空间？" class="headerlink" title="36.2 如何将共享内存映射到虚拟地址空间？"></a>36.2 如何将共享内存映射到虚拟地址空间？</h4><p>从上面的代码解析中，我们知道，共享内存的数据结构struct shmid_kernel，是通过它的成员struct file *shm_file，来管理内存文件系统shmem上的内存文件的。无论这个共享内存是否被映射，shm_file都是存在的。</p>
<p>接下来，我们要将共享内存映射到虚拟地址空间中。调用的是shmat，对应的系统调用如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>shmat<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> shmid<span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> shmaddr<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> shmflg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ret<span class="token punctuation">;</span>
    <span class="token keyword">long</span> err<span class="token punctuation">;</span>
    err <span class="token operator">=</span> <span class="token function">do_shmat</span><span class="token punctuation">(</span>shmid<span class="token punctuation">,</span> shmaddr<span class="token punctuation">,</span> shmflg<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ret<span class="token punctuation">,</span> SHMLBA<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">force_successful_syscall_return</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">long</span> <span class="token function">do_shmat</span><span class="token punctuation">(</span><span class="token keyword">int</span> shmid<span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>shmaddr<span class="token punctuation">,</span> <span class="token keyword">int</span> shmflg<span class="token punctuation">,</span>
          ulong <span class="token operator">*</span>raddr<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> shmlba<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">shmid_kernel</span> <span class="token operator">*</span>shp<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> addr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span>shmaddr<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">;</span>
    <span class="token keyword">int</span>    err<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags <span class="token operator">=</span> MAP_SHARED<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> prot<span class="token punctuation">;</span>
    <span class="token keyword">int</span> acc_mode<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">ipc_namespace</span> <span class="token operator">*</span>ns<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">shm_file_data</span> <span class="token operator">*</span>sfd<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">path</span> path<span class="token punctuation">;</span>
    fmode_t f_mode<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> populate <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    prot <span class="token operator">=</span> PROT_READ <span class="token operator">|</span> PROT_WRITE<span class="token punctuation">;</span>
    acc_mode <span class="token operator">=</span> S_IRUGO <span class="token operator">|</span> S_IWUGO<span class="token punctuation">;</span>
    f_mode <span class="token operator">=</span> FMODE_READ <span class="token operator">|</span> FMODE_WRITE<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    ns <span class="token operator">=</span> current<span class="token operator">-&gt;</span>nsproxy<span class="token operator">-&gt;</span>ipc_ns<span class="token punctuation">;</span>
    shp <span class="token operator">=</span> <span class="token function">shm_obtain_object_check</span><span class="token punctuation">(</span>ns<span class="token punctuation">,</span> shmid<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    path <span class="token operator">=</span> shp<span class="token operator">-&gt;</span>shm_file<span class="token operator">-&gt;</span>f_path<span class="token punctuation">;</span>
    <span class="token function">path_get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
    shp<span class="token operator">-&gt;</span>shm_nattch<span class="token operator">++</span><span class="token punctuation">;</span>
    size <span class="token operator">=</span> <span class="token function">i_size_read</span><span class="token punctuation">(</span><span class="token function">d_inode</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span>dentry<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    sfd <span class="token operator">=</span> <span class="token function">kzalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>sfd<span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    file <span class="token operator">=</span> <span class="token function">alloc_file</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>path<span class="token punctuation">,</span> f_mode<span class="token punctuation">,</span>
              <span class="token function">is_file_hugepages</span><span class="token punctuation">(</span>shp<span class="token operator">-&gt;</span>shm_file<span class="token punctuation">)</span> <span class="token operator">?</span>
                <span class="token operator">&amp;</span>shm_file_operations_huge <span class="token operator">:</span>
                <span class="token operator">&amp;</span>shm_file_operations<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    file<span class="token operator">-&gt;</span>private_data <span class="token operator">=</span> sfd<span class="token punctuation">;</span>
    file<span class="token operator">-&gt;</span>f_mapping <span class="token operator">=</span> shp<span class="token operator">-&gt;</span>shm_file<span class="token operator">-&gt;</span>f_mapping<span class="token punctuation">;</span>
    sfd<span class="token operator">-&gt;</span>id <span class="token operator">=</span> shp<span class="token operator">-&gt;</span>shm_perm<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
    sfd<span class="token operator">-&gt;</span>ns <span class="token operator">=</span> <span class="token function">get_ipc_ns</span><span class="token punctuation">(</span>ns<span class="token punctuation">)</span><span class="token punctuation">;</span>
    sfd<span class="token operator">-&gt;</span>file <span class="token operator">=</span> shp<span class="token operator">-&gt;</span>shm_file<span class="token punctuation">;</span>
    sfd<span class="token operator">-&gt;</span>vm_ops <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    addr <span class="token operator">=</span> <span class="token function">do_mmap_pgoff</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> size<span class="token punctuation">,</span> prot<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>populate<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>raddr <span class="token operator">=</span> addr<span class="token punctuation">;</span>
    err <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> err<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这个函数里面，shm_obtain_object_check会通过共享内存的id，在基数树中找到对应的struct shmid_kernel结构，通过它找到shmem上的内存文件。</p>
<p>接下来，我们要分配一个struct shm_file_data，来表示这个内存文件。将shmem中指向内存文件的shm_file赋值给struct shm_file_data中的file成员。</p>
<p>然后，我们创建了一个struct file，指向的也是shmem中的内存文件。</p>
<p>为什么要再创建一个呢？这两个的功能不同，shmem中shm_file用于管理内存文件，是一个中立的，独立于任何一个进程的角色。而新创建的struct file是专门用于做内存映射的，就像咱们在讲内存映射那一节讲过的，一个硬盘上的文件要映射到虚拟地址空间中的时候，需要在vm_area_struct里面有一个struct file *vm_file指向硬盘上的文件，现在变成内存文件了，但是这个结构还是不能少。</p>
<p>新创建的struct file的private_data，指向struct shm_file_data，这样内存映射那部分的数据结构，就能够通过它来访问内存文件了。</p>
<p>新创建的struct file的file_operations也发生了变化，变成了shm_file_operations。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> shm_file_operations <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>mmap       <span class="token operator">=</span> shm_mmap<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>fsync      <span class="token operator">=</span> shm_fsync<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>release    <span class="token operator">=</span> shm_release<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>get_unmapped_area  <span class="token operator">=</span> shm_get_unmapped_area<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>llseek     <span class="token operator">=</span> noop_llseek<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>fallocate  <span class="token operator">=</span> shm_fallocate<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来，do_mmap_pgoff函数我们遇到过，原来映射硬盘上的文件的时候，也是调用它。这里我们不再详细解析了。它会分配一个vm_area_struct指向虚拟地址空间中没有分配的区域，它的vm_file指向这个内存文件，然后它会调用shm_file_operations的mmap函数，也即shm_mmap进行映射。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">shm_mmap</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span>vma<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">shm_file_data</span> <span class="token operator">*</span>sfd <span class="token operator">=</span> <span class="token function">shm_file_data</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
    ret <span class="token operator">=</span> <span class="token function">__shm_open</span><span class="token punctuation">(</span>vma<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ret <span class="token operator">=</span> <span class="token function">call_mmap</span><span class="token punctuation">(</span>sfd<span class="token operator">-&gt;</span>file<span class="token punctuation">,</span> vma<span class="token punctuation">)</span><span class="token punctuation">;</span>
    sfd<span class="token operator">-&gt;</span>vm_ops <span class="token operator">=</span> vma<span class="token operator">-&gt;</span>vm_ops<span class="token punctuation">;</span>
    vma<span class="token operator">-&gt;</span>vm_ops <span class="token operator">=</span> <span class="token operator">&amp;</span>shm_vm_ops<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>shm_mmap中调用了shm_file_data中的file的mmap函数，这次调用的是shmem_file_operations的mmap，也即shmem_mmap。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">shmem_mmap</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span>vma<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">file_accessed</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vma<span class="token operator">-&gt;</span>vm_ops <span class="token operator">=</span> <span class="token operator">&amp;</span>shmem_vm_ops<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面，vm_area_struct的vm_ops指向shmem_vm_ops。等从call_mmap中返回之后，shm_file_data的vm_ops指向了shmem_vm_ops，而vm_area_struct的vm_ops改为指向shm_vm_ops。</p>
<p>我们来看一下，shm_vm_ops和shmem_vm_ops的定义。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">vm_operations_struct</span> shm_vm_ops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>open   <span class="token operator">=</span> shm_open<span class="token punctuation">,</span> <span class="token comment">/* callback for a new vm-area open */</span>
    <span class="token punctuation">.</span>close  <span class="token operator">=</span> shm_close<span class="token punctuation">,</span>    <span class="token comment">/* callback for when the vm-area is released */</span>
    <span class="token punctuation">.</span>fault  <span class="token operator">=</span> shm_fault<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">vm_operations_struct</span> shmem_vm_ops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>fault      <span class="token operator">=</span> shmem_fault<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>map_pages  <span class="token operator">=</span> filemap_map_pages<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>它们里面最关键的就是fault函数，也即访问虚拟内存的时候，访问不到应该怎么办。</p>
<p>当访问不到的时候，先调用vm_area_struct的vm_ops，也即shm_vm_ops的fault函数shm_fault。然后它会转而调用shm_file_data的vm_ops，也即shmem_vm_ops的fault函数shmem_fault。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">shm_fault</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">vm_fault</span> <span class="token operator">*</span>vmf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file <span class="token operator">=</span> vmf<span class="token operator">-&gt;</span>vma<span class="token operator">-&gt;</span>vm_file<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">shm_file_data</span> <span class="token operator">*</span>sfd <span class="token operator">=</span> <span class="token function">shm_file_data</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> sfd<span class="token operator">-&gt;</span>vm_ops<span class="token operator">-&gt;</span><span class="token function">fault</span><span class="token punctuation">(</span>vmf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>虽然基于内存的文件系统，已经为这个内存文件分配了inode，但是内存也却是一点儿都没分配，只有在发生缺页异常的时候才进行分配。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">shmem_fault</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">vm_fault</span> <span class="token operator">*</span>vmf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span>vma <span class="token operator">=</span> vmf<span class="token operator">-&gt;</span>vma<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode <span class="token operator">=</span> <span class="token function">file_inode</span><span class="token punctuation">(</span>vma<span class="token operator">-&gt;</span>vm_file<span class="token punctuation">)</span><span class="token punctuation">;</span>
    gfp_t gfp <span class="token operator">=</span> <span class="token function">mapping_gfp_mask</span><span class="token punctuation">(</span>inode<span class="token operator">-&gt;</span>i_mapping<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    error <span class="token operator">=</span> <span class="token function">shmem_getpage_gfp</span><span class="token punctuation">(</span>inode<span class="token punctuation">,</span> vmf<span class="token operator">-&gt;</span>pgoff<span class="token punctuation">,</span> <span class="token operator">&amp;</span>vmf<span class="token operator">-&gt;</span>page<span class="token punctuation">,</span> sgp<span class="token punctuation">,</span>
                  gfp<span class="token punctuation">,</span> vma<span class="token punctuation">,</span> vmf<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token comment">/*
 * shmem_getpage_gfp - find page in cache, or get from swap, or allocate
 *
 * If we allocate a new one we do not mark it dirty. That's up to the
 * vm. If we swap it in we mark it dirty since we also free the swap
 * entry since a page cannot live in both the swap and page cache.
 *
 * fault_mm and fault_type are only supplied by shmem_fault:
 * otherwise they are NULL.
 */</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">shmem_getpage_gfp</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> pgoff_t index<span class="token punctuation">,</span>
    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span><span class="token operator">*</span>pagep<span class="token punctuation">,</span> <span class="token keyword">enum</span> <span class="token class-name">sgp_type</span> sgp<span class="token punctuation">,</span> gfp_t gfp<span class="token punctuation">,</span>
    <span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span>vma<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">vm_fault</span> <span class="token operator">*</span>vmf<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>fault_type<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    page <span class="token operator">=</span> <span class="token function">shmem_alloc_and_acct_page</span><span class="token punctuation">(</span>gfp<span class="token punctuation">,</span> info<span class="token punctuation">,</span> sbinfo<span class="token punctuation">,</span>
                    index<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>shmem_fault会调用shmem_getpage_gfp在page cache和swap中找一个空闲页，如果找不到就通过shmem_alloc_and_acct_page分配一个新的页，他最终会调用内存管理系统的alloc_page_vma在物理内存中分配一个页。</p>
<p>至此，共享内存才真的映射到了虚拟地址空间中，进程可以像访问本地内存一样访问共享内存。</p>
<h4 id="36-3-总结"><a href="#36-3-总结" class="headerlink" title="36.3 总结"></a>36.3 总结</h4><p>我们来总结一下共享内存的创建和映射过程。</p>
<ol>
<li>调用shmget创建共享内存。</li>
<li>先通过ipc_findkey在基数树中查找key对应的共享内存对象shmid_kernel是否已经被创建过，如果已经被创建，就会被查询出来，例如producer创建过，在consumer中就会查询出来。</li>
<li>如果共享内存没有被创建过，则调用shm_ops的newseg方法，创建一个共享内存对象shmid_kernel。例如，在producer中就会新建。</li>
<li>在shmem文件系统里面创建一个文件，共享内存对象shmid_kernel指向这个文件，这个文件用struct file表示，我们姑且称它为file1。</li>
<li>调用shmat，将共享内存映射到虚拟地址空间。</li>
<li>shm_obtain_object_check先从基数树里面找到shmid_kernel对象。</li>
<li>创建用于内存映射到文件的file和shm_file_data，这里的struct file我们姑且称为file2。</li>
<li>关联内存区域vm_area_struct和用于内存映射到文件的file，也即file2，调用file2的mmap函数。</li>
<li>file2的mmap函数shm_mmap，会调用file1的mmap函数shmem_mmap，设置shm_file_data和vm_area_struct的vm_ops。</li>
<li>内存映射完毕之后，其实并没有真的分配物理内存，当访问内存的时候，会触发缺页异常do_page_fault。</li>
<li>vm_area_struct的vm_ops的shm_fault会调用shm_file_data的vm_ops的shmem_fault。</li>
<li>在page cache中找一个空闲页，或者创建一个空闲页。</li>
</ol>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/共享内存的创建和映射过程.png" alt="共享内存的创建和映射过程"></p>
<h3 id="37-IPC（下）"><a href="#37-IPC（下）" class="headerlink" title="37. IPC（下）"></a>37. IPC（下）</h3><p>今天我们来看最后一部分，信号量的内核机制。</p>
<p>首先，我们需要创建一个信号量，调用的是系统调用semget。代码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>semget<span class="token punctuation">,</span> key_t<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> nsems<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> semflg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">ipc_namespace</span> <span class="token operator">*</span>ns<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">ipc_ops</span> sem_ops <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span>getnew <span class="token operator">=</span> newary<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>associate <span class="token operator">=</span> sem_security<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>more_checks <span class="token operator">=</span> sem_more_checks<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">ipc_params</span> sem_params<span class="token punctuation">;</span>
    ns <span class="token operator">=</span> current<span class="token operator">-&gt;</span>nsproxy<span class="token operator">-&gt;</span>ipc_ns<span class="token punctuation">;</span>
    sem_params<span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
    sem_params<span class="token punctuation">.</span>flg <span class="token operator">=</span> semflg<span class="token punctuation">;</span>
    sem_params<span class="token punctuation">.</span>u<span class="token punctuation">.</span>nsems <span class="token operator">=</span> nsems<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">ipcget</span><span class="token punctuation">(</span>ns<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token function">sem_ids</span><span class="token punctuation">(</span>ns<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>sem_ops<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sem_params<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们解析过了共享内存，再看信号量，就顺畅很多了。这里同样调用了抽象的ipcget，参数分别为信号量对应的sem_ids、对应的操作sem_ops以及对应的参数sem_params。</p>
<p>ipcget的代码我们已经解析过了。如果key设置为IPC_PRIVATE则永远创建新的；如果不是的话，就会调用ipcget_public。</p>
<p>在ipcget_public中，我们能会按照key，去查找struct kern_ipc_perm。如果没有找到，那就看看是否设置了IPC_CREAT。如果设置了，就创建一个新的。如果找到了，就将对应的id返回。</p>
<p>我们这里重点看，如何按照参数sem_ops，创建新的信号量会调用newary。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">newary</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ipc_namespace</span> <span class="token operator">*</span>ns<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">ipc_params</span> <span class="token operator">*</span>params<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> retval<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sem_array</span> <span class="token operator">*</span>sma<span class="token punctuation">;</span>
    key_t key <span class="token operator">=</span> params<span class="token operator">-&gt;</span>key<span class="token punctuation">;</span>
    <span class="token keyword">int</span> nsems <span class="token operator">=</span> params<span class="token operator">-&gt;</span>u<span class="token punctuation">.</span>nsems<span class="token punctuation">;</span>
    <span class="token keyword">int</span> semflg <span class="token operator">=</span> params<span class="token operator">-&gt;</span>flg<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    sma <span class="token operator">=</span> <span class="token function">sem_alloc</span><span class="token punctuation">(</span>nsems<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    sma<span class="token operator">-&gt;</span>sem_perm<span class="token punctuation">.</span>mode <span class="token operator">=</span> <span class="token punctuation">(</span>semflg <span class="token operator">&amp;</span> S_IRWXUGO<span class="token punctuation">)</span><span class="token punctuation">;</span>
    sma<span class="token operator">-&gt;</span>sem_perm<span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
    sma<span class="token operator">-&gt;</span>sem_perm<span class="token punctuation">.</span>security <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nsems<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sma<span class="token operator">-&gt;</span>sems<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>pending_alter<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sma<span class="token operator">-&gt;</span>sems<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>pending_const<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">spin_lock_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sma<span class="token operator">-&gt;</span>sems<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    sma<span class="token operator">-&gt;</span>complex_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    sma<span class="token operator">-&gt;</span>use_global_lock <span class="token operator">=</span> USE_GLOBAL_LOCK_HYSTERESIS<span class="token punctuation">;</span>
    <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sma<span class="token operator">-&gt;</span>pending_alter<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sma<span class="token operator">-&gt;</span>pending_const<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sma<span class="token operator">-&gt;</span>list_id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    sma<span class="token operator">-&gt;</span>sem_nsems <span class="token operator">=</span> nsems<span class="token punctuation">;</span>
    sma<span class="token operator">-&gt;</span>sem_ctime <span class="token operator">=</span> <span class="token function">get_seconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    retval <span class="token operator">=</span> <span class="token function">ipc_addid</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token function">sem_ids</span><span class="token punctuation">(</span>ns<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>sma<span class="token operator">-&gt;</span>sem_perm<span class="token punctuation">,</span> ns<span class="token operator">-&gt;</span>sc_semmni<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    ns<span class="token operator">-&gt;</span>used_sems <span class="token operator">+=</span> nsems<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> sma<span class="token operator">-&gt;</span>sem_perm<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>newary函数的第一步，通过kvmalloc在直接映射区分配一个struct sem_array结构。这个结构是用来描述信号量的，这个结构最开始就是上面说的struct kern_ipc_perm结构。接下来就是填充这个struct sem_array结构，例如key、权限等。</p>
<p>struct sem_array里有多个信号量，放在struct sem sems[]数组里面，在struct sem里面有当前的信号量的数值semval。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sem</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> semval<span class="token punctuation">;</span>                     <span class="token comment">/* current value */</span>
    <span class="token comment">/*
     * PID of the process that last modified the semaphore. For
     * Linux, specifically these are:
     *  - semop
     *  - semctl, via SETVAL and SETALL.
     *  - at task exit when performing undo adjustments (see exit_sem).
     */</span>
    <span class="token keyword">int</span> sempid<span class="token punctuation">;</span>
    spinlock_t  lock<span class="token punctuation">;</span>               <span class="token comment">/* spinlock for fine-grained semtimedop */</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> pending_alter<span class="token punctuation">;</span> <span class="token comment">/* pending single-sop operations that alter the semaphore */</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> pending_const<span class="token punctuation">;</span> <span class="token comment">/* pending single-sop operations that do not alter the semaphore*/</span>
    time_t  sem_otime<span class="token punctuation">;</span>              <span class="token comment">/* candidate for sem_otime */</span>
<span class="token punctuation">}</span> ____cacheline_aligned_in_smp<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>struct sem_array和struct sem各有一个链表struct list_head pending_alter，分别表示对于整个信号量数组的修改和对于某个信号量的修改。</p>
<p>newary函数的第二步，就是初始化这些链表。</p>
<p>newary函数的第三步，通过ipc_addid将新创建的struct sem_array结构，挂到sem_ids里面的基数树上，并返回相应的id。</p>
<p>信号量创建的过程到此结束，接下来我们来看，如何通过semctl对信号量数组进行初始化。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE4</span><span class="token punctuation">(</span>semctl<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> semid<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> semnum<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> cmd<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> version<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">ipc_namespace</span> <span class="token operator">*</span>ns<span class="token punctuation">;</span>
    <span class="token keyword">void</span> __user <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> __user <span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">;</span>
    ns <span class="token operator">=</span> current<span class="token operator">-&gt;</span>nsproxy<span class="token operator">-&gt;</span>ipc_ns<span class="token punctuation">;</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>cmd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> IPC_INFO<span class="token operator">:</span>
    <span class="token keyword">case</span> SEM_INFO<span class="token operator">:</span>
    <span class="token keyword">case</span> IPC_STAT<span class="token operator">:</span>
    <span class="token keyword">case</span> SEM_STAT<span class="token operator">:</span>
        <span class="token keyword">return</span> <span class="token function">semctl_nolock</span><span class="token punctuation">(</span>ns<span class="token punctuation">,</span> semid<span class="token punctuation">,</span> cmd<span class="token punctuation">,</span> version<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> GETALL<span class="token operator">:</span>
    <span class="token keyword">case</span> GETVAL<span class="token operator">:</span>
    <span class="token keyword">case</span> GETPID<span class="token operator">:</span>
    <span class="token keyword">case</span> GETNCNT<span class="token operator">:</span>
    <span class="token keyword">case</span> GETZCNT<span class="token operator">:</span>
    <span class="token keyword">case</span> SETALL<span class="token operator">:</span>
        <span class="token keyword">return</span> <span class="token function">semctl_main</span><span class="token punctuation">(</span>ns<span class="token punctuation">,</span> semid<span class="token punctuation">,</span> semnum<span class="token punctuation">,</span> cmd<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SETVAL<span class="token operator">:</span>
        <span class="token keyword">return</span> <span class="token function">semctl_setval</span><span class="token punctuation">(</span>ns<span class="token punctuation">,</span> semid<span class="token punctuation">,</span> semnum<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> IPC_RMID<span class="token operator">:</span>
    <span class="token keyword">case</span> IPC_SET<span class="token operator">:</span>
        <span class="token keyword">return</span> <span class="token function">semctl_down</span><span class="token punctuation">(</span>ns<span class="token punctuation">,</span> semid<span class="token punctuation">,</span> cmd<span class="token punctuation">,</span> version<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里我们重点看，SETALL操作调用的semctl_main函数，以及SETVAL操作调用的semctl_setval函数。</p>
<p>对于SETALL操作来讲，传进来的参数为union semun里面的unsigned short *array，会设置整个信号量集合。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">semctl_main</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ipc_namespace</span> <span class="token operator">*</span>ns<span class="token punctuation">,</span> <span class="token keyword">int</span> semid<span class="token punctuation">,</span> <span class="token keyword">int</span> semnum<span class="token punctuation">,</span>
        <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">void</span> __user <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">sem_array</span> <span class="token operator">*</span>sma<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sem</span> <span class="token operator">*</span>curr<span class="token punctuation">;</span>
    <span class="token keyword">int</span> err<span class="token punctuation">,</span> nsems<span class="token punctuation">;</span>
    ushort fast_sem_io<span class="token punctuation">[</span>SEMMSL_FAST<span class="token punctuation">]</span><span class="token punctuation">;</span>
    ushort <span class="token operator">*</span>sem_io <span class="token operator">=</span> fast_sem_io<span class="token punctuation">;</span>
    <span class="token function">DEFINE_WAKE_Q</span><span class="token punctuation">(</span>wake_q<span class="token punctuation">)</span><span class="token punctuation">;</span>
    sma <span class="token operator">=</span> <span class="token function">sem_obtain_object_check</span><span class="token punctuation">(</span>ns<span class="token punctuation">,</span> semid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    nsems <span class="token operator">=</span> sma<span class="token operator">-&gt;</span>sem_nsems<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>cmd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">case</span> SETALL<span class="token operator">:</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">int</span> i<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">sem_undo</span> <span class="token operator">*</span>un<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_from_user</span><span class="token punctuation">(</span>sem_io<span class="token punctuation">,</span> p<span class="token punctuation">,</span> nsems<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ushort<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nsems<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sma<span class="token operator">-&gt;</span>sems<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>semval <span class="token operator">=</span> sem_io<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            sma<span class="token operator">-&gt;</span>sems<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sempid <span class="token operator">=</span> <span class="token function">task_tgid_vnr</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        sma<span class="token operator">-&gt;</span>sem_ctime <span class="token operator">=</span> <span class="token function">get_seconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">/* maybe some queued-up processes were waiting for this */</span>
        <span class="token function">do_smart_update</span><span class="token punctuation">(</span>sma<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>wake_q<span class="token punctuation">)</span><span class="token punctuation">;</span>
        err <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> out_unlock<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">wake_up_q</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wake_q<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在semctl_main函数中，先是通过sem_obtain_object_check，根据信号量集合的id在基数树里面找到struct sem_array对象，发现如果是SETALL操作，就将用户的参数中的unsigned short *array通过copy_from_user拷贝到内核里面的sem_io数组，然后是一个循环，对于信号量集合里面的每一个信号量，设置semval，以及修改这个信号量值的pid。</p>
<p>对于SETVAL操作来讲，传进来的参数union semun里面的int val，仅仅会设置某个信号量。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">semctl_setval</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ipc_namespace</span> <span class="token operator">*</span>ns<span class="token punctuation">,</span> <span class="token keyword">int</span> semid<span class="token punctuation">,</span> <span class="token keyword">int</span> semnum<span class="token punctuation">,</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> arg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">sem_undo</span> <span class="token operator">*</span>un<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sem_array</span> <span class="token operator">*</span>sma<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sem</span> <span class="token operator">*</span>curr<span class="token punctuation">;</span>
    <span class="token keyword">int</span> err<span class="token punctuation">,</span> val<span class="token punctuation">;</span>
    <span class="token function">DEFINE_WAKE_Q</span><span class="token punctuation">(</span>wake_q<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    sma <span class="token operator">=</span> <span class="token function">sem_obtain_object_check</span><span class="token punctuation">(</span>ns<span class="token punctuation">,</span> semid<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    curr <span class="token operator">=</span> <span class="token operator">&amp;</span>sma<span class="token operator">-&gt;</span>sems<span class="token punctuation">[</span>semnum<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    curr<span class="token operator">-&gt;</span>semval <span class="token operator">=</span> val<span class="token punctuation">;</span>
    curr<span class="token operator">-&gt;</span>sempid <span class="token operator">=</span> <span class="token function">task_tgid_vnr</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
    sma<span class="token operator">-&gt;</span>sem_ctime <span class="token operator">=</span> <span class="token function">get_seconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* maybe some queued-up processes were waiting for this */</span>
    <span class="token function">do_smart_update</span><span class="token punctuation">(</span>sma<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>wake_q<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">wake_up_q</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wake_q<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在semctl_setval函数中，我们先是通过sem_obtain_object_check，根据信号量集合的id在基数树里面找到struct sem_array对象，对于SETVAL操作，直接根据参数中的val设置semval，以及修改这个信号量值的pid。</p>
<p>至此，信号量数组初始化完毕。接下来我们来看P操作和V操作。无论是P操作，还是V操作都是调用semop系统调用。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>semop<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> semid<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sembuf</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> tsops<span class="token punctuation">,</span>
        <span class="token keyword">unsigned</span><span class="token punctuation">,</span> nsops<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">sys_semtimedop</span><span class="token punctuation">(</span>semid<span class="token punctuation">,</span> tsops<span class="token punctuation">,</span> nsops<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">SYSCALL_DEFINE4</span><span class="token punctuation">(</span>semtimedop<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> semid<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sembuf</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> tsops<span class="token punctuation">,</span>
        <span class="token keyword">unsigned</span><span class="token punctuation">,</span> nsops<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">timespec</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> timeout<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> error <span class="token operator">=</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sem_array</span> <span class="token operator">*</span>sma<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sembuf</span> fast_sops<span class="token punctuation">[</span>SEMOPM_FAST<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sembuf</span> <span class="token operator">*</span>sops <span class="token operator">=</span> fast_sops<span class="token punctuation">,</span> <span class="token operator">*</span>sop<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sem_undo</span> <span class="token operator">*</span>un<span class="token punctuation">;</span>
    <span class="token keyword">int</span> max<span class="token punctuation">,</span> locknum<span class="token punctuation">;</span>
    bool undos <span class="token operator">=</span> false<span class="token punctuation">,</span> alter <span class="token operator">=</span> false<span class="token punctuation">,</span> dupsop <span class="token operator">=</span> false<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sem_queue</span> queue<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> dup <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> jiffies_left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">ipc_namespace</span> <span class="token operator">*</span>ns<span class="token punctuation">;</span>

    ns <span class="token operator">=</span> current<span class="token operator">-&gt;</span>nsproxy<span class="token operator">-&gt;</span>ipc_ns<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_from_user</span><span class="token punctuation">(</span>sops<span class="token punctuation">,</span> tsops<span class="token punctuation">,</span> nsops <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>tsops<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        error <span class="token operator">=</span>  <span class="token operator">-</span>EFAULT<span class="token punctuation">;</span>
        <span class="token keyword">goto</span> out_free<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">timespec</span> _timeout<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_from_user</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_timeout<span class="token punctuation">,</span> timeout<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>timeout<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>
        jiffies_left <span class="token operator">=</span> <span class="token function">timespec_to_jiffies</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* On success, find_alloc_undo takes the rcu_read_lock */</span>
    un <span class="token operator">=</span> <span class="token function">find_alloc_undo</span><span class="token punctuation">(</span>ns<span class="token punctuation">,</span> semid<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    sma <span class="token operator">=</span> <span class="token function">sem_obtain_object_check</span><span class="token punctuation">(</span>ns<span class="token punctuation">,</span> semid<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    queue<span class="token punctuation">.</span>sops <span class="token operator">=</span> sops<span class="token punctuation">;</span>
    queue<span class="token punctuation">.</span>nsops <span class="token operator">=</span> nsops<span class="token punctuation">;</span>
    queue<span class="token punctuation">.</span>undo <span class="token operator">=</span> un<span class="token punctuation">;</span>
    queue<span class="token punctuation">.</span>pid <span class="token operator">=</span> <span class="token function">task_tgid_vnr</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
    queue<span class="token punctuation">.</span>alter <span class="token operator">=</span> alter<span class="token punctuation">;</span>
    queue<span class="token punctuation">.</span>dupsop <span class="token operator">=</span> dupsop<span class="token punctuation">;</span>

    error <span class="token operator">=</span> <span class="token function">perform_atomic_semop</span><span class="token punctuation">(</span>sma<span class="token punctuation">,</span> <span class="token operator">&amp;</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>error <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* non-blocking succesfull path */</span>
        <span class="token function">DEFINE_WAKE_Q</span><span class="token punctuation">(</span>wake_q<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token function">do_smart_update</span><span class="token punctuation">(</span>sma<span class="token punctuation">,</span> sops<span class="token punctuation">,</span> nsops<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>wake_q<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token function">wake_up_q</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wake_q<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> out_free<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/*
     * We need to sleep on this operation, so we put the current
     * task into the pending queue and go to sleep.
     */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nsops <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">sem</span> <span class="token operator">*</span>curr<span class="token punctuation">;</span>
        curr <span class="token operator">=</span> <span class="token operator">&amp;</span>sma<span class="token operator">-&gt;</span>sems<span class="token punctuation">[</span>sops<span class="token operator">-&gt;</span>sem_num<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token function">list_add_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token punctuation">.</span>list<span class="token punctuation">,</span>
                        <span class="token operator">&amp;</span>curr<span class="token operator">-&gt;</span>pending_alter<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token function">list_add_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token punctuation">.</span>list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sma<span class="token operator">-&gt;</span>pending_alter<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        queue<span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token operator">-</span>EINTR<span class="token punctuation">;</span>
        queue<span class="token punctuation">.</span>sleeper <span class="token operator">=</span> current<span class="token punctuation">;</span>

        <span class="token function">__set_current_state</span><span class="token punctuation">(</span>TASK_INTERRUPTIBLE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout<span class="token punctuation">)</span>
            jiffies_left <span class="token operator">=</span> <span class="token function">schedule_timeout</span><span class="token punctuation">(</span>jiffies_left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token comment">/*
         * If an interrupt occurred we have to clean up the queue.
         */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout <span class="token operator">&amp;&amp;</span> jiffies_left <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            error <span class="token operator">=</span> <span class="token operator">-</span>EAGAIN<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>error <span class="token operator">==</span> <span class="token operator">-</span>EINTR <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">signal_pending</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* spurious */</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>semop会调用semtimedop，这是一个非常复杂的函数。</p>
<p>semtimedop做的第一件事情，就是将用户的参数，例如，对于信号量的操作struct sembuf，拷贝到内核里面来。另外，如果是P操作，很可能让进程进入等待状态，是否要为这个等待状态设置一个超时，timeout也是一个参数，会把它变成时钟的滴答数目。</p>
<p>semtimedop做的第二件事情，是通过sem_obtain_object_check，根据信号量集合的id，获得struct sem_array，然后，创建一个struct sem_queue表示当前的信号量操作。为什么叫queue呢？因为这个操作可能马上就能完成，也可能因为无法获取信号量不能完成，不能完成的话就只好排列到队列上，等待信号量满足条件的时候。semtimedop会调用perform_atomic_semop在实施信号量操作。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">perform_atomic_semop</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sem_array</span> <span class="token operator">*</span>sma<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sem_queue</span> <span class="token operator">*</span>q<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> result<span class="token punctuation">,</span> sem_op<span class="token punctuation">,</span> nsops<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sembuf</span> <span class="token operator">*</span>sop<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sem</span> <span class="token operator">*</span>curr<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sembuf</span> <span class="token operator">*</span>sops<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sem_undo</span> <span class="token operator">*</span>un<span class="token punctuation">;</span>

    sops <span class="token operator">=</span> q<span class="token operator">-&gt;</span>sops<span class="token punctuation">;</span>
    nsops <span class="token operator">=</span> q<span class="token operator">-&gt;</span>nsops<span class="token punctuation">;</span>
    un <span class="token operator">=</span> q<span class="token operator">-&gt;</span>undo<span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>sop <span class="token operator">=</span> sops<span class="token punctuation">;</span> sop <span class="token operator">&lt;</span> sops <span class="token operator">+</span> nsops<span class="token punctuation">;</span> sop<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        curr <span class="token operator">=</span> <span class="token operator">&amp;</span>sma<span class="token operator">-&gt;</span>sems<span class="token punctuation">[</span>sop<span class="token operator">-&gt;</span>sem_num<span class="token punctuation">]</span><span class="token punctuation">;</span>
        sem_op <span class="token operator">=</span> sop<span class="token operator">-&gt;</span>sem_op<span class="token punctuation">;</span>
        result <span class="token operator">=</span> curr<span class="token operator">-&gt;</span>semval<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        result <span class="token operator">+=</span> sem_op<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">goto</span> would_block<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>sop<span class="token operator">-&gt;</span>sem_flg <span class="token operator">&amp;</span> SEM_UNDO<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> undo <span class="token operator">=</span> un<span class="token operator">-&gt;</span>semadj<span class="token punctuation">[</span>sop<span class="token operator">-&gt;</span>sem_num<span class="token punctuation">]</span> <span class="token operator">-</span> sem_op<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>sop <span class="token operator">=</span> sops<span class="token punctuation">;</span> sop <span class="token operator">&lt;</span> sops <span class="token operator">+</span> nsops<span class="token punctuation">;</span> sop<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        curr <span class="token operator">=</span> <span class="token operator">&amp;</span>sma<span class="token operator">-&gt;</span>sems<span class="token punctuation">[</span>sop<span class="token operator">-&gt;</span>sem_num<span class="token punctuation">]</span><span class="token punctuation">;</span>
        sem_op <span class="token operator">=</span> sop<span class="token operator">-&gt;</span>sem_op<span class="token punctuation">;</span>
        result <span class="token operator">=</span> curr<span class="token operator">-&gt;</span>semval<span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>sop<span class="token operator">-&gt;</span>sem_flg <span class="token operator">&amp;</span> SEM_UNDO<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> undo <span class="token operator">=</span> un<span class="token operator">-&gt;</span>semadj<span class="token punctuation">[</span>sop<span class="token operator">-&gt;</span>sem_num<span class="token punctuation">]</span> <span class="token operator">-</span> sem_op<span class="token punctuation">;</span>
            un<span class="token operator">-&gt;</span>semadj<span class="token punctuation">[</span>sop<span class="token operator">-&gt;</span>sem_num<span class="token punctuation">]</span> <span class="token operator">=</span> undo<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        curr<span class="token operator">-&gt;</span>semval <span class="token operator">+=</span> sem_op<span class="token punctuation">;</span>
        curr<span class="token operator">-&gt;</span>sempid <span class="token operator">=</span> q<span class="token operator">-&gt;</span>pid<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
would_block<span class="token operator">:</span>
    q<span class="token operator">-&gt;</span>blocking <span class="token operator">=</span> sop<span class="token punctuation">;</span>
    <span class="token keyword">return</span> sop<span class="token operator">-&gt;</span>sem_flg <span class="token operator">&amp;</span> IPC_NOWAIT <span class="token operator">?</span> <span class="token operator">-</span>EAGAIN <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在perform_atomic_semop函数中，对于所有信号量操作都进行两次循环。在第一次循环中，如果发现计算出的result小于0，则说明必须等待，于是跳到would_block中，设置q-&gt;blocking = sop表示这个queue是block在这个操作上，然后如果需要等待，则返回1。如果第一次循环中发现无需等待，则第二个循环实施所有的信号量操作，将信号量的值设置为新的值，并且返回0。</p>
<p>接下来，我们回到semtimedop，来看它干的第三件事情，就是如果需要等待，应该怎么办？</p>
<p>如果需要等待，则要区分刚才的对于信号量的操作，是对一个信号量的，还是对于整个信号量集合的。如果是对于一个信号量的，那我们就将queue挂到这个信号量的pending_alter中；如果是对于整个信号量集合的，那我们就将queue挂到整个信号量集合的pending_alter中。</p>
<p>接下来的do-while循环，就是要开始等待了。如果等待没有时间限制，则调用schedule让出CPU；如果等待有时间限制，则调用schedule_timeout让出CPU，过一段时间还回来。当回来的时候，判断是否等待超时，如果没有等待超时则进入下一轮循环，再次等待，如果超时则退出循环，返回错误。在让出CPU的时候，设置进程的状态为TASK_INTERRUPTIBLE，并且循环的结束会通过signal_pending查看是否收到过信号，这说明这个等待信号量的进程是可以被信号中断的，也即一个等待信号量的进程是可以通过kill杀掉的。</p>
<p>我们再来看，semtimedop要做的第四件事情，如果不需要等待，应该怎么办？</p>
<p>如果不需要等待，就说明对于信号量的操作完成了，也改变了信号量的值。接下来，就是一个标准流程。我们通过DEFINE_WAKE_Q(wake_q)声明一个wake_q，调用do_smart_update，看这次对于信号量的值的改变，可以影响并可以激活等待队列中的哪些struct sem_queue，然后把它们都放在wake_q里面，调用wake_up_q唤醒这些进程。其实，所有的对于信号量的值的修改都会涉及这三个操作，如果你回过头去仔细看SETALL和SETVAL操作，在设置完毕信号量之后，也是这三个操作。</p>
<p>我们来看do_smart_update是如何实现的。do_smart_update会调用update_queue。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">update_queue</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sem_array</span> <span class="token operator">*</span>sma<span class="token punctuation">,</span> <span class="token keyword">int</span> semnum<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">wake_q_head</span> <span class="token operator">*</span>wake_q<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">sem_queue</span> <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token operator">*</span>tmp<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> <span class="token operator">*</span>pending_list<span class="token punctuation">;</span>
    <span class="token keyword">int</span> semop_completed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>semnum <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        pending_list <span class="token operator">=</span> <span class="token operator">&amp;</span>sma<span class="token operator">-&gt;</span>pending_alter<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        pending_list <span class="token operator">=</span> <span class="token operator">&amp;</span>sma<span class="token operator">-&gt;</span>sems<span class="token punctuation">[</span>semnum<span class="token punctuation">]</span><span class="token punctuation">.</span>pending_alter<span class="token punctuation">;</span>

again<span class="token operator">:</span>
    <span class="token function">list_for_each_entry_safe</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> tmp<span class="token punctuation">,</span> pending_list<span class="token punctuation">,</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> error<span class="token punctuation">,</span> restart<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        error <span class="token operator">=</span> <span class="token function">perform_atomic_semop</span><span class="token punctuation">(</span>sma<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* Does q-&gt;sleeper still need to sleep? */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>error <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>

        <span class="token function">unlink_queue</span><span class="token punctuation">(</span>sma<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token function">wake_up_sem_queue_prepare</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> error<span class="token punctuation">,</span> wake_q<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> semop_completed<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">wake_up_sem_queue_prepare</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sem_queue</span> <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token keyword">int</span> error<span class="token punctuation">,</span>
                         <span class="token keyword">struct</span> <span class="token class-name">wake_q_head</span> <span class="token operator">*</span>wake_q<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">wake_q_add</span><span class="token punctuation">(</span>wake_q<span class="token punctuation">,</span> q<span class="token operator">-&gt;</span>sleeper<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>update_queue会依次循环整个信号量集合的等待队列pending_alter，或者某个信号量的等待队列。试图在信号量的值变了的情况下，再次尝试perform_atomic_semop进行信号量操作。如果不成功，则尝试队列中的下一个；如果尝试成功，则调用unlink_queue从队列上取下来，然后调用wake_up_sem_queue_prepare，将q-&gt;sleeper加到wake_q上去。q-&gt;sleeper是一个task_struct，是等待在这个信号量操作上的进程。</p>
<p>接下来，wake_up_q就依次唤醒wake_q上的所有task_struct，调用的是我们在进程调度那一节学过的wake_up_process方法。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">wake_up_q</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">wake_q_head</span> <span class="token operator">*</span>head<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">wake_q_node</span> <span class="token operator">*</span>node <span class="token operator">=</span> head<span class="token operator">-&gt;</span>first<span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> WAKE_Q_TAIL<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>task<span class="token punctuation">;</span>

        task <span class="token operator">=</span> <span class="token function">container_of</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token punctuation">,</span> wake_q<span class="token punctuation">)</span><span class="token punctuation">;</span>

        node <span class="token operator">=</span> node<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        task<span class="token operator">-&gt;</span>wake_q<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

        <span class="token function">wake_up_process</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">put_task_struct</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>至此，对于信号量的主流操作都解析完毕了。</p>
<p>其实还有一点需要强调一下，信号量是一个整个Linux可见的全局资源，而不像咱们在线程同步那一节讲过的都是某个进程独占的资源，好处是可以跨进程通信，坏处就是如果一个进程通过P操作拿到了一个信号量，但是不幸异常退出了，如果没有来得及归还这个信号量，可能所有其他的进程都阻塞了。</p>
<p>那怎么办呢？Linux有一种机制叫SEM_UNDO，也即每一个semop操作都会保存一个反向struct sem_undo操作，当因为某个进程异常退出的时候，这个进程做的所有的操作都会回退，从而保证其他进程可以正常工作。</p>
<p>如果你回头看，我们写的程序里面的semaphore_p函数和semaphore_v函数，都把sem_flg设置为SEM_UNDO，就是这个作用。</p>
<p>等待队列上的每一个struct sem_queue，都有一个struct sem_undo，以此来表示这次操作的反向操作。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sem_queue</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    list<span class="token punctuation">;</span>       <span class="token comment">/* queue of pending operations */</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span>  <span class="token operator">*</span>sleeper<span class="token punctuation">;</span>   <span class="token comment">/* this process */</span>
    <span class="token keyword">struct</span> <span class="token class-name">sem_undo</span>     <span class="token operator">*</span>undo<span class="token punctuation">;</span>      <span class="token comment">/* undo structure */</span>
    <span class="token keyword">int</span>                 pid<span class="token punctuation">;</span>        <span class="token comment">/* process id of requesting process */</span>
    <span class="token keyword">int</span>                 status<span class="token punctuation">;</span>     <span class="token comment">/* completion status of operation */</span>
    <span class="token keyword">struct</span> <span class="token class-name">sembuf</span>       <span class="token operator">*</span>sops<span class="token punctuation">;</span>      <span class="token comment">/* array of pending operations */</span>
    <span class="token keyword">struct</span> <span class="token class-name">sembuf</span>       <span class="token operator">*</span>blocking<span class="token punctuation">;</span>  <span class="token comment">/* the operation that blocked */</span>
    <span class="token keyword">int</span>                 nsops<span class="token punctuation">;</span>      <span class="token comment">/* number of operations */</span>
    bool                alter<span class="token punctuation">;</span>      <span class="token comment">/* does *sops alter the array? */</span>
    bool                dupsop<span class="token punctuation">;</span>     <span class="token comment">/* sops on more than one sem_num */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在进程的task_struct里面对于信号量有一个成员struct sysv_sem，里面是一个struct sem_undo_list，将这个进程所有的semop所带来的undo操作都串起来。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">struct</span> <span class="token class-name">sysv_sem</span>         sysvsem<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">sysv_sem</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">sem_undo_list</span> <span class="token operator">*</span>undo_list<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">sem_undo</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>        list_proc<span class="token punctuation">;</span>  <span class="token comment">/* per-process list: *
                                         * all undos from one process
                                         * rcu protected */</span>
    <span class="token keyword">struct</span> <span class="token class-name">rcu_head</span>         rcu<span class="token punctuation">;</span>        <span class="token comment">/* rcu struct for sem_undo */</span>
    <span class="token keyword">struct</span> <span class="token class-name">sem_undo_list</span>    <span class="token operator">*</span>ulp<span class="token punctuation">;</span>       <span class="token comment">/* back ptr to sem_undo_list */</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>        list_id<span class="token punctuation">;</span>    <span class="token comment">/* per semaphore array list:
                                         * all undos for one array */</span>
    <span class="token keyword">int</span>                     semid<span class="token punctuation">;</span>      <span class="token comment">/* semaphore set identifier */</span>
    <span class="token keyword">short</span>                   <span class="token operator">*</span>semadj<span class="token punctuation">;</span>    <span class="token comment">/* array of adjustments */</span>
                                        <span class="token comment">/* one per semaphore */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">sem_undo_list</span> <span class="token punctuation">{</span>
    atomic_t            refcnt<span class="token punctuation">;</span>
    spinlock_t          lock<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    list_proc<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了让你更清楚地理解struct sem_undo的原理，我们这里举一个例子。</p>
<p>假设我们创建了两个信号量集合。一个叫semaphore1，它包含三个信号量，初始化值为3，另一个叫semaphore2，它包含4个信号量，初始化值都为4。初始化时候的信号量以及undo结构里面的值如图中(1)标号所示。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/sem_undo原理举例.png" alt="sem_undo原理举例"></p>
<p>首先，我们来看进程1。我们调用semop，将semaphore1的三个信号量的值，分别加1、加2和减3，从而信号量的值变为4,5,0。于是在semaphore1和进程1链表交汇的undo结构里面，填写-1,-2,+3，是semop操作的反向操作，如图中(2)标号所示。</p>
<p>然后，我们来看进程2。我们调用semop，将semaphore1的三个信号量的值，分别减3、加2和加1，从而信号量的值变为1、7、1。于是在semaphore1和进程2链表交汇的undo结构里面，填写+3、-2、-1，是semop操作的反向操作，如图中(3)标号所示。</p>
<p>然后，我们接着看进程2。我们调用semop，将semaphore2的四个信号量的值，分别减3、加1、加4和减1，从而信号量的值变为1、5、8、3。于是，在semaphore2和进程2链表交汇的undo结构里面，填写+3、-1、-4、+1，是semop操作的反向操作，如图中(4)标号所示。</p>
<p>然后，我们再来看进程1。我们调用semop，将semaphore2的四个信号量的值，分别减1、减4、减5和加2，从而信号量的值变为0、1、3、5。于是在semaphore2和进程1链表交汇的undo结构里面，填写+1、+4、+5、-2，是semop操作的反向操作，如图中(5)标号所示。</p>
<p>从这个例子可以看出，无论哪个进程异常退出，只要将undo结构里面的值加回当前信号量的值，就能够得到正确的信号量的值，不会因为一个进程退出，导致信号量的值处于不一致的状态。</p>
<h4 id="37-1-总结"><a href="#37-1-总结" class="headerlink" title="37.1 总结"></a>37.1 总结</h4><p>信号量的机制也很复杂，我们对着下面这个图总结一下。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/信号量机制总结.png" alt="信号量机制总结"></p>
<ol>
<li>调用semget创建信号量集合。</li>
<li>ipc_findkey会在基数树中，根据key查找信号量集合sem_array对象。如果已经被创建，就会被查询出来。例如producer被创建过，在consumer中就会查询出来。</li>
<li>如果信号量集合没有被创建过，则调用sem_ops的newary方法，创建一个信号量集合对象sem_array。例如，在producer中就会新建。</li>
<li>调用semctl(SETALL)初始化信号量。</li>
<li>sem_obtain_object_check先从基数树里面找到sem_array对象。</li>
<li>根据用户指定的信号量数组，初始化信号量集合，也即初始化sem_array对象的struct sem sems[]成员。</li>
<li>调用semop操作信号量。</li>
<li>创建信号量操作结构sem_queue，放入队列。</li>
<li>创建undo结构，放入链表。</li>
</ol>
<h2 id="七、网络系统"><a href="#七、网络系统" class="headerlink" title="七、网络系统"></a>七、网络系统</h2><h3 id="38-Socket通信之网络协议基本原理"><a href="#38-Socket通信之网络协议基本原理" class="headerlink" title="38. Socket通信之网络协议基本原理"></a>38. Socket通信之网络协议基本原理</h3><p>上一节我们讲的进程间通信，其实是通过内核的数据结构完成的，主要用于在一台Linux上两个进程之间的通信。但是，一旦超出一台机器的范畴，我们就需要一种跨机器的通信机制。</p>
<p>一台机器将自己想要表达的内容，按照某种约定好的格式发送出去，当另外一台机器收到这些信息后，也能够按照约定好的格式解析出来，从而准确、可靠地获得发送方想要表达的内容。这种约定好的格式就是<strong>网络协议（Networking Protocol）</strong>。</p>
<h4 id="38-1-网络为什么要分层？"><a href="#38-1-网络为什么要分层？" class="headerlink" title="38.1 网络为什么要分层？"></a>38.1 网络为什么要分层？</h4><p>我们这里先构建一个相对简单的场景，之后几节内容，我们都要基于这个场景进行讲解。</p>
<p>我们假设这里就涉及三台机器。Linux服务器A和Linux服务器B处于不同的网段，通过中间的Linux服务器作为路由器进行转发。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/网络场景举例.png" alt="网络场景举例"></p>
<p>说到网络协议，我们还需要简要介绍一下两种网络协议模型，一种是<strong>OSI的标准七层模型</strong>，一种是<strong>业界标准的TCP/IP模型</strong>。它们的对应关系如下图所示：</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/网络协议模型.png" alt="网络协议模型"></p>
<p>为什么网络要分层呢？因为网络环境过于复杂，不是一个能够集中控制的体系。全球数以亿记的服务器和设备各有各的体系，但是都可以通过同一套网络协议栈通过切分成多个层次和组合，来满足不同服务器和设备的通信需求。</p>
<p>我们这里简单介绍一下网络协议的几个层次。</p>
<p>我们从哪一个层次开始呢？从第三层，网络层开始，因为这一层有我们熟悉的IP地址。也因此，这一层我们也叫IP层。</p>
<p>我们通常看到的IP地址都是这个样子的：192.168.1.100/24。斜杠前面是IP地址，这个地址被点分隔为四个部分，每个部分8位，总共是32位。斜线后面24的意思是，32位中，前24位是网络号，后8位是主机号。</p>
<p>为什么要这样分呢？我们可以想象，虽然全世界组成一张大的互联网，美国的网站你也能够访问的，但是这个网络不是一整个的。你们小区有一个网络，你们公司也有一个网络，联通、移动、电信运营商也各有各的网络，所以一个大网络是被分成个小的网络。</p>
<p>那如何区分这些网络呢？这就是网络号的概念。一个网络里面会有多个设备，这些设备的网络号一样，主机号不一样。不信你可以观察一下你家里的手机、电视、电脑。</p>
<p>连接到网络上的每一个设备都至少有一个IP地址，用于定位这个设备。无论是近在咫尺的你旁边同学的电脑，还是远在天边的电商网站，都可以通过IP地址进行定位。因此，<strong>IP地址类似互联网上的邮寄地址，是有全局定位功能的</strong>。</p>
<p>就算你要访问美国的一个地址，也可以从你身边的网络出发，通过不断的打听道儿，经过多个网络，最终到达目的地址，和快递员送包裹的过程差不多。打听道儿的协议也在第三层，称为路由协议（Routing protocol），将网络包从一个网络转发给另一个网络的设备称为路由器。</p>
<p>路由器和路由协议十分复杂，我们这里就不详细讲解了，感兴趣可以去看我写的另一个专栏“趣谈网络协议”里的相关文章。</p>
<p>总而言之，第三层干的事情，就是网络包从一个起始的IP地址，沿着路由协议指的道儿，经过多个网络，通过多次路由器转发，到达目标IP地址。</p>
<p>从第三层，我们往下看，第二层是数据链路层。有时候我们简称为二层或者MAC层。所谓MAC，就是每个网卡都有的唯一的硬件地址（不绝对唯一，相对大概率唯一即可，类比UUID）。这虽然也是一个地址，但是这个地址是没有全局定位功能的。</p>
<p>就像给你送外卖的小哥，不可能根据手机尾号找到你家，但是手机尾号有本地定位功能的，只不过这个定位主要靠“吼”。外卖小哥到了你的楼层就开始大喊：“尾号xxxx的，你外卖到了！”</p>
<p>MAC地址的定位功能局限在一个网络里面，也即同一个网络号下的IP地址之间，可以通过MAC进行定位和通信。从IP地址获取MAC地址要通过ARP协议，是通过在本地发送广播包，也就是“吼”，获得的MAC地址。</p>
<p>由于同一个网络内的机器数量有限，通过MAC地址的好处就是简单。匹配上MAC地址就接收，匹配不上就不接收，没有什么所谓路由协议这样复杂的协议。当然坏处就是，MAC地址的作用范围不能出本地网络，所以一旦跨网络通信，虽然IP地址保持不变，但是MAC地址每经过一个路由器就要换一次。</p>
<p>我们看前面的图。服务器A发送网络包给服务器B，原IP地址始终是192.168.1.100，目标IP地址始终是192.168.2.100，但是在网络1里面，原MAC地址是MAC1，目标MAC地址是路由器的MAC2，路由器转发之后，原MAC地址是路由器的MAC3，目标MAC地址是MAC4。</p>
<p>所以第二层干的事情，就是网络包在本地网络中的服务器之间定位及通信的机制。</p>
<p>我们再往下看，第一层，物理层，这一层就是物理设备。例如连着电脑的网线，我们能连上的WiFi，这一层我们不打算进行分析。</p>
<p>从第三层往上看，第四层是传输层，这里面有两个著名的协议TCP和UDP。尤其是TCP，更是广泛使用，在IP层的代码逻辑中，仅仅负责数据从一个IP地址发送给另一个IP地址，丢包、乱序、重传、拥塞，这些IP层都不管。处理这些问题的代码逻辑写在了传输层的TCP协议里面。</p>
<p>我们常称，TCP是可靠传输协议，也是难为它了。因为从第一层到第三层都不可靠，网络包说丢就丢，是TCP这一层通过各种编号、重传等机制，让本来不可靠的网络对于更上层来讲，变得“看起来”可靠。哪有什么应用层岁月静好，只不过TCP层帮你负重前行。</p>
<p>传输层再往上就是应用层，例如咱们在浏览器里面输入的HTTP，Java服务端写的Servlet，都是这一层的。</p>
<p>二层到四层都是在Linux内核里面处理的，应用层例如浏览器、Nginx、Tomcat都是用户态的。内核里面对于网络包的处理是不区分应用的。</p>
<p>从四层再往上，就需要区分网络包发给哪个应用。在传输层的TCP和UDP协议里面，都有端口的概念，不同的应用监听不同的端口。例如，服务端Nginx监听80、Tomcat监听8080；再如客户端浏览器监听一个随机端口，FTP客户端监听另外一个随机端口。</p>
<p>应用层和内核互通的机制，就是通过Socket系统调用。所以经常有人会问，Socket属于哪一层，其实它哪一层都不属于，它属于操作系统的概念，而非网络协议分层的概念。只不过操作系统选择对于网络协议的实现模式是，二到四层的处理代码在内核里面，七层的处理代码让应用自己去做，两者需要跨内核态和用户态通信，就需要一个系统调用完成这个衔接，这就是Socket。</p>
<h4 id="38-2-发送数据包"><a href="#38-2-发送数据包" class="headerlink" title="38.2 发送数据包"></a>38.2 发送数据包</h4><p>网络分完层之后，对于数据包的发送，就是层层封装的过程。</p>
<p>就像下面的图中展示的一样，在Linux服务器B上部署的服务端Nginx和Tomcat，都是通过Socket监听80和8080端口。这个时候，内核的数据结构就知道了。如果遇到发送到这两个端口的，就发送给这两个进程。</p>
<p>在Linux服务器A上的客户端，打开一个Firefox连接Ngnix。也是通过Socket，客户端会被分配一个随机端口12345。同理，打开一个Chrome连接Tomcat，同样通过Socket分配随机端口12346。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/数据包发送的过程举例.jpeg" alt="数据包发送的过程举例"></p>
<p>在客户端浏览器，我们将请求封装为HTTP协议，通过Socket发送到内核。内核的网络协议栈里面，在TCP层创建用于维护连接、序列号、重传、拥塞控制的数据结构，将HTTP包加上TCP头，发送给IP层，IP层加上IP头，发送给MAC层，MAC层加上MAC头，从硬件网卡发出去。</p>
<p>网络包会先到达网络1的交换机。我们常称交换机为二层设备，这是因为，交换机只会处理到第二层，然后它会将网络包的MAC头拿下来，发现目标MAC是在自己右面的网口，于是就从这个网口发出去。</p>
<p>网络包会到达中间的Linux路由器，它左面的网卡会收到网络包，发现MAC地址匹配，就交给IP层，在IP层根据IP头中的信息，在路由表中查找。下一跳在哪里，应该从哪个网口发出去？在这个例子中，最终会从右面的网口发出去。我们常把路由器称为三层设备，因为它只会处理到第三层。</p>
<p>从路由器右面的网口发出去的包会到网络2的交换机，还是会经历一次二层的处理，转发到交换机右面的网口。</p>
<p>最终网络包会被转发到Linux服务器B，它发现MAC地址匹配，就将MAC头取下来，交给上一层。IP层发现IP地址匹配，将IP头取下来，交给上一层。TCP层会根据TCP头中的序列号等信息，发现它是一个正确的网络包，就会将网络包缓存起来，等待应用层的读取。</p>
<p>应用层通过Socket监听某个端口，因而读取的时候，内核会根据TCP头中的端口号，将网络包发给相应的应用。</p>
<p>HTTP层的头和正文，是应用层来解析的。通过解析，应用层知道了客户端的请求，例如购买一个商品，还是请求一个网页。当应用层处理完HTTP的请求，会将结果仍然封装为HTTP的网络包，通过Socket接口，发送给内核。</p>
<p>内核会经过层层封装，从物理网口发送出去，经过网络2的交换机，Linux路由器到达网络1，经过网络1的交换机，到达Linux服务器A。在Linux服务器A上，经过层层解封装，通过socket接口，根据客户端的随机端口号，发送给客户端的应用程序，浏览器。于是浏览器就能够显示出一个绚丽多彩的页面了。</p>
<p>即便在如此简单的一个环境中，网络包的发送过程，竟然如此的复杂。不过这一章后面，我们还是会层层剖析每一层做的事情。</p>
<h3 id="39-Socket通信"><a href="#39-Socket通信" class="headerlink" title="39. Socket通信"></a>39. Socket通信</h3><p>按照前一篇文章说的分层机制，我们可以想到，socket接口大多数情况下操作的是传输层，更底层的协议不用它来操心，这就是分层的好处。</p>
<p>在传输层有两个主流的协议TCP和UDP，所以我们的socket程序设计也是主要操作这两个协议。这两个协议的区别是什么呢？通常的答案是下面这样的。</p>
<ul>
<li>TCP是面向连接的，UDP是面向无连接的。</li>
<li>TCP提供可靠交付，无差错、不丢失、不重复、并且按序到达；UDP不提供可靠交付，不保证不丢失，不保证按顺序到达。</li>
<li>TCP是面向字节流的，发送时发的是一个流，没头没尾；UDP是面向数据报的，一个一个的发送。</li>
<li>TCP是可以提供流量控制和拥塞控制的，既防止对端被压垮，也防止网络被压垮。</li>
</ul>
<p>这些答案没有问题，但是没有到达本质，也经常让人产生错觉。例如，下面这些问题，你看看你是否了解？</p>
<ul>
<li>所谓的连接，容易让人误以为，使用TCP会使得两端之间的通路和使用UDP不一样，那我们会在沿途建立一条线表示这个连接吗？</li>
<li>我从中国访问美国网站，中间这么多环节，我怎么保证连接不断呢？</li>
<li>中间有个网络管理员拔了一根网线不就断了吗？我不能控制它，它也不会通知我，我一个个人电脑怎么能够保持连接呢？</li>
<li>还让我做流量控制和拥塞控制，我既管不了中间的链路，也管不了对端的服务器呀，我怎么能够做到？</li>
<li>按照网络分层，TCP和UDP都是基于IP协议的，IP都不能保证可靠，说丢就丢，TCP怎么能够保证呢？</li>
<li>IP层都是一个包一个包的发送，TCP怎么就变成流了？</li>
</ul>
<p>从本质上来讲，所谓的<strong>建立连接</strong>，其实是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，并用这样的数据结构来保证面向连接的特性。TCP无法左右中间的任何通路，也没有什么虚拟的连接，中间的通路根本意识不到两端使用了TCP还是UDP。</p>
<p>所谓的<strong>连接</strong>，就是两端数据结构状态的协同，两边的状态能够对得上。符合TCP协议的规则，就认为连接存在；两面状态对不上，连接就算断了。</p>
<p>流量控制和拥塞控制其实就是根据收到的对端的网络包，调整两端数据结构的状态。TCP协议的设计理论上认为，这样调整了数据结构的状态，就能进行流量控制和拥塞控制了，其实在通路上是不是真的做到了，谁也管不着。</p>
<p>所谓的<strong>可靠</strong>，也是两端的数据结构做的事情。不丢失其实是数据结构在“点名”，顺序到达其实是数据结构在“排序”，面向数据流其实是数据结构将零散的包，按照顺序捏成一个流发给应用层。总而言之，“连接”两个字让人误以为功夫在通路，其实功夫在两端。</p>
<p>当然，无论是用socket操作TCP，还是UDP，我们首先都要调用socket函数。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token keyword">int</span> domain<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span> protocol<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>socket函数用于创建一个socket的文件描述符，唯一标识一个socket。我们把它叫作文件描述符，因为在内核中，我们会创建类似文件系统的数据结构，并且后续的操作都有用到它。</p>
<p>socket函数有三个参数。</p>
<ul>
<li>domain：表示使用什么IP层协议。AF_INET表示IPv4，AF_INET6表示IPv6。</li>
<li>type：表示socket类型。SOCK_STREAM，顾名思义就是TCP面向流的，SOCK_DGRAM就是UDP面向数据报的，SOCK_RAW可以直接操作IP层，或者非TCP和UDP的协议。例如ICMP。</li>
<li>protocol表示的协议，包括IPPROTO_TCP、IPPTOTO_UDP。</li>
</ul>
<p>通信结束后，我们还要像关闭文件一样，关闭socket。</p>
<h4 id="39-1-针对TCP应该如何编程？"><a href="#39-1-针对TCP应该如何编程？" class="headerlink" title="39.1 针对TCP应该如何编程？"></a>39.1 针对TCP应该如何编程？</h4><p><img src="/images/《趣谈Linux操作系统》学习笔记/TCP编程流程.png" alt="TCP编程流程"></p>
<p>TCP的服务端要先监听一个端口，一般是先调用bind函数，给这个socket赋予一个端口和IP地址。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span>socklen_t addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> <span class="token punctuation">{</span>
  __kernel_sa_family_t  sin_family<span class="token punctuation">;</span> <span class="token comment">/* Address family       */</span>
  __be16                sin_port<span class="token punctuation">;</span>   <span class="token comment">/* Port number          */</span>
  <span class="token keyword">struct</span> <span class="token class-name">in_addr</span>        sin_addr<span class="token punctuation">;</span>   <span class="token comment">/* Internet address     */</span>

  <span class="token comment">/* Pad to size of `struct sockaddr'. */</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">char</span>         __pad<span class="token punctuation">[</span>__SOCK_SIZE__ <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">short</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">-</span>
                        <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">in_addr</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">in_addr</span> <span class="token punctuation">{</span>
    __be32  s_addr<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，sockfd是上面我们创建的socket文件描述符。在sockaddr_in结构中，sin_family设置为AF_INET，表示IPv4；sin_port是端口号；sin_addr是IP地址。</p>
<p>服务端所在的服务器可能有多个网卡、多个地址，可以选择监听在一个地址，也可以监听0.0.0.0表示所有的地址都监听。服务端一般要监听在一个众所周知的端口上，例如，Nginx一般是80，Tomcat一般是8080。</p>
<p>客户端要访问服务端，肯定事先要知道服务端的端口。无论是电商，还是游戏，还是视频，如果你仔细观察，会发现都有一个这样的端口。可能你会发现，客户端不需要bind，因为浏览器嘛，随机分配一个端口就可以了，只有你主动去连接别人，别人不会主动连接你，没有人关心客户端监听到了哪里。</p>
<p>如果你看上面代码中的数据结构，里面的变量名称都有“be”两个字母，代表的意思是“big-endian”。如果在网络上传输超过1 Byte的类型，就要区分<strong>大端（Big Endian）</strong>和<strong>小端（Little Endian）</strong>。</p>
<p>假设，我们要在32位4 Bytes的一个空间存放整数1，很显然只要1 Byte放1，其他3 Bytes放0就可以了。那问题是，最后一个Byte放1呢，还是第一个Byte放1呢？或者说，1作为最低位，应该放在32位的最后一个位置呢，还是放在第一个位置呢？</p>
<p>最低位放在最后一个位置，我们叫作小端，最低位放在第一个位置，叫作大端。TCP/IP栈是按照大端来设计的，而x86机器多按照小端来设计，因而发出去时需要做一个转换。</p>
<p>接下来，就要建立TCP的连接了，也就是著名的三次握手，其实就是将客户端和服务端的状态通过三次网络交互，达到初始状态是协同的状态。下图就是三次握手的序列图以及对应的状态转换。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/TCP三次握手过程.png" alt="TCP三次握手过程"></p>
<p>接下来，服务端要调用listen进入LISTEN状态，等待客户端进行连接。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">int</span> backlog<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>连接的建立过程，也即三次握手，是TCP层的动作，是在内核完成的，应用层不需要参与。</p>
<p>接着，服务端只需要调用accept，等待内核完成了至少一个连接的建立，才返回。如果没有一个连接完成了三次握手，accept就一直等待；如果有多个客户端发起连接，并且在内核里面完成了多个三次握手，建立了多个连接，这些连接会被放在一个队列里面。accept会从队列里面取出一个来进行处理。如果想进一步处理其他连接，需要调用多次accept，所以accept往往在一个循环里面。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> socklen_t <span class="token operator">*</span>addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>接下来，客户端可以通过connect函数发起连接。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> socklen_t addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>我们先在参数中指明要连接的IP地址和端口号，然后发起三次握手。内核会给客户端分配一个临时的端口。一旦握手成功，服务端的accept就会返回另一个socket。</p>
<p>这里需要注意的是，监听的socket和真正用来传送数据的socket，是两个socket，一个叫作<strong>监听socket</strong>，一个叫作<strong>已连接socket</strong>。成功连接建立之后，双方开始通过read和write函数来读写数据，就像往一个文件流里面写东西一样。</p>
<h4 id="39-2-针对UDP应该如何编程？"><a href="#39-2-针对UDP应该如何编程？" class="headerlink" title="39.2 针对UDP应该如何编程？"></a>39.2 针对UDP应该如何编程？</h4><p><img src="/images/《趣谈Linux操作系统》学习笔记/UDP编程流程.png" alt="UDP编程流程"></p>
<p>UDP是没有连接的，所以不需要三次握手，也就不需要调用listen和connect，但是UDP的交互仍然需要IP地址和端口号，因而也需要bind。</p>
<p>对于UDP来讲，没有所谓的连接维护，也没有所谓的连接的发起方和接收方，甚至都不存在客户端和服务端的概念，大家就都是客户端，也同时都是服务端。只要有一个socket，多台机器就可以任意通信，不存在哪两台机器是属于一个连接的概念。因此，每一个UDP的socket都需要bind。每次通信时，调用sendto和recvfrom，都要传入IP地址和端口。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">ssize_t <span class="token function">sendto</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t len<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>dest_addr<span class="token punctuation">,</span> socklen_t addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
ssize_t <span class="token function">recvfrom</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t len<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>src_addr<span class="token punctuation">,</span> socklen_t <span class="token operator">*</span>addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h4 id="39-3-总结"><a href="#39-3-总结" class="headerlink" title="39.3 总结"></a>39.3 总结</h4><p>socket系统调用是用户态和内核态的接口，网络协议的四层以下都是在内核中的。</p>
<p>TCP协议的socket调用的过程：</p>
<ol>
<li>服务端和客户端都调用socket，得到文件描述符；</li>
<li>服务端调用listen，进行监听；</li>
<li>服务端调用accept，等待客户端连接；</li>
<li>客户端调用connect，连接服务端；</li>
<li>服务端accept返回用于传输的socket的文件描述符；</li>
<li>客户端调用write写入数据；</li>
<li>服务端调用read读取数据。</li>
</ol>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/socket系统调用.png" alt="socket系统调用"></p>
<h3 id="40-Socket内核数据结构"><a href="#40-Socket内核数据结构" class="headerlink" title="40. Socket内核数据结构"></a>40. Socket内核数据结构</h3><h4 id="40-1-解析socket函数"><a href="#40-1-解析socket函数" class="headerlink" title="40.1 解析socket函数"></a>40.1 解析socket函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>socket<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> family<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> protocol<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> retval<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span>sock<span class="token punctuation">;</span>
    <span class="token keyword">int</span> flags<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>SOCK_NONBLOCK <span class="token operator">!=</span> O_NONBLOCK <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> SOCK_NONBLOCK<span class="token punctuation">)</span><span class="token punctuation">)</span>
        flags <span class="token operator">=</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> <span class="token operator">~</span>SOCK_NONBLOCK<span class="token punctuation">)</span> <span class="token operator">|</span> O_NONBLOCK<span class="token punctuation">;</span>

    retval <span class="token operator">=</span> <span class="token function">sock_create</span><span class="token punctuation">(</span>family<span class="token punctuation">,</span> type<span class="token punctuation">,</span> protocol<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    retval <span class="token operator">=</span> <span class="token function">sock_map_fd</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span>O_CLOEXEC <span class="token operator">|</span> O_NONBLOCK<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> retval<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面的代码比较容易看懂，Socket系统调用会调用sock_create创建一个struct socket结构，然后通过sock_map_fd和文件描述符对应起来。</p>
<p>在创建Socket的时候，有三个参数。</p>
<p>一个是<strong>family</strong>，表示地址族。不是所有的Socket都要通过IP进行通信，还有其他的通信方式。例如，下面的定义中，domain sockets就是通过本地文件进行通信的，不需要IP地址。只不过，通过IP地址只是最常用的模式，所以我们这里着重分析这种模式。</p>
<p>第二个参数是<strong>type</strong>，也即Socket的类型。类型是比较少的。</p>
<p>第三个参数是<strong>protocol</strong>，是协议。协议数目是比较多的，也就是说，多个协议会属于同一种类型。</p>
<p>常用的Socket类型有三种，分别是SOCK_STREAM、SOCK_DGRAM和SOCK_RAW。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span> <span class="token class-name">sock_type</span> <span class="token punctuation">{</span>
SOCK_STREAM <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
SOCK_DGRAM <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span>
SOCK_RAW <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>SOCK_STREAM是面向数据流的，协议IPPROTO_TCP属于这种类型。SOCK_DGRAM是面向数据报的，协议IPPROTO_UDP属于这种类型。如果在内核里面看的话，IPPROTO_ICMP也属于这种类型。SOCK_RAW是原始的IP包，IPPROTO_IP属于这种类型。</p>
<p><strong>这一节，我们重点看SOCK_STREAM类型和IPPROTO_TCP协议。</strong></p>
<p>为了管理family、type、protocol这三个分类层次，内核会创建对应的数据结构。</p>
<p>接下来，我们打开sock_create函数看一下。它会调用__sock_create。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">__sock_create</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">net</span> <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">int</span> family<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span> protocol<span class="token punctuation">,</span>
             <span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span><span class="token operator">*</span>res<span class="token punctuation">,</span> <span class="token keyword">int</span> kern<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> err<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span>sock<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">net_proto_family</span> <span class="token operator">*</span>pf<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    sock <span class="token operator">=</span> <span class="token function">sock_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    sock<span class="token operator">-&gt;</span>type <span class="token operator">=</span> type<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    pf <span class="token operator">=</span> <span class="token function">rcu_dereference</span><span class="token punctuation">(</span>net_families<span class="token punctuation">[</span>family<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    err <span class="token operator">=</span> pf<span class="token operator">-&gt;</span><span class="token function">create</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> sock<span class="token punctuation">,</span> protocol<span class="token punctuation">,</span> kern<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token operator">*</span>res <span class="token operator">=</span> sock<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里先是分配了一个struct socket结构。接下来我们要用到family参数。这里有一个net_families数组，我们可以以family参数为下标，找到对应的struct net_proto_family。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Supported address families. */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">AF_UNSPEC   <span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">AF_UNIX     <span class="token number">1</span>       </span><span class="token comment">/* Unix domain sockets      */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">AF_LOCAL    <span class="token number">1</span>       </span><span class="token comment">/* POSIX name for AF_UNIX   */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">AF_INET     <span class="token number">2</span>       </span><span class="token comment">/* Internet IP Protocol     */</span></span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">AF_INET6    <span class="token number">10</span>      </span><span class="token comment">/* IP version 6         */</span></span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">AF_MPLS     <span class="token number">28</span>      </span><span class="token comment">/* MPLS */</span></span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">AF_MAX      <span class="token number">44</span>      </span><span class="token comment">/* For now.. */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">NPROTO      AF_MAX</span></span>

<span class="token keyword">struct</span> <span class="token class-name">net_proto_family</span> __rcu <span class="token operator">*</span>net_families<span class="token punctuation">[</span>NPROTO<span class="token punctuation">]</span> __read_mostly<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们可以找到net_families的定义。每一个地址族在这个数组里面都有一项，里面的内容是net_proto_family。每一种地址族都有自己的net_proto_family，IP地址族的net_proto_family定义如下，里面最重要的就是，create函数指向inet_create。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//net/ipv4/af_inet.c</span>
<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">net_proto_family</span> inet_family_ops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>family <span class="token operator">=</span> PF_INET<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>create <span class="token operator">=</span> inet_create<span class="token punctuation">,</span><span class="token comment">//这个用于socket系统调用创建</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们回到函数__sock_create。接下来，在这里面，这个inet_create会被调用。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">inet_create</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">net</span> <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">int</span> protocol<span class="token punctuation">,</span> <span class="token keyword">int</span> kern<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">inet_protosw</span> <span class="token operator">*</span>answer<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">inet_sock</span> <span class="token operator">*</span>inet<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">proto</span> <span class="token operator">*</span>answer_prot<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> answer_flags<span class="token punctuation">;</span>
    <span class="token keyword">int</span> try_loading_module <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> err<span class="token punctuation">;</span>

    <span class="token comment">/* Look for the requested type/protocol pair. */</span>
lookup_protocol<span class="token operator">:</span>
    <span class="token function">list_for_each_entry_rcu</span><span class="token punctuation">(</span>answer<span class="token punctuation">,</span> <span class="token operator">&amp;</span>inetsw<span class="token punctuation">[</span>sock<span class="token operator">-&gt;</span>type<span class="token punctuation">]</span><span class="token punctuation">,</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        err <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment">/* Check the non-wild match. */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>protocol <span class="token operator">==</span> answer<span class="token operator">-&gt;</span>protocol<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>protocol <span class="token operator">!=</span> IPPROTO_IP<span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">/* Check for the two wild cases. */</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>IPPROTO_IP <span class="token operator">==</span> protocol<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                protocol <span class="token operator">=</span> answer<span class="token operator">-&gt;</span>protocol<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>IPPROTO_IP <span class="token operator">==</span> answer<span class="token operator">-&gt;</span>protocol<span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        err <span class="token operator">=</span> <span class="token operator">-</span>EPROTONOSUPPORT<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    sock<span class="token operator">-&gt;</span>ops <span class="token operator">=</span> answer<span class="token operator">-&gt;</span>ops<span class="token punctuation">;</span>
    answer_prot <span class="token operator">=</span> answer<span class="token operator">-&gt;</span>prot<span class="token punctuation">;</span>
    answer_flags <span class="token operator">=</span> answer<span class="token operator">-&gt;</span>flags<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    sk <span class="token operator">=</span> <span class="token function">sk_alloc</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> PF_INET<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">,</span> answer_prot<span class="token punctuation">,</span> kern<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    inet <span class="token operator">=</span> <span class="token function">inet_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    inet<span class="token operator">-&gt;</span>nodefrag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>SOCK_RAW <span class="token operator">==</span> sock<span class="token operator">-&gt;</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        inet<span class="token operator">-&gt;</span>inet_num <span class="token operator">=</span> protocol<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>IPPROTO_RAW <span class="token operator">==</span> protocol<span class="token punctuation">)</span>
            inet<span class="token operator">-&gt;</span>hdrincl <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    inet<span class="token operator">-&gt;</span>inet_id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">sock_init_data</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> sk<span class="token punctuation">)</span><span class="token punctuation">;</span>

    sk<span class="token operator">-&gt;</span>sk_destruct    <span class="token operator">=</span> inet_sock_destruct<span class="token punctuation">;</span>
    sk<span class="token operator">-&gt;</span>sk_protocol    <span class="token operator">=</span> protocol<span class="token punctuation">;</span>
    sk<span class="token operator">-&gt;</span>sk_backlog_rcv <span class="token operator">=</span> sk<span class="token operator">-&gt;</span>sk_prot<span class="token operator">-&gt;</span>backlog_rcv<span class="token punctuation">;</span>

    inet<span class="token operator">-&gt;</span>uc_ttl    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    inet<span class="token operator">-&gt;</span>mc_loop   <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    inet<span class="token operator">-&gt;</span>mc_ttl    <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    inet<span class="token operator">-&gt;</span>mc_all    <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    inet<span class="token operator">-&gt;</span>mc_index  <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    inet<span class="token operator">-&gt;</span>mc_list   <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    inet<span class="token operator">-&gt;</span>rcv_tos   <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>inet<span class="token operator">-&gt;</span>inet_num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        inet<span class="token operator">-&gt;</span>inet_sport <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>inet<span class="token operator">-&gt;</span>inet_num<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">/* Add to protocol hash chains. */</span>
        err <span class="token operator">=</span> sk<span class="token operator">-&gt;</span>sk_prot<span class="token operator">-&gt;</span><span class="token function">hash</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>sk<span class="token operator">-&gt;</span>sk_prot<span class="token operator">-&gt;</span>init<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        err <span class="token operator">=</span> sk<span class="token operator">-&gt;</span>sk_prot<span class="token operator">-&gt;</span><span class="token function">init</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在inet_create中，我们先会看到一个循环list_for_each_entry_rcu。在这里，第二个参数type开始起作用。因为循环查看的是inetsw[sock-&gt;type]。</p>
<p>这里的inetsw也是一个数组，type作为下标，里面的内容是struct inet_protosw，是协议，也即inetsw数组对于每个类型有一项，这一项里面是属于这个类型的协议。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">list_head</span> inetsw<span class="token punctuation">[</span>SOCK_MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">inet_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* Register the socket-side information for inet_create. */</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token operator">&amp;</span>inetsw<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> r <span class="token operator">&lt;</span> <span class="token operator">&amp;</span>inetsw<span class="token punctuation">[</span>SOCK_MAX<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>r<span class="token punctuation">)</span>
        <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>q <span class="token operator">=</span> inetsw_array<span class="token punctuation">;</span> q <span class="token operator">&lt;</span> <span class="token operator">&amp;</span>inetsw_array<span class="token punctuation">[</span>INETSW_ARRAY_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>q<span class="token punctuation">)</span>
        <span class="token function">inet_register_protosw</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>inetsw数组是在系统初始化的时候初始化的，就像下面代码里面实现的一样。</p>
<p>首先，一个循环会将inetsw数组的每一项，都初始化为一个链表。咱们前面说了，一个type类型会包含多个protocol，因而我们需要一个链表。接下来一个循环，是将inetsw_array注册到inetsw数组里面去。inetsw_array的定义如下，这个数组里面的内容很重要，后面会用到它们。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">inet_protosw</span> inetsw_array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
        <span class="token punctuation">.</span>type <span class="token operator">=</span>       SOCK_STREAM<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>protocol <span class="token operator">=</span>   IPPROTO_TCP<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>prot <span class="token operator">=</span>       <span class="token operator">&amp;</span>tcp_prot<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>ops <span class="token operator">=</span>        <span class="token operator">&amp;</span>inet_stream_ops<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>flags <span class="token operator">=</span>      INET_PROTOSW_PERMANENT <span class="token operator">|</span>
                  INET_PROTOSW_ICSK<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
        <span class="token punctuation">.</span>type <span class="token operator">=</span>       SOCK_DGRAM<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>protocol <span class="token operator">=</span>   IPPROTO_UDP<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>prot <span class="token operator">=</span>       <span class="token operator">&amp;</span>udp_prot<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>ops <span class="token operator">=</span>        <span class="token operator">&amp;</span>inet_dgram_ops<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>flags <span class="token operator">=</span>      INET_PROTOSW_PERMANENT<span class="token punctuation">,</span>
     <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span>
        <span class="token punctuation">.</span>type <span class="token operator">=</span>       SOCK_DGRAM<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>protocol <span class="token operator">=</span>   IPPROTO_ICMP<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>prot <span class="token operator">=</span>       <span class="token operator">&amp;</span>ping_prot<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>ops <span class="token operator">=</span>        <span class="token operator">&amp;</span>inet_sockraw_ops<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>flags <span class="token operator">=</span>      INET_PROTOSW_REUSE<span class="token punctuation">,</span>
     <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span>
        <span class="token punctuation">.</span>type <span class="token operator">=</span>       SOCK_RAW<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>protocol <span class="token operator">=</span>   IPPROTO_IP<span class="token punctuation">,</span>   <span class="token comment">/* wild card */</span>
        <span class="token punctuation">.</span>prot <span class="token operator">=</span>       <span class="token operator">&amp;</span>raw_prot<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>ops <span class="token operator">=</span>        <span class="token operator">&amp;</span>inet_sockraw_ops<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>flags <span class="token operator">=</span>      INET_PROTOSW_REUSE<span class="token punctuation">,</span>
     <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们回到inet_create的list_for_each_entry_rcu循环中。到这里就好理解了，这是在inetsw数组中，根据type找到属于这个类型的列表，然后依次比较列表中的struct inet_protosw的protocol是不是用户指定的protocol；如果是，就得到了符合用户指定的family-&gt;type-&gt;protocol的struct inet_protosw *answer对象。</p>
<p>接下来，struct socket *sock的ops成员变量，被赋值为answer的ops。对于TCP来讲，就是inet_stream_ops。后面任何用户对于这个socket的操作，都是通过inet_stream_ops进行的。</p>
<p>接下来，我们创建一个struct sock *sk对象。这里比较让人困惑。socket和sock看起来几乎一样，容易让人混淆，这里需要说明一下，socket是用于负责对上给用户提供接口，并且和文件系统关联。而sock，负责向下对接内核网络协议栈。</p>
<p>在sk_alloc函数中，struct inet_protosw <em>answer结构的tcp_prot赋值给了struct sock </em>sk的sk_prot成员。tcp_prot的定义如下，里面定义了很多的函数，都是sock之下内核协议栈的动作。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">proto</span> tcp_prot <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>name           <span class="token operator">=</span> <span class="token string">"TCP"</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>owner          <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>close          <span class="token operator">=</span> tcp_close<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>connect        <span class="token operator">=</span> tcp_v4_connect<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>disconnect     <span class="token operator">=</span> tcp_disconnect<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>accept         <span class="token operator">=</span> inet_csk_accept<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>ioctl          <span class="token operator">=</span> tcp_ioctl<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>init           <span class="token operator">=</span> tcp_v4_init_sock<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>destroy        <span class="token operator">=</span> tcp_v4_destroy_sock<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>shutdown       <span class="token operator">=</span> tcp_shutdown<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>setsockopt     <span class="token operator">=</span> tcp_setsockopt<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>getsockopt     <span class="token operator">=</span> tcp_getsockopt<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>keepalive      <span class="token operator">=</span> tcp_set_keepalive<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>recvmsg        <span class="token operator">=</span> tcp_recvmsg<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>sendmsg        <span class="token operator">=</span> tcp_sendmsg<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>sendpage       <span class="token operator">=</span> tcp_sendpage<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>backlog_rcv    <span class="token operator">=</span> tcp_v4_do_rcv<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>release_cb     <span class="token operator">=</span> tcp_release_cb<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>hash           <span class="token operator">=</span> inet_hash<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>get_port       <span class="token operator">=</span> inet_csk_get_port<span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在inet_create函数中，接下来创建一个struct inet_sock结构，这个结构一开始就是struct sock，然后扩展了一些其他的信息，剩下的代码就填充这些信息。这一幕我们会经常看到，将一个结构放在另一个结构的开始位置，然后扩展一些成员，通过对于指针的强制类型转换，来访问这些成员。</p>
<p>socket的创建至此结束。</p>
<h4 id="40-2-解析bind函数"><a href="#40-2-解析bind函数" class="headerlink" title="40.2 解析bind函数"></a>40.2 解析bind函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>bind<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> umyaddr<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> addrlen<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span>sock<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_storage</span> address<span class="token punctuation">;</span>
    <span class="token keyword">int</span> err<span class="token punctuation">,</span> fput_needed<span class="token punctuation">;</span>

    sock <span class="token operator">=</span> <span class="token function">sockfd_lookup_light</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>err<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fput_needed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>sock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        err <span class="token operator">=</span> <span class="token function">move_addr_to_kernel</span><span class="token punctuation">(</span>umyaddr<span class="token punctuation">,</span> addrlen<span class="token punctuation">,</span> <span class="token operator">&amp;</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            err <span class="token operator">=</span> sock<span class="token operator">-&gt;</span>ops<span class="token operator">-&gt;</span><span class="token function">bind</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span>
                              <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span>
                              <span class="token operator">&amp;</span>address<span class="token punctuation">,</span> addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">fput_light</span><span class="token punctuation">(</span>sock<span class="token operator">-&gt;</span>file<span class="token punctuation">,</span> fput_needed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> err<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在bind中，sockfd_lookup_light会根据fd文件描述符，找到struct socket结构。然后将sockaddr从用户态拷贝到内核态，然后调用struct socket结构里面ops的bind函数。根据前面创建socket的时候的设定，调用的是inet_stream_ops的bind函数，也即调用inet_bind。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">inet_bind</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>uaddr<span class="token punctuation">,</span> <span class="token keyword">int</span> addr_len<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> <span class="token operator">*</span>addr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> <span class="token operator">*</span><span class="token punctuation">)</span>uaddr<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk <span class="token operator">=</span> sock<span class="token operator">-&gt;</span>sk<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">inet_sock</span> <span class="token operator">*</span>inet <span class="token operator">=</span> <span class="token function">inet_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">net</span> <span class="token operator">*</span>net <span class="token operator">=</span> <span class="token function">sock_net</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> snum<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    snum <span class="token operator">=</span> <span class="token function">ntohs</span><span class="token punctuation">(</span>addr<span class="token operator">-&gt;</span>sin_port<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    inet<span class="token operator">-&gt;</span>inet_rcv_saddr <span class="token operator">=</span> inet<span class="token operator">-&gt;</span>inet_saddr <span class="token operator">=</span> addr<span class="token operator">-&gt;</span>sin_addr<span class="token punctuation">.</span>s_addr<span class="token punctuation">;</span>
    <span class="token comment">/* Make sure we are allowed to bind here. */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>snum <span class="token operator">||</span> <span class="token operator">!</span>inet<span class="token operator">-&gt;</span>bind_address_no_port<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        sk<span class="token operator">-&gt;</span>sk_prot<span class="token operator">-&gt;</span><span class="token function">get_port</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> snum<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
    inet<span class="token operator">-&gt;</span>inet_sport <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>inet<span class="token operator">-&gt;</span>inet_num<span class="token punctuation">)</span><span class="token punctuation">;</span>
    inet<span class="token operator">-&gt;</span>inet_daddr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    inet<span class="token operator">-&gt;</span>inet_dport <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">sk_dst_reset</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>bind里面会调用sk_prot的get_port函数，也即inet_csk_get_port来检查端口是否冲突，是否可以绑定。如果允许，则会设置struct inet_sock的本方的地址inet_saddr和本方的端口inet_sport，对方的地址inet_daddr和对方的端口inet_dport都初始化为0。</p>
<p>bind的逻辑相对比较简单，就到这里了。</p>
<h4 id="40-3-解析listen函数"><a href="#40-3-解析listen函数" class="headerlink" title="40.3 解析listen函数"></a>40.3 解析listen函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE2</span><span class="token punctuation">(</span>listen<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> backlog<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span>sock<span class="token punctuation">;</span>
    <span class="token keyword">int</span> err<span class="token punctuation">,</span> fput_needed<span class="token punctuation">;</span>
    <span class="token keyword">int</span> somaxconn<span class="token punctuation">;</span>

    sock <span class="token operator">=</span> <span class="token function">sockfd_lookup_light</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>err<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fput_needed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>sock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        somaxconn <span class="token operator">=</span> <span class="token function">sock_net</span><span class="token punctuation">(</span>sock<span class="token operator">-&gt;</span>sk<span class="token punctuation">)</span><span class="token operator">-&gt;</span>core<span class="token punctuation">.</span>sysctl_somaxconn<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>backlog <span class="token operator">&gt;</span> somaxconn<span class="token punctuation">)</span>
            backlog <span class="token operator">=</span> somaxconn<span class="token punctuation">;</span>
        err <span class="token operator">=</span> sock<span class="token operator">-&gt;</span>ops<span class="token operator">-&gt;</span><span class="token function">listen</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> backlog<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">fput_light</span><span class="token punctuation">(</span>sock<span class="token operator">-&gt;</span>file<span class="token punctuation">,</span> fput_needed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> err<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在listen中，我们还是通过sockfd_lookup_light，根据fd文件描述符，找到struct socket结构。接着，我们调用struct socket结构里面ops的listen函数。根据前面创建socket的时候的设定，调用的是inet_stream_ops的listen函数，也即调用inet_listen。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">inet_listen</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">int</span> backlog<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk <span class="token operator">=</span> sock<span class="token operator">-&gt;</span>sk<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> old_state<span class="token punctuation">;</span>
    <span class="token keyword">int</span> err<span class="token punctuation">;</span>
    old_state <span class="token operator">=</span> sk<span class="token operator">-&gt;</span>sk_state<span class="token punctuation">;</span>
    <span class="token comment">/* Really, if the socket is already in listen state
     * we can only allow the backlog to be adjusted.
     */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>old_state <span class="token operator">!=</span> TCP_LISTEN<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        err <span class="token operator">=</span> <span class="token function">inet_csk_listen_start</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> backlog<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    sk<span class="token operator">-&gt;</span>sk_max_ack_backlog <span class="token operator">=</span> backlog<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果这个socket还不在TCP_LISTEN状态，会调用inet_csk_listen_start进入监听状态。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">inet_csk_listen_start</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">int</span> backlog<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">inet_connection_sock</span> <span class="token operator">*</span>icsk <span class="token operator">=</span> <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">inet_sock</span> <span class="token operator">*</span>inet <span class="token operator">=</span> <span class="token function">inet_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> err <span class="token operator">=</span> <span class="token operator">-</span>EADDRINUSE<span class="token punctuation">;</span>

    <span class="token function">reqsk_queue_alloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>icsk<span class="token operator">-&gt;</span>icsk_accept_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>

    sk<span class="token operator">-&gt;</span>sk_max_ack_backlog <span class="token operator">=</span> backlog<span class="token punctuation">;</span>
    sk<span class="token operator">-&gt;</span>sk_ack_backlog <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">inet_csk_delack_init</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">sk_state_store</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> TCP_LISTEN<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sk<span class="token operator">-&gt;</span>sk_prot<span class="token operator">-&gt;</span><span class="token function">get_port</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> inet<span class="token operator">-&gt;</span>inet_num<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面建立了一个新的结构inet_connection_sock，这个结构一开始是struct inet_sock，inet_csk其实做了一次强制类型转换，扩大了结构，看到了吧，又是这个套路。</p>
<p>struct inet_connection_sock结构比较复杂。如果打开它，你能看到处于各种状态的队列，各种超时时间、拥塞控制等字眼。我们说TCP是面向连接的，就是客户端和服务端都是有一个结构维护连接的状态，就是指这个结构。我们这里先不详细分析里面的变量，因为太多了，后面我们遇到一个分析一个。</p>
<p>首先，我们遇到的是icsk_accept_queue。它是干什么的呢？</p>
<p>在TCP的状态里面，有一个listen状态，当调用listen函数之后，就会进入这个状态，虽然我们写程序的时候，一般要等待服务端调用accept后，等待在哪里的时候，让客户端就发起连接。其实服务端一旦处于listen状态，不用accept，客户端也能发起连接。其实TCP的状态中，没有一个是否被accept的状态，那accept函数的作用是什么呢？</p>
<p>在内核中，为每个Socket维护两个队列。一个是已经建立了连接的队列，这时候连接三次握手已经完毕，处于established状态；一个是还没有完全建立连接的队列，这个时候三次握手还没完成，处于syn_rcvd的状态。</p>
<p>服务端调用accept函数，其实是在第一个队列中拿出一个已经完成的连接进行处理。如果还没有完成就阻塞等待。这里的icsk_accept_queue就是第一个队列。</p>
<p>初始化完之后，将TCP的状态设置为TCP_LISTEN，再次调用get_port判断端口是否冲突。</p>
<p>至此，listen的逻辑就结束了。</p>
<h4 id="40-4-解析accept函数"><a href="#40-4-解析accept函数" class="headerlink" title="40.4 解析accept函数"></a>40.4 解析accept函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>accept<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> upeer_sockaddr<span class="token punctuation">,</span>
        <span class="token keyword">int</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> upeer_addrlen<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">sys_accept4</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> upeer_sockaddr<span class="token punctuation">,</span> upeer_addrlen<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">SYSCALL_DEFINE4</span><span class="token punctuation">(</span>accept4<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> upeer_sockaddr<span class="token punctuation">,</span>
        <span class="token keyword">int</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> upeer_addrlen<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token operator">*</span>newsock<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>newfile<span class="token punctuation">;</span>
    <span class="token keyword">int</span> err<span class="token punctuation">,</span> len<span class="token punctuation">,</span> newfd<span class="token punctuation">,</span> fput_needed<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_storage</span> address<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    sock <span class="token operator">=</span> <span class="token function">sockfd_lookup_light</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>err<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fput_needed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    newsock <span class="token operator">=</span> <span class="token function">sock_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    newsock<span class="token operator">-&gt;</span>type <span class="token operator">=</span> sock<span class="token operator">-&gt;</span>type<span class="token punctuation">;</span>
    newsock<span class="token operator">-&gt;</span>ops <span class="token operator">=</span> sock<span class="token operator">-&gt;</span>ops<span class="token punctuation">;</span>
    newfd <span class="token operator">=</span> <span class="token function">get_unused_fd_flags</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    newfile <span class="token operator">=</span> <span class="token function">sock_alloc_file</span><span class="token punctuation">(</span>newsock<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> sock<span class="token operator">-&gt;</span>sk<span class="token operator">-&gt;</span>sk_prot_creator<span class="token operator">-&gt;</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    err <span class="token operator">=</span> sock<span class="token operator">-&gt;</span>ops<span class="token operator">-&gt;</span><span class="token function">accept</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> newsock<span class="token punctuation">,</span> sock<span class="token operator">-&gt;</span>file<span class="token operator">-&gt;</span>f_flags<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>upeer_sockaddr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>newsock<span class="token operator">-&gt;</span>ops<span class="token operator">-&gt;</span><span class="token function">getname</span><span class="token punctuation">(</span>newsock<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span> <span class="token operator">&amp;</span>len<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>
        err <span class="token operator">=</span> <span class="token function">move_addr_to_user</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span>
                    len<span class="token punctuation">,</span> upeer_sockaddr<span class="token punctuation">,</span> upeer_addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">fd_install</span><span class="token punctuation">(</span>newfd<span class="token punctuation">,</span> newfile<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>accept函数的实现，印证了socket的原理中说的那样，原来的socket是监听socket，这里我们会找到原来的struct socket，并基于它去创建一个新的newsock。这才是连接socket。除此之外，我们还会创建一个新的struct file和fd，并关联到socket。</p>
<p>这里面还会调用struct socket的sock-&gt;ops-&gt;accept，也即会调用inet_stream_ops的accept函数，也即inet_accept。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">inet_accept</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span>newsock<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> bool kern<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk1 <span class="token operator">=</span> sock<span class="token operator">-&gt;</span>sk<span class="token punctuation">;</span>
    <span class="token keyword">int</span> err <span class="token operator">=</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk2 <span class="token operator">=</span> sk1<span class="token operator">-&gt;</span>sk_prot<span class="token operator">-&gt;</span><span class="token function">accept</span><span class="token punctuation">(</span>sk1<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> <span class="token operator">&amp;</span>err<span class="token punctuation">,</span> kern<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sock_rps_record_flow</span><span class="token punctuation">(</span>sk2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sock_graft</span><span class="token punctuation">(</span>sk2<span class="token punctuation">,</span> newsock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    newsock<span class="token operator">-&gt;</span>state <span class="token operator">=</span> SS_CONNECTED<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>inet_accept会调用struct sock的sk1-&gt;sk_prot-&gt;accept，也即tcp_prot的accept函数，inet_csk_accept函数。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * This will accept the next outstanding connection.
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span><span class="token function">inet_csk_accept</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>err<span class="token punctuation">,</span> bool kern<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">inet_connection_sock</span> <span class="token operator">*</span>icsk <span class="token operator">=</span> <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">request_sock_queue</span> <span class="token operator">*</span>queue <span class="token operator">=</span> <span class="token operator">&amp;</span>icsk<span class="token operator">-&gt;</span>icsk_accept_queue<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">request_sock</span> <span class="token operator">*</span>req<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>newsk<span class="token punctuation">;</span>
    <span class="token keyword">int</span> error<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>sk<span class="token operator">-&gt;</span>sk_state <span class="token operator">!=</span> TCP_LISTEN<span class="token punctuation">)</span>
        <span class="token keyword">goto</span> out_err<span class="token punctuation">;</span>

    <span class="token comment">/* Find already established connection */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">reqsk_queue_empty</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">long</span> timeo <span class="token operator">=</span> <span class="token function">sock_rcvtimeo</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> flags <span class="token operator">&amp;</span> O_NONBLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span>
        error <span class="token operator">=</span> <span class="token function">inet_csk_wait_for_connect</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> timeo<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    req <span class="token operator">=</span> <span class="token function">reqsk_queue_remove</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    newsk <span class="token operator">=</span> req<span class="token operator">-&gt;</span>sk<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token comment">/*
 * Wait for an incoming connection, avoid race conditions. This must be called
 * with the socket locked.
 */</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">inet_csk_wait_for_connect</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">long</span> timeo<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">inet_connection_sock</span> <span class="token operator">*</span>icsk <span class="token operator">=</span> <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">DEFINE_WAIT</span><span class="token punctuation">(</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> err<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">prepare_to_wait_exclusive</span><span class="token punctuation">(</span><span class="token function">sk_sleep</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait<span class="token punctuation">,</span>
                      TASK_INTERRUPTIBLE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">release_sock</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">reqsk_queue_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>icsk<span class="token operator">-&gt;</span>icsk_accept_queue<span class="token punctuation">)</span><span class="token punctuation">)</span>
            timeo <span class="token operator">=</span> <span class="token function">schedule_timeout</span><span class="token punctuation">(</span>timeo<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sched_annotate_sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">lock_sock</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
        err <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">reqsk_queue_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>icsk<span class="token operator">-&gt;</span>icsk_accept_queue<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        err <span class="token operator">=</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>sk<span class="token operator">-&gt;</span>sk_state <span class="token operator">!=</span> TCP_LISTEN<span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        err <span class="token operator">=</span> <span class="token function">sock_intr_errno</span><span class="token punctuation">(</span>timeo<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">signal_pending</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        err <span class="token operator">=</span> <span class="token operator">-</span>EAGAIN<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timeo<span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">finish_wait</span><span class="token punctuation">(</span><span class="token function">sk_sleep</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> err<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>inet_csk_accept的实现，印证了上面我们讲的两个队列的逻辑。如果icsk_accept_queue为空，则调用inet_csk_wait_for_connect进行等待；等待的时候，调用schedule_timeout，让出CPU，并且将进程状态设置为TASK_INTERRUPTIBLE。</p>
<p>如果再次CPU醒来，我们会接着判断icsk_accept_queue是否为空，同时也会调用signal_pending看有没有信号可以处理。一旦icsk_accept_queue不为空，就从inet_csk_wait_for_connect中返回，在队列中取出一个struct sock对象赋值给newsk。</p>
<h4 id="40-5-解析connect函数"><a href="#40-5-解析connect函数" class="headerlink" title="40.5 解析connect函数"></a>40.5 解析connect函数</h4><p>什么情况下，icsk_accept_queue才不为空呢？当然是三次握手结束才可以。接下来我们来分析三次握手的过程。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/TCP三次握手内核流程.png" alt="TCP三次握手内核流程"></p>
<p>三次握手一般是由客户端调用connect发起。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>connect<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> uservaddr<span class="token punctuation">,</span>
        <span class="token keyword">int</span><span class="token punctuation">,</span> addrlen<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span>sock<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_storage</span> address<span class="token punctuation">;</span>
    <span class="token keyword">int</span> err<span class="token punctuation">,</span> fput_needed<span class="token punctuation">;</span>
    sock <span class="token operator">=</span> <span class="token function">sockfd_lookup_light</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>err<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fput_needed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    err <span class="token operator">=</span> <span class="token function">move_addr_to_kernel</span><span class="token punctuation">(</span>uservaddr<span class="token punctuation">,</span> addrlen<span class="token punctuation">,</span> <span class="token operator">&amp;</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>
    err <span class="token operator">=</span> sock<span class="token operator">-&gt;</span>ops<span class="token operator">-&gt;</span><span class="token function">connect</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span> addrlen<span class="token punctuation">,</span> sock<span class="token operator">-&gt;</span>file<span class="token operator">-&gt;</span>f_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>connect函数的实现一开始你应该很眼熟，还是通过sockfd_lookup_light，根据fd文件描述符，找到struct socket结构。接着，我们会调用struct socket结构里面ops的connect函数，根据前面创建socket的时候的设定，调用inet_stream_ops的connect函数，也即调用inet_stream_connect。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 *  Connect to a remote host. There is regrettably still a little
 *  TCP 'magic' in here.
 */</span>
<span class="token keyword">int</span> <span class="token function">__inet_stream_connect</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>uaddr<span class="token punctuation">,</span>
              <span class="token keyword">int</span> addr_len<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> is_sendmsg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk <span class="token operator">=</span> sock<span class="token operator">-&gt;</span>sk<span class="token punctuation">;</span>
    <span class="token keyword">int</span> err<span class="token punctuation">;</span>
    <span class="token keyword">long</span> timeo<span class="token punctuation">;</span>

    <span class="token keyword">switch</span> <span class="token punctuation">(</span>sock<span class="token operator">-&gt;</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">case</span> SS_UNCONNECTED<span class="token operator">:</span>
        err <span class="token operator">=</span> <span class="token operator">-</span>EISCONN<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>sk<span class="token operator">-&gt;</span>sk_state <span class="token operator">!=</span> TCP_CLOSE<span class="token punctuation">)</span>
            <span class="token keyword">goto</span> out<span class="token punctuation">;</span>

        err <span class="token operator">=</span> sk<span class="token operator">-&gt;</span>sk_prot<span class="token operator">-&gt;</span><span class="token function">connect</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> uaddr<span class="token punctuation">,</span> addr_len<span class="token punctuation">)</span><span class="token punctuation">;</span>
        sock<span class="token operator">-&gt;</span>state <span class="token operator">=</span> SS_CONNECTING<span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    timeo <span class="token operator">=</span> <span class="token function">sock_sndtimeo</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> flags <span class="token operator">&amp;</span> O_NONBLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> sk<span class="token operator">-&gt;</span>sk_state<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>TCPF_SYN_SENT <span class="token operator">|</span> TCPF_SYN_RECV<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timeo <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">inet_wait_for_connect</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> timeo<span class="token punctuation">,</span> writebias<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">goto</span> out<span class="token punctuation">;</span>

        err <span class="token operator">=</span> <span class="token function">sock_intr_errno</span><span class="token punctuation">(</span>timeo<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">signal_pending</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">goto</span> out<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    sock<span class="token operator">-&gt;</span>state <span class="token operator">=</span> SS_CONNECTED<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在__inet_stream_connect里面，我们发现，如果socket处于SS_UNCONNECTED状态，那就调用struct sock的sk-&gt;sk_prot-&gt;connect，也即tcp_prot的connect函数——tcp_v4_connect函数。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_v4_connect</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>uaddr<span class="token punctuation">,</span> <span class="token keyword">int</span> addr_len<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> <span class="token operator">*</span>usin <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> <span class="token operator">*</span><span class="token punctuation">)</span>uaddr<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">inet_sock</span> <span class="token operator">*</span>inet <span class="token operator">=</span> <span class="token function">inet_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">tcp_sock</span> <span class="token operator">*</span>tp <span class="token operator">=</span> <span class="token function">tcp_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    __be16 orig_sport<span class="token punctuation">,</span> orig_dport<span class="token punctuation">;</span>
    __be32 daddr<span class="token punctuation">,</span> nexthop<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">flowi4</span> <span class="token operator">*</span>fl4<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rtable</span> <span class="token operator">*</span>rt<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    orig_sport <span class="token operator">=</span> inet<span class="token operator">-&gt;</span>inet_sport<span class="token punctuation">;</span>
    orig_dport <span class="token operator">=</span> usin<span class="token operator">-&gt;</span>sin_port<span class="token punctuation">;</span>
    rt <span class="token operator">=</span> <span class="token function">ip_route_connect</span><span class="token punctuation">(</span>fl4<span class="token punctuation">,</span> nexthop<span class="token punctuation">,</span> inet<span class="token operator">-&gt;</span>inet_saddr<span class="token punctuation">,</span>
                  <span class="token function">RT_CONN_FLAGS</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> sk<span class="token operator">-&gt;</span>sk_bound_dev_if<span class="token punctuation">,</span>
                  IPPROTO_TCP<span class="token punctuation">,</span>
                  orig_sport<span class="token punctuation">,</span> orig_dport<span class="token punctuation">,</span> sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">tcp_set_state</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> TCP_SYN_SENT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    err <span class="token operator">=</span> <span class="token function">inet_hash_connect</span><span class="token punctuation">(</span>tcp_death_row<span class="token punctuation">,</span> sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sk_set_txhash</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    rt <span class="token operator">=</span> <span class="token function">ip_route_newports</span><span class="token punctuation">(</span>fl4<span class="token punctuation">,</span> rt<span class="token punctuation">,</span> orig_sport<span class="token punctuation">,</span> orig_dport<span class="token punctuation">,</span>
                   inet<span class="token operator">-&gt;</span>inet_sport<span class="token punctuation">,</span> inet<span class="token operator">-&gt;</span>inet_dport<span class="token punctuation">,</span> sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* OK, now commit destination to socket.  */</span>
    sk<span class="token operator">-&gt;</span>sk_gso_type <span class="token operator">=</span> SKB_GSO_TCPV4<span class="token punctuation">;</span>
    <span class="token function">sk_setup_caps</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rt<span class="token operator">-&gt;</span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token operator">!</span>tp<span class="token operator">-&gt;</span>repair<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tp<span class="token operator">-&gt;</span>write_seq<span class="token punctuation">)</span>
            tp<span class="token operator">-&gt;</span>write_seq <span class="token operator">=</span> <span class="token function">secure_tcp_seq</span><span class="token punctuation">(</span>inet<span class="token operator">-&gt;</span>inet_saddr<span class="token punctuation">,</span>
                               inet<span class="token operator">-&gt;</span>inet_daddr<span class="token punctuation">,</span>
                               inet<span class="token operator">-&gt;</span>inet_sport<span class="token punctuation">,</span>
                               usin<span class="token operator">-&gt;</span>sin_port<span class="token punctuation">)</span><span class="token punctuation">;</span>
        tp<span class="token operator">-&gt;</span>tsoffset <span class="token operator">=</span> <span class="token function">secure_tcp_ts_off</span><span class="token punctuation">(</span><span class="token function">sock_net</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span>
                         inet<span class="token operator">-&gt;</span>inet_saddr<span class="token punctuation">,</span>
                         inet<span class="token operator">-&gt;</span>inet_daddr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    rt <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    err <span class="token operator">=</span> <span class="token function">tcp_connect</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在tcp_v4_connect函数中，ip_route_connect其实是做一个路由的选择。为什么呢？因为三次握手马上就要发送一个SYN包了，这就要凑齐源地址、源端口、目标地址、目标端口。目标地址和目标端口是服务端的，已经知道源端口是客户端随机分配的，源地址应该用哪一个呢？这时候要选择一条路由，看从哪个网卡出去，就应该填写哪个网卡的IP地址。</p>
<p>接下来，在发送SYN之前，我们先将客户端socket的状态设置为TCP_SYN_SENT。然后初始化TCP的seq num，也即write_seq，然后调用tcp_connect进行发送。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Build a SYN and send it off. */</span>
<span class="token keyword">int</span> <span class="token function">tcp_connect</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">tcp_sock</span> <span class="token operator">*</span>tp <span class="token operator">=</span> <span class="token function">tcp_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>buff<span class="token punctuation">;</span>
    <span class="token keyword">int</span> err<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">tcp_connect_init</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    buff <span class="token operator">=</span> <span class="token function">sk_stream_alloc_skb</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> sk<span class="token operator">-&gt;</span>sk_allocation<span class="token punctuation">,</span> true<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">tcp_init_nondata_skb</span><span class="token punctuation">(</span>buff<span class="token punctuation">,</span> tp<span class="token operator">-&gt;</span>write_seq<span class="token operator">++</span><span class="token punctuation">,</span> TCPHDR_SYN<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">tcp_mstamp_refresh</span><span class="token punctuation">(</span>tp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    tp<span class="token operator">-&gt;</span>retrans_stamp <span class="token operator">=</span> <span class="token function">tcp_time_stamp</span><span class="token punctuation">(</span>tp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">tcp_connect_queue_skb</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> buff<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">tcp_ecn_send_syn</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> buff<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* Send off SYN; include data in Fast Open. */</span>
    err <span class="token operator">=</span> tp<span class="token operator">-&gt;</span>fastopen_req <span class="token operator">?</span> <span class="token function">tcp_send_syn_data</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> buff<span class="token punctuation">)</span> <span class="token operator">:</span>
          <span class="token function">tcp_transmit_skb</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> buff<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> sk<span class="token operator">-&gt;</span>sk_allocation<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    tp<span class="token operator">-&gt;</span>snd_nxt <span class="token operator">=</span> tp<span class="token operator">-&gt;</span>write_seq<span class="token punctuation">;</span>
    tp<span class="token operator">-&gt;</span>pushed_seq <span class="token operator">=</span> tp<span class="token operator">-&gt;</span>write_seq<span class="token punctuation">;</span>
    buff <span class="token operator">=</span> <span class="token function">tcp_send_head</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        tp<span class="token operator">-&gt;</span>snd_nxt <span class="token operator">=</span> <span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token operator">-&gt;</span>seq<span class="token punctuation">;</span>
        tp<span class="token operator">-&gt;</span>pushed_seq  <span class="token operator">=</span> <span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token operator">-&gt;</span>seq<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* Timer for repeating the SYN until an answer. */</span>
    <span class="token function">inet_csk_reset_xmit_timer</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> ICSK_TIME_RETRANS<span class="token punctuation">,</span>
                  <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token operator">-&gt;</span>icsk_rto<span class="token punctuation">,</span> TCP_RTO_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在tcp_connect中，有一个新的结构struct tcp_sock，如果打开他，你会发现他是struct inet_connection_sock的一个扩展，struct inet_connection_sock在struct tcp_sock开头的位置，通过强制类型转换访问，故伎重演又一次。</p>
<p>struct tcp_sock里面维护了更多的TCP的状态，咱们同样是遇到了再分析。</p>
<p>接下来tcp_init_nondata_skb初始化一个SYN包，tcp_transmit_skb将SYN包发送出去，inet_csk_reset_xmit_timer设置了一个timer，如果SYN发送不成功，则再次发送。</p>
<p>发送网络包的过程，我们放到下一节讲解。这里我们姑且认为SYN已经发送出去了。</p>
<p>我们回到__inet_stream_connect函数，在调用sk-&gt;sk_prot-&gt;connect之后，inet_wait_for_connect会一直等待客户端收到服务端的ACK。而我们知道，服务端在accept之后，也是在等待中。</p>
<p>网络包是如何接收的呢？对于解析的详细过程，我们会在下下节讲解，这里为了解析三次握手，我们简单的看网络包接收到TCP层做的部分事情。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">net_protocol</span> tcp_protocol <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>early_demux         <span class="token operator">=</span>   tcp_v4_early_demux<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>early_demux_handler <span class="token operator">=</span>  tcp_v4_early_demux<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>handler             <span class="token operator">=</span>   tcp_v4_rcv<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>err_handler         <span class="token operator">=</span>   tcp_v4_err<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>no_policy           <span class="token operator">=</span>   <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>netns_ok            <span class="token operator">=</span>   <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>icmp_strict_tag_validation <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们通过struct net_protocol结构中的handler进行接收，调用的函数是tcp_v4_rcv。接下来的调用链为tcp_v4_rcv-&gt;tcp_v4_do_rcv-&gt;tcp_rcv_state_process。tcp_rcv_state_process，顾名思义，是用来处理接收一个网络包后引起状态变化的。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_rcv_state_process</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">tcp_sock</span> <span class="token operator">*</span>tp <span class="token operator">=</span> <span class="token function">tcp_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">inet_connection_sock</span> <span class="token operator">*</span>icsk <span class="token operator">=</span> <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">tcphdr</span> <span class="token operator">*</span>th <span class="token operator">=</span> <span class="token function">tcp_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">request_sock</span> <span class="token operator">*</span>req<span class="token punctuation">;</span>
    <span class="token keyword">int</span> queued <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    bool acceptable<span class="token punctuation">;</span>

    <span class="token keyword">switch</span> <span class="token punctuation">(</span>sk<span class="token operator">-&gt;</span>sk_state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">case</span> TCP_LISTEN<span class="token operator">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>th<span class="token operator">-&gt;</span>syn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            acceptable <span class="token operator">=</span> icsk<span class="token operator">-&gt;</span>icsk_af_ops<span class="token operator">-&gt;</span><span class="token function">conn_request</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>acceptable<span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token function">consume_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>目前服务端是处于TCP_LISTEN状态的，而且发过来的包是SYN，因而就有了上面的代码，调用icsk-&gt;icsk_af_ops-&gt;conn_request函数。struct inet_connection_sock对应的操作是inet_connection_sock_af_ops，按照下面的定义，其实调用的是tcp_v4_conn_request。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">inet_connection_sock_af_ops</span> ipv4_specific <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>queue_xmit        <span class="token operator">=</span> ip_queue_xmit<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>send_check        <span class="token operator">=</span> tcp_v4_send_check<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>rebuild_header    <span class="token operator">=</span> inet_sk_rebuild_header<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>sk_rx_dst_set     <span class="token operator">=</span> inet_sk_rx_dst_set<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>conn_request      <span class="token operator">=</span> tcp_v4_conn_request<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>syn_recv_sock     <span class="token operator">=</span> tcp_v4_syn_recv_sock<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>net_header_len    <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">iphdr</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>setsockopt        <span class="token operator">=</span> ip_setsockopt<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>getsockopt        <span class="token operator">=</span> ip_getsockopt<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>addr2sockaddr     <span class="token operator">=</span> inet_csk_addr2sockaddr<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>sockaddr_len      <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>mtu_reduced       <span class="token operator">=</span> tcp_v4_mtu_reduced<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>tcp_v4_conn_request会调用tcp_conn_request，这个函数也比较长，里面调用了send_synack，但实际调用的是tcp_v4_send_synack。具体发送的过程我们不去管它，看注释我们能知道，这是收到了SYN后，回复一个SYN-ACK，回复完毕后，服务端处于TCP_SYN_RECV。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_conn_request</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">request_sock_ops</span> <span class="token operator">*</span>rsk_ops<span class="token punctuation">,</span>
             <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">tcp_request_sock_ops</span> <span class="token operator">*</span>af_ops<span class="token punctuation">,</span>
             <span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
af_ops<span class="token operator">-&gt;</span><span class="token function">send_synack</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> dst<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fl<span class="token punctuation">,</span> req<span class="token punctuation">,</span> <span class="token operator">&amp;</span>foc<span class="token punctuation">,</span>
                    <span class="token operator">!</span>want_cookie <span class="token operator">?</span> TCP_SYNACK_NORMAL <span class="token operator">:</span>
                           TCP_SYNACK_COOKIE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token comment">/*
 *  Send a SYN-ACK after having received a SYN.
 */</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">tcp_v4_send_synack</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dst_entry</span> <span class="token operator">*</span>dst<span class="token punctuation">,</span>
                  <span class="token keyword">struct</span> <span class="token class-name">flowi</span> <span class="token operator">*</span>fl<span class="token punctuation">,</span>
                  <span class="token keyword">struct</span> <span class="token class-name">request_sock</span> <span class="token operator">*</span>req<span class="token punctuation">,</span>
                  <span class="token keyword">struct</span> <span class="token class-name">tcp_fastopen_cookie</span> <span class="token operator">*</span>foc<span class="token punctuation">,</span>
                  <span class="token keyword">enum</span> <span class="token class-name">tcp_synack_type</span> synack_type<span class="token punctuation">)</span>
<span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个时候，轮到客户端接收网络包了。都是TCP协议栈，所以过程和服务端没有太多区别，还是会走到tcp_rcv_state_process函数的，只不过由于客户端目前处于TCP_SYN_SENT状态，就进入了下面的代码分支。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_rcv_state_process</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">tcp_sock</span> <span class="token operator">*</span>tp <span class="token operator">=</span> <span class="token function">tcp_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">inet_connection_sock</span> <span class="token operator">*</span>icsk <span class="token operator">=</span> <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">tcphdr</span> <span class="token operator">*</span>th <span class="token operator">=</span> <span class="token function">tcp_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">request_sock</span> <span class="token operator">*</span>req<span class="token punctuation">;</span>
    <span class="token keyword">int</span> queued <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    bool acceptable<span class="token punctuation">;</span>

    <span class="token keyword">switch</span> <span class="token punctuation">(</span>sk<span class="token operator">-&gt;</span>sk_state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">case</span> TCP_SYN_SENT<span class="token operator">:</span>
        tp<span class="token operator">-&gt;</span>rx_opt<span class="token punctuation">.</span>saw_tstamp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token function">tcp_mstamp_refresh</span><span class="token punctuation">(</span>tp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        queued <span class="token operator">=</span> <span class="token function">tcp_rcv_synsent_state_process</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> th<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>queued <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> queued<span class="token punctuation">;</span>
        <span class="token comment">/* Do step6 onward by hand. */</span>
        <span class="token function">tcp_urg</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> th<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">__kfree_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">tcp_data_snd_check</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>tcp_rcv_synsent_state_process会调用tcp_send_ack，发送一个ACK-ACK，发送后客户端处于TCP_ESTABLISHED状态。</p>
<p>又轮到服务端接收网络包了，我们还是归tcp_rcv_state_process函数处理。由于服务端目前处于状态TCP_SYN_RECV状态，因而又走了另外的分支。当收到这个网络包的时候，服务端也处于TCP_ESTABLISHED状态，三次握手结束。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_rcv_state_process</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">tcp_sock</span> <span class="token operator">*</span>tp <span class="token operator">=</span> <span class="token function">tcp_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">inet_connection_sock</span> <span class="token operator">*</span>icsk <span class="token operator">=</span> <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">tcphdr</span> <span class="token operator">*</span>th <span class="token operator">=</span> <span class="token function">tcp_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">request_sock</span> <span class="token operator">*</span>req<span class="token punctuation">;</span>
    <span class="token keyword">int</span> queued <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    bool acceptable<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>sk<span class="token operator">-&gt;</span>sk_state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> TCP_SYN_RECV<span class="token operator">:</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>req<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token operator">-&gt;</span>icsk_retransmits <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token function">reqsk_fastopen_remove</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> req<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">/* Make sure socket is routed, for correct metrics. */</span>
            icsk<span class="token operator">-&gt;</span>icsk_af_ops<span class="token operator">-&gt;</span><span class="token function">rebuild_header</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">tcp_call_bpf</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">tcp_init_congestion_control</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token function">tcp_mtup_init</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
            tp<span class="token operator">-&gt;</span>copied_seq <span class="token operator">=</span> tp<span class="token operator">-&gt;</span>rcv_nxt<span class="token punctuation">;</span>
            <span class="token function">tcp_init_buffer_space</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">smp_mb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">tcp_set_state</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> TCP_ESTABLISHED<span class="token punctuation">)</span><span class="token punctuation">;</span>
        sk<span class="token operator">-&gt;</span><span class="token function">sk_state_change</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>sk<span class="token operator">-&gt;</span>sk_socket<span class="token punctuation">)</span>
            <span class="token function">sk_wake_async</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> SOCK_WAKE_IO<span class="token punctuation">,</span> POLL_OUT<span class="token punctuation">)</span><span class="token punctuation">;</span>
        tp<span class="token operator">-&gt;</span>snd_una <span class="token operator">=</span> <span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>ack_seq<span class="token punctuation">;</span>
        tp<span class="token operator">-&gt;</span>snd_wnd <span class="token operator">=</span> <span class="token function">ntohs</span><span class="token punctuation">(</span>th<span class="token operator">-&gt;</span>window<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> tp<span class="token operator">-&gt;</span>rx_opt<span class="token punctuation">.</span>snd_wscale<span class="token punctuation">;</span>
        <span class="token function">tcp_init_wl</span><span class="token punctuation">(</span>tp<span class="token punctuation">,</span> <span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>seq<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="40-6-总结"><a href="#40-6-总结" class="headerlink" title="40.6 总结"></a>40.6 总结</h4><p>这一节除了网络包的接收和发送，其他的系统调用我们都分析到了。可以看出来，它们有一个统一的数据结构和流程。具体如下图所示：</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/Socket内核数据结构总结.png" alt="Socket内核数据结构总结"></p>
<p>首先，Socket系统调用会有三级参数family、type、protocal，通过这三级参数，分别在net_proto_family表中找到type链表，在type链表中找到protocal对应的操作。这个操作分为两层，对于TCP协议来讲，第一层是inet_stream_ops层，第二层是tcp_prot层。</p>
<p>于是，接下来的系统调用规律就都一样了：</p>
<ul>
<li>bind第一层调用inet_stream_ops的inet_bind函数，第二层调用tcp_prot的inet_csk_get_port函数；</li>
<li>listen第一层调用inet_stream_ops的inet_listen函数，第二层调用tcp_prot的inet_csk_get_port函数；</li>
<li>accept第一层调用inet_stream_ops的inet_accept函数，第二层调用tcp_prot的inet_csk_accept函数；</li>
<li>connect第一层调用inet_stream_ops的inet_stream_connect函数，第二层调用tcp_prot的tcp_v4_connect函数。</li>
</ul>
<h3 id="41-发送网络包（上）"><a href="#41-发送网络包（上）" class="headerlink" title="41. 发送网络包（上）"></a>41. 发送网络包（上）</h3><p>分析发送一个网络包的过程。</p>
<h4 id="41-1-解析socket的Write操作"><a href="#41-1-解析socket的Write操作" class="headerlink" title="41.1 解析socket的Write操作"></a>41.1 解析socket的Write操作</h4><p>socket对于用户来讲，是一个文件一样的存在，拥有一个文件描述符。因而对于网络包的发送，我们可以使用对于socket文件的写入系统调用，也就是write系统调用。</p>
<p>write系统调用对于一个文件描述符的操作，大致过程都是类似的。在文件系统那一节，我们已经详细解析过，这里不再多说。对于每一个打开的文件都有一个struct file结构，write系统调用会最终调用stuct file结构指向的file_operations操作。</p>
<p>对于socket来讲，它的file_operations定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> socket_file_ops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>owner <span class="token operator">=</span>        THIS_MODULE<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>llseek <span class="token operator">=</span>       no_llseek<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>read_iter <span class="token operator">=</span>    sock_read_iter<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>write_iter <span class="token operator">=</span>   sock_write_iter<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>poll <span class="token operator">=</span>         sock_poll<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>unlocked_ioctl <span class="token operator">=</span> sock_ioctl<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>mmap <span class="token operator">=</span>         sock_mmap<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>release <span class="token operator">=</span>      sock_close<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>fasync <span class="token operator">=</span>       sock_fasync<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>sendpage <span class="token operator">=</span>     sock_sendpage<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>splice_write <span class="token operator">=</span> generic_splice_sendpage<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>splice_read <span class="token operator">=</span>  sock_splice_read<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>按照文件系统的写入流程，调用的是sock_write_iter。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> ssize_t <span class="token function">sock_write_iter</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kiocb</span> <span class="token operator">*</span>iocb<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">iov_iter</span> <span class="token operator">*</span>from<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file <span class="token operator">=</span> iocb<span class="token operator">-&gt;</span>ki_filp<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span>sock <span class="token operator">=</span> file<span class="token operator">-&gt;</span>private_data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">msghdr</span> msg <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>msg_iter <span class="token operator">=</span> <span class="token operator">*</span>from<span class="token punctuation">,</span>
                 <span class="token punctuation">.</span>msg_iocb <span class="token operator">=</span> iocb<span class="token punctuation">}</span><span class="token punctuation">;</span>
    ssize_t res<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    res <span class="token operator">=</span> <span class="token function">sock_sendmsg</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>from <span class="token operator">=</span> msg<span class="token punctuation">.</span>msg_iter<span class="token punctuation">;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在sock_write_iter中，我们通过VFS中的struct file，将创建好的socket结构拿出来，然后调用sock_sendmsg。而sock_sendmsg会调用sock_sendmsg_nosec。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">sock_sendmsg_nosec</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">msghdr</span> <span class="token operator">*</span>msg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> ret <span class="token operator">=</span> sock<span class="token operator">-&gt;</span>ops<span class="token operator">-&gt;</span><span class="token function">sendmsg</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> <span class="token function">msg_data_left</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里调用了socket的ops的sendmsg，我们在上一节已经遇到它好几次了。根据inet_stream_ops的定义，我们这里调用的是inet_sendmsg。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">inet_sendmsg</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">msghdr</span> <span class="token operator">*</span>msg<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk <span class="token operator">=</span> sock<span class="token operator">-&gt;</span>sk<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> sk<span class="token operator">-&gt;</span>sk_prot<span class="token operator">-&gt;</span><span class="token function">sendmsg</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面，从socket结构中，我们可以得到更底层的sock结构，然后调用sk_prot的sendmsg方法。这个我们同样在上一节遇到好几次了。</p>
<h4 id="41-2-解析tcp-sendmsg函数"><a href="#41-2-解析tcp-sendmsg函数" class="headerlink" title="41.2 解析tcp_sendmsg函数"></a>41.2 解析tcp_sendmsg函数</h4><p>根据tcp_prot的定义，我们调用的是tcp_sendmsg。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_sendmsg</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">msghdr</span> <span class="token operator">*</span>msg<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">tcp_sock</span> <span class="token operator">*</span>tp <span class="token operator">=</span> <span class="token function">tcp_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">;</span>
    <span class="token keyword">int</span> flags<span class="token punctuation">,</span> err<span class="token punctuation">,</span> copied <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> mss_now <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> size_goal<span class="token punctuation">,</span> copied_syn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> timeo<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* Ok commence sending. */</span>
    copied <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
restart<span class="token operator">:</span>
    mss_now <span class="token operator">=</span> <span class="token function">tcp_send_mss</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>size_goal<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">msg_data_left</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> copy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> max <span class="token operator">=</span> size_goal<span class="token punctuation">;</span>

        skb <span class="token operator">=</span> <span class="token function">tcp_write_queue_tail</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tcp_send_head</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>skb<span class="token operator">-&gt;</span>ip_summed <span class="token operator">==</span> CHECKSUM_NONE<span class="token punctuation">)</span>
                max <span class="token operator">=</span> mss_now<span class="token punctuation">;</span>
            copy <span class="token operator">=</span> max <span class="token operator">-</span> skb<span class="token operator">-&gt;</span>len<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>copy <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">tcp_skb_can_collapse_to</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            bool first_skb<span class="token punctuation">;</span>

new_segment<span class="token operator">:</span>
            <span class="token comment">/* Allocate new segment. If the interface is SG,
             * allocate skb fitting to single page.
             */</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">sk_stream_memory_free</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">goto</span> wait_for_sndbuf<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            first_skb <span class="token operator">=</span> <span class="token function">skb_queue_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sk<span class="token operator">-&gt;</span>sk_write_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
            skb <span class="token operator">=</span> <span class="token function">sk_stream_alloc_skb</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span>
                          <span class="token function">select_size</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> sg<span class="token punctuation">,</span> first_skb<span class="token punctuation">)</span><span class="token punctuation">,</span>
                          sk<span class="token operator">-&gt;</span>sk_allocation<span class="token punctuation">,</span>
                          first_skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token function">skb_entail</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
            copy <span class="token operator">=</span> size_goal<span class="token punctuation">;</span>
            max <span class="token operator">=</span> size_goal<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">}</span>

        <span class="token comment">/* Try to append data to the end of skb. */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>copy <span class="token operator">&gt;</span> <span class="token function">msg_data_left</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">)</span>
            copy <span class="token operator">=</span> <span class="token function">msg_data_left</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* Where to copy to? */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">skb_availroom</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">/* We have some space in skb head. Superb! */</span>
            copy <span class="token operator">=</span> <span class="token function">min_t</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> copy<span class="token punctuation">,</span> <span class="token function">skb_availroom</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            err <span class="token operator">=</span> <span class="token function">skb_add_data_nocache</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token operator">-&gt;</span>msg_iter<span class="token punctuation">,</span> copy<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            bool merge <span class="token operator">=</span> true<span class="token punctuation">;</span>
            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">skb_shinfo</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>nr_frags<span class="token punctuation">;</span>
            <span class="token keyword">struct</span> <span class="token class-name">page_frag</span> <span class="token operator">*</span>pfrag <span class="token operator">=</span> <span class="token function">sk_page_frag</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            copy <span class="token operator">=</span> <span class="token function">min_t</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> copy<span class="token punctuation">,</span> pfrag<span class="token operator">-&gt;</span>size <span class="token operator">-</span> pfrag<span class="token operator">-&gt;</span>offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            err <span class="token operator">=</span> <span class="token function">skb_copy_to_page_nocache</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token operator">-&gt;</span>msg_iter<span class="token punctuation">,</span> skb<span class="token punctuation">,</span>
                               pfrag<span class="token operator">-&gt;</span>page<span class="token punctuation">,</span>
                               pfrag<span class="token operator">-&gt;</span>offset<span class="token punctuation">,</span>
                               copy<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            pfrag<span class="token operator">-&gt;</span>offset <span class="token operator">+=</span> copy<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        tp<span class="token operator">-&gt;</span>write_seq <span class="token operator">+=</span> copy<span class="token punctuation">;</span>
        <span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>end_seq <span class="token operator">+=</span> copy<span class="token punctuation">;</span>
        <span class="token function">tcp_skb_pcount_set</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        copied <span class="token operator">+=</span> copy<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">msg_data_left</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> MSG_EOR<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>eor <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">goto</span> out<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>skb<span class="token operator">-&gt;</span>len <span class="token operator">&lt;</span> max <span class="token operator">||</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> MSG_OOB<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">unlikely</span><span class="token punctuation">(</span>tp<span class="token operator">-&gt;</span>repair<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">forced_push</span><span class="token punctuation">(</span>tp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">tcp_mark_push</span><span class="token punctuation">(</span>tp<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">__tcp_push_pending_frames</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> mss_now<span class="token punctuation">,</span> TCP_NAGLE_PUSH<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>skb <span class="token operator">==</span> <span class="token function">tcp_send_head</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token function">tcp_push_one</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> mss_now<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">continue</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>tcp_sendmsg的实现还是很复杂的，这里面做了这样几件事情。</p>
<p>msg是用户要写入的数据，这个数据要拷贝到内核协议栈里面去发送；在内核协议栈里面，网络包的数据都是由struct sk_buff维护的，因而第一件事情就是找到一个空闲的内存空间，将用户要写入的数据，拷贝到struct sk_buff的管辖范围内。而第二件事情就是发送struct sk_buff。</p>
<p>在tcp_sendmsg中，我们首先通过强制类型转换，将sock结构转换为struct tcp_sock，这个是维护TCP连接状态的重要数据结构。</p>
<p>接下来是tcp_sendmsg的第一件事情，把数据拷贝到struct sk_buff。</p>
<p>我们先声明一个变量copied，初始化为0，这表示拷贝了多少数据。紧接着是一个循环，while (msg_data_left(msg))，也即如果用户的数据没有发送完毕，就一直循环。循环里声明了一个copy变量，表示这次拷贝的数值，在循环的最后有copied += copy，将每次拷贝的数量都加起来。</p>
<p>我们这里只需要看一次循环做了哪些事情。</p>
<p><strong>第一步</strong>，tcp_write_queue_tail从TCP写入队列sk_write_queue中拿出最后一个struct sk_buff，在这个写入队列中排满了要发送的struct sk_buff，为什么要拿最后一个呢？这里面只有最后一个，可能会因为上次用户给的数据太少，而没有填满。</p>
<p><strong>第二步</strong>，tcp_send_mss会计算MSS，也即Max Segment Size。这是什么呢？这个意思是说，我们在网络上传输的网络包的大小是有限制的，而这个限制在最底层开始就有。</p>
<p><strong>MTU（Maximum Transmission Unit，最大传输单元）</strong>是二层的一个定义。以以太网为例，MTU为1500个Byte，前面有6个Byte的目标MAC地址，6个Byte的源MAC地址，2个Byte的类型，后面有4个Byte的CRC校验，共1518个Byte。</p>
<p>在IP层，一个IP数据报在以太网中传输，如果它的长度大于该MTU值，就要进行分片传输。</p>
<p>在TCP层有个<strong>MSS（Maximum Segment Size，最大分段大小）</strong>，等于MTU减去IP头，再减去TCP头。也就是，在不分片的情况下，TCP里面放的最大内容。</p>
<p>在这里，max是struct sk_buff的最大数据长度，skb-&gt;len是当前已经占用的skb的数据长度，相减得到当前skb的剩余数据空间。</p>
<p><strong>第三步</strong>，如果copy小于0，说明最后一个struct sk_buff已经没地方存放了，需要调用sk_stream_alloc_skb，重新分配struct sk_buff，然后调用skb_entail，将新分配的sk_buff放到队列尾部。</p>
<p>struct sk_buff是存储网络包的重要的数据结构，在应用层数据包叫data，在TCP层我们称为segment，在IP层我们叫packet，在数据链路层称为frame。在struct sk_buff，首先是一个链表，将struct sk_buff结构串起来。</p>
<p>接下来，我们从headers_start开始，到headers_end结束，里面都是各层次的头的位置。这里面有二层的mac_header、三层的network_header和四层的transport_header。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token punctuation">{</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token punctuation">{</span>
            <span class="token comment">/* These two members must be first. */</span>
            <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span>      <span class="token operator">*</span>next<span class="token punctuation">;</span>
            <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span>      <span class="token operator">*</span>prev<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">rb_node</span>  rbnode<span class="token punctuation">;</span> <span class="token comment">/* used in netem &amp; tcp stack */</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* private: */</span>
    __u32               headers_start<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">/* public: */</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    __u32               priority<span class="token punctuation">;</span>
    <span class="token keyword">int</span>                 skb_iif<span class="token punctuation">;</span>
    __u32               hash<span class="token punctuation">;</span>
    __be16              vlan_proto<span class="token punctuation">;</span>
    __u16               vlan_tci<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        __u32           mark<span class="token punctuation">;</span>
        __u32           reserved_tailroom<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        __be16          inner_protocol<span class="token punctuation">;</span>
        __u8            inner_ipproto<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    __u16               inner_transport_header<span class="token punctuation">;</span>
    __u16               inner_network_header<span class="token punctuation">;</span>
    __u16               inner_mac_header<span class="token punctuation">;</span>

    __be16              protocol<span class="token punctuation">;</span>
    __u16               transport_header<span class="token punctuation">;</span>
    __u16               network_header<span class="token punctuation">;</span>
    __u16               mac_header<span class="token punctuation">;</span>

    <span class="token comment">/* private: */</span>
    __u32               headers_end<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">/* public: */</span>

    <span class="token comment">/* These elements must be at the end, see alloc_skb() for details.  */</span>
    sk_buff_data_t      tail<span class="token punctuation">;</span>
    sk_buff_data_t      end<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span>       <span class="token operator">*</span>head<span class="token punctuation">,</span>
                        <span class="token operator">*</span>data<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        truesize<span class="token punctuation">;</span>
    refcount_t          users<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后几项， head指向分配的内存块起始地址。data这个指针指向的位置是可变的。它有可能随着报文所处的层次而变动。当接收报文时，从网卡驱动开始，通过协议栈层层往上传送数据报，通过增加 skb-&gt;data 的值，来逐步剥离协议首部。而要发送报文时，各协议会创建 sk_buff{}，在经过各下层协议时，通过减少 skb-&gt;data的值来增加协议首部。tail指向数据的结尾，end指向分配的内存块的结束地址。</p>
<p>要分配这样一个结构，sk_stream_alloc_skb会最终调用到__alloc_skb。在这个函数里面，除了分配一个sk_buff结构之外，还要分配sk_buff指向的数据区域。这段数据区域分为下面这几个部分。</p>
<p>第一部分是连续的数据区域。紧接着是第二部分，一个struct skb_shared_info结构。这个结构是对于网络包发送过程的一个优化，因为传输层之上就是应用层了。按照TCP的定义，应用层感受不到下面的网络层的IP包是一个个独立的包的存在的。反正就是一个流，往里写就是了，可能一下子写多了，超过了一个IP包的承载能力，就会出现上面MSS的定义，拆分成一个个的Segment放在一个个的IP包里面，也可能一次写一点，一次写一点，这样数据是分散的，在IP层还要通过内存拷贝合成一个IP包。</p>
<p>为了减少内存拷贝的代价，有的网络设备支持<strong>分散聚合（Scatter/Gather）I/O</strong>，顾名思义，就是IP层没必要通过内存拷贝进行聚合，让散的数据零散的放在原处，在设备层进行聚合。如果使用这种模式，网络包的数据就不会放在连续的数据区域，而是放在struct skb_shared_info结构里面指向的离散数据，skb_shared_info的成员变量skb_frag_t frags[MAX_SKB_FRAGS]，会指向一个数组的页面，就不能保证连续了。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/sk_buff结构.png" alt="sk_buff结构"></p>
<p>于是我们就有了<strong>第四步</strong>。在注释/<em> Where to copy to? </em>/后面有个if-else分支。if分支就是skb_add_data_nocache将数据拷贝到连续的数据区域。else分支就是skb_copy_to_page_nocache将数据拷贝到struct skb_shared_info结构指向的不需要连续的页面区域。</p>
<p><strong>第五步</strong>，就是要发生网络包了。第一种情况是积累的数据报数目太多了，因而我们需要通过调用<strong>tcp_push_pending_frames发送网络包。第二种情况是，这是第一个网络包，需要马上发送，调用tcp_push_one。无论</strong>tcp_push_pending_frames还是tcp_push_one，都会调用tcp_write_xmit发送网络包。</p>
<p>至此，tcp_sendmsg解析完了。</p>
<h4 id="41-3-解析tcp-write-xmit函数"><a href="#41-3-解析tcp-write-xmit函数" class="headerlink" title="41.3 解析tcp_write_xmit函数"></a>41.3 解析tcp_write_xmit函数</h4><p>接下来我们来看，tcp_write_xmit是如何发送网络包的。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> bool <span class="token function">tcp_write_xmit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> mss_now<span class="token punctuation">,</span> <span class="token keyword">int</span> nonagle<span class="token punctuation">,</span> <span class="token keyword">int</span> push_one<span class="token punctuation">,</span> gfp_t gfp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">tcp_sock</span> <span class="token operator">*</span>tp <span class="token operator">=</span> <span class="token function">tcp_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> tso_segs<span class="token punctuation">,</span> sent_pkts<span class="token punctuation">;</span>
    <span class="token keyword">int</span> cwnd_quota<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    max_segs <span class="token operator">=</span> <span class="token function">tcp_tso_segs</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> mss_now<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>skb <span class="token operator">=</span> <span class="token function">tcp_send_head</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> limit<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        tso_segs <span class="token operator">=</span> <span class="token function">tcp_init_tso_segs</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> mss_now<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        cwnd_quota <span class="token operator">=</span> <span class="token function">tcp_cwnd_test</span><span class="token punctuation">(</span>tp<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tcp_snd_wnd_test</span><span class="token punctuation">(</span>tp<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> mss_now<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            is_rwnd_limited <span class="token operator">=</span> true<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        limit <span class="token operator">=</span> mss_now<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>tso_segs <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">tcp_urg_mode</span><span class="token punctuation">(</span>tp<span class="token punctuation">)</span><span class="token punctuation">)</span>
            limit <span class="token operator">=</span> <span class="token function">tcp_mss_split_point</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> mss_now<span class="token punctuation">,</span> <span class="token function">min_t</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> cwnd_quota<span class="token punctuation">,</span> max_segs<span class="token punctuation">)</span><span class="token punctuation">,</span> nonagle<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>skb<span class="token operator">-&gt;</span>len <span class="token operator">&gt;</span> limit <span class="token operator">&amp;&amp;</span>
            <span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token function">tso_fragment</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> limit<span class="token punctuation">,</span> mss_now<span class="token punctuation">,</span> gfp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token function">tcp_transmit_skb</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> gfp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>

repair<span class="token operator">:</span>
        <span class="token comment">/* Advance the send_head.  This one is sent out.
         * This call will increment packets_out.
         */</span>
        <span class="token function">tcp_event_new_data_sent</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">tcp_minshall_update</span><span class="token punctuation">(</span>tp<span class="token punctuation">,</span> mss_now<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
        sent_pkts <span class="token operator">+=</span> <span class="token function">tcp_skb_pcount</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>push_one<span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面主要的逻辑是一个循环，用来处理发送队列，只要队列不空，就会发送。</p>
<p>在一个循环中，涉及TCP层的很多传输算法，我们来一一解析。</p>
<p>第一个概念是<strong>TSO（TCP Segmentation Offload）</strong>。如果发送的网络包非常大，就像上面说的一样，要进行分段。分段这个事情可以由协议栈代码在内核做，但是缺点是比较费CPU，另一种方式是延迟到硬件网卡去做，需要网卡支持对大数据包进行自动分段，可以降低CPU负载。</p>
<p>在代码中，tcp_init_tso_segs会调用tcp_set_skb_tso_segs。这里面有这样的语句：DIV_ROUND_UP(skb-&gt;len, mss_now)。也就是sk_buff的长度除以mss_now，应该分成几个段。如果算出来要分成多个段，接下来就是要看，是在这里（协议栈的代码里面）分好，还是等待到了底层网卡再分。</p>
<p>于是，调用函数tcp_mss_split_point，开始计算切分的limit。这里面会计算max_len = mss_now * max_segs，根据现在不切分来计算limit，所以下一步的判断中，大部分情况下tso_fragment不会被调用，等待到了底层网卡来切分。</p>
<p>第二个概念是<strong>拥塞窗口</strong>的概念（cwnd，congestion window），也就是说为了避免拼命发包，把网络塞满了，定义一个窗口的概念，在这个窗口之内的才能发送，超过这个窗口的就不能发送，来控制发送的频率。</p>
<p>那窗口大小是多少呢？就是遵循下面这个著名的拥塞窗口变化图。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/著名的拥塞窗口变化图.png" alt="著名的拥塞窗口变化图"></p>
<p>一开始的窗口只有一个mss大小叫作slow start（慢启动）。一开始的增长速度的很快的，翻倍增长。一旦到达一个临界值ssthresh，就变成线性增长，我们就称为<strong>拥塞避免</strong>。什么时候算真正拥塞呢？就是出现了丢包。一旦丢包，一种方法是马上降回到一个mss，然后重复先翻倍再线性对的过程。如果觉得太过激进，也可以有第二种方法，就是降到当前cwnd的一半，然后进行线性增长。</p>
<p>在代码中，tcp_cwnd_test会将当前的snd_cwnd，减去已经在窗口里面尚未发送完毕的网络包，那就是剩下的窗口大小cwnd_quota，也即就能发送这么多了。</p>
<p>第三个概念就是<strong>接收窗口</strong>rwnd的概念（receive window），也叫滑动窗口。如果说拥塞窗口是为了怕把网络塞满，在出现丢包的时候减少发送速度，那么滑动窗口就是为了怕把接收方塞满，而控制发送速度。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/滑动窗口一.png" alt="滑动窗口一"></p>
<p>滑动窗口，其实就是接收方告诉发送方自己的网络包的接收能力，超过这个能力，我就受不了了。因为滑动窗口的存在，将发送方的缓存分成了四个部分。</p>
<ul>
<li>第一部分：发送了并且已经确认的。这部分是已经发送完毕的网络包，这部分没有用了，可以回收。</li>
<li>第二部分：发送了但尚未确认的。这部分，发送方要等待，万一发送不成功，还要重新发送，所以不能删除。</li>
<li>第三部分：没有发送，但是已经等待发送的。这部分是接收方空闲的能力，可以马上发送，接收方收得了。</li>
<li>第四部分：没有发送，并且暂时还不会发送的。这部分已经超过了接收方的接收能力，再发送接收方就收不了了。</li>
</ul>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/滑动窗口二.png" alt="滑动窗口二"></p>
<p>因为滑动窗口的存在，接收方的缓存也要分成了三个部分。</p>
<ul>
<li>第一部分：接受并且确认过的任务。这部分完全接收成功了，可以交给应用层了。</li>
<li>第二部分：还没接收，但是马上就能接收的任务。这部分有的网络包到达了，但是还没确认，不算完全完毕，有的还没有到达，那就是接收方能够接受的最大的网络包数量。</li>
<li>第三部分：还没接收，也没法接收的任务。这部分已经超出接收方能力。</li>
</ul>
<p>在网络包的交互过程中，接收方会将第二部分的大小，作为AdvertisedWindow发送给发送方，发送方就可以根据他来调整发送速度了。</p>
<p>在tcp_snd_wnd_test函数中，会判断sk_buff中的end_seq和tcp_wnd_end(tp)之间的关系，也即这个sk_buff是否在滑动窗口的允许范围之内。如果不在范围内，说明发送要受限制了，我们就要把is_rwnd_limited设置为true。</p>
<p>接下来，tcp_mss_split_point函数要被调用了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">tcp_mss_split_point</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span>
                                        <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">,</span>
                                        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> mss_now<span class="token punctuation">,</span>
                                        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> max_segs<span class="token punctuation">,</span>
                                        <span class="token keyword">int</span> nonagle<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">tcp_sock</span> <span class="token operator">*</span>tp <span class="token operator">=</span> <span class="token function">tcp_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
        u32 partial<span class="token punctuation">,</span> needed<span class="token punctuation">,</span> window<span class="token punctuation">,</span> max_len<span class="token punctuation">;</span>

        window <span class="token operator">=</span> <span class="token function">tcp_wnd_end</span><span class="token punctuation">(</span>tp<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>seq<span class="token punctuation">;</span>
        max_len <span class="token operator">=</span> mss_now <span class="token operator">*</span> max_segs<span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>max_len <span class="token operator">&lt;=</span> window <span class="token operator">&amp;&amp;</span> skb <span class="token operator">!=</span> <span class="token function">tcp_write_queue_tail</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> max_len<span class="token punctuation">;</span>

        needed <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>skb<span class="token operator">-&gt;</span>len<span class="token punctuation">,</span> window<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>max_len <span class="token operator">&lt;=</span> needed<span class="token punctuation">)</span>
                <span class="token keyword">return</span> max_len<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">return</span> needed<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面除了会判断上面讲的，是否会因为超出mss而分段，还会判断另一个条件，就是是否在滑动窗口的运行范围之内，如果小于窗口的大小，也需要分段，也即需要调用tso_fragment。</p>
<p>在一个循环的最后，是调用tcp_transmit_skb，真的去发送一个网络包。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">tcp_transmit_skb</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">int</span> clone_it<span class="token punctuation">,</span>
                gfp_t gfp_mask<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">inet_connection_sock</span> <span class="token operator">*</span>icsk <span class="token operator">=</span> <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">inet_sock</span> <span class="token operator">*</span>inet<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">tcp_sock</span> <span class="token operator">*</span>tp<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">tcp_skb_cb</span> <span class="token operator">*</span>tcb<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">tcphdr</span> <span class="token operator">*</span>th<span class="token punctuation">;</span>
    <span class="token keyword">int</span> err<span class="token punctuation">;</span>

    tp <span class="token operator">=</span> <span class="token function">tcp_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>

    skb<span class="token operator">-&gt;</span>skb_mstamp <span class="token operator">=</span> tp<span class="token operator">-&gt;</span>tcp_mstamp<span class="token punctuation">;</span>
    inet <span class="token operator">=</span> <span class="token function">inet_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    tcb <span class="token operator">=</span> <span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>opts<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>opts<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    tcp_header_size <span class="token operator">=</span> tcp_options_size <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">tcphdr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">skb_push</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> tcp_header_size<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* Build TCP header and checksum it. */</span>
    th <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">tcphdr</span> <span class="token operator">*</span><span class="token punctuation">)</span>skb<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
    th<span class="token operator">-&gt;</span>source      <span class="token operator">=</span> inet<span class="token operator">-&gt;</span>inet_sport<span class="token punctuation">;</span>
    th<span class="token operator">-&gt;</span>dest        <span class="token operator">=</span> inet<span class="token operator">-&gt;</span>inet_dport<span class="token punctuation">;</span>
    th<span class="token operator">-&gt;</span>seq         <span class="token operator">=</span> <span class="token function">htonl</span><span class="token punctuation">(</span>tcb<span class="token operator">-&gt;</span>seq<span class="token punctuation">)</span><span class="token punctuation">;</span>
    th<span class="token operator">-&gt;</span>ack_seq     <span class="token operator">=</span> <span class="token function">htonl</span><span class="token punctuation">(</span>tp<span class="token operator">-&gt;</span>rcv_nxt<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>__be16 <span class="token operator">*</span><span class="token punctuation">)</span>th<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">6</span><span class="token punctuation">)</span>   <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>tcp_header_size <span class="token operator">&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span> <span class="token operator">|</span>
                    tcb<span class="token operator">-&gt;</span>tcp_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>

    th<span class="token operator">-&gt;</span>check       <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    th<span class="token operator">-&gt;</span>urg_ptr     <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">tcp_options_write</span><span class="token punctuation">(</span><span class="token punctuation">(</span>__be32 <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>th <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> tp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>opts<span class="token punctuation">)</span><span class="token punctuation">;</span>
    th<span class="token operator">-&gt;</span>window  <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token function">min</span><span class="token punctuation">(</span>tp<span class="token operator">-&gt;</span>rcv_wnd<span class="token punctuation">,</span> <span class="token number">65535U</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    err <span class="token operator">=</span> icsk<span class="token operator">-&gt;</span>icsk_af_ops<span class="token operator">-&gt;</span><span class="token function">queue_xmit</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>inet<span class="token operator">-&gt;</span>cork<span class="token punctuation">.</span>fl<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>tcp_transmit_skb这个函数比较长，主要做了两件事情，第一件事情就是填充TCP头，如果我们对着TCP头的格式。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/TCP头格式.png" alt="TCP头格式"></p>
<p>这里面有源端口，设置为inet_sport，有目标端口，设置为inet_dport；有序列号，设置为tcb-&gt;seq；有确认序列号，设置为tp-&gt;rcv_nxt。我们把所有的flags设置为tcb-&gt;tcp_flags。设置选项为opts。设置窗口大小为tp-&gt;rcv_wnd。</p>
<p>全部设置完毕之后，就会调用icsk_af_ops的queue_xmit方法，icsk_af_ops指向ipv4_specific，也即调用的是ip_queue_xmit函数。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">inet_connection_sock_af_ops</span> ipv4_specific <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>queue_xmit        <span class="token operator">=</span> ip_queue_xmit<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>send_check        <span class="token operator">=</span> tcp_v4_send_check<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>rebuild_header    <span class="token operator">=</span> inet_sk_rebuild_header<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>sk_rx_dst_set     <span class="token operator">=</span> inet_sk_rx_dst_set<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>conn_request      <span class="token operator">=</span> tcp_v4_conn_request<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>syn_recv_sock     <span class="token operator">=</span> tcp_v4_syn_recv_sock<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>net_header_len    <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">iphdr</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>setsockopt        <span class="token operator">=</span> ip_setsockopt<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>getsockopt        <span class="token operator">=</span> ip_getsockopt<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>addr2sockaddr     <span class="token operator">=</span> inet_csk_addr2sockaddr<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>sockaddr_len      <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>mtu_reduced       <span class="token operator">=</span> tcp_v4_mtu_reduced<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="41-4-总结"><a href="#41-4-总结" class="headerlink" title="41.4 总结"></a>41.4 总结</h4><p>这一节，我们解析了发送一个网络包的一部分过程，如下图所示。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/发送一个网络包的一部分过程.png" alt="发送一个网络包的一部分过程"></p>
<p>这个过程分成几个层次。</p>
<ul>
<li>VFS层：write系统调用找到struct file，根据里面的file_operations的定义，调用sock_write_iter函数。sock_write_iter函数调用sock_sendmsg函数。</li>
<li>Socket层：从struct file里面的private_data得到struct socket，根据里面ops的定义，调用inet_sendmsg函数。</li>
<li>Sock层：从struct socket里面的sk得到struct sock，根据里面sk_prot的定义，调用tcp_sendmsg函数。</li>
<li>TCP层：tcp_sendmsg函数会调用tcp_write_xmit函数，tcp_write_xmit函数会调用tcp_transmit_skb，在这里实现了TCP层面向连接的逻辑。</li>
<li>IP层：扩展struct sock，得到struct inet_connection_sock，根据里面icsk_af_ops的定义，调用ip_queue_xmit函数。</li>
</ul>
<h3 id="42-发送网络包（下）"><a href="#42-发送网络包（下）" class="headerlink" title="42. 发送网络包（下）"></a>42. 发送网络包（下）</h3><p>上一节我们讲网络包的发送，讲了上半部分，也即从VFS层一直到IP层，这一节我们接着看下去，看IP层和MAC层是如何发送数据的。</p>
<h4 id="42-1-解析ip-queue-xmit函数"><a href="#42-1-解析ip-queue-xmit函数" class="headerlink" title="42.1 解析ip_queue_xmit函数"></a>42.1 解析ip_queue_xmit函数</h4><p>从ip_queue_xmit函数开始，我们就要进入IP层的发送逻辑了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">ip_queue_xmit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">flowi</span> <span class="token operator">*</span>fl<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">inet_sock</span> <span class="token operator">*</span>inet <span class="token operator">=</span> <span class="token function">inet_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">net</span> <span class="token operator">*</span>net <span class="token operator">=</span> <span class="token function">sock_net</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">ip_options_rcu</span> <span class="token operator">*</span>inet_opt<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">flowi4</span> <span class="token operator">*</span>fl4<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rtable</span> <span class="token operator">*</span>rt<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">iphdr</span> <span class="token operator">*</span>iph<span class="token punctuation">;</span>
    <span class="token keyword">int</span> res<span class="token punctuation">;</span>

    inet_opt <span class="token operator">=</span> <span class="token function">rcu_dereference</span><span class="token punctuation">(</span>inet<span class="token operator">-&gt;</span>inet_opt<span class="token punctuation">)</span><span class="token punctuation">;</span>
    fl4 <span class="token operator">=</span> <span class="token operator">&amp;</span>fl<span class="token operator">-&gt;</span>u<span class="token punctuation">.</span>ip4<span class="token punctuation">;</span>
    rt <span class="token operator">=</span> <span class="token function">skb_rtable</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* Make sure we can route this packet. */</span>
    rt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rtable</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">__sk_dst_check</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        __be32 daddr<span class="token punctuation">;</span>
        <span class="token comment">/* Use correct destination address if we have options. */</span>
        daddr <span class="token operator">=</span> inet<span class="token operator">-&gt;</span>inet_daddr<span class="token punctuation">;</span>
 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        rt <span class="token operator">=</span> <span class="token function">ip_route_output_ports</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> fl4<span class="token punctuation">,</span> sk<span class="token punctuation">,</span>
                       daddr<span class="token punctuation">,</span> inet<span class="token operator">-&gt;</span>inet_saddr<span class="token punctuation">,</span>
                       inet<span class="token operator">-&gt;</span>inet_dport<span class="token punctuation">,</span>
                       inet<span class="token operator">-&gt;</span>inet_sport<span class="token punctuation">,</span>
                       sk<span class="token operator">-&gt;</span>sk_protocol<span class="token punctuation">,</span>
                       <span class="token function">RT_CONN_FLAGS</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span>
                       sk<span class="token operator">-&gt;</span>sk_bound_dev_if<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>rt<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">goto</span> no_route<span class="token punctuation">;</span>
        <span class="token function">sk_setup_caps</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rt<span class="token operator">-&gt;</span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">skb_dst_set_noref</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rt<span class="token operator">-&gt;</span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>

packet_routed<span class="token operator">:</span>
    <span class="token comment">/* OK, we know where to send it, allocate and build IP header. */</span>
    <span class="token function">skb_push</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">iphdr</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>inet_opt <span class="token operator">?</span> inet_opt<span class="token operator">-&gt;</span>opt<span class="token punctuation">.</span>optlen <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">skb_reset_network_header</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    iph <span class="token operator">=</span> <span class="token function">ip_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>__be16 <span class="token operator">*</span><span class="token punctuation">)</span>iph<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">&lt;&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>inet<span class="token operator">-&gt;</span>tos <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ip_dont_fragment</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rt<span class="token operator">-&gt;</span>dst<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>skb<span class="token operator">-&gt;</span>ignore_df<span class="token punctuation">)</span>
        iph<span class="token operator">-&gt;</span>frag_off <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>IP_DF<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        iph<span class="token operator">-&gt;</span>frag_off <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    iph<span class="token operator">-&gt;</span>ttl      <span class="token operator">=</span> <span class="token function">ip_select_ttl</span><span class="token punctuation">(</span>inet<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rt<span class="token operator">-&gt;</span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>
    iph<span class="token operator">-&gt;</span>protocol <span class="token operator">=</span> sk<span class="token operator">-&gt;</span>sk_protocol<span class="token punctuation">;</span>
    <span class="token function">ip_copy_addrs</span><span class="token punctuation">(</span>iph<span class="token punctuation">,</span> fl4<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* Transport layer set skb-&gt;h.foo itself. */</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>inet_opt <span class="token operator">&amp;&amp;</span> inet_opt<span class="token operator">-&gt;</span>opt<span class="token punctuation">.</span>optlen<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        iph<span class="token operator">-&gt;</span>ihl <span class="token operator">+=</span> inet_opt<span class="token operator">-&gt;</span>opt<span class="token punctuation">.</span>optlen <span class="token operator">&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token function">ip_options_build</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>inet_opt<span class="token operator">-&gt;</span>opt<span class="token punctuation">,</span> inet<span class="token operator">-&gt;</span>inet_daddr<span class="token punctuation">,</span> rt<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">ip_select_ident_segs</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> sk<span class="token punctuation">,</span>
                 <span class="token function">skb_shinfo</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>gso_segs <span class="token operator">?</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* TODO : should we use skb-&gt;sk here instead of sk ? */</span>
    skb<span class="token operator">-&gt;</span>priority <span class="token operator">=</span> sk<span class="token operator">-&gt;</span>sk_priority<span class="token punctuation">;</span>
    skb<span class="token operator">-&gt;</span>mark <span class="token operator">=</span> sk<span class="token operator">-&gt;</span>sk_mark<span class="token punctuation">;</span>

    res <span class="token operator">=</span> <span class="token function">ip_local_out</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在ip_queue_xmit中，也即IP层的发送函数里面，有三部分逻辑。</p>
<p>第一部分，选取路由，也即我要发送这个包应该从哪个网卡出去。</p>
<p>这件事情主要由ip_route_output_ports函数完成。接下来的调用链为：ip_route_output_ports-&gt;ip_route_output_flow-&gt;__ip_route_output_key-&gt;ip_route_output_key_hash-&gt;ip_route_output_key_hash_rcu。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">rtable</span> <span class="token operator">*</span><span class="token function">ip_route_output_key_hash_rcu</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">net</span> <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">flowi4</span> <span class="token operator">*</span>fl4<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">fib_result</span> <span class="token operator">*</span>res<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev_out <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> orig_oif <span class="token operator">=</span> fl4<span class="token operator">-&gt;</span>flowi4_oif<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rtable</span> <span class="token operator">*</span>rth<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    err <span class="token operator">=</span> <span class="token function">fib_lookup</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> fl4<span class="token punctuation">,</span> res<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
make_route<span class="token operator">:</span>
    rth <span class="token operator">=</span> <span class="token function">__mkroute_output</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> fl4<span class="token punctuation">,</span> orig_oif<span class="token punctuation">,</span> dev_out<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>ip_route_output_key_hash_rcu先会调用fib_lookup。</p>
<p><strong>FIB</strong>全称是Forwarding Information Base，<strong>转发信息表</strong>。其实就是咱们常说的路由表。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">fib_lookup</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">net</span> <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">flowi4</span> <span class="token operator">*</span>flp<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">fib_result</span> <span class="token operator">*</span>res<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>   <span class="token keyword">struct</span> <span class="token class-name">fib_table</span> <span class="token operator">*</span>tb<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    tb <span class="token operator">=</span> <span class="token function">fib_get_table</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> RT_TABLE_MAIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tb<span class="token punctuation">)</span>
        err <span class="token operator">=</span> <span class="token function">fib_table_lookup</span><span class="token punctuation">(</span>tb<span class="token punctuation">,</span> flp<span class="token punctuation">,</span> res<span class="token punctuation">,</span> flags <span class="token operator">|</span> FIB_LOOKUP_NOREF<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>路由表可以有多个，一般会有一个主表，RT_TABLE_MAIN。然后fib_table_lookup函数在这个表里面进行查找。</p>
<p>路由表是一个什么样的结构呢？</p>
<p>路由就是在Linux服务器上的路由表里面配置的一条一条规则。这些规则大概是这样的：想访问某个网段，从某个网卡出去，下一跳是某个IP。</p>
<p>之前我们讲过一个简单的拓扑图，里面的三台Linux机器的路由表都可以通过ip route命令查看。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/网络场景举例.png" alt="网络场景举例"></p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text"># Linux服务器A
default via 192.168.1.1 dev eth0
192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.100 metric 100

# Linux服务器B
default via 192.168.2.1 dev eth0
192.168.2.0/24 dev eth0 proto kernel scope link src 192.168.2.100 metric 100

# Linux服务器做路由器
192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.1
192.168.2.0/24 dev eth1 proto kernel scope link src 192.168.2.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其实，对于两端的服务器来讲，我们没有太多路由可以选，但是对于中间的Linux服务器做路由器来讲，这里有两条路可以选，一个是往左面转发，一个是往右面转发，就需要路由表的查找。</p>
<p>fib_table_lookup的代码逻辑比较复杂，好在注释比较清楚。因为路由表要按照前缀进行查询，希望找到最长匹配的那一个，例如192.168.2.0/24和192.168.0.0/16都能匹配192.168.2.100/24。但是，我们应该使用192.168.2.0/24的这一条。</p>
<p>为了更方面的做这个事情，我们使用了Trie树这种结构。比如我们有一系列的字符串：<code>{bcs#, badge#, baby#, back#, badger#, badness#}</code>。之所以每个字符串都加上#，是希望不要一个字符串成为另外一个字符串的前缀。然后我们把它们放在Trie树中，如下图所示：</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/路由表使用的Trie树举例.png" alt="路由表使用的Trie树举例"></p>
<p>对于将IP地址转成二进制放入trie树，也是同样的道理，可以很快进行路由的查询。</p>
<p>找到了路由，就知道了应该从哪个网卡发出去。</p>
<p>然后，ip_route_output_key_hash_rcu会调用__mkroute_output，创建一个struct rtable，表示找到的路由表项。这个结构是由rt_dst_alloc函数分配的。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">rtable</span> <span class="token operator">*</span><span class="token function">rt_dst_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span>
                <span class="token keyword">unsigned</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> u16 type<span class="token punctuation">,</span>
                bool nopolicy<span class="token punctuation">,</span> bool noxfrm<span class="token punctuation">,</span> bool will_cache<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">rtable</span> <span class="token operator">*</span>rt<span class="token punctuation">;</span>

    rt <span class="token operator">=</span> <span class="token function">dst_alloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ipv4_dst_ops<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> DST_OBSOLETE_FORCE_CHK<span class="token punctuation">,</span>
               <span class="token punctuation">(</span>will_cache <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> DST_HOST<span class="token punctuation">)</span> <span class="token operator">|</span>
               <span class="token punctuation">(</span>nopolicy <span class="token operator">?</span> DST_NOPOLICY <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">|</span>
               <span class="token punctuation">(</span>noxfrm <span class="token operator">?</span> DST_NOXFRM <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>rt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        rt<span class="token operator">-&gt;</span>rt_genid <span class="token operator">=</span> <span class="token function">rt_genid_ipv4</span><span class="token punctuation">(</span><span class="token function">dev_net</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        rt<span class="token operator">-&gt;</span>rt_flags <span class="token operator">=</span> flags<span class="token punctuation">;</span>
        rt<span class="token operator">-&gt;</span>rt_type <span class="token operator">=</span> type<span class="token punctuation">;</span>
        rt<span class="token operator">-&gt;</span>rt_is_input <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        rt<span class="token operator">-&gt;</span>rt_iif <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        rt<span class="token operator">-&gt;</span>rt_pmtu <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        rt<span class="token operator">-&gt;</span>rt_gateway <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        rt<span class="token operator">-&gt;</span>rt_uses_gateway <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        rt<span class="token operator">-&gt;</span>rt_table_id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rt<span class="token operator">-&gt;</span>rt_uncached<span class="token punctuation">)</span><span class="token punctuation">;</span>

        rt<span class="token operator">-&gt;</span>dst<span class="token punctuation">.</span>output <span class="token operator">=</span> ip_output<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> RTCF_LOCAL<span class="token punctuation">)</span>
            rt<span class="token operator">-&gt;</span>dst<span class="token punctuation">.</span>input <span class="token operator">=</span> ip_local_deliver<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> rt<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最终返回struct rtable实例，第一部分也就完成了。</p>
<p>第二部分，就是准备IP层的头，往里面填充内容。这就要对着IP层的头的格式进行理解。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/IP头格式.png" alt="IP头格式"></p>
<p>在这里面，服务类型设置为tos，标识位里面设置是否允许分片frag_off。如果不允许，而遇到MTU太小过不去的情况，就发送ICMP报错。TTL是这个包的存活时间，为了防止一个IP包迷路以后一直存活下去，每经过一个路由器TTL都减一，减为零则“死去”。设置protocol，指的是更上层的协议，这里是TCP。源地址和目标地址由ip_copy_addrs设置。最后，设置options。</p>
<p>第三部分，就是调用ip_local_out发送IP包。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">ip_local_out</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">net</span> <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> err<span class="token punctuation">;</span>

    err <span class="token operator">=</span> <span class="token function">__ip_local_out</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>err <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        err <span class="token operator">=</span> <span class="token function">dst_output</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> err<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">__ip_local_out</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">net</span> <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">iphdr</span> <span class="token operator">*</span>iph <span class="token operator">=</span> <span class="token function">ip_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    iph<span class="token operator">-&gt;</span>tot_len <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>skb<span class="token operator">-&gt;</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    skb<span class="token operator">-&gt;</span>protocol <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>ETH_P_IP<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token function">nf_hook</span><span class="token punctuation">(</span>NFPROTO_IPV4<span class="token punctuation">,</span> NF_INET_LOCAL_OUT<span class="token punctuation">,</span>
               net<span class="token punctuation">,</span> sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token function">skb_dst</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>dev<span class="token punctuation">,</span>
               dst_output<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>ip_local_out先是调用__ip_local_out，然后里面调用了nf_hook。这是什么呢？nf的意思是Netfilter，这是Linux内核的一个机制，用于在网络发送和转发的关键节点上加上hook函数，这些函数可以截获数据包，对数据包进行干预。</p>
<p>一个著名的实现，就是内核模块ip_tables。在用户态，还有一个客户端程序iptables，用命令行来干预内核的规则。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/ip_table内核模块.png" alt="ip_table内核模块"></p>
<p>iptables有表和链的概念，最终要的是两个表。</p>
<p>filter表处理过滤功能，主要包含以下三个链。</p>
<ul>
<li>INPUT链：过滤所有目标地址是本机的数据包</li>
<li>FORWARD链：过滤所有路过本机的数据包</li>
<li>OUTPUT链：过滤所有由本机产生的数据包</li>
</ul>
<p>nat表主要处理网络地址转换，可以进行SNAT（改变源地址）、DNAT（改变目标地址），包含以下三个链。</p>
<ul>
<li>PREROUTING链：可以在数据包到达时改变目标地址</li>
<li>OUTPUT链：可以改变本地产生的数据包的目标地址</li>
<li>POSTROUTING链：在数据包离开时改变数据包的源地址</li>
</ul>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/iptables的表和链.png" alt="iptables的表和链"></p>
<p>在这里，网络包马上就要发出去了，因而是NF_INET_LOCAL_OUT，也即ouput链，如果用户曾经在iptables里面写过某些规则，就会在nf_hook这个函数里面起作用。</p>
<p>ip_local_out再调用dst_output，就是真正的发送数据。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Output packet to network from transport.  */</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">dst_output</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">net</span> <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">skb_dst</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">output</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里调用的就是struct rtable成员dst的ouput函数。在rt_dst_alloc中，我们可以看到，output函数指向的是ip_output。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">ip_output</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">net</span> <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev <span class="token operator">=</span> <span class="token function">skb_dst</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>dev<span class="token punctuation">;</span>
    skb<span class="token operator">-&gt;</span>dev <span class="token operator">=</span> dev<span class="token punctuation">;</span>
    skb<span class="token operator">-&gt;</span>protocol <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>ETH_P_IP<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token function">NF_HOOK_COND</span><span class="token punctuation">(</span>NFPROTO_IPV4<span class="token punctuation">,</span> NF_INET_POST_ROUTING<span class="token punctuation">,</span>
                net<span class="token punctuation">,</span> sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> dev<span class="token punctuation">,</span>
                ip_finish_output<span class="token punctuation">,</span>
                <span class="token operator">!</span><span class="token punctuation">(</span><span class="token function">IPCB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> IPSKB_REROUTED<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在ip_output里面，我们又看到了熟悉的NF_HOOK。这一次是NF_INET_POST_ROUTING，也即POSTROUTING链，处理完之后，调用ip_finish_output。</p>
<h4 id="42-2-解析ip-finish-output函数"><a href="#42-2-解析ip-finish-output函数" class="headerlink" title="42.2 解析ip_finish_output函数"></a>42.2 解析ip_finish_output函数</h4><p>从ip_finish_output函数开始，发送网络包的逻辑由第三层到达第二层。ip_finish_output最终调用ip_finish_output2。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ip_finish_output2</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">net</span> <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">dst_entry</span> <span class="token operator">*</span>dst <span class="token operator">=</span> <span class="token function">skb_dst</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rtable</span> <span class="token operator">*</span>rt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rtable</span> <span class="token operator">*</span><span class="token punctuation">)</span>dst<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev <span class="token operator">=</span> dst<span class="token operator">-&gt;</span>dev<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> hh_len <span class="token operator">=</span> <span class="token function">LL_RESERVED_SPACE</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">neighbour</span> <span class="token operator">*</span>neigh<span class="token punctuation">;</span>
    u32 nexthop<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    nexthop <span class="token operator">=</span> <span class="token punctuation">(</span>__force u32<span class="token punctuation">)</span> <span class="token function">rt_nexthop</span><span class="token punctuation">(</span>rt<span class="token punctuation">,</span> <span class="token function">ip_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>daddr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    neigh <span class="token operator">=</span> <span class="token function">__ipv4_neigh_lookup_noref</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> nexthop<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>neigh<span class="token punctuation">)</span><span class="token punctuation">)</span>
        neigh <span class="token operator">=</span> <span class="token function">__neigh_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arp_tbl<span class="token punctuation">,</span> <span class="token operator">&amp;</span>nexthop<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>neigh<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> res<span class="token punctuation">;</span>
        <span class="token function">sock_confirm_neigh</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> neigh<span class="token punctuation">)</span><span class="token punctuation">;</span>
        res <span class="token operator">=</span> <span class="token function">neigh_output</span><span class="token punctuation">(</span>neigh<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在ip_finish_output2中，先找到struct rtable路由表里面的下一跳，下一跳一定和本机在同一个局域网中，可以通过二层进行通信，因而通过__ipv4_neigh_lookup_noref，查找如何通过二层访问下一跳。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">neighbour</span> <span class="token operator">*</span><span class="token function">__ipv4_neigh_lookup_noref</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> u32 key<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">___neigh_lookup_noref</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arp_tbl<span class="token punctuation">,</span> neigh_key_eq32<span class="token punctuation">,</span> arp_hashfn<span class="token punctuation">,</span> <span class="token operator">&amp;</span>key<span class="token punctuation">,</span> dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>__ipv4_neigh_lookup_noref是从本地的ARP表中查找下一跳的MAC地址。ARP表的定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">neigh_table</span> arp_tbl <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>family     <span class="token operator">=</span> AF_INET<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>key_len    <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>protocol   <span class="token operator">=</span> <span class="token function">cpu_to_be16</span><span class="token punctuation">(</span>ETH_P_IP<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>hash       <span class="token operator">=</span> arp_hash<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>key_eq     <span class="token operator">=</span> arp_key_eq<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>constructor    <span class="token operator">=</span> arp_constructor<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>proxy_redo <span class="token operator">=</span> parp_redo<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>id     <span class="token operator">=</span> <span class="token string">"arp_cache"</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">.</span>gc_interval    <span class="token operator">=</span> <span class="token number">30</span> <span class="token operator">*</span> HZ<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>gc_thresh1 <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>gc_thresh2 <span class="token operator">=</span> <span class="token number">512</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>gc_thresh3 <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果在ARP表中没有找到相应的项，则调用__neigh_create进行创建。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">neighbour</span> <span class="token operator">*</span><span class="token function">__neigh_create</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">neigh_table</span> <span class="token operator">*</span>tbl<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>pkey<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> bool want_ref<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    u32 hash_val<span class="token punctuation">;</span>
    <span class="token keyword">int</span> key_len <span class="token operator">=</span> tbl<span class="token operator">-&gt;</span>key_len<span class="token punctuation">;</span>
    <span class="token keyword">int</span> error<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">neighbour</span> <span class="token operator">*</span>n1<span class="token punctuation">,</span> <span class="token operator">*</span>rc<span class="token punctuation">,</span> <span class="token operator">*</span>n <span class="token operator">=</span> <span class="token function">neigh_alloc</span><span class="token punctuation">(</span>tbl<span class="token punctuation">,</span> dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">neigh_hash_table</span> <span class="token operator">*</span>nht<span class="token punctuation">;</span>

    <span class="token function">memcpy</span><span class="token punctuation">(</span>n<span class="token operator">-&gt;</span>primary_key<span class="token punctuation">,</span> pkey<span class="token punctuation">,</span> key_len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    n<span class="token operator">-&gt;</span>dev <span class="token operator">=</span> dev<span class="token punctuation">;</span>
    <span class="token function">dev_hold</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* Protocol specific setup. */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tbl<span class="token operator">-&gt;</span>constructor <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>error <span class="token operator">=</span> tbl<span class="token operator">-&gt;</span><span class="token function">constructor</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">atomic_read</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tbl<span class="token operator">-&gt;</span>entries<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> nht<span class="token operator">-&gt;</span>hash_shift<span class="token punctuation">)</span><span class="token punctuation">)</span>
        nht <span class="token operator">=</span> <span class="token function">neigh_hash_grow</span><span class="token punctuation">(</span>tbl<span class="token punctuation">,</span> nht<span class="token operator">-&gt;</span>hash_shift <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    hash_val <span class="token operator">=</span> tbl<span class="token operator">-&gt;</span><span class="token function">hash</span><span class="token punctuation">(</span>pkey<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> nht<span class="token operator">-&gt;</span>hash_rnd<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span><span class="token number">32</span> <span class="token operator">-</span> nht<span class="token operator">-&gt;</span>hash_shift<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>n1 <span class="token operator">=</span> <span class="token function">rcu_dereference_protected</span><span class="token punctuation">(</span>nht<span class="token operator">-&gt;</span>hash_buckets<span class="token punctuation">[</span>hash_val<span class="token punctuation">]</span><span class="token punctuation">,</span>
                        <span class="token function">lockdep_is_held</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tbl<span class="token operator">-&gt;</span>lock<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         n1 <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
         n1 <span class="token operator">=</span> <span class="token function">rcu_dereference_protected</span><span class="token punctuation">(</span>n1<span class="token operator">-&gt;</span>next<span class="token punctuation">,</span>
            <span class="token function">lockdep_is_held</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tbl<span class="token operator">-&gt;</span>lock<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>dev <span class="token operator">==</span> n1<span class="token operator">-&gt;</span>dev <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">memcmp</span><span class="token punctuation">(</span>n1<span class="token operator">-&gt;</span>primary_key<span class="token punctuation">,</span> pkey<span class="token punctuation">,</span> key_len<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>want_ref<span class="token punctuation">)</span>
                <span class="token function">neigh_hold</span><span class="token punctuation">(</span>n1<span class="token punctuation">)</span><span class="token punctuation">;</span>
            rc <span class="token operator">=</span> n1<span class="token punctuation">;</span>
            <span class="token keyword">goto</span> out_tbl_unlock<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">rcu_assign_pointer</span><span class="token punctuation">(</span>n<span class="token operator">-&gt;</span>next<span class="token punctuation">,</span>
               <span class="token function">rcu_dereference_protected</span><span class="token punctuation">(</span>nht<span class="token operator">-&gt;</span>hash_buckets<span class="token punctuation">[</span>hash_val<span class="token punctuation">]</span><span class="token punctuation">,</span>
                             <span class="token function">lockdep_is_held</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tbl<span class="token operator">-&gt;</span>lock<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">rcu_assign_pointer</span><span class="token punctuation">(</span>nht<span class="token operator">-&gt;</span>hash_buckets<span class="token punctuation">[</span>hash_val<span class="token punctuation">]</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>__neigh_create先调用neigh_alloc，创建一个struct neighbour结构，用于维护MAC地址和ARP相关的信息。这个名字也很好理解，大家都是在一个局域网里面，可以通过MAC地址访问到，当然是邻居了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">neighbour</span> <span class="token operator">*</span><span class="token function">neigh_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">neigh_table</span> <span class="token operator">*</span>tbl<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">neighbour</span> <span class="token operator">*</span>n <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> now <span class="token operator">=</span> jiffies<span class="token punctuation">;</span>
    <span class="token keyword">int</span> entries<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    n <span class="token operator">=</span> <span class="token function">kzalloc</span><span class="token punctuation">(</span>tbl<span class="token operator">-&gt;</span>entry_size <span class="token operator">+</span> dev<span class="token operator">-&gt;</span>neigh_priv_len<span class="token punctuation">,</span> GFP_ATOMIC<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>n<span class="token punctuation">)</span>
        <span class="token keyword">goto</span> out_entries<span class="token punctuation">;</span>

    <span class="token function">__skb_queue_head_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token operator">-&gt;</span>arp_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">rwlock_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token operator">-&gt;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">seqlock_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token operator">-&gt;</span>ha_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    n<span class="token operator">-&gt;</span>updated      <span class="token operator">=</span> n<span class="token operator">-&gt;</span>used <span class="token operator">=</span> now<span class="token punctuation">;</span>
    n<span class="token operator">-&gt;</span>nud_state    <span class="token operator">=</span> NUD_NONE<span class="token punctuation">;</span>
    n<span class="token operator">-&gt;</span>output       <span class="token operator">=</span> neigh_blackhole<span class="token punctuation">;</span>
    <span class="token function">seqlock_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token operator">-&gt;</span>hh<span class="token punctuation">.</span>hh_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    n<span class="token operator">-&gt;</span>parms        <span class="token operator">=</span> <span class="token function">neigh_parms_clone</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tbl<span class="token operator">-&gt;</span>parms<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setup_timer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token operator">-&gt;</span>timer<span class="token punctuation">,</span> neigh_timer_handler<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">NEIGH_CACHE_STAT_INC</span><span class="token punctuation">(</span>tbl<span class="token punctuation">,</span> allocs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    n<span class="token operator">-&gt;</span>tbl          <span class="token operator">=</span> tbl<span class="token punctuation">;</span>
    <span class="token function">refcount_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token operator">-&gt;</span>refcnt<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    n<span class="token operator">-&gt;</span>dead         <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在neigh_alloc中，我们先分配一个struct neighbour结构并且初始化。这里面比较重要的有两个成员，一个是arp_queue，所以上层想通过ARP获取MAC地址的任务，都放在这个队列里面。另一个是timer定时器，我们设置成，过一段时间就调用neigh_timer_handler，来处理这些ARP任务。</p>
<p>__neigh_create然后调用了arp_tbl的constructor函数，也即调用了arp_constructor，在这里面定义了ARP的操作arp_hh_ops。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">arp_constructor</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">neighbour</span> <span class="token operator">*</span>neigh<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    __be32 addr <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>__be32 <span class="token operator">*</span><span class="token punctuation">)</span>neigh<span class="token operator">-&gt;</span>primary_key<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev <span class="token operator">=</span> neigh<span class="token operator">-&gt;</span>dev<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">in_device</span> <span class="token operator">*</span>in_dev<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">neigh_parms</span> <span class="token operator">*</span>parms<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    neigh<span class="token operator">-&gt;</span>type <span class="token operator">=</span> <span class="token function">inet_addr_type_dev_table</span><span class="token punctuation">(</span><span class="token function">dev_net</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">,</span> dev<span class="token punctuation">,</span> addr<span class="token punctuation">)</span><span class="token punctuation">;</span>

    parms <span class="token operator">=</span> in_dev<span class="token operator">-&gt;</span>arp_parms<span class="token punctuation">;</span>
    <span class="token function">__neigh_parms_put</span><span class="token punctuation">(</span>neigh<span class="token operator">-&gt;</span>parms<span class="token punctuation">)</span><span class="token punctuation">;</span>
    neigh<span class="token operator">-&gt;</span>parms <span class="token operator">=</span> <span class="token function">neigh_parms_clone</span><span class="token punctuation">(</span>parms<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    neigh<span class="token operator">-&gt;</span>ops <span class="token operator">=</span> <span class="token operator">&amp;</span>arp_hh_ops<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    neigh<span class="token operator">-&gt;</span>output <span class="token operator">=</span> neigh<span class="token operator">-&gt;</span>ops<span class="token operator">-&gt;</span>output<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">neigh_ops</span> arp_hh_ops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>family <span class="token operator">=</span>           AF_INET<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>solicit <span class="token operator">=</span>          arp_solicit<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>error_report <span class="token operator">=</span>     arp_error_report<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>output <span class="token operator">=</span>           neigh_resolve_output<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>connected_output <span class="token operator">=</span> neigh_resolve_output<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>__neigh_create最后是将创建的struct neighbour结构放入一个哈希表，从里面的代码逻辑比较容易看出，这是一个数组加链表的链式哈希表，先计算出哈希值hash_val，得到相应的链表，然后循环这个链表找到对应的项，如果找不到就在最后插入一项。</p>
<p>我们回到ip_finish_output2，在__neigh_create之后，会调用neigh_output发送网络包。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">neigh_output</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">neighbour</span> <span class="token operator">*</span>n<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> n<span class="token operator">-&gt;</span><span class="token function">output</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>按照上面对于struct neighbour的操作函数arp_hh_ops 的定义，output调用的是neigh_resolve_output。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">neigh_resolve_output</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">neighbour</span> <span class="token operator">*</span>neigh<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">neigh_event_send</span><span class="token punctuation">(</span>neigh<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        rc <span class="token operator">=</span> <span class="token function">dev_queue_xmit</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在neigh_resolve_output里面，首先neigh_event_send触发一个事件，看能否激活ARP。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">__neigh_event_send</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">neighbour</span> <span class="token operator">*</span>neigh<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> rc<span class="token punctuation">;</span>
    bool immediate_probe <span class="token operator">=</span> false<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>neigh<span class="token operator">-&gt;</span>nud_state <span class="token operator">&amp;</span> <span class="token punctuation">(</span>NUD_STALE <span class="token operator">|</span> NUD_INCOMPLETE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">NEIGH_VAR</span><span class="token punctuation">(</span>neigh<span class="token operator">-&gt;</span>parms<span class="token punctuation">,</span> MCAST_PROBES<span class="token punctuation">)</span> <span class="token operator">+</span>
            <span class="token function">NEIGH_VAR</span><span class="token punctuation">(</span>neigh<span class="token operator">-&gt;</span>parms<span class="token punctuation">,</span> APP_PROBES<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">unsigned</span> <span class="token keyword">long</span> next<span class="token punctuation">,</span> now <span class="token operator">=</span> jiffies<span class="token punctuation">;</span>

            <span class="token function">atomic_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>neigh<span class="token operator">-&gt;</span>probes<span class="token punctuation">,</span>
                   <span class="token function">NEIGH_VAR</span><span class="token punctuation">(</span>neigh<span class="token operator">-&gt;</span>parms<span class="token punctuation">,</span> UCAST_PROBES<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            neigh<span class="token operator">-&gt;</span>nud_state     <span class="token operator">=</span> NUD_INCOMPLETE<span class="token punctuation">;</span>
            neigh<span class="token operator">-&gt;</span>updated <span class="token operator">=</span> now<span class="token punctuation">;</span>
            next <span class="token operator">=</span> now <span class="token operator">+</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">NEIGH_VAR</span><span class="token punctuation">(</span>neigh<span class="token operator">-&gt;</span>parms<span class="token punctuation">,</span> RETRANS_TIME<span class="token punctuation">)</span><span class="token punctuation">,</span>
                     HZ<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">neigh_add_timer</span><span class="token punctuation">(</span>neigh<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>
            immediate_probe <span class="token operator">=</span> true<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>neigh<span class="token operator">-&gt;</span>nud_state <span class="token operator">&amp;</span> NUD_STALE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">neigh_dbg</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"neigh %p is delayed\n"</span><span class="token punctuation">,</span> neigh<span class="token punctuation">)</span><span class="token punctuation">;</span>
        neigh<span class="token operator">-&gt;</span>nud_state <span class="token operator">=</span> NUD_DELAY<span class="token punctuation">;</span>
        neigh<span class="token operator">-&gt;</span>updated <span class="token operator">=</span> jiffies<span class="token punctuation">;</span>
        <span class="token function">neigh_add_timer</span><span class="token punctuation">(</span>neigh<span class="token punctuation">,</span> jiffies <span class="token operator">+</span>
                <span class="token function">NEIGH_VAR</span><span class="token punctuation">(</span>neigh<span class="token operator">-&gt;</span>parms<span class="token punctuation">,</span> DELAY_PROBE_TIME<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>neigh<span class="token operator">-&gt;</span>nud_state <span class="token operator">==</span> NUD_INCOMPLETE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>skb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token function">__skb_queue_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>neigh<span class="token operator">-&gt;</span>arp_queue<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
            neigh<span class="token operator">-&gt;</span>arp_queue_len_Bytes <span class="token operator">+=</span> skb<span class="token operator">-&gt;</span>truesize<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        rc <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
out_unlock_bh<span class="token operator">:</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>immediate_probe<span class="token punctuation">)</span>
        <span class="token function">neigh_probe</span><span class="token punctuation">(</span>neigh<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在__neigh_event_send中，激活ARP分两种情况，第一种情况是马上激活，也即immediate_probe。另一种情况是延迟激活则仅仅设置一个timer。然后将ARP包放在arp_queue上。如果马上激活，就直接调用neigh_probe；如果延迟激活，则定时器到了就会触发neigh_timer_handler，在这里面还是会调用neigh_probe。</p>
<p>我们就来看neigh_probe的实现，在这里面会从arp_queue中拿出ARP包来，然后调用struct neighbour的solicit操作。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">neigh_probe</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">neighbour</span> <span class="token operator">*</span>neigh<span class="token punctuation">)</span>
        <span class="token function">__releases</span><span class="token punctuation">(</span>neigh<span class="token operator">-&gt;</span>lock<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb <span class="token operator">=</span> <span class="token function">skb_peek_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>neigh<span class="token operator">-&gt;</span>arp_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>neigh<span class="token operator">-&gt;</span>ops<span class="token operator">-&gt;</span>solicit<span class="token punctuation">)</span>
                neigh<span class="token operator">-&gt;</span>ops<span class="token operator">-&gt;</span><span class="token function">solicit</span><span class="token punctuation">(</span>neigh<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>按照上面对于struct neighbour的操作函数arp_hh_ops 的定义，solicit调用的是arp_solicit，在这里我们可以找到对于arp_send_dst的调用，创建并发送一个arp包，得到结果放在struct dst_entry里面。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">arp_send_dst</span><span class="token punctuation">(</span><span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span> ptype<span class="token punctuation">,</span> __be32 dest_ip<span class="token punctuation">,</span>
                         <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> __be32 src_ip<span class="token punctuation">,</span>
                         <span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>dest_hw<span class="token punctuation">,</span>
                         <span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>src_hw<span class="token punctuation">,</span>
                         <span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>target_hw<span class="token punctuation">,</span>
                         <span class="token keyword">struct</span> <span class="token class-name">dst_entry</span> <span class="token operator">*</span>dst<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        skb <span class="token operator">=</span> <span class="token function">arp_create</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> ptype<span class="token punctuation">,</span> dest_ip<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> src_ip<span class="token punctuation">,</span>
                         dest_hw<span class="token punctuation">,</span> src_hw<span class="token punctuation">,</span> target_hw<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token function">skb_dst_set</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> <span class="token function">dst_clone</span><span class="token punctuation">(</span>dst<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">arp_xmit</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们回到neigh_resolve_output中，当ARP发送完毕，就可以调用dev_queue_xmit发送二层网络包了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/**
 *  __dev_queue_xmit - transmit a buffer
 *  @skb: buffer to transmit
 *  @accel_priv: private data used for L2 forwarding offload
 *
 *  Queue a buffer for transmission to a network device.
 */</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">__dev_queue_xmit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>accel_priv<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev <span class="token operator">=</span> skb<span class="token operator">-&gt;</span>dev<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">netdev_queue</span> <span class="token operator">*</span>txq<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">Qdisc</span> <span class="token operator">*</span>q<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    txq <span class="token operator">=</span> <span class="token function">netdev_pick_tx</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> accel_priv<span class="token punctuation">)</span><span class="token punctuation">;</span>
    q <span class="token operator">=</span> <span class="token function">rcu_dereference_bh</span><span class="token punctuation">(</span>txq<span class="token operator">-&gt;</span>qdisc<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token operator">-&gt;</span>enqueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        rc <span class="token operator">=</span> <span class="token function">__dev_xmit_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> q<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> txq<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> out<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>就像咱们在讲述硬盘块设备的时候讲过，每个块设备都有队列，用于将内核的数据放到队列里面，然后设备驱动从队列里面取出后，将数据根据具体设备的特性发送给设备。</p>
<p>网络设备也是类似的，对于发送来说，有一个发送队列struct netdev_queue *txq。</p>
<p>这里还有另一个变量叫做struct Qdisc，这个是什么呢？如果我们在一台Linux机器上运行ip addr，我们能看到对于一个网卡，都有下面的输出。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ip</span> addr
<span class="token number">1</span>: lo: <span class="token operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class="token number">1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet <span class="token number">127.0</span>.0.1/8 scope <span class="token function">host</span> lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope <span class="token function">host</span>
       valid_lft forever preferred_lft forever
<span class="token number">2</span>: eth0: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">1400</span> qdisc pfifo_fast state UP group default qlen <span class="token number">1000</span>
    link/ether fa:16:3e:75:99:08 brd ff:ff:ff:ff:ff:ff
    inet <span class="token number">10.173</span>.32.47/21 brd <span class="token number">10.173</span>.39.255 scope global noprefixroute dynamic eth0
       valid_lft 67104sec preferred_lft 67104sec
    inet6 fe80::f816:3eff:fe75:9908/64 scope <span class="token function">link</span>
       valid_lft forever preferred_lft forever<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面有个关键字qdisc pfifo_fast是什么意思呢？qdisc全称是queueing discipline，中文叫排队规则。内核如果需要通过某个网络接口发送数据包，都需要按照为这个接口配置的qdisc（排队规则）把数据包加入队列。</p>
<p>最简单的qdisc是pfifo，它不对进入的数据包做任何的处理，数据包采用先入先出的方式通过队列。pfifo_fast稍微复杂一些，它的队列包括三个波段（band）。在每个波段里面，使用先进先出规则。</p>
<p>三个波段的优先级也不相同。band 0的优先级最高，band 2的最低。如果band 0里面有数据包，系统就不会处理band 1里面的数据包，band 1和band 2之间也是一样。</p>
<p>数据包是按照服务类型（Type of Service，TOS）被分配到三个波段里面的。TOS是IP头里面的一个字段，代表了当前的包是高优先级的，还是低优先级的。</p>
<p>pfifo_fast分为三个先入先出的队列，我们能称为三个Band。根据网络包里面的TOS，看这个包到底应该进入哪个队列。TOS总共四位，每一位表示的意思不同，总共十六种类型。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/pfifo_fast和TOS.png" alt="pfifo_fast和TOS"></p>
<p>通过命令行tc qdisc show dev eth0，我们可以输出结果priomap，也是十六个数字。在0到2之间，和TOS的十六种类型对应起来。不同的TOS对应不同的队列。其中Band 0优先级最高，发送完毕后才轮到Band 1发送，最后才是Band 2。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ tc qdisc show dev eth0
qdisc pfifo_fast <span class="token number">0</span>: root refcnt <span class="token number">2</span> bands <span class="token number">3</span> priomap  <span class="token number">1</span> <span class="token number">2</span> <span class="token number">2</span> <span class="token number">2</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>接下来，__dev_xmit_skb开始进行网络包发送。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">__dev_xmit_skb</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">Qdisc</span> <span class="token operator">*</span>q<span class="token punctuation">,</span>
                 <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span>
                 <span class="token keyword">struct</span> <span class="token class-name">netdev_queue</span> <span class="token operator">*</span>txq<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    rc <span class="token operator">=</span> q<span class="token operator">-&gt;</span><span class="token function">enqueue</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> q<span class="token punctuation">,</span> <span class="token operator">&amp;</span>to_free<span class="token punctuation">)</span> <span class="token operator">&amp;</span> NET_XMIT_MASK<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">qdisc_run_begin</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token function">__qdisc_run</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">__qdisc_run</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Qdisc</span> <span class="token operator">*</span>q<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> quota <span class="token operator">=</span> dev_tx_weight<span class="token punctuation">;</span>
    <span class="token keyword">int</span> packets<span class="token punctuation">;</span>
     <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">qdisc_restart</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> <span class="token operator">&amp;</span>packets<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/*
         * Ordered by possible occurrence: Postpone processing if
         * 1. we've exceeded packet quota
         * 2. another process needs the CPU;
         */</span>
        quota <span class="token operator">-=</span> packets<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>quota <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">need_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">__netif_schedule</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
     <span class="token function">qdisc_run_end</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>dev_xmit_skb会将请求放入队列，然后调用</strong>qdisc_run处理队列中的数据。qdisc_restart用于数据的发送。根据注释中的说法，qdisc的另一个功能是用于控制网络包的发送速度，因而如果超过速度，就需要重新调度，则会调用__netif_schedule。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">__netif_reschedule</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Qdisc</span> <span class="token operator">*</span>q<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">softnet_data</span> <span class="token operator">*</span>sd<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>
    <span class="token function">local_irq_save</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    sd <span class="token operator">=</span> <span class="token function">this_cpu_ptr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>softnet_data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    q<span class="token operator">-&gt;</span>next_sched <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>sd<span class="token operator">-&gt;</span>output_queue_tailp <span class="token operator">=</span> q<span class="token punctuation">;</span>
    sd<span class="token operator">-&gt;</span>output_queue_tailp <span class="token operator">=</span> <span class="token operator">&amp;</span>q<span class="token operator">-&gt;</span>next_sched<span class="token punctuation">;</span>
    <span class="token function">raise_softirq_irqoff</span><span class="token punctuation">(</span>NET_TX_SOFTIRQ<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">local_irq_restore</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>netif_schedule会调用</strong>netif_reschedule，发起一个软中断NET_TX_SOFTIRQ。咱们讲设备驱动程序的时候讲过，设备驱动程序处理中断，分两个过程，一个是屏蔽中断的关键处理逻辑，一个是延迟处理逻辑。当时说工作队列是延迟处理逻辑的处理方案，软中断也是一种方案。</p>
<p>在系统初始化的时候，我们会定义软中断的处理函数。例如，NET_TX_SOFTIRQ的处理函数是net_tx_action，用于发送网络包。还有一个NET_RX_SOFTIRQ的处理函数是net_rx_action，用于接收网络包。接收网络包的过程咱们下一节解析。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">open_softirq</span><span class="token punctuation">(</span>NET_TX_SOFTIRQ<span class="token punctuation">,</span> net_tx_action<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">open_softirq</span><span class="token punctuation">(</span>NET_RX_SOFTIRQ<span class="token punctuation">,</span> net_rx_action<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这里我们来解析一下net_tx_action。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> __latent_entropy <span class="token keyword">void</span> <span class="token function">net_tx_action</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">softirq_action</span> <span class="token operator">*</span>h<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">softnet_data</span> <span class="token operator">*</span>sd <span class="token operator">=</span> <span class="token function">this_cpu_ptr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>softnet_data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>sd<span class="token operator">-&gt;</span>output_queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">Qdisc</span> <span class="token operator">*</span>head<span class="token punctuation">;</span>

        <span class="token function">local_irq_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        head <span class="token operator">=</span> sd<span class="token operator">-&gt;</span>output_queue<span class="token punctuation">;</span>
        sd<span class="token operator">-&gt;</span>output_queue <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        sd<span class="token operator">-&gt;</span>output_queue_tailp <span class="token operator">=</span> <span class="token operator">&amp;</span>sd<span class="token operator">-&gt;</span>output_queue<span class="token punctuation">;</span>
        <span class="token function">local_irq_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">while</span> <span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">struct</span> <span class="token class-name">Qdisc</span> <span class="token operator">*</span>q <span class="token operator">=</span> head<span class="token punctuation">;</span>
            spinlock_t <span class="token operator">*</span>root_lock<span class="token punctuation">;</span>

            head <span class="token operator">=</span> head<span class="token operator">-&gt;</span>next_sched<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token function">qdisc_run</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们会发现，net_tx_action还是调用了qdisc_run，还是会调用__qdisc_run，然后调用qdisc_restart发送网络包。</p>
<p>我们来看一下qdisc_restart的实现。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">qdisc_restart</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Qdisc</span> <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>packets<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">netdev_queue</span> <span class="token operator">*</span>txq<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev<span class="token punctuation">;</span>
    spinlock_t <span class="token operator">*</span>root_lock<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">;</span>
    bool validate<span class="token punctuation">;</span>

    <span class="token comment">/* Dequeue packet */</span>
    skb <span class="token operator">=</span> <span class="token function">dequeue_skb</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> <span class="token operator">&amp;</span>validate<span class="token punctuation">,</span> packets<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>skb<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

    root_lock <span class="token operator">=</span> <span class="token function">qdisc_lock</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
    dev <span class="token operator">=</span> <span class="token function">qdisc_dev</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
    txq <span class="token operator">=</span> <span class="token function">skb_get_tx_queue</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token function">sch_direct_xmit</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> q<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> txq<span class="token punctuation">,</span> root_lock<span class="token punctuation">,</span> validate<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>qdisc_restart将网络包从Qdisc的队列中拿下来，然后调用sch_direct_xmit进行发送。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sch_direct_xmit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">Qdisc</span> <span class="token operator">*</span>q<span class="token punctuation">,</span>
            <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">netdev_queue</span> <span class="token operator">*</span>txq<span class="token punctuation">,</span>
            spinlock_t <span class="token operator">*</span>root_lock<span class="token punctuation">,</span> bool validate<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> ret <span class="token operator">=</span> NETDEV_TX_BUSY<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">netif_xmit_frozen_or_stopped</span><span class="token punctuation">(</span>txq<span class="token punctuation">)</span><span class="token punctuation">)</span>
            skb <span class="token operator">=</span> <span class="token function">dev_hard_start_xmit</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> txq<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dev_xmit_complete</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* Driver sent out skb successfully or skb was consumed */</span>
        ret <span class="token operator">=</span> <span class="token function">qdisc_qlen</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">/* Driver returned NETDEV_TX_BUSY - requeue skb */</span>
        ret <span class="token operator">=</span> <span class="token function">dev_requeue_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在sch_direct_xmit中，调用dev_hard_start_xmit进行发送，如果发送不成功，会返回NETDEV_TX_BUSY。这说明网络卡很忙，于是就调用dev_requeue_skb，重新放入队列。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span><span class="token function">dev_hard_start_xmit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>first<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">netdev_queue</span> <span class="token operator">*</span>txq<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>ret<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb <span class="token operator">=</span> first<span class="token punctuation">;</span>
    <span class="token keyword">int</span> rc <span class="token operator">=</span> NETDEV_TX_OK<span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>skb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>next <span class="token operator">=</span> skb<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        rc <span class="token operator">=</span> <span class="token function">xmit_one</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> txq<span class="token punctuation">,</span> next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        skb <span class="token operator">=</span> next<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">netif_xmit_stopped</span><span class="token punctuation">(</span>txq<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> skb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            rc <span class="token operator">=</span> NETDEV_TX_BUSY<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在dev_hard_start_xmit中，是一个while循环。每次在队列中取出一个sk_buff，调用xmit_one发送。</p>
<p>接下来的调用链为：xmit_one-&gt;netdev_start_xmit-&gt;__netdev_start_xmit。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> netdev_tx_t <span class="token function">__netdev_start_xmit</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">net_device_ops</span> <span class="token operator">*</span>ops<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> bool more<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    skb<span class="token operator">-&gt;</span>xmit_more <span class="token operator">=</span> more <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> ops<span class="token operator">-&gt;</span><span class="token function">ndo_start_xmit</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个时候，已经到了设备驱动层了。我们能看到，drivers/net/ethernet/intel/ixgb/ixgb_main.c里面有对于这个网卡的操作的定义。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">net_device_ops</span> ixgb_netdev_ops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>ndo_open               <span class="token operator">=</span> ixgb_open<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>ndo_stop               <span class="token operator">=</span> ixgb_close<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>ndo_start_xmit         <span class="token operator">=</span> ixgb_xmit_frame<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>ndo_set_rx_mode        <span class="token operator">=</span> ixgb_set_multi<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>ndo_validate_addr      <span class="token operator">=</span> eth_validate_addr<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>ndo_set_mac_address    <span class="token operator">=</span> ixgb_set_mac<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>ndo_change_mtu         <span class="token operator">=</span> ixgb_change_mtu<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>ndo_tx_timeout         <span class="token operator">=</span> ixgb_tx_timeout<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>ndo_vlan_rx_add_vid    <span class="token operator">=</span> ixgb_vlan_rx_add_vid<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>ndo_vlan_rx_kill_vid   <span class="token operator">=</span> ixgb_vlan_rx_kill_vid<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>ndo_fix_features       <span class="token operator">=</span> ixgb_fix_features<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>ndo_set_features       <span class="token operator">=</span> ixgb_set_features<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里面，我们可以找到对于ndo_start_xmit的定义，调用ixgb_xmit_frame。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> netdev_tx_t
<span class="token function">ixgb_xmit_frame</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>netdev<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">ixgb_adapter</span> <span class="token operator">*</span>adapter <span class="token operator">=</span> <span class="token function">netdev_priv</span><span class="token punctuation">(</span>netdev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">ixgb_tx_queue</span><span class="token punctuation">(</span>adapter<span class="token punctuation">,</span> count<span class="token punctuation">,</span> vlan_id<span class="token punctuation">,</span> tx_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">/* Make sure there is space in the ring for the next send. */</span>
        <span class="token function">ixgb_maybe_stop_tx</span><span class="token punctuation">(</span>netdev<span class="token punctuation">,</span> <span class="token operator">&amp;</span>adapter<span class="token operator">-&gt;</span>tx_ring<span class="token punctuation">,</span> DESC_NEEDED<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> NETDEV_TX_OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在ixgb_xmit_frame中，我们会得到这个网卡对应的适配器，然后将其放入硬件网卡的队列中。</p>
<p>至此，整个发送才算结束。</p>
<h4 id="42-3-总结"><a href="#42-3-总结" class="headerlink" title="42.3 总结"></a>42.3 总结</h4><p>这一节，我们继续解析了发送一个网络包的过程，我们整个过程的图画在了下面。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/发送一个网络包的完整过程.png" alt="发送一个网络包的完整过程"></p>
<p>这个过程分成几个层次。</p>
<ul>
<li>VFS层：write系统调用找到struct file，根据里面的file_operations的定义，调用sock_write_iter函数。sock_write_iter函数调用sock_sendmsg函数。</li>
<li>Socket层：从struct file里面的private_data得到struct socket，根据里面ops的定义，调用inet_sendmsg函数。</li>
<li>Sock层：从struct socket里面的sk得到struct sock，根据里面sk_prot的定义，调用tcp_sendmsg函数。</li>
<li>TCP层：tcp_sendmsg函数会调用tcp_write_xmit函数，tcp_write_xmit函数会调用tcp_transmit_skb，在这里实现了TCP层面向连接的逻辑。</li>
<li>IP层：扩展struct sock，得到struct inet_connection_sock，根据里面icsk_af_ops的定义，调用ip_queue_xmit函数。</li>
<li>IP层：ip_route_output_ports函数里面会调用fib_lookup查找路由表。FIB全称是Forwarding Information Base，转发信息表，也就是路由表。</li>
<li>在IP层里面要做的另一个事情是填写IP层的头。</li>
<li>在IP层还要做的一件事情就是通过iptables规则。</li>
<li>MAC层：IP层调用ip_finish_output进行MAC层。</li>
<li>MAC层需要ARP获得MAC地址，因而要调用___neigh_lookup_noref查找属于同一个网段的邻居，他会调用neigh_probe发送ARP。</li>
<li>有了MAC地址，就可以调用dev_queue_xmit发送二层网络包了，它会调用__dev_xmit_skb会将请求放入队列。</li>
<li>设备层：网络包的发送回触发一个软中断NET_TX_SOFTIRQ来处理队列中的数据。这个软中断的处理函数是net_tx_action。</li>
<li>在软中断处理函数中，会将网络包从队列上拿下来，调用网络设备的传输函数ixgb_xmit_frame，将网络包发的设备的队列上去。</li>
</ul>
<h3 id="43-接收网络包（上）"><a href="#43-接收网络包（上）" class="headerlink" title="43. 接收网络包（上）"></a>43. 接收网络包（上）</h3><p>如果说网络包的发送是从应用层开始，层层调用，一直到网卡驱动程序的话，网络包的结束过程，就是一个反过来的过程，我们不能从应用层的读取开始，而应该从网卡接收到一个网络包开始。我们用两节来解析这个过程，这一节我们从硬件网卡解析到IP层，下一节，我们从IP层解析到Socket层。</p>
<h4 id="43-1-设备驱动层"><a href="#43-1-设备驱动层" class="headerlink" title="43.1 设备驱动层"></a>43.1 设备驱动层</h4><p>网卡作为一个硬件，接收到网络包，应该怎么通知操作系统，这个网络包到达了呢？咱们学习过输入输出设备和中断。没错，我们可以触发一个中断。但是这里有个问题，就是网络包的到来，往往是很难预期的。网络吞吐量比较大的时候，网络包的到达会十分频繁。这个时候，如果非常频繁地去触发中断，想想就觉得是个灾难。</p>
<p>比如说，CPU正在做某个事情，一些网络包来了，触发了中断，CPU停下手里的事情，去处理这些网络包，处理完毕按照中断处理的逻辑，应该回去继续处理其他事情。这个时候，另一些网络包又来了，又触发了中断，CPU手里的事情还没捂热，又要停下来去处理网络包。能不能大家要来的一起来，把网络包好好处理一把，然后再回去集中处理其他事情呢？</p>
<p>网络包能不能一起来，这个我们没法儿控制，但是我们可以有一种机制，就是当一些网络包到来触发了中断，内核处理完这些网络包之后，我们可以先进入主动轮询poll网卡的方式，主动去接收到来的网络包。如果一直有，就一直处理，等处理告一段落，就返回干其他的事情。当再有下一批网络包到来的时候，再中断，再轮询poll。这样就会大大减少中断的数量，提升网络处理的效率，这种处理方式我们称为<strong>NAPI</strong>。</p>
<p>为了帮你了解设备驱动层的工作机制，我们还是以上一节发送网络包时的网卡drivers/net/ethernet/intel/ixgb/ixgb_main.c为例子，来进行解析。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">pci_driver</span> ixgb_driver <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>name     <span class="token operator">=</span> ixgb_driver_name<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>id_table <span class="token operator">=</span> ixgb_pci_tbl<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>probe    <span class="token operator">=</span> ixgb_probe<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>remove   <span class="token operator">=</span> ixgb_remove<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>err_handler <span class="token operator">=</span> <span class="token operator">&amp;</span>ixgb_err_handler
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"Intel Corporation, &lt;linux.nics@intel.com&gt;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_DESCRIPTION</span><span class="token punctuation">(</span><span class="token string">"Intel(R) PRO/10GbE Network Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_VERSION</span><span class="token punctuation">(</span>DRV_VERSION<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * ixgb_init_module - Driver Registration Routine
 *
 * ixgb_init_module is the first routine called when the driver is
 * loaded. All it does is register with the PCI subsystem.
 **/</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> __init
<span class="token function">ixgb_init_module</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">pr_info</span><span class="token punctuation">(</span><span class="token string">"%s - version %s\n"</span><span class="token punctuation">,</span> ixgb_driver_string<span class="token punctuation">,</span> ixgb_driver_version<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pr_info</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> ixgb_copyright<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token function">pci_register_driver</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ixgb_driver<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">module_init</span><span class="token punctuation">(</span>ixgb_init_module<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在网卡驱动程序初始化的时候，我们会调用ixgb_init_module，注册一个驱动ixgb_driver，并且调用它的probe函数ixgb_probe。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span>
<span class="token function">ixgb_probe</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pci_dev</span> <span class="token operator">*</span>pdev<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">pci_device_id</span> <span class="token operator">*</span>ent<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>netdev <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">ixgb_adapter</span> <span class="token operator">*</span>adapter<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    netdev <span class="token operator">=</span> <span class="token function">alloc_etherdev</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ixgb_adapter</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">SET_NETDEV_DEV</span><span class="token punctuation">(</span>netdev<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pdev<span class="token operator">-&gt;</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">pci_set_drvdata</span><span class="token punctuation">(</span>pdev<span class="token punctuation">,</span> netdev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    adapter <span class="token operator">=</span> <span class="token function">netdev_priv</span><span class="token punctuation">(</span>netdev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    adapter<span class="token operator">-&gt;</span>netdev <span class="token operator">=</span> netdev<span class="token punctuation">;</span>
    adapter<span class="token operator">-&gt;</span>pdev <span class="token operator">=</span> pdev<span class="token punctuation">;</span>
    adapter<span class="token operator">-&gt;</span>hw<span class="token punctuation">.</span>back <span class="token operator">=</span> adapter<span class="token punctuation">;</span>
    adapter<span class="token operator">-&gt;</span>msg_enable <span class="token operator">=</span> <span class="token function">netif_msg_init</span><span class="token punctuation">(</span>debug<span class="token punctuation">,</span> DEFAULT_MSG_ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>

    adapter<span class="token operator">-&gt;</span>hw<span class="token punctuation">.</span>hw_addr <span class="token operator">=</span> <span class="token function">pci_ioremap_bar</span><span class="token punctuation">(</span>pdev<span class="token punctuation">,</span> BAR_0<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    netdev<span class="token operator">-&gt;</span>netdev_ops <span class="token operator">=</span> <span class="token operator">&amp;</span>ixgb_netdev_ops<span class="token punctuation">;</span>
    <span class="token function">ixgb_set_ethtool_ops</span><span class="token punctuation">(</span>netdev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    netdev<span class="token operator">-&gt;</span>watchdog_timeo <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">*</span> HZ<span class="token punctuation">;</span>
    <span class="token function">netif_napi_add</span><span class="token punctuation">(</span>netdev<span class="token punctuation">,</span> <span class="token operator">&amp;</span>adapter<span class="token operator">-&gt;</span>napi<span class="token punctuation">,</span> ixgb_clean<span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">strncpy</span><span class="token punctuation">(</span>netdev<span class="token operator">-&gt;</span>name<span class="token punctuation">,</span> <span class="token function">pci_name</span><span class="token punctuation">(</span>pdev<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>netdev<span class="token operator">-&gt;</span>name<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    adapter<span class="token operator">-&gt;</span>bd_number <span class="token operator">=</span> cards_found<span class="token punctuation">;</span>
    adapter<span class="token operator">-&gt;</span>link_speed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    adapter<span class="token operator">-&gt;</span>link_duplex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在ixgb_probe中，我们会创建一个struct net_device表示这个网络设备，并且netif_napi_add函数为这个网络设备注册一个轮询poll函数ixgb_clean，将来一旦出现网络包的时候，就是要通过他来轮询了。</p>
<p>当一个网卡被激活的时候，我们会调用函数ixgb_open-&gt;ixgb_up，在这里面注册一个硬件的中断处理函数。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span>
<span class="token function">ixgb_up</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ixgb_adapter</span> <span class="token operator">*</span>adapter<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>netdev <span class="token operator">=</span> adapter<span class="token operator">-&gt;</span>netdev<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    err <span class="token operator">=</span> <span class="token function">request_irq</span><span class="token punctuation">(</span>adapter<span class="token operator">-&gt;</span>pdev<span class="token operator">-&gt;</span>irq<span class="token punctuation">,</span> ixgb_intr<span class="token punctuation">,</span> irq_flags<span class="token punctuation">,</span>
                      netdev<span class="token operator">-&gt;</span>name<span class="token punctuation">,</span> netdev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * ixgb_intr - Interrupt Handler
 * @irq: interrupt number
 * @data: pointer to a network interface device structure
 **/</span>

<span class="token keyword">static</span> irqreturn_t
<span class="token function">ixgb_intr</span><span class="token punctuation">(</span><span class="token keyword">int</span> irq<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>netdev <span class="token operator">=</span> data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">ixgb_adapter</span> <span class="token operator">*</span>adapter <span class="token operator">=</span> <span class="token function">netdev_priv</span><span class="token punctuation">(</span>netdev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">ixgb_hw</span> <span class="token operator">*</span>hw <span class="token operator">=</span> <span class="token operator">&amp;</span>adapter<span class="token operator">-&gt;</span>hw<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">napi_schedule_prep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>adapter<span class="token operator">-&gt;</span>napi<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">IXGB_WRITE_REG</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>adapter<span class="token operator">-&gt;</span>hw<span class="token punctuation">,</span> IMC<span class="token punctuation">,</span> <span class="token operator">~</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">__napi_schedule</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>adapter<span class="token operator">-&gt;</span>napi<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> IRQ_HANDLED<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果一个网络包到来，触发了硬件中断，就会调用ixgb_intr，这里面会调用__napi_schedule。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/**
 * __napi_schedule - schedule for receive
 * @n: entry to schedule
 *
 * The entry's receive function will be scheduled to run.
 * Consider using __napi_schedule_irqoff() if hard irqs are masked.
 */</span>
<span class="token keyword">void</span> <span class="token function">__napi_schedule</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">napi_struct</span> <span class="token operator">*</span>n<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>

    <span class="token function">local_irq_save</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">____napi_schedule</span><span class="token punctuation">(</span><span class="token function">this_cpu_ptr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>softnet_data<span class="token punctuation">)</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">local_irq_restore</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">____napi_schedule</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">softnet_data</span> <span class="token operator">*</span>sd<span class="token punctuation">,</span>
                     <span class="token keyword">struct</span> <span class="token class-name">napi_struct</span> <span class="token operator">*</span>napi<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">list_add_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>napi<span class="token operator">-&gt;</span>poll_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sd<span class="token operator">-&gt;</span>poll_list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">__raise_softirq_irqoff</span><span class="token punctuation">(</span>NET_RX_SOFTIRQ<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>napi_schedule是处于中断处理的关键部分，在他被调用的时候，中断是暂时关闭的，但是处理网络包是个复杂的过程，需要到延迟处理部分，所以__</strong>napi_schedule将当前设备放到struct softnet_data结构的poll_list里面，说明在延迟处理部分可以接着处理这个poll_list里面的网络设备。</p>
<p>然后____napi_schedule触发一个软中断NET_RX_SOFTIRQ，通过软中断触发中断处理的延迟处理部分，也是常用的手段。</p>
<p>上一节，我们知道，软中断NET_RX_SOFTIRQ对应的中断处理函数是net_rx_action。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> __latent_entropy <span class="token keyword">void</span> <span class="token function">net_rx_action</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">softirq_action</span> <span class="token operator">*</span>h<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">softnet_data</span> <span class="token operator">*</span>sd <span class="token operator">=</span> <span class="token function">this_cpu_ptr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>softnet_data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">LIST_HEAD</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">list_splice_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sd<span class="token operator">-&gt;</span>poll_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">napi_struct</span> <span class="token operator">*</span>n<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        n <span class="token operator">=</span> <span class="token function">list_first_entry</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>list<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">napi_struct</span><span class="token punctuation">,</span> poll_list<span class="token punctuation">)</span><span class="token punctuation">;</span>
        budget <span class="token operator">-=</span> <span class="token function">napi_poll</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>repoll<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在net_rx_action中，会得到struct softnet_data结构，这个结构在发送的时候我们也遇到过。当时它的output_queue用于网络包的发送，这里的poll_list用于网络包的接收。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">softnet_data</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    poll_list<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">struct</span> <span class="token class-name">Qdisc</span>        <span class="token operator">*</span>output_queue<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">Qdisc</span>        <span class="token operator">*</span><span class="token operator">*</span>output_queue_tailp<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在net_rx_action中，接下来是一个循环，在poll_list里面取出网络包到达的设备，然后调用napi_poll来轮询这些设备，napi_poll会调用最初设备初始化的时候，注册的poll函数，对于ixgb_driver，对应的函数是ixgb_clean。</p>
<p>ixgb_clean会调用ixgb_clean_rx_irq。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> bool
<span class="token function">ixgb_clean_rx_irq</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ixgb_adapter</span> <span class="token operator">*</span>adapter<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>work_done<span class="token punctuation">,</span> <span class="token keyword">int</span> work_to_do<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">ixgb_desc_ring</span> <span class="token operator">*</span>rx_ring <span class="token operator">=</span> <span class="token operator">&amp;</span>adapter<span class="token operator">-&gt;</span>rx_ring<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>netdev <span class="token operator">=</span> adapter<span class="token operator">-&gt;</span>netdev<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">pci_dev</span> <span class="token operator">*</span>pdev <span class="token operator">=</span> adapter<span class="token operator">-&gt;</span>pdev<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">ixgb_rx_desc</span> <span class="token operator">*</span>rx_desc<span class="token punctuation">,</span> <span class="token operator">*</span>next_rxd<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">ixgb_buffer</span> <span class="token operator">*</span>buffer_info<span class="token punctuation">,</span> <span class="token operator">*</span>next_buffer<span class="token punctuation">,</span> <span class="token operator">*</span>next2_buffer<span class="token punctuation">;</span>
    u32 length<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>
    <span class="token keyword">int</span> cleaned_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    bool cleaned <span class="token operator">=</span> false<span class="token punctuation">;</span>

    i <span class="token operator">=</span> rx_ring<span class="token operator">-&gt;</span>next_to_clean<span class="token punctuation">;</span>
    rx_desc <span class="token operator">=</span> <span class="token function">IXGB_RX_DESC</span><span class="token punctuation">(</span><span class="token operator">*</span>rx_ring<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    buffer_info <span class="token operator">=</span> <span class="token operator">&amp;</span>rx_ring<span class="token operator">-&gt;</span>buffer_info<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>rx_desc<span class="token operator">-&gt;</span>status <span class="token operator">&amp;</span> IXGB_RX_DESC_STATUS_DD<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">;</span>
        u8 status<span class="token punctuation">;</span>

        status <span class="token operator">=</span> rx_desc<span class="token operator">-&gt;</span>status<span class="token punctuation">;</span>
        skb <span class="token operator">=</span> buffer_info<span class="token operator">-&gt;</span>skb<span class="token punctuation">;</span>
        buffer_info<span class="token operator">-&gt;</span>skb <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

        <span class="token function">prefetch</span><span class="token punctuation">(</span>skb<span class="token operator">-&gt;</span>data <span class="token operator">-</span> NET_IP_ALIGN<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>i <span class="token operator">==</span> rx_ring<span class="token operator">-&gt;</span>count<span class="token punctuation">)</span>
            i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        next_rxd <span class="token operator">=</span> <span class="token function">IXGB_RX_DESC</span><span class="token punctuation">(</span><span class="token operator">*</span>rx_ring<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">prefetch</span><span class="token punctuation">(</span>next_rxd<span class="token punctuation">)</span><span class="token punctuation">;</span>

        j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> rx_ring<span class="token operator">-&gt;</span>count<span class="token punctuation">)</span>
            j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        next2_buffer <span class="token operator">=</span> <span class="token operator">&amp;</span>rx_ring<span class="token operator">-&gt;</span>buffer_info<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token function">prefetch</span><span class="token punctuation">(</span>next2_buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>

        next_buffer <span class="token operator">=</span> <span class="token operator">&amp;</span>rx_ring<span class="token operator">-&gt;</span>buffer_info<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        length <span class="token operator">=</span> <span class="token function">le16_to_cpu</span><span class="token punctuation">(</span>rx_desc<span class="token operator">-&gt;</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        rx_desc<span class="token operator">-&gt;</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token function">ixgb_check_copybreak</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>adapter<span class="token operator">-&gt;</span>napi<span class="token punctuation">,</span> buffer_info<span class="token punctuation">,</span> length<span class="token punctuation">,</span> <span class="token operator">&amp;</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* Good Receive */</span>
        <span class="token function">skb_put</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* Receive Checksum Offload */</span>
        <span class="token function">ixgb_rx_checksum</span><span class="token punctuation">(</span>adapter<span class="token punctuation">,</span> rx_desc<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>

        skb<span class="token operator">-&gt;</span>protocol <span class="token operator">=</span> <span class="token function">eth_type_trans</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> netdev<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">netif_receive_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token comment">/* use prefetched values */</span>
        rx_desc <span class="token operator">=</span> next_rxd<span class="token punctuation">;</span>
        buffer_info <span class="token operator">=</span> next_buffer<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    rx_ring<span class="token operator">-&gt;</span>next_to_clean <span class="token operator">=</span> i<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在网络设备的驱动层，有一个用于接收网络包的rx_ring。它是一个环，从网卡硬件接收的包会放在这个环里面。这个环里面的buffer_info[]是一个数组，存放的是网络包的内容。i和j是这个数组的下标，在ixgb_clean_rx_irq里面的while循环中，依次处理环里面的数据。在这里面，我们看到了i和j加一之后，如果超过了数组的大小，就跳回下标0，就说明这是一个环。</p>
<p>ixgb_check_copybreak函数将buffer_info里面的内容，拷贝到struct sk_buff *skb，从而可以作为一个网络包进行后续的处理，然后调用netif_receive_skb。</p>
<h4 id="43-2-网络协议栈的二层逻辑"><a href="#43-2-网络协议栈的二层逻辑" class="headerlink" title="43.2 网络协议栈的二层逻辑"></a>43.2 网络协议栈的二层逻辑</h4><p>从netif_receive_skb函数开始，我们就进入了内核的网络协议栈。</p>
<p>接下来的调用链为：netif_receive_skb-&gt;netif_receive_skb_internal-&gt;<strong>netif_receive_skb-&gt;</strong>netif_receive_skb_core。</p>
<p>在__netif_receive_skb_core中，我们先是处理了二层的一些逻辑。例如，对于VLAN的处理，接下来要想办法交给第三层。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">__netif_receive_skb_core</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">,</span> bool pfmemalloc<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">packet_type</span> <span class="token operator">*</span>ptype<span class="token punctuation">,</span> <span class="token operator">*</span>pt_prev<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    type <span class="token operator">=</span> skb<span class="token operator">-&gt;</span>protocol<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">deliver_ptype_list_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pt_prev<span class="token punctuation">,</span> orig_dev<span class="token punctuation">,</span> type<span class="token punctuation">,</span>
                   <span class="token operator">&amp;</span>orig_dev<span class="token operator">-&gt;</span>ptype_specific<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pt_prev<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ret <span class="token operator">=</span> pt_prev<span class="token operator">-&gt;</span><span class="token function">func</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> skb<span class="token operator">-&gt;</span>dev<span class="token punctuation">,</span> pt_prev<span class="token punctuation">,</span> orig_dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">deliver_ptype_list_skb</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">,</span>
                      <span class="token keyword">struct</span> <span class="token class-name">packet_type</span> <span class="token operator">*</span><span class="token operator">*</span>pt<span class="token punctuation">,</span>
                      <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>orig_dev<span class="token punctuation">,</span>
                      __be16 type<span class="token punctuation">,</span>
                      <span class="token keyword">struct</span> <span class="token class-name">list_head</span> <span class="token operator">*</span>ptype_list<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">packet_type</span> <span class="token operator">*</span>ptype<span class="token punctuation">,</span> <span class="token operator">*</span>pt_prev <span class="token operator">=</span> <span class="token operator">*</span>pt<span class="token punctuation">;</span>

    <span class="token function">list_for_each_entry_rcu</span><span class="token punctuation">(</span>ptype<span class="token punctuation">,</span> ptype_list<span class="token punctuation">,</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ptype<span class="token operator">-&gt;</span>type <span class="token operator">!=</span> type<span class="token punctuation">)</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pt_prev<span class="token punctuation">)</span>
            <span class="token function">deliver_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> pt_prev<span class="token punctuation">,</span> orig_dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
        pt_prev <span class="token operator">=</span> ptype<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">*</span>pt <span class="token operator">=</span> pt_prev<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在网络包struct sk_buff里面，二层的头里面有一个protocol，表示里面一层，也即三层是什么协议。deliver_ptype_list_skb在一个协议列表中逐个匹配。如果能够匹配到，就返回。</p>
<p>这些协议的注册在网络协议栈初始化的时候， inet_init函数调用dev_add_pack(&amp;ip_packet_type)，添加IP协议。协议被放在一个链表里面。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">dev_add_pack</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">packet_type</span> <span class="token operator">*</span>pt<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> <span class="token operator">*</span>head <span class="token operator">=</span> <span class="token function">ptype_head</span><span class="token punctuation">(</span>pt<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">list_add_rcu</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pt<span class="token operator">-&gt;</span>list<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">list_head</span> <span class="token operator">*</span><span class="token function">ptype_head</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">packet_type</span> <span class="token operator">*</span>pt<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pt<span class="token operator">-&gt;</span>type <span class="token operator">==</span> <span class="token function">htons</span><span class="token punctuation">(</span>ETH_P_ALL<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> pt<span class="token operator">-&gt;</span>dev <span class="token operator">?</span> <span class="token operator">&amp;</span>pt<span class="token operator">-&gt;</span>dev<span class="token operator">-&gt;</span>ptype_all <span class="token operator">:</span> <span class="token operator">&amp;</span>ptype_all<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> pt<span class="token operator">-&gt;</span>dev <span class="token operator">?</span> <span class="token operator">&amp;</span>pt<span class="token operator">-&gt;</span>dev<span class="token operator">-&gt;</span>ptype_specific <span class="token operator">:</span> <span class="token operator">&amp;</span>ptype_base<span class="token punctuation">[</span><span class="token function">ntohs</span><span class="token punctuation">(</span>pt<span class="token operator">-&gt;</span>type<span class="token punctuation">)</span> <span class="token operator">&amp;</span> PTYPE_HASH_MASK<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>假设这个时候的网络包是一个IP包，则在这个链表里面一定能够找到ip_packet_type，在__netif_receive_skb_core中会调用ip_packet_type的func函数。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">packet_type</span> ip_packet_type __read_mostly <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token function">cpu_to_be16</span><span class="token punctuation">(</span>ETH_P_IP<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>func <span class="token operator">=</span> ip_rcv<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>从上面的定义我们可以看出，接下来，ip_rcv会被调用。</p>
<h4 id="43-3-网络协议栈的IP层"><a href="#43-3-网络协议栈的IP层" class="headerlink" title="43.3 网络协议栈的IP层"></a>43.3 网络协议栈的IP层</h4><p>从ip_rcv函数开始，我们的处理逻辑就从二层到了三层，IP层。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">ip_rcv</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">packet_type</span> <span class="token operator">*</span>pt<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>orig_dev<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">iphdr</span> <span class="token operator">*</span>iph<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">net</span> <span class="token operator">*</span>net<span class="token punctuation">;</span>
    u32 len<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    net <span class="token operator">=</span> <span class="token function">dev_net</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    iph <span class="token operator">=</span> <span class="token function">ip_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    len <span class="token operator">=</span> <span class="token function">ntohs</span><span class="token punctuation">(</span>iph<span class="token operator">-&gt;</span>tot_len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    skb<span class="token operator">-&gt;</span>transport_header <span class="token operator">=</span> skb<span class="token operator">-&gt;</span>network_header <span class="token operator">+</span> iph<span class="token operator">-&gt;</span>ihl<span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> <span class="token function">NF_HOOK</span><span class="token punctuation">(</span>NFPROTO_IPV4<span class="token punctuation">,</span> NF_INET_PRE_ROUTING<span class="token punctuation">,</span>
               net<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> skb<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span>
               ip_rcv_finish<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在ip_rcv中，得到IP头，然后又遇到了我们见过多次的NF_HOOK，这次因为是接收网络包，第一个hook点是NF_INET_PRE_ROUTING，也就是iptables的PREROUTING链。如果里面有规则，则执行规则，然后调用ip_rcv_finish。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ip_rcv_finish</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">net</span> <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">iphdr</span> <span class="token operator">*</span>iph <span class="token operator">=</span> <span class="token function">ip_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev <span class="token operator">=</span> skb<span class="token operator">-&gt;</span>dev<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rtable</span> <span class="token operator">*</span>rt<span class="token punctuation">;</span>
    <span class="token keyword">int</span> err<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    rt <span class="token operator">=</span> <span class="token function">skb_rtable</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> <span class="token function">dst_input</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">dst_input</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">skb_dst</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">input</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>ip_rcv_finish得到网络包对应的路由表，然后调用dst_input，在dst_input中，调用的是struct rtable的成员的dst的input函数。在rt_dst_alloc中，我们可以看到，input函数指向的是ip_local_deliver。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">ip_local_deliver</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">/*
     *  Reassemble IP fragments.
     */</span>
    <span class="token keyword">struct</span> <span class="token class-name">net</span> <span class="token operator">*</span>net <span class="token operator">=</span> <span class="token function">dev_net</span><span class="token punctuation">(</span>skb<span class="token operator">-&gt;</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ip_is_fragment</span><span class="token punctuation">(</span><span class="token function">ip_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ip_defrag</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> IP_DEFRAG_LOCAL_DELIVER<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token function">NF_HOOK</span><span class="token punctuation">(</span>NFPROTO_IPV4<span class="token punctuation">,</span> NF_INET_LOCAL_IN<span class="token punctuation">,</span>
               net<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> skb<span class="token punctuation">,</span> skb<span class="token operator">-&gt;</span>dev<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span>
               ip_local_deliver_finish<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在ip_local_deliver函数中，如果IP层进行了分段，则进行重新的组合。接下来就是我们熟悉的NF_HOOK。hook点在NF_INET_LOCAL_IN，对应iptables里面的INPUT链。在经过iptables规则处理完毕后，我们调用ip_local_deliver_finish。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ip_local_deliver_finish</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">net</span> <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">__skb_pull</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> <span class="token function">skb_network_header_len</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> protocol <span class="token operator">=</span> <span class="token function">ip_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>protocol<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">net_protocol</span> <span class="token operator">*</span>ipprot<span class="token punctuation">;</span>

    ipprot <span class="token operator">=</span> <span class="token function">rcu_dereference</span><span class="token punctuation">(</span>inet_protos<span class="token punctuation">[</span>protocol<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ipprot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
        ret <span class="token operator">=</span> ipprot<span class="token operator">-&gt;</span><span class="token function">handler</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在IP头中，有一个字段protocol用于指定里面一层的协议，在这里应该是TCP协议。于是，从inet_protos数组中，找出TCP协议对应的处理函数。这个数组的定义如下，里面的内容是struct net_protocol。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">net_protocol</span> __rcu <span class="token operator">*</span>inet_protos<span class="token punctuation">[</span>MAX_INET_PROTOS<span class="token punctuation">]</span> __read_mostly<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">inet_add_protocol</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">net_protocol</span> <span class="token operator">*</span>prot<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> protocol<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token function">cmpxchg</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">net_protocol</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>inet_protos<span class="token punctuation">[</span>protocol<span class="token punctuation">]</span><span class="token punctuation">,</span>
            <span class="token constant">NULL</span><span class="token punctuation">,</span> prot<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">inet_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">inet_add_protocol</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>udp_protocol<span class="token punctuation">,</span> IPPROTO_UDP<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">pr_crit</span><span class="token punctuation">(</span><span class="token string">"%s: Cannot add UDP protocol\n"</span><span class="token punctuation">,</span> <span class="token constant">__func__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">inet_add_protocol</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tcp_protocol<span class="token punctuation">,</span> IPPROTO_TCP<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">pr_crit</span><span class="token punctuation">(</span><span class="token string">"%s: Cannot add TCP protocol\n"</span><span class="token punctuation">,</span> <span class="token constant">__func__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">net_protocol</span> tcp_protocol <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>early_demux         <span class="token operator">=</span>   tcp_v4_early_demux<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>early_demux_handler <span class="token operator">=</span>  tcp_v4_early_demux<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>handler             <span class="token operator">=</span>   tcp_v4_rcv<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>err_handler         <span class="token operator">=</span>   tcp_v4_err<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>no_policy           <span class="token operator">=</span>   <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>netns_ok            <span class="token operator">=</span>   <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>icmp_strict_tag_validation <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">net_protocol</span> udp_protocol <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>early_demux            <span class="token operator">=</span>  udp_v4_early_demux<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>early_demux_handler    <span class="token operator">=</span>  udp_v4_early_demux<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>handler                <span class="token operator">=</span>  udp_rcv<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>err_handler            <span class="token operator">=</span>  udp_err<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>no_policy              <span class="token operator">=</span>    <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>netns_ok               <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在系统初始化的时候，网络协议栈的初始化调用的是inet_init，它会调用inet_add_protocol，将TCP协议对应的处理函数tcp_protocol、UDP协议对应的处理函数udp_protocol，放到inet_protos数组中。</p>
<p>在上面的网络包的接收过程中，会取出TCP协议对应的处理函数tcp_protocol，然后调用handler函数，也即tcp_v4_rcv函数。</p>
<h4 id="43-4-总结"><a href="#43-4-总结" class="headerlink" title="43.4 总结"></a>43.4 总结</h4><p>这一节我们讲了接收网络包的上半部分，分以下几个层次。</p>
<ul>
<li>硬件网卡接收到网络包之后，通过DMA技术，将网络包放入Ring Buffer。</li>
<li>硬件网卡通过中断通知CPU新的网络包的到来。</li>
<li>网卡驱动程序会注册中断处理函数ixgb_intr。</li>
<li>中断处理函数处理完需要暂时屏蔽中断的核心流程之后，通过软中断NET_RX_SOFTIRQ触发接下来的处理过程。</li>
<li>NET_RX_SOFTIRQ软中断处理函数net_rx_action，net_rx_action会调用napi_poll，进而调用ixgb_clean_rx_irq，从Ring Buffer中读取数据到内核struct sk_buff。</li>
<li>调用netif_receive_skb进入内核网络协议栈，进行一些关于VLAN的二层逻辑处理后，调用ip_rcv进入三层IP层。</li>
<li>在IP层，会处理iptables规则，然后调用ip_local_deliver，交给更上层TCP层。</li>
<li>在TCP层调用tcp_v4_rcv。</li>
</ul>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/接收网络包部分过程.png" alt="接收网络包部分过程"></p>
<h3 id="44-接收网络包（下）"><a href="#44-接收网络包（下）" class="headerlink" title="44. 接收网络包（下）"></a>44. 接收网络包（下）</h3><p>上一节，我们解析了网络包接收的上半部分，从硬件网卡到IP层。这一节，我们接着来解析TCP层和Socket层都做了哪些事情。</p>
<h4 id="44-1-网络协议栈的TCP层"><a href="#44-1-网络协议栈的TCP层" class="headerlink" title="44.1 网络协议栈的TCP层"></a>44.1 网络协议栈的TCP层</h4><p>从tcp_v4_rcv函数开始，我们的处理逻辑就从IP层到了TCP层。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_v4_rcv</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">net</span> <span class="token operator">*</span>net <span class="token operator">=</span> <span class="token function">dev_net</span><span class="token punctuation">(</span>skb<span class="token operator">-&gt;</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">iphdr</span> <span class="token operator">*</span>iph<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">tcphdr</span> <span class="token operator">*</span>th<span class="token punctuation">;</span>
    bool refcounted<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    th <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">tcphdr</span> <span class="token operator">*</span><span class="token punctuation">)</span>skb<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
    iph <span class="token operator">=</span> <span class="token function">ip_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>seq <span class="token operator">=</span> <span class="token function">ntohl</span><span class="token punctuation">(</span>th<span class="token operator">-&gt;</span>seq<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>end_seq <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>seq <span class="token operator">+</span> th<span class="token operator">-&gt;</span>syn <span class="token operator">+</span> th<span class="token operator">-&gt;</span>fin <span class="token operator">+</span> skb<span class="token operator">-&gt;</span>len <span class="token operator">-</span> th<span class="token operator">-&gt;</span>doff <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>ack_seq <span class="token operator">=</span> <span class="token function">ntohl</span><span class="token punctuation">(</span>th<span class="token operator">-&gt;</span>ack_seq<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>tcp_flags <span class="token operator">=</span> <span class="token function">tcp_flag_byte</span><span class="token punctuation">(</span>th<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>tcp_tw_isn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>ip_dsfield <span class="token operator">=</span> <span class="token function">ipv4_get_dsfield</span><span class="token punctuation">(</span>iph<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>sacked  <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

lookup<span class="token operator">:</span>
    sk <span class="token operator">=</span> <span class="token function">__inet_lookup_skb</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tcp_hashinfo<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> <span class="token function">__tcp_hdrlen</span><span class="token punctuation">(</span>th<span class="token punctuation">)</span><span class="token punctuation">,</span> th<span class="token operator">-&gt;</span>source<span class="token punctuation">,</span> th<span class="token operator">-&gt;</span>dest<span class="token punctuation">,</span> <span class="token operator">&amp;</span>refcounted<span class="token punctuation">)</span><span class="token punctuation">;</span>

process<span class="token operator">:</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>sk<span class="token operator">-&gt;</span>sk_state <span class="token operator">==</span> TCP_TIME_WAIT<span class="token punctuation">)</span>
        <span class="token keyword">goto</span> do_time_wait<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>sk<span class="token operator">-&gt;</span>sk_state <span class="token operator">==</span> TCP_NEW_SYN_RECV<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    th <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">tcphdr</span> <span class="token operator">*</span><span class="token punctuation">)</span>skb<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
    iph <span class="token operator">=</span> <span class="token function">ip_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>

    skb<span class="token operator">-&gt;</span>dev <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>sk<span class="token operator">-&gt;</span>sk_state <span class="token operator">==</span> TCP_LISTEN<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ret <span class="token operator">=</span> <span class="token function">tcp_v4_do_rcv</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> put_and_return<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">sock_owned_by_user</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tcp_prequeue</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">)</span>
            ret <span class="token operator">=</span> <span class="token function">tcp_v4_do_rcv</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tcp_add_backlog</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">goto</span> discard_and_relse<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在tcp_v4_rcv中，得到TCP的头之后，我们可以开始处理TCP层的事情。因为TCP层是分状态的，状态被维护在数据结构struct sock里面，因而我们要根据IP地址以及TCP头里面的内容，在tcp_hashinfo中找到这个包对应的struct sock，从而得到这个包对应的连接的状态。</p>
<p>接下来，我们就根据不同的状态做不同的处理，例如，上面代码中的TCP_LISTEN、TCP_NEW_SYN_RECV状态属于连接建立过程中。这个我们在讲三次握手的时候讲过了。再如，TCP_TIME_WAIT状态是连接结束的时候的状态，这个我们暂时可以不用看。</p>
<p>接下来，我们来分析最主流的网络包的接收过程，这里面涉及三个队列：</p>
<ul>
<li>backlog队列</li>
<li>prequeue队列</li>
<li>sk_receive_queue队列</li>
</ul>
<p>为什么接收网络包的过程，需要在这三个队列里面倒腾过来、倒腾过去呢？这是因为，同样一个网络包要在三个主体之间交接。</p>
<p>第一个主体是<strong>软中断的处理过程</strong>。如果你没忘记的话，我们在执行tcp_v4_rcv函数的时候，依然处于软中断的处理逻辑里，所以必然会占用这个软中断。</p>
<p>第二个主体就是<strong>用户态进程</strong>。如果用户态触发系统调用read读取网络包，也要从队列里面找。</p>
<p>第三个主体就是<strong>内核协议栈</strong>。哪怕用户进程没有调用read，读取网络包，当网络包来的时候，也得有一个地方收着呀。</p>
<p>这时候，我们就能够了解上面代码中sock_owned_by_user的意思了，其实就是说，当前这个sock是不是正有一个用户态进程等着读数据呢，如果没有，内核协议栈也调用tcp_add_backlog，暂存在backlog队列中，并且抓紧离开软中断的处理过程。</p>
<p>如果有一个用户态进程等待读取数据呢？我们先调用tcp_prequeue，也即赶紧放入prequeue队列，并且离开软中断的处理过程。在这个函数里面，我们会看到对于sysctl_tcp_low_latency的判断，也即是不是要低时延地处理网络包。</p>
<p>如果把sysctl_tcp_low_latency设置为0，那就要放在prequeue队列中暂存，这样不用等待网络包处理完毕，就可以离开软中断的处理过程，但是会造成比较长的时延。如果把sysctl_tcp_low_latency设置为1，我们还是调用tcp_v4_do_rcv。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_v4_do_rcv</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>rsk<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>sk<span class="token operator">-&gt;</span>sk_state <span class="token operator">==</span> TCP_ESTABLISHED<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* Fast path */</span>
        <span class="token keyword">struct</span> <span class="token class-name">dst_entry</span> <span class="token operator">*</span>dst <span class="token operator">=</span> sk<span class="token operator">-&gt;</span>sk_rx_dst<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token function">tcp_rcv_established</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> <span class="token function">tcp_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">,</span> skb<span class="token operator">-&gt;</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tcp_rcv_state_process</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在tcp_v4_do_rcv中，分两种情况，一种情况是连接已经建立，处于TCP_ESTABLISHED状态，调用tcp_rcv_established。另一种情况，就是其他的状态，调用tcp_rcv_state_process。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_rcv_state_process</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">tcp_sock</span> <span class="token operator">*</span>tp <span class="token operator">=</span> <span class="token function">tcp_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">inet_connection_sock</span> <span class="token operator">*</span>icsk <span class="token operator">=</span> <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">tcphdr</span> <span class="token operator">*</span>th <span class="token operator">=</span> <span class="token function">tcp_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">request_sock</span> <span class="token operator">*</span>req<span class="token punctuation">;</span>
    <span class="token keyword">int</span> queued <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    bool acceptable<span class="token punctuation">;</span>

    <span class="token keyword">switch</span> <span class="token punctuation">(</span>sk<span class="token operator">-&gt;</span>sk_state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> TCP_CLOSE<span class="token operator">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">case</span> TCP_LISTEN<span class="token operator">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">case</span> TCP_SYN_SENT<span class="token operator">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>sk<span class="token operator">-&gt;</span>sk_state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> TCP_SYN_RECV<span class="token operator">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">case</span> TCP_FIN_WAIT1<span class="token operator">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">case</span> TCP_CLOSING<span class="token operator">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">case</span> TCP_LAST_ACK<span class="token operator">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* step 7: process the segment text */</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>sk<span class="token operator">-&gt;</span>sk_state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> TCP_CLOSE_WAIT<span class="token operator">:</span>
    <span class="token keyword">case</span> TCP_CLOSING<span class="token operator">:</span>
    <span class="token keyword">case</span> TCP_LAST_ACK<span class="token operator">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">case</span> TCP_FIN_WAIT1<span class="token operator">:</span>
    <span class="token keyword">case</span> TCP_FIN_WAIT2<span class="token operator">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">case</span> TCP_ESTABLISHED<span class="token operator">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在tcp_rcv_state_process中，如果我们对着TCP的状态图进行比对，能看到，对于TCP所有状态的处理，其中和连接建立相关的状态，咱们已经分析过，所以我们重点关注连接状态下的工作模式。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/TCP的状态图.png" alt="TCP的状态图"></p>
<p>在连接状态下，我们会调用tcp_rcv_established。在这个函数里面，我们会调用tcp_data_queue，将其放入sk_receive_queue队列进行处理。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">tcp_data_queue</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">tcp_sock</span> <span class="token operator">*</span>tp <span class="token operator">=</span> <span class="token function">tcp_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    bool fragstolen <span class="token operator">=</span> false<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>seq <span class="token operator">==</span> tp<span class="token operator">-&gt;</span>rcv_nxt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tcp_receive_window</span><span class="token punctuation">(</span>tp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">goto</span> out_of_window<span class="token punctuation">;</span>

        <span class="token comment">/* Ok. In sequence. In window. */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>tp<span class="token operator">-&gt;</span>ucopy<span class="token punctuation">.</span>task <span class="token operator">==</span> current <span class="token operator">&amp;&amp;</span>
            tp<span class="token operator">-&gt;</span>copied_seq <span class="token operator">==</span> tp<span class="token operator">-&gt;</span>rcv_nxt <span class="token operator">&amp;&amp;</span> tp<span class="token operator">-&gt;</span>ucopy<span class="token punctuation">.</span>len <span class="token operator">&amp;&amp;</span>
            <span class="token function">sock_owned_by_user</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>tp<span class="token operator">-&gt;</span>urg_data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> chunk <span class="token operator">=</span> <span class="token function">min_t</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> skb<span class="token operator">-&gt;</span>len<span class="token punctuation">,</span>
                      tp<span class="token operator">-&gt;</span>ucopy<span class="token punctuation">.</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token function">__set_current_state</span><span class="token punctuation">(</span>TASK_RUNNING<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">skb_copy_datagram_msg</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> tp<span class="token operator">-&gt;</span>ucopy<span class="token punctuation">.</span>msg<span class="token punctuation">,</span> chunk<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                tp<span class="token operator">-&gt;</span>ucopy<span class="token punctuation">.</span>len <span class="token operator">-=</span> chunk<span class="token punctuation">;</span>
                tp<span class="token operator">-&gt;</span>copied_seq <span class="token operator">+=</span> chunk<span class="token punctuation">;</span>
                eaten <span class="token operator">=</span> <span class="token punctuation">(</span>chunk <span class="token operator">==</span> skb<span class="token operator">-&gt;</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">tcp_rcv_space_adjust</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>eaten <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
queue_and_out<span class="token operator">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            eaten <span class="token operator">=</span> <span class="token function">tcp_queue_rcv</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fragstolen<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">tcp_rcv_nxt_update</span><span class="token punctuation">(</span>tp<span class="token punctuation">,</span> <span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>end_seq<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">RB_EMPTY_ROOT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tp<span class="token operator">-&gt;</span>out_of_order_queue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">tcp_ofo_queue</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">after</span><span class="token punctuation">(</span><span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>end_seq<span class="token punctuation">,</span> tp<span class="token operator">-&gt;</span>rcv_nxt<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* A retransmit, 2nd most common case.  Force an immediate ack. */</span>
        <span class="token function">tcp_dsack_set</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>seq<span class="token punctuation">,</span> <span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>end_seq<span class="token punctuation">)</span><span class="token punctuation">;</span>

out_of_window<span class="token operator">:</span>
        <span class="token function">tcp_enter_quickack_mode</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">inet_csk_schedule_ack</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
drop<span class="token operator">:</span>
        <span class="token function">tcp_drop</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* Out of window. F.e. zero window probe. */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">before</span><span class="token punctuation">(</span><span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>seq<span class="token punctuation">,</span> tp<span class="token operator">-&gt;</span>rcv_nxt <span class="token operator">+</span> <span class="token function">tcp_receive_window</span><span class="token punctuation">(</span>tp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">goto</span> out_of_window<span class="token punctuation">;</span>

    <span class="token function">tcp_enter_quickack_mode</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">before</span><span class="token punctuation">(</span><span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>seq<span class="token punctuation">,</span> tp<span class="token operator">-&gt;</span>rcv_nxt<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* Partial packet, seq &lt; rcv_next &lt; end_seq */</span>
        <span class="token function">tcp_dsack_set</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>seq<span class="token punctuation">,</span> tp<span class="token operator">-&gt;</span>rcv_nxt<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">/* If window is closed, drop tail of packet. But after
         * remembering D-SACK for its head made in previous line.
         */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tcp_receive_window</span><span class="token punctuation">(</span>tp<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">goto</span> out_of_window<span class="token punctuation">;</span>
        <span class="token keyword">goto</span> queue_and_out<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">tcp_data_queue_ofo</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在tcp_data_queue中，对于收到的网络包，我们要分情况进行处理。</p>
<p>第一种情况，seq == tp-&gt;rcv_nxt，说明来的网络包正是我服务端期望的下一个网络包。这个时候我们判断sock_owned_by_user，也即用户进程也是正在等待读取，这种情况下，就直接skb_copy_datagram_msg，将网络包拷贝给用户进程就可以了。</p>
<p>如果用户进程没有正在等待读取，或者因为内存原因没有能够拷贝成功，tcp_queue_rcv里面还是将网络包放入sk_receive_queue队列。</p>
<p>接下来，tcp_rcv_nxt_update将tp-&gt;rcv_nxt设置为end_seq，也即当前的网络包接收成功后，更新下一个期待的网络包。</p>
<p>这个时候，我们还会判断一下另一个队列，out_of_order_queue，也看看乱序队列的情况，看看乱序队列里面的包，会不会因为这个新的网络包的到来，也能放入到sk_receive_queue队列中。</p>
<p>例如，客户端发送的网络包序号为5、6、7、8、9。在5还没有到达的时候，服务端的rcv_nxt应该是5，也即期望下一个网络包是5。但是由于中间网络通路的问题，5、6还没到达服务端，7、8已经到达了服务端了，这就出现了乱序。</p>
<p>乱序的包不能进入sk_receive_queue队列。因为一旦进入到这个队列，意味着可以发送给用户进程。然而，按照TCP的定义，用户进程应该是按顺序收到包的，没有排好序，就不能给用户进程。所以，7、8不能进入sk_receive_queue队列，只能暂时放在out_of_order_queue乱序队列中。</p>
<p>当5、6到达的时候，5、6先进入sk_receive_queue队列。这个时候我们再来看out_of_order_queue乱序队列中的7、8，发现能够接上。于是，7、8也能进入sk_receive_queue队列了。tcp_ofo_queue函数就是做这个事情的。</p>
<p>至此第一种情况处理完毕。</p>
<p>第二种情况，end_seq不大于rcv_nxt，也即服务端期望网络包5。但是，来了一个网络包3，怎样才会出现这种情况呢？肯定是服务端早就收到了网络包3，但是ACK没有到达客户端，中途丢了，那客户端就认为网络包3没有发送成功，于是又发送了一遍，这种情况下，要赶紧给客户端再发送一次ACK，表示早就收到了。</p>
<p>第三种情况，seq不小于rcv_nxt + tcp_receive_window。这说明客户端发送得太猛了。本来seq肯定应该在接收窗口里面的，这样服务端才来得及处理，结果现在超出了接收窗口，说明客户端一下子把服务端给塞满了。</p>
<p>这种情况下，服务端不能再接收数据包了，只能发送ACK了，在ACK中会将接收窗口为0的情况告知客户端，客户端就知道不能再发送了。这个时候双方只能交互窗口探测数据包，直到服务端因为用户进程把数据读走了，空出接收窗口，才能在ACK里面再次告诉客户端，又有窗口了，又能发送数据包了。</p>
<p>第四种情况，seq小于rcv_nxt，但是end_seq大于rcv_nxt，这说明从seq到rcv_nxt这部分网络包原来的ACK客户端没有收到，所以重新发送了一次，从rcv_nxt到end_seq时新发送的，可以放入sk_receive_queue队列。</p>
<p>当前四种情况都排除掉了，说明网络包一定是一个乱序包了。这里有点儿难理解，我们还是用上面那个乱序的例子仔细分析一下rcv_nxt=5。</p>
<p>我们假设tcp_receive_window也是5，也即超过10服务端就接收不了了。当前来的这个网络包既不在rcv_nxt之前（不是3这种），也不在rcv_nxt + tcp_receive_window之后（不是11这种），说明这正在我们期望的接收窗口里面，但是又不是rcv_nxt（不是我们马上期望的网络包5），这正是上面的例子中网络包7、8的情况。</p>
<p>对于网络包7、8，我们只好调用tcp_data_queue_ofo进入out_of_order_queue乱序队列，但是没有关系，当网络包5、6到来的时候，我们会走第一种情况，把7、8拿出来放到sk_receive_queue队列中。</p>
<p>至此，网络协议栈的处理过程就结束了。</p>
<h4 id="44-2-Socket层"><a href="#44-2-Socket层" class="headerlink" title="44.2 Socket层"></a>44.2 Socket层</h4><p>当接收的网络包进入各种队列之后，接下来我们就要等待用户进程去读取它们了。</p>
<p>读取一个socket，就像读取一个文件一样，读取socket的文件描述符，通过read系统调用。</p>
<p>read系统调用对于一个文件描述符的操作，大致过程都是类似的，在文件系统那一节，我们已经详细解析过。最终它会调用到用来表示一个打开文件的结构stuct file指向的file_operations操作。</p>
<p>对于socket来讲，它的file_operations定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> socket_file_ops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>owner <span class="token operator">=</span>        THIS_MODULE<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>llseek <span class="token operator">=</span>       no_llseek<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>read_iter <span class="token operator">=</span>    sock_read_iter<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>write_iter <span class="token operator">=</span>   sock_write_iter<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>poll <span class="token operator">=</span>         sock_poll<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>unlocked_ioctl <span class="token operator">=</span> sock_ioctl<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>mmap <span class="token operator">=</span>         sock_mmap<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>release <span class="token operator">=</span>      sock_close<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>fasync <span class="token operator">=</span>       sock_fasync<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>sendpage <span class="token operator">=</span>     sock_sendpage<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>splice_write <span class="token operator">=</span> generic_splice_sendpage<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>splice_read <span class="token operator">=</span>  sock_splice_read<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>按照文件系统的读取流程，调用的是sock_read_iter。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> ssize_t <span class="token function">sock_read_iter</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kiocb</span> <span class="token operator">*</span>iocb<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">iov_iter</span> <span class="token operator">*</span>to<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file <span class="token operator">=</span> iocb<span class="token operator">-&gt;</span>ki_filp<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span>sock <span class="token operator">=</span> file<span class="token operator">-&gt;</span>private_data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">msghdr</span> msg <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>msg_iter <span class="token operator">=</span> <span class="token operator">*</span>to<span class="token punctuation">,</span>
                 <span class="token punctuation">.</span>msg_iocb <span class="token operator">=</span> iocb<span class="token punctuation">}</span><span class="token punctuation">;</span>
    ssize_t res<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>file<span class="token operator">-&gt;</span>f_flags <span class="token operator">&amp;</span> O_NONBLOCK<span class="token punctuation">)</span>
        msg<span class="token punctuation">.</span>msg_flags <span class="token operator">=</span> MSG_DONTWAIT<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    res <span class="token operator">=</span> <span class="token function">sock_recvmsg</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token punctuation">,</span> msg<span class="token punctuation">.</span>msg_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>to <span class="token operator">=</span> msg<span class="token punctuation">.</span>msg_iter<span class="token punctuation">;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在sock_read_iter中，通过VFS中的struct file，将创建好的socket结构拿出来，然后调用sock_recvmsg，sock_recvmsg会调用sock_recvmsg_nosec。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">sock_recvmsg_nosec</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">msghdr</span> <span class="token operator">*</span>msg<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> sock<span class="token operator">-&gt;</span>ops<span class="token operator">-&gt;</span><span class="token function">recvmsg</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> <span class="token function">msg_data_left</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里调用了socket的ops的recvmsg，这个我们遇到好几次了。根据inet_stream_ops的定义，这里调用的是inet_recvmsg。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">inet_recvmsg</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">msghdr</span> <span class="token operator">*</span>msg<span class="token punctuation">,</span> size_t size<span class="token punctuation">,</span>
         <span class="token keyword">int</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk <span class="token operator">=</span> sock<span class="token operator">-&gt;</span>sk<span class="token punctuation">;</span>
    <span class="token keyword">int</span> addr_len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> err<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    err <span class="token operator">=</span> sk<span class="token operator">-&gt;</span>sk_prot<span class="token operator">-&gt;</span><span class="token function">recvmsg</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> size<span class="token punctuation">,</span> flags <span class="token operator">&amp;</span> MSG_DONTWAIT<span class="token punctuation">,</span>
                   flags <span class="token operator">&amp;</span> <span class="token operator">~</span>MSG_DONTWAIT<span class="token punctuation">,</span> <span class="token operator">&amp;</span>addr_len<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面，从socket结构，我们可以得到更底层的sock结构，然后调用sk_prot的recvmsg方法。这个同样遇到好几次了，根据tcp_prot的定义，调用的是tcp_recvmsg。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tcp_recvmsg</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">msghdr</span> <span class="token operator">*</span>msg<span class="token punctuation">,</span> size_t len<span class="token punctuation">,</span> <span class="token keyword">int</span> nonblock<span class="token punctuation">,</span>
        <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>addr_len<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">tcp_sock</span> <span class="token operator">*</span>tp <span class="token operator">=</span> <span class="token function">tcp_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> copied <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    u32 peek_seq<span class="token punctuation">;</span>
    u32 <span class="token operator">*</span>seq<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> used<span class="token punctuation">;</span>
    <span class="token keyword">int</span> err<span class="token punctuation">;</span>
    <span class="token keyword">int</span> target<span class="token punctuation">;</span>     <span class="token comment">/* Read at least this many bytes */</span>
    <span class="token keyword">long</span> timeo<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>user_recv <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token operator">*</span>last<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        u32 offset<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token comment">/* Next get a buffer. */</span>
        last <span class="token operator">=</span> <span class="token function">skb_peek_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sk<span class="token operator">-&gt;</span>sk_receive_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">skb_queue_walk</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sk<span class="token operator">-&gt;</span>sk_receive_queue<span class="token punctuation">,</span> skb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            last <span class="token operator">=</span> skb<span class="token punctuation">;</span>
            offset <span class="token operator">=</span> <span class="token operator">*</span>seq <span class="token operator">-</span> <span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>seq<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>offset <span class="token operator">&lt;</span> skb<span class="token operator">-&gt;</span>len<span class="token punctuation">)</span>
                <span class="token keyword">goto</span> found_ok_skb<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sysctl_tcp_low_latency <span class="token operator">&amp;&amp;</span> tp<span class="token operator">-&gt;</span>ucopy<span class="token punctuation">.</span>task <span class="token operator">==</span> user_recv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">/* Install new reader */</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>user_recv <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span>MSG_TRUNC <span class="token operator">|</span> MSG_PEEK<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                user_recv <span class="token operator">=</span> current<span class="token punctuation">;</span>
                tp<span class="token operator">-&gt;</span>ucopy<span class="token punctuation">.</span>task <span class="token operator">=</span> user_recv<span class="token punctuation">;</span>
                tp<span class="token operator">-&gt;</span>ucopy<span class="token punctuation">.</span>msg <span class="token operator">=</span> msg<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            tp<span class="token operator">-&gt;</span>ucopy<span class="token punctuation">.</span>len <span class="token operator">=</span> len<span class="token punctuation">;</span>
            <span class="token comment">/* Look: we have the following (pseudo)queues:
             *
             * 1. packets in flight
             * 2. backlog
             * 3. prequeue
             * 4. receive_queue
             *
             * Each queue can be processed only if the next ones
             * are empty.
             */</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">skb_queue_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tp<span class="token operator">-&gt;</span>ucopy<span class="token punctuation">.</span>prequeue<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">goto</span> do_prequeue<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>copied <span class="token operator">&gt;=</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">/* Do not sleep, just process backlog. */</span>
            <span class="token function">release_sock</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">lock_sock</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">sk_wait_data</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>timeo<span class="token punctuation">,</span> last<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>user_recv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> chunk<span class="token punctuation">;</span>
            chunk <span class="token operator">=</span> len <span class="token operator">-</span> tp<span class="token operator">-&gt;</span>ucopy<span class="token punctuation">.</span>len<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>chunk <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                len <span class="token operator">-=</span> chunk<span class="token punctuation">;</span>
                copied <span class="token operator">+=</span> chunk<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>tp<span class="token operator">-&gt;</span>rcv_nxt <span class="token operator">==</span> tp<span class="token operator">-&gt;</span>copied_seq <span class="token operator">&amp;&amp;</span>
                <span class="token operator">!</span><span class="token function">skb_queue_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tp<span class="token operator">-&gt;</span>ucopy<span class="token punctuation">.</span>prequeue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
do_prequeue<span class="token operator">:</span>
                <span class="token function">tcp_prequeue_process</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>

                chunk <span class="token operator">=</span> len <span class="token operator">-</span> tp<span class="token operator">-&gt;</span>ucopy<span class="token punctuation">.</span>len<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>chunk <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    len <span class="token operator">-=</span> chunk<span class="token punctuation">;</span>
                    copied <span class="token operator">+=</span> chunk<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">continue</span><span class="token punctuation">;</span>
    found_ok_skb<span class="token operator">:</span>
        <span class="token comment">/* Ok so how much can we use? */</span>
        used <span class="token operator">=</span> skb<span class="token operator">-&gt;</span>len <span class="token operator">-</span> offset<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> used<span class="token punctuation">)</span>
            used <span class="token operator">=</span> len<span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> MSG_TRUNC<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            err <span class="token operator">=</span> <span class="token function">skb_copy_datagram_msg</span><span class="token punctuation">(</span>skb<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> used<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">}</span>

        <span class="token operator">*</span>seq <span class="token operator">+=</span> used<span class="token punctuation">;</span>
        copied <span class="token operator">+=</span> used<span class="token punctuation">;</span>
        len <span class="token operator">-=</span> used<span class="token punctuation">;</span>

        <span class="token function">tcp_rcv_space_adjust</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>len <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>tcp_recvmsg这个函数比较长，里面逻辑也很复杂，好在里面有一段注释概扩了这里面的逻辑。注释里面提到了三个队列，receive_queue队列、prequeue队列和backlog队列。这里面，我们需要把前一个队列处理完毕，才处理后一个队列。</p>
<p>tcp_recvmsg的整个逻辑也是这样执行的：这里面有一个while循环，不断地读取网络包。</p>
<p>这里，我们会先处理sk_receive_queue队列。如果找到了网络包，就跳到found_ok_skb这里。这里会调用skb_copy_datagram_msg，将网络包拷贝到用户进程中，然后直接进入下一层循环。</p>
<p>直到sk_receive_queue队列处理完毕，我们才到了sysctl_tcp_low_latency判断。如果不需要低时延，则会有prequeue队列。于是，我们能就跳到do_prequeue这里，调用tcp_prequeue_process进行处理。</p>
<p>如果sysctl_tcp_low_latency设置为1，也即没有prequeue队列，或者prequeue队列为空，则需要处理backlog队列，在release_sock函数中处理。</p>
<p>release_sock会调用__release_sock，这里面会依次处理队列中的网络包。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">release_sock</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>sk<span class="token operator">-&gt;</span>sk_backlog<span class="token punctuation">.</span>tail<span class="token punctuation">)</span>
        <span class="token function">__release_sock</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">__release_sock</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">)</span>
    <span class="token function">__releases</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sk<span class="token operator">-&gt;</span>sk_lock<span class="token punctuation">.</span>slock<span class="token punctuation">)</span>
    <span class="token function">__acquires</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sk<span class="token operator">-&gt;</span>sk_lock<span class="token punctuation">.</span>slock<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>skb <span class="token operator">=</span> sk<span class="token operator">-&gt;</span>sk_backlog<span class="token punctuation">.</span>head<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sk<span class="token operator">-&gt;</span>sk_backlog<span class="token punctuation">.</span>head <span class="token operator">=</span> sk<span class="token operator">-&gt;</span>sk_backlog<span class="token punctuation">.</span>tail <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token keyword">do</span> <span class="token punctuation">{</span>
            next <span class="token operator">=</span> skb<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
            <span class="token function">prefetch</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
            skb<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
            <span class="token function">sk_backlog_rcv</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">cond_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            skb <span class="token operator">=</span> next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>skb <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后，哪里都没有网络包，我们只好调用sk_wait_data，继续等待在哪里，等待网络包的到来。</p>
<p>至此，网络包的接收过程到此结束。</p>
<h4 id="44-3-总结"><a href="#44-3-总结" class="headerlink" title="44.3 总结"></a>44.3 总结</h4><p>这一节我们讲完了接收网络包，我们来从头串一下，整个过程可以分成以下几个层次。</p>
<ul>
<li>硬件网卡接收到网络包之后，通过DMA技术，将网络包放入Ring Buffer；</li>
<li>硬件网卡通过中断通知CPU新的网络包的到来；</li>
<li>网卡驱动程序会注册中断处理函数ixgb_intr；</li>
<li>中断处理函数处理完需要暂时屏蔽中断的核心流程之后，通过软中断NET_RX_SOFTIRQ触发接下来的处理过程；</li>
<li>NET_RX_SOFTIRQ软中断处理函数net_rx_action，net_rx_action会调用napi_poll，进而调用ixgb_clean_rx_irq，从Ring Buffer中读取数据到内核struct sk_buff；</li>
<li>调用netif_receive_skb进入内核网络协议栈，进行一些关于VLAN的二层逻辑处理后，调用ip_rcv进入三层IP层；</li>
<li>在IP层，会处理iptables规则，然后调用ip_local_deliver交给更上层TCP层；</li>
<li>在TCP层调用tcp_v4_rcv，这里面有三个队列需要处理，如果当前的Socket不是正在被读；取，则放入backlog队列，如果正在被读取，不需要很实时的话，则放入prequeue队列，其他情况调用tcp_v4_do_rcv；</li>
<li>在tcp_v4_do_rcv中，如果是处于TCP_ESTABLISHED状态，调用tcp_rcv_established，其他的状态，调用tcp_rcv_state_process；</li>
<li>在tcp_rcv_established中，调用tcp_data_queue，如果序列号能够接的上，则放入sk_receive_queue队列；如果序列号接不上，则暂时放入out_of_order_queue队列，等序列号能够接上的时候，再放入sk_receive_queue队列。</li>
</ul>
<p>至此内核接收网络包的过程到此结束，接下来就是用户态读取网络包的过程，这个过程分成几个层次。</p>
<ul>
<li>VFS层：read系统调用找到struct file，根据里面的file_operations的定义，调用sock_read_iter函数。sock_read_iter函数调用sock_recvmsg函数。</li>
<li>Socket层：从struct file里面的private_data得到struct socket，根据里面ops的定义，调用inet_recvmsg函数。</li>
<li>Sock层：从struct socket里面的sk得到struct sock，根据里面sk_prot的定义，调用tcp_recvmsg函数。</li>
<li>TCP层：tcp_recvmsg函数会依次读取receive_queue队列、prequeue队列和backlog队列。</li>
</ul>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/接收网络包完整过程.png" alt="接收网络包完整过程"></p>
<h2 id="八、虚拟化"><a href="#八、虚拟化" class="headerlink" title="八、虚拟化"></a>八、虚拟化</h2><h3 id="43-虚拟机"><a href="#43-虚拟机" class="headerlink" title="43. 虚拟机"></a>43. 虚拟机</h3><p>我们前面所有章节涉及的Linux操作系统原理，都是在一台Linux服务器上工作的.在前面的原理阐述中，我们一直把Linux当作一家外包公司的老板来看待。想要管理这么复杂、这么大的一个公司，需要配备咱们前面讲过的所有机制。</p>
<p>Linux很强大，Linux服务器也随之变得越来越强大了。无论是计算、网络、存储，都越来越牛。例如，内存动不动就是百G内存，网络设备一个端口的带宽就能有几十G甚至上百G，存储在数据中心至少是PB级别的（一个P是1024个T，一个T是1024个G）。</p>
<p>公司大有大了的好处，自然也有大的毛病，也就是咱们常见的“大公司病”——<strong>不灵活</strong>。这里面的不灵活，有下面这几种，我列一下，你看看你是不是都见过。</p>
<ul>
<li><strong>资源大小不灵活</strong>：有时候我们不需要这么大规格的机器，可能只想尝试一下某些新业务，申请个4核8G的服务器试一下，但是不可能采购这么小规格的机器。无论每个项目需要多大规格的机器，公司统一采购就限制几种，全部是上面那种大规格的。</li>
<li><strong>资源申请不灵活</strong>：规格定死就定死吧，可是每次申请机器都要重新采购，周期很长。</li>
<li><strong>资源复用不灵活</strong>：反正我需要的资源不多，和别人共享一台机器吧，这样不同的进程可能会产生冲突，例如socket的端口冲突。另外就是别人用过的机器，不知道上面做过哪些操作，有很多的历史包袱，如果重新安装则代价太大。</li>
</ul>
<p>这些是不是和咱们在大公司里面遇到的问题很像？按说，大事情流程严禁没问题，很多小事情也要被拖累走整个流程，而且很容易出现资源冲突，每天跨部门的协调很累人，历史包袱严重，创新没有办法轻装上阵。</p>
<p>很多公司处理这种问题采取的策略是成立独立的子公司，独立决策，独立运营，往往用于创新型的项目。</p>
<p>Linux也采取了这样的手段，就是在物理机上面创建虚拟机。每个虚拟机有自己单独的操作系统、灵活的规格，一个命令就能启动起来。每次创建都是新的操作系统，很好地解决了上面不灵活的问题。</p>
<p>但是要使用虚拟机，还有一些问题需要解决一下。</p>
<p>我们知道，操作系统上的程序分为两种，一种是用户态的程序，例如Word、Excel等，一种是内核态的程序，例如内核代码、驱动程序等。</p>
<p>为了区分内核态和用户态，CPU专门设置四个特权等级0、1、2、3来做这个事情。</p>
<p>当时写Linux内核的时候，估计大牛们还不知道将来虚拟机会大放异彩。大牛们想，一共两级特权，一个内核态，一个用户态，却有四个等级，好奢侈、好富裕，于是就敞开了用。内核态运行在第0等级，用户态运行在第3等级，占了两头，中间的都不用，太不会过日子了。</p>
<p>大牛们在写Linux内核的时候，如果用户态程序做事情，就将扳手掰到第3等级，一旦要申请使用更多的资源，就需要申请将扳手掰到第0等级，内核才能在高权限访问这些资源，申请完资源，返回到用户态，扳手再掰回去。</p>
<p>这个程序一直非常顺利地运行着，直到虚拟机出现了。</p>
<h4 id="43-1-三种虚拟化方式"><a href="#43-1-三种虚拟化方式" class="headerlink" title="43.1 三种虚拟化方式"></a>43.1 三种虚拟化方式</h4><p>如果你安装VirtualBox桌面版，你可以用这个虚拟化软件创建虚拟机，在虚拟机里面安装一个Linux，外面的操作系统也可以是Linux。VirtualBox这个虚拟化软件，和你的Excel一样，都是在你的任务栏里面并排放着，是一个普通的应用。</p>
<p>当你进入虚拟机的时候，虚拟机里面的Excel也是一个普通的应用。</p>
<p>这个时候麻烦的事情出现了，当你设身处地地站在虚拟机的内核角度，去思考一下人生，你就会出现困惑了，会想，我到底是啥？</p>
<p>在硬件上的操作系统来看，我是一个普通的应用，只能运行在用户态。可是大牛们“生“我的时候，我的每一行代码都告诉我，我是个内核啊，应该运行在内核态。当虚拟机里面的Excel要访问网络的时候，向我请求，我的代码就要努力地去操作网卡。尽管我努力，但是我做不到啊，我没有权限！</p>
<p>我分裂了……</p>
<p>怎么办呢？虚拟化层，也就是Virtualbox会帮你解决这个问题，它有三种虚拟化的方式。</p>
<p>我们先来看第一种方式，<strong>完全虚拟化（Full virtualization）</strong>。其实说白了，这是一种“骗人”的方式。虚拟化软件会模拟假的CPU、内存、网络、硬盘给到我，让我自我感觉良好，感觉自己终于又像个内核了。</p>
<p>但是，真正的工作模式其实是下面这样的。</p>
<blockquote>
<p>虚拟机内核说：我要在CPU上跑一个指令！</p>
<p>虚拟化软件说：没问题，你是内核嘛，可以跑！</p>
<p>虚拟化软件转过头去找物理机内核说：报告，我管理的虚拟机里面的一个要执行一个CPU指令，帮忙来一小段时间空闲的CPU时间，让我代它跑个指令。</p>
<p>物理机内核说：你等着，另一个跑着呢。（过了一会儿）它跑完了，该你了。</p>
<p>虚拟化软件说：我代它跑，终于跑完了，出来结果了。</p>
<p>虚拟化软件转头给虚拟机内核说：哥们儿，跑完了，结果是这个。我说你是内核吧，绝对有权限，没问题，下次跑指令找我啊！</p>
<p>虚拟机内核说：看来我真的是内核呢，可是，哥，好像这点儿指令跑得有点慢啊！</p>
<p>虚拟化软件说：这就不错啦，好几个排着队跑呢！</p>
</blockquote>
<p>内存的申请模式是下面这样的。</p>
<blockquote>
<p>虚拟机内核说：我启动需要4G内存，我好分给我上面的应用。</p>
<p>虚拟化软件说：没问题，才4G，你是内核嘛，我马上申请好。</p>
<p>虚拟化软件转头给物理机内核说：报告，我启动了一个虚拟机，需要4G内存，给我4个房间呗。</p>
<p>物理机内核：怎么又一个虚拟机啊！好吧，给你90、91、92、93四个房间。</p>
<p>虚拟化软件转头给虚拟机内核说：哥们，内存有了，0、1、2、3这个四个房间都是你的。你看，你是内核嘛，独占资源，从0编号的就是你的。</p>
<p>虚拟机内核说：看来我真的是内核啊，能从头开始用。那好，我就在房间2的第三个柜子里面放个东西吧！</p>
<p>虚拟化软件说：要放东西啊，没问题。但是，它心里想：我查查看，这个虚拟机是90号房间开头的，它要在房间2放东西，那就相当于在房间92放东西。</p>
<p>虚拟化软件转头给物理机内核说：报告，我上面的虚拟机要在92号房间的第三个柜子里面放个东西。</p>
</blockquote>
<p>好了，说完了CPU和内存的例子，网络和硬盘就不细说了，情况也是类似的，都是虚拟化软件模拟一个给虚拟机内核看的，其实啥事儿都需要虚拟化软件转一遍。</p>
<p>这种方式一个坏处就是，慢，而且往往慢到不能忍受。</p>
<p>于是，虚拟化软件想，我能不能不当传话筒，要让虚拟机内核正视自己的身份。别说你是内核，你还真喘上了。你不是物理机，你是虚拟机！</p>
<p>但是，怎么解决权限等级的问题呢？于是，Intel的VT-x和AMD的AMD-V从硬件层面帮上了忙。当初谁让你们这些写内核的大牛用等级这么奢侈，用完了0，就是3，也不省着点儿用，没办法，只好另起炉灶弄一个新的标志位，表示当前是在虚拟机状态下，还是在真正的物理机内核下。</p>
<p>对于虚拟机内核来讲，只要将标志位设为虚拟机状态，我们就可以直接在CPU上执行大部分的指令，不需要虚拟化软件在中间转述，除非遇到特别敏感的指令，才需要将标志位设为物理机内核态运行，这样大大提高了效率。</p>
<p>所以，安装虚拟机的时候，我们务必要将物理CPU的这个标志位打开。想知道是否打开，对于Intel，你可以查看grep “vmx” /proc/cpuinfo；对于AMD，你可以查看grep “svm” /proc/cpuinfo</p>
<p>这叫作<strong>硬件辅助虚拟化（Hardware-Assisted Virtualization）</strong>。</p>
<p>另外就是访问网络或者硬盘的时候，为了取得更高的性能，也需要让虚拟机内核加载特殊的驱动，也是让虚拟机内核从代码层面就重新定位自己的身份，不能像访问物理机一样访问网络或者硬盘，而是用一种特殊的方式。</p>
<p>我知道我不是物理机内核，我知道我是虚拟机，我没那么高的权限，我很可能和很多虚拟机共享物理资源，所以我要学会排队，我写硬盘其实写的是一个物理机上的文件，那我的写文件的缓存方式是不是可以变一下。我发送网络包，根本就不是发给真正的网络设备，而是给虚拟的设备，我可不可以直接在内存里面拷贝给它，等等等等。</p>
<p>一旦我知道我不是物理机内核，痛定思痛，只好重新认识自己，反而能找出很多方式来优化我的资源访问。</p>
<p>这叫作<strong>半虚拟化（Paravirtualization）</strong>。</p>
<p>对于桌面虚拟化软件，我们多采用VirtualBox，如果使用服务器的虚拟化软件，则有另外的选型。</p>
<p>服务器上的虚拟化软件，多使用qemu，其中关键字emu，全称是emulator，模拟器。所以，单纯使用qemu，采用的是完全虚拟化的模式。</p>
<p>qemu向Guest OS模拟CPU，也模拟其他的硬件，GuestOS认为自己和硬件直接打交道，其实是同qemu模拟出来的硬件打交道，qemu会将这些指令转译给真正的硬件。由于所有的指令都要从qemu里面过一手，因而性能就会比较差。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/qemu的完全虚拟化.png" alt="qemu的完全虚拟化"></p>
<p>按照上面的介绍，完全虚拟化是非常慢的，所以要使用硬件辅助虚拟化技术Intel-VT，AMD-V，所以需要CPU硬件开启这个标志位，一般在BIOS里面设置。</p>
<p>当确认开始了标志位之后，通过KVM，GuestOS的CPU指令不用经过Qemu转译，直接运行，大大提高了速度。</p>
<p>所以，KVM在内核里面需要有一个模块，来设置当前CPU是Guest OS在用，还是Host OS在用。</p>
<p>下面，我们来查看内核模块中是否含有kvm, lsmod | grep kvm。</p>
<p>KVM内核模块通过/dev/kvm暴露接口，用户态程序可以通过ioctl来访问这个接口。例如，你可以通过下面的流程编写程序。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/使用kvm的流程.png" alt="使用kvm的流程"></p>
<p>Qemu将KVM整合进来，将有关CPU指令的部分交由内核模块来做，就是qemu-kvm (qemu-system-XXX)。</p>
<p>qemu和kvm整合之后，CPU的性能问题解决了。另外Qemu还会模拟其他的硬件，如网络和硬盘。同样，全虚拟化的方式也会影响这些设备的性能。</p>
<p>于是，qemu采取半虚拟化的方式，让Guest OS加载特殊的驱动来做这件事情。</p>
<p>例如，网络需要加载virtio_net，存储需要加载virtio_blk，Guest需要安装这些半虚拟化驱动，GuestOS知道自己是虚拟机，所以数据会直接发送给半虚拟化设备，经过特殊处理（例如排队、缓存、批量处理等性能优化方式），最终发送给真正的硬件。这在一定程度上提高了性能。</p>
<p>至此，整个关系如下图所示。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/qemu的半虚拟化.png" alt="qemu的半虚拟化"></p>
<h4 id="43-2-创建虚拟机"><a href="#43-2-创建虚拟机" class="headerlink" title="43.2 创建虚拟机"></a>43.2 创建虚拟机</h4><p>了解了qemu-kvm的工作原理之后，下面我们来看一下，如何使用qemu-kvm创建一个能够上网的虚拟机。</p>
<p>如果使用VirtualBox创建过虚拟机，通过界面点点就能创建一个能够上网的虚拟机。如果使用qemu-kvm，就没有这么简单了。一切都得自己来做，不过这个过程可以了解KVM虚拟机的创建原理。</p>
<p>首先，我们要给虚拟机起一个名字，在KVM里面就是-name ubuntutest。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/创建虚拟机一.png" alt="创建虚拟机一"></p>
<p>设置一个内存大小，在KVM里面就是-m 1024。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/创建虚拟机二.png" alt="创建虚拟机二"></p>
<p>创建一个虚拟硬盘，对于VirtualBox是VDI格式，对于KVM则不同。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/创建虚拟机三.png" alt="创建虚拟机三"></p>
<p>硬盘有两种格式，一个是动态分配，也即开始创建的时候，看起来很大，其实占用的空间很少，真实有多少数据，才真的占用多少空间。一个是固定大小，一开始就占用指定的大小。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/创建虚拟机四.png" alt="创建虚拟机四"></p>
<p>比如，我这台电脑，硬盘的大小为8G。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/创建虚拟机五.png" alt="创建虚拟机五"></p>
<p>在KVM中，创建一个虚拟机镜像，大小为8G，其中qcow2格式为动态分配，raw格式为固定大小。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">qemu-img create -f qcow2 ubuntutest.img 8G<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>我们将Ubuntu的ISO挂载为光盘，在KVM里面-cdrom ubuntu-xxx-server-amd64.iso</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/创建虚拟机六.png" alt="创建虚拟机六"></p>
<p>创建一个网络，有时候会选择桥接网络，有时候会选择NAT网络，这个在KVM里面只有自己配置了。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/创建虚拟机七.png" alt="创建虚拟机七"></p>
<p>接下来Virtualbox就会有一个界面，可以看到安装的整个过程，在KVM里面，我们用VNC来做。参数为-vnc :19</p>
<p>于是，我们也可以创建KVM虚拟机了，可以用下面的命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">qemu-system-x86_64 -enable-kvm-name ubuntutest  -m <span class="token number">2048</span> -hda ubuntutest.img -cdromubuntu-14.04-server-amd64.iso -boot d -vnc :19<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>启动了虚拟机后，连接VNC，我们也能看到安装的过程。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/创建虚拟机八.png" alt="创建虚拟机八"></p>
<p>按照普通安装Ubuntu的流程安装好Ubuntu，然后shutdown -h now，关闭虚拟机。</p>
<p>接下来，我们可以对KVM创建桥接网络了。这个要模拟virtualbox的桥接网络模式。</p>
<p>如果在桌面虚拟化软件上选择桥接网络，在你的笔记本电脑上，就会形成下面的结构。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/虚拟机网络结构一.png" alt="虚拟机网络结构一"></p>
<p>每个虚拟机都会有虚拟网卡，在你的笔记本电脑上，会发现多了几个网卡，其实是虚拟交换机。这个虚拟交换机将虚拟机连接在一起。在桥接模式下，物理网卡也连接到这个虚拟交换机上。物理网卡在桌面虚拟化软件的“界面名称”那里选定。</p>
<p>如果使用桥接网络，当你登录虚拟机里看IP地址时会发现，你的虚拟机的地址和你的笔记本电脑的地址，以及你旁边的同事的电脑的网段是一个网段。这是为什么呢？这其实相当于将物理机和虚拟机放在同一个网桥上，相当于这个网桥上有三台机器，是一个网段的，全部打平了。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/虚拟机网络结构二.png" alt="虚拟机网络结构二"></p>
<p>在数据中心里面，采取的也是类似的技术，连接方式如下图所示，只不过是Linux在每台机器上都创建网桥br0，虚拟机的网卡都连到br0上，物理网卡也连到br0上，所有的br0都通过物理网卡连接到物理交换机上。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/虚拟机网络结构三.png" alt="虚拟机网络结构三"></p>
<p>同样我们换一个角度看待这个拓扑图。同样是将网络打平，虚拟机会和物理网络具有相同的网段，就相当于两个虚拟交换机、一个物理交换机，一共三个交换机连在一起。两组四个虚拟机和两台物理机都是在一个二层网络里面的。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/虚拟机网络结构四.png" alt="虚拟机网络结构四"></p>
<p>qemu-kvm如何才能创建一个这样的桥接网络呢？</p>
<ol>
<li><p>在Host机器上创建bridge br0。</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brctl addbr br0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>将br0设为up。</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> br0 up<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>创建tap device。</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tunctl -b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>将tap0设为up。</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> tap0 up<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>将tap0加入到br0上。</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brctl addif br0 tap0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>启动虚拟机, 虚拟机连接tap0、tap0连接br0。</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">qemu-system-x86_64 -enable-kvm -name ubuntutest -m <span class="token number">2048</span> -hda ubuntutest.qcow2 -vnc :19 -net nic,model<span class="token operator">=</span>virtio -nettap,ifname<span class="token operator">=</span>tap0,script<span class="token operator">=</span>no,downscript<span class="token operator">=</span>no<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>虚拟机启动后，网卡没有配置，所以无法连接外网，先给br0设置一个ip。</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ifconfig</span> br0 <span class="token number">192.168</span>.57.1/24<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>VNC连上虚拟机，给网卡设置地址，重启虚拟机，可ping通br0。</p>
</li>
<li><p>要想访问外网，在Host上设置NAT，并且enable ip forwarding，可以ping通外网网关。</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ sysctl -p
net.ipv4.ip_forward <span class="token operator">=</span> <span class="token number">1</span>

$ <span class="token function">sudo</span> iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>如果DNS没配错，可以进行apt-get update。</li>
</ol>
<p>在这里，请记住qemu-system-x86_64的启动命令，这里面有CPU虚拟化KVM，有内存虚拟化、硬盘虚拟化、网络虚拟化。接下来的章节，我们会看内核是如何进行虚拟化的。</p>
<h4 id="43-3-总结"><a href="#43-3-总结" class="headerlink" title="43.3 总结"></a>43.3 总结</h4><p>理解虚拟机启动的参数就是理解虚拟化技术的入口。学会创建虚拟机，在后面做内核相关实验的时候就会非常方便。</p>
<p>具体到知识点上，这一节你需要需要记住下面的这些知识点：</p>
<ul>
<li>虚拟化的本质是用qemu的软件模拟硬件，但是模拟方式比较慢，需要加速；</li>
<li>虚拟化主要模拟CPU、内存、网络、存储，分别有不同的加速办法；</li>
<li>CPU和内存主要使用硬件辅助虚拟化进行加速，需要配备特殊的硬件才能工作；</li>
<li>网络和存储主要使用特殊的半虚拟化驱动加速，需要加载特殊的驱动程序。</li>
</ul>
<h3 id="44-计算虚拟化之CPU（上）"><a href="#44-计算虚拟化之CPU（上）" class="headerlink" title="44. 计算虚拟化之CPU（上）"></a>44. 计算虚拟化之CPU（上）</h3><p>上一节，我们讲了一下虚拟化的基本原理，以及qemu、kvm之间的关系。这一节，我们就来看一下，用户态的qemu和内核态的kvm如何一起协作，来创建虚拟机，实现CPU和内存虚拟化。</p>
<p>这里是上一节我们讲的qemu启动时候的命令。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">qemu-system-x86_64 -enable-kvm -name ubuntutest  -m <span class="token number">2048</span> -hda ubuntutest.qcow2 -vnc :19 -net nic,model<span class="token operator">=</span>virtio -nettap,ifname<span class="token operator">=</span>tap0,script<span class="token operator">=</span>no,downscript<span class="token operator">=</span>no<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>接下来，我们在<a target="_blank" rel="noopener" href="https://www.qemu.org/">这里</a>下载qemu的代码。qemu的main函数在vl.c下面。这是一个非常非常长的函数，我们来慢慢地解析它。</p>
<h4 id="44-1-初始化所有的Module"><a href="#44-1-初始化所有的Module" class="headerlink" title="44.1 初始化所有的Module"></a>44.1 初始化所有的Module</h4><p>第一步，初始化所有的Module，调用下面的函数。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">module_call_init</span><span class="token punctuation">(</span>MODULE_INIT_QOM<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>上一节我们讲过，qemu作为中间人其实挺累的，对上面的虚拟机需要模拟各种各样的外部设备。当虚拟机真的要使用物理资源的时候，对下面的物理机上的资源要进行请求，所以它的工作模式有点儿类似操作系统对接驱动。驱动要符合一定的格式，才能算操作系统的一个模块。同理，qemu为了模拟各种各样的设备，也需要管理各种各样的模块，这些模块也需要符合一定的格式。</p>
<p>定义一个qemu模块会调用type_init。例如，kvm的模块要在accel/kvm/kvm-all.c文件里面实现。在这个文件里面，有一行下面的代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">type_init</span><span class="token punctuation">(</span>kvm_type_init<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">type_init</span><span class="token punctuation">(</span>function<span class="token punctuation">)</span> <span class="token function">module_init</span><span class="token punctuation">(</span>function<span class="token punctuation">,</span> MODULE_INIT_QOM<span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">module_init</span><span class="token punctuation">(</span>function<span class="token punctuation">,</span> type<span class="token punctuation">)</span>                                         </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span>constructor<span class="token punctuation">)</span><span class="token punctuation">)</span> do_qemu_init_ </span><span class="token punctuation">##</span> <span class="token expression"><span class="token function">function</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>    </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">{</span>                                                                           </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token function">register_module_init</span><span class="token punctuation">(</span>function<span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span>                                   </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">}</span></span></span>

<span class="token keyword">void</span> <span class="token function">register_module_init</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>fn<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">,</span> module_init_type type<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    ModuleEntry <span class="token operator">*</span>e<span class="token punctuation">;</span>
    ModuleTypeList <span class="token operator">*</span>l<span class="token punctuation">;</span>

    e <span class="token operator">=</span> <span class="token function">g_malloc0</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    e<span class="token operator">-&gt;</span>init <span class="token operator">=</span> fn<span class="token punctuation">;</span>
    e<span class="token operator">-&gt;</span>type <span class="token operator">=</span> type<span class="token punctuation">;</span>

    l <span class="token operator">=</span> <span class="token function">find_type</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">QTAILQ_INSERT_TAIL</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> e<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从代码里面的定义我们可以看出来，type_init后面的参数是一个函数，调用type_init就相当于调用module_init，在这里函数就是kvm_type_init，类型就是MODULE_INIT_QOM。是不是感觉和驱动有点儿像？</p>
<p>module_init最终要调用register_module_init。属于MODULE_INIT_QOM这种类型的，有一个Module列表ModuleTypeList，列表里面是一项一项的ModuleEntry。KVM就是其中一项，并且会初始化每一项的init函数为参数表示的函数fn，也即KVM这个module的init函数就是kvm_type_init。</p>
<p>当然，MODULE_INIT_QOM这种类型会有很多很多的module，从后面的代码我们可以看到，所有调用type_init的地方都注册了一个MODULE_INIT_QOM类型的Module。</p>
<p>了解了Module的注册机制，我们继续回到main函数中module_call_init的调用。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">module_call_init</span><span class="token punctuation">(</span>module_init_type type<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    ModuleTypeList <span class="token operator">*</span>l<span class="token punctuation">;</span>
    ModuleEntry <span class="token operator">*</span>e<span class="token punctuation">;</span>
    l <span class="token operator">=</span> <span class="token function">find_type</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">QTAILQ_FOREACH</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> l<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        e<span class="token operator">-&gt;</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在module_call_init中，我们会找到MODULE_INIT_QOM这种类型对应的ModuleTypeList，找出列表中所有的ModuleEntry，然后调用每个ModuleEntry的init函数。这里需要注意的是，在module_call_init调用的这一步，所有Module的init函数都已经被调用过了。</p>
<p>后面我们会看到很多的Module，当你看到它们的时候，你需要意识到，它的init函数在这里也被调用过了。这里我们还是以对于kvm这个module为例子，看看它的init函数都做了哪些事情。你会发现，其实它调用的是kvm_type_init。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">kvm_type_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">type_register_static</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kvm_accel_type<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

TypeImpl <span class="token operator">*</span><span class="token function">type_register_static</span><span class="token punctuation">(</span><span class="token keyword">const</span> TypeInfo <span class="token operator">*</span>info<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">type_register</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

TypeImpl <span class="token operator">*</span><span class="token function">type_register</span><span class="token punctuation">(</span><span class="token keyword">const</span> TypeInfo <span class="token operator">*</span>info<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>info<span class="token operator">-&gt;</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">type_register_internal</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> TypeImpl <span class="token operator">*</span><span class="token function">type_register_internal</span><span class="token punctuation">(</span><span class="token keyword">const</span> TypeInfo <span class="token operator">*</span>info<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    TypeImpl <span class="token operator">*</span>ti<span class="token punctuation">;</span>
    ti <span class="token operator">=</span> <span class="token function">type_new</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">type_table_add</span><span class="token punctuation">(</span>ti<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> ti<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> TypeImpl <span class="token operator">*</span><span class="token function">type_new</span><span class="token punctuation">(</span><span class="token keyword">const</span> TypeInfo <span class="token operator">*</span>info<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    TypeImpl <span class="token operator">*</span>ti <span class="token operator">=</span> <span class="token function">g_malloc0</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>ti<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">type_table_lookup</span><span class="token punctuation">(</span>info<span class="token operator">-&gt;</span>name<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    ti<span class="token operator">-&gt;</span>name <span class="token operator">=</span> <span class="token function">g_strdup</span><span class="token punctuation">(</span>info<span class="token operator">-&gt;</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ti<span class="token operator">-&gt;</span>parent <span class="token operator">=</span> <span class="token function">g_strdup</span><span class="token punctuation">(</span>info<span class="token operator">-&gt;</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>

    ti<span class="token operator">-&gt;</span>class_size <span class="token operator">=</span> info<span class="token operator">-&gt;</span>class_size<span class="token punctuation">;</span>
    ti<span class="token operator">-&gt;</span>instance_size <span class="token operator">=</span> info<span class="token operator">-&gt;</span>instance_size<span class="token punctuation">;</span>

    ti<span class="token operator">-&gt;</span>class_init <span class="token operator">=</span> info<span class="token operator">-&gt;</span>class_init<span class="token punctuation">;</span>
    ti<span class="token operator">-&gt;</span>class_base_init <span class="token operator">=</span> info<span class="token operator">-&gt;</span>class_base_init<span class="token punctuation">;</span>
    ti<span class="token operator">-&gt;</span>class_data <span class="token operator">=</span> info<span class="token operator">-&gt;</span>class_data<span class="token punctuation">;</span>

    ti<span class="token operator">-&gt;</span>instance_init <span class="token operator">=</span> info<span class="token operator">-&gt;</span>instance_init<span class="token punctuation">;</span>
    ti<span class="token operator">-&gt;</span>instance_post_init <span class="token operator">=</span> info<span class="token operator">-&gt;</span>instance_post_init<span class="token punctuation">;</span>
    ti<span class="token operator">-&gt;</span>instance_finalize <span class="token operator">=</span> info<span class="token operator">-&gt;</span>instance_finalize<span class="token punctuation">;</span>

    ti<span class="token operator">-&gt;</span>abstract <span class="token operator">=</span> info<span class="token operator">-&gt;</span>abstract<span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> info<span class="token operator">-&gt;</span>interfaces <span class="token operator">&amp;&amp;</span> info<span class="token operator">-&gt;</span>interfaces<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>type<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ti<span class="token operator">-&gt;</span>interfaces<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>typename <span class="token operator">=</span> <span class="token function">g_strdup</span><span class="token punctuation">(</span>info<span class="token operator">-&gt;</span>interfaces<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    ti<span class="token operator">-&gt;</span>num_interfaces <span class="token operator">=</span> i<span class="token punctuation">;</span>

    <span class="token keyword">return</span> ti<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">type_table_add</span><span class="token punctuation">(</span>TypeImpl <span class="token operator">*</span>ti<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">!</span>enumerating_types<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">g_hash_table_insert</span><span class="token punctuation">(</span><span class="token function">type_table_get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>ti<span class="token operator">-&gt;</span>name<span class="token punctuation">,</span> ti<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> GHashTable <span class="token operator">*</span><span class="token function">type_table_get</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">static</span> GHashTable <span class="token operator">*</span>type_table<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>type_table <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        type_table <span class="token operator">=</span> <span class="token function">g_hash_table_new</span><span class="token punctuation">(</span>g_str_hash<span class="token punctuation">,</span> g_str_equal<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> type_table<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">const</span> TypeInfo kvm_accel_type <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>name <span class="token operator">=</span> TYPE_KVM_ACCEL<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>parent <span class="token operator">=</span> TYPE_ACCEL<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>class_init <span class="token operator">=</span> kvm_accel_class_init<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>instance_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>KVMState<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>每一个Module既然要模拟某种设备，那应该定义一种类型TypeImpl来表示这些设备，这其实是一种面向对象编程的思路，只不过这里用的是纯C语言的实现，所以需要变相实现一下类和对象。</p>
<p>kvm_type_init会注册kvm_accel_type，定义上面的代码，我们可以认为这样动态定义了一个类。这个类的名字是TYPE_KVM_ACCEL，这个类有父类TYPE_ACCEL，这个类的初始化应该调用函数kvm_accel_class_init（看，这里已经直接叫类class了）。如果用这个类声明一个对象，对象的大小应该是instance_size。是不是有点儿Java语言反射的意思，根据一些名称的定义，一个类就定义好了。</p>
<p>这里的调用链为：kvm_type_init-&gt;type_register_static-&gt;type_register-&gt;type_register_internal。</p>
<p>在type_register_internal中，我们会根据kvm_accel_type这个TypeInfo，创建一个TypeImpl来表示这个新注册的类，也就是说，TypeImpl才是我们想要声明的那个class。在qemu里面，有一个全局的哈希表type_table，用来存放所有定义的类。在type_new里面，我们先从全局表里面根据名字找这个类。如果找到，说明这个类曾经被注册过，就报错；如果没有找到，说明这是一个新的类，则将TypeInfo里面信息填到TypeImpl里面。type_table_add会将这个类注册到全局的表里面。到这里，我们注意，class_init还没有被调用，也即这个类现在还处于纸面的状态。</p>
<p>这点更加像Java的反射机制了。在Java里面，对于一个类，首先我们写代码的时候要写一个class xxx的定义，编译好就放在.class文件中，这也是出于纸面的状态。然后，Java会有一个Class对象，用于读取和表示这个纸面上的class xxx，可以生成真正的对象。</p>
<p>相同的过程在后面的代码中我们也可以看到，class_init会生成XXXClass，就相当于Java里面的Class对象，TypeImpl还会有一个instance_init函数，相当于构造函数，用于根据XXXClass生成Object，这就相当于Java反射里面最终创建的对象。和构造函数对应的还有instance_finalize，相当于析构函数。</p>
<p>这一套反射机制放在qom文件夹下面，全称QEMU Object Model，也即用C实现了一套面向对象的反射机制。</p>
<p>说完了初始化Module，我们还回到main函数接着分析。</p>
<h4 id="44-2-解析qemu的命令行"><a href="#44-2-解析qemu的命令行" class="headerlink" title="44.2 解析qemu的命令行"></a>44.2 解析qemu的命令行</h4><p>第二步我们就要开始解析qemu的命令行了。qemu的命令行解析，就是下面这样一长串。还记得咱们自己写过一个解析命令行参数的程序吗？这里的opts是差不多的意思。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">qemu_add_opts</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>qemu_drive_opts<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">qemu_add_opts</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>qemu_chardev_opts<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">qemu_add_opts</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>qemu_device_opts<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">qemu_add_opts</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>qemu_netdev_opts<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">qemu_add_opts</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>qemu_nic_opts<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">qemu_add_opts</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>qemu_net_opts<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">qemu_add_opts</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>qemu_rtc_opts<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">qemu_add_opts</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>qemu_machine_opts<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">qemu_add_opts</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>qemu_accel_opts<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">qemu_add_opts</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>qemu_mem_opts<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">qemu_add_opts</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>qemu_smp_opts<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">qemu_add_opts</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>qemu_boot_opts<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">qemu_add_opts</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>qemu_name_opts<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">qemu_add_opts</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>qemu_numa_opts<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为什么有这么多的opts呢？这是因为，我们上一节给的参数都是简单的参数，实际运行中创建的kvm参数会复杂N倍。这里我们贴一个开源云平台软件OpenStack创建出来的KVM的参数，如下所示。不要被吓坏，你不需要全部看懂，只需要看懂一部分就行了。具体我来给你解析。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">qemu-system-x86_64
-enable-kvm
-name instance-00000024
-machine pc-i440fx-trusty,accel<span class="token operator">=</span>kvm,usb<span class="token operator">=</span>off
-cpu SandyBridge,+erms,+smep,+fsgsbase,+pdpe1gb,+rdrand,+f16c,+osxsave,+dca,+pcid,+pdcm,+xtpr,+tm2,+est,+smx,+vmx,+ds_cpl,+monitor,+dtes64,+pbe,+tm,+ht,+ss,+acpi,+ds,+vme
-m <span class="token number">2048</span>
-smp <span class="token number">1</span>,sockets<span class="token operator">=</span><span class="token number">1</span>,cores<span class="token operator">=</span><span class="token number">1</span>,threads<span class="token operator">=</span><span class="token number">1</span>
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
-rtc <span class="token assign-left variable">base</span><span class="token operator">=</span>utc,driftfix<span class="token operator">=</span>slew
-drive <span class="token assign-left variable">file</span><span class="token operator">=</span>/var/lib/nova/instances/1f8e6f7e-5a70-4780-89c1-464dc0e7f308/disk,if<span class="token operator">=</span>none,id<span class="token operator">=</span>drive-virtio-disk0,format<span class="token operator">=</span>qcow2,cache<span class="token operator">=</span>none
-device virtio-blk-pci,scsi<span class="token operator">=</span>off,bus<span class="token operator">=</span>pci.0,addr<span class="token operator">=</span>0x4,drive<span class="token operator">=</span>drive-virtio-disk0,id<span class="token operator">=</span>virtio-disk0,bootindex<span class="token operator">=</span><span class="token number">1</span>
-netdev tap,fd<span class="token operator">=</span><span class="token number">32</span>,id<span class="token operator">=</span>hostnet0,vhost<span class="token operator">=</span>on,vhostfd<span class="token operator">=</span><span class="token number">37</span>
-device virtio-net-pci,netdev<span class="token operator">=</span>hostnet0,id<span class="token operator">=</span>net0,mac<span class="token operator">=</span>fa:16:3e:d1:2d:99,bus<span class="token operator">=</span>pci.0,addr<span class="token operator">=</span>0x3
-chardev file,id<span class="token operator">=</span>charserial0,path<span class="token operator">=</span>/var/lib/nova/instances/1f8e6f7e-5a70-4780-89c1-464dc0e7f308/console.log
-vnc <span class="token number">0.0</span>.0.0:12
-device cirrus-vga,id<span class="token operator">=</span>video0,bus<span class="token operator">=</span>pci.0,addr<span class="token operator">=</span>0x2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>-enable-kvm：表示启用硬件辅助虚拟化。</li>
<li>-name instance-00000024：表示虚拟机的名称。</li>
<li>-machine pc-i440fx-trusty,accel=kvm,usb=off：machine是什么呢？其实就是计算机体系结构。不知道什么是体系结构的话，可以订阅极客时间的另一个专栏《深入浅出计算机组成原理》。qemu会模拟多种体系结构，常用的有普通PC机，也即x86的32位或者64位的体系结构、Mac电脑PowerPC的体系结构、Sun的体系结构、MIPS的体系结构，精简指令集。如果使用KVM hardware-assisted virtualization，也即BIOS中VD-T是打开的，则参数中accel=kvm。如果不使用hardware-assisted virtualization，用的是纯模拟，则有参数accel = tcg，-no-kvm。</li>
<li>-cpu SandyBridge,+erms,+smep,+fsgsbase,+pdpe1gb,+rdrand,+f16c,+osxsave,+dca,+pcid,+pdcm,+xtpr,+tm2,+est,+smx,+vmx,+ds_cpl,+monitor,+dtes64,+pbe,+tm,+ht,+ss,+acpi,+ds,+vme：表示设置CPU，SandyBridge是Intel处理器，后面的加号都是添加的CPU的参数，这些参数会显示在/proc/cpuinfo里面。</li>
<li>-m 2048：表示内存。</li>
<li>-smp 1,sockets=1,cores=1,threads=1：SMP我们解析过，叫对称多处理器，和NUMA对应。qemu仿真了一个具有1个vcpu，一个socket，一个core，一个threads的处理器。socket、core、threads是什么概念呢？socket就是主板上插cpu的槽的数目，也即常说的“路”，core就是我们平时说的“核”，即双核、4核等。thread就是每个core的硬件线程数，即超线程。举个具体的例子，某个服务器是：2路4核超线程（一般默认为2个线程），通过cat /proc/cpuinfo，我们看到的是242=16个processor，很多人也习惯成为16核了。</li>
<li>-rtc base=utc,driftfix=slew：表示系统时间由参数-rtc指定。</li>
<li>-device cirrus-vga,id=video0,bus=pci.0,addr=0x2：表示显示器用参数-vga设置，默认为cirrus，它模拟了CL-GD5446PCI VGA card。</li>
<li>有关网卡，使用-net参数和-device。</li>
<li>从HOST角度：-netdev tap,fd=32,id=hostnet0,vhost=on,vhostfd=37。</li>
<li>从GUEST角度：-device virtio-net-pci,netdev=hostnet0,id=net0,mac=fa:16:3e:d1:2d:99,bus=pci.0,addr=0x3。</li>
<li>有关硬盘，使用-hda -hdb，或者使用-drive和-device。</li>
<li>从HOST角度：-drive file=/var/lib/nova/instances/1f8e6f7e-5a70-4780-89c1-464dc0e7f308/disk,if=none,id=drive-virtio-disk0,format=qcow2,cache=none</li>
<li>从GUEST角度：-device virtio-blk-pci,scsi=off,bus=pci.0,addr=0x4,drive=drive-virtio-disk0,id=virtio-disk0,bootindex=1</li>
<li>-vnc 0.0.0.0:12：设置VNC。</li>
</ul>
<p>在main函数中，接下来的for循环和大量的switch case语句，就是对于这些参数的解析，我们不一一解析，后面真的用到这些参数的时候，我们再仔细看。</p>
<h4 id="44-3-初始化machine"><a href="#44-3-初始化machine" class="headerlink" title="44.3 初始化machine"></a>44.3 初始化machine</h4><p>回到main函数，接下来是初始化machine。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">machine_class <span class="token operator">=</span> <span class="token function">select_machine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
current_machine <span class="token operator">=</span> <span class="token function">MACHINE</span><span class="token punctuation">(</span><span class="token function">object_new</span><span class="token punctuation">(</span><span class="token function">object_class_get_name</span><span class="token punctuation">(</span>
                          <span class="token function">OBJECT_CLASS</span><span class="token punctuation">(</span>machine_class<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这里面的machine_class是什么呢？这还得从machine参数说起。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-machine pc-i440fx-trusty,accel<span class="token operator">=</span>kvm,usb<span class="token operator">=</span>off<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这里的pc-i440fx是x86机器默认的体系结构。在hw/i386/pc_piix.c中，它定义了对应的machine_class。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">DEFINE_I440FX_MACHINE</span><span class="token punctuation">(</span>v4_0<span class="token punctuation">,</span> <span class="token string">"pc-i440fx-4.0"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span>
                      pc_i440fx_4_0_machine_options<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">DEFINE_I440FX_MACHINE</span><span class="token punctuation">(</span>suffix<span class="token punctuation">,</span> name<span class="token punctuation">,</span> compatfn<span class="token punctuation">,</span> optionfn<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">static</span> <span class="token keyword">void</span> pc_init_</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">suffix</span><span class="token punctuation">(</span>MachineState <span class="token operator">*</span>machine<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">{</span> </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span></span>
        <span class="token function">pc_init1</span><span class="token punctuation">(</span>machine<span class="token punctuation">,</span> TYPE_I440FX_PCI_HOST_BRIDGE<span class="token punctuation">,</span> \
                 TYPE_I440FX_PCI_DEVICE<span class="token punctuation">)</span><span class="token punctuation">;</span> \
    <span class="token punctuation">}</span> \
    <span class="token function">DEFINE_PC_MACHINE</span><span class="token punctuation">(</span>suffix<span class="token punctuation">,</span> name<span class="token punctuation">,</span> pc_init_##suffix<span class="token punctuation">,</span> optionfn<span class="token punctuation">)</span>


<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">DEFINE_PC_MACHINE</span><span class="token punctuation">(</span>suffix<span class="token punctuation">,</span> namestr<span class="token punctuation">,</span> initfn<span class="token punctuation">,</span> optsfn<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">static</span> <span class="token keyword">void</span> pc_machine_</span><span class="token punctuation">##</span><span class="token expression">suffix</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">_class_init</span><span class="token punctuation">(</span>ObjectClass <span class="token operator">*</span>oc<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>data</span></span>
<span class="token punctuation">)</span> \
    <span class="token punctuation">{</span> \
        MachineClass <span class="token operator">*</span>mc <span class="token operator">=</span> <span class="token function">MACHINE_CLASS</span><span class="token punctuation">(</span>oc<span class="token punctuation">)</span><span class="token punctuation">;</span> \
        <span class="token function">optsfn</span><span class="token punctuation">(</span>mc<span class="token punctuation">)</span><span class="token punctuation">;</span> \
        mc<span class="token operator">-&gt;</span>init <span class="token operator">=</span> initfn<span class="token punctuation">;</span> \
    <span class="token punctuation">}</span> \
    <span class="token keyword">static</span> <span class="token keyword">const</span> TypeInfo pc_machine_type_##suffix <span class="token operator">=</span> <span class="token punctuation">{</span> \
        <span class="token punctuation">.</span>name       <span class="token operator">=</span> namestr TYPE_MACHINE_SUFFIX<span class="token punctuation">,</span> \
        <span class="token punctuation">.</span>parent     <span class="token operator">=</span> TYPE_PC_MACHINE<span class="token punctuation">,</span> \
        <span class="token punctuation">.</span>class_init <span class="token operator">=</span> pc_machine_##suffix##_class_init<span class="token punctuation">,</span> \
    <span class="token punctuation">}</span><span class="token punctuation">;</span> \
    <span class="token keyword">static</span> <span class="token keyword">void</span> pc_machine_init_##<span class="token function">suffix</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> \
    <span class="token punctuation">{</span> \
        <span class="token function">type_register</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pc_machine_type_##suffix<span class="token punctuation">)</span><span class="token punctuation">;</span> \
    <span class="token punctuation">}</span> \
    <span class="token function">type_init</span><span class="token punctuation">(</span>pc_machine_init_##suffix<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了定义machine_class，这里有一系列的宏定义。入口是DEFINE_I440FX_MACHINE。这个宏有几个参数，v4_0是后缀，”pc-i440fx-4.0”是名字，pc_i440fx_4_0_machine_options是一个函数，用于定义machine_class相关的选项。这个函数定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">pc_i440fx_4_0_machine_options</span><span class="token punctuation">(</span>MachineClass <span class="token operator">*</span>m<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">pc_i440fx_machine_options</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
    m<span class="token operator">-&gt;</span>alias <span class="token operator">=</span> <span class="token string">"pc"</span><span class="token punctuation">;</span>
    m<span class="token operator">-&gt;</span>is_default <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">pc_i440fx_machine_options</span><span class="token punctuation">(</span>MachineClass <span class="token operator">*</span>m<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    PCMachineClass <span class="token operator">*</span>pcmc <span class="token operator">=</span> <span class="token function">PC_MACHINE_CLASS</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
    pcmc<span class="token operator">-&gt;</span>default_nic_model <span class="token operator">=</span> <span class="token string">"e1000"</span><span class="token punctuation">;</span>

    m<span class="token operator">-&gt;</span>family <span class="token operator">=</span> <span class="token string">"pc_piix"</span><span class="token punctuation">;</span>
    m<span class="token operator">-&gt;</span>desc <span class="token operator">=</span> <span class="token string">"Standard PC (i440FX + PIIX, 1996)"</span><span class="token punctuation">;</span>
    m<span class="token operator">-&gt;</span>default_machine_opts <span class="token operator">=</span> <span class="token string">"firmware=bios-256k.bin"</span><span class="token punctuation">;</span>
    m<span class="token operator">-&gt;</span>default_display <span class="token operator">=</span> <span class="token string">"std"</span><span class="token punctuation">;</span>
    <span class="token function">machine_class_allow_dynamic_sysbus_dev</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> TYPE_RAMFB_DEVICE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们先不看pc_i440fx_4_0_machine_options，先来看DEFINE_I440FX_MACHINE。</p>
<p>这里面定义了一个pc_init_##suffix，也就是pc_init_v4_0。这里面转而调用pc_init1。注意这里这个函数只是定义了一下，没有被调用。</p>
<p>接下来，DEFINE_I440FX_MACHINE里面又定义了DEFINE_PC_MACHINE。它有四个参数，除了DEFINE_I440FX_MACHINE传进来的三个参数以外，多了一个initfn，也即初始化函数，指向刚才定义的pc_init_##suffix。</p>
<p>在DEFINE_PC_MACHINE中，我们定义了一个函数pc_machine_##suffix##class_init。从函数的名字class_init可以看出，这是machine_class从纸面上的class初始化为Class对象的方法。在这个函数里面，我们可以看到，它创建了一个MachineClass对象，这个就是Class对象。MachineClass对象的init函数指向上面定义的pc_init##suffix，说明这个函数是machine这种类型初始化的一个函数，后面会被调用。</p>
<p>接着，我们看DEFINE_PC_MACHINE。它定义了一个pc_machine_type_##suffix的TypeInfo。这是用于生成纸面上的class的原材料，果真后面调用了type_init。</p>
<p>看到了type_init，我们应该能够想到，既然它定义了一个纸面上的class，那上面的那句module_call_init，会和我们上面解析的type_init是一样的，在全局的表里面注册了一个全局的名字是”pc-i440fx-4.0”的纸面上的class，也即TypeImpl。</p>
<p>现在全局表中有这个纸面上的class了。我们回到select_machine。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> MachineClass <span class="token operator">*</span><span class="token function">select_machine</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    MachineClass <span class="token operator">*</span>machine_class <span class="token operator">=</span> <span class="token function">find_default_machine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>optarg<span class="token punctuation">;</span>
    QemuOpts <span class="token operator">*</span>opts<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    opts <span class="token operator">=</span> <span class="token function">qemu_get_machine_opts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">qemu_opts_loc_restore</span><span class="token punctuation">(</span>opts<span class="token punctuation">)</span><span class="token punctuation">;</span>

    optarg <span class="token operator">=</span> <span class="token function">qemu_opt_get</span><span class="token punctuation">(</span>opts<span class="token punctuation">,</span> <span class="token string">"type"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>optarg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        machine_class <span class="token operator">=</span> <span class="token function">machine_parse</span><span class="token punctuation">(</span>optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> machine_class<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

MachineClass <span class="token operator">*</span><span class="token function">find_default_machine</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    GSList <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token operator">*</span>machines <span class="token operator">=</span> <span class="token function">object_class_get_list</span><span class="token punctuation">(</span>TYPE_MACHINE<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span>
    MachineClass <span class="token operator">*</span>mc <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>el <span class="token operator">=</span> machines<span class="token punctuation">;</span> el<span class="token punctuation">;</span> el <span class="token operator">=</span> el<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        MachineClass <span class="token operator">*</span>temp <span class="token operator">=</span> el<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>temp<span class="token operator">-&gt;</span>is_default<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            mc <span class="token operator">=</span> temp<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">g_slist_free</span><span class="token punctuation">(</span>machines<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> mc<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> MachineClass <span class="token operator">*</span><span class="token function">machine_parse</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    MachineClass <span class="token operator">*</span>mc <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    GSList <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token operator">*</span>machines <span class="token operator">=</span> <span class="token function">object_class_get_list</span><span class="token punctuation">(</span>TYPE_MACHINE<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        mc <span class="token operator">=</span> <span class="token function">find_machine</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">g_slist_free</span><span class="token punctuation">(</span>machines<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> mc<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在select_machine中，有两种方式可以生成MachineClass。一种方式是find_default_machine，找一个默认的；另一种方式是machine_parse，通过解析参数生成MachineClass。无论哪种方式，都会调用object_class_get_list获得一个MachineClass的列表，然后在里面找。object_class_get_list定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">GSList <span class="token operator">*</span><span class="token function">object_class_get_list</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>implements_type<span class="token punctuation">,</span>
                              bool include_abstract<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    GSList <span class="token operator">*</span>list <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

    <span class="token function">object_class_foreach</span><span class="token punctuation">(</span>object_class_get_list_tramp<span class="token punctuation">,</span>
                         implements_type<span class="token punctuation">,</span> include_abstract<span class="token punctuation">,</span> <span class="token operator">&amp;</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> list<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">object_class_foreach</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>fn<span class="token punctuation">)</span><span class="token punctuation">(</span>ObjectClass <span class="token operator">*</span>klass<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>opaque<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>implements_type<span class="token punctuation">,</span> bool include_abstract<span class="token punctuation">,</span>
                          <span class="token keyword">void</span> <span class="token operator">*</span>opaque<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    OCFData data <span class="token operator">=</span> <span class="token punctuation">{</span> fn<span class="token punctuation">,</span> implements_type<span class="token punctuation">,</span> include_abstract<span class="token punctuation">,</span> opaque <span class="token punctuation">}</span><span class="token punctuation">;</span>

    enumerating_types <span class="token operator">=</span> true<span class="token punctuation">;</span>
    <span class="token function">g_hash_table_foreach</span><span class="token punctuation">(</span><span class="token function">type_table_get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> object_class_foreach_tramp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    enumerating_types <span class="token operator">=</span> false<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在全局表type_table_get()中，对于每一项TypeImpl，我们都执行object_class_foreach_tramp。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">object_class_foreach_tramp</span><span class="token punctuation">(</span>gpointer key<span class="token punctuation">,</span> gpointer value<span class="token punctuation">,</span>
                                       gpointer opaque<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    OCFData <span class="token operator">*</span>data <span class="token operator">=</span> opaque<span class="token punctuation">;</span>
    TypeImpl <span class="token operator">*</span>type <span class="token operator">=</span> value<span class="token punctuation">;</span>
    ObjectClass <span class="token operator">*</span>k<span class="token punctuation">;</span>

    <span class="token function">type_initialize</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
    k <span class="token operator">=</span> type<span class="token operator">-&gt;</span>class<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    data<span class="token operator">-&gt;</span><span class="token function">fn</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> data<span class="token operator">-&gt;</span>opaque<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">type_initialize</span><span class="token punctuation">(</span>TypeImpl <span class="token operator">*</span>ti<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    TypeImpl <span class="token operator">*</span>parent<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    ti<span class="token operator">-&gt;</span>class_size <span class="token operator">=</span> <span class="token function">type_class_get_size</span><span class="token punctuation">(</span>ti<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ti<span class="token operator">-&gt;</span>instance_size <span class="token operator">=</span> <span class="token function">type_object_get_size</span><span class="token punctuation">(</span>ti<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ti<span class="token operator">-&gt;</span>instance_size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ti<span class="token operator">-&gt;</span>abstract <span class="token operator">=</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    ti<span class="token operator">-&gt;</span>class <span class="token operator">=</span> <span class="token function">g_malloc0</span><span class="token punctuation">(</span>ti<span class="token operator">-&gt;</span>class_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    ti<span class="token operator">-&gt;</span>class<span class="token operator">-&gt;</span>type <span class="token operator">=</span> ti<span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-&gt;</span>class_base_init<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            parent<span class="token operator">-&gt;</span><span class="token function">class_base_init</span><span class="token punctuation">(</span>ti<span class="token operator">-&gt;</span>class<span class="token punctuation">,</span> ti<span class="token operator">-&gt;</span>class_data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        parent <span class="token operator">=</span> <span class="token function">type_get_parent</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>ti<span class="token operator">-&gt;</span>class_init<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ti<span class="token operator">-&gt;</span><span class="token function">class_init</span><span class="token punctuation">(</span>ti<span class="token operator">-&gt;</span>class<span class="token punctuation">,</span> ti<span class="token operator">-&gt;</span>class_data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在object_class_foreach_tramp中，会调用将type_initialize，这里面会调用class_init将纸面上的class也即TypeImpl变为ObjectClass，ObjectClass是所有Class类的祖先，MachineClass是它的子类。</p>
<p>因为在machine的命令行里面，我们指定了名字为”pc-i440fx-4.0”，就肯定能够找到我们注册过了的TypeImpl，并调用它的class_init函数。</p>
<p>因而pc_machine_##suffix##class_init会被调用，在这里面，pc_i440fx_machine_options才真正被调用初始化MachineClass，并且将MachineClass的init函数设置为pc_init##suffix。也即，当select_machine执行完毕后，就有一个MachineClass了。</p>
<p>接着，我们回到object_new。这就很好理解了，MachineClass是一个Class类，接下来应该通过它生成一个Instance，也即对象，这就是object_new的作用。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">Object <span class="token operator">*</span><span class="token function">object_new</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>typename<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    TypeImpl <span class="token operator">*</span>ti <span class="token operator">=</span> <span class="token function">type_get_by_name</span><span class="token punctuation">(</span>typename<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token function">object_new_with_type</span><span class="token punctuation">(</span>ti<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> Object <span class="token operator">*</span><span class="token function">object_new_with_type</span><span class="token punctuation">(</span>Type type<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Object <span class="token operator">*</span>obj<span class="token punctuation">;</span>
    <span class="token function">type_initialize</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
    obj <span class="token operator">=</span> <span class="token function">g_malloc</span><span class="token punctuation">(</span>type<span class="token operator">-&gt;</span>instance_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">object_initialize_with_type</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> type<span class="token operator">-&gt;</span>instance_size<span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span>
    obj<span class="token operator">-&gt;</span>free <span class="token operator">=</span> g_free<span class="token punctuation">;</span>

    <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>object_new中，TypeImpl的instance_init会被调用，创建一个对象。current_machine就是这个对象，它的类型是MachineState。</p>
<p>至此，绕了这么大一圈，有关体系结构的对象才创建完毕，接下来很多的设备的初始化，包括CPU和内存的初始化，都是围绕着体系结构的对象来的，后面我们会常常看到current_machine。</p>
<h4 id="44-4-总结"><a href="#44-4-总结" class="headerlink" title="44.4 总结"></a>44.4 总结</h4><p>这一节，我们学到，虚拟机对于设备的模拟是一件非常复杂的事情，需要用复杂的参数模拟各种各样的设备。为了能够适配这些设备，qemu定义了自己的模块管理机制，只有了解了这种机制，后面看每一种设备的虚拟化的时候，才有一个整体的思路。</p>
<p>这里的MachineClass是我们遇到的第一个，我们需要掌握它里面各种定义之间的关系。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/MachineClass与其他定义之间的关系.png" alt="MachineClass与其他定义之间的关系"></p>
<p>每个模块都会有一个定义TypeInfo，会通过type_init变为全局的TypeImpl。TypeInfo以及生成的TypeImpl有以下成员：</p>
<ul>
<li>name表示当前类型的名称</li>
<li>parent表示父类的名称</li>
<li>class_init用于将TypeImpl初始化为MachineClass</li>
<li>instance_init用于将MachineClass初始化为MachineState</li>
</ul>
<p>所以，以后遇到任何一个类型的时候，将父类和子类之间的关系，以及对应的初始化函数都要看好，这样就一目了然了。</p>
<h3 id="45-计算虚拟化之CPU（下）"><a href="#45-计算虚拟化之CPU（下）" class="headerlink" title="45. 计算虚拟化之CPU（下）"></a>45. 计算虚拟化之CPU（下）</h3><p>上一节qemu初始化的main函数，我们解析了一个开头，得到了表示体系结构的MachineClass以及MachineState。</p>
<h4 id="45-1-初始化块设备"><a href="#45-1-初始化块设备" class="headerlink" title="45.1 初始化块设备"></a>45.1 初始化块设备</h4><p>我们接着回到main函数，接下来初始化的是块设备，调用的是configure_blockdev。这里我们需要重点关注上面参数中的硬盘，不过我们放在存储虚拟化那一节再解析。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">configure_blockdev</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bdo_queue<span class="token punctuation">,</span> machine_class<span class="token punctuation">,</span> snapshot<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="45-2-初始化计算虚拟化的加速模式"><a href="#45-2-初始化计算虚拟化的加速模式" class="headerlink" title="45.2 初始化计算虚拟化的加速模式"></a>45.2 初始化计算虚拟化的加速模式</h4><p>接下来初始化的是计算虚拟化的加速模式，也即要不要使用KVM。根据参数中的配置是启用KVM。这里调用的是configure_accelerator。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">configure_accelerator</span><span class="token punctuation">(</span>current_machine<span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">configure_accelerator</span><span class="token punctuation">(</span>MachineState <span class="token operator">*</span>ms<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>progname<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>accel<span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>accel_list<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token operator">*</span>tmp<span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
    bool accel_initialised <span class="token operator">=</span> false<span class="token punctuation">;</span>
    bool init_failed <span class="token operator">=</span> false<span class="token punctuation">;</span>
    AccelClass <span class="token operator">*</span>acc <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

    accel <span class="token operator">=</span> <span class="token function">qemu_opt_get</span><span class="token punctuation">(</span><span class="token function">qemu_get_machine_opts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"accel"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    accel <span class="token operator">=</span> <span class="token string">"kvm"</span><span class="token punctuation">;</span>
    accel_list <span class="token operator">=</span> <span class="token function">g_strsplit</span><span class="token punctuation">(</span>accel<span class="token punctuation">,</span> <span class="token string">":"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>tmp <span class="token operator">=</span> accel_list<span class="token punctuation">;</span> <span class="token operator">!</span>accel_initialised <span class="token operator">&amp;&amp;</span> tmp <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>tmp<span class="token punctuation">;</span> tmp<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        acc <span class="token operator">=</span> <span class="token function">accel_find</span><span class="token punctuation">(</span><span class="token operator">*</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        ret <span class="token operator">=</span> <span class="token function">accel_init_machine</span><span class="token punctuation">(</span>acc<span class="token punctuation">,</span> ms<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> AccelClass <span class="token operator">*</span><span class="token function">accel_find</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>opt_name<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>class_name <span class="token operator">=</span> <span class="token function">g_strdup_printf</span><span class="token punctuation">(</span><span class="token function">ACCEL_CLASS_NAME</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> opt_name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    AccelClass <span class="token operator">*</span>ac <span class="token operator">=</span> <span class="token function">ACCEL_CLASS</span><span class="token punctuation">(</span><span class="token function">object_class_by_name</span><span class="token punctuation">(</span>class_name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">g_free</span><span class="token punctuation">(</span>class_name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> ac<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">accel_init_machine</span><span class="token punctuation">(</span>AccelClass <span class="token operator">*</span>acc<span class="token punctuation">,</span> MachineState <span class="token operator">*</span>ms<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    ObjectClass <span class="token operator">*</span>oc <span class="token operator">=</span> <span class="token function">OBJECT_CLASS</span><span class="token punctuation">(</span>acc<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>cname <span class="token operator">=</span> <span class="token function">object_class_get_name</span><span class="token punctuation">(</span>oc<span class="token punctuation">)</span><span class="token punctuation">;</span>
    AccelState <span class="token operator">*</span>accel <span class="token operator">=</span> <span class="token function">ACCEL</span><span class="token punctuation">(</span><span class="token function">object_new</span><span class="token punctuation">(</span>cname<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
    ms<span class="token operator">-&gt;</span>accelerator <span class="token operator">=</span> accel<span class="token punctuation">;</span>
    <span class="token operator">*</span><span class="token punctuation">(</span>acc<span class="token operator">-&gt;</span>allowed<span class="token punctuation">)</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>
    ret <span class="token operator">=</span> acc<span class="token operator">-&gt;</span><span class="token function">init_machine</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在configure_accelerator中，我们看命令行参数里面的accel，发现是kvm，则调用accel_find根据名字，得到相应的纸面上的class，并初始化为Class类。</p>
<p>MachineClass是计算机体系结构的Class类，同理，AccelClass就是加速器的Class类，然后调用accel_init_machine，通过object_new，将AccelClass这个Class类实例化为AccelState，类似对于体系结构的实例是MachineState。</p>
<p>在accel_find中，我们会根据名字kvm，找到纸面上的class，也即kvm_accel_type，然后调用type_initialize，里面调用kvm_accel_type的class_init方法，也即kvm_accel_class_init。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">kvm_accel_class_init</span><span class="token punctuation">(</span>ObjectClass <span class="token operator">*</span>oc<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    AccelClass <span class="token operator">*</span>ac <span class="token operator">=</span> <span class="token function">ACCEL_CLASS</span><span class="token punctuation">(</span>oc<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ac<span class="token operator">-&gt;</span>name <span class="token operator">=</span> <span class="token string">"KVM"</span><span class="token punctuation">;</span>
    ac<span class="token operator">-&gt;</span>init_machine <span class="token operator">=</span> kvm_init<span class="token punctuation">;</span>
    ac<span class="token operator">-&gt;</span>allowed <span class="token operator">=</span> <span class="token operator">&amp;</span>kvm_allowed<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在kvm_accel_class_init中，我们创建AccelClass，将init_machine设置为kvm_init。在accel_init_machine中其实就调用了这个init_machine函数，也即调用kvm_init方法。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">kvm_init</span><span class="token punctuation">(</span>MachineState <span class="token operator">*</span>ms<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    MachineClass <span class="token operator">*</span>mc <span class="token operator">=</span> <span class="token function">MACHINE_GET_CLASS</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> soft_vcpus_limit<span class="token punctuation">,</span> hard_vcpus_limit<span class="token punctuation">;</span>
    KVMState <span class="token operator">*</span>s<span class="token punctuation">;</span>
    <span class="token keyword">const</span> KVMCapabilityInfo <span class="token operator">*</span>missing_cap<span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
    <span class="token keyword">int</span> type <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>kvm_type<span class="token punctuation">;</span>

    s <span class="token operator">=</span> <span class="token function">KVM_STATE</span><span class="token punctuation">(</span>ms<span class="token operator">-&gt;</span>accelerator<span class="token punctuation">)</span><span class="token punctuation">;</span>
    s<span class="token operator">-&gt;</span>fd <span class="token operator">=</span> <span class="token function">qemu_open</span><span class="token punctuation">(</span><span class="token string">"/dev/kvm"</span><span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ret <span class="token operator">=</span> <span class="token function">kvm_ioctl</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> KVM_GET_API_VERSION<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        ret <span class="token operator">=</span> <span class="token function">kvm_ioctl</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> KVM_CREATE_VM<span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>ret <span class="token operator">==</span> <span class="token operator">-</span>EINTR<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    s<span class="token operator">-&gt;</span>vmfd <span class="token operator">=</span> ret<span class="token punctuation">;</span>

    <span class="token comment">/* check the vcpu limits */</span>
    soft_vcpus_limit <span class="token operator">=</span> <span class="token function">kvm_recommended_vcpus</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    hard_vcpus_limit <span class="token operator">=</span> <span class="token function">kvm_max_vcpus</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    ret <span class="token operator">=</span> <span class="token function">kvm_arch_init</span><span class="token punctuation">(</span>ms<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">goto</span> err<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">machine_kernel_irqchip_allowed</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">kvm_irqchip_create</span><span class="token punctuation">(</span>ms<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面的操作就从用户态到内核态的KVM了。就像前面原理讲过的一样，用户态使用内核态KVM的能力，需要打开一个文件/dev/kvm，这是一个字符设备文件，打开一个字符设备文件的过程我们讲过，这里不再赘述。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">miscdevice</span> kvm_dev <span class="token operator">=</span> <span class="token punctuation">{</span>
    KVM_MINOR<span class="token punctuation">,</span>
    <span class="token string">"kvm"</span><span class="token punctuation">,</span>
    <span class="token operator">&amp;</span>kvm_chardev_ops<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> kvm_chardev_ops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>unlocked_ioctl <span class="token operator">=</span> kvm_dev_ioctl<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>compat_ioctl   <span class="token operator">=</span> kvm_dev_ioctl<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>llseek     <span class="token operator">=</span> noop_llseek<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>KVM这个字符设备文件定义了一个字符设备文件的操作函数kvm_chardev_ops，这里面只定义了ioctl的操作。</p>
<p>接下来，用户态就通过ioctl系统调用，调用到kvm_dev_ioctl这个函数。这个过程我们在字符设备那一节也讲了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">kvm_dev_ioctl</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>filp<span class="token punctuation">,</span>
              <span class="token keyword">unsigned</span> <span class="token keyword">int</span> ioctl<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> arg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">long</span> r <span class="token operator">=</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>

    <span class="token keyword">switch</span> <span class="token punctuation">(</span>ioctl<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> KVM_GET_API_VERSION<span class="token operator">:</span>
        r <span class="token operator">=</span> KVM_API_VERSION<span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> KVM_CREATE_VM<span class="token operator">:</span>
        r <span class="token operator">=</span> <span class="token function">kvm_dev_ioctl_create_vm</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> KVM_CHECK_EXTENSION<span class="token operator">:</span>
        r <span class="token operator">=</span> <span class="token function">kvm_vm_ioctl_check_extension_generic</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> KVM_GET_VCPU_MMAP_SIZE<span class="token operator">:</span>
        r <span class="token operator">=</span> PAGE_SIZE<span class="token punctuation">;</span>     <span class="token comment">/* struct kvm_run */</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
out<span class="token operator">:</span>
    <span class="token keyword">return</span> r<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们可以看到，在用户态qemu中，调用KVM_GET_API_VERSION查看版本号，内核就有相应的分支，返回版本号，如果能够匹配上，则调用KVM_CREATE_VM创建虚拟机。</p>
<p>创建虚拟机，需要调用kvm_dev_ioctl_create_vm。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">kvm_dev_ioctl_create_vm</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> type<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> r<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">kvm</span> <span class="token operator">*</span>kvm<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">;</span>

    kvm <span class="token operator">=</span> <span class="token function">kvm_create_vm</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    r <span class="token operator">=</span> <span class="token function">get_unused_fd_flags</span><span class="token punctuation">(</span>O_CLOEXEC<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    file <span class="token operator">=</span> <span class="token function">anon_inode_getfile</span><span class="token punctuation">(</span><span class="token string">"kvm-vm"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>kvm_vm_fops<span class="token punctuation">,</span> kvm<span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">fd_install</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> file<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> r<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在kvm_dev_ioctl_create_vm中，首先调用kvm_create_vm创建一个struct kvm结构。这个结构在内核里面代表一个虚拟机。</p>
<p>从下面结构的定义里，我们可以看到，这里面有vcpu，有mm_struct结构。这个结构本来用来管理进程的内存的。虚拟机也是一个进程，所以虚拟机的用户进程空间也是用它来表示。虚拟机里面的操作系统以及应用的进程空间不归它管。</p>
<p>在kvm_dev_ioctl_create_vm中，第二件事情就是创建一个文件描述符，和struct file关联起来，这个struct file的file_operations会被设置为kvm_vm_fops。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">kvm</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>mm<span class="token punctuation">;</span> <span class="token comment">/* userspace tied to this vm */</span>
    <span class="token keyword">struct</span> <span class="token class-name">kvm_memslots</span> __rcu <span class="token operator">*</span>memslots<span class="token punctuation">[</span>KVM_ADDRESS_SPACE_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">kvm_vcpu</span> <span class="token operator">*</span>vcpus<span class="token punctuation">[</span>KVM_MAX_VCPUS<span class="token punctuation">]</span><span class="token punctuation">;</span>
    atomic_t online_vcpus<span class="token punctuation">;</span>
    <span class="token keyword">int</span> created_vcpus<span class="token punctuation">;</span>
    <span class="token keyword">int</span> last_boosted_vcpu<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> vm_list<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">mutex</span> lock<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">kvm_io_bus</span> __rcu <span class="token operator">*</span>buses<span class="token punctuation">[</span>KVM_NR_BUSES<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">struct</span> <span class="token class-name">kvm_vm_stat</span> stat<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">kvm_arch</span> arch<span class="token punctuation">;</span>
    refcount_t users_count<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">long</span> tlbs_dirty<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> devices<span class="token punctuation">;</span>
    pid_t userspace_pid<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> kvm_vm_fops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>release        <span class="token operator">=</span> kvm_vm_release<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>unlocked_ioctl <span class="token operator">=</span> kvm_vm_ioctl<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>llseek         <span class="token operator">=</span> noop_llseek<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>kvm_dev_ioctl_create_vm结束之后，对于一台虚拟机而言，只是在内核中有一个数据结构，对于相应的资源还没有分配，所以我们还需要接着看。</p>
<h4 id="45-3-初始化网络设备"><a href="#45-3-初始化网络设备" class="headerlink" title="45.3 初始化网络设备"></a>45.3 初始化网络设备</h4><p>接下来，调用net_init_clients进行网络设备的初始化。我们可以解析net参数，也会在net_init_clients中解析netdev参数。这属于网络虚拟化的部分，我们先暂时放一下。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">net_init_clients</span><span class="token punctuation">(</span>Error <span class="token operator">*</span><span class="token operator">*</span>errp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">QTAILQ_INIT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>net_clients<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">qemu_opts_foreach</span><span class="token punctuation">(</span><span class="token function">qemu_find_opts</span><span class="token punctuation">(</span><span class="token string">"netdev"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                          net_init_netdev<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> errp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">qemu_opts_foreach</span><span class="token punctuation">(</span><span class="token function">qemu_find_opts</span><span class="token punctuation">(</span><span class="token string">"nic"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> net_param_nic<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> errp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">qemu_opts_foreach</span><span class="token punctuation">(</span><span class="token function">qemu_find_opts</span><span class="token punctuation">(</span><span class="token string">"net"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> net_init_client<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> errp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="45-4-CPU虚拟化"><a href="#45-4-CPU虚拟化" class="headerlink" title="45.4 CPU虚拟化"></a>45.4 CPU虚拟化</h4><p>接下来，我们要调用machine_run_board_init。这里面调用了MachineClass的init函数。盼啊盼才到了它，这才调用了pc_init1。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">machine_run_board_init</span><span class="token punctuation">(</span>MachineState <span class="token operator">*</span>machine<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    MachineClass <span class="token operator">*</span>machine_class <span class="token operator">=</span> <span class="token function">MACHINE_GET_CLASS</span><span class="token punctuation">(</span>machine<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">numa_complete_configuration</span><span class="token punctuation">(</span>machine<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nb_numa_nodes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">machine_numa_finish_cpu_init</span><span class="token punctuation">(</span>machine<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    machine_class<span class="token operator">-&gt;</span><span class="token function">init</span><span class="token punctuation">(</span>machine<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在pc_init1里面，我们重点关注两件重要的事情，一个的CPU的虚拟化，主要调用pc_cpus_init；另外就是内存的虚拟化，主要调用pc_memory_init。这一节我们重点关注CPU的虚拟化，下一节，我们来看内存的虚拟化。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">pc_cpus_init</span><span class="token punctuation">(</span>PCMachineState <span class="token operator">*</span>pcms<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> smp_cpus<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">pc_new_cpu</span><span class="token punctuation">(</span>possible_cpus<span class="token operator">-&gt;</span>cpus<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>type<span class="token punctuation">,</span> possible_cpus<span class="token operator">-&gt;</span>cpus<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>arch_id<span class="token punctuation">,</span> <span class="token operator">&amp;</span>error_fatal<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">pc_new_cpu</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>typename<span class="token punctuation">,</span> int64_t apic_id<span class="token punctuation">,</span> Error <span class="token operator">*</span><span class="token operator">*</span>errp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Object <span class="token operator">*</span>cpu <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    cpu <span class="token operator">=</span> <span class="token function">object_new</span><span class="token punctuation">(</span>typename<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">object_property_set_uint</span><span class="token punctuation">(</span>cpu<span class="token punctuation">,</span> apic_id<span class="token punctuation">,</span> <span class="token string">"apic-id"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>local_err<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">object_property_set_bool</span><span class="token punctuation">(</span>cpu<span class="token punctuation">,</span> true<span class="token punctuation">,</span> <span class="token string">"realized"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>local_err<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用 object_property_add_bool的时候，设置了用 device_set_realized 来设置</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在pc_cpus_init中，对于每一个CPU，都调用pc_new_cpu，在这里，我们又看到了object_new，这又是一个从TypeImpl到Class类再到对象的一个过程。</p>
<p>这个时候，我们就要看CPU的类是怎么组织的了。</p>
<p>在上面的参数里面，CPU的配置是这样的：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-cpu SandyBridge,+erms,+smep,+fsgsbase,+pdpe1gb,+rdrand,+f16c,+osxsave,+dca,+pcid,+pdcm,+xtpr,+tm2,+est,+smx,+vmx,+ds_cpl,+monitor,+dtes64,+pbe,+tm,+ht,+ss,+acpi,+ds,+vme<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在这里我们知道，SandyBridge是CPU的一种类型。在hw/i386/pc.c中，我们能看到这种CPU的定义。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">{</span> <span class="token string">"SandyBridge"</span> <span class="token string">"-"</span> TYPE_X86_CPU<span class="token punctuation">,</span> <span class="token string">"min-xlevel"</span><span class="token punctuation">,</span> <span class="token string">"0x8000000a"</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>接下来，我们就来看”SandyBridge”，也即TYPE_X86_CPU这种CPU的类，是一个什么样的结构。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">const</span> TypeInfo device_type_info <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>name <span class="token operator">=</span> TYPE_DEVICE<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>parent <span class="token operator">=</span> TYPE_OBJECT<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>instance_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>DeviceState<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>instance_init <span class="token operator">=</span> device_initfn<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>instance_post_init <span class="token operator">=</span> device_post_init<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>instance_finalize <span class="token operator">=</span> device_finalize<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>class_base_init <span class="token operator">=</span> device_class_base_init<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>class_init <span class="token operator">=</span> device_class_init<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>abstract <span class="token operator">=</span> true<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>class_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>DeviceClass<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">const</span> TypeInfo cpu_type_info <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>name <span class="token operator">=</span> TYPE_CPU<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>parent <span class="token operator">=</span> TYPE_DEVICE<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>instance_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>CPUState<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>instance_init <span class="token operator">=</span> cpu_common_initfn<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>instance_finalize <span class="token operator">=</span> cpu_common_finalize<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>abstract <span class="token operator">=</span> true<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>class_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>CPUClass<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>class_init <span class="token operator">=</span> cpu_class_init<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">const</span> TypeInfo x86_cpu_type_info <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>name <span class="token operator">=</span> TYPE_X86_CPU<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>parent <span class="token operator">=</span> TYPE_CPU<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>instance_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>X86CPU<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>instance_init <span class="token operator">=</span> x86_cpu_initfn<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>abstract <span class="token operator">=</span> true<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>class_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>X86CPUClass<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>class_init <span class="token operator">=</span> x86_cpu_common_class_init<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>CPU这种类的定义是有多层继承关系的。TYPE_X86_CPU的父类是TYPE_CPU，TYPE_CPU的父类是TYPE_DEVICE，TYPE_DEVICE的父类是TYPE_OBJECT。到头了。</p>
<p>这里面每一层都有class_init，用于从TypeImpl生产xxxClass，也有instance_init将xxxClass初始化为实例。</p>
<p>在TYPE_X86_CPU这一层的class_init中，也即x86_cpu_common_class_init中，设置了DeviceClass的realize函数为x86_cpu_realizefn。这个函数很重要，马上就能用到。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">x86_cpu_common_class_init</span><span class="token punctuation">(</span>ObjectClass <span class="token operator">*</span>oc<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    X86CPUClass <span class="token operator">*</span>xcc <span class="token operator">=</span> <span class="token function">X86_CPU_CLASS</span><span class="token punctuation">(</span>oc<span class="token punctuation">)</span><span class="token punctuation">;</span>
    CPUClass <span class="token operator">*</span>cc <span class="token operator">=</span> <span class="token function">CPU_CLASS</span><span class="token punctuation">(</span>oc<span class="token punctuation">)</span><span class="token punctuation">;</span>
    DeviceClass <span class="token operator">*</span>dc <span class="token operator">=</span> <span class="token function">DEVICE_CLASS</span><span class="token punctuation">(</span>oc<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">device_class_set_parent_realize</span><span class="token punctuation">(</span>dc<span class="token punctuation">,</span> x86_cpu_realizefn<span class="token punctuation">,</span>
                                    <span class="token operator">&amp;</span>xcc<span class="token operator">-&gt;</span>parent_realize<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在TYPE_DEVICE这一层的instance_init函数device_initfn，会为这个设备添加一个属性”realized”，要设置这个属性，需要用函数device_set_realized。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">device_initfn</span><span class="token punctuation">(</span>Object <span class="token operator">*</span>obj<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    DeviceState <span class="token operator">*</span>dev <span class="token operator">=</span> <span class="token function">DEVICE</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ObjectClass <span class="token operator">*</span>class<span class="token punctuation">;</span>
    Property <span class="token operator">*</span>prop<span class="token punctuation">;</span>
    dev<span class="token operator">-&gt;</span>realized <span class="token operator">=</span> false<span class="token punctuation">;</span>
    <span class="token function">object_property_add_bool</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">"realized"</span><span class="token punctuation">,</span>
                             device_get_realized<span class="token punctuation">,</span> device_set_realized<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们回到pc_new_cpu函数，这里面就是通过object_property_set_bool设置这个属性为true，所以device_set_realized函数会被调用。</p>
<p>在device_set_realized中，DeviceClass的realize函数x86_cpu_realizefn会被调用。这里面qemu_init_vcpu会调用qemu_kvm_start_vcpu。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">qemu_kvm_start_vcpu</span><span class="token punctuation">(</span>CPUState <span class="token operator">*</span>cpu<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> thread_name<span class="token punctuation">[</span>VCPU_THREAD_NAME_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    cpu<span class="token operator">-&gt;</span>thread <span class="token operator">=</span> <span class="token function">g_malloc0</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>QemuThread<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cpu<span class="token operator">-&gt;</span>halt_cond <span class="token operator">=</span> <span class="token function">g_malloc0</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>QemuCond<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">qemu_cond_init</span><span class="token punctuation">(</span>cpu<span class="token operator">-&gt;</span>halt_cond<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">qemu_thread_create</span><span class="token punctuation">(</span>cpu<span class="token operator">-&gt;</span>thread<span class="token punctuation">,</span> thread_name<span class="token punctuation">,</span> qemu_kvm_cpu_thread_fn<span class="token punctuation">,</span> cpu<span class="token punctuation">,</span> QEMU_THREAD_JOINABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里面，为这个vcpu创建一个线程，也即虚拟机里面的一个vcpu对应物理机上的一个线程，然后这个线程被调度到某个物理CPU上。</p>
<p>我们来看这个vcpu的线程执行函数。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">qemu_kvm_cpu_thread_fn</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    CPUState <span class="token operator">*</span>cpu <span class="token operator">=</span> arg<span class="token punctuation">;</span>
    <span class="token keyword">int</span> r<span class="token punctuation">;</span>

    <span class="token function">rcu_register_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">qemu_mutex_lock_iothread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">qemu_thread_get_self</span><span class="token punctuation">(</span>cpu<span class="token operator">-&gt;</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cpu<span class="token operator">-&gt;</span>thread_id <span class="token operator">=</span> <span class="token function">qemu_get_thread_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cpu<span class="token operator">-&gt;</span>can_do_io <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    current_cpu <span class="token operator">=</span> cpu<span class="token punctuation">;</span>

    r <span class="token operator">=</span> <span class="token function">kvm_init_vcpu</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">kvm_init_cpu_signals</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* signal CPU creation */</span>
    cpu<span class="token operator">-&gt;</span>created <span class="token operator">=</span> true<span class="token punctuation">;</span>
    <span class="token function">qemu_cond_signal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>qemu_cpu_cond<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">cpu_can_run</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            r <span class="token operator">=</span> <span class="token function">kvm_cpu_exec</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">qemu_wait_io_event</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>cpu<span class="token operator">-&gt;</span>unplug <span class="token operator">||</span> <span class="token function">cpu_can_run</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">qemu_kvm_destroy_vcpu</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cpu<span class="token operator">-&gt;</span>created <span class="token operator">=</span> false<span class="token punctuation">;</span>
    <span class="token function">qemu_cond_signal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>qemu_cpu_cond<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">qemu_mutex_unlock_iothread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">rcu_unregister_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在qemu_kvm_cpu_thread_fn中，先是kvm_init_vcpu初始化这个vcpu。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">kvm_init_vcpu</span><span class="token punctuation">(</span>CPUState <span class="token operator">*</span>cpu<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    KVMState <span class="token operator">*</span>s <span class="token operator">=</span> kvm_state<span class="token punctuation">;</span>
    <span class="token keyword">long</span> mmap_size<span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    ret <span class="token operator">=</span> <span class="token function">kvm_get_vcpu</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token function">kvm_arch_vcpu_id</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    cpu<span class="token operator">-&gt;</span>kvm_fd <span class="token operator">=</span> ret<span class="token punctuation">;</span>
    cpu<span class="token operator">-&gt;</span>kvm_state <span class="token operator">=</span> s<span class="token punctuation">;</span>
    cpu<span class="token operator">-&gt;</span>vcpu_dirty <span class="token operator">=</span> true<span class="token punctuation">;</span>

    mmap_size <span class="token operator">=</span> <span class="token function">kvm_ioctl</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> KVM_GET_VCPU_MMAP_SIZE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    cpu<span class="token operator">-&gt;</span>kvm_run <span class="token operator">=</span> <span class="token function">mmap</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> mmap_size<span class="token punctuation">,</span> PROT_READ <span class="token operator">|</span> PROT_WRITE<span class="token punctuation">,</span> MAP_SHARED<span class="token punctuation">,</span> cpu<span class="token operator">-&gt;</span>kvm_fd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    ret <span class="token operator">=</span> <span class="token function">kvm_arch_init_vcpu</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
err<span class="token operator">:</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在kvm_get_vcpu中，我们会调用kvm_vm_ioctl(s, KVM_CREATE_VCPU, (void *)vcpu_id)，在内核里面创建一个vcpu。在上面创建KVM_CREATE_VM的时候，我们已经创建了一个struct file，它的file_operations被设置为kvm_vm_fops，这个内核文件也是可以响应ioctl的。</p>
<p>如果我们切换到内核KVM，在kvm_vm_ioctl函数中，有对于KVM_CREATE_VCPU的处理，调用的是kvm_vm_ioctl_create_vcpu。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">kvm_vm_ioctl</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>filp<span class="token punctuation">,</span>
               <span class="token keyword">unsigned</span> <span class="token keyword">int</span> ioctl<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> arg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">kvm</span> <span class="token operator">*</span>kvm <span class="token operator">=</span> filp<span class="token operator">-&gt;</span>private_data<span class="token punctuation">;</span>
    <span class="token keyword">void</span> __user <span class="token operator">*</span>argp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> __user <span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">;</span>
    <span class="token keyword">int</span> r<span class="token punctuation">;</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>ioctl<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> KVM_CREATE_VCPU<span class="token operator">:</span>
        r <span class="token operator">=</span> <span class="token function">kvm_vm_ioctl_create_vcpu</span><span class="token punctuation">(</span>kvm<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> KVM_SET_USER_MEMORY_REGION<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">kvm_userspace_memory_region</span> kvm_userspace_mem<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_from_user</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kvm_userspace_mem<span class="token punctuation">,</span> argp<span class="token punctuation">,</span>
                        <span class="token keyword">sizeof</span><span class="token punctuation">(</span>kvm_userspace_mem<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">goto</span> out<span class="token punctuation">;</span>
        r <span class="token operator">=</span> <span class="token function">kvm_vm_ioctl_set_memory_region</span><span class="token punctuation">(</span>kvm<span class="token punctuation">,</span> <span class="token operator">&amp;</span>kvm_userspace_mem<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">case</span> KVM_CREATE_DEVICE<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">kvm_create_device</span> cd<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_from_user</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cd<span class="token punctuation">,</span> argp<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>cd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">goto</span> out<span class="token punctuation">;</span>
        r <span class="token operator">=</span> <span class="token function">kvm_ioctl_create_device</span><span class="token punctuation">(</span>kvm<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cd<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_to_user</span><span class="token punctuation">(</span>argp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cd<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>cd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">goto</span> out<span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">case</span> KVM_CHECK_EXTENSION<span class="token operator">:</span>
        r <span class="token operator">=</span> <span class="token function">kvm_vm_ioctl_check_extension_generic</span><span class="token punctuation">(</span>kvm<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
        r <span class="token operator">=</span> <span class="token function">kvm_arch_vm_ioctl</span><span class="token punctuation">(</span>filp<span class="token punctuation">,</span> ioctl<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
out<span class="token operator">:</span>
    <span class="token keyword">return</span> r<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在kvm_vm_ioctl_create_vcpu中，kvm_arch_vcpu_create调用kvm_x86_ops的vcpu_create函数来创建CPU。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">kvm_vm_ioctl_create_vcpu</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kvm</span> <span class="token operator">*</span>kvm<span class="token punctuation">,</span> u32 id<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> r<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">kvm_vcpu</span> <span class="token operator">*</span>vcpu<span class="token punctuation">;</span>
    kvm<span class="token operator">-&gt;</span>created_vcpus<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    vcpu <span class="token operator">=</span> <span class="token function">kvm_arch_vcpu_create</span><span class="token punctuation">(</span>kvm<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">preempt_notifier_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vcpu<span class="token operator">-&gt;</span>preempt_notifier<span class="token punctuation">,</span> <span class="token operator">&amp;</span>kvm_preempt_ops<span class="token punctuation">)</span><span class="token punctuation">;</span>
    r <span class="token operator">=</span> <span class="token function">kvm_arch_vcpu_setup</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* Now it's all set up, let userspace reach it */</span>
    <span class="token function">kvm_get_kvm</span><span class="token punctuation">(</span>kvm<span class="token punctuation">)</span><span class="token punctuation">;</span>
    r <span class="token operator">=</span> <span class="token function">create_vcpu_fd</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
    kvm<span class="token operator">-&gt;</span>vcpus<span class="token punctuation">[</span><span class="token function">atomic_read</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kvm<span class="token operator">-&gt;</span>online_vcpus<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> vcpu<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">kvm_vcpu</span> <span class="token operator">*</span><span class="token function">kvm_arch_vcpu_create</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kvm</span> <span class="token operator">*</span>kvm<span class="token punctuation">,</span>
                        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">kvm_vcpu</span> <span class="token operator">*</span>vcpu<span class="token punctuation">;</span>
    vcpu <span class="token operator">=</span> kvm_x86_ops<span class="token operator">-&gt;</span><span class="token function">vcpu_create</span><span class="token punctuation">(</span>kvm<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> vcpu<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">create_vcpu_fd</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kvm_vcpu</span> <span class="token operator">*</span>vcpu<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">anon_inode_getfd</span><span class="token punctuation">(</span><span class="token string">"kvm-vcpu"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>kvm_vcpu_fops<span class="token punctuation">,</span> vcpu<span class="token punctuation">,</span> O_RDWR <span class="token operator">|</span> O_CLOEXEC<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后，create_vcpu_fd又创建了一个struct file，它的file_operations指向kvm_vcpu_fops。从这里可以看出，KVM的内核模块是一个文件，可以通过ioctl进行操作。基于这个内核模块创建的VM也是一个文件，也可以通过ioctl进行操作。在这个VM上创建的vcpu同样是一个文件，同样可以通过ioctl进行操作。</p>
<p>我们回过头来看，kvm_x86_ops的vcpu_create函数。kvm_x86_ops对于不同的硬件加速虚拟化指向不同的结构，如果是vmx，则指向vmx_x86_ops；如果是svm，则指向svm_x86_ops。我们这里看vmx_x86_ops。这个结构很长，里面有非常多的操作，我们用一个看一个。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">kvm_x86_ops</span> vmx_x86_ops __ro_after_init <span class="token operator">=</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">.</span>vcpu_create <span class="token operator">=</span> vmx_create_vcpu<span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">kvm_vcpu</span> <span class="token operator">*</span><span class="token function">vmx_create_vcpu</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kvm</span> <span class="token operator">*</span>kvm<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> err<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">vcpu_vmx</span> <span class="token operator">*</span>vmx <span class="token operator">=</span> <span class="token function">kmem_cache_zalloc</span><span class="token punctuation">(</span>kvm_vcpu_cache<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> cpu<span class="token punctuation">;</span>
    vmx<span class="token operator">-&gt;</span>vpid <span class="token operator">=</span> <span class="token function">allocate_vpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    err <span class="token operator">=</span> <span class="token function">kvm_vcpu_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vmx<span class="token operator">-&gt;</span>vcpu<span class="token punctuation">,</span> kvm<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vmx<span class="token operator">-&gt;</span>guest_msrs <span class="token operator">=</span> <span class="token function">kmalloc</span><span class="token punctuation">(</span>PAGE_SIZE<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vmx<span class="token operator">-&gt;</span>loaded_vmcs <span class="token operator">=</span> <span class="token operator">&amp;</span>vmx<span class="token operator">-&gt;</span>vmcs01<span class="token punctuation">;</span>
    vmx<span class="token operator">-&gt;</span>loaded_vmcs<span class="token operator">-&gt;</span>vmcs <span class="token operator">=</span> <span class="token function">alloc_vmcs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    vmx<span class="token operator">-&gt;</span>loaded_vmcs<span class="token operator">-&gt;</span>shadow_vmcs <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token function">loaded_vmcs_init</span><span class="token punctuation">(</span>vmx<span class="token operator">-&gt;</span>loaded_vmcs<span class="token punctuation">)</span><span class="token punctuation">;</span>

    cpu <span class="token operator">=</span> <span class="token function">get_cpu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">vmx_vcpu_load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vmx<span class="token operator">-&gt;</span>vcpu<span class="token punctuation">,</span> cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vmx<span class="token operator">-&gt;</span>vcpu<span class="token punctuation">.</span>cpu <span class="token operator">=</span> cpu<span class="token punctuation">;</span>
    err <span class="token operator">=</span> <span class="token function">vmx_vcpu_setup</span><span class="token punctuation">(</span>vmx<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">vmx_vcpu_put</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vmx<span class="token operator">-&gt;</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">put_cpu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>enable_ept<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>kvm<span class="token operator">-&gt;</span>arch<span class="token punctuation">.</span>ept_identity_map_addr<span class="token punctuation">)</span>
            kvm<span class="token operator">-&gt;</span>arch<span class="token punctuation">.</span>ept_identity_map_addr <span class="token operator">=</span>
                VMX_EPT_IDENTITY_PAGETABLE_ADDR<span class="token punctuation">;</span>
        err <span class="token operator">=</span> <span class="token function">init_rmode_identity_map</span><span class="token punctuation">(</span>kvm<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token operator">&amp;</span>vmx<span class="token operator">-&gt;</span>vcpu<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>vmx_create_vcpu创建用于表示vcpu的结构struct vcpu_vmx，并填写里面的内容。例如guest_msrs，咱们在讲系统调用的时候提过msr寄存器，虚拟机也需要有这样的寄存器。</p>
<p>enable_ept是和内存虚拟化相关的，EPT全称Extended Page Table，顾名思义，是优化内存虚拟化的，这个功能我们放到内存的那一节讲。</p>
<p>最最重要的就是loaded_vmcs了。VMCS是什么呢？它的全称是Virtual Machine Control Structure。它是来干什么呢？</p>
<p>前面咱们将进程调度的时候讲过，为了支持进程在CPU上的切换，CPU硬件要求有一个TSS结构，用于保存进程运行时的所有寄存器的状态，进程切换的时候，需要根据TSS恢复寄存器。</p>
<p>虚拟机也是一个进程，也需要切换，而且切换更加的复杂，可能是两个虚拟机之间切换，也可能是虚拟机切换给内核，虚拟机因为里面还有另一个操作系统，要保存的信息比普通的进程多得多。那就需要有一个结构来保存虚拟机运行的上下文，VMCS就是是Intel实现CPU虚拟化，记录vCPU状态的一个关键数据结构。</p>
<p>VMCS数据结构主要包含以下信息。</p>
<ul>
<li>Guest-state area，即vCPU的状态信息，包括vCPU的基本运行环境，例如寄存器等。</li>
<li>Host-state area，是物理CPU的状态信息。物理CPU和vCPU之间也会来回切换，所以，VMCS中既要记录vCPU的状态，也要记录物理CPU的状态。</li>
<li>VM-execution control fields，对vCPU的运行行为进行控制。例如，发生中断怎么办，是否使用EPT（Extended Page Table）功能等。</li>
</ul>
<p>接下来，对于VMCS，有两个重要的操作。</p>
<p>VM-Entry，我们称为从根模式切换到非根模式，也即切换到guest上，这个时候CPU上运行的是虚拟机。VM-Exit我们称为CPU从非根模式切换到根模式，也即从guest切换到宿主机。例如，当要执行一些虚拟机没有权限的敏感指令时。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/虚拟机管理系统.png" alt="虚拟机管理系统"></p>
<p>为了维护这两个动作，VMCS里面还有几项内容：</p>
<ul>
<li>VM-exit control fields，对VM Exit的行为进行控制。比如，VM Exit的时候对vCPU来说需要保存哪些MSR寄存器，对于主机CPU来说需要恢复哪些MSR寄存器。</li>
<li>VM-entry control fields，对VM Entry的行为进行控制。比如，需要保存和恢复哪些MSR寄存器等。</li>
<li>VM-exit information fields，记录下发生VM Exit发生的原因及一些必要的信息，方便对VM Exit事件进行处理。</li>
</ul>
<p>至此，内核准备完毕。</p>
<p>我们再回到qemu的kvm_init_vcpu函数，这里面除了创建内核中的vcpu结构之外，还通过mmap将内核的vcpu结构，映射到qemu中CPUState的kvm_run中，为什么能用mmap呢，上面咱们不是说过了吗，vcpu也是一个文件。</p>
<p>我们再回到这个vcpu的线程函数qemu_kvm_cpu_thread_fn，他在执行kvm_init_vcpu创建vcpu之后，接下来是一个do-while循环，也即一直运行，并且通过调用kvm_cpu_exec，运行这个虚拟机。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">kvm_cpu_exec</span><span class="token punctuation">(</span>CPUState <span class="token operator">*</span>cpu<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">kvm_run</span> <span class="token operator">*</span>run <span class="token operator">=</span> cpu<span class="token operator">-&gt;</span>kvm_run<span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">,</span> run_ret<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        run_ret <span class="token operator">=</span> <span class="token function">kvm_vcpu_ioctl</span><span class="token punctuation">(</span>cpu<span class="token punctuation">,</span> KVM_RUN<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span>run<span class="token operator">-&gt;</span>exit_reason<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> KVM_EXIT_IO<span class="token operator">:</span>
            <span class="token function">kvm_handle_io</span><span class="token punctuation">(</span>run<span class="token operator">-&gt;</span>io<span class="token punctuation">.</span>port<span class="token punctuation">,</span> attrs<span class="token punctuation">,</span>
                          <span class="token punctuation">(</span>uint8_t <span class="token operator">*</span><span class="token punctuation">)</span>run <span class="token operator">+</span> run<span class="token operator">-&gt;</span>io<span class="token punctuation">.</span>data_offset<span class="token punctuation">,</span>
                          run<span class="token operator">-&gt;</span>io<span class="token punctuation">.</span>direction<span class="token punctuation">,</span>
                          run<span class="token operator">-&gt;</span>io<span class="token punctuation">.</span>size<span class="token punctuation">,</span>
                          run<span class="token operator">-&gt;</span>io<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> KVM_EXIT_IRQ_WINDOW_OPEN<span class="token operator">:</span>
            ret <span class="token operator">=</span> EXCP_INTERRUPT<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> KVM_EXIT_SHUTDOWN<span class="token operator">:</span>
            <span class="token function">qemu_system_reset_request</span><span class="token punctuation">(</span>SHUTDOWN_CAUSE_GUEST_RESET<span class="token punctuation">)</span><span class="token punctuation">;</span>
            ret <span class="token operator">=</span> EXCP_INTERRUPT<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> KVM_EXIT_UNKNOWN<span class="token operator">:</span>
            <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"KVM: unknown exit, hardware reason %"</span> PRIx64 <span class="token string">"\n"</span><span class="token punctuation">,</span><span class="token punctuation">(</span>uint64_t<span class="token punctuation">)</span>run<span class="token operator">-&gt;</span>hw<span class="token punctuation">.</span>hardware_exit_reason<span class="token punctuation">)</span><span class="token punctuation">;</span>
            ret <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> KVM_EXIT_INTERNAL_ERROR<span class="token operator">:</span>
            ret <span class="token operator">=</span> <span class="token function">kvm_handle_internal_error</span><span class="token punctuation">(</span>cpu<span class="token punctuation">,</span> run<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>ret <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在kvm_cpu_exec中，我们能看到一个循环，在循环中，kvm_vcpu_ioctl(KVM_RUN)运行这个虚拟机，这个时候CPU进入VM-Entry，也即进入客户机模式。</p>
<p>如果一直是客户机的操作系统占用这个CPU，则会一直停留在这一行运行，一旦这个调用返回了，就说明CPU进入VM-Exit退出客户机模式，将CPU交还给宿主机。在循环中，我们会对退出的原因exit_reason进行分析处理，因为有了I/O，还有了中断等，做相应的处理。处理完毕之后，再次循环，再次通过VM-Entry，进入客户机模式。如此循环，直到虚拟机正常或者异常退出。</p>
<p>我们来看kvm_vcpu_ioctl(KVM_RUN)在内核做了哪些事情。</p>
<p>上面我们也讲了，vcpu在内核也是一个文件，也是通过ioctl进行用户态和内核态通信的，在内核中，调用的是kvm_vcpu_ioctl。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">kvm_vcpu_ioctl</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>filp<span class="token punctuation">,</span>
               <span class="token keyword">unsigned</span> <span class="token keyword">int</span> ioctl<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> arg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">kvm_vcpu</span> <span class="token operator">*</span>vcpu <span class="token operator">=</span> filp<span class="token operator">-&gt;</span>private_data<span class="token punctuation">;</span>
    <span class="token keyword">void</span> __user <span class="token operator">*</span>argp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> __user <span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">;</span>
    <span class="token keyword">int</span> r<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">kvm_fpu</span> <span class="token operator">*</span>fpu <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">kvm_sregs</span> <span class="token operator">*</span>kvm_sregs <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    r <span class="token operator">=</span> <span class="token function">vcpu_load</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>ioctl<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> KVM_RUN<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">pid</span> <span class="token operator">*</span>oldpid<span class="token punctuation">;</span>
        r <span class="token operator">=</span> <span class="token function">kvm_arch_vcpu_ioctl_run</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">,</span> vcpu<span class="token operator">-&gt;</span>run<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">case</span> KVM_GET_REGS<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">kvm_regs</span> <span class="token operator">*</span>kvm_regs<span class="token punctuation">;</span>
        kvm_regs <span class="token operator">=</span> <span class="token function">kzalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kvm_regs</span><span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
        r <span class="token operator">=</span> <span class="token function">kvm_arch_vcpu_ioctl_get_regs</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">,</span> kvm_regs<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_to_user</span><span class="token punctuation">(</span>argp<span class="token punctuation">,</span> kvm_regs<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kvm_regs</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">goto</span> out_free1<span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">case</span> KVM_SET_REGS<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">kvm_regs</span> <span class="token operator">*</span>kvm_regs<span class="token punctuation">;</span>
        kvm_regs <span class="token operator">=</span> <span class="token function">memdup_user</span><span class="token punctuation">(</span>argp<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>kvm_regs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        r <span class="token operator">=</span> <span class="token function">kvm_arch_vcpu_ioctl_set_regs</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">,</span> kvm_regs<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>kvm_arch_vcpu_ioctl_run会调用vcpu_run，这里面也是一个无限循环。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">vcpu_run</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kvm_vcpu</span> <span class="token operator">*</span>vcpu<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> r<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">kvm</span> <span class="token operator">*</span>kvm <span class="token operator">=</span> vcpu<span class="token operator">-&gt;</span>kvm<span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">kvm_vcpu_running</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            r <span class="token operator">=</span> <span class="token function">vcpu_enter_guest</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            r <span class="token operator">=</span> <span class="token function">vcpu_block</span><span class="token punctuation">(</span>kvm<span class="token punctuation">,</span> vcpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">signal_pending</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            r <span class="token operator">=</span> <span class="token operator">-</span>EINTR<span class="token punctuation">;</span>
            vcpu<span class="token operator">-&gt;</span>run<span class="token operator">-&gt;</span>exit_reason <span class="token operator">=</span> KVM_EXIT_INTR<span class="token punctuation">;</span>
            <span class="token operator">++</span>vcpu<span class="token operator">-&gt;</span>stat<span class="token punctuation">.</span>signal_exits<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">need_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">cond_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> r<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这个循环中，除了调用vcpu_enter_guest进入客户机模式运行之外，还有对于信号的响应signal_pending，也即一台虚拟机是可以被kill掉的，还有对于调度的响应，这台虚拟机可以被从当前的物理CPU上赶下来，换成别的虚拟机或者其他进程。</p>
<p>我们这里重点看vcpu_enter_guest。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">vcpu_enter_guest</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kvm_vcpu</span> <span class="token operator">*</span>vcpu<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    r <span class="token operator">=</span> <span class="token function">kvm_mmu_reload</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vcpu<span class="token operator">-&gt;</span>mode <span class="token operator">=</span> IN_GUEST_MODE<span class="token punctuation">;</span>
    <span class="token function">kvm_load_guest_xcr0</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">guest_enter_irqoff</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    kvm_x86_ops<span class="token operator">-&gt;</span><span class="token function">run</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vcpu<span class="token operator">-&gt;</span>mode <span class="token operator">=</span> OUTSIDE_GUEST_MODE<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">kvm_put_guest_xcr0</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
    kvm_x86_ops<span class="token operator">-&gt;</span><span class="token function">handle_external_intr</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">++</span>vcpu<span class="token operator">-&gt;</span>stat<span class="token punctuation">.</span>exits<span class="token punctuation">;</span>
    <span class="token function">guest_exit_irqoff</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    r <span class="token operator">=</span> kvm_x86_ops<span class="token operator">-&gt;</span><span class="token function">handle_exit</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> r<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">kvm_x86_ops</span> vmx_x86_ops __ro_after_init <span class="token operator">=</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">.</span>run <span class="token operator">=</span> vmx_vcpu_run<span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在vcpu_enter_guest中，我们会调用vmx_x86_ops 的vmx_vcpu_run函数，进入客户机模式。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> __noclone <span class="token function">vmx_vcpu_run</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kvm_vcpu</span> <span class="token operator">*</span>vcpu<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">vcpu_vmx</span> <span class="token operator">*</span>vmx <span class="token operator">=</span> <span class="token function">to_vmx</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> debugctlmsr<span class="token punctuation">,</span> cr3<span class="token punctuation">,</span> cr4<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    cr3 <span class="token operator">=</span> <span class="token function">__get_current_cr3_fast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    cr4 <span class="token operator">=</span> <span class="token function">cr4_read_shadow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    vmx<span class="token operator">-&gt;</span>__launched <span class="token operator">=</span> vmx<span class="token operator">-&gt;</span>loaded_vmcs<span class="token operator">-&gt;</span>launched<span class="token punctuation">;</span>
    <span class="token keyword">asm</span><span class="token punctuation">(</span>
        <span class="token comment">/* Store host registers */</span>
        <span class="token string">"push %%"</span> _ASM_DX <span class="token string">"; push %%"</span> _ASM_BP <span class="token string">";"</span>
        <span class="token string">"push %%"</span> _ASM_CX <span class="token string">" \n\t"</span> <span class="token comment">/* placeholder for guest rcx */</span>
        <span class="token string">"push %%"</span> _ASM_CX <span class="token string">" \n\t"</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token comment">/* Load guest registers.  Don't clobber flags. */</span>
        <span class="token string">"mov %crax, %%"</span> _ASM_AX <span class="token string">" \n\t"</span>
        <span class="token string">"mov %crbx, %%"</span> _ASM_BX <span class="token string">" \n\t"</span>
        <span class="token string">"mov %crdx, %%"</span> _ASM_DX <span class="token string">" \n\t"</span>
        <span class="token string">"mov %crsi, %%"</span> _ASM_SI <span class="token string">" \n\t"</span>
        <span class="token string">"mov %crdi, %%"</span> _ASM_DI <span class="token string">" \n\t"</span>
        <span class="token string">"mov %crbp, %%"</span> _ASM_BP <span class="token string">" \n\t"</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_X86_64</span></span>
        <span class="token string">"mov %cr8,  %%r8  \n\t"</span>
        <span class="token string">"mov %cr9,  %%r9  \n\t"</span>
        <span class="token string">"mov %cr10, %%r10 \n\t"</span>
        <span class="token string">"mov %cr11, %%r11 \n\t"</span>
        <span class="token string">"mov %cr12, %%r12 \n\t"</span>
        <span class="token string">"mov %cr13, %%r13 \n\t"</span>
        <span class="token string">"mov %cr14, %%r14 \n\t"</span>
        <span class="token string">"mov %cr15, %%r15 \n\t"</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
        <span class="token string">"mov %crcx, %%"</span> _ASM_CX <span class="token string">" \n\t"</span> <span class="token comment">/* kills %0 (ecx) */</span>

        <span class="token comment">/* Enter guest mode */</span>
        <span class="token string">"jne 1f \n\t"</span>
        <span class="token function">__ex</span><span class="token punctuation">(</span>ASM_VMX_VMLAUNCH<span class="token punctuation">)</span> <span class="token string">"\n\t"</span>
        <span class="token string">"jmp 2f \n\t"</span>
        <span class="token string">"1: "</span> <span class="token function">__ex</span><span class="token punctuation">(</span>ASM_VMX_VMRESUME<span class="token punctuation">)</span> <span class="token string">"\n\t"</span>
        <span class="token string">"2: "</span>
        <span class="token comment">/* Save guest registers, load host registers, keep flags */</span>
        <span class="token string">"mov %0, %cwordsize \n\t"</span>
        <span class="token string">"pop %0 \n\t"</span>
        <span class="token string">"mov %%"</span> _ASM_AX <span class="token string">", %crax \n\t"</span>
        <span class="token string">"mov %%"</span> _ASM_BX <span class="token string">", %crbx \n\t"</span>
        <span class="token function">__ASM_SIZE</span><span class="token punctuation">(</span>pop<span class="token punctuation">)</span> <span class="token string">" %crcx \n\t"</span>
        <span class="token string">"mov %%"</span> _ASM_DX <span class="token string">", %crdx \n\t"</span>
        <span class="token string">"mov %%"</span> _ASM_SI <span class="token string">", %crsi \n\t"</span>
        <span class="token string">"mov %%"</span> _ASM_DI <span class="token string">", %crdi \n\t"</span>
        <span class="token string">"mov %%"</span> _ASM_BP <span class="token string">", %crbp \n\t"</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_X86_64</span></span>
        <span class="token string">"mov %%r8,  %cr8 \n\t"</span>
        <span class="token string">"mov %%r9,  %cr9 \n\t"</span>
        <span class="token string">"mov %%r10, %cr10 \n\t"</span>
        <span class="token string">"mov %%r11, %cr11 \n\t"</span>
        <span class="token string">"mov %%r12, %cr12 \n\t"</span>
        <span class="token string">"mov %%r13, %cr13 \n\t"</span>
        <span class="token string">"mov %%r14, %cr14 \n\t"</span>
        <span class="token string">"mov %%r15, %cr15 \n\t"</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
        <span class="token string">"mov %%cr2, %%"</span> _ASM_AX <span class="token string">"   \n\t"</span>
        <span class="token string">"mov %%"</span> _ASM_AX <span class="token string">", %ccr2 \n\t"</span>

        <span class="token string">"pop  %%"</span> _ASM_BP <span class="token string">"; pop  %%"</span> _ASM_DX <span class="token string">" \n\t"</span>
        <span class="token string">"setbe %cfail \n\t"</span>
        <span class="token string">".pushsection .rodata \n\t"</span>
        <span class="token string">".global vmx_return \n\t"</span>
        <span class="token string">"vmx_return: "</span> _ASM_PTR <span class="token string">" 2b \n\t"</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
          <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    vmx<span class="token operator">-&gt;</span>loaded_vmcs<span class="token operator">-&gt;</span>launched <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    vmx<span class="token operator">-&gt;</span>exit_reason <span class="token operator">=</span> <span class="token function">vmcs_read32</span><span class="token punctuation">(</span>VM_EXIT_REASON<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在vmx_vcpu_run中，出现了汇编语言的代码，比较难看懂，但是没有关系呀，里面有注释呀，我们可以沿着注释来看。</p>
<ul>
<li>首先是Store host registers，要从宿主机模式变为客户机模式了，所以原来宿主机运行时候的寄存器要保存下来。</li>
<li>接下来是Load guest registers，将原来客户机运行的时候的寄存器加载进来。</li>
<li>接下来是Enter guest mode，调用ASM_VMX_VMLAUNCH进入客户机模型运行，或者ASM_VMX_VMRESUME恢复客户机模型运行。</li>
<li>如果客户机因为某种原因退出，Save guest registers, load host registers，也即保存客户机运行的时候的寄存器，就加载宿主机运行的时候的寄存器。</li>
<li>最后将exit_reason保存在vmx结构中。</li>
</ul>
<p>至此，CPU虚拟化就解析完了。</p>
<h4 id="45-5-总结"><a href="#45-5-总结" class="headerlink" title="45.5 总结"></a>45.5 总结</h4><p>CPU的虚拟化过程还是很复杂的，我画了一张图总结了一下。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/CPU的虚拟化过程.png" alt="CPU的虚拟化过程"></p>
<ul>
<li>首先，我们要定义CPU这种类型的TypeInfo和TypeImpl、继承关系，并且声明它的类初始化函数。</li>
<li>在qemu的main函数中调用MachineClass的init函数，这个函数既会初始化CPU，也会初始化内存。</li>
<li>CPU初始化的时候，会调用pc_new_cpu创建一个虚拟CPU，它会调用CPU这个类的初始化函数。</li>
<li>每一个虚拟CPU会调用qemu_thread_create创建一个线程，线程的执行函数为qemu_kvm_cpu_thread_fn。</li>
<li>在虚拟CPU对应的线程执行函数中，我们先是调用kvm_vm_ioctl(KVM_CREATE_VCPU)，在内核的KVM里面，创建一个结构struct vcpu_vmx，表示这个虚拟CPU。在这个结构里面，有一个VMCS，用于保存当前虚拟机CPU的运行时的状态，用于状态切换。</li>
<li>在虚拟CPU对应的线程执行函数中，我们接着调用kvm_vcpu_ioctl(KVM_RUN)，在内核的KVM里面运行这个虚拟机CPU。运行的方式是保存宿主机的寄存器，加载客户机的寄存器，然后调用<strong>ex(ASM_VMX_VMLAUNCH)或者</strong>ex(ASM_VMX_VMRESUME)，进入客户机模式运行。一旦退出客户机模式，就会保存客户机寄存器，加载宿主机寄存器，进入宿主机模式运行，并且会记录退出虚拟机模式的原因。大部分的原因是等待I/O，因而宿主机调用kvm_handle_io进行处理。</li>
</ul>
<h3 id="46-计算虚拟化之内存"><a href="#46-计算虚拟化之内存" class="headerlink" title="46. 计算虚拟化之内存"></a>46. 计算虚拟化之内存</h3><p>上一节，我们解析了计算虚拟化之CPU。可以看到，CPU的虚拟化是用户态的qemu和内核态的KVM共同配合完成的。它们二者通过ioctl进行通信。对于内存管理来讲，也是需要这两者配合完成的。</p>
<p>咱们在内存管理的时候讲过，操作系统给每个进程分配的内存都是虚拟内存，需要通过页表映射，变成物理内存进行访问。当有了虚拟机之后，情况会变得更加复杂。因为虚拟机对于物理机来讲是一个进程，但是虚拟机里面也有内核，也有虚拟机里面跑的进程。所以有了虚拟机，内存就变成了四类：</p>
<ul>
<li><strong>虚拟机里面的虚拟内存（Guest OS Virtual Memory，GVA）</strong>，这是虚拟机里面的进程看到的内存空间；</li>
<li><strong>虚拟机里面的物理内存（Guest OS Physical Memory，GPA）</strong>，这是虚拟机里面的操作系统看到的内存，它认为这是物理内存；</li>
<li><strong>物理机的虚拟内存（Host Virtual Memory，HVA）</strong>，这是物理机上的qemu进程看到的内存空间；</li>
<li><strong>物理机的物理内存（Host Physical Memory，HPA）</strong>，这是物理机上的操作系统看到的内存。</li>
</ul>
<p>这下咱们内存管理那一章讲的两大内容，一个是内存管理变得非常复杂，另一个是内存映射，就都要转多手了。换句话说就是，从GVA到GPA，到HVA，再到HPA，性能会变得很差。当然，虚拟化技术成熟的今天，有了一些优化的手段，具体怎么优化呢？我们这一节就来一一解析。</p>
<h4 id="46-1-内存管理"><a href="#46-1-内存管理" class="headerlink" title="46.1 内存管理"></a>46.1 内存管理</h4><p>我们先来看内存管理的部分。</p>
<p>由于CPU和内存是紧密结合的，因而内存虚拟化的初始化过程，和CPU虚拟化的初始化是一起完成的。</p>
<p>上一节说CPU虚拟化初始化的时候，我们会调用kvm_init函数，这里面打开了”/dev/kvm”这个字符文件，并且通过ioctl调用到内核kvm的KVM_CREATE_VM操作，除了这些CPU相关的调用，接下来还有内存相关的。我们来看看。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">kvm_init</span><span class="token punctuation">(</span>MachineState <span class="token operator">*</span>ms<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    MachineClass <span class="token operator">*</span>mc <span class="token operator">=</span> <span class="token function">MACHINE_GET_CLASS</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">kvm_memory_listener_register</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token operator">-&gt;</span>memory_listener<span class="token punctuation">,</span>
                                 <span class="token operator">&amp;</span>address_space_memory<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">memory_listener_register</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kvm_io_listener<span class="token punctuation">,</span>
                             <span class="token operator">&amp;</span>address_space_io<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

AddressSpace address_space_io<span class="token punctuation">;</span>
AddressSpace address_space_memory<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面有两个地址空间AddressSpace，一个是系统内存的地址空间address_space_memory，一个用于I/O的地址空间address_space_io。这里我们重点看address_space_memory。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">AddressSpace</span> <span class="token punctuation">{</span>
    <span class="token comment">/* All fields are private. */</span>
    <span class="token keyword">struct</span> <span class="token class-name">rcu_head</span> rcu<span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>
    MemoryRegion <span class="token operator">*</span>root<span class="token punctuation">;</span>

    <span class="token comment">/* Accessed via RCU.  */</span>
    <span class="token keyword">struct</span> <span class="token class-name">FlatView</span> <span class="token operator">*</span>current_map<span class="token punctuation">;</span>

    <span class="token keyword">int</span> ioeventfd_nb<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">MemoryRegionIoeventfd</span> <span class="token operator">*</span>ioeventfds<span class="token punctuation">;</span>
    <span class="token function">QTAILQ_HEAD</span><span class="token punctuation">(</span><span class="token punctuation">,</span> MemoryListener<span class="token punctuation">)</span> listeners<span class="token punctuation">;</span>
    <span class="token function">QTAILQ_ENTRY</span><span class="token punctuation">(</span>AddressSpace<span class="token punctuation">)</span> address_spaces_link<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于一个地址空间，会有多个内存区域MemoryRegion组成树形结构。这里面，root是这棵树的根。另外，还有一个MemoryListener链表，当内存区域发生变化的时候，需要做一些动作，使得用户态和内核态能够协同，就是由这些MemoryListener完成的。</p>
<p>在kvm_init这个时候，还没有内存区域加入进来，root还是空的，但是我们可以先注册MemoryListener，这里注册的是KVMMemoryListener。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">kvm_memory_listener_register</span><span class="token punctuation">(</span>KVMState <span class="token operator">*</span>s<span class="token punctuation">,</span> KVMMemoryListener <span class="token operator">*</span>kml<span class="token punctuation">,</span>
                                  AddressSpace <span class="token operator">*</span>as<span class="token punctuation">,</span> <span class="token keyword">int</span> as_id<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>

    kml<span class="token operator">-&gt;</span>slots <span class="token operator">=</span> <span class="token function">g_malloc0</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>nr_slots <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>KVMSlot<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    kml<span class="token operator">-&gt;</span>as_id <span class="token operator">=</span> as_id<span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token operator">-&gt;</span>nr_slots<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        kml<span class="token operator">-&gt;</span>slots<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>slot <span class="token operator">=</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    kml<span class="token operator">-&gt;</span>listener<span class="token punctuation">.</span>region_add <span class="token operator">=</span> kvm_region_add<span class="token punctuation">;</span>
    kml<span class="token operator">-&gt;</span>listener<span class="token punctuation">.</span>region_del <span class="token operator">=</span> kvm_region_del<span class="token punctuation">;</span>
    kml<span class="token operator">-&gt;</span>listener<span class="token punctuation">.</span>priority <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

    <span class="token function">memory_listener_register</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kml<span class="token operator">-&gt;</span>listener<span class="token punctuation">,</span> as<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这个KVMMemoryListener中是这样配置的：当添加一个MemoryRegion的时候，region_add会被调用，这个我们后面会用到。</p>
<p>接下来，在qemu启动的main函数中，我们会调用cpu_exec_init_all-&gt;memory_map_init.</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">memory_map_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    system_memory <span class="token operator">=</span> <span class="token function">g_malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>system_memory<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">memory_region_init</span><span class="token punctuation">(</span>system_memory<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">"system"</span><span class="token punctuation">,</span> UINT64_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">address_space_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>address_space_memory<span class="token punctuation">,</span> system_memory<span class="token punctuation">,</span> <span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    system_io <span class="token operator">=</span> <span class="token function">g_malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>system_io<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">memory_region_init_io</span><span class="token punctuation">(</span>system_io<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>unassigned_io_ops<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">"io"</span><span class="token punctuation">,</span>
                          <span class="token number">65536</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">address_space_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>address_space_io<span class="token punctuation">,</span> system_io<span class="token punctuation">,</span> <span class="token string">"I/O"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里，对于系统内存区域system_memory和用于I/O的内存区域system_io，我们都进行了初始化，并且关联到了相应的地址空间AddressSpace。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">address_space_init</span><span class="token punctuation">(</span>AddressSpace <span class="token operator">*</span>as<span class="token punctuation">,</span> MemoryRegion <span class="token operator">*</span>root<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">memory_region_ref</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    as<span class="token operator">-&gt;</span>root <span class="token operator">=</span> root<span class="token punctuation">;</span>
    as<span class="token operator">-&gt;</span>current_map <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    as<span class="token operator">-&gt;</span>ioeventfd_nb <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    as<span class="token operator">-&gt;</span>ioeventfds <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token function">QTAILQ_INIT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>as<span class="token operator">-&gt;</span>listeners<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">QTAILQ_INSERT_TAIL</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>address_spaces<span class="token punctuation">,</span> as<span class="token punctuation">,</span> address_spaces_link<span class="token punctuation">)</span><span class="token punctuation">;</span>
    as<span class="token operator">-&gt;</span>name <span class="token operator">=</span> <span class="token function">g_strdup</span><span class="token punctuation">(</span>name <span class="token operator">?</span> name <span class="token operator">:</span> <span class="token string">"anonymous"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">address_space_update_topology</span><span class="token punctuation">(</span>as<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">address_space_update_ioeventfds</span><span class="token punctuation">(</span>as<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于系统内存地址空间address_space_memory，我们需要把它里面内存区域的根root设置为system_memory。</p>
<p>另外，在这里，我们还调用了address_space_update_topology。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">address_space_update_topology</span><span class="token punctuation">(</span>AddressSpace <span class="token operator">*</span>as<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    MemoryRegion <span class="token operator">*</span>physmr <span class="token operator">=</span> <span class="token function">memory_region_get_flatview_root</span><span class="token punctuation">(</span>as<span class="token operator">-&gt;</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">flatviews_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">g_hash_table_lookup</span><span class="token punctuation">(</span>flat_views<span class="token punctuation">,</span> physmr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">generate_memory_topology</span><span class="token punctuation">(</span>physmr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">address_space_set_flatview</span><span class="token punctuation">(</span>as<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">address_space_set_flatview</span><span class="token punctuation">(</span>AddressSpace <span class="token operator">*</span>as<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    FlatView <span class="token operator">*</span>old_view <span class="token operator">=</span> <span class="token function">address_space_to_flatview</span><span class="token punctuation">(</span>as<span class="token punctuation">)</span><span class="token punctuation">;</span>
    MemoryRegion <span class="token operator">*</span>physmr <span class="token operator">=</span> <span class="token function">memory_region_get_flatview_root</span><span class="token punctuation">(</span>as<span class="token operator">-&gt;</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    FlatView <span class="token operator">*</span>new_view <span class="token operator">=</span> <span class="token function">g_hash_table_lookup</span><span class="token punctuation">(</span>flat_views<span class="token punctuation">,</span> physmr<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>old_view <span class="token operator">==</span> new_view<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">QTAILQ_EMPTY</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>as<span class="token operator">-&gt;</span>listeners<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        FlatView tmpview <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span>nr <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token operator">*</span>old_view2 <span class="token operator">=</span> old_view<span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>old_view2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            old_view2 <span class="token operator">=</span> <span class="token operator">&amp;</span>tmpview<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">address_space_update_topology_pass</span><span class="token punctuation">(</span>as<span class="token punctuation">,</span> old_view2<span class="token punctuation">,</span> new_view<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">address_space_update_topology_pass</span><span class="token punctuation">(</span>as<span class="token punctuation">,</span> old_view2<span class="token punctuation">,</span> new_view<span class="token punctuation">,</span> true<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* Writes are protected by the BQL.  */</span>
    <span class="token function">atomic_rcu_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>as<span class="token operator">-&gt;</span>current_map<span class="token punctuation">,</span> new_view<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面会生成AddressSpace的flatview。flatview是什么意思呢？</p>
<p>我们可以看到，在AddressSpace里面，除了树形结构的MemoryRegion之外，还有一个flatview结构，其实这个结构就是把这样一个树形的内存结构变成平的内存结构。因为树形内存结构比较容易管理，但是平的内存结构，比较方便和内核里面通信，来请求物理内存。虽然操作系统内核里面也是用树形结构来表示内存区域的，但是用户态向内核申请内存的时候，会按照平的、连续的模式进行申请。这里，qemu在用户态，所以要做这样一个转换。</p>
<p>在address_space_set_flatview中，我们将老的flatview和新的flatview进行比较。如果不同，说明内存结构发生了变化，会调用address_space_update_topology_pass-&gt;MEMORY_LISTENER_UPDATE_REGION-&gt;MEMORY_LISTENER_CALL。</p>
<p>这里面调用所有的listener。但是，这个逻辑这里不会执行的。这是因为这里内存处于初始化的阶段，全局的flat_views里面肯定找不到。因而generate_memory_topology第一次生成了FlatView，然后才调用了address_space_set_flatview。这里面，老的flatview和新的flatview一定是一样的。</p>
<p>但是，请你记住这个逻辑，到这里我们还没解析qemu有关内存的参数，所以这里添加的MemoryRegion虽然是一个根，但是是空的，是为了管理使用的，后面真的添加内存的时候，这个逻辑还会调用到。</p>
<p>我们再回到qemu启动的main函数中。接下来的初始化过程会调用pc_init1。在这里面，对于CPU虚拟化，我们会调用pc_cpus_init。这个我们在上一节已经讲过了。另外，pc_init1还会调用pc_memory_init，进行内存的虚拟化，我们这里解析这一部分。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">pc_memory_init</span><span class="token punctuation">(</span>PCMachineState <span class="token operator">*</span>pcms<span class="token punctuation">,</span>
                    MemoryRegion <span class="token operator">*</span>system_memory<span class="token punctuation">,</span>
                    MemoryRegion <span class="token operator">*</span>rom_memory<span class="token punctuation">,</span>
                    MemoryRegion <span class="token operator">*</span><span class="token operator">*</span>ram_memory<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> linux_boot<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
    MemoryRegion <span class="token operator">*</span>ram<span class="token punctuation">,</span> <span class="token operator">*</span>option_rom_mr<span class="token punctuation">;</span>
    MemoryRegion <span class="token operator">*</span>ram_below_4g<span class="token punctuation">,</span> <span class="token operator">*</span>ram_above_4g<span class="token punctuation">;</span>
    FWCfgState <span class="token operator">*</span>fw_cfg<span class="token punctuation">;</span>
    MachineState <span class="token operator">*</span>machine <span class="token operator">=</span> <span class="token function">MACHINE</span><span class="token punctuation">(</span>pcms<span class="token punctuation">)</span><span class="token punctuation">;</span>
    PCMachineClass <span class="token operator">*</span>pcmc <span class="token operator">=</span> <span class="token function">PC_MACHINE_GET_CLASS</span><span class="token punctuation">(</span>pcms<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* Allocate RAM.  We allocate it as a single memory region and use
     * aliases to address portions of it, mostly for backwards compatibility with older qemus that used qemu_ram_alloc().
     */</span>
    ram <span class="token operator">=</span> <span class="token function">g_malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>ram<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">memory_region_allocate_system_memory</span><span class="token punctuation">(</span>ram<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">"pc.ram"</span><span class="token punctuation">,</span>
                                         machine<span class="token operator">-&gt;</span>ram_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>ram_memory <span class="token operator">=</span> ram<span class="token punctuation">;</span>
    ram_below_4g <span class="token operator">=</span> <span class="token function">g_malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>ram_below_4g<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">memory_region_init_alias</span><span class="token punctuation">(</span>ram_below_4g<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">"ram-below-4g"</span><span class="token punctuation">,</span> ram<span class="token punctuation">,</span>
                             <span class="token number">0</span><span class="token punctuation">,</span> pcms<span class="token operator">-&gt;</span>below_4g_mem_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">memory_region_add_subregion</span><span class="token punctuation">(</span>system_memory<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> ram_below_4g<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">e820_add_entry</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> pcms<span class="token operator">-&gt;</span>below_4g_mem_size<span class="token punctuation">,</span> E820_RAM<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pcms<span class="token operator">-&gt;</span>above_4g_mem_size <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ram_above_4g <span class="token operator">=</span> <span class="token function">g_malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>ram_above_4g<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">memory_region_init_alias</span><span class="token punctuation">(</span>ram_above_4g<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">"ram-above-4g"</span><span class="token punctuation">,</span> ram<span class="token punctuation">,</span> pcms<span class="token operator">-&gt;</span>below_4g_mem_size<span class="token punctuation">,</span> pcms<span class="token operator">-&gt;</span>above_4g_mem_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">memory_region_add_subregion</span><span class="token punctuation">(</span>system_memory<span class="token punctuation">,</span> <span class="token number">0x100000000ULL</span><span class="token punctuation">,</span>
                                    ram_above_4g<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">e820_add_entry</span><span class="token punctuation">(</span><span class="token number">0x100000000ULL</span><span class="token punctuation">,</span> pcms<span class="token operator">-&gt;</span>above_4g_mem_size<span class="token punctuation">,</span> E820_RAM<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在pc_memory_init中，我们已经知道了虚拟机要申请的内存ram_size，于是通过memory_region_allocate_system_memory来申请内存。</p>
<p>接下来的调用链为：memory_region_allocate_system_memory-&gt;allocate_system_memory_nonnuma-&gt;memory_region_init_ram_nomigrate-&gt;memory_region_init_ram_shared_nomigrate。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">memory_region_init_ram_shared_nomigrate</span><span class="token punctuation">(</span>MemoryRegion <span class="token operator">*</span>mr<span class="token punctuation">,</span>
                                             Object <span class="token operator">*</span>owner<span class="token punctuation">,</span>
                                             <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span>
                                             uint64_t size<span class="token punctuation">,</span>
                                             bool share<span class="token punctuation">,</span>
                                             Error <span class="token operator">*</span><span class="token operator">*</span>errp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Error <span class="token operator">*</span>err <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token function">memory_region_init</span><span class="token punctuation">(</span>mr<span class="token punctuation">,</span> owner<span class="token punctuation">,</span> name<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    mr<span class="token operator">-&gt;</span>ram <span class="token operator">=</span> true<span class="token punctuation">;</span>
    mr<span class="token operator">-&gt;</span>terminates <span class="token operator">=</span> true<span class="token punctuation">;</span>
    mr<span class="token operator">-&gt;</span>destructor <span class="token operator">=</span> memory_region_destructor_ram<span class="token punctuation">;</span>
    mr<span class="token operator">-&gt;</span>ram_block <span class="token operator">=</span> <span class="token function">qemu_ram_alloc</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> share<span class="token punctuation">,</span> mr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span>
RAMBlock <span class="token operator">*</span><span class="token function">qemu_ram_alloc_internal</span><span class="token punctuation">(</span>ram_addr_t size<span class="token punctuation">,</span> ram_addr_t max_size<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>resized<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span>uint64_t length<span class="token punctuation">,</span><span class="token keyword">void</span> <span class="token operator">*</span>host<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">void</span> <span class="token operator">*</span>host<span class="token punctuation">,</span> bool resizeable<span class="token punctuation">,</span> bool share<span class="token punctuation">,</span>MemoryRegion <span class="token operator">*</span>mr<span class="token punctuation">,</span> Error <span class="token operator">*</span><span class="token operator">*</span>errp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    RAMBlock <span class="token operator">*</span>new_block<span class="token punctuation">;</span>
    size <span class="token operator">=</span> <span class="token function">HOST_PAGE_ALIGN</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    max_size <span class="token operator">=</span> <span class="token function">HOST_PAGE_ALIGN</span><span class="token punctuation">(</span>max_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    new_block <span class="token operator">=</span> <span class="token function">g_malloc0</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>new_block<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    new_block<span class="token operator">-&gt;</span>mr <span class="token operator">=</span> mr<span class="token punctuation">;</span>
    new_block<span class="token operator">-&gt;</span>resized <span class="token operator">=</span> resized<span class="token punctuation">;</span>
    new_block<span class="token operator">-&gt;</span>used_length <span class="token operator">=</span> size<span class="token punctuation">;</span>
    new_block<span class="token operator">-&gt;</span>max_length <span class="token operator">=</span> max_size<span class="token punctuation">;</span>
    new_block<span class="token operator">-&gt;</span>fd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    new_block<span class="token operator">-&gt;</span>page_size <span class="token operator">=</span> <span class="token function">getpagesize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    new_block<span class="token operator">-&gt;</span>host <span class="token operator">=</span> host<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">ram_block_add</span><span class="token punctuation">(</span>new_block<span class="token punctuation">,</span> <span class="token operator">&amp;</span>local_err<span class="token punctuation">,</span> share<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> new_block<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">ram_block_add</span><span class="token punctuation">(</span>RAMBlock <span class="token operator">*</span>new_block<span class="token punctuation">,</span> Error <span class="token operator">*</span><span class="token operator">*</span>errp<span class="token punctuation">,</span> bool shared<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    RAMBlock <span class="token operator">*</span>block<span class="token punctuation">;</span>
    RAMBlock <span class="token operator">*</span>last_block <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    ram_addr_t old_ram_size<span class="token punctuation">,</span> new_ram_size<span class="token punctuation">;</span>
    Error <span class="token operator">*</span>err <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    old_ram_size <span class="token operator">=</span> <span class="token function">last_ram_page</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    new_block<span class="token operator">-&gt;</span>offset <span class="token operator">=</span> <span class="token function">find_ram_offset</span><span class="token punctuation">(</span>new_block<span class="token operator">-&gt;</span>max_length<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>new_block<span class="token operator">-&gt;</span>host<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        new_block<span class="token operator">-&gt;</span>host <span class="token operator">=</span> <span class="token function">phys_mem_alloc</span><span class="token punctuation">(</span>new_block<span class="token operator">-&gt;</span>max_length<span class="token punctuation">,</span> <span class="token operator">&amp;</span>new_block<span class="token operator">-&gt;</span>mr<span class="token operator">-&gt;</span>align<span class="token punctuation">,</span> shared<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面，我们会调用qemu_ram_alloc，创建一个RAMBlock用来表示内存块。这里面调用ram_block_add-&gt;phys_mem_alloc。phys_mem_alloc是一个函数指针，指向函数qemu_anon_ram_alloc，这里面调用qemu_ram_mmap，在qemu_ram_mmap中调用mmap分配内存。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>phys_mem_alloc<span class="token punctuation">)</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">,</span> uint64_t <span class="token operator">*</span>align<span class="token punctuation">,</span> bool shared<span class="token punctuation">)</span> <span class="token operator">=</span> qemu_anon_ram_alloc<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">qemu_anon_ram_alloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">,</span> uint64_t <span class="token operator">*</span>alignment<span class="token punctuation">,</span> bool shared<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    size_t align <span class="token operator">=</span> QEMU_VMALLOC_ALIGN<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token function">qemu_ram_mmap</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> size<span class="token punctuation">,</span> align<span class="token punctuation">,</span> shared<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>alignment<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">*</span>alignment <span class="token operator">=</span> align<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> ptr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">qemu_ram_mmap</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> size_t size<span class="token punctuation">,</span> size_t align<span class="token punctuation">,</span> bool shared<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> flags<span class="token punctuation">;</span>
    <span class="token keyword">int</span> guardfd<span class="token punctuation">;</span>
    size_t offset<span class="token punctuation">;</span>
    size_t pagesize<span class="token punctuation">;</span>
    size_t total<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>guardptr<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    total <span class="token operator">=</span> size <span class="token operator">+</span> align<span class="token punctuation">;</span>
    guardfd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    pagesize <span class="token operator">=</span> <span class="token function">getpagesize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    flags <span class="token operator">=</span> MAP_PRIVATE <span class="token operator">|</span> MAP_ANONYMOUS<span class="token punctuation">;</span>
    guardptr <span class="token operator">=</span> <span class="token function">mmap</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> total<span class="token punctuation">,</span> PROT_NONE<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> guardfd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    flags <span class="token operator">=</span> MAP_FIXED<span class="token punctuation">;</span>
    flags <span class="token operator">|=</span> fd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">?</span> MAP_ANONYMOUS <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
    flags <span class="token operator">|=</span> shared <span class="token operator">?</span> MAP_SHARED <span class="token operator">:</span> MAP_PRIVATE<span class="token punctuation">;</span>
    offset <span class="token operator">=</span> <span class="token function">QEMU_ALIGN_UP</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uintptr_t<span class="token punctuation">)</span>guardptr<span class="token punctuation">,</span> align<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span>uintptr_t<span class="token punctuation">)</span>guardptr<span class="token punctuation">;</span>
    ptr <span class="token operator">=</span> <span class="token function">mmap</span><span class="token punctuation">(</span>guardptr <span class="token operator">+</span> offset<span class="token punctuation">,</span> size<span class="token punctuation">,</span> PROT_READ <span class="token operator">|</span> PROT_WRITE<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> ptr<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们回到pc_memory_init，通过memory_region_allocate_system_memory申请到内存以后，为了兼容过去的版本，我们分成两个MemoryRegion进行管理，一个是ram_below_4g，一个是ram_above_4g。对于这两个MemoryRegion，我们都会初始化一个alias，也即别名，意思是说，两个MemoryRegion其实都指向memory_region_allocate_system_memory分配的内存，只不过分成两个部分，起两个别名指向不同的区域。</p>
<p>这两部分MemoryRegion都会调用memory_region_add_subregion，将这两部分作为子的内存区域添加到system_memory这棵树上。</p>
<p>接下来的调用链为：memory_region_add_subregion-&gt;memory_region_add_subregion_common-&gt;memory_region_update_container_subregions。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">memory_region_update_container_subregions</span><span class="token punctuation">(</span>MemoryRegion <span class="token operator">*</span>subregion<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    MemoryRegion <span class="token operator">*</span>mr <span class="token operator">=</span> subregion<span class="token operator">-&gt;</span>container<span class="token punctuation">;</span>
    MemoryRegion <span class="token operator">*</span>other<span class="token punctuation">;</span>

    <span class="token function">memory_region_transaction_begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">memory_region_ref</span><span class="token punctuation">(</span>subregion<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">QTAILQ_FOREACH</span><span class="token punctuation">(</span>other<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mr<span class="token operator">-&gt;</span>subregions<span class="token punctuation">,</span> subregions_link<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>subregion<span class="token operator">-&gt;</span>priority <span class="token operator">&gt;=</span> other<span class="token operator">-&gt;</span>priority<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">QTAILQ_INSERT_BEFORE</span><span class="token punctuation">(</span>other<span class="token punctuation">,</span> subregion<span class="token punctuation">,</span> subregions_link<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">goto</span> done<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">QTAILQ_INSERT_TAIL</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mr<span class="token operator">-&gt;</span>subregions<span class="token punctuation">,</span> subregion<span class="token punctuation">,</span> subregions_link<span class="token punctuation">)</span><span class="token punctuation">;</span>
done<span class="token operator">:</span>
    memory_region_update_pending <span class="token operator">|=</span> mr<span class="token operator">-&gt;</span>enabled <span class="token operator">&amp;&amp;</span> subregion<span class="token operator">-&gt;</span>enabled<span class="token punctuation">;</span>
    <span class="token function">memory_region_transaction_commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在memory_region_update_container_subregions中，我们会将子区域放到链表中，然后调用memory_region_transaction_commit。在这里面，我们会调用address_space_set_flatview。因为内存区域变了，flatview也会变，就像上面分析过的一样，listener会被调用。</p>
<p>因为添加了一个MemoryRegion，region_add也即kvm_region_add。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">kvm_region_add</span><span class="token punctuation">(</span>MemoryListener <span class="token operator">*</span>listener<span class="token punctuation">,</span>
                           MemoryRegionSection <span class="token operator">*</span>section<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    KVMMemoryListener <span class="token operator">*</span>kml <span class="token operator">=</span> <span class="token function">container_of</span><span class="token punctuation">(</span>listener<span class="token punctuation">,</span> KVMMemoryListener<span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">kvm_set_phys_mem</span><span class="token punctuation">(</span>kml<span class="token punctuation">,</span> section<span class="token punctuation">,</span> true<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">kvm_set_phys_mem</span><span class="token punctuation">(</span>KVMMemoryListener <span class="token operator">*</span>kml<span class="token punctuation">,</span>
                             MemoryRegionSection <span class="token operator">*</span>section<span class="token punctuation">,</span> bool add<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    KVMSlot <span class="token operator">*</span>mem<span class="token punctuation">;</span>
    <span class="token keyword">int</span> err<span class="token punctuation">;</span>
    MemoryRegion <span class="token operator">*</span>mr <span class="token operator">=</span> section<span class="token operator">-&gt;</span>mr<span class="token punctuation">;</span>
    bool writeable <span class="token operator">=</span> <span class="token operator">!</span>mr<span class="token operator">-&gt;</span>readonly <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>mr<span class="token operator">-&gt;</span>rom_device<span class="token punctuation">;</span>
    hwaddr start_addr<span class="token punctuation">,</span> size<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ram<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    size <span class="token operator">=</span> <span class="token function">kvm_align_section</span><span class="token punctuation">(</span>section<span class="token punctuation">,</span> <span class="token operator">&amp;</span>start_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* use aligned delta to align the ram address */</span>
    ram <span class="token operator">=</span> <span class="token function">memory_region_get_ram_ptr</span><span class="token punctuation">(</span>mr<span class="token punctuation">)</span> <span class="token operator">+</span> section<span class="token operator">-&gt;</span>offset_within_region <span class="token operator">+</span> <span class="token punctuation">(</span>start_addr <span class="token operator">-</span> section<span class="token operator">-&gt;</span>offset_within_address_space<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* register the new slot */</span>
    mem <span class="token operator">=</span> <span class="token function">kvm_alloc_slot</span><span class="token punctuation">(</span>kml<span class="token punctuation">)</span><span class="token punctuation">;</span>
    mem<span class="token operator">-&gt;</span>memory_size <span class="token operator">=</span> size<span class="token punctuation">;</span>
    mem<span class="token operator">-&gt;</span>start_addr <span class="token operator">=</span> start_addr<span class="token punctuation">;</span>
    mem<span class="token operator">-&gt;</span>ram <span class="token operator">=</span> ram<span class="token punctuation">;</span>
    mem<span class="token operator">-&gt;</span>flags <span class="token operator">=</span> <span class="token function">kvm_mem_flags</span><span class="token punctuation">(</span>mr<span class="token punctuation">)</span><span class="token punctuation">;</span>

    err <span class="token operator">=</span> <span class="token function">kvm_set_user_memory_region</span><span class="token punctuation">(</span>kml<span class="token punctuation">,</span> mem<span class="token punctuation">,</span> true<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>kvm_region_add调用的是kvm_set_phys_mem，这里面分配一个用于放这块那内存的KVMSlot结构，就像一个内存条一样，当然这是在用户态模拟出来的内存条，放在KVMState结构里面。这个结构是我们上一节创建虚拟机的时候创建的。</p>
<p>接下来，kvm_set_user_memory_region就会将用户态模拟出来的内存条，和内核中的KVM模块关联起来。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">kvm_set_user_memory_region</span><span class="token punctuation">(</span>KVMMemoryListener <span class="token operator">*</span>kml<span class="token punctuation">,</span> KVMSlot <span class="token operator">*</span>slot<span class="token punctuation">,</span> bool new<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    KVMState <span class="token operator">*</span>s <span class="token operator">=</span> kvm_state<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">kvm_userspace_memory_region</span> mem<span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>

    mem<span class="token punctuation">.</span>slot <span class="token operator">=</span> slot<span class="token operator">-&gt;</span>slot <span class="token operator">|</span> <span class="token punctuation">(</span>kml<span class="token operator">-&gt;</span>as_id <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    mem<span class="token punctuation">.</span>guest_phys_addr <span class="token operator">=</span> slot<span class="token operator">-&gt;</span>start_addr<span class="token punctuation">;</span>
    mem<span class="token punctuation">.</span>userspace_addr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span>slot<span class="token operator">-&gt;</span>ram<span class="token punctuation">;</span>
    mem<span class="token punctuation">.</span>flags <span class="token operator">=</span> slot<span class="token operator">-&gt;</span>flags<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    mem<span class="token punctuation">.</span>memory_size <span class="token operator">=</span> slot<span class="token operator">-&gt;</span>memory_size<span class="token punctuation">;</span>
    ret <span class="token operator">=</span> <span class="token function">kvm_vm_ioctl</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> KVM_SET_USER_MEMORY_REGION<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mem<span class="token punctuation">)</span><span class="token punctuation">;</span>
    slot<span class="token operator">-&gt;</span>old_flags <span class="token operator">=</span> mem<span class="token punctuation">.</span>flags<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>终于，在这里，我们又看到了可以和内核通信的kvm_vm_ioctl。我们来看内核收到KVM_SET_USER_MEMORY_REGION会做哪些事情。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">kvm_vm_ioctl</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>filp<span class="token punctuation">,</span>
               <span class="token keyword">unsigned</span> <span class="token keyword">int</span> ioctl<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> arg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">kvm</span> <span class="token operator">*</span>kvm <span class="token operator">=</span> filp<span class="token operator">-&gt;</span>private_data<span class="token punctuation">;</span>
    <span class="token keyword">void</span> __user <span class="token operator">*</span>argp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> __user <span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">;</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>ioctl<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> KVM_SET_USER_MEMORY_REGION<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">kvm_userspace_memory_region</span> kvm_userspace_mem<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_from_user</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kvm_userspace_mem<span class="token punctuation">,</span> argp<span class="token punctuation">,</span>
                        <span class="token keyword">sizeof</span><span class="token punctuation">(</span>kvm_userspace_mem<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">goto</span> out<span class="token punctuation">;</span>
        r <span class="token operator">=</span> <span class="token function">kvm_vm_ioctl_set_memory_region</span><span class="token punctuation">(</span>kvm<span class="token punctuation">,</span> <span class="token operator">&amp;</span>kvm_userspace_mem<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来的调用链为：kvm_vm_ioctl_set_memory_region-&gt;kvm_set_memory_region-&gt;__kvm_set_memory_region。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">__kvm_set_memory_region</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kvm</span> <span class="token operator">*</span>kvm<span class="token punctuation">,</span>
                <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">kvm_userspace_memory_region</span> <span class="token operator">*</span>mem<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> r<span class="token punctuation">;</span>
    gfn_t base_gfn<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> npages<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">kvm_memory_slot</span> <span class="token operator">*</span>slot<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">kvm_memory_slot</span> old<span class="token punctuation">,</span> new<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">kvm_memslots</span> <span class="token operator">*</span>slots <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">*</span>old_memslots<span class="token punctuation">;</span>
    <span class="token keyword">int</span> as_id<span class="token punctuation">,</span> id<span class="token punctuation">;</span>
    <span class="token keyword">enum</span> <span class="token class-name">kvm_mr_change</span> change<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    as_id <span class="token operator">=</span> mem<span class="token operator">-&gt;</span>slot <span class="token operator">&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">;</span>
    id <span class="token operator">=</span> <span class="token punctuation">(</span>u16<span class="token punctuation">)</span>mem<span class="token operator">-&gt;</span>slot<span class="token punctuation">;</span>

    slot <span class="token operator">=</span> <span class="token function">id_to_memslot</span><span class="token punctuation">(</span><span class="token function">__kvm_memslots</span><span class="token punctuation">(</span>kvm<span class="token punctuation">,</span> as_id<span class="token punctuation">)</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    base_gfn <span class="token operator">=</span> mem<span class="token operator">-&gt;</span>guest_phys_addr <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">;</span>
    npages <span class="token operator">=</span> mem<span class="token operator">-&gt;</span>memory_size <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    new <span class="token operator">=</span> old <span class="token operator">=</span> <span class="token operator">*</span>slot<span class="token punctuation">;</span>

    new<span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
    new<span class="token punctuation">.</span>base_gfn <span class="token operator">=</span> base_gfn<span class="token punctuation">;</span>
    new<span class="token punctuation">.</span>npages <span class="token operator">=</span> npages<span class="token punctuation">;</span>
    new<span class="token punctuation">.</span>flags <span class="token operator">=</span> mem<span class="token operator">-&gt;</span>flags<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>change <span class="token operator">==</span> KVM_MR_CREATE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        new<span class="token punctuation">.</span>userspace_addr <span class="token operator">=</span> mem<span class="token operator">-&gt;</span>userspace_addr<span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">kvm_arch_create_memslot</span><span class="token punctuation">(</span>kvm<span class="token punctuation">,</span> <span class="token operator">&amp;</span>new<span class="token punctuation">,</span> npages<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">goto</span> out_free<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    slots <span class="token operator">=</span> <span class="token function">kvzalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kvm_memslots</span><span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">memcpy</span><span class="token punctuation">(</span>slots<span class="token punctuation">,</span> <span class="token function">__kvm_memslots</span><span class="token punctuation">(</span>kvm<span class="token punctuation">,</span> as_id<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kvm_memslots</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    r <span class="token operator">=</span> <span class="token function">kvm_arch_prepare_memory_region</span><span class="token punctuation">(</span>kvm<span class="token punctuation">,</span> <span class="token operator">&amp;</span>new<span class="token punctuation">,</span> mem<span class="token punctuation">,</span> change<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">update_memslots</span><span class="token punctuation">(</span>slots<span class="token punctuation">,</span> <span class="token operator">&amp;</span>new<span class="token punctuation">)</span><span class="token punctuation">;</span>
    old_memslots <span class="token operator">=</span> <span class="token function">install_new_memslots</span><span class="token punctuation">(</span>kvm<span class="token punctuation">,</span> as_id<span class="token punctuation">,</span> slots<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">kvm_arch_commit_memory_region</span><span class="token punctuation">(</span>kvm<span class="token punctuation">,</span> mem<span class="token punctuation">,</span> <span class="token operator">&amp;</span>old<span class="token punctuation">,</span> <span class="token operator">&amp;</span>new<span class="token punctuation">,</span> change<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在用户态每个KVMState有多个KVMSlot，在内核里面，同样每个struct kvm也有多个struct kvm_memory_slot，两者是对应起来的。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//用户态</span>
<span class="token keyword">struct</span> <span class="token class-name">KVMState</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">int</span> nr_slots<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    KVMMemoryListener memory_listener<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">KVMMemoryListener</span> <span class="token punctuation">{</span>
    MemoryListener listener<span class="token punctuation">;</span>
    KVMSlot <span class="token operator">*</span>slots<span class="token punctuation">;</span>
    <span class="token keyword">int</span> as_id<span class="token punctuation">;</span>
<span class="token punctuation">}</span> KVMMemoryListener

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">KVMSlot</span>
<span class="token punctuation">{</span>
    hwaddr start_addr<span class="token punctuation">;</span>
    ram_addr_t memory_size<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ram<span class="token punctuation">;</span>
    <span class="token keyword">int</span> slot<span class="token punctuation">;</span>
    <span class="token keyword">int</span> flags<span class="token punctuation">;</span>
    <span class="token keyword">int</span> old_flags<span class="token punctuation">;</span>
<span class="token punctuation">}</span> KVMSlot<span class="token punctuation">;</span>

<span class="token comment">//内核态</span>
<span class="token keyword">struct</span> <span class="token class-name">kvm</span> <span class="token punctuation">{</span>
    spinlock_t mmu_lock<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">mutex</span> slots_lock<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>mm<span class="token punctuation">;</span> <span class="token comment">/* userspace tied to this vm */</span>
    <span class="token keyword">struct</span> <span class="token class-name">kvm_memslots</span> __rcu <span class="token operator">*</span>memslots<span class="token punctuation">[</span>KVM_ADDRESS_SPACE_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">kvm_memslots</span> <span class="token punctuation">{</span>
    u64 generation<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">kvm_memory_slot</span> memslots<span class="token punctuation">[</span>KVM_MEM_SLOTS_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">/* The mapping table from slot id to the index in memslots[]. */</span>
    <span class="token keyword">short</span> id_to_index<span class="token punctuation">[</span>KVM_MEM_SLOTS_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span>
    atomic_t lru_slot<span class="token punctuation">;</span>
    <span class="token keyword">int</span> used_slots<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">kvm_memory_slot</span> <span class="token punctuation">{</span>
    gfn_t base_gfn<span class="token punctuation">;</span><span class="token comment">//根据guest_phys_addr计算</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> npages<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span>dirty_bitmap<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">kvm_arch_memory_slot</span> arch<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> userspace_addr<span class="token punctuation">;</span>
    u32 flags<span class="token punctuation">;</span>
    <span class="token keyword">short</span> id<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>并且，id_to_memslot函数可以根据用户态的slot号得到内核态的slot结构。</p>
<p>如果传进来的参数是KVM_MR_CREATE，表示要创建一个新的内存条，就会调用kvm_arch_create_memslot来创建kvm_memory_slot的成员kvm_arch_memory_slot。</p>
<p>接下来就是创建kvm_memslots结构，填充这个结构，然后通过install_new_memslots将这个新的内存条，添加到struct kvm结构中。</p>
<p>至此，用户态的内存结构和内核态的内存结构算是对应了起来。</p>
<h4 id="46-2-页面分配和映射"><a href="#46-2-页面分配和映射" class="headerlink" title="46.2 页面分配和映射"></a>46.2 页面分配和映射</h4><p>上面对于内存的管理，还只是停留在元数据的管理。对于内存的分配与映射，我们还没有涉及，接下来，我们就来看看，页面是如何进行分配和映射的。</p>
<p>上面咱们说了，内存映射对于虚拟机来讲是一件非常麻烦的事情，从GVA到GPA到HVA到HPA，性能很差，为了解决这个问题，有两种主要的思路。</p>
<h4 id="46-3-影子页表"><a href="#46-3-影子页表" class="headerlink" title="46.3 影子页表"></a>46.3 影子页表</h4><p>第一种方式就是软件的方式，<strong>影子页表 （Shadow Page Table）</strong>。</p>
<p>按照咱们在内存管理那一节讲的，内存映射要通过页表来管理，页表地址应该放在cr3寄存器里面。本来的过程是，客户机要通过cr3找到客户机的页表，实现从GVA到GPA的转换，然后在宿主机上，要通过cr3找到宿主机的页表，实现从HVA到HPA的转换。</p>
<p>为了实现客户机虚拟地址空间到宿主机物理地址空间的直接映射。客户机中每个进程都有自己的虚拟地址空间，所以KVM需要为客户机中的每个进程页表都要维护一套相应的影子页表。</p>
<p>在客户机访问内存时，使用的不是客户机的原来的页表，而是这个页表对应的影子页表，从而实现了从客户机虚拟地址到宿主机物理地址的直接转换。而且，在TLB和CPU 缓存上缓存的是来自影子页表中客户机虚拟地址和宿主机物理地址之间的映射，也因此提高了缓存的效率。</p>
<p>但是影子页表的引入也意味着 KVM 需要为每个客户机的每个进程的页表都要维护一套相应的影子页表，内存占用比较大，而且客户机页表和和影子页表也需要进行实时同步。</p>
<h4 id="46-4-扩展页表"><a href="#46-4-扩展页表" class="headerlink" title="46.4 扩展页表"></a>46.4 扩展页表</h4><p>于是就有了第二种方式，就是硬件的方式，Intel的EPT（Extent Page Table，扩展页表）技术。</p>
<p>EPT在原有客户机页表对客户机虚拟地址到客户机物理地址映射的基础上，又引入了 EPT页表来实现客户机物理地址到宿主机物理地址的另一次映射。客户机运行时，客户机页表被载入 CR3，而EPT页表被载入专门的EPT 页表指针寄存器 EPTP。</p>
<p>有了EPT，在客户机物理地址到宿主机物理地址转换的过程中，缺页会产生EPT 缺页异常。KVM首先根据引起异常的客户机物理地址，映射到对应的宿主机虚拟地址，然后为此虚拟地址分配新的物理页，最后 KVM 再更新 EPT 页表，建立起引起异常的客户机物理地址到宿主机物理地址之间的映射。</p>
<p>KVM 只需为每个客户机维护一套 EPT 页表，也大大减少了内存的开销。</p>
<p>这里，我们重点看第二种方式。因为使用了EPT之后，客户机里面的页表映射，也即从GVA到GPA的转换，还是用传统的方式，和在内存管理那一章讲的没有什么区别。而EPT重点帮我们解决的就是从GPA到HPA的转换问题。因为要经过两次页表，所以EPT又tdp(two dimentional paging)。</p>
<p>EPT的页表结构也是分为四层，EPT Pointer （EPTP）指向PML4的首地址。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/EPT的页表结构.jpg" alt="EPT的页表结构.jpg"></p>
<p>管理物理页面的Page结构和咱们讲内存管理那一章是一样的。EPT页表也需要存放在一个页中，这些页要用kvm_mmu_page这个结构来管理。</p>
<p>当一个虚拟机运行，进入客户机模式的时候，我们上一节解析过，它会调用vcpu_enter_guest函数，这里面会调用kvm_mmu_reload-&gt;kvm_mmu_load。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">kvm_mmu_load</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kvm_vcpu</span> <span class="token operator">*</span>vcpu<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    r <span class="token operator">=</span> <span class="token function">mmu_topup_memory_caches</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
    r <span class="token operator">=</span> <span class="token function">mmu_alloc_roots</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">kvm_mmu_sync_roots</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* set_cr3() should ensure TLB has been flushed */</span>
    vcpu<span class="token operator">-&gt;</span>arch<span class="token punctuation">.</span>mmu<span class="token punctuation">.</span><span class="token function">set_cr3</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">,</span> vcpu<span class="token operator">-&gt;</span>arch<span class="token punctuation">.</span>mmu<span class="token punctuation">.</span>root_hpa<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">mmu_alloc_roots</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kvm_vcpu</span> <span class="token operator">*</span>vcpu<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>vcpu<span class="token operator">-&gt;</span>arch<span class="token punctuation">.</span>mmu<span class="token punctuation">.</span>direct_map<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">mmu_alloc_direct_roots</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token function">mmu_alloc_shadow_roots</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">mmu_alloc_direct_roots</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kvm_vcpu</span> <span class="token operator">*</span>vcpu<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">kvm_mmu_page</span> <span class="token operator">*</span>sp<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> i<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>vcpu<span class="token operator">-&gt;</span>arch<span class="token punctuation">.</span>mmu<span class="token punctuation">.</span>shadow_root_level <span class="token operator">==</span> PT64_ROOT_LEVEL<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">spin_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vcpu<span class="token operator">-&gt;</span>kvm<span class="token operator">-&gt;</span>mmu_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">make_mmu_pages_available</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
        sp <span class="token operator">=</span> <span class="token function">kvm_mmu_get_page</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> PT64_ROOT_LEVEL<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> ACC_ALL<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">++</span>sp<span class="token operator">-&gt;</span>root_count<span class="token punctuation">;</span>
        <span class="token function">spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vcpu<span class="token operator">-&gt;</span>kvm<span class="token operator">-&gt;</span>mmu_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
        vcpu<span class="token operator">-&gt;</span>arch<span class="token punctuation">.</span>mmu<span class="token punctuation">.</span>root_hpa <span class="token operator">=</span> <span class="token function">__pa</span><span class="token punctuation">(</span>sp<span class="token operator">-&gt;</span>spt<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里构建的是页表的根部，也即顶级页表，并且设置cr3来刷新TLB。mmu_alloc_roots会调用mmu_alloc_direct_roots，因为我们用的是EPT模式，而非影子表。在mmu_alloc_direct_roots中，kvm_mmu_get_page会分配一个kvm_mmu_page，来存放顶级页表项。</p>
<p>接下来，当虚拟机真的要访问内存的时候，会发现有的页表没有建立，有的物理页没有分配，这都会触发缺页异常，在KVM里面会发送VM-Exit，从客户机模式转换为宿主机模式，来修复这个缺失的页表或者物理页。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">const</span> kvm_vmx_exit_handlers<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kvm_vcpu</span> <span class="token operator">*</span>vcpu<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>EXIT_REASON_EXCEPTION_NMI<span class="token punctuation">]</span>           <span class="token operator">=</span> handle_exception<span class="token punctuation">,</span>
    <span class="token punctuation">[</span>EXIT_REASON_EXTERNAL_INTERRUPT<span class="token punctuation">]</span>      <span class="token operator">=</span> handle_external_interrupt<span class="token punctuation">,</span>
    <span class="token punctuation">[</span>EXIT_REASON_IO_INSTRUCTION<span class="token punctuation">]</span>          <span class="token operator">=</span> handle_io<span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">[</span>EXIT_REASON_EPT_VIOLATION<span class="token punctuation">]</span>           <span class="token operator">=</span> handle_ept_violation<span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>咱们前面讲过，虚拟机退出客户机模式有很多种原因，例如接收到中断、接收到I/O等，EPT的缺页异常也是一种类型，我们称为EXIT_REASON_EPT_VIOLATION，对应的处理函数是handle_ept_violation。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">handle_ept_violation</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kvm_vcpu</span> <span class="token operator">*</span>vcpu<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    gpa_t gpa<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    gpa <span class="token operator">=</span> <span class="token function">vmcs_read64</span><span class="token punctuation">(</span>GUEST_PHYSICAL_ADDRESS<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    vcpu<span class="token operator">-&gt;</span>arch<span class="token punctuation">.</span>gpa_available <span class="token operator">=</span> true<span class="token punctuation">;</span>
    vcpu<span class="token operator">-&gt;</span>arch<span class="token punctuation">.</span>exit_qualification <span class="token operator">=</span> exit_qualification<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token function">kvm_mmu_page_fault</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">,</span> gpa<span class="token punctuation">,</span> error_code<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">kvm_mmu_page_fault</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kvm_vcpu</span> <span class="token operator">*</span>vcpu<span class="token punctuation">,</span> gva_t cr2<span class="token punctuation">,</span> u64 error_code<span class="token punctuation">,</span>
               <span class="token keyword">void</span> <span class="token operator">*</span>insn<span class="token punctuation">,</span> <span class="token keyword">int</span> insn_len<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    r <span class="token operator">=</span> vcpu<span class="token operator">-&gt;</span>arch<span class="token punctuation">.</span>mmu<span class="token punctuation">.</span><span class="token function">page_fault</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">,</span> cr2<span class="token punctuation">,</span> <span class="token function">lower_32_bits</span><span class="token punctuation">(</span>error_code<span class="token punctuation">)</span><span class="token punctuation">,</span>false<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在handle_ept_violation里面，我们从VMCS中得到没有解析成功的GPA，也即客户机的物理地址，然后调用kvm_mmu_page_fault，看为什么解析不成功。kvm_mmu_page_fault会调用page_fault函数，其实是tdp_page_fault函数。tdp的意思就是EPT，前面我们解释过了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">tdp_page_fault</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kvm_vcpu</span> <span class="token operator">*</span>vcpu<span class="token punctuation">,</span> gva_t gpa<span class="token punctuation">,</span> u32 error_code<span class="token punctuation">,</span> bool prefault<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    kvm_pfn_t pfn<span class="token punctuation">;</span>
    <span class="token keyword">int</span> r<span class="token punctuation">;</span>
    <span class="token keyword">int</span> level<span class="token punctuation">;</span>
    bool force_pt_level<span class="token punctuation">;</span>
    gfn_t gfn <span class="token operator">=</span> gpa <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> mmu_seq<span class="token punctuation">;</span>
    <span class="token keyword">int</span> write <span class="token operator">=</span> error_code <span class="token operator">&amp;</span> PFERR_WRITE_MASK<span class="token punctuation">;</span>
    bool map_writable<span class="token punctuation">;</span>

    r <span class="token operator">=</span> <span class="token function">mmu_topup_memory_caches</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
    level <span class="token operator">=</span> <span class="token function">mapping_level</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">,</span> gfn<span class="token punctuation">,</span> <span class="token operator">&amp;</span>force_pt_level<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">try_async_pf</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">,</span> prefault<span class="token punctuation">,</span> gfn<span class="token punctuation">,</span> gpa<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pfn<span class="token punctuation">,</span> write<span class="token punctuation">,</span> <span class="token operator">&amp;</span>map_writable<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">handle_abnormal_pfn</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> gfn<span class="token punctuation">,</span> pfn<span class="token punctuation">,</span> ACC_ALL<span class="token punctuation">,</span> <span class="token operator">&amp;</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> r<span class="token punctuation">;</span>

    <span class="token function">make_mmu_pages_available</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
    r <span class="token operator">=</span> <span class="token function">__direct_map</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">,</span> write<span class="token punctuation">,</span> map_writable<span class="token punctuation">,</span> level<span class="token punctuation">,</span> gfn<span class="token punctuation">,</span> pfn<span class="token punctuation">,</span> prefault<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>既然没有映射，就应该加上映射，tdp_page_fault就是干这个事情的。</p>
<p>在tdp_page_fault这个函数开头，我们通过gpa，也即客户机的物理地址得到客户机的页号gfn。接下来，我们要通过调用try_async_pf得到宿主机的物理地址对应的页号，也即真正的物理页的页号，然后通过__direct_map将两者关联起来。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> bool <span class="token function">try_async_pf</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kvm_vcpu</span> <span class="token operator">*</span>vcpu<span class="token punctuation">,</span> bool prefault<span class="token punctuation">,</span> gfn_t gfn<span class="token punctuation">,</span> gva_t gva<span class="token punctuation">,</span> kvm_pfn_t <span class="token operator">*</span>pfn<span class="token punctuation">,</span> bool write<span class="token punctuation">,</span> bool <span class="token operator">*</span>writable<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">kvm_memory_slot</span> <span class="token operator">*</span>slot<span class="token punctuation">;</span>
    bool async<span class="token punctuation">;</span>

    slot <span class="token operator">=</span> <span class="token function">kvm_vcpu_gfn_to_memslot</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">,</span> gfn<span class="token punctuation">)</span><span class="token punctuation">;</span>
    async <span class="token operator">=</span> false<span class="token punctuation">;</span>
    <span class="token operator">*</span>pfn <span class="token operator">=</span> <span class="token function">__gfn_to_pfn_memslot</span><span class="token punctuation">(</span>slot<span class="token punctuation">,</span> gfn<span class="token punctuation">,</span> false<span class="token punctuation">,</span> <span class="token operator">&amp;</span>async<span class="token punctuation">,</span> write<span class="token punctuation">,</span> writable<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>async<span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span> <span class="token comment">/* *pfn has correct page already */</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>prefault <span class="token operator">&amp;&amp;</span> <span class="token function">kvm_can_do_async_pf</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">kvm_find_async_pf_gfn</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">,</span> gfn<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">kvm_make_request</span><span class="token punctuation">(</span>KVM_REQ_APF_HALT<span class="token punctuation">,</span> vcpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> true<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">kvm_arch_setup_async_pf</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">,</span> gva<span class="token punctuation">,</span> gfn<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">*</span>pfn <span class="token operator">=</span> <span class="token function">__gfn_to_pfn_memslot</span><span class="token punctuation">(</span>slot<span class="token punctuation">,</span> gfn<span class="token punctuation">,</span> false<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> write<span class="token punctuation">,</span> writable<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> false<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在try_async_pf中，要想得到pfn，也即物理页的页号，会先通过kvm_vcpu_gfn_to_memslot，根据客户机的物理地址对应的页号找到内存条，然后调用__gfn_to_pfn_memslot，根据内存条找到pfn。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">kvm_pfn_t <span class="token function">__gfn_to_pfn_memslot</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kvm_memory_slot</span> <span class="token operator">*</span>slot<span class="token punctuation">,</span> gfn_t gfn<span class="token punctuation">,</span>bool atomic<span class="token punctuation">,</span> bool <span class="token operator">*</span>async<span class="token punctuation">,</span> bool write_fault<span class="token punctuation">,</span>bool <span class="token operator">*</span>writable<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> addr <span class="token operator">=</span> <span class="token function">__gfn_to_hva_many</span><span class="token punctuation">(</span>slot<span class="token punctuation">,</span> gfn<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> write_fault<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> <span class="token function">hva_to_pfn</span><span class="token punctuation">(</span>addr<span class="token punctuation">,</span> atomic<span class="token punctuation">,</span> async<span class="token punctuation">,</span> write_fault<span class="token punctuation">,</span>
              writable<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在<strong>gfn_to_pfn_memslot中，我们会调用</strong>gfn_to_hva_many，从客户机物理地址对应的页号，得到宿主机虚拟地址hva，然后从宿主机虚拟地址到宿主机物理地址，调用的是hva_to_pfn。</p>
<p>hva_to_pfn会调用hva_to_pfn_slow。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hva_to_pfn_slow</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> addr<span class="token punctuation">,</span> bool <span class="token operator">*</span>async<span class="token punctuation">,</span> bool write_fault<span class="token punctuation">,</span>
               bool <span class="token operator">*</span>writable<span class="token punctuation">,</span> kvm_pfn_t <span class="token operator">*</span>pfn<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> npages <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>async<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        npages <span class="token operator">=</span> <span class="token function">get_user_page_nowait</span><span class="token punctuation">(</span>addr<span class="token punctuation">,</span> write_fault<span class="token punctuation">,</span> page<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        npages <span class="token operator">=</span> <span class="token function">get_user_pages_unlocked</span><span class="token punctuation">(</span>addr<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> page<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token operator">*</span>pfn <span class="token operator">=</span> <span class="token function">page_to_pfn</span><span class="token punctuation">(</span>page<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> npages<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在hva_to_pfn_slow中，我们要先调用get_user_page_nowait，得到一个物理页面，然后再调用page_to_pfn将物理页面转换成为物理页号。</p>
<p>无论是哪一种get_user_pages_XXX，最终都会调用__get_user_pages函数。这里面会调用faultin_page，在faultin_page中我们会调用handle_mm_fault。看到这个是不是很熟悉？这就是咱们内存管理那一章讲的缺页异常的逻辑，分配一个物理内存。</p>
<p>至此，try_async_pf得到了物理页面，并且转换为对应的物理页号。</p>
<p>接下来，__direct_map会关联客户机物理页号和宿主机物理页号。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">__direct_map</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kvm_vcpu</span> <span class="token operator">*</span>vcpu<span class="token punctuation">,</span> <span class="token keyword">int</span> write<span class="token punctuation">,</span> <span class="token keyword">int</span> map_writable<span class="token punctuation">,</span>
            <span class="token keyword">int</span> level<span class="token punctuation">,</span> gfn_t gfn<span class="token punctuation">,</span> kvm_pfn_t pfn<span class="token punctuation">,</span> bool prefault<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">kvm_shadow_walk_iterator</span> iterator<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">kvm_mmu_page</span> <span class="token operator">*</span>sp<span class="token punctuation">;</span>
    <span class="token keyword">int</span> emulate <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    gfn_t pseudo_gfn<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">VALID_PAGE</span><span class="token punctuation">(</span>vcpu<span class="token operator">-&gt;</span>arch<span class="token punctuation">.</span>mmu<span class="token punctuation">.</span>root_hpa<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token function">for_each_shadow_entry</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">,</span> <span class="token punctuation">(</span>u64<span class="token punctuation">)</span>gfn <span class="token operator">&lt;&lt;</span> PAGE_SHIFT<span class="token punctuation">,</span> iterator<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span>level <span class="token operator">==</span> level<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            emulate <span class="token operator">=</span> <span class="token function">mmu_set_spte</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">,</span> iterator<span class="token punctuation">.</span>sptep<span class="token punctuation">,</span> ACC_ALL<span class="token punctuation">,</span>
                           write<span class="token punctuation">,</span> level<span class="token punctuation">,</span> gfn<span class="token punctuation">,</span> pfn<span class="token punctuation">,</span> prefault<span class="token punctuation">,</span>
                           map_writable<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">direct_pte_prefetch</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">,</span> iterator<span class="token punctuation">.</span>sptep<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">++</span>vcpu<span class="token operator">-&gt;</span>stat<span class="token punctuation">.</span>pf_fixed<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token function">drop_large_spte</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">,</span> iterator<span class="token punctuation">.</span>sptep<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">is_shadow_present_pte</span><span class="token punctuation">(</span><span class="token operator">*</span>iterator<span class="token punctuation">.</span>sptep<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            u64 base_addr <span class="token operator">=</span> iterator<span class="token punctuation">.</span>addr<span class="token punctuation">;</span>

            base_addr <span class="token operator">&amp;=</span> <span class="token function">PT64_LVL_ADDR_MASK</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span>level<span class="token punctuation">)</span><span class="token punctuation">;</span>
            pseudo_gfn <span class="token operator">=</span> base_addr <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">;</span>
            sp <span class="token operator">=</span> <span class="token function">kvm_mmu_get_page</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">,</span> pseudo_gfn<span class="token punctuation">,</span> iterator<span class="token punctuation">.</span>addr<span class="token punctuation">,</span>
                          iterator<span class="token punctuation">.</span>level <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> ACC_ALL<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token function">link_shadow_page</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">,</span> iterator<span class="token punctuation">.</span>sptep<span class="token punctuation">,</span> sp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> emulate<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>__direct_map首先判断页表的根是否存在，当然存在，我们刚才初始化了。</p>
<p>接下来是for_each_shadow_entry一个循环。每一个循环中，先是会判断需要映射的level，是否正是当前循环的这个iterator.level。如果是，则说明是叶子节点，直接映射真正的物理页面pfn，然后退出。接着是非叶子节点的情形，判断如果这一项指向的页表项不存在，就要建立页表项，通过kvm_mmu_get_page得到保存页表项的页面，然后将这一项指向下一级的页表页面。</p>
<p>至此，内存映射就结束了。</p>
<h4 id="46-5-总结"><a href="#46-5-总结" class="headerlink" title="46.5 总结"></a>46.5 总结</h4><p>我们这里来总结一下，虚拟机的内存管理也是需要用户态的qemu和内核态的KVM共同完成。为了加速内存映射，需要借助硬件的EPT技术。</p>
<p>在用户态qemu中，有一个结构AddressSpace address_space_memory来表示虚拟机的系统内存，这个内存可能包含多个内存区域struct MemoryRegion，组成树形结构，指向由mmap分配的虚拟内存。</p>
<p>在AddressSpace结构中，有一个struct KVMMemoryListener，当有新的内存区域添加的时候，会被通知调用kvm_region_add来通知内核。</p>
<p>在用户态qemu中，对于虚拟机有一个结构struct KVMState表示这个虚拟机，这个结构会指向一个数组的struct KVMSlot表示这个虚拟机的多个内存条，KVMSlot中有一个void *ram指针指向mmap分配的那块虚拟内存。</p>
<p>kvm_region_add是通过ioctl来通知内核KVM的，会给内核KVM发送一个KVM_SET_USER_MEMORY_REGION消息，表示用户态qemu添加了一个内存区域，内核KVM也应该添加一个相应的内存区域。</p>
<p>和用户态qemu对应的内核KVM，对于虚拟机有一个结构struct kvm表示这个虚拟机，这个结构会指向一个数组的struct kvm_memory_slot表示这个虚拟机的多个内存条，kvm_memory_slot中有起始页号，页面数目，表示这个虚拟机的物理内存空间。</p>
<p>虚拟机的物理内存空间里面的页面当然不是一开始就映射到物理页面的，只有当虚拟机的内存被访问的时候，也即mmap分配的虚拟内存空间被访问的时候，先查看EPT页表，是否已经映射过，如果已经映射过，则经过四级页表映射，就能访问到物理页面。</p>
<p>如果没有映射过，则虚拟机会通过VM-Exit指令回到宿主机模式，通过handle_ept_violation补充页表映射。先是通过handle_mm_fault为虚拟机的物理内存空间分配真正的物理页面，然后通过__direct_map添加EPT页表映射。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/虚拟机的内存管理中的EPT技术.jpg" alt="虚拟机的内存管理中的EPT技术"></p>
<h3 id="47-存储虚拟化（上）"><a href="#47-存储虚拟化（上）" class="headerlink" title="47. 存储虚拟化（上）"></a>47. 存储虚拟化（上）</h3><p>前面几节，我们讲了CPU和内存的虚拟化。我们知道，完全虚拟化是很慢的，而通过内核的KVM技术和EPT技术，加速虚拟机对于物理CPU和内存的使用，我们称为硬件辅助虚拟化。</p>
<p>对于一台虚拟机而言，除了要虚拟化CPU和内存，存储和网络也需要虚拟化，存储和网络都属于外部设备，这些外部设备应该如何虚拟化呢？</p>
<p>当然一种方式还是完全虚拟化。比如，有什么样的硬盘设备或者网卡设备，我们就用qemu模拟一个一模一样的软件的硬盘和网卡设备，这样在虚拟机里面的操作系统看来，使用这些设备和使用物理设备是一样的。当然缺点就是，qemu模拟的设备又是一个翻译官的角色。虽然这个时候虚拟机里面的操作系统，意识不到自己是运行在虚拟机里面的，但是这种每个指令都翻译的方式，实在是太慢了。</p>
<p>另外一种方式就是，虚拟机里面的操作系统不是一个通用的操作系统，它知道自己是运行在虚拟机里面的，使用的硬盘设备和网络设备都是虚拟的，应该加载特殊的驱动才能运行。这些特殊的驱动往往要通过虚拟机里面和外面配合工作的模式，来加速对于物理存储和网络设备的使用。</p>
<h4 id="47-1-virtio的基本原理"><a href="#47-1-virtio的基本原理" class="headerlink" title="47.1 virtio的基本原理"></a>47.1 virtio的基本原理</h4><p>在虚拟化技术的早期，不同的虚拟化技术会针对不同硬盘设备和网络设备实现不同的驱动，虚拟机里面的操作系统也要根据不同的虚拟化技术和物理存储和网络设备，选择加载不同的驱动。但是，由于硬盘设备和网络设备太多了，驱动纷繁复杂。</p>
<p>后来慢慢就形成了一定的标准，这就是<strong>virtio</strong>，就是<strong>虚拟化I/O设备</strong>的意思。virtio负责对于虚拟机提供统一的接口。也就是说，在虚拟机里面的操作系统加载的驱动，以后都统一加载virtio就可以了。</p>
<p>在虚拟机外，我们可以实现不同的virtio的后端，来适配不同的物理硬件设备。那virtio到底长什么样子呢？我们一起来看一看。</p>
<p>virtio的架构可以分为四层。</p>
<ul>
<li>首先，在虚拟机里面的virtio前端，针对不同类型的设备有不同的<strong>驱动程序</strong>，但是接口都是统一的。例如，硬盘就是virtio_blk，网络就是virtio_net。</li>
<li>其次，在宿主机的qemu里面，实现virtio后端的逻辑，主要就是<strong>操作硬件的设备</strong>。例如通过写一个物理机硬盘上的文件来完成虚拟机写入硬盘的操作。再如向内核协议栈发送一个网络包完成虚拟机对于网络的操作。</li>
<li>在virtio的前端和后端之间，有一个通信层，里面包含<strong>virtio层和virtio-ring层</strong>。virtio这一层实现的是虚拟队列接口，算是前后端通信的桥梁。而virtio-ring则是该桥梁的具体实现。</li>
</ul>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/virtio的架构.png" alt="virtio的架构"></p>
<p>virtio使用virtqueue进行前端和后端的高速通信。不同类型的设备队列数目不同。virtio-net使用两个队列，一个用于接受，另一个用于发送；而 virtio-blk仅使用一个队列。</p>
<p>如果客户机要向宿主机发送数据，宿主机会将数据的buffer添加到virtqueue中，然后通过写入寄存器通知宿主机。这样宿主机就可以从virtqueue 中收到的buffer里面的数据。</p>
<p>了解了virtio的基本原理，接下来，我们以硬盘写入为例，具体看一下存储虚拟化的过程。</p>
<h4 id="47-2-初始化阶段的存储虚拟化"><a href="#47-2-初始化阶段的存储虚拟化" class="headerlink" title="47.2 初始化阶段的存储虚拟化"></a>47.2 初始化阶段的存储虚拟化</h4><p>和咱们在学习CPU的时候看到的一样，Virtio Block Device也是一种类。它的继承关系如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">const</span> TypeInfo device_type_info <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>name <span class="token operator">=</span> TYPE_DEVICE<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>parent <span class="token operator">=</span> TYPE_OBJECT<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>instance_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>DeviceState<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>instance_init <span class="token operator">=</span> device_initfn<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>instance_post_init <span class="token operator">=</span> device_post_init<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>instance_finalize <span class="token operator">=</span> device_finalize<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>class_base_init <span class="token operator">=</span> device_class_base_init<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>class_init <span class="token operator">=</span> device_class_init<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>abstract <span class="token operator">=</span> true<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>class_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>DeviceClass<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">const</span> TypeInfo virtio_device_info <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>name <span class="token operator">=</span> TYPE_VIRTIO_DEVICE<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>parent <span class="token operator">=</span> TYPE_DEVICE<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>instance_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>VirtIODevice<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>class_init <span class="token operator">=</span> virtio_device_class_init<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>instance_finalize <span class="token operator">=</span> virtio_device_instance_finalize<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>abstract <span class="token operator">=</span> true<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>class_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>VirtioDeviceClass<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">const</span> TypeInfo virtio_blk_info <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>name <span class="token operator">=</span> TYPE_VIRTIO_BLK<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>parent <span class="token operator">=</span> TYPE_VIRTIO_DEVICE<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>instance_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>VirtIOBlock<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>instance_init <span class="token operator">=</span> virtio_blk_instance_init<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>class_init <span class="token operator">=</span> virtio_blk_class_init<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">virtio_register_types</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">type_register_static</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>virtio_blk_info<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">type_init</span><span class="token punctuation">(</span>virtio_register_types<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Virtio Block Device这种类的定义是有多层继承关系的。TYPE_VIRTIO_BLK的父类是TYPE_VIRTIO_DEVICE，TYPE_VIRTIO_DEVICE的父类是TYPE_DEVICE，TYPE_DEVICE的父类是TYPE_OBJECT。到头了。</p>
<p>type_init用于注册这种类。这里面每一层都有class_init，用于从TypeImpl生产xxxClass。还有instance_init，可以将xxxClass初始化为实例。</p>
<p>在TYPE_VIRTIO_BLK层的class_init函数virtio_blk_class_init中，定义了DeviceClass的realize函数为virtio_blk_device_realize，这一点在<strong>计算虚拟化之CPU（上）</strong>那一节也有类似的结构。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">virtio_blk_device_realize</span><span class="token punctuation">(</span>DeviceState <span class="token operator">*</span>dev<span class="token punctuation">,</span> Error <span class="token operator">*</span><span class="token operator">*</span>errp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    VirtIODevice <span class="token operator">*</span>vdev <span class="token operator">=</span> <span class="token function">VIRTIO_DEVICE</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    VirtIOBlock <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token function">VIRTIO_BLK</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    VirtIOBlkConf <span class="token operator">*</span>conf <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token operator">-&gt;</span>conf<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">blkconf_blocksizes</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>conf<span class="token operator">-&gt;</span>conf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">virtio_blk_set_config_size</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> s<span class="token operator">-&gt;</span>host_features<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">virtio_init</span><span class="token punctuation">(</span>vdev<span class="token punctuation">,</span> <span class="token string">"virtio-blk"</span><span class="token punctuation">,</span> VIRTIO_ID_BLOCK<span class="token punctuation">,</span> s<span class="token operator">-&gt;</span>config_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    s<span class="token operator">-&gt;</span>blk <span class="token operator">=</span> conf<span class="token operator">-&gt;</span>conf<span class="token punctuation">.</span>blk<span class="token punctuation">;</span>
    s<span class="token operator">-&gt;</span>rq <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    s<span class="token operator">-&gt;</span>sector_mask <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>conf<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>logical_block_size <span class="token operator">/</span> BDRV_SECTOR_SIZE<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> conf<span class="token operator">-&gt;</span>num_queues<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">virtio_add_queue</span><span class="token punctuation">(</span>vdev<span class="token punctuation">,</span> conf<span class="token operator">-&gt;</span>queue_size<span class="token punctuation">,</span> virtio_blk_handle_output<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">virtio_blk_data_plane_create</span><span class="token punctuation">(</span>vdev<span class="token punctuation">,</span> conf<span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token operator">-&gt;</span>dataplane<span class="token punctuation">,</span> <span class="token operator">&amp;</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
    s<span class="token operator">-&gt;</span>change <span class="token operator">=</span> <span class="token function">qemu_add_vm_change_state_handler</span><span class="token punctuation">(</span>virtio_blk_dma_restart_cb<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">blk_set_dev_ops</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>blk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>virtio_block_ops<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">blk_set_guest_block_size</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>blk<span class="token punctuation">,</span> s<span class="token operator">-&gt;</span>conf<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>logical_block_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">blk_iostatus_enable</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>blk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在virtio_blk_device_realize函数中，我们先是通过virtio_init初始化VirtIODevice结构。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">virtio_init</span><span class="token punctuation">(</span>VirtIODevice <span class="token operator">*</span>vdev<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span>
                 uint16_t device_id<span class="token punctuation">,</span> size_t config_size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    BusState <span class="token operator">*</span>qbus <span class="token operator">=</span> <span class="token function">qdev_get_parent_bus</span><span class="token punctuation">(</span><span class="token function">DEVICE</span><span class="token punctuation">(</span>vdev<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    VirtioBusClass <span class="token operator">*</span>k <span class="token operator">=</span> <span class="token function">VIRTIO_BUS_GET_CLASS</span><span class="token punctuation">(</span>qbus<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">int</span> nvectors <span class="token operator">=</span> k<span class="token operator">-&gt;</span>query_nvectors <span class="token operator">?</span> k<span class="token operator">-&gt;</span><span class="token function">query_nvectors</span><span class="token punctuation">(</span>qbus<span class="token operator">-&gt;</span>parent<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>nvectors<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        vdev<span class="token operator">-&gt;</span>vector_queues <span class="token operator">=</span>
            <span class="token function">g_malloc0</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>vdev<span class="token operator">-&gt;</span>vector_queues<span class="token punctuation">)</span> <span class="token operator">*</span> nvectors<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    vdev<span class="token operator">-&gt;</span>device_id <span class="token operator">=</span> device_id<span class="token punctuation">;</span>
    vdev<span class="token operator">-&gt;</span>status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">atomic_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vdev<span class="token operator">-&gt;</span>isr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    vdev<span class="token operator">-&gt;</span>queue_sel <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    vdev<span class="token operator">-&gt;</span>config_vector <span class="token operator">=</span> VIRTIO_NO_VECTOR<span class="token punctuation">;</span>
    vdev<span class="token operator">-&gt;</span>vq <span class="token operator">=</span> <span class="token function">g_malloc0</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>VirtQueue<span class="token punctuation">)</span> <span class="token operator">*</span> VIRTIO_QUEUE_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vdev<span class="token operator">-&gt;</span>vm_running <span class="token operator">=</span> <span class="token function">runstate_is_running</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    vdev<span class="token operator">-&gt;</span>broken <span class="token operator">=</span> false<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> VIRTIO_QUEUE_MAX<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        vdev<span class="token operator">-&gt;</span>vq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>vector <span class="token operator">=</span> VIRTIO_NO_VECTOR<span class="token punctuation">;</span>
        vdev<span class="token operator">-&gt;</span>vq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>vdev <span class="token operator">=</span> vdev<span class="token punctuation">;</span>
        vdev<span class="token operator">-&gt;</span>vq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>queue_index <span class="token operator">=</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    vdev<span class="token operator">-&gt;</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    vdev<span class="token operator">-&gt;</span>config_len <span class="token operator">=</span> config_size<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>vdev<span class="token operator">-&gt;</span>config_len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        vdev<span class="token operator">-&gt;</span>config <span class="token operator">=</span> <span class="token function">g_malloc0</span><span class="token punctuation">(</span>config_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        vdev<span class="token operator">-&gt;</span>config <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    vdev<span class="token operator">-&gt;</span>vmstate <span class="token operator">=</span> <span class="token function">qemu_add_vm_change_state_handler</span><span class="token punctuation">(</span>virtio_vmstate_change<span class="token punctuation">,</span>
                                                     vdev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vdev<span class="token operator">-&gt;</span>device_endian <span class="token operator">=</span> <span class="token function">virtio_default_endian</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    vdev<span class="token operator">-&gt;</span>use_guest_notifier_mask <span class="token operator">=</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从virtio_init中可以看出，VirtIODevice结构里面有一个VirtQueue数组，这就是virtio前端和后端互相传数据的队列，最多VIRTIO_QUEUE_MAX个。</p>
<p>我们回到virtio_blk_device_realize函数。接下来，根据配置的队列数目num_queues，对于每个队列都调用virtio_add_queue来初始化队列。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">VirtQueue <span class="token operator">*</span><span class="token function">virtio_add_queue</span><span class="token punctuation">(</span>VirtIODevice <span class="token operator">*</span>vdev<span class="token punctuation">,</span> <span class="token keyword">int</span> queue_size<span class="token punctuation">,</span>
                            VirtIOHandleOutput handle_output<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    vdev<span class="token operator">-&gt;</span>vq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>vring<span class="token punctuation">.</span>num <span class="token operator">=</span> queue_size<span class="token punctuation">;</span>
    vdev<span class="token operator">-&gt;</span>vq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>vring<span class="token punctuation">.</span>num_default <span class="token operator">=</span> queue_size<span class="token punctuation">;</span>
    vdev<span class="token operator">-&gt;</span>vq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>vring<span class="token punctuation">.</span>align <span class="token operator">=</span> VIRTIO_PCI_VRING_ALIGN<span class="token punctuation">;</span>
    vdev<span class="token operator">-&gt;</span>vq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>handle_output <span class="token operator">=</span> handle_output<span class="token punctuation">;</span>
    vdev<span class="token operator">-&gt;</span>vq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>handle_aio_output <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token operator">&amp;</span>vdev<span class="token operator">-&gt;</span>vq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在每个VirtQueue中，都有一个vring，用来维护这个队列里面的数据；另外还有一个函数virtio_blk_handle_output，用于处理数据写入，这个函数我们后面会用到。</p>
<p>至此，VirtIODevice，VirtQueue，vring之间的关系如下图所示。这是在qemu里面的对应关系，请你记好，后面我们还能看到类似的结构。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/VirtIODevice与VirtQueue和vring之间的关系.jpg" alt="VirtIODevice与VirtQueue和vring之间的关系"></p>
<h4 id="47-3-qemu启动过程中的存储虚拟化"><a href="#47-3-qemu启动过程中的存储虚拟化" class="headerlink" title="47.3 qemu启动过程中的存储虚拟化"></a>47.3 qemu启动过程中的存储虚拟化</h4><p>初始化过程解析完毕以后，我们接下来从qemu的启动过程看起。</p>
<p>对于硬盘的虚拟化，qemu的启动参数里面有关的是下面两行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-drive <span class="token assign-left variable">file</span><span class="token operator">=</span>/var/lib/nova/instances/1f8e6f7e-5a70-4780-89c1-464dc0e7f308/disk,if<span class="token operator">=</span>none,id<span class="token operator">=</span>drive-virtio-disk0,format<span class="token operator">=</span>qcow2,cache<span class="token operator">=</span>none
-device virtio-blk-pci,scsi<span class="token operator">=</span>off,bus<span class="token operator">=</span>pci.0,addr<span class="token operator">=</span>0x4,drive<span class="token operator">=</span>drive-virtio-disk0,id<span class="token operator">=</span>virtio-disk0,bootindex<span class="token operator">=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>其中，第一行指定了宿主机硬盘上的一个文件，文件的格式是qcow2，这个格式我们这里不准备解析它，你只要明白，对于宿主机上的一个文件，可以被qemu模拟称为客户机上的一块硬盘就可以了。</p>
<p>而第二行说明了，使用的驱动是virtio-blk驱动。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">configure_blockdev</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bdo_queue<span class="token punctuation">,</span> machine_class<span class="token punctuation">,</span> snapshot<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在qemu启动的main函数里面，初始化块设备，是通过configure_blockdev调用开始的。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">configure_blockdev</span><span class="token punctuation">(</span>BlockdevOptionsQueue <span class="token operator">*</span>bdo_queue<span class="token punctuation">,</span> MachineClass <span class="token operator">*</span>machine_class<span class="token punctuation">,</span> <span class="token keyword">int</span> snapshot<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">qemu_opts_foreach</span><span class="token punctuation">(</span><span class="token function">qemu_find_opts</span><span class="token punctuation">(</span><span class="token string">"drive"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> drive_init_func<span class="token punctuation">,</span>
                          <span class="token operator">&amp;</span>machine_class<span class="token operator">-&gt;</span>block_default_type<span class="token punctuation">,</span> <span class="token operator">&amp;</span>error_fatal<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">drive_init_func</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>opaque<span class="token punctuation">,</span> QemuOpts <span class="token operator">*</span>opts<span class="token punctuation">,</span> Error <span class="token operator">*</span><span class="token operator">*</span>errp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    BlockInterfaceType <span class="token operator">*</span>block_default_type <span class="token operator">=</span> opaque<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">drive_new</span><span class="token punctuation">(</span>opts<span class="token punctuation">,</span> <span class="token operator">*</span>block_default_type<span class="token punctuation">,</span> errp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在configure_blockdev中，我们能看到对于drive这个参数的解析，并且初始化这个设备要调用drive_init_func函数，这里面会调用drive_new创建一个设备。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">DriveInfo <span class="token operator">*</span><span class="token function">drive_new</span><span class="token punctuation">(</span>QemuOpts <span class="token operator">*</span>all_opts<span class="token punctuation">,</span> BlockInterfaceType block_default_type<span class="token punctuation">,</span> Error <span class="token operator">*</span><span class="token operator">*</span>errp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>value<span class="token punctuation">;</span>
    BlockBackend <span class="token operator">*</span>blk<span class="token punctuation">;</span>
    DriveInfo <span class="token operator">*</span>dinfo <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    QDict <span class="token operator">*</span>bs_opts<span class="token punctuation">;</span>
    QemuOpts <span class="token operator">*</span>legacy_opts<span class="token punctuation">;</span>
    DriveMediaType media <span class="token operator">=</span> MEDIA_DISK<span class="token punctuation">;</span>
    BlockInterfaceType type<span class="token punctuation">;</span>
    <span class="token keyword">int</span> max_devs<span class="token punctuation">,</span> bus_id<span class="token punctuation">,</span> unit_id<span class="token punctuation">,</span> index<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>werror<span class="token punctuation">,</span> <span class="token operator">*</span>rerror<span class="token punctuation">;</span>
    bool read_only <span class="token operator">=</span> false<span class="token punctuation">;</span>
    bool copy_on_read<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">;</span>
    Error <span class="token operator">*</span>local_err <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    legacy_opts <span class="token operator">=</span> <span class="token function">qemu_opts_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>qemu_legacy_drive_opts<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>
                                   <span class="token operator">&amp;</span>error_abort<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* Add virtio block device */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> IF_VIRTIO<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        QemuOpts <span class="token operator">*</span>devopts<span class="token punctuation">;</span>
        devopts <span class="token operator">=</span> <span class="token function">qemu_opts_create</span><span class="token punctuation">(</span><span class="token function">qemu_find_opts</span><span class="token punctuation">(</span><span class="token string">"device"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>
                                   <span class="token operator">&amp;</span>error_abort<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">qemu_opt_set</span><span class="token punctuation">(</span>devopts<span class="token punctuation">,</span> <span class="token string">"driver"</span><span class="token punctuation">,</span> <span class="token string">"virtio-blk-pci"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>error_abort<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">qemu_opt_set</span><span class="token punctuation">(</span>devopts<span class="token punctuation">,</span> <span class="token string">"drive"</span><span class="token punctuation">,</span> <span class="token function">qdict_get_str</span><span class="token punctuation">(</span>bs_opts<span class="token punctuation">,</span> <span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                     <span class="token operator">&amp;</span>error_abort<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    filename <span class="token operator">=</span> <span class="token function">qemu_opt_get</span><span class="token punctuation">(</span>legacy_opts<span class="token punctuation">,</span> <span class="token string">"file"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* Actual block device init: Functionality shared with blockdev-add */</span>
    blk <span class="token operator">=</span> <span class="token function">blockdev_init</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> bs_opts<span class="token punctuation">,</span> <span class="token operator">&amp;</span>local_err<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* Create legacy DriveInfo */</span>
    dinfo <span class="token operator">=</span> <span class="token function">g_malloc0</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>dinfo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    dinfo<span class="token operator">-&gt;</span>opts <span class="token operator">=</span> all_opts<span class="token punctuation">;</span>

    dinfo<span class="token operator">-&gt;</span>type <span class="token operator">=</span> type<span class="token punctuation">;</span>
    dinfo<span class="token operator">-&gt;</span>bus <span class="token operator">=</span> bus_id<span class="token punctuation">;</span>
    dinfo<span class="token operator">-&gt;</span>unit <span class="token operator">=</span> unit_id<span class="token punctuation">;</span>

    <span class="token function">blk_set_legacy_dinfo</span><span class="token punctuation">(</span>blk<span class="token punctuation">,</span> dinfo<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">switch</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> IF_IDE<span class="token operator">:</span>
    <span class="token keyword">case</span> IF_SCSI<span class="token operator">:</span>
    <span class="token keyword">case</span> IF_XEN<span class="token operator">:</span>
    <span class="token keyword">case</span> IF_NONE<span class="token operator">:</span>
        dinfo<span class="token operator">-&gt;</span>media_cd <span class="token operator">=</span> media <span class="token operator">==</span> MEDIA_CDROM<span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在drive_new里面，会解析qemu的启动参数。对于virtio来讲，会解析device参数，把driver设置为virtio-blk-pci；还会解析file参数，就是指向那个宿主机上的文件。</p>
<p>接下来，drive_new会调用blockdev_init，根据参数进行初始化，最后会创建一个DriveInfo来管理这个设备。</p>
<p>我们重点来看blockdev_init。在这里面，我们发现，如果file不为空，则应该调用blk_new_open打开宿主机上的硬盘文件，返回的结果是BlockBackend，对应我们上面讲原理的时候的virtio的后端。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">BlockBackend <span class="token operator">*</span><span class="token function">blk_new_open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>reference<span class="token punctuation">,</span>
                           QDict <span class="token operator">*</span>options<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> Error <span class="token operator">*</span><span class="token operator">*</span>errp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    BlockBackend <span class="token operator">*</span>blk<span class="token punctuation">;</span>
    BlockDriverState <span class="token operator">*</span>bs<span class="token punctuation">;</span>
    uint64_t perm <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    blk <span class="token operator">=</span> <span class="token function">blk_new</span><span class="token punctuation">(</span>perm<span class="token punctuation">,</span> BLK_PERM_ALL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    bs <span class="token operator">=</span> <span class="token function">bdrv_open</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> reference<span class="token punctuation">,</span> options<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> errp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    blk<span class="token operator">-&gt;</span>root <span class="token operator">=</span> <span class="token function">bdrv_root_attach_child</span><span class="token punctuation">(</span>bs<span class="token punctuation">,</span> <span class="token string">"root"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>child_root<span class="token punctuation">,</span>
                                       perm<span class="token punctuation">,</span> BLK_PERM_ALL<span class="token punctuation">,</span> blk<span class="token punctuation">,</span> errp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> blk<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来的调用链为：bdrv_open-&gt;bdrv_open_inherit-&gt;bdrv_open_common.</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">bdrv_open_common</span><span class="token punctuation">(</span>BlockDriverState <span class="token operator">*</span>bs<span class="token punctuation">,</span> BlockBackend <span class="token operator">*</span>file<span class="token punctuation">,</span>
                            QDict <span class="token operator">*</span>options<span class="token punctuation">,</span> Error <span class="token operator">*</span><span class="token operator">*</span>errp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">,</span> open_flags<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>driver_name <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>node_name <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>discard<span class="token punctuation">;</span>
    QemuOpts <span class="token operator">*</span>opts<span class="token punctuation">;</span>
    BlockDriver <span class="token operator">*</span>drv<span class="token punctuation">;</span>
    Error <span class="token operator">*</span>local_err <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    drv <span class="token operator">=</span> <span class="token function">bdrv_find_format</span><span class="token punctuation">(</span>driver_name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    ret <span class="token operator">=</span> <span class="token function">bdrv_open_driver</span><span class="token punctuation">(</span>bs<span class="token punctuation">,</span> drv<span class="token punctuation">,</span> node_name<span class="token punctuation">,</span> options<span class="token punctuation">,</span> open_flags<span class="token punctuation">,</span> errp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">bdrv_open_driver</span><span class="token punctuation">(</span>BlockDriverState <span class="token operator">*</span>bs<span class="token punctuation">,</span> BlockDriver <span class="token operator">*</span>drv<span class="token punctuation">,</span>
                            <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>node_name<span class="token punctuation">,</span> QDict <span class="token operator">*</span>options<span class="token punctuation">,</span>
                            <span class="token keyword">int</span> open_flags<span class="token punctuation">,</span> Error <span class="token operator">*</span><span class="token operator">*</span>errp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    bs<span class="token operator">-&gt;</span>drv <span class="token operator">=</span> drv<span class="token punctuation">;</span>
    bs<span class="token operator">-&gt;</span>read_only <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span>bs<span class="token operator">-&gt;</span>open_flags <span class="token operator">&amp;</span> BDRV_O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>
    bs<span class="token operator">-&gt;</span>opaque <span class="token operator">=</span> <span class="token function">g_malloc0</span><span class="token punctuation">(</span>drv<span class="token operator">-&gt;</span>instance_size<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>drv<span class="token operator">-&gt;</span>bdrv_open<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ret <span class="token operator">=</span> drv<span class="token operator">-&gt;</span><span class="token function">bdrv_open</span><span class="token punctuation">(</span>bs<span class="token punctuation">,</span> options<span class="token punctuation">,</span> open_flags<span class="token punctuation">,</span> <span class="token operator">&amp;</span>local_err<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在bdrv_open_common中，根据硬盘文件的格式，得到BlockDriver。因为虚拟机的硬盘文件格式有很多种，qcow2是一种，raw是一种，vmdk是一种，各有优缺点，启动虚拟机的时候，可以自由选择。</p>
<p>对于不同的格式，打开的方式不一样，我们拿qcow2来解析。它的BlockDriver定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">BlockDriver bdrv_qcow2 <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>format_name        <span class="token operator">=</span> <span class="token string">"qcow2"</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>instance_size      <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>BDRVQcow2State<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>bdrv_probe         <span class="token operator">=</span> qcow2_probe<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>bdrv_open          <span class="token operator">=</span> qcow2_open<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>bdrv_close         <span class="token operator">=</span> qcow2_close<span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">.</span>bdrv_snapshot_create   <span class="token operator">=</span> qcow2_snapshot_create<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>bdrv_snapshot_goto     <span class="token operator">=</span> qcow2_snapshot_goto<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>bdrv_snapshot_delete   <span class="token operator">=</span> qcow2_snapshot_delete<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>bdrv_snapshot_list     <span class="token operator">=</span> qcow2_snapshot_list<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>bdrv_snapshot_load_tmp <span class="token operator">=</span> qcow2_snapshot_load_tmp<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>bdrv_measure           <span class="token operator">=</span> qcow2_measure<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>bdrv_get_info          <span class="token operator">=</span> qcow2_get_info<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>bdrv_get_specific_info <span class="token operator">=</span> qcow2_get_specific_info<span class="token punctuation">,</span>

    <span class="token punctuation">.</span>bdrv_save_vmstate    <span class="token operator">=</span> qcow2_save_vmstate<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>bdrv_load_vmstate    <span class="token operator">=</span> qcow2_load_vmstate<span class="token punctuation">,</span>

    <span class="token punctuation">.</span>supports_backing           <span class="token operator">=</span> true<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>bdrv_change_backing_file   <span class="token operator">=</span> qcow2_change_backing_file<span class="token punctuation">,</span>

    <span class="token punctuation">.</span>bdrv_refresh_limits        <span class="token operator">=</span> qcow2_refresh_limits<span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>根据上面的定义，对于qcow2来讲，bdrv_open调用的是qcow2_open。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">qcow2_open</span><span class="token punctuation">(</span>BlockDriverState <span class="token operator">*</span>bs<span class="token punctuation">,</span> QDict <span class="token operator">*</span>options<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span>
                      Error <span class="token operator">*</span><span class="token operator">*</span>errp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    BDRVQcow2State <span class="token operator">*</span>s <span class="token operator">=</span> bs<span class="token operator">-&gt;</span>opaque<span class="token punctuation">;</span>
    QCow2OpenCo qoc <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span>bs <span class="token operator">=</span> bs<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>options <span class="token operator">=</span> options<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>flags <span class="token operator">=</span> flags<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>errp <span class="token operator">=</span> errp<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>ret <span class="token operator">=</span> <span class="token operator">-</span>EINPROGRESS
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    bs<span class="token operator">-&gt;</span>file <span class="token operator">=</span> <span class="token function">bdrv_open_child</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> options<span class="token punctuation">,</span> <span class="token string">"file"</span><span class="token punctuation">,</span> bs<span class="token punctuation">,</span> <span class="token operator">&amp;</span>child_file<span class="token punctuation">,</span>
                               false<span class="token punctuation">,</span> errp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">qemu_coroutine_enter</span><span class="token punctuation">(</span><span class="token function">qemu_coroutine_create</span><span class="token punctuation">(</span>qcow2_open_entry<span class="token punctuation">,</span> <span class="token operator">&amp;</span>qoc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在qcow2_open中，我们会通过qemu_coroutine_enter进入一个协程coroutine。什么叫协程呢？我们可以简单地将它理解为用户态自己实现的线程。</p>
<p>前面咱们讲线程的时候说过，如果一个程序想实现并发，可以创建多个线程，但是线程是一个内核的概念，创建的每一个线程内核都能看到，内核的调度也是以线程为单位的。这对于普通的进程没有什么问题，但是对于qemu这种虚拟机，如果在用户态和内核态切换来切换去，由于还涉及虚拟机的状态，代价比较大。</p>
<p>但是，qemu的设备也是需要多线程能力的，怎么办呢？我们就在用户态实现一个类似线程的东西，也就是协程，用于实现并发，并且不被内核看到，调度全部在用户态完成。</p>
<p>从后面的读写过程可以看出，协程在后端经常使用。这里打开一个qcow2文件就是使用一个协程，创建一个协程和创建一个线程很像，也需要指定一个函数来执行，qcow2_open_entry就是协程的函数。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> coroutine_fn <span class="token function">qcow2_open_entry</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>opaque<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    QCow2OpenCo <span class="token operator">*</span>qoc <span class="token operator">=</span> opaque<span class="token punctuation">;</span>
    BDRVQcow2State <span class="token operator">*</span>s <span class="token operator">=</span> qoc<span class="token operator">-&gt;</span>bs<span class="token operator">-&gt;</span>opaque<span class="token punctuation">;</span>

    <span class="token function">qemu_co_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token operator">-&gt;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    qoc<span class="token operator">-&gt;</span>ret <span class="token operator">=</span> <span class="token function">qcow2_do_open</span><span class="token punctuation">(</span>qoc<span class="token operator">-&gt;</span>bs<span class="token punctuation">,</span> qoc<span class="token operator">-&gt;</span>options<span class="token punctuation">,</span> qoc<span class="token operator">-&gt;</span>flags<span class="token punctuation">,</span> qoc<span class="token operator">-&gt;</span>errp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">qemu_co_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token operator">-&gt;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们可以看到，qcow2_open_entry函数前面有一个coroutine_fn，说明它是一个协程函数。在qcow2_do_open中，qcow2_do_open根据qcow2的格式打开硬盘文件。这个格式官网就有，我们这里就不花篇幅解析了。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>我们这里来总结一下，存储虚拟化的过程分为前端、后端和中间的队列。</p>
<ul>
<li>前端有前端的块设备驱动Front-end driver，在客户机的内核里面，它符合普通设备驱动的格式，对外通过VFS暴露文件系统接口给客户机里面的应用。这一部分这一节我们没有讲，放在下一节解析。</li>
<li>后端有后端的设备驱动Back-end driver，在宿主机的qemu进程中，当收到客户机的写入请求的时候，调用文件系统的write函数，写入宿主机的VFS文件系统，最终写到物理硬盘设备上的qcow2文件。</li>
<li>中间的队列用于前端和后端之间传输数据，在前端的设备驱动和后端的设备驱动，都有类似的数据结构virt-queue来管理这些队列，这一部分这一节我们也没有讲，也放到下一节解析。</li>
</ul>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/存储虚拟化（上）总结.jpg" alt="存储虚拟化（上）总结"></p>
<h3 id="48-存储虚拟化（下）"><a href="#48-存储虚拟化（下）" class="headerlink" title="48. 存储虚拟化（下）"></a>48. 存储虚拟化（下）</h3><p>上一节，我们讲了qemu启动过程中的存储虚拟化。好了，现在qemu启动了，硬盘设备文件已经打开了。那如果我们要往虚拟机的一个进程写入一个文件，该怎么做呢？最终这个文件又是如何落到宿主机上的硬盘文件的呢？这一节，我们一起来看一看。</p>
<h4 id="48-1-前端设备驱动virtio-blk"><a href="#48-1-前端设备驱动virtio-blk" class="headerlink" title="48.1 前端设备驱动virtio_blk"></a>48.1 前端设备驱动virtio_blk</h4><p>虚拟机里面的进程写入一个文件，当然要通过文件系统。整个过程和咱们在<strong>文件系统</strong>那一节讲的过程没有区别。只是到了设备驱动层，我们看到的就不是普通的硬盘驱动了，而是virtio的驱动。</p>
<p>virtio的驱动程序代码在Linux操作系统的源代码里面，文件名叫drivers/block/virtio_blk.c。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> error<span class="token punctuation">;</span>
    virtblk_wq <span class="token operator">=</span> <span class="token function">alloc_workqueue</span><span class="token punctuation">(</span><span class="token string">"virtio-blk"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    major <span class="token operator">=</span> <span class="token function">register_blkdev</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"virtblk"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    error <span class="token operator">=</span> <span class="token function">register_virtio_driver</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>virtio_blk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token function">module_init</span><span class="token punctuation">(</span>init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>fini<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">MODULE_DEVICE_TABLE</span><span class="token punctuation">(</span>virtio<span class="token punctuation">,</span> id_table<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_DESCRIPTION</span><span class="token punctuation">(</span><span class="token string">"Virtio block driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">virtio_driver</span> virtio_blk <span class="token operator">=</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">.</span>driver<span class="token punctuation">.</span>name            <span class="token operator">=</span> KBUILD_MODNAME<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>driver<span class="token punctuation">.</span>owner           <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>id_table               <span class="token operator">=</span> id_table<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>probe                  <span class="token operator">=</span> virtblk_probe<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>remove                 <span class="token operator">=</span> virtblk_remove<span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>前面我们介绍过设备驱动程序，从这里的代码中，我们能看到非常熟悉的结构。它会创建一个workqueue，注册一个块设备，并获得一个主设备号，然后注册一个驱动函数virtio_blk。</p>
<p>当一个设备驱动作为一个内核模块被初始化的时候，probe函数会被调用，因而我们来看一下virtblk_probe。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">virtblk_probe</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">virtio_device</span> <span class="token operator">*</span>vdev<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">virtio_blk</span> <span class="token operator">*</span>vblk<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">request_queue</span> <span class="token operator">*</span>q<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    vdev<span class="token operator">-&gt;</span>priv <span class="token operator">=</span> vblk <span class="token operator">=</span> <span class="token function">kmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>vblk<span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vblk<span class="token operator">-&gt;</span>vdev <span class="token operator">=</span> vdev<span class="token punctuation">;</span>
    vblk<span class="token operator">-&gt;</span>sg_elems <span class="token operator">=</span> sg_elems<span class="token punctuation">;</span>
    <span class="token function">INIT_WORK</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vblk<span class="token operator">-&gt;</span>config_work<span class="token punctuation">,</span> virtblk_config_changed_work<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    err <span class="token operator">=</span> <span class="token function">init_vq</span><span class="token punctuation">(</span>vblk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    vblk<span class="token operator">-&gt;</span>disk <span class="token operator">=</span> <span class="token function">alloc_disk</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> PART_BITS<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vblk<span class="token operator">-&gt;</span>tag_set<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>vblk<span class="token operator">-&gt;</span>tag_set<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    vblk<span class="token operator">-&gt;</span>tag_set<span class="token punctuation">.</span>ops <span class="token operator">=</span> <span class="token operator">&amp;</span>virtio_mq_ops<span class="token punctuation">;</span>
    vblk<span class="token operator">-&gt;</span>tag_set<span class="token punctuation">.</span>queue_depth <span class="token operator">=</span> virtblk_queue_depth<span class="token punctuation">;</span>
    vblk<span class="token operator">-&gt;</span>tag_set<span class="token punctuation">.</span>numa_node <span class="token operator">=</span> NUMA_NO_NODE<span class="token punctuation">;</span>
    vblk<span class="token operator">-&gt;</span>tag_set<span class="token punctuation">.</span>flags <span class="token operator">=</span> BLK_MQ_F_SHOULD_MERGE<span class="token punctuation">;</span>
    vblk<span class="token operator">-&gt;</span>tag_set<span class="token punctuation">.</span>cmd_size <span class="token operator">=</span>
        <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">virtblk_req</span><span class="token punctuation">)</span> <span class="token operator">+</span>
        <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">scatterlist</span><span class="token punctuation">)</span> <span class="token operator">*</span> sg_elems<span class="token punctuation">;</span>
    vblk<span class="token operator">-&gt;</span>tag_set<span class="token punctuation">.</span>driver_data <span class="token operator">=</span> vblk<span class="token punctuation">;</span>
    vblk<span class="token operator">-&gt;</span>tag_set<span class="token punctuation">.</span>nr_hw_queues <span class="token operator">=</span> vblk<span class="token operator">-&gt;</span>num_vqs<span class="token punctuation">;</span>
    err <span class="token operator">=</span> <span class="token function">blk_mq_alloc_tag_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vblk<span class="token operator">-&gt;</span>tag_set<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    q <span class="token operator">=</span> <span class="token function">blk_mq_init_queue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vblk<span class="token operator">-&gt;</span>tag_set<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vblk<span class="token operator">-&gt;</span>disk<span class="token operator">-&gt;</span>queue <span class="token operator">=</span> q<span class="token punctuation">;</span>
    q<span class="token operator">-&gt;</span>queuedata <span class="token operator">=</span> vblk<span class="token punctuation">;</span>
    <span class="token function">virtblk_name_format</span><span class="token punctuation">(</span><span class="token string">"vd"</span><span class="token punctuation">,</span> index<span class="token punctuation">,</span> vblk<span class="token operator">-&gt;</span>disk<span class="token operator">-&gt;</span>disk_name<span class="token punctuation">,</span> DISK_NAME_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vblk<span class="token operator">-&gt;</span>disk<span class="token operator">-&gt;</span>major <span class="token operator">=</span> major<span class="token punctuation">;</span>
    vblk<span class="token operator">-&gt;</span>disk<span class="token operator">-&gt;</span>first_minor <span class="token operator">=</span> <span class="token function">index_to_minor</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vblk<span class="token operator">-&gt;</span>disk<span class="token operator">-&gt;</span>private_data <span class="token operator">=</span> vblk<span class="token punctuation">;</span>
    vblk<span class="token operator">-&gt;</span>disk<span class="token operator">-&gt;</span>fops <span class="token operator">=</span> <span class="token operator">&amp;</span>virtblk_fops<span class="token punctuation">;</span>
    vblk<span class="token operator">-&gt;</span>disk<span class="token operator">-&gt;</span>flags <span class="token operator">|=</span> GENHD_FL_EXT_DEVT<span class="token punctuation">;</span>
    vblk<span class="token operator">-&gt;</span>index <span class="token operator">=</span> index<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">device_add_disk</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vdev<span class="token operator">-&gt;</span>dev<span class="token punctuation">,</span> vblk<span class="token operator">-&gt;</span>disk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    err <span class="token operator">=</span> <span class="token function">device_create_file</span><span class="token punctuation">(</span><span class="token function">disk_to_dev</span><span class="token punctuation">(</span>vblk<span class="token operator">-&gt;</span>disk<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>dev_attr_serial<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在virtblk_probe中，我们首先看到的是struct request_queue，这是每一个块设备都有的一个队列。还记得吗？它有两个函数，一个是make_request_fn函数，用于生成request；另一个是request_fn函数，用于处理request。</p>
<p>这个request_queue的初始化过程在blk_mq_init_queue中。它会调用blk_mq_init_allocated_queue-&gt;blk_queue_make_request。在这里面，我们可以将make_request_fn函数设置为blk_mq_make_request，也就是说，一旦上层有写入请求，我们就通过blk_mq_make_request这个函数，将请求放入request_queue队列中。</p>
<p>另外，在virtblk_probe中，我们会初始化一个gendisk。前面我们也讲了，每一个块设备都有这样一个结构。</p>
<p>在virtblk_probe中，还有一件重要的事情就是，init_vq会来初始化virtqueue。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">init_vq</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">virtio_blk</span> <span class="token operator">*</span>vblk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> err<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    vq_callback_t <span class="token operator">*</span><span class="token operator">*</span>callbacks<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>names<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">virtqueue</span> <span class="token operator">*</span><span class="token operator">*</span>vqs<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> num_vqs<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">virtio_device</span> <span class="token operator">*</span>vdev <span class="token operator">=</span> vblk<span class="token operator">-&gt;</span>vdev<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    vblk<span class="token operator">-&gt;</span>vqs <span class="token operator">=</span> <span class="token function">kmalloc_array</span><span class="token punctuation">(</span>num_vqs<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>vblk<span class="token operator">-&gt;</span>vqs<span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    names <span class="token operator">=</span> <span class="token function">kmalloc_array</span><span class="token punctuation">(</span>num_vqs<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>names<span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    callbacks <span class="token operator">=</span> <span class="token function">kmalloc_array</span><span class="token punctuation">(</span>num_vqs<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>callbacks<span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vqs <span class="token operator">=</span> <span class="token function">kmalloc_array</span><span class="token punctuation">(</span>num_vqs<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>vqs<span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num_vqs<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        callbacks<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> virtblk_done<span class="token punctuation">;</span>
        names<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> vblk<span class="token operator">-&gt;</span>vqs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* Discover virtqueues and write information to configuration.  */</span>
    err <span class="token operator">=</span> <span class="token function">virtio_find_vqs</span><span class="token punctuation">(</span>vdev<span class="token punctuation">,</span> num_vqs<span class="token punctuation">,</span> vqs<span class="token punctuation">,</span> callbacks<span class="token punctuation">,</span> names<span class="token punctuation">,</span> <span class="token operator">&amp;</span>desc<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num_vqs<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        vblk<span class="token operator">-&gt;</span>vqs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>vq <span class="token operator">=</span> vqs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    vblk<span class="token operator">-&gt;</span>num_vqs <span class="token operator">=</span> num_vqs<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>按照上面的原理来说，virtqueue是一个介于客户机前端和qemu后端的一个结构，用于在这两端之间传递数据。这里建立的struct virtqueue是客户机前端对于队列的管理的数据结构，在客户机的linux内核中通过kmalloc_array进行分配。</p>
<p>而队列的实体需要通过函数virtio_find_vqs查找或者生成，所以这里我们还把callback函数指定为virtblk_done。当buffer使用发生变化的时候，我们需要调用这个callback函数进行通知。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span>
<span class="token keyword">int</span> <span class="token function">virtio_find_vqs</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">virtio_device</span> <span class="token operator">*</span>vdev<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> nvqs<span class="token punctuation">,</span>
            <span class="token keyword">struct</span> <span class="token class-name">virtqueue</span> <span class="token operator">*</span>vqs<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> vq_callback_t <span class="token operator">*</span>callbacks<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
            <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token keyword">const</span> names<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
            <span class="token keyword">struct</span> <span class="token class-name">irq_affinity</span> <span class="token operator">*</span>desc<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> vdev<span class="token operator">-&gt;</span>config<span class="token operator">-&gt;</span><span class="token function">find_vqs</span><span class="token punctuation">(</span>vdev<span class="token punctuation">,</span> nvqs<span class="token punctuation">,</span> vqs<span class="token punctuation">,</span> callbacks<span class="token punctuation">,</span> names<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> desc<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">virtio_config_ops</span> virtio_pci_config_ops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>get                <span class="token operator">=</span> vp_get<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>set                <span class="token operator">=</span> vp_set<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>generation         <span class="token operator">=</span> vp_generation<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>get_status         <span class="token operator">=</span> vp_get_status<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>set_status         <span class="token operator">=</span> vp_set_status<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>reset              <span class="token operator">=</span> vp_reset<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>find_vqs           <span class="token operator">=</span> vp_modern_find_vqs<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>del_vqs            <span class="token operator">=</span> vp_del_vqs<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>get_features       <span class="token operator">=</span> vp_get_features<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>finalize_features  <span class="token operator">=</span> vp_finalize_features<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>bus_name           <span class="token operator">=</span> vp_bus_name<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>set_vq_affinity    <span class="token operator">=</span> vp_set_vq_affinity<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>get_vq_affinity    <span class="token operator">=</span> vp_get_vq_affinity<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>根据virtio_config_ops的定义，virtio_find_vqs会调用vp_modern_find_vqs。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">vp_modern_find_vqs</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">virtio_device</span> <span class="token operator">*</span>vdev<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> nvqs<span class="token punctuation">,</span>
                  <span class="token keyword">struct</span> <span class="token class-name">virtqueue</span> <span class="token operator">*</span>vqs<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                  vq_callback_t <span class="token operator">*</span>callbacks<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                  <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token keyword">const</span> names<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">const</span> bool <span class="token operator">*</span>ctx<span class="token punctuation">,</span>
                  <span class="token keyword">struct</span> <span class="token class-name">irq_affinity</span> <span class="token operator">*</span>desc<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">virtio_pci_device</span> <span class="token operator">*</span>vp_dev <span class="token operator">=</span> <span class="token function">to_vp_device</span><span class="token punctuation">(</span>vdev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">virtqueue</span> <span class="token operator">*</span>vq<span class="token punctuation">;</span>
    <span class="token keyword">int</span> rc <span class="token operator">=</span> <span class="token function">vp_find_vqs</span><span class="token punctuation">(</span>vdev<span class="token punctuation">,</span> nvqs<span class="token punctuation">,</span> vqs<span class="token punctuation">,</span> callbacks<span class="token punctuation">,</span> names<span class="token punctuation">,</span> ctx<span class="token punctuation">,</span> desc<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* Select and activate all queues. Has to be done last: once we do
     * this, there's no way to go back except reset.
     */</span>
    <span class="token function">list_for_each_entry</span><span class="token punctuation">(</span>vq<span class="token punctuation">,</span> <span class="token operator">&amp;</span>vdev<span class="token operator">-&gt;</span>vqs<span class="token punctuation">,</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">vp_iowrite16</span><span class="token punctuation">(</span>vq<span class="token operator">-&gt;</span>index<span class="token punctuation">,</span> <span class="token operator">&amp;</span>vp_dev<span class="token operator">-&gt;</span>common<span class="token operator">-&gt;</span>queue_select<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">vp_iowrite16</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>vp_dev<span class="token operator">-&gt;</span>common<span class="token operator">-&gt;</span>queue_enable<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在vp_modern_find_vqs中，vp_find_vqs会调用vp_find_vqs_intx。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">vp_find_vqs_intx</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">virtio_device</span> <span class="token operator">*</span>vdev<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> nvqs<span class="token punctuation">,</span>
        <span class="token keyword">struct</span> <span class="token class-name">virtqueue</span> <span class="token operator">*</span>vqs<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> vq_callback_t <span class="token operator">*</span>callbacks<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token keyword">const</span> names<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">const</span> bool <span class="token operator">*</span>ctx<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">virtio_pci_device</span> <span class="token operator">*</span>vp_dev <span class="token operator">=</span> <span class="token function">to_vp_device</span><span class="token punctuation">(</span>vdev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> err<span class="token punctuation">;</span>

    vp_dev<span class="token operator">-&gt;</span>vqs <span class="token operator">=</span> <span class="token function">kcalloc</span><span class="token punctuation">(</span>nvqs<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>vp_dev<span class="token operator">-&gt;</span>vqs<span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    err <span class="token operator">=</span> <span class="token function">request_irq</span><span class="token punctuation">(</span>vp_dev<span class="token operator">-&gt;</span>pci_dev<span class="token operator">-&gt;</span>irq<span class="token punctuation">,</span> vp_interrupt<span class="token punctuation">,</span> IRQF_SHARED<span class="token punctuation">,</span>
            <span class="token function">dev_name</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vdev<span class="token operator">-&gt;</span>dev<span class="token punctuation">)</span><span class="token punctuation">,</span> vp_dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vp_dev<span class="token operator">-&gt;</span>intx_enabled <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    vp_dev<span class="token operator">-&gt;</span>per_vq_vectors <span class="token operator">=</span> false<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nvqs<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        vqs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">vp_setup_vq</span><span class="token punctuation">(</span>vdev<span class="token punctuation">,</span> i<span class="token punctuation">,</span> callbacks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> names<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>
                     ctx <span class="token operator">?</span> ctx<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">:</span> false<span class="token punctuation">,</span>
                     VIRTIO_MSI_NO_VECTOR<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在vp_find_vqs_intx中，我们通过request_irq注册一个中断处理函数vp_interrupt，当设备的配置信息发生改变，会产生一个中断，当设备向队列中写入信息时，也会会产生一个中断，我们称为vq中断，中断处理函数需要调用相应的队列的回调函数。</p>
<p>然后，我们根据队列的数目，依次调用vp_setup_vq，完成virtqueue、vring的分配和初始化。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">virtqueue</span> <span class="token operator">*</span><span class="token function">vp_setup_vq</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">virtio_device</span> <span class="token operator">*</span>vdev<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> index<span class="token punctuation">,</span>
                     <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>callback<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">virtqueue</span> <span class="token operator">*</span>vq<span class="token punctuation">)</span><span class="token punctuation">,</span>
                     <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span>
                     bool ctx<span class="token punctuation">,</span>
                     u16 msix_vec<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">virtio_pci_device</span> <span class="token operator">*</span>vp_dev <span class="token operator">=</span> <span class="token function">to_vp_device</span><span class="token punctuation">(</span>vdev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">virtio_pci_vq_info</span> <span class="token operator">*</span>info <span class="token operator">=</span> <span class="token function">kmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span> <span class="token operator">*</span>info<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">virtqueue</span> <span class="token operator">*</span>vq<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    vq <span class="token operator">=</span> vp_dev<span class="token operator">-&gt;</span><span class="token function">setup_vq</span><span class="token punctuation">(</span>vp_dev<span class="token punctuation">,</span> info<span class="token punctuation">,</span> index<span class="token punctuation">,</span> callback<span class="token punctuation">,</span> name<span class="token punctuation">,</span> ctx<span class="token punctuation">,</span>
                  msix_vec<span class="token punctuation">)</span><span class="token punctuation">;</span>
    info<span class="token operator">-&gt;</span>vq <span class="token operator">=</span> vq<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">spin_lock_irqsave</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vp_dev<span class="token operator">-&gt;</span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">list_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>info<span class="token operator">-&gt;</span>node<span class="token punctuation">,</span> <span class="token operator">&amp;</span>vp_dev<span class="token operator">-&gt;</span>virtqueues<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">spin_unlock_irqrestore</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vp_dev<span class="token operator">-&gt;</span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>info<span class="token operator">-&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    vp_dev<span class="token operator">-&gt;</span>vqs<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> info<span class="token punctuation">;</span>
    <span class="token keyword">return</span> vq<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">virtqueue</span> <span class="token operator">*</span><span class="token function">setup_vq</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">virtio_pci_device</span> <span class="token operator">*</span>vp_dev<span class="token punctuation">,</span>
                  <span class="token keyword">struct</span> <span class="token class-name">virtio_pci_vq_info</span> <span class="token operator">*</span>info<span class="token punctuation">,</span>
                  <span class="token keyword">unsigned</span> index<span class="token punctuation">,</span>
                  <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>callback<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">virtqueue</span> <span class="token operator">*</span>vq<span class="token punctuation">)</span><span class="token punctuation">,</span>
                  <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span>
                  bool ctx<span class="token punctuation">,</span>
                  u16 msix_vec<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">virtio_pci_common_cfg</span> __iomem <span class="token operator">*</span>cfg <span class="token operator">=</span> vp_dev<span class="token operator">-&gt;</span>common<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">virtqueue</span> <span class="token operator">*</span>vq<span class="token punctuation">;</span>
    u16 num<span class="token punctuation">,</span> off<span class="token punctuation">;</span>
    <span class="token keyword">int</span> err<span class="token punctuation">;</span>

    <span class="token comment">/* Select the queue we're interested in */</span>
    <span class="token function">vp_iowrite16</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cfg<span class="token operator">-&gt;</span>queue_select<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* Check if queue is either not available or already active. */</span>
    num <span class="token operator">=</span> <span class="token function">vp_ioread16</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cfg<span class="token operator">-&gt;</span>queue_size<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* get offset of notification word for this vq */</span>
    off <span class="token operator">=</span> <span class="token function">vp_ioread16</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cfg<span class="token operator">-&gt;</span>queue_notify_off<span class="token punctuation">)</span><span class="token punctuation">;</span>

    info<span class="token operator">-&gt;</span>msix_vector <span class="token operator">=</span> msix_vec<span class="token punctuation">;</span>

    <span class="token comment">/* create the vring */</span>
    vq <span class="token operator">=</span> <span class="token function">vring_create_virtqueue</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> num<span class="token punctuation">,</span>
                    SMP_CACHE_BYTES<span class="token punctuation">,</span> <span class="token operator">&amp;</span>vp_dev<span class="token operator">-&gt;</span>vdev<span class="token punctuation">,</span>
                    true<span class="token punctuation">,</span> true<span class="token punctuation">,</span> ctx<span class="token punctuation">,</span>
                    vp_notify<span class="token punctuation">,</span> callback<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* activate the queue */</span>
    <span class="token function">vp_iowrite16</span><span class="token punctuation">(</span><span class="token function">virtqueue_get_vring_size</span><span class="token punctuation">(</span>vq<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>cfg<span class="token operator">-&gt;</span>queue_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">vp_iowrite64_twopart</span><span class="token punctuation">(</span><span class="token function">virtqueue_get_desc_addr</span><span class="token punctuation">(</span>vq<span class="token punctuation">)</span><span class="token punctuation">,</span>
                 <span class="token operator">&amp;</span>cfg<span class="token operator">-&gt;</span>queue_desc_lo<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cfg<span class="token operator">-&gt;</span>queue_desc_hi<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">vp_iowrite64_twopart</span><span class="token punctuation">(</span><span class="token function">virtqueue_get_avail_addr</span><span class="token punctuation">(</span>vq<span class="token punctuation">)</span><span class="token punctuation">,</span>
                 <span class="token operator">&amp;</span>cfg<span class="token operator">-&gt;</span>queue_avail_lo<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cfg<span class="token operator">-&gt;</span>queue_avail_hi<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">vp_iowrite64_twopart</span><span class="token punctuation">(</span><span class="token function">virtqueue_get_used_addr</span><span class="token punctuation">(</span>vq<span class="token punctuation">)</span><span class="token punctuation">,</span>
                 <span class="token operator">&amp;</span>cfg<span class="token operator">-&gt;</span>queue_used_lo<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cfg<span class="token operator">-&gt;</span>queue_used_hi<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> vq<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">virtqueue</span> <span class="token operator">*</span><span class="token function">vring_create_virtqueue</span><span class="token punctuation">(</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> index<span class="token punctuation">,</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> num<span class="token punctuation">,</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> vring_align<span class="token punctuation">,</span>
    <span class="token keyword">struct</span> <span class="token class-name">virtio_device</span> <span class="token operator">*</span>vdev<span class="token punctuation">,</span>
    bool weak_barriers<span class="token punctuation">,</span>
    bool may_reduce_num<span class="token punctuation">,</span>
    bool context<span class="token punctuation">,</span>
    <span class="token function">bool</span> <span class="token punctuation">(</span><span class="token operator">*</span>notify<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">virtqueue</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>callback<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">virtqueue</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">virtqueue</span> <span class="token operator">*</span>vq<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>queue <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    dma_addr_t dma_addr<span class="token punctuation">;</span>
    size_t queue_size_in_bytes<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">vring</span> vring<span class="token punctuation">;</span>

    <span class="token comment">/* TODO: allocate each queue chunk individually */</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> num <span class="token operator">&amp;&amp;</span> <span class="token function">vring_size</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> vring_align<span class="token punctuation">)</span> <span class="token operator">&gt;</span> PAGE_SIZE<span class="token punctuation">;</span> num <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        queue <span class="token operator">=</span> <span class="token function">vring_alloc_queue</span><span class="token punctuation">(</span>vdev<span class="token punctuation">,</span> <span class="token function">vring_size</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> vring_align<span class="token punctuation">)</span><span class="token punctuation">,</span>
                      <span class="token operator">&amp;</span>dma_addr<span class="token punctuation">,</span>
                      GFP_KERNEL<span class="token operator">|</span>__GFP_NOWARN<span class="token operator">|</span>__GFP_ZERO<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>queue<span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* Try to get a single page. You are my only hope! */</span>
        queue <span class="token operator">=</span> <span class="token function">vring_alloc_queue</span><span class="token punctuation">(</span>vdev<span class="token punctuation">,</span> <span class="token function">vring_size</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> vring_align<span class="token punctuation">)</span><span class="token punctuation">,</span>
                      <span class="token operator">&amp;</span>dma_addr<span class="token punctuation">,</span> GFP_KERNEL<span class="token operator">|</span>__GFP_ZERO<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    queue_size_in_bytes <span class="token operator">=</span> <span class="token function">vring_size</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> vring_align<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">vring_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vring<span class="token punctuation">,</span> num<span class="token punctuation">,</span> queue<span class="token punctuation">,</span> vring_align<span class="token punctuation">)</span><span class="token punctuation">;</span>

    vq <span class="token operator">=</span> <span class="token function">__vring_new_virtqueue</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> vring<span class="token punctuation">,</span> vdev<span class="token punctuation">,</span> weak_barriers<span class="token punctuation">,</span> context<span class="token punctuation">,</span> notify<span class="token punctuation">,</span> callback<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">to_vvq</span><span class="token punctuation">(</span>vq<span class="token punctuation">)</span><span class="token operator">-&gt;</span>queue_dma_addr <span class="token operator">=</span> dma_addr<span class="token punctuation">;</span>
    <span class="token function">to_vvq</span><span class="token punctuation">(</span>vq<span class="token punctuation">)</span><span class="token operator">-&gt;</span>queue_size_in_bytes <span class="token operator">=</span> queue_size_in_bytes<span class="token punctuation">;</span>
    <span class="token function">to_vvq</span><span class="token punctuation">(</span>vq<span class="token punctuation">)</span><span class="token operator">-&gt;</span>we_own_ring <span class="token operator">=</span> true<span class="token punctuation">;</span>

    <span class="token keyword">return</span> vq<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在vring_create_virtqueue中，我们会调用vring_alloc_queue，来创建队列所需要的内存空间，然后调用vring_init初始化结构struct vring，来管理队列的内存空间，调用__vring_new_virtqueue，来创建struct vring_virtqueue。</p>
<p>这个结构的一开始，是struct virtqueue，它也是struct virtqueue的一个扩展，紧接着后面就是struct vring。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">vring_virtqueue</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">virtqueue</span> vq<span class="token punctuation">;</span>

    <span class="token comment">/* Actual memory layout for this queue */</span>
    <span class="token keyword">struct</span> <span class="token class-name">vring</span> vring<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>至此我们发现，虚拟机里面的virtio的前端是这样的结构：struct virtio_device里面有一个struct vring_virtqueue，在struct vring_virtqueue里面有一个struct vring。</p>
<h4 id="48-2-中间virtio队列的管理"><a href="#48-2-中间virtio队列的管理" class="headerlink" title="48.2 中间virtio队列的管理"></a>48.2 中间virtio队列的管理</h4><p>还记不记得我们上面讲qemu初始化的时候，virtio的后端有数据结构VirtIODevice，VirtQueue和vring一模一样，前端和后端对应起来，都应该指向刚才创建的那一段内存。</p>
<p>现在的问题是，我们刚才分配的内存在客户机的内核里面，如何告知qemu来访问这段内存呢？</p>
<p>别忘了，qemu模拟出来的virtio block device只是一个PCI设备。对于客户机来讲，这是一个外部设备，我们可以通过给外部设备发送指令的方式告知外部设备，这就是代码中vp_iowrite16的作用。它会调用专门给外部设备发送指令的函数iowrite，告诉外部的PCI设备。</p>
<p>告知的有三个地址virtqueue_get_desc_addr、virtqueue_get_avail_addr，virtqueue_get_used_addr。从客户机角度来看，这里面的地址都是物理地址，也即GPA（Guest Physical Address）。因为只有物理地址才是客户机和qemu程序都认可的地址，本来客户机的物理内存也是qemu模拟出来的。</p>
<p>在qemu中，对PCI总线添加一个设备的时候，我们会调用virtio_pci_device_plugged。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">virtio_pci_device_plugged</span><span class="token punctuation">(</span>DeviceState <span class="token operator">*</span>d<span class="token punctuation">,</span> Error <span class="token operator">*</span><span class="token operator">*</span>errp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    VirtIOPCIProxy <span class="token operator">*</span>proxy <span class="token operator">=</span> <span class="token function">VIRTIO_PCI</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">memory_region_init_io</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>proxy<span class="token operator">-&gt;</span>bar<span class="token punctuation">,</span> <span class="token function">OBJECT</span><span class="token punctuation">(</span>proxy<span class="token punctuation">)</span><span class="token punctuation">,</span>
                              <span class="token operator">&amp;</span>virtio_pci_config_ops<span class="token punctuation">,</span>
                              proxy<span class="token punctuation">,</span> <span class="token string">"virtio-pci"</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">const</span> MemoryRegionOps virtio_pci_config_ops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>read <span class="token operator">=</span> virtio_pci_config_read<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>write <span class="token operator">=</span> virtio_pci_config_write<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>impl <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span>min_access_size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
        <span class="token punctuation">.</span>max_access_size <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>endianness <span class="token operator">=</span> DEVICE_LITTLE_ENDIAN<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里面，对于这个加载的设备进行I/O操作，会映射到读写某一块内存空间，对应的操作为virtio_pci_config_ops，也即写入这块内存空间，这就相当于对于这个PCI设备进行某种配置。</p>
<p>对PCI设备进行配置的时候，会有这样的调用链：virtio_pci_config_write-&gt;virtio_ioport_write-&gt;virtio_queue_set_addr。设置virtio的queue的地址是一项很重要的操作。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">virtio_queue_set_addr</span><span class="token punctuation">(</span>VirtIODevice <span class="token operator">*</span>vdev<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> hwaddr addr<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    vdev<span class="token operator">-&gt;</span>vq<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">.</span>vring<span class="token punctuation">.</span>desc <span class="token operator">=</span> addr<span class="token punctuation">;</span>
    <span class="token function">virtio_queue_update_rings</span><span class="token punctuation">(</span>vdev<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从这里我们可以看出，qemu后端的VirtIODevice的VirtQueue的vring的地址，被设置成了刚才给队列分配的内存的GPA。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/virtio队列的相关定义.jpg" alt="virtio队列的相关定义"></p>
<p>接着，我们来看一下这个队列的格式。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/virtio队列的格式.jpg" alt="virtio队列的格式"></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Virtio ring descriptors: 16 bytes.  These can chain together via "next". */</span>
<span class="token keyword">struct</span> <span class="token class-name">vring_desc</span> <span class="token punctuation">{</span>
    <span class="token comment">/* Address (guest-physical). */</span>
    __virtio64 addr<span class="token punctuation">;</span>
    <span class="token comment">/* Length. */</span>
    __virtio32 len<span class="token punctuation">;</span>
    <span class="token comment">/* The flags as indicated above. */</span>
    __virtio16 flags<span class="token punctuation">;</span>
    <span class="token comment">/* We chain unused descriptors via this, too */</span>
    __virtio16 next<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">vring_avail</span> <span class="token punctuation">{</span>
    __virtio16 flags<span class="token punctuation">;</span>
    __virtio16 idx<span class="token punctuation">;</span>
    __virtio16 ring<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/* u32 is used here for ids for padding reasons. */</span>
<span class="token keyword">struct</span> <span class="token class-name">vring_used_elem</span> <span class="token punctuation">{</span>
    <span class="token comment">/* Index of start of used descriptor chain. */</span>
    __virtio32 id<span class="token punctuation">;</span>
    <span class="token comment">/* Total length of the descriptor chain which was used (written to) */</span>
    __virtio32 len<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">vring_used</span> <span class="token punctuation">{</span>
    __virtio16 flags<span class="token punctuation">;</span>
    __virtio16 idx<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">vring_used_elem</span> ring<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">vring</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> num<span class="token punctuation">;</span>

    <span class="token keyword">struct</span> <span class="token class-name">vring_desc</span> <span class="token operator">*</span>desc<span class="token punctuation">;</span>

    <span class="token keyword">struct</span> <span class="token class-name">vring_avail</span> <span class="token operator">*</span>avail<span class="token punctuation">;</span>

    <span class="token keyword">struct</span> <span class="token class-name">vring_used</span> <span class="token operator">*</span>used<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>vring包含三个成员：</p>
<ul>
<li>vring_desc指向分配的内存块，用于存放客户机和qemu之间传输的数据。</li>
<li>avail-&gt;ring[]是发送端维护的环形队列，指向需要接收端处理的vring_desc。</li>
<li>used-&gt;ring[]是接收端维护的环形队列，指向自己已经处理过了的vring_desc。</li>
</ul>
<h4 id="48-3-数据写入的流程"><a href="#48-3-数据写入的流程" class="headerlink" title="48.3 数据写入的流程"></a>48.3 数据写入的流程</h4><p>接下来，我们来看，真的写入一个数据的时候，会发生什么。</p>
<p>按照上面virtio驱动初始化的时候的逻辑，blk_mq_make_request会被调用。这个函数比较复杂，会分成多个分支，但是最终都会调用到request_queue的virtio_mq_ops的queue_rq函数。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">request_queue</span> <span class="token operator">*</span>q <span class="token operator">=</span> rq<span class="token operator">-&gt;</span>q<span class="token punctuation">;</span>
q<span class="token operator">-&gt;</span>mq_ops<span class="token operator">-&gt;</span><span class="token function">queue_rq</span><span class="token punctuation">(</span>hctx<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bd<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">blk_mq_ops</span> virtio_mq_ops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>queue_rq       <span class="token operator">=</span> virtio_queue_rq<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>complete       <span class="token operator">=</span> virtblk_request_done<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>init_request   <span class="token operator">=</span> virtblk_init_request<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>map_queues     <span class="token operator">=</span> virtblk_map_queues<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>根据virtio_mq_ops的定义，我们现在要调用virtio_queue_rq。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> blk_status_t <span class="token function">virtio_queue_rq</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">blk_mq_hw_ctx</span> <span class="token operator">*</span>hctx<span class="token punctuation">,</span>
               <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">blk_mq_queue_data</span> <span class="token operator">*</span>bd<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">virtio_blk</span> <span class="token operator">*</span>vblk <span class="token operator">=</span> hctx<span class="token operator">-&gt;</span>queue<span class="token operator">-&gt;</span>queuedata<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">request</span> <span class="token operator">*</span>req <span class="token operator">=</span> bd<span class="token operator">-&gt;</span>rq<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">virtblk_req</span> <span class="token operator">*</span>vbr <span class="token operator">=</span> <span class="token function">blk_mq_rq_to_pdu</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    err <span class="token operator">=</span> <span class="token function">virtblk_add_req</span><span class="token punctuation">(</span>vblk<span class="token operator">-&gt;</span>vqs<span class="token punctuation">[</span>qid<span class="token punctuation">]</span><span class="token punctuation">.</span>vq<span class="token punctuation">,</span> vbr<span class="token punctuation">,</span> vbr<span class="token operator">-&gt;</span>sg<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>notify<span class="token punctuation">)</span>
        <span class="token function">virtqueue_notify</span><span class="token punctuation">(</span>vblk<span class="token operator">-&gt;</span>vqs<span class="token punctuation">[</span>qid<span class="token punctuation">]</span><span class="token punctuation">.</span>vq<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> BLK_STS_OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在virtio_queue_rq中，我们会将请求写入的数据，通过virtblk_add_req放入struct virtqueue。</p>
<p>因此，接下来的调用链为：virtblk_add_req-&gt;virtqueue_add_sgs-&gt;virtqueue_add。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">virtqueue_add</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">virtqueue</span> <span class="token operator">*</span>_vq<span class="token punctuation">,</span>
                <span class="token keyword">struct</span> <span class="token class-name">scatterlist</span> <span class="token operator">*</span>sgs<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                <span class="token keyword">unsigned</span> <span class="token keyword">int</span> total_sg<span class="token punctuation">,</span>
                <span class="token keyword">unsigned</span> <span class="token keyword">int</span> out_sgs<span class="token punctuation">,</span>
                <span class="token keyword">unsigned</span> <span class="token keyword">int</span> in_sgs<span class="token punctuation">,</span>
                <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">,</span>
                <span class="token keyword">void</span> <span class="token operator">*</span>ctx<span class="token punctuation">,</span>
                gfp_t gfp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">vring_virtqueue</span> <span class="token operator">*</span>vq <span class="token operator">=</span> <span class="token function">to_vvq</span><span class="token punctuation">(</span>_vq<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">scatterlist</span> <span class="token operator">*</span>sg<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">vring_desc</span> <span class="token operator">*</span>desc<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> n<span class="token punctuation">,</span> avail<span class="token punctuation">,</span> descs_used<span class="token punctuation">,</span> <span class="token function">uninitialized_var</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">,</span> err_idx<span class="token punctuation">;</span>
    <span class="token keyword">int</span> head<span class="token punctuation">;</span>
    bool indirect<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    head <span class="token operator">=</span> vq<span class="token operator">-&gt;</span>free_head<span class="token punctuation">;</span>

    indirect <span class="token operator">=</span> false<span class="token punctuation">;</span>
    desc <span class="token operator">=</span> vq<span class="token operator">-&gt;</span>vring<span class="token punctuation">.</span>desc<span class="token punctuation">;</span>
    i <span class="token operator">=</span> head<span class="token punctuation">;</span>
    descs_used <span class="token operator">=</span> total_sg<span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;</span> out_sgs<span class="token punctuation">;</span> n<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>sg <span class="token operator">=</span> sgs<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> sg<span class="token punctuation">;</span> sg <span class="token operator">=</span> <span class="token function">sg_next</span><span class="token punctuation">(</span>sg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            dma_addr_t addr <span class="token operator">=</span> <span class="token function">vring_map_one_sg</span><span class="token punctuation">(</span>vq<span class="token punctuation">,</span> sg<span class="token punctuation">,</span> DMA_TO_DEVICE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            desc<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>flags <span class="token operator">=</span> <span class="token function">cpu_to_virtio16</span><span class="token punctuation">(</span>_vq<span class="token operator">-&gt;</span>vdev<span class="token punctuation">,</span> VRING_DESC_F_NEXT<span class="token punctuation">)</span><span class="token punctuation">;</span>
            desc<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>addr <span class="token operator">=</span> <span class="token function">cpu_to_virtio64</span><span class="token punctuation">(</span>_vq<span class="token operator">-&gt;</span>vdev<span class="token punctuation">,</span> addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
            desc<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>len <span class="token operator">=</span> <span class="token function">cpu_to_virtio32</span><span class="token punctuation">(</span>_vq<span class="token operator">-&gt;</span>vdev<span class="token punctuation">,</span> sg<span class="token operator">-&gt;</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
            prev <span class="token operator">=</span> i<span class="token punctuation">;</span>
            i <span class="token operator">=</span> <span class="token function">virtio16_to_cpu</span><span class="token punctuation">(</span>_vq<span class="token operator">-&gt;</span>vdev<span class="token punctuation">,</span> desc<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* Last one doesn't continue. */</span>
    desc<span class="token punctuation">[</span>prev<span class="token punctuation">]</span><span class="token punctuation">.</span>flags <span class="token operator">&amp;=</span> <span class="token function">cpu_to_virtio16</span><span class="token punctuation">(</span>_vq<span class="token operator">-&gt;</span>vdev<span class="token punctuation">,</span> <span class="token operator">~</span>VRING_DESC_F_NEXT<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* We're using some buffers from the free list. */</span>
    vq<span class="token operator">-&gt;</span>vq<span class="token punctuation">.</span>num_free <span class="token operator">-=</span> descs_used<span class="token punctuation">;</span>

    <span class="token comment">/* Update free pointer */</span>
    vq<span class="token operator">-&gt;</span>free_head <span class="token operator">=</span> i<span class="token punctuation">;</span>

    <span class="token comment">/* Store token and indirect buffer state. */</span>
    vq<span class="token operator">-&gt;</span>desc_state<span class="token punctuation">[</span>head<span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>

    <span class="token comment">/* Put entry in available array (but don't update avail-&gt;idx until they do sync). */</span>
    avail <span class="token operator">=</span> vq<span class="token operator">-&gt;</span>avail_idx_shadow <span class="token operator">&amp;</span> <span class="token punctuation">(</span>vq<span class="token operator">-&gt;</span>vring<span class="token punctuation">.</span>num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    vq<span class="token operator">-&gt;</span>vring<span class="token punctuation">.</span>avail<span class="token operator">-&gt;</span>ring<span class="token punctuation">[</span>avail<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">cpu_to_virtio16</span><span class="token punctuation">(</span>_vq<span class="token operator">-&gt;</span>vdev<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* Descriptors and available array need to be set before we expose the new available array entries. */</span>
    <span class="token function">virtio_wmb</span><span class="token punctuation">(</span>vq<span class="token operator">-&gt;</span>weak_barriers<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vq<span class="token operator">-&gt;</span>avail_idx_shadow<span class="token operator">++</span><span class="token punctuation">;</span>
    vq<span class="token operator">-&gt;</span>vring<span class="token punctuation">.</span>avail<span class="token operator">-&gt;</span>idx <span class="token operator">=</span> <span class="token function">cpu_to_virtio16</span><span class="token punctuation">(</span>_vq<span class="token operator">-&gt;</span>vdev<span class="token punctuation">,</span> vq<span class="token operator">-&gt;</span>avail_idx_shadow<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vq<span class="token operator">-&gt;</span>num_added<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在virtqueue_add函数中，我们能看到，free_head指向的整个内存块空闲链表的起始位置，用head变量记住这个起始位置。</p>
<p>接下来，i也指向这个起始位置，然后是一个for循环，将数据放到内存块里面，放的过程中，next不断指向下一个空闲位置，这样空闲的内存块被不断的占用。等所有的写入都结束了，i就会指向这次存放的内存块的下一个空闲位置，然后free_head就指向i，因为前面的都填满了。</p>
<p>至此，从head到i之间的内存块，就是这次写入的全部数据。</p>
<p>于是，在vring的avail变量中，在ring[]数组中分配新的一项，在avail的位置，avail的计算是avail_idx_shadow &amp; (vq-&gt;vring.num - 1)，其中，avail_idx_shadow是上一次的avail的位置。这里如果超过了ring[]数组的下标，则重新跳到起始位置，就说明是一个环。这次分配的新的avail的位置就存放新写入的从head到i之间的内存块。然后是avail_idx_shadow++，这说明这一块内存可以被接收方读取了。</p>
<p>接下来，我们回到virtio_queue_rq，调用virtqueue_notify通知接收方。而virtqueue_notify会调用vp_notify。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">bool <span class="token function">vp_notify</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">virtqueue</span> <span class="token operator">*</span>vq<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">/* we write the queue's selector into the notification register to
     * signal the other end */</span>
    <span class="token function">iowrite16</span><span class="token punctuation">(</span>vq<span class="token operator">-&gt;</span>index<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> __iomem <span class="token operator">*</span><span class="token punctuation">)</span>vq<span class="token operator">-&gt;</span>priv<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后，我们写入一个I/O会触发VM exit。我们在解析CPU的时候看到过这个逻辑。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">kvm_cpu_exec</span><span class="token punctuation">(</span>CPUState <span class="token operator">*</span>cpu<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">kvm_run</span> <span class="token operator">*</span>run <span class="token operator">=</span> cpu<span class="token operator">-&gt;</span>kvm_run<span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">,</span> run_ret<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    run_ret <span class="token operator">=</span> <span class="token function">kvm_vcpu_ioctl</span><span class="token punctuation">(</span>cpu<span class="token punctuation">,</span> KVM_RUN<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>run<span class="token operator">-&gt;</span>exit_reason<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> KVM_EXIT_IO<span class="token operator">:</span>
            <span class="token function">DPRINTF</span><span class="token punctuation">(</span><span class="token string">"handle_io\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">/* Called outside BQL */</span>
            <span class="token function">kvm_handle_io</span><span class="token punctuation">(</span>run<span class="token operator">-&gt;</span>io<span class="token punctuation">.</span>port<span class="token punctuation">,</span> attrs<span class="token punctuation">,</span>
                          <span class="token punctuation">(</span>uint8_t <span class="token operator">*</span><span class="token punctuation">)</span>run <span class="token operator">+</span> run<span class="token operator">-&gt;</span>io<span class="token punctuation">.</span>data_offset<span class="token punctuation">,</span>
                          run<span class="token operator">-&gt;</span>io<span class="token punctuation">.</span>direction<span class="token punctuation">,</span>
                          run<span class="token operator">-&gt;</span>io<span class="token punctuation">.</span>size<span class="token punctuation">,</span>
                          run<span class="token operator">-&gt;</span>io<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
            ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这次写入的也是一个I/O的内存空间，同样会触发virtio_ioport_write，这次会调用virtio_queue_notify。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">virtio_queue_notify</span><span class="token punctuation">(</span>VirtIODevice <span class="token operator">*</span>vdev<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    VirtQueue <span class="token operator">*</span>vq <span class="token operator">=</span> <span class="token operator">&amp;</span>vdev<span class="token operator">-&gt;</span>vq<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>vq<span class="token operator">-&gt;</span>handle_aio_output<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">event_notifier_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vq<span class="token operator">-&gt;</span>host_notifier<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>vq<span class="token operator">-&gt;</span>handle_output<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        vq<span class="token operator">-&gt;</span><span class="token function">handle_output</span><span class="token punctuation">(</span>vdev<span class="token punctuation">,</span> vq<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>virtio_queue_notify会调用VirtQueue的handle_output函数，前面我们已经设置过这个函数了，是virtio_blk_handle_output。</p>
<p>接下来的调用链为：virtio_blk_handle_output-&gt;virtio_blk_handle_output_do-&gt;virtio_blk_handle_vq。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">bool <span class="token function">virtio_blk_handle_vq</span><span class="token punctuation">(</span>VirtIOBlock <span class="token operator">*</span>s<span class="token punctuation">,</span> VirtQueue <span class="token operator">*</span>vq<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    VirtIOBlockReq <span class="token operator">*</span>req<span class="token punctuation">;</span>
    MultiReqBuffer mrb <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    bool progress <span class="token operator">=</span> false<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        <span class="token function">virtio_queue_set_notification</span><span class="token punctuation">(</span>vq<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>req <span class="token operator">=</span> <span class="token function">virtio_blk_get_request</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> vq<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            progress <span class="token operator">=</span> true<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">virtio_blk_handle_request</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mrb<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">virtqueue_detach_element</span><span class="token punctuation">(</span>req<span class="token operator">-&gt;</span>vq<span class="token punctuation">,</span> <span class="token operator">&amp;</span>req<span class="token operator">-&gt;</span>elem<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">virtio_blk_free_request</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token function">virtio_queue_set_notification</span><span class="token punctuation">(</span>vq<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">virtio_queue_empty</span><span class="token punctuation">(</span>vq<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>mrb<span class="token punctuation">.</span>num_reqs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">virtio_blk_submit_multireq</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>blk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mrb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> progress<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在virtio_blk_handle_vq中，有一个while循环，在循环中调用函数virtio_blk_get_request从vq中取出请求，然后调用virtio_blk_handle_request处理从vq中取出的请求。</p>
<p>我们先来看virtio_blk_get_request。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> VirtIOBlockReq <span class="token operator">*</span><span class="token function">virtio_blk_get_request</span><span class="token punctuation">(</span>VirtIOBlock <span class="token operator">*</span>s<span class="token punctuation">,</span> VirtQueue <span class="token operator">*</span>vq<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    VirtIOBlockReq <span class="token operator">*</span>req <span class="token operator">=</span> <span class="token function">virtqueue_pop</span><span class="token punctuation">(</span>vq<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>VirtIOBlockReq<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>req<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">virtio_blk_init_request</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> vq<span class="token punctuation">,</span> req<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> req<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">virtqueue_pop</span><span class="token punctuation">(</span>VirtQueue <span class="token operator">*</span>vq<span class="token punctuation">,</span> size_t sz<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> head<span class="token punctuation">,</span> max<span class="token punctuation">;</span>
    VRingMemoryRegionCaches <span class="token operator">*</span>caches<span class="token punctuation">;</span>
    MemoryRegionCache <span class="token operator">*</span>desc_cache<span class="token punctuation">;</span>
    int64_t len<span class="token punctuation">;</span>
    VirtIODevice <span class="token operator">*</span>vdev <span class="token operator">=</span> vq<span class="token operator">-&gt;</span>vdev<span class="token punctuation">;</span>
    VirtQueueElement <span class="token operator">*</span>elem <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> out_num<span class="token punctuation">,</span> in_num<span class="token punctuation">,</span> elem_entries<span class="token punctuation">;</span>
    hwaddr addr<span class="token punctuation">[</span>VIRTQUEUE_MAX_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">iovec</span> iov<span class="token punctuation">[</span>VIRTQUEUE_MAX_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    VRingDesc desc<span class="token punctuation">;</span>
    <span class="token keyword">int</span> rc<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* When we start there are none of either input nor output. */</span>
    out_num <span class="token operator">=</span> in_num <span class="token operator">=</span> elem_entries <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    max <span class="token operator">=</span> vq<span class="token operator">-&gt;</span>vring<span class="token punctuation">.</span>num<span class="token punctuation">;</span>

    i <span class="token operator">=</span> head<span class="token punctuation">;</span>

    caches <span class="token operator">=</span> <span class="token function">vring_get_region_caches</span><span class="token punctuation">(</span>vq<span class="token punctuation">)</span><span class="token punctuation">;</span>
    desc_cache <span class="token operator">=</span> <span class="token operator">&amp;</span>caches<span class="token operator">-&gt;</span>desc<span class="token punctuation">;</span>
    <span class="token function">vring_desc_read</span><span class="token punctuation">(</span>vdev<span class="token punctuation">,</span> <span class="token operator">&amp;</span>desc<span class="token punctuation">,</span> desc_cache<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* Collect all the descriptors */</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        bool map_ok<span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>desc<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> VRING_DESC_F_WRITE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            map_ok <span class="token operator">=</span> <span class="token function">virtqueue_map_desc</span><span class="token punctuation">(</span>vdev<span class="token punctuation">,</span> <span class="token operator">&amp;</span>in_num<span class="token punctuation">,</span> addr <span class="token operator">+</span> out_num<span class="token punctuation">,</span>
                                        iov <span class="token operator">+</span> out_num<span class="token punctuation">,</span>
                                        VIRTQUEUE_MAX_SIZE <span class="token operator">-</span> out_num<span class="token punctuation">,</span> true<span class="token punctuation">,</span>
                                        desc<span class="token punctuation">.</span>addr<span class="token punctuation">,</span> desc<span class="token punctuation">.</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            map_ok <span class="token operator">=</span> <span class="token function">virtqueue_map_desc</span><span class="token punctuation">(</span>vdev<span class="token punctuation">,</span> <span class="token operator">&amp;</span>out_num<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> iov<span class="token punctuation">,</span>
                                        VIRTQUEUE_MAX_SIZE<span class="token punctuation">,</span> false<span class="token punctuation">,</span>
                                        desc<span class="token punctuation">.</span>addr<span class="token punctuation">,</span> desc<span class="token punctuation">.</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        rc <span class="token operator">=</span> <span class="token function">virtqueue_read_next_desc</span><span class="token punctuation">(</span>vdev<span class="token punctuation">,</span> <span class="token operator">&amp;</span>desc<span class="token punctuation">,</span> desc_cache<span class="token punctuation">,</span> max<span class="token punctuation">,</span> <span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>rc <span class="token operator">==</span> VIRTQUEUE_READ_DESC_MORE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* Now copy what we have collected and mapped */</span>
    elem <span class="token operator">=</span> <span class="token function">virtqueue_alloc_element</span><span class="token punctuation">(</span>sz<span class="token punctuation">,</span> out_num<span class="token punctuation">,</span> in_num<span class="token punctuation">)</span><span class="token punctuation">;</span>
    elem<span class="token operator">-&gt;</span>index <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> out_num<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        elem<span class="token operator">-&gt;</span>out_addr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> addr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        elem<span class="token operator">-&gt;</span>out_sg<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> iov<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> in_num<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        elem<span class="token operator">-&gt;</span>in_addr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> addr<span class="token punctuation">[</span>out_num <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        elem<span class="token operator">-&gt;</span>in_sg<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> iov<span class="token punctuation">[</span>out_num <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    vq<span class="token operator">-&gt;</span>inuse<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> elem<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们可以看到，virtio_blk_get_request会调用virtqueue_pop。在这里面，我们能看到对于vring的操作，也即从这里面将客户机里面写入的数据读取出来，放到VirtIOBlockReq结构中。</p>
<p>接下来，我们就要调用virtio_blk_handle_request处理这些数据。所以接下来的调用链为：virtio_blk_handle_request-&gt;virtio_blk_submit_multireq-&gt;submit_requests。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">submit_requests</span><span class="token punctuation">(</span>BlockBackend <span class="token operator">*</span>blk<span class="token punctuation">,</span> MultiReqBuffer <span class="token operator">*</span>mrb<span class="token punctuation">,</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> num_reqs<span class="token punctuation">,</span> <span class="token keyword">int</span> niov<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    QEMUIOVector <span class="token operator">*</span>qiov <span class="token operator">=</span> <span class="token operator">&amp;</span>mrb<span class="token operator">-&gt;</span>reqs<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token operator">-&gt;</span>qiov<span class="token punctuation">;</span>
    int64_t sector_num <span class="token operator">=</span> mrb<span class="token operator">-&gt;</span>reqs<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token operator">-&gt;</span>sector_num<span class="token punctuation">;</span>
    bool is_write <span class="token operator">=</span> mrb<span class="token operator">-&gt;</span>is_write<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>num_reqs <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> i<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">iovec</span> <span class="token operator">*</span>tmp_iov <span class="token operator">=</span> qiov<span class="token operator">-&gt;</span>iov<span class="token punctuation">;</span>
        <span class="token keyword">int</span> tmp_niov <span class="token operator">=</span> qiov<span class="token operator">-&gt;</span>niov<span class="token punctuation">;</span>
        <span class="token function">qemu_iovec_init</span><span class="token punctuation">(</span>qiov<span class="token punctuation">,</span> niov<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tmp_niov<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">qemu_iovec_add</span><span class="token punctuation">(</span>qiov<span class="token punctuation">,</span> tmp_iov<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>iov_base<span class="token punctuation">,</span> tmp_iov<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>iov_len<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> start <span class="token operator">+</span> num_reqs<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">qemu_iovec_concat</span><span class="token punctuation">(</span>qiov<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mrb<span class="token operator">-&gt;</span>reqs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span>qiov<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>
                              mrb<span class="token operator">-&gt;</span>reqs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span>qiov<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
            mrb<span class="token operator">-&gt;</span>reqs<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-&gt;</span>mr_next <span class="token operator">=</span> mrb<span class="token operator">-&gt;</span>reqs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token function">block_acct_merge_done</span><span class="token punctuation">(</span><span class="token function">blk_get_stats</span><span class="token punctuation">(</span>blk<span class="token punctuation">)</span><span class="token punctuation">,</span>
                              is_write <span class="token operator">?</span> BLOCK_ACCT_WRITE <span class="token operator">:</span> BLOCK_ACCT_READ<span class="token punctuation">,</span>
                              num_reqs <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>is_write<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">blk_aio_pwritev</span><span class="token punctuation">(</span>blk<span class="token punctuation">,</span> sector_num <span class="token operator">&lt;&lt;</span> BDRV_SECTOR_BITS<span class="token punctuation">,</span> qiov<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>
                        virtio_blk_rw_complete<span class="token punctuation">,</span> mrb<span class="token operator">-&gt;</span>reqs<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">blk_aio_preadv</span><span class="token punctuation">(</span>blk<span class="token punctuation">,</span> sector_num <span class="token operator">&lt;&lt;</span> BDRV_SECTOR_BITS<span class="token punctuation">,</span> qiov<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>
                       virtio_blk_rw_complete<span class="token punctuation">,</span> mrb<span class="token operator">-&gt;</span>reqs<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在submit_requests中，我们看到了BlockBackend。这是在qemu启动的时候，打开qcow2文件的时候生成的，现在我们可以用它来写入文件了，调用的是blk_aio_pwritev。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">BlockAIOCB <span class="token operator">*</span><span class="token function">blk_aio_pwritev</span><span class="token punctuation">(</span>BlockBackend <span class="token operator">*</span>blk<span class="token punctuation">,</span> int64_t offset<span class="token punctuation">,</span>
                            QEMUIOVector <span class="token operator">*</span>qiov<span class="token punctuation">,</span> BdrvRequestFlags flags<span class="token punctuation">,</span>
                            BlockCompletionFunc <span class="token operator">*</span>cb<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>opaque<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">blk_aio_prwv</span><span class="token punctuation">(</span>blk<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> qiov<span class="token operator">-&gt;</span>size<span class="token punctuation">,</span> qiov<span class="token punctuation">,</span>
                        blk_aio_write_entry<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> cb<span class="token punctuation">,</span> opaque<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> BlockAIOCB <span class="token operator">*</span><span class="token function">blk_aio_prwv</span><span class="token punctuation">(</span>BlockBackend <span class="token operator">*</span>blk<span class="token punctuation">,</span> int64_t offset<span class="token punctuation">,</span> <span class="token keyword">int</span> bytes<span class="token punctuation">,</span>
                                <span class="token keyword">void</span> <span class="token operator">*</span>iobuf<span class="token punctuation">,</span> CoroutineEntry co_entry<span class="token punctuation">,</span>
                                BdrvRequestFlags flags<span class="token punctuation">,</span>
                                BlockCompletionFunc <span class="token operator">*</span>cb<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>opaque<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    BlkAioEmAIOCB <span class="token operator">*</span>acb<span class="token punctuation">;</span>
    Coroutine <span class="token operator">*</span>co<span class="token punctuation">;</span>
    acb <span class="token operator">=</span> <span class="token function">blk_aio_get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>blk_aio_em_aiocb_info<span class="token punctuation">,</span> blk<span class="token punctuation">,</span> cb<span class="token punctuation">,</span> opaque<span class="token punctuation">)</span><span class="token punctuation">;</span>
    acb<span class="token operator">-&gt;</span>rwco <span class="token operator">=</span> <span class="token punctuation">(</span>BlkRwCo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span>blk    <span class="token operator">=</span> blk<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>offset <span class="token operator">=</span> offset<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>iobuf  <span class="token operator">=</span> iobuf<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>flags  <span class="token operator">=</span> flags<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>ret    <span class="token operator">=</span> NOT_DONE<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    acb<span class="token operator">-&gt;</span>bytes <span class="token operator">=</span> bytes<span class="token punctuation">;</span>
    acb<span class="token operator">-&gt;</span>has_returned <span class="token operator">=</span> false<span class="token punctuation">;</span>

    co <span class="token operator">=</span> <span class="token function">qemu_coroutine_create</span><span class="token punctuation">(</span>co_entry<span class="token punctuation">,</span> acb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">bdrv_coroutine_enter</span><span class="token punctuation">(</span><span class="token function">blk_bs</span><span class="token punctuation">(</span>blk<span class="token punctuation">)</span><span class="token punctuation">,</span> co<span class="token punctuation">)</span><span class="token punctuation">;</span>

    acb<span class="token operator">-&gt;</span>has_returned <span class="token operator">=</span> true<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">&amp;</span>acb<span class="token operator">-&gt;</span>common<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在blk_aio_pwritev中，我们看到，又是创建了一个协程来进行写入。写入完毕之后调用virtio_blk_rw_complete-&gt;virtio_blk_req_complete。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">virtio_blk_req_complete</span><span class="token punctuation">(</span>VirtIOBlockReq <span class="token operator">*</span>req<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> status<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    VirtIOBlock <span class="token operator">*</span>s <span class="token operator">=</span> req<span class="token operator">-&gt;</span>dev<span class="token punctuation">;</span>
    VirtIODevice <span class="token operator">*</span>vdev <span class="token operator">=</span> <span class="token function">VIRTIO_DEVICE</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">trace_virtio_blk_req_complete</span><span class="token punctuation">(</span>vdev<span class="token punctuation">,</span> req<span class="token punctuation">,</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">stb_p</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>req<span class="token operator">-&gt;</span>in<span class="token operator">-&gt;</span>status<span class="token punctuation">,</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">virtqueue_push</span><span class="token punctuation">(</span>req<span class="token operator">-&gt;</span>vq<span class="token punctuation">,</span> <span class="token operator">&amp;</span>req<span class="token operator">-&gt;</span>elem<span class="token punctuation">,</span> req<span class="token operator">-&gt;</span>in_len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">virtio_notify</span><span class="token punctuation">(</span>vdev<span class="token punctuation">,</span> req<span class="token operator">-&gt;</span>vq<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在virtio_blk_req_complete中，我们先是调用virtqueue_push，更新vring中used变量，表示这部分已经写入完毕，空间可以回收利用了。但是，这部分的改变仅仅改变了qemu后端的vring，我们还需要通知客户机中virtio前端的vring的值，因而要调用virtio_notify。virtio_notify会调用virtio_irq发送一个中断。</p>
<p>还记得咱们前面注册过一个中断处理函数vp_interrupt吗？它就是干这个事情的。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> irqreturn_t <span class="token function">vp_interrupt</span><span class="token punctuation">(</span><span class="token keyword">int</span> irq<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>opaque<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">virtio_pci_device</span> <span class="token operator">*</span>vp_dev <span class="token operator">=</span> opaque<span class="token punctuation">;</span>
    u8 isr<span class="token punctuation">;</span>

    <span class="token comment">/* reading the ISR has the effect of also clearing it so it's very
     * important to save off the value. */</span>
    isr <span class="token operator">=</span> <span class="token function">ioread8</span><span class="token punctuation">(</span>vp_dev<span class="token operator">-&gt;</span>isr<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* Configuration change?  Tell driver if it wants to know. */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>isr <span class="token operator">&amp;</span> VIRTIO_PCI_ISR_CONFIG<span class="token punctuation">)</span>
        <span class="token function">vp_config_changed</span><span class="token punctuation">(</span>irq<span class="token punctuation">,</span> opaque<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token function">vp_vring_interrupt</span><span class="token punctuation">(</span>irq<span class="token punctuation">,</span> opaque<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>就像前面说的一样vp_interrupt这个中断处理函数，一是处理配置变化，二是处理I/O结束。第二种的调用链为：vp_interrupt-&gt;vp_vring_interrupt-&gt;vring_interrupt。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">irqreturn_t <span class="token function">vring_interrupt</span><span class="token punctuation">(</span><span class="token keyword">int</span> irq<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>_vq<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">vring_virtqueue</span> <span class="token operator">*</span>vq <span class="token operator">=</span> <span class="token function">to_vvq</span><span class="token punctuation">(</span>_vq<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>vq<span class="token operator">-&gt;</span>vq<span class="token punctuation">.</span>callback<span class="token punctuation">)</span>
        vq<span class="token operator">-&gt;</span>vq<span class="token punctuation">.</span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vq<span class="token operator">-&gt;</span>vq<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> IRQ_HANDLED<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在vring_interrupt中，我们会调用callback函数，这个也是在前面注册过的，是virtblk_done。</p>
<p>接下来的调用链为：virtblk_done-&gt;virtqueue_get_buf-&gt;virtqueue_get_buf_ctx。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">virtqueue_get_buf_ctx</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">virtqueue</span> <span class="token operator">*</span>_vq<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token operator">*</span>len<span class="token punctuation">,</span>
                <span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>ctx<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">vring_virtqueue</span> <span class="token operator">*</span>vq <span class="token operator">=</span> <span class="token function">to_vvq</span><span class="token punctuation">(</span>_vq<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ret<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    u16 last_used<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    last_used <span class="token operator">=</span> <span class="token punctuation">(</span>vq<span class="token operator">-&gt;</span>last_used_idx <span class="token operator">&amp;</span> <span class="token punctuation">(</span>vq<span class="token operator">-&gt;</span>vring<span class="token punctuation">.</span>num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    i <span class="token operator">=</span> <span class="token function">virtio32_to_cpu</span><span class="token punctuation">(</span>_vq<span class="token operator">-&gt;</span>vdev<span class="token punctuation">,</span> vq<span class="token operator">-&gt;</span>vring<span class="token punctuation">.</span>used<span class="token operator">-&gt;</span>ring<span class="token punctuation">[</span>last_used<span class="token punctuation">]</span><span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>len <span class="token operator">=</span> <span class="token function">virtio32_to_cpu</span><span class="token punctuation">(</span>_vq<span class="token operator">-&gt;</span>vdev<span class="token punctuation">,</span> vq<span class="token operator">-&gt;</span>vring<span class="token punctuation">.</span>used<span class="token operator">-&gt;</span>ring<span class="token punctuation">[</span>last_used<span class="token punctuation">]</span><span class="token punctuation">.</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* detach_buf clears data, so grab it now. */</span>
    ret <span class="token operator">=</span> vq<span class="token operator">-&gt;</span>desc_state<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">;</span>
    <span class="token function">detach_buf</span><span class="token punctuation">(</span>vq<span class="token punctuation">,</span> i<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vq<span class="token operator">-&gt;</span>last_used_idx<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在virtqueue_get_buf_ctx中，我们可以看到，virtio前端的vring中的last_used_idx加一，说明这块数据qemu后端已经消费完毕。我们可以通过detach_buf将其放入空闲队列中，留给以后的写入请求使用。</p>
<p>至此，整个存储虚拟化的写入流程才全部完成。</p>
<h4 id="48-4-总结"><a href="#48-4-总结" class="headerlink" title="48.4 总结"></a>48.4 总结</h4><p>下面我们来总结一下存储虚拟化的场景下，整个写入的过程。</p>
<ul>
<li>在虚拟机里面，应用层调用write系统调用写入文件。</li>
<li>write系统调用进入虚拟机里面的内核，经过VFS，通用块设备层，I/O调度层，到达块设备驱动。</li>
<li>虚拟机里面的块设备驱动是virtio_blk，它和通用的块设备驱动一样，有一个request queue，另外有一个函数make_request_fn会被设置为blk_mq_make_request，这个函数用于将请求放入队列。</li>
<li>虚拟机里面的块设备驱动是virtio_blk会注册一个中断处理函数vp_interrupt。当qemu写入完成之后，它会通知虚拟机里面的块设备驱动。</li>
<li>blk_mq_make_request最终调用virtqueue_add，将请求添加到传输队列virtqueue中，然后调用virtqueue_notify通知qemu。</li>
<li>在qemu中，本来虚拟机正处于KVM_RUN的状态，也即处于客户机状态。</li>
<li>qemu收到通知后，通过VM exit指令退出客户机状态，进入宿主机状态，根据退出原因，得知有I/O需要处理。</li>
<li>qemu调用virtio_blk_handle_output，最终调用virtio_blk_handle_vq。</li>
<li>virtio_blk_handle_vq里面有一个循环，在循环中，virtio_blk_get_request函数从传输队列中拿出请求，然后调用virtio_blk_handle_request处理请求。</li>
<li>virtio_blk_handle_request会调用blk_aio_pwritev，通过BlockBackend驱动写入qcow2文件。</li>
<li>写入完毕之后，virtio_blk_req_complete会调用virtio_notify通知虚拟机里面的驱动。数据写入完成，刚才注册的中断处理函数vp_interrupt会收到这个通知。</li>
</ul>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/存储虚拟化的场景下整个写入的过程.jpg" alt="存储虚拟化的场景下整个写入的过程"></p>
<h3 id="49-网络虚拟化"><a href="#49-网络虚拟化" class="headerlink" title="49. 网络虚拟化"></a>49. 网络虚拟化</h3><p>上一节，我们讲了存储虚拟化，这一节我们来讲网络虚拟化。</p>
<p>网络虚拟化有和存储虚拟化类似的地方，例如，它们都是基于virtio的，因而我们在看网络虚拟化的过程中，会看到和存储虚拟化很像的数据结构和原理。但是，网络虚拟化也有自己的特殊性。例如，存储虚拟化是将宿主机上的文件作为客户机上的硬盘，而网络虚拟化需要依赖于内核协议栈进行网络包的封装与解封装。那怎么实现客户机和宿主机之间的互通呢？我们就一起来看一看。</p>
<h4 id="49-1-解析初始化过程"><a href="#49-1-解析初始化过程" class="headerlink" title="49.1 解析初始化过程"></a>49.1 解析初始化过程</h4><p>我们还是从Virtio Network Device这个设备的初始化讲起。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">const</span> TypeInfo device_type_info <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>name <span class="token operator">=</span> TYPE_DEVICE<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>parent <span class="token operator">=</span> TYPE_OBJECT<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>instance_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>DeviceState<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>instance_init <span class="token operator">=</span> device_initfn<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>instance_post_init <span class="token operator">=</span> device_post_init<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>instance_finalize <span class="token operator">=</span> device_finalize<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>class_base_init <span class="token operator">=</span> device_class_base_init<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>class_init <span class="token operator">=</span> device_class_init<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>abstract <span class="token operator">=</span> true<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>class_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>DeviceClass<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">const</span> TypeInfo virtio_device_info <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>name <span class="token operator">=</span> TYPE_VIRTIO_DEVICE<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>parent <span class="token operator">=</span> TYPE_DEVICE<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>instance_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>VirtIODevice<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>class_init <span class="token operator">=</span> virtio_device_class_init<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>instance_finalize <span class="token operator">=</span> virtio_device_instance_finalize<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>abstract <span class="token operator">=</span> true<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>class_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>VirtioDeviceClass<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">const</span> TypeInfo virtio_net_info <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>name <span class="token operator">=</span> TYPE_VIRTIO_NET<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>parent <span class="token operator">=</span> TYPE_VIRTIO_DEVICE<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>instance_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>VirtIONet<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>instance_init <span class="token operator">=</span> virtio_net_instance_init<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>class_init <span class="token operator">=</span> virtio_net_class_init<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">virtio_register_types</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">type_register_static</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>virtio_net_info<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">type_init</span><span class="token punctuation">(</span>virtio_register_types<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Virtio Network Device这种类的定义是有多层继承关系的，TYPE_VIRTIO_NET的父类是TYPE_VIRTIO_DEVICE，TYPE_VIRTIO_DEVICE的父类是TYPE_DEVICE，TYPE_DEVICE的父类是TYPE_OBJECT，继承关系到头了。</p>
<p>type_init用于注册这种类。这里面每一层都有class_init，用于从TypeImpl生产xxxClass，也有instance_init，会将xxxClass初始化为实例。</p>
<p>TYPE_VIRTIO_NET层的class_init函数virtio_net_class_init，定义了DeviceClass的realize函数为virtio_net_device_realize，这一点和存储块设备是一样的。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">virtio_net_device_realize</span><span class="token punctuation">(</span>DeviceState <span class="token operator">*</span>dev<span class="token punctuation">,</span> Error <span class="token operator">*</span><span class="token operator">*</span>errp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    VirtIODevice <span class="token operator">*</span>vdev <span class="token operator">=</span> <span class="token function">VIRTIO_DEVICE</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    VirtIONet <span class="token operator">*</span>n <span class="token operator">=</span> <span class="token function">VIRTIO_NET</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    NetClientState <span class="token operator">*</span>nc<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">virtio_init</span><span class="token punctuation">(</span>vdev<span class="token punctuation">,</span> <span class="token string">"virtio-net"</span><span class="token punctuation">,</span> VIRTIO_ID_NET<span class="token punctuation">,</span> n<span class="token operator">-&gt;</span>config_size<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*
     * We set a lower limit on RX queue size to what it always was.
     * Guests that want a smaller ring can always resize it without
     * help from us (using virtio 1 and up).
     */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">-&gt;</span>net_conf<span class="token punctuation">.</span>rx_queue_size <span class="token operator">&lt;</span> VIRTIO_NET_RX_QUEUE_MIN_SIZE <span class="token operator">||</span>
        n<span class="token operator">-&gt;</span>net_conf<span class="token punctuation">.</span>rx_queue_size <span class="token operator">&gt;</span> VIRTQUEUE_MAX_SIZE <span class="token operator">||</span>
        <span class="token operator">!</span><span class="token function">is_power_of_2</span><span class="token punctuation">(</span>n<span class="token operator">-&gt;</span>net_conf<span class="token punctuation">.</span>rx_queue_size<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">-&gt;</span>net_conf<span class="token punctuation">.</span>tx_queue_size <span class="token operator">&lt;</span> VIRTIO_NET_TX_QUEUE_MIN_SIZE <span class="token operator">||</span>
        n<span class="token operator">-&gt;</span>net_conf<span class="token punctuation">.</span>tx_queue_size <span class="token operator">&gt;</span> VIRTQUEUE_MAX_SIZE <span class="token operator">||</span>
        <span class="token operator">!</span><span class="token function">is_power_of_2</span><span class="token punctuation">(</span>n<span class="token operator">-&gt;</span>net_conf<span class="token punctuation">.</span>tx_queue_size<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    n<span class="token operator">-&gt;</span>max_queues <span class="token operator">=</span> <span class="token function">MAX</span><span class="token punctuation">(</span>n<span class="token operator">-&gt;</span>nic_conf<span class="token punctuation">.</span>peers<span class="token punctuation">.</span>queues<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">-&gt;</span>max_queues <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&gt;</span> VIRTIO_QUEUE_MAX<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    n<span class="token operator">-&gt;</span>vqs <span class="token operator">=</span> <span class="token function">g_malloc0</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>VirtIONetQueue<span class="token punctuation">)</span> <span class="token operator">*</span> n<span class="token operator">-&gt;</span>max_queues<span class="token punctuation">)</span><span class="token punctuation">;</span>
    n<span class="token operator">-&gt;</span>curr_queues <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    n<span class="token operator">-&gt;</span>net_conf<span class="token punctuation">.</span>tx_queue_size <span class="token operator">=</span> <span class="token function">MIN</span><span class="token punctuation">(</span><span class="token function">virtio_net_max_tx_queue_size</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span>
                                    n<span class="token operator">-&gt;</span>net_conf<span class="token punctuation">.</span>tx_queue_size<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token operator">-&gt;</span>max_queues<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">virtio_net_add_queue</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    n<span class="token operator">-&gt;</span>ctrl_vq <span class="token operator">=</span> <span class="token function">virtio_add_queue</span><span class="token punctuation">(</span>vdev<span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> virtio_net_handle_ctrl<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">qemu_macaddr_default_if_unset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token operator">-&gt;</span>nic_conf<span class="token punctuation">.</span>macaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token operator">-&gt;</span>mac<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token operator">-&gt;</span>nic_conf<span class="token punctuation">.</span>macaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>n<span class="token operator">-&gt;</span>mac<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    n<span class="token operator">-&gt;</span>status <span class="token operator">=</span> VIRTIO_NET_S_LINK_UP<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">-&gt;</span>netclient_type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        n<span class="token operator">-&gt;</span>nic <span class="token operator">=</span> <span class="token function">qemu_new_nic</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>net_virtio_info<span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token operator">-&gt;</span>nic_conf<span class="token punctuation">,</span>
                              n<span class="token operator">-&gt;</span>netclient_type<span class="token punctuation">,</span> n<span class="token operator">-&gt;</span>netclient_name<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        n<span class="token operator">-&gt;</span>nic <span class="token operator">=</span> <span class="token function">qemu_new_nic</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>net_virtio_info<span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token operator">-&gt;</span>nic_conf<span class="token punctuation">,</span>
                              <span class="token function">object_get_typename</span><span class="token punctuation">(</span><span class="token function">OBJECT</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dev<span class="token operator">-&gt;</span>id<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面创建了一个VirtIODevice，这一点和存储虚拟化也是一样的。virtio_init用来初始化这个设备。VirtIODevice结构里面有一个VirtQueue数组，这就是virtio前端和后端互相传数据的队列，最多有VIRTIO_QUEUE_MAX个。</p>
<p>刚才我们说的都是一样的地方，其实也有不一样的地方，我们下面来看。</p>
<p>你会发现，这里面有这样的语句n-&gt;max_queues * 2 + 1 &gt; VIRTIO_QUEUE_MAX。为什么要乘以2呢？这是因为，对于网络设备来讲，应该分发送队列和接收队列两个方向，所以乘以2。</p>
<p>接下来，我们调用virtio_net_add_queue来初始化队列，可以看出来，这里面就有发送tx_vq和接收rx_vq两个队列。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">VirtIONetQueue</span> <span class="token punctuation">{</span>
    VirtQueue <span class="token operator">*</span>rx_vq<span class="token punctuation">;</span>
    VirtQueue <span class="token operator">*</span>tx_vq<span class="token punctuation">;</span>
    QEMUTimer <span class="token operator">*</span>tx_timer<span class="token punctuation">;</span>
    QEMUBH <span class="token operator">*</span>tx_bh<span class="token punctuation">;</span>
    uint32_t tx_waiting<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token punctuation">{</span>
        VirtQueueElement <span class="token operator">*</span>elem<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> async_tx<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">VirtIONet</span> <span class="token operator">*</span>n<span class="token punctuation">;</span>
<span class="token punctuation">}</span> VirtIONetQueue<span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">virtio_net_add_queue</span><span class="token punctuation">(</span>VirtIONet <span class="token operator">*</span>n<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    VirtIODevice <span class="token operator">*</span>vdev <span class="token operator">=</span> <span class="token function">VIRTIO_DEVICE</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>

    n<span class="token operator">-&gt;</span>vqs<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>rx_vq <span class="token operator">=</span> <span class="token function">virtio_add_queue</span><span class="token punctuation">(</span>vdev<span class="token punctuation">,</span> n<span class="token operator">-&gt;</span>net_conf<span class="token punctuation">.</span>rx_queue_size<span class="token punctuation">,</span> virtio_net_handle_rx<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    n<span class="token operator">-&gt;</span>vqs<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>tx_vq <span class="token operator">=</span> <span class="token function">virtio_add_queue</span><span class="token punctuation">(</span>vdev<span class="token punctuation">,</span> n<span class="token operator">-&gt;</span>net_conf<span class="token punctuation">.</span>tx_queue_size<span class="token punctuation">,</span> virtio_net_handle_tx_bh<span class="token punctuation">)</span><span class="token punctuation">;</span>
    n<span class="token operator">-&gt;</span>vqs<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>tx_bh <span class="token operator">=</span> <span class="token function">qemu_bh_new</span><span class="token punctuation">(</span>virtio_net_tx_bh<span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token operator">-&gt;</span>vqs<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    n<span class="token operator">-&gt;</span>vqs<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>n <span class="token operator">=</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>每个VirtQueue中，都有一个vring用来维护这个队列里面的数据；另外还有函数virtio_net_handle_rx用于处理网络包的接收；函数virtio_net_handle_tx_bh用于网络包的发送，这个函数我们后面会用到。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">NICState <span class="token operator">*</span><span class="token function">qemu_new_nic</span><span class="token punctuation">(</span>NetClientInfo <span class="token operator">*</span>info<span class="token punctuation">,</span>
                       NICConf <span class="token operator">*</span>conf<span class="token punctuation">,</span>
                       <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>model<span class="token punctuation">,</span>
                       <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span>
                       <span class="token keyword">void</span> <span class="token operator">*</span>opaque<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    NetClientState <span class="token operator">*</span><span class="token operator">*</span>peers <span class="token operator">=</span> conf<span class="token operator">-&gt;</span>peers<span class="token punctuation">.</span>ncs<span class="token punctuation">;</span>
    NICState <span class="token operator">*</span>nic<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> queues <span class="token operator">=</span> <span class="token function">MAX</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> conf<span class="token operator">-&gt;</span>peers<span class="token punctuation">.</span>queues<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    nic <span class="token operator">=</span> <span class="token function">g_malloc0</span><span class="token punctuation">(</span>info<span class="token operator">-&gt;</span>size <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>NetClientState<span class="token punctuation">)</span> <span class="token operator">*</span> queues<span class="token punctuation">)</span><span class="token punctuation">;</span>
    nic<span class="token operator">-&gt;</span>ncs <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>nic <span class="token operator">+</span> info<span class="token operator">-&gt;</span>size<span class="token punctuation">;</span>
    nic<span class="token operator">-&gt;</span>conf <span class="token operator">=</span> conf<span class="token punctuation">;</span>
    nic<span class="token operator">-&gt;</span>opaque <span class="token operator">=</span> opaque<span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> queues<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">qemu_net_client_setup</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>nic<span class="token operator">-&gt;</span>ncs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> info<span class="token punctuation">,</span> peers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> model<span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        nic<span class="token operator">-&gt;</span>ncs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>queue_index <span class="token operator">=</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> nic<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">qemu_net_client_setup</span><span class="token punctuation">(</span>NetClientState <span class="token operator">*</span>nc<span class="token punctuation">,</span>
                                  NetClientInfo <span class="token operator">*</span>info<span class="token punctuation">,</span>
                                  NetClientState <span class="token operator">*</span>peer<span class="token punctuation">,</span>
                                  <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>model<span class="token punctuation">,</span>
                                  <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span>
                                  NetClientDestructor <span class="token operator">*</span>destructor<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    nc<span class="token operator">-&gt;</span>info <span class="token operator">=</span> info<span class="token punctuation">;</span>
    nc<span class="token operator">-&gt;</span>model <span class="token operator">=</span> <span class="token function">g_strdup</span><span class="token punctuation">(</span>model<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        nc<span class="token operator">-&gt;</span>name <span class="token operator">=</span> <span class="token function">g_strdup</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        nc<span class="token operator">-&gt;</span>name <span class="token operator">=</span> <span class="token function">assign_name</span><span class="token punctuation">(</span>nc<span class="token punctuation">,</span> model<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">QTAILQ_INSERT_TAIL</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>net_clients<span class="token punctuation">,</span> nc<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>

    nc<span class="token operator">-&gt;</span>incoming_queue <span class="token operator">=</span> <span class="token function">qemu_new_net_queue</span><span class="token punctuation">(</span>qemu_deliver_packet_iov<span class="token punctuation">,</span> nc<span class="token punctuation">)</span><span class="token punctuation">;</span>
    nc<span class="token operator">-&gt;</span>destructor <span class="token operator">=</span> destructor<span class="token punctuation">;</span>
    <span class="token function">QTAILQ_INIT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>nc<span class="token operator">-&gt;</span>filters<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来，qemu_new_nic会创建一个虚拟机里面的网卡。</p>
<h4 id="49-2-qemu的启动过程中的网络虚拟化"><a href="#49-2-qemu的启动过程中的网络虚拟化" class="headerlink" title="49.2 qemu的启动过程中的网络虚拟化"></a>49.2 qemu的启动过程中的网络虚拟化</h4><p>初始化过程解析完毕以后，我们接下来从qemu的启动过程看起。</p>
<p>对于网卡的虚拟化，qemu的启动参数里面有关的是下面两行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-netdev tap,fd<span class="token operator">=</span><span class="token number">32</span>,id<span class="token operator">=</span>hostnet0,vhost<span class="token operator">=</span>on,vhostfd<span class="token operator">=</span><span class="token number">37</span>
-device virtio-net-pci,netdev<span class="token operator">=</span>hostnet0,id<span class="token operator">=</span>net0,mac<span class="token operator">=</span>fa:16:3e:d1:2d:99,bus<span class="token operator">=</span>pci.0,addr<span class="token operator">=</span>0x3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>qemu的main函数会调用net_init_clients进行网络设备的初始化，可以解析net参数，也可以在net_init_clients中解析netdev参数。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">net_init_clients</span><span class="token punctuation">(</span>Error <span class="token operator">*</span><span class="token operator">*</span>errp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">QTAILQ_INIT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>net_clients<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">qemu_opts_foreach</span><span class="token punctuation">(</span><span class="token function">qemu_find_opts</span><span class="token punctuation">(</span><span class="token string">"netdev"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                          net_init_netdev<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> errp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">qemu_opts_foreach</span><span class="token punctuation">(</span><span class="token function">qemu_find_opts</span><span class="token punctuation">(</span><span class="token string">"nic"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> net_param_nic<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> errp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">qemu_opts_foreach</span><span class="token punctuation">(</span><span class="token function">qemu_find_opts</span><span class="token punctuation">(</span><span class="token string">"net"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> net_init_client<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> errp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>net_init_clients会解析参数。上面的参数netdev会调用net_init_netdev-&gt;net_client_init-&gt;net_client_init1。</p>
<p>net_client_init1会根据不同的driver类型，调用不同的初始化函数。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token keyword">const</span> net_client_init_fun<span class="token punctuation">[</span>NET_CLIENT_DRIVER__MAX<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span>
    <span class="token keyword">const</span> Netdev <span class="token operator">*</span>netdev<span class="token punctuation">,</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span>
    NetClientState <span class="token operator">*</span>peer<span class="token punctuation">,</span> Error <span class="token operator">*</span><span class="token operator">*</span>errp<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token punctuation">[</span>NET_CLIENT_DRIVER_NIC<span class="token punctuation">]</span>       <span class="token operator">=</span> net_init_nic<span class="token punctuation">,</span>
        <span class="token punctuation">[</span>NET_CLIENT_DRIVER_TAP<span class="token punctuation">]</span>       <span class="token operator">=</span> net_init_tap<span class="token punctuation">,</span>
        <span class="token punctuation">[</span>NET_CLIENT_DRIVER_SOCKET<span class="token punctuation">]</span>    <span class="token operator">=</span> net_init_socket<span class="token punctuation">,</span>
        <span class="token punctuation">[</span>NET_CLIENT_DRIVER_HUBPORT<span class="token punctuation">]</span>   <span class="token operator">=</span> net_init_hubport<span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于我们配置的driver的类型是tap，因而这里会调用net_init_tap-&gt;net_tap_init-&gt;tap_open。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">PATH_NET_TUN </span><span class="token string">"/dev/net/tun"</span></span>

<span class="token keyword">int</span> <span class="token function">tap_open</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>ifname<span class="token punctuation">,</span> <span class="token keyword">int</span> ifname_size<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>vnet_hdr<span class="token punctuation">,</span>
             <span class="token keyword">int</span> vnet_hdr_required<span class="token punctuation">,</span> <span class="token keyword">int</span> mq_required<span class="token punctuation">,</span> Error <span class="token operator">*</span><span class="token operator">*</span>errp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">ifreq</span> ifr<span class="token punctuation">;</span>
    <span class="token keyword">int</span> fd<span class="token punctuation">,</span> ret<span class="token punctuation">;</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">virtio_net_hdr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> features<span class="token punctuation">;</span>

    <span class="token function">TFR</span><span class="token punctuation">(</span>fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>PATH_NET_TUN<span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ifr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ifr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ifr<span class="token punctuation">.</span>ifr_flags <span class="token operator">=</span> IFF_TAP <span class="token operator">|</span> IFF_NO_PI<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ioctl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> TUNGETFEATURES<span class="token punctuation">,</span> <span class="token operator">&amp;</span>features<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        features <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>features <span class="token operator">&amp;</span> IFF_ONE_QUEUE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ifr<span class="token punctuation">.</span>ifr_flags <span class="token operator">|=</span> IFF_ONE_QUEUE<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>vnet_hdr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>features <span class="token operator">&amp;</span> IFF_VNET_HDR<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token operator">*</span>vnet_hdr <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            ifr<span class="token punctuation">.</span>ifr_flags <span class="token operator">|=</span> IFF_VNET_HDR<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token operator">*</span>vnet_hdr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">ioctl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> TUNSETVNETHDRSZ<span class="token punctuation">,</span> <span class="token operator">&amp;</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    ret <span class="token operator">=</span> <span class="token function">ioctl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> TUNSETIFF<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>ifr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> F_SETFL<span class="token punctuation">,</span> O_NONBLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> fd<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在tap_open中，我们打开一个文件”/dev/net/tun”，然后通过ioctl操作这个文件。这是Linux内核的一项机制，和KVM机制很像。其实这就是一种通过打开这个字符设备文件，然后通过ioctl操作这个文件和内核打交道，来使用内核的能力。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/网络虚拟化过程.png" alt="网络虚拟化过程"></p>
<p>为什么需要使用内核的机制呢？因为网络包需要从虚拟机里面发送到虚拟机外面，发送到宿主机上的时候，必须是一个正常的网络包才能被转发。要形成一个网络包，我们那就需要经过复杂的协议栈，协议栈的复杂咱们在<strong>发送网络包</strong>那一节讲过了。</p>
<p>客户机会将网络包发送给qemu。qemu自己没有网络协议栈，现去实现一个也不可能，太复杂了。于是，它就要借助内核的力量。</p>
<p>qemu会将客户机发送给它的网络包，然后转换成为文件流，写入”/dev/net/tun”字符设备。就像写一个文件一样。内核中TUN/TAP字符设备驱动会收到这个写入的文件流，然后交给TUN/TAP的虚拟网卡驱动。这个驱动会将文件流再次转成网络包，交给TCP/IP栈，最终从虚拟TAP网卡tap0发出来，成为标准的网络包。后面我们会看到这个过程。</p>
<p>现在我们到内核里面，看一看打开”/dev/net/tun”字符设备后，内核会发生什么事情。内核的实现在drivers/net/tun.c文件中。这是一个字符设备驱动程序，应该符合字符设备的格式。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">module_init</span><span class="token punctuation">(</span>tun_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>tun_cleanup<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_DESCRIPTION</span><span class="token punctuation">(</span>DRV_DESCRIPTION<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span>DRV_COPYRIGHT<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_ALIAS_MISCDEV</span><span class="token punctuation">(</span>TUN_MINOR<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_ALIAS</span><span class="token punctuation">(</span><span class="token string">"devname:net/tun"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">tun_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    ret <span class="token operator">=</span> <span class="token function">rtnl_link_register</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tun_link_ops<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    ret <span class="token operator">=</span> <span class="token function">misc_register</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tun_miscdev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    ret <span class="token operator">=</span> <span class="token function">register_netdevice_notifier</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tun_notifier_block<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面注册了一个tun_miscdev字符设备，从它的定义可以看出，这就是”/dev/net/tun”字符设备。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">miscdevice</span> tun_miscdev <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>minor <span class="token operator">=</span> TUN_MINOR<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"tun"</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>nodename <span class="token operator">=</span> <span class="token string">"net/tun"</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>fops <span class="token operator">=</span> <span class="token operator">&amp;</span>tun_fops<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> tun_fops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>owner  <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>llseek <span class="token operator">=</span> no_llseek<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>read_iter  <span class="token operator">=</span> tun_chr_read_iter<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>write_iter <span class="token operator">=</span> tun_chr_write_iter<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>poll   <span class="token operator">=</span> tun_chr_poll<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>unlocked_ioctl <span class="token operator">=</span> tun_chr_ioctl<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>open   <span class="token operator">=</span> tun_chr_open<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>release <span class="token operator">=</span> tun_chr_close<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>fasync <span class="token operator">=</span> tun_chr_fasync<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>qemu的tap_open函数会打开这个字符设备PATH_NET_TUN。打开字符设备的过程我们不再重复。我就说一下，到了驱动这一层，调用的是tun_chr_open。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">tun_chr_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span> file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">tun_file</span> <span class="token operator">*</span>tfile<span class="token punctuation">;</span>
    tfile <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">tun_file</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">sk_alloc</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> AF_UNSPEC<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">,</span>
                        <span class="token operator">&amp;</span>tun_proto<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">RCU_INIT_POINTER</span><span class="token punctuation">(</span>tfile<span class="token operator">-&gt;</span>tun<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    tfile<span class="token operator">-&gt;</span>flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    tfile<span class="token operator">-&gt;</span>ifindex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token function">init_waitqueue_head</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tfile<span class="token operator">-&gt;</span>wq<span class="token punctuation">.</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">RCU_INIT_POINTER</span><span class="token punctuation">(</span>tfile<span class="token operator">-&gt;</span>socket<span class="token punctuation">.</span>wq<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tfile<span class="token operator">-&gt;</span>wq<span class="token punctuation">)</span><span class="token punctuation">;</span>

    tfile<span class="token operator">-&gt;</span>socket<span class="token punctuation">.</span>file <span class="token operator">=</span> file<span class="token punctuation">;</span>
    tfile<span class="token operator">-&gt;</span>socket<span class="token punctuation">.</span>ops <span class="token operator">=</span> <span class="token operator">&amp;</span>tun_socket_ops<span class="token punctuation">;</span>

    <span class="token function">sock_init_data</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tfile<span class="token operator">-&gt;</span>socket<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tfile<span class="token operator">-&gt;</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>

    tfile<span class="token operator">-&gt;</span>sk<span class="token punctuation">.</span>sk_write_space <span class="token operator">=</span> tun_sock_write_space<span class="token punctuation">;</span>
    tfile<span class="token operator">-&gt;</span>sk<span class="token punctuation">.</span>sk_sndbuf <span class="token operator">=</span> INT_MAX<span class="token punctuation">;</span>

    file<span class="token operator">-&gt;</span>private_data <span class="token operator">=</span> tfile<span class="token punctuation">;</span>
    <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tfile<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">sock_set_flag</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tfile<span class="token operator">-&gt;</span>sk<span class="token punctuation">,</span> SOCK_ZEROCOPY<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在tun_chr_open的参数里面，有一个struct file，这是代表什么文件呢？它代表的就是打开的字符设备文件”/dev/net/tun”，因而往这个字符设备文件中写数据，就会通过这个struct file写入。这个struct file里面的file_operations，按照字符设备打开的规则，指向的就是tun_fops。</p>
<p>另外，我们还需要在tun_chr_open创建了一个结构struct tun_file，并且将struct file的private_data指向它。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* A tun_file connects an open character device to a tuntap netdevice. It
 * also contains all socket related structures
 * to serve as one transmit queue for tuntap device.
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">tun_file</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">sock</span> sk<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">socket</span> socket<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">socket_wq</span> wq<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">tun_struct</span> __rcu <span class="token operator">*</span>tun<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">fasync_struct</span> <span class="token operator">*</span>fasync<span class="token punctuation">;</span>
    <span class="token comment">/* only used for fasnyc */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> flags<span class="token punctuation">;</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        u16 queue_index<span class="token punctuation">;</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> ifindex<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> next<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">tun_struct</span> <span class="token operator">*</span>detached<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">skb_array</span> tx_array<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">tun_struct</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">tun_file</span> __rcu   <span class="token operator">*</span>tfiles<span class="token punctuation">[</span>MAX_TAP_QUEUES<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>            numqueues<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        flags<span class="token punctuation">;</span>
    kuid_t          owner<span class="token punctuation">;</span>
    kgid_t          group<span class="token punctuation">;</span>

    <span class="token keyword">struct</span> <span class="token class-name">net_device</span>   <span class="token operator">*</span>dev<span class="token punctuation">;</span>
    netdev_features_t   set_features<span class="token punctuation">;</span>
    <span class="token keyword">int</span>         align<span class="token punctuation">;</span>
    <span class="token keyword">int</span>         vnet_hdr_sz<span class="token punctuation">;</span>
    <span class="token keyword">int</span>         sndbuf<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">tap_filter</span>   txflt<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sock_fprog</span>   fprog<span class="token punctuation">;</span>
    <span class="token comment">/* protected by rtnl lock */</span>
    bool            filter_attached<span class="token punctuation">;</span>
    spinlock_t lock<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">hlist_head</span> flows<span class="token punctuation">[</span>TUN_NUM_FLOW_ENTRIES<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">timer_list</span> flow_gc_timer<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ageing_time<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> numdisabled<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> disabled<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>security<span class="token punctuation">;</span>
    u32 flow_count<span class="token punctuation">;</span>
    u32 rx_batched<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">tun_pcpu_stats</span> __percpu <span class="token operator">*</span>pcpu_stats<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">proto_ops</span> tun_socket_ops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>peek_len <span class="token operator">=</span> tun_peek_len<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>sendmsg <span class="token operator">=</span> tun_sendmsg<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>recvmsg <span class="token operator">=</span> tun_recvmsg<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在struct tun_file中，有一个成员struct tun_struct，它里面有一个struct net_device，这个用来表示宿主机上的tuntap网络设备。在struct tun_file中，还有struct socket和struct sock，因为要用到内核的<strong>Socket通信之网络协议基本原理</strong>栈，所以就需要这两个结构，这在网络协议那一节已经分析过了。</p>
<p>所以，按照struct tun_file的注释说的，这是一个很重要的数据结构。”/dev/net/tun”对应的struct file的private_data指向它，因而可以接收qemu发过来的数据。除此之外，它还可以通过struct sock来操作内核协议栈，然后将网络包从宿主机上的tuntap网络设备发出去，宿主机上的tuntap网络设备对应的struct net_device也归它管。</p>
<p>在qemu的tap_open函数中，打开这个字符设备文件之后，接下来要做的事情是，通过ioctl来设置宿主机的网卡TUNSETIFF。</p>
<p>接下来，ioctl到了内核里面，会调用tun_chr_ioctl。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">__tun_chr_ioctl</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span>
                <span class="token keyword">unsigned</span> <span class="token keyword">long</span> arg<span class="token punctuation">,</span> <span class="token keyword">int</span> ifreq_len<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">tun_file</span> <span class="token operator">*</span>tfile <span class="token operator">=</span> file<span class="token operator">-&gt;</span>private_data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">tun_struct</span> <span class="token operator">*</span>tun<span class="token punctuation">;</span>
    <span class="token keyword">void</span> __user<span class="token operator">*</span> argp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> __user<span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">ifreq</span> ifr<span class="token punctuation">;</span>
    kuid_t owner<span class="token punctuation">;</span>
    kgid_t group<span class="token punctuation">;</span>
    <span class="token keyword">int</span> sndbuf<span class="token punctuation">;</span>
    <span class="token keyword">int</span> vnet_hdr_sz<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> ifindex<span class="token punctuation">;</span>
    <span class="token keyword">int</span> le<span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>cmd <span class="token operator">==</span> TUNSETIFF <span class="token operator">||</span> cmd <span class="token operator">==</span> TUNSETQUEUE <span class="token operator">||</span> <span class="token function">_IOC_TYPE</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span> <span class="token operator">==</span> SOCK_IOC_TYPE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_from_user</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ifr<span class="token punctuation">,</span> argp<span class="token punctuation">,</span> ifreq_len<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token operator">-</span>EFAULT<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    tun <span class="token operator">=</span> <span class="token function">__tun_get</span><span class="token punctuation">(</span>tfile<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cmd <span class="token operator">==</span> TUNSETIFF<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ifr<span class="token punctuation">.</span>ifr_name<span class="token punctuation">[</span>IFNAMSIZ<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>
        ret <span class="token operator">=</span> <span class="token function">tun_set_iff</span><span class="token punctuation">(</span><span class="token function">sock_net</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tfile<span class="token operator">-&gt;</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> file<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ifr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_to_user</span><span class="token punctuation">(</span>argp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ifr<span class="token punctuation">,</span> ifreq_len<span class="token punctuation">)</span><span class="token punctuation">)</span>
            ret <span class="token operator">=</span> <span class="token operator">-</span>EFAULT<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在__tun_chr_ioctl中，我们首先通过copy_from_user把配置从用户态拷贝到内核态，调用tun_set_iff设置tuntap网络设备，然后调用copy_to_user将配置结果返回。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">tun_set_iff</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">net</span> <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">ifreq</span> <span class="token operator">*</span>ifr<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">tun_struct</span> <span class="token operator">*</span>tun<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">tun_file</span> <span class="token operator">*</span>tfile <span class="token operator">=</span> file<span class="token operator">-&gt;</span>private_data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> queues <span class="token operator">=</span> ifr<span class="token operator">-&gt;</span>ifr_flags <span class="token operator">&amp;</span> IFF_MULTI_QUEUE <span class="token operator">?</span>
                 MAX_TAP_QUEUES <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>ifr<span class="token operator">-&gt;</span>ifr_flags <span class="token operator">&amp;</span> IFF_TUN<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* TUN device */</span>
        flags <span class="token operator">|=</span> IFF_TUN<span class="token punctuation">;</span>
        name <span class="token operator">=</span> <span class="token string">"tun%d"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ifr<span class="token operator">-&gt;</span>ifr_flags <span class="token operator">&amp;</span> IFF_TAP<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* TAP device */</span>
        flags <span class="token operator">|=</span> IFF_TAP<span class="token punctuation">;</span>
        name <span class="token operator">=</span> <span class="token string">"tap%d"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>ifr<span class="token operator">-&gt;</span>ifr_name<span class="token punctuation">)</span>
        name <span class="token operator">=</span> ifr<span class="token operator">-&gt;</span>ifr_name<span class="token punctuation">;</span>

    dev <span class="token operator">=</span> <span class="token function">alloc_netdev_mqs</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">tun_struct</span><span class="token punctuation">)</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span>
                       NET_NAME_UNKNOWN<span class="token punctuation">,</span> tun_setup<span class="token punctuation">,</span> queues<span class="token punctuation">,</span>
                       queues<span class="token punctuation">)</span><span class="token punctuation">;</span>

    err <span class="token operator">=</span> <span class="token function">dev_get_valid_name</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> dev<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">dev_net_set</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> net<span class="token punctuation">)</span><span class="token punctuation">;</span>
    dev<span class="token operator">-&gt;</span>rtnl_link_ops <span class="token operator">=</span> <span class="token operator">&amp;</span>tun_link_ops<span class="token punctuation">;</span>
    dev<span class="token operator">-&gt;</span>ifindex <span class="token operator">=</span> tfile<span class="token operator">-&gt;</span>ifindex<span class="token punctuation">;</span>
    dev<span class="token operator">-&gt;</span>sysfs_groups<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>tun_attr_group<span class="token punctuation">;</span>

    tun <span class="token operator">=</span> <span class="token function">netdev_priv</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    tun<span class="token operator">-&gt;</span>dev <span class="token operator">=</span> dev<span class="token punctuation">;</span>
    tun<span class="token operator">-&gt;</span>flags <span class="token operator">=</span> flags<span class="token punctuation">;</span>
    tun<span class="token operator">-&gt;</span>txflt<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    tun<span class="token operator">-&gt;</span>vnet_hdr_sz <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">virtio_net_hdr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    tun<span class="token operator">-&gt;</span>align <span class="token operator">=</span> NET_SKB_PAD<span class="token punctuation">;</span>
    tun<span class="token operator">-&gt;</span>filter_attached <span class="token operator">=</span> false<span class="token punctuation">;</span>
    tun<span class="token operator">-&gt;</span>sndbuf <span class="token operator">=</span> tfile<span class="token operator">-&gt;</span>socket<span class="token punctuation">.</span>sk<span class="token operator">-&gt;</span>sk_sndbuf<span class="token punctuation">;</span>
    tun<span class="token operator">-&gt;</span>rx_batched <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token function">tun_net_init</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">tun_flow_init</span><span class="token punctuation">(</span>tun<span class="token punctuation">)</span><span class="token punctuation">;</span>

    err <span class="token operator">=</span> <span class="token function">tun_attach</span><span class="token punctuation">(</span>tun<span class="token punctuation">,</span> file<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span>
    err <span class="token operator">=</span> <span class="token function">register_netdevice</span><span class="token punctuation">(</span>tun<span class="token operator">-&gt;</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">netif_carrier_on</span><span class="token punctuation">(</span>tun<span class="token operator">-&gt;</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">netif_running</span><span class="token punctuation">(</span>tun<span class="token operator">-&gt;</span>dev<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">netif_tx_wake_all_queues</span><span class="token punctuation">(</span>tun<span class="token operator">-&gt;</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">strcpy</span><span class="token punctuation">(</span>ifr<span class="token operator">-&gt;</span>ifr_name<span class="token punctuation">,</span> tun<span class="token operator">-&gt;</span>dev<span class="token operator">-&gt;</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>tun_set_iff创建了struct tun_struct和struct net_device，并且将这个tuntap网络设备通过register_netdevice注册到内核中。这样，我们就能在宿主机上通过ip addr看到这个网卡了。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/网络虚拟化函数过程.png" alt="网络虚拟化函数过程"></p>
<p>至此宿主机上的内核的数据结构也完成了。</p>
<h4 id="49-3-关联前端设备驱动和后端设备驱动"><a href="#49-3-关联前端设备驱动和后端设备驱动" class="headerlink" title="49.3 关联前端设备驱动和后端设备驱动"></a>49.3 关联前端设备驱动和后端设备驱动</h4><p>下面，我们来解析在客户机中发送一个网络包的时候，会发生哪些事情。</p>
<p>虚拟机里面的进程发送一个网络包，通过文件系统和Socket调用网络协议栈，到达网络设备层。只不过这个不是普通的网络设备，而是virtio_net的驱动。</p>
<p>virtio_net的驱动程序代码在Linux操作系统的源代码里面，文件名为drivers/net/virtio_net.c。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> __init <span class="token keyword">int</span> <span class="token function">virtio_net_driver_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    ret <span class="token operator">=</span> <span class="token function">register_virtio_driver</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>virtio_net_driver<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>virtio_net_driver_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>virtio_net_driver_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">MODULE_DEVICE_TABLE</span><span class="token punctuation">(</span>virtio<span class="token punctuation">,</span> id_table<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_DESCRIPTION</span><span class="token punctuation">(</span><span class="token string">"Virtio network driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">virtio_driver</span> virtio_net_driver <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>driver<span class="token punctuation">.</span>name <span class="token operator">=</span>  KBUILD_MODNAME<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>driver<span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>id_table <span class="token operator">=</span>     id_table<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>validate <span class="token operator">=</span>     virtnet_validate<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>probe <span class="token operator">=</span>        virtnet_probe<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>remove <span class="token operator">=</span>       virtnet_remove<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>config_changed <span class="token operator">=</span> virtnet_config_changed<span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在virtio_net的驱动程序的初始化代码中，我们需要注册一个驱动函数virtio_net_driver。</p>
<p>当一个设备驱动作为一个内核模块被初始化的时候，probe函数会被调用，因而我们来看一下virtnet_probe。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">virtnet_probe</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">virtio_device</span> <span class="token operator">*</span>vdev<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> err<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">virtnet_info</span> <span class="token operator">*</span>vi<span class="token punctuation">;</span>
    u16 max_queue_pairs<span class="token punctuation">;</span>
    <span class="token keyword">int</span> mtu<span class="token punctuation">;</span>

    <span class="token comment">/* Allocate ourselves a network device with room for our info */</span>
    dev <span class="token operator">=</span> <span class="token function">alloc_etherdev_mq</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">virtnet_info</span><span class="token punctuation">)</span><span class="token punctuation">,</span> max_queue_pairs<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* Set up network device as normal. */</span>
    dev<span class="token operator">-&gt;</span>priv_flags <span class="token operator">|=</span> IFF_UNICAST_FLT <span class="token operator">|</span> IFF_LIVE_ADDR_CHANGE<span class="token punctuation">;</span>
    dev<span class="token operator">-&gt;</span>netdev_ops <span class="token operator">=</span> <span class="token operator">&amp;</span>virtnet_netdev<span class="token punctuation">;</span>
    dev<span class="token operator">-&gt;</span>features <span class="token operator">=</span> NETIF_F_HIGHDMA<span class="token punctuation">;</span>

    dev<span class="token operator">-&gt;</span>ethtool_ops <span class="token operator">=</span> <span class="token operator">&amp;</span>virtnet_ethtool_ops<span class="token punctuation">;</span>
    <span class="token function">SET_NETDEV_DEV</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> <span class="token operator">&amp;</span>vdev<span class="token operator">-&gt;</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* MTU range: 68 - 65535 */</span>
    dev<span class="token operator">-&gt;</span>min_mtu <span class="token operator">=</span> MIN_MTU<span class="token punctuation">;</span>
    dev<span class="token operator">-&gt;</span>max_mtu <span class="token operator">=</span> MAX_MTU<span class="token punctuation">;</span>

    <span class="token comment">/* Set up our device-specific information */</span>
    vi <span class="token operator">=</span> <span class="token function">netdev_priv</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vi<span class="token operator">-&gt;</span>dev <span class="token operator">=</span> dev<span class="token punctuation">;</span>
    vi<span class="token operator">-&gt;</span>vdev <span class="token operator">=</span> vdev<span class="token punctuation">;</span>
    vdev<span class="token operator">-&gt;</span>priv <span class="token operator">=</span> vi<span class="token punctuation">;</span>
    vi<span class="token operator">-&gt;</span>stats <span class="token operator">=</span> <span class="token function">alloc_percpu</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">virtnet_stats</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">INIT_WORK</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vi<span class="token operator">-&gt;</span>config_work<span class="token punctuation">,</span> virtnet_config_changed_work<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    vi<span class="token operator">-&gt;</span>max_queue_pairs <span class="token operator">=</span> max_queue_pairs<span class="token punctuation">;</span>

    <span class="token comment">/* Allocate/initialize the rx/tx queues, and invoke find_vqs */</span>
    err <span class="token operator">=</span> <span class="token function">init_vqs</span><span class="token punctuation">(</span>vi<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">netif_set_real_num_tx_queues</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> vi<span class="token operator">-&gt;</span>curr_queue_pairs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">netif_set_real_num_rx_queues</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> vi<span class="token operator">-&gt;</span>curr_queue_pairs<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">virtnet_init_settings</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>

    err <span class="token operator">=</span> <span class="token function">register_netdev</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">virtio_device_ready</span><span class="token punctuation">(</span>vdev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">virtnet_set_queues</span><span class="token punctuation">(</span>vi<span class="token punctuation">,</span> vi<span class="token operator">-&gt;</span>curr_queue_pairs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在virtnet_probe中，会创建struct net_device，并且通过register_netdev注册这个网络设备，这样在客户机里面，就能看到这个网卡了。</p>
<p>在virtnet_probe中，还有一件重要的事情就是，init_vqs会初始化发送和接收的virtqueue。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">init_vqs</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">virtnet_info</span> <span class="token operator">*</span>vi<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>

    <span class="token comment">/* Allocate send &amp; receive queues */</span>
    ret <span class="token operator">=</span> <span class="token function">virtnet_alloc_queues</span><span class="token punctuation">(</span>vi<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ret <span class="token operator">=</span> <span class="token function">virtnet_find_vqs</span><span class="token punctuation">(</span>vi<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">get_online_cpus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">virtnet_set_affinity</span><span class="token punctuation">(</span>vi<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">put_online_cpus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">virtnet_alloc_queues</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">virtnet_info</span> <span class="token operator">*</span>vi<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>

    vi<span class="token operator">-&gt;</span>sq <span class="token operator">=</span> <span class="token function">kzalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>vi<span class="token operator">-&gt;</span>sq<span class="token punctuation">)</span> <span class="token operator">*</span> vi<span class="token operator">-&gt;</span>max_queue_pairs<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vi<span class="token operator">-&gt;</span>rq <span class="token operator">=</span> <span class="token function">kzalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>vi<span class="token operator">-&gt;</span>rq<span class="token punctuation">)</span> <span class="token operator">*</span> vi<span class="token operator">-&gt;</span>max_queue_pairs<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">INIT_DELAYED_WORK</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vi<span class="token operator">-&gt;</span>refill<span class="token punctuation">,</span> refill_work<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> vi<span class="token operator">-&gt;</span>max_queue_pairs<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        vi<span class="token operator">-&gt;</span>rq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>pages <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token function">netif_napi_add</span><span class="token punctuation">(</span>vi<span class="token operator">-&gt;</span>dev<span class="token punctuation">,</span> <span class="token operator">&amp;</span>vi<span class="token operator">-&gt;</span>rq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>napi<span class="token punctuation">,</span> virtnet_poll<span class="token punctuation">,</span>
                   napi_weight<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">netif_tx_napi_add</span><span class="token punctuation">(</span>vi<span class="token operator">-&gt;</span>dev<span class="token punctuation">,</span> <span class="token operator">&amp;</span>vi<span class="token operator">-&gt;</span>sq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>napi<span class="token punctuation">,</span> virtnet_poll_tx<span class="token punctuation">,</span>
                  napi_tx <span class="token operator">?</span> napi_weight <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">sg_init_table</span><span class="token punctuation">(</span>vi<span class="token operator">-&gt;</span>rq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sg<span class="token punctuation">,</span> <span class="token function">ARRAY_SIZE</span><span class="token punctuation">(</span>vi<span class="token operator">-&gt;</span>rq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">ewma_pkt_len_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vi<span class="token operator">-&gt;</span>rq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>mrg_avg_pkt_len<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sg_init_table</span><span class="token punctuation">(</span>vi<span class="token operator">-&gt;</span>sq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sg<span class="token punctuation">,</span> <span class="token function">ARRAY_SIZE</span><span class="token punctuation">(</span>vi<span class="token operator">-&gt;</span>sq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>按照上一节的virtio原理，virtqueue是一个介于客户机前端和qemu后端的一个结构，用于在这两端之间传递数据，对于网络设备来讲有发送和接收两个方向的队列。这里建立的struct virtqueue是客户机前端对于队列的管理的数据结构。</p>
<p>队列的实体需要通过函数virtnet_find_vqs查找或者生成，这里还会指定接收队列的callback函数为skb_recv_done，发送队列的callback函数为skb_xmit_done。那当buffer使用发生变化的时候，我们可以调用这个callback函数进行通知。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">virtnet_find_vqs</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">virtnet_info</span> <span class="token operator">*</span>vi<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    vq_callback_t <span class="token operator">*</span><span class="token operator">*</span>callbacks<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">virtqueue</span> <span class="token operator">*</span><span class="token operator">*</span>vqs<span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token operator">-</span>ENOMEM<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> total_vqs<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>names<span class="token punctuation">;</span>

    <span class="token comment">/* Allocate space for find_vqs parameters */</span>
    vqs <span class="token operator">=</span> <span class="token function">kzalloc</span><span class="token punctuation">(</span>total_vqs <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>vqs<span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    callbacks <span class="token operator">=</span> <span class="token function">kmalloc</span><span class="token punctuation">(</span>total_vqs <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>callbacks<span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    names <span class="token operator">=</span> <span class="token function">kmalloc</span><span class="token punctuation">(</span>total_vqs <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>names<span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* Allocate/initialize parameters for send/receive virtqueues */</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> vi<span class="token operator">-&gt;</span>max_queue_pairs<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        callbacks<span class="token punctuation">[</span><span class="token function">rxq2vq</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> skb_recv_done<span class="token punctuation">;</span>
        callbacks<span class="token punctuation">[</span><span class="token function">txq2vq</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> skb_xmit_done<span class="token punctuation">;</span>
        names<span class="token punctuation">[</span><span class="token function">rxq2vq</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> vi<span class="token operator">-&gt;</span>rq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>
        names<span class="token punctuation">[</span><span class="token function">txq2vq</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> vi<span class="token operator">-&gt;</span>sq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    ret <span class="token operator">=</span> vi<span class="token operator">-&gt;</span>vdev<span class="token operator">-&gt;</span>config<span class="token operator">-&gt;</span><span class="token function">find_vqs</span><span class="token punctuation">(</span>vi<span class="token operator">-&gt;</span>vdev<span class="token punctuation">,</span> total_vqs<span class="token punctuation">,</span> vqs<span class="token punctuation">,</span> callbacks<span class="token punctuation">,</span> names<span class="token punctuation">,</span> ctx<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> vi<span class="token operator">-&gt;</span>max_queue_pairs<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        vi<span class="token operator">-&gt;</span>rq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>vq <span class="token operator">=</span> vqs<span class="token punctuation">[</span><span class="token function">rxq2vq</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        vi<span class="token operator">-&gt;</span>rq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>min_buf_len <span class="token operator">=</span> <span class="token function">mergeable_min_buf_len</span><span class="token punctuation">(</span>vi<span class="token punctuation">,</span> vi<span class="token operator">-&gt;</span>rq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>vq<span class="token punctuation">)</span><span class="token punctuation">;</span>
        vi<span class="token operator">-&gt;</span>sq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>vq <span class="token operator">=</span> vqs<span class="token punctuation">[</span><span class="token function">txq2vq</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里的find_vqs是在struct virtnet_info里的struct virtio_device里的struct virtio_config_ops *config里面定义的。</p>
<p>根据virtio_config_ops的定义，find_vqs会调用vp_modern_find_vqs，到这一步和块设备是一样的了。</p>
<p>在vp_modern_find_vqs中，vp_find_vqs会调用vp_find_vqs_intx。在vp_find_vqs_intx中，通过request_irq注册一个中断处理函数vp_interrupt。当设备向队列中写入信息时，会产生一个中断，也就是vq中断。中断处理函数需要调用相应的队列的回调函数，然后根据队列的数目，依次调用vp_setup_vq完成virtqueue、vring的分配和初始化。</p>
<p>同样，这些数据结构会和virtio后端的VirtIODevice、VirtQueue、vring对应起来，都应该指向刚才创建的那一段内存。</p>
<p>客户机同样会通过调用专门给外部设备发送指令的函数iowrite告诉外部的pci设备，这些共享内存的地址。</p>
<p>至此前端设备驱动和后端设备驱动之间的两个收发队列就关联好了，这两个队列的格式和块设备是一样的。</p>
<h4 id="49-4-发送网络包过程"><a href="#49-4-发送网络包过程" class="headerlink" title="49.4 发送网络包过程"></a>49.4 发送网络包过程</h4><p>接下来，我们来看当真的发送一个网络包的时候，会发生什么。</p>
<p>当网络包经过客户机的协议栈到达virtio_net驱动的时候，按照net_device_ops的定义，start_xmit会被调用。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">net_device_ops</span> virtnet_netdev <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>ndo_open            <span class="token operator">=</span> virtnet_open<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>ndo_stop            <span class="token operator">=</span> virtnet_close<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>ndo_start_xmit      <span class="token operator">=</span> start_xmit<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>ndo_validate_addr   <span class="token operator">=</span> eth_validate_addr<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>ndo_set_mac_address <span class="token operator">=</span> virtnet_set_mac_address<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>ndo_set_rx_mode     <span class="token operator">=</span> virtnet_set_rx_mode<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>ndo_get_stats64     <span class="token operator">=</span> virtnet_stats<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>ndo_vlan_rx_add_vid <span class="token operator">=</span> virtnet_vlan_rx_add_vid<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>ndo_vlan_rx_kill_vid <span class="token operator">=</span> virtnet_vlan_rx_kill_vid<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>ndo_xdp        <span class="token operator">=</span> virtnet_xdp<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>ndo_features_check <span class="token operator">=</span> passthru_features_check<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来的调用链为：start_xmit-&gt;xmit_skb-&gt; virtqueue_add_outbuf-&gt;virtqueue_add，将网络包放入队列中，并调用virtqueue_notify通知接收方。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> netdev_tx_t <span class="token function">start_xmit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">virtnet_info</span> <span class="token operator">*</span>vi <span class="token operator">=</span> <span class="token function">netdev_priv</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> qnum <span class="token operator">=</span> <span class="token function">skb_get_queue_mapping</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">send_queue</span> <span class="token operator">*</span>sq <span class="token operator">=</span> <span class="token operator">&amp;</span>vi<span class="token operator">-&gt;</span>sq<span class="token punctuation">[</span>qnum<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> err<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">netdev_queue</span> <span class="token operator">*</span>txq <span class="token operator">=</span> <span class="token function">netdev_get_tx_queue</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> qnum<span class="token punctuation">)</span><span class="token punctuation">;</span>
    bool kick <span class="token operator">=</span> <span class="token operator">!</span>skb<span class="token operator">-&gt;</span>xmit_more<span class="token punctuation">;</span>
    bool use_napi <span class="token operator">=</span> sq<span class="token operator">-&gt;</span>napi<span class="token punctuation">.</span>weight<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* Try to transmit */</span>
    err <span class="token operator">=</span> <span class="token function">xmit_skb</span><span class="token punctuation">(</span>sq<span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>kick <span class="token operator">||</span> <span class="token function">netif_xmit_stopped</span><span class="token punctuation">(</span>txq<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">virtqueue_kick</span><span class="token punctuation">(</span>sq<span class="token operator">-&gt;</span>vq<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> NETDEV_TX_OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

bool <span class="token function">virtqueue_kick</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">virtqueue</span> <span class="token operator">*</span>vq<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">virtqueue_kick_prepare</span><span class="token punctuation">(</span>vq<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">virtqueue_notify</span><span class="token punctuation">(</span>vq<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>写入一个I/O会使得qemu触发VM exit，这个逻辑我们在解析CPU的时候看到过。</p>
<p>接下来，我们那会调用VirtQueue的handle_output函数。前面我们已经设置过这个函数了，其实就是virtio_net_handle_tx_bh。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">virtio_net_handle_tx_bh</span><span class="token punctuation">(</span>VirtIODevice <span class="token operator">*</span>vdev<span class="token punctuation">,</span> VirtQueue <span class="token operator">*</span>vq<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    VirtIONet <span class="token operator">*</span>n <span class="token operator">=</span> <span class="token function">VIRTIO_NET</span><span class="token punctuation">(</span>vdev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    VirtIONetQueue <span class="token operator">*</span>q <span class="token operator">=</span> <span class="token operator">&amp;</span>n<span class="token operator">-&gt;</span>vqs<span class="token punctuation">[</span><span class="token function">vq2q</span><span class="token punctuation">(</span><span class="token function">virtio_get_queue_index</span><span class="token punctuation">(</span>vq<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    q<span class="token operator">-&gt;</span>tx_waiting <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token function">virtio_queue_set_notification</span><span class="token punctuation">(</span>vq<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">qemu_bh_schedule</span><span class="token punctuation">(</span>q<span class="token operator">-&gt;</span>tx_bh<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>virtio_net_handle_tx_bh调用了qemu_bh_schedule，而在virtio_net_add_queue中调用qemu_bh_new，并把函数设置为virtio_net_tx_bh。</p>
<p>virtio_net_tx_bh函数调用发送函数virtio_net_flush_tx。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> int32_t <span class="token function">virtio_net_flush_tx</span><span class="token punctuation">(</span>VirtIONetQueue <span class="token operator">*</span>q<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    VirtIONet <span class="token operator">*</span>n <span class="token operator">=</span> q<span class="token operator">-&gt;</span>n<span class="token punctuation">;</span>
    VirtIODevice <span class="token operator">*</span>vdev <span class="token operator">=</span> <span class="token function">VIRTIO_DEVICE</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    VirtQueueElement <span class="token operator">*</span>elem<span class="token punctuation">;</span>
    int32_t num_packets <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> queue_index <span class="token operator">=</span> <span class="token function">vq2q</span><span class="token punctuation">(</span><span class="token function">virtio_get_queue_index</span><span class="token punctuation">(</span>q<span class="token operator">-&gt;</span>tx_vq<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ssize_t ret<span class="token punctuation">;</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> out_num<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">iovec</span> sg<span class="token punctuation">[</span>VIRTQUEUE_MAX_SIZE<span class="token punctuation">]</span><span class="token punctuation">,</span> sg2<span class="token punctuation">[</span>VIRTQUEUE_MAX_SIZE <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>out_sg<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">virtio_net_hdr_mrg_rxbuf</span> mhdr<span class="token punctuation">;</span>

        elem <span class="token operator">=</span> <span class="token function">virtqueue_pop</span><span class="token punctuation">(</span>q<span class="token operator">-&gt;</span>tx_vq<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>VirtQueueElement<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        out_num <span class="token operator">=</span> elem<span class="token operator">-&gt;</span>out_num<span class="token punctuation">;</span>
        out_sg <span class="token operator">=</span> elem<span class="token operator">-&gt;</span>out_sg<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        ret <span class="token operator">=</span> <span class="token function">qemu_sendv_packet_async</span><span class="token punctuation">(</span><span class="token function">qemu_get_subqueue</span><span class="token punctuation">(</span>n<span class="token operator">-&gt;</span>nic<span class="token punctuation">,</span> queue_index<span class="token punctuation">)</span><span class="token punctuation">,</span>out_sg<span class="token punctuation">,</span> out_num<span class="token punctuation">,</span> virtio_net_tx_complete<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> num_packets<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>virtio_net_flush_tx会调用virtqueue_pop。这里面，我们能看到对于vring的操作，也即从这里面将客户机里面写入的数据读取出来。</p>
<p>然后，我们调用qemu_sendv_packet_async发送网络包。接下来的调用链为：qemu_sendv_packet_async-&gt;qemu_net_queue_send_iov-&gt;qemu_net_queue_flush-&gt;qemu_net_queue_deliver。</p>
<p>在qemu_net_queue_deliver中，我们会调用NetQueue的deliver函数。前面qemu_new_net_queue会把deliver函数设置为qemu_deliver_packet_iov。它会调用nc-&gt;info-&gt;receive_iov。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> NetClientInfo net_tap_info <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>type <span class="token operator">=</span> NET_CLIENT_DRIVER_TAP<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>TAPState<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>receive <span class="token operator">=</span> tap_receive<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>receive_raw <span class="token operator">=</span> tap_receive_raw<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>receive_iov <span class="token operator">=</span> tap_receive_iov<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>poll <span class="token operator">=</span> tap_poll<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>cleanup <span class="token operator">=</span> tap_cleanup<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>has_ufo <span class="token operator">=</span> tap_has_ufo<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>has_vnet_hdr <span class="token operator">=</span> tap_has_vnet_hdr<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>has_vnet_hdr_len <span class="token operator">=</span> tap_has_vnet_hdr_len<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>using_vnet_hdr <span class="token operator">=</span> tap_using_vnet_hdr<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>set_offload <span class="token operator">=</span> tap_set_offload<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>set_vnet_hdr_len <span class="token operator">=</span> tap_set_vnet_hdr_len<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>set_vnet_le <span class="token operator">=</span> tap_set_vnet_le<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>set_vnet_be <span class="token operator">=</span> tap_set_vnet_be<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>根据net_tap_info的定义调用的是tap_receive_iov。他会调用tap_write_packet-&gt;writev写入这个字符设备。</p>
<p>在内核的字符设备驱动中，tun_chr_write_iter会被调用。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> ssize_t <span class="token function">tun_chr_write_iter</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kiocb</span> <span class="token operator">*</span>iocb<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">iov_iter</span> <span class="token operator">*</span>from<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file <span class="token operator">=</span> iocb<span class="token operator">-&gt;</span>ki_filp<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">tun_struct</span> <span class="token operator">*</span>tun <span class="token operator">=</span> <span class="token function">tun_get</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">tun_file</span> <span class="token operator">*</span>tfile <span class="token operator">=</span> file<span class="token operator">-&gt;</span>private_data<span class="token punctuation">;</span>
    ssize_t result<span class="token punctuation">;</span>

    result <span class="token operator">=</span> <span class="token function">tun_get_user</span><span class="token punctuation">(</span>tun<span class="token punctuation">,</span> tfile<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> from<span class="token punctuation">,</span>
                  file<span class="token operator">-&gt;</span>f_flags <span class="token operator">&amp;</span> O_NONBLOCK<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">tun_put</span><span class="token punctuation">(</span>tun<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当我们使用writev()系统调用向tun/tap设备的字符设备文件写入数据时，tun_chr_write函数将被调用。它会使用tun_get_user，从用户区接收数据，将数据存入skb中，然后调用关键的函数netif_rx_ni(skb) ，将skb送给tcp/ip协议栈处理，最终完成虚拟网卡的数据接收。</p>
<p>至此，从虚拟机内部到宿主机的网络传输过程才算结束。</p>
<h4 id="49-5-总结"><a href="#49-5-总结" class="headerlink" title="49.5 总结"></a>49.5 总结</h4><p>最后，我们把网络虚拟化场景下网络包的发送过程总结一下。</p>
<ul>
<li>在虚拟机里面的用户态，应用程序通过write系统调用写入socket。</li>
<li>写入的内容经过VFS层，内核协议栈，到达虚拟机里面的内核的网络设备驱动，也即virtio_net。</li>
<li>virtio_net网络设备有一个操作结构struct net_device_ops，里面定义了发送一个网络包调用的函数为start_xmit。</li>
<li>在virtio_net的前端驱动和qemu中的后端驱动之间，有两个队列virtqueue，一个用于发送，一个用于接收。然后，我们需要在start_xmit中调用virtqueue_add，将网络包放入发送队列，然后调用virtqueue_notify通知qemu。</li>
<li>qemu本来处于KVM_RUN的状态，收到通知后，通过VM exit指令退出客户机模式，进入宿主机模式。发送网络包的时候，virtio_net_handle_tx_bh函数会被调用。</li>
<li>接下来是一个for循环，我们需要在循环中调用virtqueue_pop，从传输队列中获取要发送的数据，然后调用qemu_sendv_packet_async进行发送。</li>
<li>qemu会调用writev向字符设备文件写入，进入宿主机的内核。</li>
<li>在宿主机内核中字符设备文件的file_operations里面的write_iter会被调用，也即会调用tun_chr_write_iter。</li>
<li>在tun_chr_write_iter函数中，tun_get_user将要发送的网络包从qemu拷贝到宿主机内核里面来，然后调用netif_rx_ni开始调用宿主机内核协议栈进行处理。</li>
<li>宿主机内核协议栈处理完毕之后，会发送给tap虚拟网卡，完成从虚拟机里面到宿主机的整个发送过程。</li>
</ul>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/网络虚拟化场景下网络包的发送过程.jpg" alt="网络虚拟化场景下网络包的发送过程"></p>
<h2 id="九、容器化"><a href="#九、容器化" class="headerlink" title="九、容器化"></a>九、容器化</h2><h3 id="50-容器"><a href="#50-容器" class="headerlink" title="50. 容器"></a>50. 容器</h3><p>上一章，我们讲了虚拟化的原理。从一台物理机虚拟化出很多的虚拟机这种方式，一定程度上实现了资源创建的灵活性。但是你同时会发现，虚拟化的方式还是非常复杂的。</p>
<p>那有没有一种更加灵活的方式，既可以隔离出一部分资源，专门用于某个进程，又不需要费劲周折的虚拟化这么多的硬件呢？毕竟最终我只想跑一个程序，而不是要一整个Linux系统。</p>
<p>在Linux操作系统中，有一项新的技术，称为容器，它就可以做到这一点。</p>
<p>容器的英文叫Container，Container的另一个意思是“集装箱”。其实容器就像船上的不同的集装箱装着不同的货物，有一定的隔离，但是隔离性又没有那么好，仅仅做简单的封装。当然封装也带来了好处，一个是打包，二是标准。</p>
<p>在没有集装箱的时代，假设我们要将货物从A运到B，中间要经过三个码头、换三次船。那么每次都要将货物卸下船来，弄得乱七八糟，然后还要再搬上船重新摆好。因此在没有集装箱的时候，每次换船，船员们都要在岸上待几天才能干完活。</p>
<p>有了尺寸全部都一样的集装箱以后，我们可以把所有的货物都打包在一起。每次换船的时候，把整个集装箱搬过去就行了，几个小时就能完成。船员换船时间大大缩短了。这是集装箱的“打包”和“标准”两大特点在生活中的应用。</p>
<p>其实容器的思想就是要变成软件交付的集装箱。那么容器如何对应用打包呢？</p>
<p>我们先来学习一下集装箱的打包过程。首先，我们得有个封闭的环境，将货物封装起来，让货物之间互不干扰，互相隔离，这样装货卸货才方便。</p>
<p>容器实现封闭的环境主要要靠两种技术，一种是看起来是隔离的技术，称为namespace（命名空间）。在每个namespace中的应用看到的，都是不同的 IP地址、用户空间、进程ID等。另一种是用起来是隔离的技术，称为cgroup（网络资源限制），即明明整台机器有很多的 CPU、内存，但是一个应用只能用其中的一部分。</p>
<p>有了这两项技术，就相当于我们焊好了集装箱。接下来的问题就是，如何“将这些集装箱标准化”，在哪艘船上都能运输。这里就要用到镜像了。</p>
<p>所谓镜像（Image），就是在你焊好集装箱的那一刻，将集装箱的状态保存下来。就像孙悟空说：“定！”，集装箱里的状态就被“定”在了那一刻，然后这一刻的状态会被保存成一系列文件。无论在哪里运行这个镜像，都能完整地还原当时的情况。</p>
<p>当程序员根据产品设计开发完毕之后，可以将代码连同运行环境打包成一个容器镜像。这个时候集装箱就焊好了。接下来，无论是在开发环境、测试环境，还是生产环境运行代码，都可以使用相同的镜像。就好像集装箱在开发、测试、生产这三个码头非常顺利地整体迁移，这样产品的发布和上线速度就加快了。</p>
<p>Docker可以限制对于CPU的使用，我们可以分几种的方式。</p>
<ul>
<li>Docker允许用户为每个容器设置一个数字，代表容器的 CPU share，默认情况下每个容器的 share 是 1024。这个数值是相对的，本身并不能代表任何确定的意义。当主机上有多个容器运行时，每个容器占用的 CPU 时间比例为它的 share 在总额中的比例。Docker为容器设置CPU share 的参数是 -c —cpu-shares。</li>
<li>Docker提供了 —cpus 参数可以限定容器能使用的 CPU 核数。</li>
<li>Docker可以通过 —cpuset 参数让容器只运行在某些核上</li>
</ul>
<p>Docker会限制容器内存使用量，下面是一些具体的参数。</p>
<ul>
<li>-m —memory：容器能使用的最大内存大小。</li>
<li>–memory-swap：容器能够使用的 swap 大小。</li>
<li>–memory-swappiness：默认情况下，主机可以把容器使用的匿名页swap出来，你可以设置一个 0-100 之间的值，代表允许 swap 出来的比例。</li>
<li>–memory-reservation：设置一个内存使用的 soft limit，如果 docker 发现主机内存不足，会执行 OOM (Out of Memory)操作。这个值必须小于 —memory 设置的值。</li>
<li>–kernel-memory：容器能够使用的 kernel memory 大小。</li>
<li>–oom-kill-disable：是否运行 OOM (Out of Memory)的时候杀死容器。只有设置了 -m，才可以把这个选项设置为 false，否则容器会耗尽主机内存，而且导致主机应用被杀死。</li>
</ul>
<p>这就是用起来隔离的效果。</p>
<h4 id="50-1-总结"><a href="#50-1-总结" class="headerlink" title="50.1 总结"></a>50.1 总结</h4><p>这里我们来总结一下这一节的内容。无论是容器，还是虚拟机，都依赖于内核中的技术，虚拟机依赖的是KVM，容器依赖的是namespace和cgroup对进程进行隔离。</p>
<p>为了运行Docker，有一个daemon进程Docker Daemon用于接收命令行。</p>
<p>为了描述Docker里面运行的环境和应用，有一个Dockerfile，通过build命令称为容器镜像。容器镜像可以上传到镜像仓库，也可以通过pull命令从镜像仓库中下载现成的容器镜像。</p>
<p>通过Docker run命令将容器镜像运行为容器，通过namespace和cgroup进行隔离，容器里面不包含内核，是共享宿主机的内核的。对比虚拟机，虚拟机在qemu进程里面是有客户机内核的，应用运行在客户机的用户态。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/容器总结.jpg" alt="容器总结.jpg"></p>
<h3 id="51-Namespace技术"><a href="#51-Namespace技术" class="headerlink" title="51. Namespace技术"></a>51. Namespace技术</h3><p>为了隔离不同类型的资源，Linux内核里面实现了以下几种不同类型的namespace。</p>
<ul>
<li>UTS，对应的宏为CLONE_NEWUTS，表示不同的namespace可以配置不同的hostname。</li>
<li>User，对应的宏为CLONE_NEWUSER，表示不同的namespace可以配置不同的用户和组。</li>
<li>Mount，对应的宏为CLONE_NEWNS，表示不同的namespace的文件系统挂载点是隔离的</li>
<li>PID，对应的宏为CLONE_NEWPID，表示不同的namespace有完全独立的pid，也即一个namespace的进程和另一个namespace的进程，pid可以是一样的，但是代表不同的进程。</li>
<li>Network，对应的宏为CLONE_NEWNET，表示不同的namespace有独立的网络协议栈。</li>
</ul>
<p>还记得咱们启动的那个容器吗？</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker <span class="token function">ps</span>
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES
f604f0e34bc2        testnginx:1         <span class="token string">"/bin/sh -c 'nginx -…"</span>   <span class="token number">17</span> hours ago        Up <span class="token number">17</span> hours         <span class="token number">0.0</span>.0.0:8081-<span class="token operator">&gt;</span><span class="token number">80</span>/tcp   youthful_torvalds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>我们可以看这个容器对应的entrypoint的pid。通过docker inspect命令，可以看到，进程号为58212。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker inspect f604f0e34bc2
<span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
        <span class="token string">"Id"</span><span class="token builtin class-name">:</span> <span class="token string">"f604f0e34bc263bc32ba683d97a1db2a65de42ab052da16df3c7811ad07f0dc3"</span>,
        <span class="token string">"Created"</span><span class="token builtin class-name">:</span> <span class="token string">"2019-07-15T17:43:44.158300531Z"</span>,
        <span class="token string">"Path"</span><span class="token builtin class-name">:</span> <span class="token string">"/bin/sh"</span>,
        <span class="token string">"Args"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
            <span class="token string">"-c"</span>,
            <span class="token string">"nginx -g <span class="token entity" title="\&quot;">\"</span>daemon off;<span class="token entity" title="\&quot;">\"</span>"</span>
        <span class="token punctuation">]</span>,
        <span class="token string">"State"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span>
            <span class="token string">"Status"</span><span class="token builtin class-name">:</span> <span class="token string">"running"</span>,
            <span class="token string">"Running"</span><span class="token builtin class-name">:</span> true,
            <span class="token string">"Pid"</span><span class="token builtin class-name">:</span> <span class="token number">58212</span>,
            <span class="token string">"ExitCode"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,
            <span class="token string">"StartedAt"</span><span class="token builtin class-name">:</span> <span class="token string">"2019-07-15T17:43:44.651756682Z"</span>,
            <span class="token string">"FinishedAt"</span><span class="token builtin class-name">:</span> <span class="token string">"0001-01-01T00:00:00Z"</span>
        <span class="token punctuation">}</span>,
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
        <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"/youthful_torvalds"</span>,
        <span class="token string">"RestartCount"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,
        <span class="token string">"Driver"</span><span class="token builtin class-name">:</span> <span class="token string">"overlay2"</span>,
        <span class="token string">"Platform"</span><span class="token builtin class-name">:</span> <span class="token string">"linux"</span>,
        <span class="token string">"HostConfig"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span>
            <span class="token string">"NetworkMode"</span><span class="token builtin class-name">:</span> <span class="token string">"default"</span>,
            <span class="token string">"PortBindings"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span>
                <span class="token string">"80/tcp"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
                    <span class="token punctuation">{</span>
                        <span class="token string">"HostIp"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,
                        <span class="token string">"HostPort"</span><span class="token builtin class-name">:</span> <span class="token string">"8081"</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">]</span>
            <span class="token punctuation">}</span>,
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
        <span class="token punctuation">}</span>,
        <span class="token string">"Config"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span>
            <span class="token string">"Hostname"</span><span class="token builtin class-name">:</span> <span class="token string">"f604f0e34bc2"</span>,
            <span class="token string">"ExposedPorts"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span>
                <span class="token string">"80/tcp"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
            <span class="token punctuation">}</span>,
            <span class="token string">"Image"</span><span class="token builtin class-name">:</span> <span class="token string">"testnginx:1"</span>,
            <span class="token string">"Entrypoint"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
                <span class="token string">"/bin/sh"</span>,
                <span class="token string">"-c"</span>,
                <span class="token string">"nginx -g <span class="token entity" title="\&quot;">\"</span>daemon off;<span class="token entity" title="\&quot;">\"</span>"</span>
            <span class="token punctuation">]</span>,
        <span class="token punctuation">}</span>,
        <span class="token string">"NetworkSettings"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span>
            <span class="token string">"Bridge"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,
            <span class="token string">"SandboxID"</span><span class="token builtin class-name">:</span> <span class="token string">"7fd3eb469578903b66687090e512958658ae28d17bce1a7cee2da3148d1dfad4"</span>,
            <span class="token string">"Ports"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span>
                <span class="token string">"80/tcp"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
                    <span class="token punctuation">{</span>
                        <span class="token string">"HostIp"</span><span class="token builtin class-name">:</span> <span class="token string">"0.0.0.0"</span>,
                        <span class="token string">"HostPort"</span><span class="token builtin class-name">:</span> <span class="token string">"8081"</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">]</span>
            <span class="token punctuation">}</span>,
            <span class="token string">"Gateway"</span><span class="token builtin class-name">:</span> <span class="token string">"172.17.0.1"</span>,
            <span class="token string">"IPAddress"</span><span class="token builtin class-name">:</span> <span class="token string">"172.17.0.3"</span>,
            <span class="token string">"IPPrefixLen"</span><span class="token builtin class-name">:</span> <span class="token number">16</span>,
            <span class="token string">"MacAddress"</span><span class="token builtin class-name">:</span> <span class="token string">"02:42:ac:11:00:03"</span>,
            <span class="token string">"Networks"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span>
                <span class="token string">"bridge"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span>
                    <span class="token string">"NetworkID"</span><span class="token builtin class-name">:</span> <span class="token string">"c8eef1603afb399bf17af154be202fd1e543d3772cc83ef4a1ca3f97b8bd6eda"</span>,
                    <span class="token string">"EndpointID"</span><span class="token builtin class-name">:</span> <span class="token string">"8d9bb18ca57889112e758ede193d2cfb45cbf794c9d952819763c08f8545da46"</span>,
                    <span class="token string">"Gateway"</span><span class="token builtin class-name">:</span> <span class="token string">"172.17.0.1"</span>,
                    <span class="token string">"IPAddress"</span><span class="token builtin class-name">:</span> <span class="token string">"172.17.0.3"</span>,
                    <span class="token string">"IPPrefixLen"</span><span class="token builtin class-name">:</span> <span class="token number">16</span>,
                    <span class="token string">"MacAddress"</span><span class="token builtin class-name">:</span> <span class="token string">"02:42:ac:11:00:03"</span>,
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果我们用ps查看机器上的nginx进程，可以看到master和worker，worker的父进程是master。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ps</span> -ef <span class="token operator">|</span><span class="token function">grep</span> nginx
root     <span class="token number">58212</span> <span class="token number">58195</span>  <span class="token number">0</span> 01:43 ?        00:00:00 /bin/sh -c nginx -g <span class="token string">"daemon off;"</span>
root     <span class="token number">58244</span> <span class="token number">58212</span>  <span class="token number">0</span> 01:43 ?        00:00:00 nginx: master process nginx -g daemon off<span class="token punctuation">;</span>
<span class="token number">33</span>       <span class="token number">58250</span> <span class="token number">58244</span>  <span class="token number">0</span> 01:43 ?        00:00:00 nginx: worker process
<span class="token number">33</span>       <span class="token number">58251</span> <span class="token number">58244</span>  <span class="token number">0</span> 01:43 ?        00:00:05 nginx: worker process
<span class="token number">33</span>       <span class="token number">58252</span> <span class="token number">58244</span>  <span class="token number">0</span> 01:43 ?        00:00:05 nginx: worker process
<span class="token number">33</span>       <span class="token number">58253</span> <span class="token number">58244</span>  <span class="token number">0</span> 01:43 ?        00:00:05 nginx: worker process<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在/proc/pid/ns里面，我们能够看到这个进程所属于的6种namespace。我们拿出两个进程来，应该可以看出来，它们属于同一个namespace。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> -l /proc/58212/ns
lrwxrwxrwx <span class="token number">1</span> root root <span class="token number">0</span> Jul <span class="token number">16</span> <span class="token number">19</span>:19 ipc -<span class="token operator">&gt;</span> ipc:<span class="token punctuation">[</span><span class="token number">4026532278</span><span class="token punctuation">]</span>
lrwxrwxrwx <span class="token number">1</span> root root <span class="token number">0</span> Jul <span class="token number">16</span> <span class="token number">19</span>:19 mnt -<span class="token operator">&gt;</span> mnt:<span class="token punctuation">[</span><span class="token number">4026532276</span><span class="token punctuation">]</span>
lrwxrwxrwx <span class="token number">1</span> root root <span class="token number">0</span> Jul <span class="token number">16</span> 01:43 net -<span class="token operator">&gt;</span> net:<span class="token punctuation">[</span><span class="token number">4026532281</span><span class="token punctuation">]</span>
lrwxrwxrwx <span class="token number">1</span> root root <span class="token number">0</span> Jul <span class="token number">16</span> <span class="token number">19</span>:19 pid -<span class="token operator">&gt;</span> pid:<span class="token punctuation">[</span><span class="token number">4026532279</span><span class="token punctuation">]</span>
lrwxrwxrwx <span class="token number">1</span> root root <span class="token number">0</span> Jul <span class="token number">16</span> <span class="token number">19</span>:19 user -<span class="token operator">&gt;</span> user:<span class="token punctuation">[</span><span class="token number">4026531837</span><span class="token punctuation">]</span>
lrwxrwxrwx <span class="token number">1</span> root root <span class="token number">0</span> Jul <span class="token number">16</span> <span class="token number">19</span>:19 uts -<span class="token operator">&gt;</span> uts:<span class="token punctuation">[</span><span class="token number">4026532277</span><span class="token punctuation">]</span>

$ <span class="token function">ls</span> -l /proc/58253/ns
lrwxrwxrwx <span class="token number">1</span> <span class="token number">33</span> tape <span class="token number">0</span> Jul <span class="token number">16</span> <span class="token number">19</span>:20 ipc -<span class="token operator">&gt;</span> ipc:<span class="token punctuation">[</span><span class="token number">4026532278</span><span class="token punctuation">]</span>
lrwxrwxrwx <span class="token number">1</span> <span class="token number">33</span> tape <span class="token number">0</span> Jul <span class="token number">16</span> <span class="token number">19</span>:20 mnt -<span class="token operator">&gt;</span> mnt:<span class="token punctuation">[</span><span class="token number">4026532276</span><span class="token punctuation">]</span>
lrwxrwxrwx <span class="token number">1</span> <span class="token number">33</span> tape <span class="token number">0</span> Jul <span class="token number">16</span> <span class="token number">19</span>:20 net -<span class="token operator">&gt;</span> net:<span class="token punctuation">[</span><span class="token number">4026532281</span><span class="token punctuation">]</span>
lrwxrwxrwx <span class="token number">1</span> <span class="token number">33</span> tape <span class="token number">0</span> Jul <span class="token number">16</span> <span class="token number">19</span>:20 pid -<span class="token operator">&gt;</span> pid:<span class="token punctuation">[</span><span class="token number">4026532279</span><span class="token punctuation">]</span>
lrwxrwxrwx <span class="token number">1</span> <span class="token number">33</span> tape <span class="token number">0</span> Jul <span class="token number">16</span> <span class="token number">19</span>:20 user -<span class="token operator">&gt;</span> user:<span class="token punctuation">[</span><span class="token number">4026531837</span><span class="token punctuation">]</span>
lrwxrwxrwx <span class="token number">1</span> <span class="token number">33</span> tape <span class="token number">0</span> Jul <span class="token number">16</span> <span class="token number">19</span>:20 uts -<span class="token operator">&gt;</span> uts:<span class="token punctuation">[</span><span class="token number">4026532277</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来，我们来看，如何操作namespace。这里我们重点关注pid和network。</p>
<p>操作namespace的常用指令<strong>nsenter</strong>，可以用来运行一个进程，进入指定的namespace。例如，通过下面的命令，我们可以运行/bin/bash，并且进入nginx所在容器的namespace。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ nsenter --target <span class="token number">58212</span> --mount --uts --ipc --net --pid -- <span class="token function">env</span> --ignore-environment -- /bin/bash

root@f604f0e34bc2:/<span class="token comment"># ip addr</span>
<span class="token number">1</span>: lo: <span class="token operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class="token number">1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet <span class="token number">127.0</span>.0.1/8 scope <span class="token function">host</span> lo
       valid_lft forever preferred_lft forever
<span class="token number">23</span>: eth0@if24: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">1500</span> qdisc noqueue state UP group default
    link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff
    inet <span class="token number">172.17</span>.0.3/16 brd <span class="token number">172.17</span>.255.255 scope global eth0
       valid_lft forever preferred_lft forever<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另一个命令是<strong>unshare</strong>，它会离开当前的namespace，创建且加入新的namespace，然后执行参数中指定的命令。</p>
<p>例如，运行下面这行命令之后，pid和net都进入了新的namespace。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">unshare --mount --ipc --pid --net --mount-proc<span class="token operator">=</span>/proc --fork /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果从shell上运行上面这行命令的话，好像没有什么变化，但是因为pid和net都进入了新的namespace，所以我们查看进程列表和ip地址的时候应该会发现有所不同。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ip</span> addr
<span class="token number">1</span>: lo: <span class="token operator">&lt;</span>LOOPBACK<span class="token operator">&gt;</span> mtu <span class="token number">65536</span> qdisc noop state DOWN group default qlen <span class="token number">1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00

$ <span class="token function">ps</span> aux
<span class="token environment constant">USER</span>       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         <span class="token number">1</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span> <span class="token number">115568</span>  <span class="token number">2136</span> pts/0    S    <span class="token number">22</span>:55   <span class="token number">0</span>:00 /bin/bash
root        <span class="token number">13</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span> <span class="token number">155360</span>  <span class="token number">1872</span> pts/0    R+   <span class="token number">22</span>:55   <span class="token number">0</span>:00 <span class="token function">ps</span> aux<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>果真，我们看不到宿主机上的IP地址和网卡了，也看不到宿主机上的所有进程了。</p>
<p>另外，我们还可以通过函数操作namespace。</p>
<p>第一个函数是<strong>clone</strong>，也就是创建一个新的进程，并把它放到新的namespace中。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>fn<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>child_stack<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>clone函数我们原来介绍过。这里面有一个参数flags，原来我们没有注意它。其实它可以设置为CLONE_NEWUTS、CLONE_NEWUSER、CLONE_NEWNS、CLONE_NEWPID。CLONE_NEWNET会将clone出来的新进程放到新的namespace中。</p>
<p>第二个函数是<strong>setns</strong>，用于将当前进程加入到已有的namespace中。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">setns</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> nstype<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>其中，fd指向/proc/[pid]/ns/目录里相应namespace对应的文件，表示要加入哪个namespace。nstype用来指定namespace的类型，可以设置为CLONE_NEWUTS、CLONE_NEWUSER、CLONE_NEWNS、CLONE_NEWPID和CLONE_NEWNET。</p>
<p>第三个函数是<strong>unshare</strong>，它可以使当前进程退出当前的namespace，并加入到新创建的namespace。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">unshare</span><span class="token punctuation">(</span><span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>其中，flags用于指定一个或者多个上面的CLONE_NEWUTS、CLONE_NEWUSER、CLONE_NEWNS、CLONE_NEWPID和CLONE_NEWNET。</p>
<p>clone和unshare的区别是，unshare是使当前进程加入新的namespace；clone是创建一个新的子进程，然后让子进程加入新的namespace，而当前进程保持不变。</p>
<p>这里我们尝试一下，通过clone函数来进入一个namespace。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">_GNU_SOURCE</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/utsname.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sched.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">STACK_SIZE</span> <span class="token punctuation">(</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span></span></span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">childFunc</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"In child process.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">execlp</span><span class="token punctuation">(</span><span class="token string">"bash"</span><span class="token punctuation">,</span> <span class="token string">"bash"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>stack<span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>stackTop<span class="token punctuation">;</span>
    pid_t pid<span class="token punctuation">;</span>

    stack <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>STACK_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>stack <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"malloc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    stackTop <span class="token operator">=</span> stack <span class="token operator">+</span> STACK_SIZE<span class="token punctuation">;</span>

    pid <span class="token operator">=</span> <span class="token function">clone</span><span class="token punctuation">(</span>childFunc<span class="token punctuation">,</span> stackTop<span class="token punctuation">,</span> CLONE_NEWNS<span class="token operator">|</span>CLONE_NEWPID<span class="token operator">|</span>CLONE_NEWNET<span class="token operator">|</span>SIGCHLD<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"clone"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"clone() returned %ld\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">waitpid</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"waitpid"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child has terminated\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上面的代码中，我们调用clone的时候，给的参数是CLONE_NEWNS|CLONE_NEWPID|CLONE_NEWNET，也就是说，我们会进入一个新的pid、network，以及mount的namespace。</p>
<p>如果我们编译运行它，可以得到下面的结果。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token variable">$$</span>
<span class="token number">64267</span>

$ <span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">grep</span> <span class="token function">bash</span> <span class="token operator">|</span> <span class="token function">grep</span> -v <span class="token function">grep</span>
root     <span class="token number">64267</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span> <span class="token number">115572</span>  <span class="token number">2176</span> pts/0    Ss   <span class="token number">16</span>:53   <span class="token number">0</span>:00 -bash

$ ./a.out
clone<span class="token punctuation">(</span><span class="token punctuation">)</span> returned <span class="token number">64360</span>
In child process.

$ <span class="token builtin class-name">echo</span> <span class="token variable">$$</span>
<span class="token number">1</span>

$ <span class="token function">ip</span> addr
<span class="token number">1</span>: lo: <span class="token operator">&lt;</span>LOOPBACK<span class="token operator">&gt;</span> mtu <span class="token number">65536</span> qdisc noop state DOWN group default qlen <span class="token number">1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00

$ <span class="token builtin class-name">exit</span>
<span class="token builtin class-name">exit</span>
child has terminated

$ <span class="token builtin class-name">echo</span> <span class="token variable">$$</span>
<span class="token number">64267</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过echo $$，我们可以得到当前bash的进程号。一旦运行了上面的程序，我们就会进入一个新的pid的namespace。</p>
<p>当我们再次echo <script type="math/tex">的时候，就会发现当前bash的进程号变成了1。上面的程序运行了一个新的bash，它在一个独立的pid namespace里面，自己是1号进程。如果运行ip addr，可以看到，宿主机的网卡都找不到了，因为新的bash也在一个独立的network namespace里面，等退出了，再次echo</script>的时候，就可以得到原来进程号。</p>
<p>clone系统调用我们在<strong>进程的创建</strong>那一节解析过，当时我们没有看关于namespace的代码，现在我们就来看一看，namespace在内核做了哪些事情。</p>
<p>在内核里面，clone会调用_do_fork-&gt;copy_process-&gt;copy_namespaces，也就是说，在创建子进程的时候，有一个机会可以复制和设置namespace。</p>
<p>namespace是在哪里定义的呢？在每一个进程的task_struct里面，有一个指向namespace结构体的指针nsproxy。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* Namespaces: */</span>
    <span class="token keyword">struct</span> <span class="token class-name">nsproxy</span>          <span class="token operator">*</span>nsproxy<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token comment">/*
 * A structure to contain pointers to all per-process
 * namespaces - fs (mount), uts, network, sysvipc, etc.
 *
 * The pid namespace is an exception -- it's accessed using
 * task_active_pid_ns.  The pid namespace here is the
 * namespace that children will use.
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">nsproxy</span> <span class="token punctuation">{</span>
    atomic_t count<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">uts_namespace</span> <span class="token operator">*</span>uts_ns<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">ipc_namespace</span> <span class="token operator">*</span>ipc_ns<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">mnt_namespace</span> <span class="token operator">*</span>mnt_ns<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">pid_namespace</span> <span class="token operator">*</span>pid_ns_for_children<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">net</span>       <span class="token operator">*</span>net_ns<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">cgroup_namespace</span> <span class="token operator">*</span>cgroup_ns<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们可以看到在struct nsproxy结构里面，有我们上面讲过的各种namespace。</p>
<p>在系统初始化的时候，有一个默认的init_nsproxy。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">nsproxy</span> init_nsproxy <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>count          <span class="token operator">=</span> <span class="token function">ATOMIC_INIT</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>uts_ns         <span class="token operator">=</span> <span class="token operator">&amp;</span>init_uts_ns<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>CONFIG_POSIX_MQUEUE<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">defined</span><span class="token punctuation">(</span>CONFIG_SYSVIPC<span class="token punctuation">)</span></span></span>
    <span class="token punctuation">.</span>ipc_ns         <span class="token operator">=</span> <span class="token operator">&amp;</span>init_ipc_ns<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token punctuation">.</span>mnt_ns         <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>pid_ns_for_children    <span class="token operator">=</span> <span class="token operator">&amp;</span>init_pid_ns<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_NET</span></span>
    <span class="token punctuation">.</span>net_ns         <span class="token operator">=</span> <span class="token operator">&amp;</span>init_net<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_CGROUPS</span></span>
    <span class="token punctuation">.</span>cgroup_ns      <span class="token operator">=</span> <span class="token operator">&amp;</span>init_cgroup_ns<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面，我们来看copy_namespaces的实现。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * called from clone.  This now handles copy for nsproxy and all
 * namespaces therein.
 */</span>
<span class="token keyword">int</span> <span class="token function">copy_namespaces</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">nsproxy</span> <span class="token operator">*</span>old_ns <span class="token operator">=</span> tsk<span class="token operator">-&gt;</span>nsproxy<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">user_namespace</span> <span class="token operator">*</span>user_ns <span class="token operator">=</span> <span class="token function">task_cred_xxx</span><span class="token punctuation">(</span>tsk<span class="token punctuation">,</span> user_ns<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">nsproxy</span> <span class="token operator">*</span>new_ns<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span>CLONE_NEWNS <span class="token operator">|</span> CLONE_NEWUTS <span class="token operator">|</span> CLONE_NEWIPC <span class="token operator">|</span>
                  CLONE_NEWPID <span class="token operator">|</span> CLONE_NEWNET <span class="token operator">|</span>
                  CLONE_NEWCGROUP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">get_nsproxy</span><span class="token punctuation">(</span>old_ns<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">ns_capable</span><span class="token punctuation">(</span>user_ns<span class="token punctuation">,</span> CAP_SYS_ADMIN<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>EPERM<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    new_ns <span class="token operator">=</span> <span class="token function">create_new_namespaces</span><span class="token punctuation">(</span>flags<span class="token punctuation">,</span> tsk<span class="token punctuation">,</span> user_ns<span class="token punctuation">,</span> tsk<span class="token operator">-&gt;</span>fs<span class="token punctuation">)</span><span class="token punctuation">;</span>

    tsk<span class="token operator">-&gt;</span>nsproxy <span class="token operator">=</span> new_ns<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果clone的参数里面没有CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNET | CLONE_NEWCGROUP，就返回原来的namespace，调用get_nsproxy。</p>
<p>接着，我们调用create_new_namespaces。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * Create new nsproxy and all of its the associated namespaces.
 * Return the newly created nsproxy.  Do not attach this to the task,
 * leave it to the caller to do proper locking and attach it to task.
 */</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">nsproxy</span> <span class="token operator">*</span><span class="token function">create_new_namespaces</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">,</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">user_namespace</span> <span class="token operator">*</span>user_ns<span class="token punctuation">,</span>
    <span class="token keyword">struct</span> <span class="token class-name">fs_struct</span> <span class="token operator">*</span>new_fs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">nsproxy</span> <span class="token operator">*</span>new_nsp<span class="token punctuation">;</span>

    new_nsp <span class="token operator">=</span> <span class="token function">create_nsproxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    new_nsp<span class="token operator">-&gt;</span>mnt_ns <span class="token operator">=</span> <span class="token function">copy_mnt_ns</span><span class="token punctuation">(</span>flags<span class="token punctuation">,</span> tsk<span class="token operator">-&gt;</span>nsproxy<span class="token operator">-&gt;</span>mnt_ns<span class="token punctuation">,</span> user_ns<span class="token punctuation">,</span> new_fs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    new_nsp<span class="token operator">-&gt;</span>uts_ns <span class="token operator">=</span> <span class="token function">copy_utsname</span><span class="token punctuation">(</span>flags<span class="token punctuation">,</span> user_ns<span class="token punctuation">,</span> tsk<span class="token operator">-&gt;</span>nsproxy<span class="token operator">-&gt;</span>uts_ns<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    new_nsp<span class="token operator">-&gt;</span>ipc_ns <span class="token operator">=</span> <span class="token function">copy_ipcs</span><span class="token punctuation">(</span>flags<span class="token punctuation">,</span> user_ns<span class="token punctuation">,</span> tsk<span class="token operator">-&gt;</span>nsproxy<span class="token operator">-&gt;</span>ipc_ns<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    new_nsp<span class="token operator">-&gt;</span>pid_ns_for_children <span class="token operator">=</span>
        <span class="token function">copy_pid_ns</span><span class="token punctuation">(</span>flags<span class="token punctuation">,</span> user_ns<span class="token punctuation">,</span> tsk<span class="token operator">-&gt;</span>nsproxy<span class="token operator">-&gt;</span>pid_ns_for_children<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    new_nsp<span class="token operator">-&gt;</span>cgroup_ns <span class="token operator">=</span> <span class="token function">copy_cgroup_ns</span><span class="token punctuation">(</span>flags<span class="token punctuation">,</span> user_ns<span class="token punctuation">,</span>
                        tsk<span class="token operator">-&gt;</span>nsproxy<span class="token operator">-&gt;</span>cgroup_ns<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    new_nsp<span class="token operator">-&gt;</span>net_ns <span class="token operator">=</span> <span class="token function">copy_net_ns</span><span class="token punctuation">(</span>flags<span class="token punctuation">,</span> user_ns<span class="token punctuation">,</span> tsk<span class="token operator">-&gt;</span>nsproxy<span class="token operator">-&gt;</span>net_ns<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> new_nsp<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在create_new_namespaces中，我们可以看到对于各种namespace的复制。</p>
<p>我们来看copy_pid_ns对于pid namespace的复制。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">pid_namespace</span> <span class="token operator">*</span><span class="token function">copy_pid_ns</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">,</span>
    <span class="token keyword">struct</span> <span class="token class-name">user_namespace</span> <span class="token operator">*</span>user_ns<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">pid_namespace</span> <span class="token operator">*</span>old_ns<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> CLONE_NEWPID<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">get_pid_ns</span><span class="token punctuation">(</span>old_ns<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">task_active_pid_ns</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span> <span class="token operator">!=</span> old_ns<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">ERR_PTR</span><span class="token punctuation">(</span><span class="token operator">-</span>EINVAL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">create_pid_namespace</span><span class="token punctuation">(</span>user_ns<span class="token punctuation">,</span> old_ns<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在copy_pid_ns中，如果没有设置CLONE_NEWPID，则返回老的pid namespace；如果设置了，就调用create_pid_namespace，创建新的pid namespace.</p>
<p>我们再来看copy_net_ns对于network namespace的复制。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">net</span> <span class="token operator">*</span><span class="token function">copy_net_ns</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">,</span>
            <span class="token keyword">struct</span> <span class="token class-name">user_namespace</span> <span class="token operator">*</span>user_ns<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">net</span> <span class="token operator">*</span>old_net<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">ucounts</span> <span class="token operator">*</span>ucounts<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">net</span> <span class="token operator">*</span>net<span class="token punctuation">;</span>
    <span class="token keyword">int</span> rv<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> CLONE_NEWNET<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">get_net</span><span class="token punctuation">(</span>old_net<span class="token punctuation">)</span><span class="token punctuation">;</span>

    ucounts <span class="token operator">=</span> <span class="token function">inc_net_namespaces</span><span class="token punctuation">(</span>user_ns<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    net <span class="token operator">=</span> <span class="token function">net_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">get_user_ns</span><span class="token punctuation">(</span>user_ns<span class="token punctuation">)</span><span class="token punctuation">;</span>
    net<span class="token operator">-&gt;</span>ucounts <span class="token operator">=</span> ucounts<span class="token punctuation">;</span>
    rv <span class="token operator">=</span> <span class="token function">setup_net</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> user_ns<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> net<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里面，我们需要判断，如果flags中不包含CLONE_NEWNET，也就是不会创建一个新的network namespace，则返回old_net；否则需要新建一个network namespace。</p>
<p>然后，copy_net_ns会调用net = net_alloc()，分配一个新的struct net结构，然后调用setup_net对新分配的net结构进行初始化，之后调用list_add_tail_rcu，将新建的network namespace，添加到全局的network namespace列表net_namespace_list中。</p>
<p>我们来看一下setup_net的实现。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * setup_net runs the initializers for the network namespace object.
 */</span>
<span class="token keyword">static</span> __net_init <span class="token keyword">int</span> <span class="token function">setup_net</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">net</span> <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">user_namespace</span> <span class="token operator">*</span>user_ns<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">/* Must be called with net_mutex held */</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">pernet_operations</span> <span class="token operator">*</span>ops<span class="token punctuation">,</span> <span class="token operator">*</span>saved_ops<span class="token punctuation">;</span>
    <span class="token function">LIST_HEAD</span><span class="token punctuation">(</span>net_exit_list<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">atomic_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>net<span class="token operator">-&gt;</span>count<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">refcount_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>net<span class="token operator">-&gt;</span>passive<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    net<span class="token operator">-&gt;</span>dev_base_seq <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    net<span class="token operator">-&gt;</span>user_ns <span class="token operator">=</span> user_ns<span class="token punctuation">;</span>
    <span class="token function">idr_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>net<span class="token operator">-&gt;</span>netns_ids<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">spin_lock_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>net<span class="token operator">-&gt;</span>nsid_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">list_for_each_entry</span><span class="token punctuation">(</span>ops<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pernet_list<span class="token punctuation">,</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        error <span class="token operator">=</span> <span class="token function">ops_init</span><span class="token punctuation">(</span>ops<span class="token punctuation">,</span> net<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在setup_net中，这里面有一个循环list_for_each_entry，对于pernet_list的每一项struct pernet_operations，运行ops_init，也就是调用pernet_operations的init函数。</p>
<p>这个pernet_list是怎么来的呢？在网络设备初始化的时候，我们要调用net_dev_init函数，这里面有下面的代码。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">register_pernet_device</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loopback_net_ops<span class="token punctuation">)</span>

<span class="token keyword">int</span> <span class="token function">register_pernet_device</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pernet_operations</span> <span class="token operator">*</span>ops<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> error<span class="token punctuation">;</span>
    <span class="token function">mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>net_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    error <span class="token operator">=</span> <span class="token function">register_pernet_operations</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pernet_list<span class="token punctuation">,</span> ops<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>error <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>first_device <span class="token operator">==</span> <span class="token operator">&amp;</span>pernet_list<span class="token punctuation">)</span><span class="token punctuation">)</span>
        first_device <span class="token operator">=</span> <span class="token operator">&amp;</span>ops<span class="token operator">-&gt;</span>list<span class="token punctuation">;</span>
    <span class="token function">mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>net_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> error<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">pernet_operations</span> __net_initdata loopback_net_ops <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span>init <span class="token operator">=</span> loopback_net_init<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>register_pernet_device函数注册了一个loopback_net_ops，在这里面，把init函数设置为loopback_net_init.</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> __net_init <span class="token keyword">int</span> <span class="token function">loopback_net_init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">net</span> <span class="token operator">*</span>net<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">net_device</span> <span class="token operator">*</span>dev<span class="token punctuation">;</span>
    dev <span class="token operator">=</span> <span class="token function">alloc_netdev</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"lo"</span><span class="token punctuation">,</span> NET_NAME_UNKNOWN<span class="token punctuation">,</span> loopback_setup<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">dev_net_set</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> net<span class="token punctuation">)</span><span class="token punctuation">;</span>
    err <span class="token operator">=</span> <span class="token function">register_netdev</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    net<span class="token operator">-&gt;</span>loopback_dev <span class="token operator">=</span> dev<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在loopback_net_init函数中，我们会创建并且注册一个名字为”lo”的struct net_device。注册完之后，在这个namespace里面就会出现一个这样的网络设备，称为loopback网络设备。</p>
<p>这就是为什么上面的实验中，创建出的新的network namespace里面有一个lo网络设备。</p>
<h4 id="51-1-总结"><a href="#51-1-总结" class="headerlink" title="51.1 总结"></a>51.1 总结</h4><p>这一节我们讲了namespace相关的技术，有六种类型，分别是UTS、User、Mount、Pid、Network和IPC。</p>
<p>还有两个常用的命令nsenter和unshare，主要用于操作Namespace，有三个常用的函数clone、setns和unshare。</p>
<p>在内核里面，对于任何一个进程task_struct来讲，里面都会有一个成员struct nsproxy，用于保存namespace相关信息，里面有 struct uts_namespace、struct ipc_namespace、struct mnt_namespace、struct pid_namespace、struct net <em>net_ns和struct cgroup_namespace </em>cgroup_ns。</p>
<p>创建namespace的时候，我们在内核中会调用copy_namespaces，调用顺序依次是copy_mnt_ns、copy_utsname、copy_ipcs、copy_pid_ns、copy_cgroup_ns和copy_net_ns，来复制namespace。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/容器的namespace技术思维导图.png" alt="容器的namespace技术思维导图.png"></p>
<h3 id="52-CGroup技术"><a href="#52-CGroup技术" class="headerlink" title="52. CGroup技术"></a>52. CGroup技术</h3><p>我们前面说了，容器实现封闭的环境主要要靠两种技术，一种是“看起来是隔离”的技术Namespace，另一种是用起来是隔离的技术CGroup。</p>
<p>上一节我们讲了“看起来隔离“的技术Namespace，这一节我们就来看一下“用起来隔离“的技术CGroup。</p>
<p>CGroup全称是Control Group，顾名思义，它是用来做“控制”的。控制什么东西呢？当然是资源的使用了。那它都能控制哪些资源的使用呢？我们一起来看一看。</p>
<p>首先，cgroups定义了下面的一系列子系统，每个子系统用于控制某一类资源。</p>
<ul>
<li>cpu子系统，主要限制进程的cpu使用率。</li>
<li>cpuacct 子系统，可以统计 cgroups 中的进程的 cpu 使用报告。</li>
<li>cpuset 子系统，可以为 cgroups 中的进程分配单独的 cpu 节点或者内存节点。</li>
<li>memory 子系统，可以限制进程的 memory 使用量。</li>
<li>blkio 子系统，可以限制进程的块设备 io。</li>
<li>devices 子系统，可以控制进程能够访问某些设备。</li>
<li>net_cls 子系统，可以标记 cgroups 中进程的网络数据包，然后可以使用 tc 模块（traffic control）对数据包进行控制。</li>
<li>freezer 子系统，可以挂起或者恢复 cgroups 中的进程。</li>
</ul>
<p>这么多子系统，你可能要说了，那我们不用都掌握吧？没错，这里面最常用的是对于CPU和内存的控制，所以下面我们详细来说它。</p>
<p>在容器这一章的第一节，我们讲了，Docker有一些参数能够限制CPU和内存的使用，如果把它落地到Cgroup里面会如何限制呢？</p>
<p>为了验证Docker的参数与Cgroup的映射关系，我们运行一个命令特殊的docker run命令，这个命令比较长，里面的参数都会映射为cgroup的某项配置，然后我们运行docker ps，可以看到，这个容器的id为3dc0601189dd。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run -d --cpu-shares <span class="token number">513</span> --cpus <span class="token number">2</span> --cpuset-cpus <span class="token number">1,3</span> --memory 1024M --memory-swap 1234M --memory-swappiness <span class="token number">7</span> -p <span class="token number">8081</span>:80 testnginx:1

$ docker <span class="token function">ps</span>
CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                  NAMES
3dc0601189dd        testnginx:1         <span class="token string">"/bin/sh -c 'nginx -…"</span>   About a minute ago   Up About a minute   <span class="token number">0.0</span>.0.0:8081-<span class="token operator">&gt;</span><span class="token number">80</span>/tcp   boring_cohen<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在Linux上，为了操作Cgroup，有一个专门的Cgroup文件系统，我们运行mount命令可以查看。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">mount</span> -t cgroup
cgroup on /sys/fs/cgroup/systemd <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,xattr,release_agent<span class="token operator">=</span>/usr/lib/systemd/systemd-cgroups-agent,name<span class="token operator">=</span>systemd<span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/net_cls,net_prio <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,net_prio,net_cls<span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/perf_event <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,perf_event<span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/devices <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,devices<span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/blkio <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,blkio<span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/cpu,cpuacct <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,cpuacct,cpu<span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/memory <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,memory<span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/cpuset <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,cpuset<span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/hugetlb <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,hugetlb<span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/freezer <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,freezer<span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/pids <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,pids<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>cgroup文件系统多挂载到/sys/fs/cgroup下，通过上面的命令行，我们可以看到我们可以用cgroup控制哪些资源。</p>
<p>对于CPU的控制，我在这一章的第一节讲过，Docker可以控制cpu-shares、cpus和cpuset。</p>
<p>我们在/sys/fs/cgroup/下面能看到下面的目录结构。</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">drwxr-xr-x 5 root root  0 May 30 17:00 blkio
lrwxrwxrwx 1 root root 11 May 30 17:00 cpu -&gt; cpu,cpuacct
lrwxrwxrwx 1 root root 11 May 30 17:00 cpuacct -&gt; cpu,cpuacct
drwxr-xr-x 5 root root  0 May 30 17:00 cpu,cpuacct
drwxr-xr-x 3 root root  0 May 30 17:00 cpuset
drwxr-xr-x 5 root root  0 May 30 17:00 devices
drwxr-xr-x 3 root root  0 May 30 17:00 freezer
drwxr-xr-x 3 root root  0 May 30 17:00 hugetlb
drwxr-xr-x 5 root root  0 May 30 17:00 memory
lrwxrwxrwx 1 root root 16 May 30 17:00 net_cls -&gt; net_cls,net_prio
drwxr-xr-x 3 root root  0 May 30 17:00 net_cls,net_prio
lrwxrwxrwx 1 root root 16 May 30 17:00 net_prio -&gt; net_cls,net_prio
drwxr-xr-x 3 root root  0 May 30 17:00 perf_event
drwxr-xr-x 5 root root  0 May 30 17:00 pids
drwxr-xr-x 5 root root  0 May 30 17:00 systemd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们可以想象，CPU的资源控制的配置文件，应该在cpu,cpuacct这个文件夹下面。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span>
cgroup.clone_children  cpu.cfs_period_us  notify_on_release
cgroup.event_control   cpu.cfs_quota_us   release_agent
cgroup.procs           cpu.rt_period_us   system.slice
cgroup.sane_behavior   cpu.rt_runtime_us  tasks
cpuacct.stat           cpu.shares         user.slice
cpuacct.usage          cpu.stat
cpuacct.usage_percpu   docker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>果真，这下面是对cpu的相关控制，里面还有一个路径叫docker。我们进入这个路径。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span>
cgroup.clone_children
cgroup.event_control
cgroup.procs
cpuacct.stat
cpuacct.usage
cpuacct.usage_percpu
cpu.cfs_period_us
cpu.cfs_quota_us
cpu.rt_period_us
cpu.rt_runtime_us
cpu.shares
cpu.stat
3dc0601189dd218898f31f9526a6cfae83913763a4da59f95ec789c6e030ecfd
notify_on_release
tasks<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面有个很长的id，是我们创建的docker的id。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>3dc0601189dd218898f31f9526a6cfae83913763a4da59f95ec789c6e030ecfd<span class="token punctuation">]</span>$ <span class="token function">ls</span>
cgroup.clone_children  cpuacct.usage_percpu  cpu.shares
cgroup.event_control   cpu.cfs_period_us     cpu.stat
cgroup.procs           cpu.cfs_quota_us      notify_on_release
cpuacct.stat           cpu.rt_period_us      tasks
cpuacct.usage          cpu.rt_runtime_us<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里，我们能看到cpu.shares，还有一个重要的文件tasks。这里面是这个容器里所有进程的进程号，也即所有这些进程都被这些cpu策略控制。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>3dc0601189dd218898f31f9526a6cfae83913763a4da59f95ec789c6e030ecfd<span class="token punctuation">]</span>$ <span class="token function">cat</span> tasks
<span class="token number">39487</span>
<span class="token number">39520</span>
<span class="token number">39526</span>
<span class="token number">39527</span>
<span class="token number">39528</span>
<span class="token number">39529</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果我们查看cpu.shares，里面就是我们设置的513。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>3dc0601189dd218898f31f9526a6cfae83913763a4da59f95ec789c6e030ecfd<span class="token punctuation">]</span>$ <span class="token function">cat</span> cpu.shares
<span class="token number">513</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>另外，我们还配置了cpus，这个值其实是由cpu.cfs_period_us和cpu.cfs_quota_us共同决定的。cpu.cfs_period_us是运行周期，cpu.cfs_quota_us是在周期内这些进程占用多少时间。我们设置了cpus为2，代表的意思是，在周期100000毫秒的运行周期内，这些进程要占用200000毫秒的时间，也即需要两个CPU同时运行一个整整的周期。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>3dc0601189dd218898f31f9526a6cfae83913763a4da59f95ec789c6e030ecfd<span class="token punctuation">]</span>$ <span class="token function">cat</span> cpu.cfs_period_us
<span class="token number">100000</span>
<span class="token punctuation">[</span>3dc0601189dd218898f31f9526a6cfae83913763a4da59f95ec789c6e030ecfd<span class="token punctuation">]</span>$ <span class="token function">cat</span> cpu.cfs_quota_us
<span class="token number">200000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于cpuset，也即cpu绑核的参数，在另外一个文件夹里面/sys/fs/cgroup/cpuset，这里面同样有一个docker文件夹，下面同样有docker id 也即3dc0601189dd218898f31f9526a6cfae83913763a4da59f95ec789c6e030ecfd文件夹，这里面的cpuset.cpus就是配置的绑定到1、3两个核。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>3dc0601189dd218898f31f9526a6cfae83913763a4da59f95ec789c6e030ecfd<span class="token punctuation">]</span>$ <span class="token function">cat</span> cpuset.cpus
<span class="token number">1,3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这一章的第一节我们还讲了Docker可以限制内存的使用量，例如memory、memory-swap、memory-swappiness。这些在哪里控制呢？</p>
<p>/sys/fs/cgroup/下面还有一个memory路径，控制策略就是在这里面定义的。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@deployer memory<span class="token punctuation">]</span>$ <span class="token function">ls</span>
cgroup.clone_children               memory.memsw.failcnt
cgroup.event_control                memory.memsw.limit_in_bytes
cgroup.procs                        memory.memsw.max_usage_in_bytes
cgroup.sane_behavior                memory.memsw.usage_in_bytes
docker                              memory.move_charge_at_immigrate
memory.failcnt                      memory.numa_stat
memory.force_empty                  memory.oom_control
memory.kmem.failcnt                 memory.pressure_level
memory.kmem.limit_in_bytes          memory.soft_limit_in_bytes
memory.kmem.max_usage_in_bytes      memory.stat
memory.kmem.slabinfo                memory.swappiness
memory.kmem.tcp.failcnt             memory.usage_in_bytes
memory.kmem.tcp.limit_in_bytes      memory.use_hierarchy
memory.kmem.tcp.max_usage_in_bytes  notify_on_release
memory.kmem.tcp.usage_in_bytes      release_agent
memory.kmem.usage_in_bytes          system.slice
memory.limit_in_bytes               tasks
memory.max_usage_in_bytes           user.slice<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面全是对于memory的控制参数，在这里面我们可看到了docker，里面还有容器的id作为文件夹。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>docker<span class="token punctuation">]</span>$ <span class="token function">ls</span>
3dc0601189dd218898f31f9526a6cfae83913763a4da59f95ec789c6e030ecfd
cgroup.clone_children
cgroup.event_control
cgroup.procs
memory.failcnt
memory.force_empty
memory.kmem.failcnt
memory.kmem.limit_in_bytes
memory.kmem.max_usage_in_bytes
memory.kmem.slabinfo
memory.kmem.tcp.failcnt
memory.kmem.tcp.limit_in_bytes
memory.kmem.tcp.max_usage_in_bytes
memory.kmem.tcp.usage_in_bytes
memory.kmem.usage_in_bytes
memory.limit_in_bytes
memory.max_usage_in_bytes
memory.memsw.failcnt
memory.memsw.limit_in_bytes
memory.memsw.max_usage_in_bytes
memory.memsw.usage_in_bytes
memory.move_charge_at_immigrate
memory.numa_stat
memory.oom_control
memory.pressure_level
memory.soft_limit_in_bytes
memory.stat
memory.swappiness
memory.usage_in_bytes
memory.use_hierarchy
notify_on_release
tasks

<span class="token punctuation">[</span>3dc0601189dd218898f31f9526a6cfae83913763a4da59f95ec789c6e030ecfd<span class="token punctuation">]</span>$ <span class="token function">ls</span>
cgroup.clone_children               memory.memsw.failcnt
cgroup.event_control                memory.memsw.limit_in_bytes
cgroup.procs                        memory.memsw.max_usage_in_bytes
memory.failcnt                      memory.memsw.usage_in_bytes
memory.force_empty                  memory.move_charge_at_immigrate
memory.kmem.failcnt                 memory.numa_stat
memory.kmem.limit_in_bytes          memory.oom_control
memory.kmem.max_usage_in_bytes      memory.pressure_level
memory.kmem.slabinfo                memory.soft_limit_in_bytes
memory.kmem.tcp.failcnt             memory.stat
memory.kmem.tcp.limit_in_bytes      memory.swappiness
memory.kmem.tcp.max_usage_in_bytes  memory.usage_in_bytes
memory.kmem.tcp.usage_in_bytes      memory.use_hierarchy
memory.kmem.usage_in_bytes          notify_on_release
memory.limit_in_bytes               tasks
memory.max_usage_in_bytes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在docker id的文件夹下面，有一个memory.limit_in_bytes，里面配置的就是memory。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>3dc0601189dd218898f31f9526a6cfae83913763a4da59f95ec789c6e030ecfd<span class="token punctuation">]</span>$ <span class="token function">cat</span> memory.limit_in_bytes
<span class="token number">1073741824</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>还有memory.swappiness，里面配置的就是memory-swappiness。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>3dc0601189dd218898f31f9526a6cfae83913763a4da59f95ec789c6e030ecfd<span class="token punctuation">]</span>$ <span class="token function">cat</span> memory.swappiness
<span class="token number">7</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>还有就是memory.memsw.limit_in_bytes，里面配置的是memory-swap。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>3dc0601189dd218898f31f9526a6cfae83913763a4da59f95ec789c6e030ecfd<span class="token punctuation">]</span>$ <span class="token function">cat</span> memory.memsw.limit_in_bytes
<span class="token number">1293942784</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>我们还可以看一下tasks文件的内容，tasks里面是容器里面所有进程的进程号。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>3dc0601189dd218898f31f9526a6cfae83913763a4da59f95ec789c6e030ecfd<span class="token punctuation">]</span>$ <span class="token function">cat</span> tasks
<span class="token number">39487</span>
<span class="token number">39520</span>
<span class="token number">39526</span>
<span class="token number">39527</span>
<span class="token number">39528</span>
<span class="token number">39529</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>至此，我们看到了cgroup对于Docker资源的控制，在用户态是如何表现的。我画了一张图总结一下。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/cgroup对docker资源的控制.png" alt="cgroup对docker资源的控制"></p>
<p>在内核中，cgroup是如何实现的呢？</p>
<p>首先，在系统初始化的时候，cgroup也会进行初始化，在start_kernel中，cgroup_init_early和cgroup_init都会进行初始化。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">asmlinkage __visible <span class="token keyword">void</span> __init <span class="token function">start_kernel</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token function">cgroup_init_early</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token function">cgroup_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在cgroup_init_early和cgroup_init中，会有下面的循环。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">or_each_subsys</span><span class="token punctuation">(</span>ss<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ss<span class="token operator">-&gt;</span>id <span class="token operator">=</span> i<span class="token punctuation">;</span>
    ss<span class="token operator">-&gt;</span>name <span class="token operator">=</span> cgroup_subsys_name<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">cgroup_init_subsys</span><span class="token punctuation">(</span>ss<span class="token punctuation">,</span> true<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">for_each_subsys</span><span class="token punctuation">(</span>ss<span class="token punctuation">,</span> ssid<span class="token punctuation">)</span>                           </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ssid<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>ssid<span class="token punctuation">)</span> <span class="token operator">&lt;</span> CGROUP_SUBSYS_COUNT <span class="token operator">&amp;&amp;</span>        </span><span class="token punctuation">\</span>
         <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ss<span class="token punctuation">)</span> <span class="token operator">=</span> cgroup_subsys<span class="token punctuation">[</span>ssid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">||</span> true<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>ssid<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>for_each_subsys会在cgroup_subsys数组中进行循环。这个cgroup_subsys数组是如何形成的呢？</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">SUBSYS</span><span class="token punctuation">(</span>_x<span class="token punctuation">)</span> <span class="token punctuation">[</span>_x </span><span class="token punctuation">##</span> <span class="token expression">_cgrp_id<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>_x </span><span class="token punctuation">##</span> <span class="token expression">_cgrp_subsys<span class="token punctuation">,</span></span></span>
<span class="token keyword">struct</span> <span class="token class-name">cgroup_subsys</span> <span class="token operator">*</span>cgroup_subsys<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/cgroup_subsys.h&gt;</span></span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">undef</span> <span class="token expression">SUBSYS</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>SUBSYS这个宏定义了这个cgroup_subsys数组，数组中的项定义在cgroup_subsys.h头文件中。例如，对于CPU和内存有下面的定义。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//cgroup_subsys.h</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">IS_ENABLED</span><span class="token punctuation">(</span>CONFIG_CPUSETS<span class="token punctuation">)</span></span></span>
<span class="token function">SUBSYS</span><span class="token punctuation">(</span>cpuset<span class="token punctuation">)</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">IS_ENABLED</span><span class="token punctuation">(</span>CONFIG_CGROUP_SCHED<span class="token punctuation">)</span></span></span>
<span class="token function">SUBSYS</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">IS_ENABLED</span><span class="token punctuation">(</span>CONFIG_CGROUP_CPUACCT<span class="token punctuation">)</span></span></span>
<span class="token function">SUBSYS</span><span class="token punctuation">(</span>cpuacct<span class="token punctuation">)</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">IS_ENABLED</span><span class="token punctuation">(</span>CONFIG_MEMCG<span class="token punctuation">)</span></span></span>
<span class="token function">SUBSYS</span><span class="token punctuation">(</span>memory<span class="token punctuation">)</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>根据SUBSYS的定义，SUBSYS(cpu)其实是[cpu_cgrp_id] = &amp;cpu_cgrp_subsys，而SUBSYS(memory)其实是[memory_cgrp_id] = &amp;memory_cgrp_subsys。</p>
<p>我们能够找到cpu_cgrp_subsys和memory_cgrp_subsys的定义。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">cpuset_cgrp_subsys
<span class="token keyword">struct</span> <span class="token class-name">cgroup_subsys</span> cpuset_cgrp_subsys <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>css_alloc      <span class="token operator">=</span> cpuset_css_alloc<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>css_online     <span class="token operator">=</span> cpuset_css_online<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>css_offline    <span class="token operator">=</span> cpuset_css_offline<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>css_free       <span class="token operator">=</span> cpuset_css_free<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>can_attach     <span class="token operator">=</span> cpuset_can_attach<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>cancel_attach  <span class="token operator">=</span> cpuset_cancel_attach<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>attach         <span class="token operator">=</span> cpuset_attach<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>post_attach    <span class="token operator">=</span> cpuset_post_attach<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>bind           <span class="token operator">=</span> cpuset_bind<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>fork           <span class="token operator">=</span> cpuset_fork<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>legacy_cftypes <span class="token operator">=</span> files<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>early_init     <span class="token operator">=</span> true<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

cpu_cgrp_subsys
<span class="token keyword">struct</span> <span class="token class-name">cgroup_subsys</span> cpu_cgrp_subsys <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>css_alloc      <span class="token operator">=</span> cpu_cgroup_css_alloc<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>css_online     <span class="token operator">=</span> cpu_cgroup_css_online<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>css_released   <span class="token operator">=</span> cpu_cgroup_css_released<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>css_free       <span class="token operator">=</span> cpu_cgroup_css_free<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>fork           <span class="token operator">=</span> cpu_cgroup_fork<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>can_attach     <span class="token operator">=</span> cpu_cgroup_can_attach<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>attach         <span class="token operator">=</span> cpu_cgroup_attach<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>legacy_cftypes <span class="token operator">=</span> cpu_files<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>early_init     <span class="token operator">=</span> true<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

memory_cgrp_subsys
<span class="token keyword">struct</span> <span class="token class-name">cgroup_subsys</span> memory_cgrp_subsys <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>css_alloc      <span class="token operator">=</span> mem_cgroup_css_alloc<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>css_online     <span class="token operator">=</span> mem_cgroup_css_online<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>css_offline    <span class="token operator">=</span> mem_cgroup_css_offline<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>css_released   <span class="token operator">=</span> mem_cgroup_css_released<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>css_free       <span class="token operator">=</span> mem_cgroup_css_free<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>css_reset      <span class="token operator">=</span> mem_cgroup_css_reset<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>can_attach     <span class="token operator">=</span> mem_cgroup_can_attach<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>cancel_attach  <span class="token operator">=</span> mem_cgroup_cancel_attach<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>post_attach    <span class="token operator">=</span> mem_cgroup_move_task<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>bind           <span class="token operator">=</span> mem_cgroup_bind<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>dfl_cftypes    <span class="token operator">=</span> memory_files<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>legacy_cftypes <span class="token operator">=</span> mem_cgroup_legacy_files<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>early_init     <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在for_each_subsys的循环里面，cgroup_subsys[]数组中的每一个cgroup_subsys，都会调用cgroup_init_subsys，对于cgroup_subsys对于初始化。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> __init <span class="token function">cgroup_init_subsys</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cgroup_subsys</span> <span class="token operator">*</span>ss<span class="token punctuation">,</span> bool early<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">cgroup_subsys_state</span> <span class="token operator">*</span>css<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">idr_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ss<span class="token operator">-&gt;</span>css_idr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ss<span class="token operator">-&gt;</span>cfts<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* Create the root cgroup state for this subsystem */</span>
    ss<span class="token operator">-&gt;</span>root <span class="token operator">=</span> <span class="token operator">&amp;</span>cgrp_dfl_root<span class="token punctuation">;</span>
    css <span class="token operator">=</span> ss<span class="token operator">-&gt;</span><span class="token function">css_alloc</span><span class="token punctuation">(</span><span class="token function">cgroup_css</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cgrp_dfl_root<span class="token punctuation">.</span>cgrp<span class="token punctuation">,</span> ss<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">init_and_link_css</span><span class="token punctuation">(</span>css<span class="token punctuation">,</span> ss<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cgrp_dfl_root<span class="token punctuation">.</span>cgrp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    css<span class="token operator">-&gt;</span>id <span class="token operator">=</span> <span class="token function">cgroup_idr_alloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ss<span class="token operator">-&gt;</span>css_idr<span class="token punctuation">,</span> css<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    init_css_set<span class="token punctuation">.</span>subsys<span class="token punctuation">[</span>ss<span class="token operator">-&gt;</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> css<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">BUG_ON</span><span class="token punctuation">(</span><span class="token function">online_css</span><span class="token punctuation">(</span>css<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>cgroup_init_subsys里面会做两件事情，一个是调用cgroup_subsys的css_alloc函数创建一个cgroup_subsys_state；另外就是调用online_css，也即调用cgroup_subsys的css_online函数，激活这个cgroup。</p>
<p>对于CPU来讲，css_alloc函数就是cpu_cgroup_css_alloc。这里面会调用 sched_create_group创建一个struct task_group。在这个结构中，第一项就是cgroup_subsys_state，也就是说，task_group是cgroup_subsys_state的一个扩展，最终返回的是指向cgroup_subsys_state结构的指针，可以通过强制类型转换变为task_group。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">task_group</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">cgroup_subsys_state</span> css<span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_FAIR_GROUP_SCHED</span></span>
    <span class="token comment">/* schedulable entities of this group on each cpu */</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span><span class="token operator">*</span>se<span class="token punctuation">;</span>
    <span class="token comment">/* runqueue "owned" by this group on each cpu */</span>
    <span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span><span class="token operator">*</span>cfs_rq<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> shares<span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span>  <span class="token expression">CONFIG_SMP</span></span>
    atomic_long_t load_avg ____cacheline_aligned<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

    <span class="token keyword">struct</span> <span class="token class-name">rcu_head</span> rcu<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> list<span class="token punctuation">;</span>

    <span class="token keyword">struct</span> <span class="token class-name">task_group</span> <span class="token operator">*</span>parent<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> siblings<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> children<span class="token punctuation">;</span>

    <span class="token keyword">struct</span> <span class="token class-name">cfs_bandwidth</span> cfs_bandwidth<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在task_group结构中，有一个成员是sched_entity，前面我们讲进程调度的时候，遇到过它。它是调度的实体，也即这一个task_group也是一个调度实体。</p>
<p>接下来，online_css会被调用。对于CPU来讲，online_css调用的是cpu_cgroup_css_online。它会调用sched_online_group-&gt;online_fair_sched_group。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">online_fair_sched_group</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_group</span> <span class="token operator">*</span>tg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>

    <span class="token function">for_each_possible_cpu</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        rq <span class="token operator">=</span> <span class="token function">cpu_rq</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        se <span class="token operator">=</span> tg<span class="token operator">-&gt;</span>se<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token function">update_rq_clock</span><span class="token punctuation">(</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">attach_entity_cfs_rq</span><span class="token punctuation">(</span>se<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sync_throttle</span><span class="token punctuation">(</span>tg<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里面，对于每一个CPU，取出每个CPU的运行队列rq，也取出task_group的sched_entity，然后通过attach_entity_cfs_rq将sched_entity添加到运行队列中。</p>
<p>对于内存来讲，css_alloc函数就是mem_cgroup_css_alloc。这里面会调用 mem_cgroup_alloc，创建一个struct mem_cgroup。在这个结构中，第一项就是cgroup_subsys_state，也就是说，mem_cgroup是cgroup_subsys_state的一个扩展，最终返回的是指向cgroup_subsys_state结构的指针，我们可以通过强制类型转换变为mem_cgroup。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">mem_cgroup</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">cgroup_subsys_state</span> css<span class="token punctuation">;</span>

    <span class="token comment">/* Private memcg ID. Used to ID objects that outlive the cgroup */</span>
    <span class="token keyword">struct</span> <span class="token class-name">mem_cgroup_id</span> id<span class="token punctuation">;</span>

    <span class="token comment">/* Accounted resources */</span>
    <span class="token keyword">struct</span> <span class="token class-name">page_counter</span> memory<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">page_counter</span> swap<span class="token punctuation">;</span>

    <span class="token comment">/* Legacy consumer-oriented counters */</span>
    <span class="token keyword">struct</span> <span class="token class-name">page_counter</span> memsw<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">page_counter</span> kmem<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">page_counter</span> tcpmem<span class="token punctuation">;</span>

    <span class="token comment">/* Normal memory consumption range */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> low<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> high<span class="token punctuation">;</span>

    <span class="token comment">/* Range enforcement for interrupt charges */</span>
    <span class="token keyword">struct</span> <span class="token class-name">work_struct</span> high_work<span class="token punctuation">;</span>

    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> soft_limit<span class="token punctuation">;</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">int</span> swappiness<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/*
     * percpu counter.
     */</span>
    <span class="token keyword">struct</span> <span class="token class-name">mem_cgroup_stat_cpu</span> __percpu <span class="token operator">*</span>stat<span class="token punctuation">;</span>

    <span class="token keyword">int</span> last_scanned_node<span class="token punctuation">;</span>

    <span class="token comment">/* List of events which userspace want to receive */</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> event_list<span class="token punctuation">;</span>
    spinlock_t event_list_lock<span class="token punctuation">;</span>

    <span class="token keyword">struct</span> <span class="token class-name">mem_cgroup_per_node</span> <span class="token operator">*</span>nodeinfo<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">/* WARNING: nodeinfo must be the last member here */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在cgroup_init函数中，cgroup的初始化还做了一件很重要的事情，它会调用cgroup_init_cftypes(NULL, cgroup1_base_files)，来初始化对于cgroup文件类型cftype的操作函数，也就是将struct kernfs_ops *kf_ops设置为cgroup_kf_ops。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">cftype</span> cgroup1_base_files<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">{</span>
        <span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"tasks"</span><span class="token punctuation">,</span>
        <span class="token punctuation">.</span>seq_start <span class="token operator">=</span> cgroup_pidlist_start<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>seq_next <span class="token operator">=</span> cgroup_pidlist_next<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>seq_stop <span class="token operator">=</span> cgroup_pidlist_stop<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>seq_show <span class="token operator">=</span> cgroup_pidlist_show<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>private <span class="token operator">=</span> CGROUP_FILE_TASKS<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>write <span class="token operator">=</span> cgroup_tasks_write<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">kernfs_ops</span> cgroup_kf_ops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>atomic_write_len   <span class="token operator">=</span> PAGE_SIZE<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>open           <span class="token operator">=</span> cgroup_file_open<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>release        <span class="token operator">=</span> cgroup_file_release<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>write          <span class="token operator">=</span> cgroup_file_write<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>seq_start      <span class="token operator">=</span> cgroup_seqfile_start<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>seq_next       <span class="token operator">=</span> cgroup_seqfile_next<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>seq_stop       <span class="token operator">=</span> cgroup_seqfile_stop<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>seq_show       <span class="token operator">=</span> cgroup_seqfile_show<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在cgroup初始化完毕之后，接下来就是创建一个cgroup的文件系统，用了配置和操作cgroup。</p>
<p>cgroup是一种特殊的文件系统。它的定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">file_system_type</span> cgroup_fs_type <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"cgroup"</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>mount <span class="token operator">=</span> cgroup_mount<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>kill_sb <span class="token operator">=</span> cgroup_kill_sb<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>fs_flags <span class="token operator">=</span> FS_USERNS_MOUNT<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当我们mount这个cgroup文件系统的时候，会调用cgroup_mount-&gt;cgroup1_mount。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token function">cgroup1_mount</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file_system_type</span> <span class="token operator">*</span>fs_type<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span>
                 <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> magic<span class="token punctuation">,</span>
                 <span class="token keyword">struct</span> <span class="token class-name">cgroup_namespace</span> <span class="token operator">*</span>ns<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span>pinned_sb <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">cgroup_sb_opts</span> opts<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">cgroup_root</span> <span class="token operator">*</span>root<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">cgroup_subsys</span> <span class="token operator">*</span>ss<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span>dentry<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> ret<span class="token punctuation">;</span>
    bool new_root <span class="token operator">=</span> false<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    root <span class="token operator">=</span> <span class="token function">kzalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    new_root <span class="token operator">=</span> true<span class="token punctuation">;</span>

    <span class="token function">init_cgroup_root</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token operator">&amp;</span>opts<span class="token punctuation">)</span><span class="token punctuation">;</span>

    ret <span class="token operator">=</span> <span class="token function">cgroup_setup_root</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>subsys_mask<span class="token punctuation">,</span> PERCPU_REF_INIT_DEAD<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    dentry <span class="token operator">=</span> <span class="token function">cgroup_do_mount</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cgroup_fs_type<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> root<span class="token punctuation">,</span>
                 CGROUP_SUPER_MAGIC<span class="token punctuation">,</span> ns<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> dentry<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>cgroup被组织成为树形结构，因而有cgroup_root。init_cgroup_root会初始化这个cgroup_root。cgroup_root是cgroup的根，它有一个成员kf_root，是cgroup文件系统的根struct kernfs_root。kernfs_create_root就是用来创建这个kernfs_root结构的。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">cgroup_setup_root</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cgroup_root</span> <span class="token operator">*</span>root<span class="token punctuation">,</span> u16 ss_mask<span class="token punctuation">,</span> <span class="token keyword">int</span> ref_flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">LIST_HEAD</span><span class="token punctuation">(</span>tmp_links<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">cgroup</span> <span class="token operator">*</span>root_cgrp <span class="token operator">=</span> <span class="token operator">&amp;</span>root<span class="token operator">-&gt;</span>cgrp<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">kernfs_syscall_ops</span> <span class="token operator">*</span>kf_sops<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">css_set</span> <span class="token operator">*</span>cset<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> ret<span class="token punctuation">;</span>

    root<span class="token operator">-&gt;</span>kf_root <span class="token operator">=</span> <span class="token function">kernfs_create_root</span><span class="token punctuation">(</span>kf_sops<span class="token punctuation">,</span>
                       KERNFS_ROOT_CREATE_DEACTIVATED<span class="token punctuation">,</span>
                       root_cgrp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    root_cgrp<span class="token operator">-&gt;</span>kn <span class="token operator">=</span> root<span class="token operator">-&gt;</span>kf_root<span class="token operator">-&gt;</span>kn<span class="token punctuation">;</span>

    ret <span class="token operator">=</span> <span class="token function">css_populate_dir</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>root_cgrp<span class="token operator">-&gt;</span>self<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ret <span class="token operator">=</span> <span class="token function">rebind_subsystems</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> ss_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">list_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>root<span class="token operator">-&gt;</span>root_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cgroup_roots<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cgroup_root_count<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">kernfs_activate</span><span class="token punctuation">(</span>root_cgrp<span class="token operator">-&gt;</span>kn<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>就像在普通文件系统上，每一个文件都对应一个inode，在cgroup文件系统上，每个文件都对应一个struct kernfs_node结构，当然kernfs_root作为文件系的根也对应一个kernfs_node结构。</p>
<p>接下来，css_populate_dir会调用cgroup_addrm_files-&gt;cgroup_add_file-&gt;cgroup_add_file，来创建整棵文件树，并且为树中的每个文件创建对应的kernfs_node结构，并将这个文件的操作函数设置为kf_ops，也即指向cgroup_kf_ops 。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">cgroup_add_file</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cgroup_subsys_state</span> <span class="token operator">*</span>css<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">cgroup</span> <span class="token operator">*</span>cgrp<span class="token punctuation">,</span>
               <span class="token keyword">struct</span> <span class="token class-name">cftype</span> <span class="token operator">*</span>cft<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> name<span class="token punctuation">[</span>CGROUP_FILE_NAME_MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">kernfs_node</span> <span class="token operator">*</span>kn<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    kn <span class="token operator">=</span> <span class="token function">__kernfs_create_file</span><span class="token punctuation">(</span>cgrp<span class="token operator">-&gt;</span>kn<span class="token punctuation">,</span> <span class="token function">cgroup_file_name</span><span class="token punctuation">(</span>cgrp<span class="token punctuation">,</span> cft<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">,</span>
                  <span class="token function">cgroup_file_mode</span><span class="token punctuation">(</span>cft<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> cft<span class="token operator">-&gt;</span>kf_ops<span class="token punctuation">,</span> cft<span class="token punctuation">,</span>
                  <span class="token constant">NULL</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">kernfs_node</span> <span class="token operator">*</span><span class="token function">__kernfs_create_file</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kernfs_node</span> <span class="token operator">*</span>parent<span class="token punctuation">,</span>
                     <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span>
                     umode_t mode<span class="token punctuation">,</span> loff_t size<span class="token punctuation">,</span>
                     <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">kernfs_ops</span> <span class="token operator">*</span>ops<span class="token punctuation">,</span>
                     <span class="token keyword">void</span> <span class="token operator">*</span>priv<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>ns<span class="token punctuation">,</span>
                     <span class="token keyword">struct</span> <span class="token class-name">lock_class_key</span> <span class="token operator">*</span>key<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">kernfs_node</span> <span class="token operator">*</span>kn<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> flags<span class="token punctuation">;</span>
    <span class="token keyword">int</span> rc<span class="token punctuation">;</span>

    flags <span class="token operator">=</span> KERNFS_FILE<span class="token punctuation">;</span>

    kn <span class="token operator">=</span> <span class="token function">kernfs_new_node</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token punctuation">(</span>mode <span class="token operator">&amp;</span> S_IALLUGO<span class="token punctuation">)</span> <span class="token operator">|</span> S_IFREG<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>

    kn<span class="token operator">-&gt;</span>attr<span class="token punctuation">.</span>ops <span class="token operator">=</span> ops<span class="token punctuation">;</span>
    kn<span class="token operator">-&gt;</span>attr<span class="token punctuation">.</span>size <span class="token operator">=</span> size<span class="token punctuation">;</span>
    kn<span class="token operator">-&gt;</span>ns <span class="token operator">=</span> ns<span class="token punctuation">;</span>
    kn<span class="token operator">-&gt;</span>priv <span class="token operator">=</span> priv<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    rc <span class="token operator">=</span> <span class="token function">kernfs_add_one</span><span class="token punctuation">(</span>kn<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> kn<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从cgroup_setup_root返回后，接下来，在cgroup1_mount中，要做的一件事情是cgroup_do_mount，调用kernfs_mount真的去mount这个文件系统，返回一个普通的文件系统都认识的dentry。这种特殊的文件系统对应的文件操作函数为kernfs_file_fops。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> kernfs_file_fops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>read       <span class="token operator">=</span> kernfs_fop_read<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>write      <span class="token operator">=</span> kernfs_fop_write<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>llseek     <span class="token operator">=</span> generic_file_llseek<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>mmap       <span class="token operator">=</span> kernfs_fop_mmap<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>open       <span class="token operator">=</span> kernfs_fop_open<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>release    <span class="token operator">=</span> kernfs_fop_release<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>poll       <span class="token operator">=</span> kernfs_fop_poll<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>fsync      <span class="token operator">=</span> noop_fsync<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当我们要写入一个CGroup文件来设置参数的时候，根据文件系统的操作，kernfs_fop_write会被调用，在这里面会调用kernfs_ops的write函数，根据上面的定义为cgroup_file_write，在这里会调用cftype的write函数。对于CPU和内存的write函数，有以下不同的定义。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">cftype</span> cpu_files<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_FAIR_GROUP_SCHED</span></span>
    <span class="token punctuation">{</span>
        <span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"shares"</span><span class="token punctuation">,</span>
        <span class="token punctuation">.</span>read_u64 <span class="token operator">=</span> cpu_shares_read_u64<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>write_u64 <span class="token operator">=</span> cpu_shares_write_u64<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_CFS_BANDWIDTH</span></span>
    <span class="token punctuation">{</span>
        <span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"cfs_quota_us"</span><span class="token punctuation">,</span>
        <span class="token punctuation">.</span>read_s64 <span class="token operator">=</span> cpu_cfs_quota_read_s64<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>write_s64 <span class="token operator">=</span> cpu_cfs_quota_write_s64<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
        <span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"cfs_period_us"</span><span class="token punctuation">,</span>
        <span class="token punctuation">.</span>read_u64 <span class="token operator">=</span> cpu_cfs_period_read_u64<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>write_u64 <span class="token operator">=</span> cpu_cfs_period_write_u64<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>


<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">cftype</span> mem_cgroup_legacy_files<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
        <span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"usage_in_bytes"</span><span class="token punctuation">,</span>
        <span class="token punctuation">.</span>private <span class="token operator">=</span> <span class="token function">MEMFILE_PRIVATE</span><span class="token punctuation">(</span>_MEM<span class="token punctuation">,</span> RES_USAGE<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">.</span>read_u64 <span class="token operator">=</span> mem_cgroup_read_u64<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
        <span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"max_usage_in_bytes"</span><span class="token punctuation">,</span>
        <span class="token punctuation">.</span>private <span class="token operator">=</span> <span class="token function">MEMFILE_PRIVATE</span><span class="token punctuation">(</span>_MEM<span class="token punctuation">,</span> RES_MAX_USAGE<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">.</span>write <span class="token operator">=</span> mem_cgroup_reset<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>read_u64 <span class="token operator">=</span> mem_cgroup_read_u64<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
        <span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"limit_in_bytes"</span><span class="token punctuation">,</span>
        <span class="token punctuation">.</span>private <span class="token operator">=</span> <span class="token function">MEMFILE_PRIVATE</span><span class="token punctuation">(</span>_MEM<span class="token punctuation">,</span> RES_LIMIT<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">.</span>write <span class="token operator">=</span> mem_cgroup_write<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>read_u64 <span class="token operator">=</span> mem_cgroup_read_u64<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
        <span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"soft_limit_in_bytes"</span><span class="token punctuation">,</span>
        <span class="token punctuation">.</span>private <span class="token operator">=</span> <span class="token function">MEMFILE_PRIVATE</span><span class="token punctuation">(</span>_MEM<span class="token punctuation">,</span> RES_SOFT_LIMIT<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">.</span>write <span class="token operator">=</span> mem_cgroup_write<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>read_u64 <span class="token operator">=</span> mem_cgroup_read_u64<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果设置的是cpu.shares，则调用cpu_shares_write_u64。在这里面，task_group的shares变量更新了，并且更新了CPU队列上的调度实体。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sched_group_set_shares</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_group</span> <span class="token operator">*</span>tg<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> shares<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>

    shares <span class="token operator">=</span> <span class="token function">clamp</span><span class="token punctuation">(</span>shares<span class="token punctuation">,</span> <span class="token function">scale_load</span><span class="token punctuation">(</span>MIN_SHARES<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">scale_load</span><span class="token punctuation">(</span>MAX_SHARES<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    tg<span class="token operator">-&gt;</span>shares <span class="token operator">=</span> shares<span class="token punctuation">;</span>
    <span class="token function">for_each_possible_cpu</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq <span class="token operator">=</span> <span class="token function">cpu_rq</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se <span class="token operator">=</span> tg<span class="token operator">-&gt;</span>se<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> rf<span class="token punctuation">;</span>

        <span class="token function">update_rq_clock</span><span class="token punctuation">(</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">for_each_sched_entity</span><span class="token punctuation">(</span>se<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">update_load_avg</span><span class="token punctuation">(</span>se<span class="token punctuation">,</span> UPDATE_TG<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">update_cfs_shares</span><span class="token punctuation">(</span>se<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但是这个时候别忘了，我们还没有将CPU的文件夹下面的tasks文件写入进程号呢。写入一个进程号到tasks文件里面，按照cgroup1_base_files里面的定义，我们应该调用cgroup_tasks_write。</p>
<p>接下来的调用链为：cgroup_tasks_write-&gt;__cgroup_procs_write-&gt;cgroup_attach_task-&gt; cgroup_migrate-&gt;cgroup_migrate_execute。将这个进程和一个cgroup关联起来，也即将这个进程迁移到这个cgroup下面。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">cgroup_migrate_execute</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cgroup_mgctx</span> <span class="token operator">*</span>mgctx<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">cgroup_taskset</span> <span class="token operator">*</span>tset <span class="token operator">=</span> <span class="token operator">&amp;</span>mgctx<span class="token operator">-&gt;</span>tset<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">cgroup_subsys</span> <span class="token operator">*</span>ss<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>task<span class="token punctuation">,</span> <span class="token operator">*</span>tmp_task<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">css_set</span> <span class="token operator">*</span>cset<span class="token punctuation">,</span> <span class="token operator">*</span>tmp_cset<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tset<span class="token operator">-&gt;</span>nr_tasks<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">do_each_subsys_mask</span><span class="token punctuation">(</span>ss<span class="token punctuation">,</span> ssid<span class="token punctuation">,</span> mgctx<span class="token operator">-&gt;</span>ss_mask<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>ss<span class="token operator">-&gt;</span>attach<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                tset<span class="token operator">-&gt;</span>ssid <span class="token operator">=</span> ssid<span class="token punctuation">;</span>
                ss<span class="token operator">-&gt;</span><span class="token function">attach</span><span class="token punctuation">(</span>tset<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token function">while_each_subsys_mask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>每一个cgroup子系统会调用相应的attach函数。而CPU调用的是cpu_cgroup_attach-&gt; sched_move_task-&gt; sched_change_group。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sched_change_group</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_group</span> <span class="token operator">*</span>tg<span class="token punctuation">;</span>

    tg <span class="token operator">=</span> <span class="token function">container_of</span><span class="token punctuation">(</span><span class="token function">task_css_check</span><span class="token punctuation">(</span>tsk<span class="token punctuation">,</span> cpu_cgrp_id<span class="token punctuation">,</span> true<span class="token punctuation">)</span><span class="token punctuation">,</span>
              <span class="token keyword">struct</span> <span class="token class-name">task_group</span><span class="token punctuation">,</span> css<span class="token punctuation">)</span><span class="token punctuation">;</span>
    tg <span class="token operator">=</span> <span class="token function">autogroup_task_group</span><span class="token punctuation">(</span>tsk<span class="token punctuation">,</span> tg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    tsk<span class="token operator">-&gt;</span>sched_task_group <span class="token operator">=</span> tg<span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_FAIR_GROUP_SCHED</span></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tsk<span class="token operator">-&gt;</span>sched_class<span class="token operator">-&gt;</span>task_change_group<span class="token punctuation">)</span>
        tsk<span class="token operator">-&gt;</span>sched_class<span class="token operator">-&gt;</span><span class="token function">task_change_group</span><span class="token punctuation">(</span>tsk<span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
        <span class="token function">set_task_rq</span><span class="token punctuation">(</span>tsk<span class="token punctuation">,</span> <span class="token function">task_cpu</span><span class="token punctuation">(</span>tsk<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在sched_change_group中设置这个进程以这个task_group的方式参与调度，从而使得上面的cpu.shares起作用。</p>
<p>对于内存来讲，写入内存的限制使用函数mem_cgroup_write-&gt;mem_cgroup_resize_limit来设置struct mem_cgroup的memory.limit成员。</p>
<p>在进程执行过程中，申请内存的时候，我们会调用handle_pte_fault-&gt;do_anonymous_page()-&gt;mem_cgroup_try_charge()。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">mem_cgroup_try_charge</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>mm<span class="token punctuation">,</span>
              gfp_t gfp_mask<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">mem_cgroup</span> <span class="token operator">*</span><span class="token operator">*</span>memcgp<span class="token punctuation">,</span>
              bool compound<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">mem_cgroup</span> <span class="token operator">*</span>memcg <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>memcg<span class="token punctuation">)</span>
        memcg <span class="token operator">=</span> <span class="token function">get_mem_cgroup_from_mm</span><span class="token punctuation">(</span>mm<span class="token punctuation">)</span><span class="token punctuation">;</span>

    ret <span class="token operator">=</span> <span class="token function">try_charge</span><span class="token punctuation">(</span>memcg<span class="token punctuation">,</span> gfp_mask<span class="token punctuation">,</span> nr_pages<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在mem_cgroup_try_charge中，先是调用get_mem_cgroup_from_mm获得这个进程对应的mem_cgroup结构，然后在try_charge中，根据mem_cgroup的限制，看是否可以申请分配内存。</p>
<p>至此，cgroup对于内存的限制才真正起作用。</p>
<h4 id="52-1-总结"><a href="#52-1-总结" class="headerlink" title="52.1 总结"></a>52.1 总结</h4><p>内核中cgroup的工作机制，我们在这里总结一下。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/cgroup的工作机制.png" alt="cgroup的工作机制.png"></p>
<p>第一步，系统初始化的时候，初始化cgroup的各个子系统的操作函数，分配各个子系统的数据结构。</p>
<p>第二步，mount cgroup文件系统，创建文件系统的树形结构，以及操作函数。</p>
<p>第三步，写入cgroup文件，设置cpu或者memory的相关参数，这个时候文件系统的操作函数会调用到cgroup子系统的操作函数，从而将参数设置到cgroup子系统的数据结构中。</p>
<p>第四步，写入tasks文件，将进程交给某个cgroup进行管理，因为tasks文件也是一个cgroup文件，统一会调用文件系统的操作函数进而调用cgroup子系统的操作函数，将cgroup子系统的数据结构和进程关联起来。</p>
<p>第五步，对于cpu来讲，会修改scheduled entity，放入相应的队列里面去，从而下次调度的时候就起作用了。对于内存的cgroup设定，只有在申请内存的时候才起作用。</p>
<h3 id="53-数据中心操作系统"><a href="#53-数据中心操作系统" class="headerlink" title="53. 数据中心操作系统"></a>53. 数据中心操作系统</h3><p>在这门课程里面，我们说了，在内核态有很多的模块，可以帮助我们管理硬件设备，最重要的四种硬件资源是CPU、内存、存储和网络。</p>
<p>最初使用汇编语言的前辈，在程序中需要指定使用的硬件资源，例如，指定使用哪个寄存器、放在内存的哪个位置、写入或者读取那个串口等等。对于这些资源的使用，需要程序员自己心里非常地清楚，要不然一旦jump错了位置，程序就无法运行。</p>
<p>为了将程序员从对硬件的直接操作中解放出来，提升程序设计的效率，于是，我们有了操作系统这一层，用来实现对于硬件资源的统一管理。某个程序使用哪个CPU、哪部分内存、哪部分硬盘，只需要调用API就可以了，这些都由操作系统自行分配和管理。</p>
<p>其实操作系统最总要的事情，就是调度。因此，在内核态就产生这些模块：进程管理子系统、内存管理子系统、文件子系统、设备子系统和网络子系统。</p>
<p>这些模块通过统一的API，也就是系统调用，对上提供服务。基于这些API，用户态有很多的工具可以帮我们使用好Linux操作系统，比如用户管理、软件安装、软件运行、周期性进程、文件管理、网络管理和存储管理。</p>
<p>但是到目前为止，我们能管理的还是少数几台机器。当我们面临数据中心成千上万台机器的时候，仍然非常“痛苦”。如果我们运维数据中心依然像的运维一台台物理机的前辈一样，天天关心哪个程序放在了哪台机器上，使用多少内存、多少硬盘，每台机器总共有多少内存、多少硬盘，还剩多少内存和硬盘，那头就大了。</p>
<p>因而对应到数据中心，我们也需要一个调度器，将运维人员从指定物理机或者虚拟机的痛苦中解放出来，实现对于物理资源的统一管理，这就是Kubernetes。</p>
<p>Kubernetes究竟有哪些功能，可以解放运维人员呢？为什么它能做数据中心的操作系统呢？</p>
<p>我列了两个表格，将操作系统的功能和模块与Kubernetes的功能和模块做了一个对比，你可以看看。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/操作系统的功能和模块与Kubernetes的功能和模块对比.jpeg" alt="操作系统的功能和模块与Kubernetes的功能和模块对比"></p>
<p>Kubernetes作为数据中心的操作系统还是主要管理数据中心里面的四种硬件资源：CPU、内存、存储、网络。</p>
<p>对于CPU和内存这两种计算资源的管理，我们可以通过Docker技术完成。它可以将CPU和内存资源，通过namespace和cgroup，从大的资源池里面隔离出来，并通过镜像技术，实现计算资源在数据中心里面的自由漂移。</p>
<p>就像我们上面说的一样，那没有操作系统的时候，汇编程序员需要指定程序运行的CPU和内存物理地址。同理，数据中心的管理员，原来还需要指定程序运行的服务器及使用的CPU和内存。现在，Kubernetes里面有一个调度器Scheduler，你只需要告诉它，你想运行10个4核8G的Java程序，它会自动帮你选择空闲的、有足够资源的服务器，去运行这些程序。</p>
<p>对于操作系统上的进程来讲，有主线程做主要的工作，还有其它线程做辅助的工作。对于数据中心里面的运行的程序来讲，可以也会有一个主要提供服务的程序，例如上面的Java程序，也会有一些提供辅助功能的程序；例如监控、环境预设值等。Kubernetes将多个Docker组装成一个Pod的概念，在一个Pod里面，往往有一个Docker为主，多个Docker为辅。</p>
<p>操作系统上的进程会在CPU上切换来切换去，它使用的内存也会换入换出。在数据中心里面，这些运行中的程序能不能在机器之间迁移呢？能不能在一台服务器故障的时候，选择其它的服务器运行呢？反正我关心的是运行10个4核8G的Java程序，又不在乎它在哪台上运行。Kubernetes里面有Controller的概念，可以控制Pod们的运行状态以及占用的资源，如果10个变9个就选一台机器添加一个，10个变11个，就随机删除一个。</p>
<p>操作系统上的进程有时候有亲和性的要求，比如它可能希望再某一个CPU上运行，不切换CPU从而提高运行效率，或者两个线程要求在一个CPU上，从而可以使用Per CPU变量不加锁，交互和协作比较方便。有的时候，一个线程想避开另一个线程，不要共用CPU，以防相互干扰。Kubernetes的Scheduler也是有亲和性功能的，你可以选择两个Pod永远运行在一台物理机上，这样本地通信就可以了，也可以选择两个Pod永远不要运行在同一台物理机上，这样一个挂了不影响另一个。</p>
<p>你可能会问，Docker可以将CPU内存资源进行抽象，在服务器之间迁移，那数据应该怎么办呢？如果数据放在每一台服务器上，其实就像散落在汪洋大海里面，用的时候根本找不到，所以必须要有统一的存储。正像一台操作系统上多个进程之间，要通过文件系统保存持久化的数据并且实现共享，在数据中心里面也需要一个这样的基础设施。</p>
<p>统一的存储常常有三种形式，我们分别来看。</p>
<p>第一种方式是<strong>对象存储</strong>。</p>
<p>顾名思义，这种方式是将文件作为一个完整对象的方式来保存。每一个文件对我们来说，都应该有一个唯一标识这个对象的key，而文件的内容就是value。对象可以分门别类地保存在一个叫作存储空间（Bucket）的地方，有点儿像文件夹。</p>
<p>对于任何一个文件对象，我们都可以通过HTTP RESTful API来远程获取对象。由于是简单的key-value模式，当需要保存大容量数据的时候，我们就比较容易根据唯一的key进行横向扩展，所以对象存储往往能够容纳的数据量非常大。在数据中心里面保存文档，视频等很好的方式，当然缺点就是，你没办法像操作文件一样操作它，而是要将value当成整个的来对待。</p>
<p>第二种方式是<strong>分布式文件系统</strong>。</p>
<p>这种是最容易习惯的，因为使用它和使用本地的文件系统几乎没有什么区别，只不过是通过网络的方式访问远程的文件系统。多个容器能看到统一的文件系统，一个容器写入文件系统的，另一个容器能够看到，可以实现共享。缺点是分布式文件系统的性能和规模是个矛盾，规模一大性能就难以保证，性能好则规模不会很大，所以不像对象存储一样能够保持海量的数据。</p>
<p>第三种方式是<strong>分布式块存储</strong>。</p>
<p>这是云硬盘，也即存储虚拟化的方式，只不过将盘挂载给容器而不是虚拟机。块存储没有分布式文件系统这一层，一旦挂载到某一个容器，可以有本地的文件系统，这样缺点是一般情况下，不同容器挂载的块存储都是不共享的，好处是在同样的规模的情况下，性能相对分布式文件系统要好。如果为了解决一个容器从一台服务器迁移到另一台服务器，如何保持存储的数据的问题，块存储是一个很好的选择。它不用解决多个容器共享数据的问题。</p>
<p>这三种形式，对象存储使用HTTP进行访问，当然任何容器都能访问到，不需要Kubernetes去管理它。而分布式文件系统和分布式块存储，就需要对接到Kubernetes，让Kubernetes可以管理它们。如何对接呢？Kubernetes提供Container Storage Interface (CSI)接口，这是一个标准接口，不同的存储可以实现这个接口来对接Kubernetes。是不是特别像设备驱动程序呀。操作系统只要定义统一的接口，不同的存储设备的驱动实现这些接口，就能被操作系统使用了。</p>
<p>存储的问题解决了，接下来是网络。因为不同的服务器上的Docker还是需要互相通信的。</p>
<p>Kubernetes有自己的网络模型，里面是这样规定的。</p>
<ul>
<li>IP-per-Pod，每个 Pod 都拥有一个独立 IP 地址，Pod 内所有容器共享一个网络命名空间。</li>
<li>集群内所有 Pod 都在一个直接连通的扁平网络中，可通过 IP 直接访问。</li>
<li>所有容器之间无需 NAT 就可以直接互相访问。</li>
<li>所有 Node 和所有容器之间无需 NAT 就可以直接互相访问。</li>
<li>容器自己看到的 IP 跟其它容器看到的一样。</li>
</ul>
<p>这其实是说，里面的每一个Docker访问另一个Docker的时候，都是感觉在一个扁平的网络里面就可以了。</p>
<p>要实现这样的网络模型，有很多种方式，例如Kubernetes自己提供Calico、Flannel。当然，也可以对接Openvswitch这样的虚拟交换机，也可以使用brctl这种传统的桥接模式，也可以对接硬件交换机。</p>
<p>看，这又是一种类似驱动的模式，和操作系统面临的问题是一样的。Kubernetes同样是提供统一的接口Container Network Interface（CNI，容器网络接口）。无论你用哪种方式实现网络模型，只要对接这个统一的接口，Kubernetes就可以管理容器的网络。</p>
<p>至此，Kubernetes作为数据中心的操作系统，内核的问题解决了。</p>
<p>接下来是用户态的工具问题了。我们能不能像操作一台服务器那样操作数据中心呢？</p>
<p>使用操作系统，需要安装一些软件，于是，我们需要yum之类的包管理系统，使得软件的使用者和软件的编译者分隔开来，软件的编译者需要知道这个软件需要安装哪些包，包之间的依赖关系是什么，软件安装到什么地方，而软件的使用者仅仅需要yum install就可以了。Kubernetes就有这样一套包管理软件Helm，你可以用它来很方便的安装，升级，扩容一些数据中心里面的常用软件，例如数据库，缓存，消息队列。</p>
<p>使用操作系统，运行一个进程是最常见的需求。第一种进程是<strong>交互式命令行</strong>，运行起来就是执行一个任务，结束了马上返回结果。在Kubernetes里面有对应的概念叫做Job，Job 负责批量处理短暂的一次性任务 (Short Lived One-off Tasks)，即仅执行一次的任务，它保证批处理任务的一个或多个 Pod 成功结束。</p>
<p>第二种进程是<strong>nohup长期运行的进程</strong>。在Kubernetes里对应的概念是Deployment，使用 Deployment 来创建 ReplicaSet。ReplicaSet 在后台创建 pod。也即Doployment里面会声明我希望某个进程以N的Pod副本的形式运行，并且长期运行，一但副本变少就会自动添加。</p>
<p>第三种进程是<strong>系统服务</strong>。在Kubernetes里面对应的概念是DaemonSet，它保证在每个节点上都运行一个容器副本，常用来部署一些集群的日志、监控或者其它系统管理应用。</p>
<p>第四种进程是<strong>周期性进程</strong>，也即<strong>crontab</strong>，常常用来设置一些周期性的任务。在Kubernetes里面对应的概念是CronJob定时任务，就类似于 Linux 系统的 crontab，在指定的时间周期运行指定的任务。</p>
<p>使用操作系统，我们还需使用文件系统，或者使用网络发送数据，虽然在Kubernetes里面有CSI和CNI来对接存储和网络，在用户态，不能让用户意识到后面具体设备，而是应该有抽象的概念。</p>
<p>对于存储来讲，Kubernetes有Volume的概念，Kubernetes Volume 的生命周期与 Pod 绑定，</p>
<p>容器挂掉后 Kubelet 再次重启容器时，Volume 的数据依然还在，而 Pod 删除时，Volume 才会清理。数据是否丢失取决于具体的 Volume 类型。Volume的概念是对具体存储设备的抽象，就像当我们使用ext4文件系统不用管它是基于什么硬盘一样。</p>
<p>对于网络来讲，Kubernetes有自己的DNS，有Service的概念，Kubernetes Service是一个 Pod 的逻辑分组，这一组 Pod 能够被 Service 访问。每一个Service都一个名字，Kubernetes会将Service的名字作为域名进行解析，称为一个虚拟的Cluster IP，然后通过负载均衡，转发到后端的Pod，虽然Pod可能漂移，IP会变，但是Service会一直不变。</p>
<p>对应到Linux操作系统的iptables，Kubernetes 在有个概念叫Network Policy，Network Policy 提供了基于策略的网络控制，用于隔离应用并减少攻击面。它使用标签选择器模拟传统的分段网络，并通过策略控制它们之间的流量以及来自外部的流量。</p>
<p>看，是不是很神奇？有了Kubernetes，我们就能像管理一台Linux服务器那样，去管理数据中心了。</p>
<p>如果想深入了解Kubernetes这个数据中心的操作系统，你可以订阅极客时间的专栏“<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/114197">深入剖析Kubernetes</a>”。</p>
<h4 id="53-1-总结"><a href="#53-1-总结" class="headerlink" title="53.1 总结"></a>53.1 总结</h4><p>下面，你可以对照着这个图，来总结一下这个数据中心操作系统的功能。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/数据中心操作系统的功能总结.jpg" alt="数据中心操作系统的功能总结"></p>
<h2 id="十、实战串讲篇"><a href="#十、实战串讲篇" class="headerlink" title="十、实战串讲篇"></a>十、实战串讲篇</h2><h3 id="54-搭建操作系统实验环境（上）"><a href="#54-搭建操作系统实验环境（上）" class="headerlink" title="54. 搭建操作系统实验环境（上）"></a>54. 搭建操作系统实验环境（上）</h3><p>操作系统的理论部分我们就讲完了，但是计算机这门学科是实验性的。为了更加深入地了解操作系统的本质，我们必须能够做一些上手实验。操作系统的实验，相比其他计算机课程的实验要更加复杂一些。</p>
<p>我们做任何实验，都需要一个实验环境。这个实验环境要搭建在操作系统之上，但是，我们这个课程本身就是操作系统实验，难不成要自己debug自己？到底该咋整呢？</p>
<p>我们有一个利器，那就是qemu啊，不知道你还记得吗？它可以在操作系统之上模拟一个操作系统，就像一个普通的进程。那我们是否可以像debug普通进程那样，通过qemu来debug虚拟机里面的操作系统呢？</p>
<p>这一节和下一节，我们就按照这个思路，来试试看，搭建一个操作系统的实验环境。</p>
<p>运行一个qemu虚拟机，首先我们要有一个虚拟机的镜像。咱们在<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/108964">虚拟机</a>那一节，已经制作了一个虚拟机的镜像。假设我们要基于 ubuntu-18.04.2-live-server-amd64.iso，它对应的内核版本是linux-source-4.15.0。</p>
<p>当时我们启动虚拟机的过程很复杂，设置参数的时候也很复杂，以至于解析这些参数就花了我们一章的时间。所以，这里我介绍一个简单的创建和管理虚拟机的方法。</p>
<p>在<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/109335">CPU虚拟化</a>那一节，我留过一个思考题，OpenStack是如何创建和管理虚拟机的？当时我给了你一个提示，就是用libvirt。没错，这一节，我们就用libvirt来创建和管理虚拟机。</p>
<h4 id="54-1-创建虚拟机"><a href="#54-1-创建虚拟机" class="headerlink" title="54.1 创建虚拟机"></a>54.1 创建虚拟机</h4><p>首先，在宿主机上，我们需要一个网桥。我们用下面的命令创建一个网桥，并且设置一个IP地址。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brctl addbr br0
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> br0 up
<span class="token function">ifconfig</span> br0 <span class="token number">192.168</span>.57.1/24<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>为了访问外网，这里还需要设置/etc/sysctl.conf文件中net.ipv4.ip_forward=1参数，并且执行以下的命令，设置NAT。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>接下来，就要创建虚拟机了。这次我们就不再一个个指定虚拟机启动的参数，而是用libvirt。首先，使用下面的命令，安装libvirt。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt-get</span> <span class="token function">install</span> libvirt-bin
<span class="token function">apt-get</span> <span class="token function">install</span> virtinst<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>libvirt管理qemu虚拟机，是基于XML文件，这样容易维护。</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>domain</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>qemu<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">&gt;</span></span>ubuntutest<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>uuid</span><span class="token punctuation">&gt;</span></span>0f0806ab-531d-6134-5def-c5b4955292aa<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>uuid</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>memory</span> <span class="token attr-name">unit</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>GiB<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>memory</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>currentMemory</span> <span class="token attr-name">unit</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>GiB<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>currentMemory</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>vcpu</span> <span class="token attr-name">placement</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>static<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>vcpu</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>os</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span> <span class="token attr-name">arch</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>x86_64<span class="token punctuation">'</span></span> <span class="token attr-name">machine</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>pc-i440fx-trusty<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>hvm<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>boot</span> <span class="token attr-name">dev</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>hd<span class="token punctuation">'</span></span><span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>os</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>features</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>acpi</span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>apic</span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pae</span><span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>features</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>clock</span> <span class="token attr-name">offset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>utc<span class="token punctuation">'</span></span><span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>on_poweroff</span><span class="token punctuation">&gt;</span></span>destroy<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>on_poweroff</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>on_reboot</span><span class="token punctuation">&gt;</span></span>restart<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>on_reboot</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>on_crash</span><span class="token punctuation">&gt;</span></span>restart<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>on_crash</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>devices</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>emulator</span><span class="token punctuation">&gt;</span></span>/usr/bin/qemu-system-x86_64<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>emulator</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>disk</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>file<span class="token punctuation">'</span></span> <span class="token attr-name">device</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>disk<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>driver</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>qemu<span class="token punctuation">'</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>qcow2<span class="token punctuation">'</span></span><span class="token punctuation">/&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">file</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>/mnt/vdc/ubuntutest.img<span class="token punctuation">'</span></span><span class="token punctuation">/&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>target</span> <span class="token attr-name">dev</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>vda<span class="token punctuation">'</span></span> <span class="token attr-name">bus</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>virtio<span class="token punctuation">'</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>disk</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>controller</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>pci<span class="token punctuation">'</span></span> <span class="token attr-name">index</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>0<span class="token punctuation">'</span></span> <span class="token attr-name">model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>pci-root<span class="token punctuation">'</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>interface</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>bridge<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mac</span> <span class="token attr-name">address</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>fa:16:3e:6e:89:ce<span class="token punctuation">'</span></span><span class="token punctuation">/&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">bridge</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>br0<span class="token punctuation">'</span></span><span class="token punctuation">/&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>target</span> <span class="token attr-name">dev</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>tap1<span class="token punctuation">'</span></span><span class="token punctuation">/&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>model</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>virtio<span class="token punctuation">'</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>interface</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>serial</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>pty<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>target</span> <span class="token attr-name">port</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>0<span class="token punctuation">'</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>serial</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>console</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>pty<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>target</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>serial<span class="token punctuation">'</span></span> <span class="token attr-name">port</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>0<span class="token punctuation">'</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>console</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>graphics</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>vnc<span class="token punctuation">'</span></span> <span class="token attr-name">port</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>-1<span class="token punctuation">'</span></span> <span class="token attr-name">autoport</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>yes<span class="token punctuation">'</span></span> <span class="token attr-name">listen</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>0.0.0.0<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>listen</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>address<span class="token punctuation">'</span></span> <span class="token attr-name">address</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>0.0.0.0<span class="token punctuation">'</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>graphics</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>video</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>model</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>cirrus<span class="token punctuation">'</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>video</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>devices</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>domain</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这个XML文件中，/mnt/vdc/ubuntutest.img就是虚拟机的镜像，br0就是我们创建的网桥，连接到网桥上的网卡libvirt会自动帮我们创建。</p>
<p>接下来，需要将这个XML保存为domain.xml，然后调用下面的命令，交给libvirt进行管理。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">virsh</span> define domain.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>接下来，运行virsh list —all，我们就可以看到这个定义好的虚拟机了，然后我们调用virsh start ubuntutest，启动这个虚拟机。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">virsh</span> list
 Id    Name                           State
----------------------------------------------------
 <span class="token number">1</span>     ubuntutest                     running<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们可以通过ps查看libvirt启动的qemu进程。这个命令行是不是很眼熟？我们之前花了一章来讲解。如果不记得了，你可以回去看看前面的内容。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">grep</span> qemu
libvirt+  <span class="token number">9343</span> <span class="token number">85.1</span> <span class="token number">34.7</span> <span class="token number">10367352</span> <span class="token number">5699400</span> ?    Sl   Jul27 <span class="token number">1239</span>:18 /usr/bin/qemu-system-x86_64 -name ubuntutest -S -machine pc-i440fx-trusty,accel<span class="token operator">=</span>tcg,usb<span class="token operator">=</span>off -m <span class="token number">4096</span> -realtime <span class="token assign-left variable">mlock</span><span class="token operator">=</span>off -smp <span class="token number">2</span>,sockets<span class="token operator">=</span><span class="token number">2</span>,cores<span class="token operator">=</span><span class="token number">1</span>,threads<span class="token operator">=</span><span class="token number">1</span> -uuid 0f0806ab-531d-6134-5def-c5b4955292aa -no-user-config -nodefaults -chardev socket,id<span class="token operator">=</span>charmonitor,path<span class="token operator">=</span>/var/lib/libvirt/qemu/domain-ubuntutest/monitor.sock,server,nowait -mon <span class="token assign-left variable">chardev</span><span class="token operator">=</span>charmonitor,id<span class="token operator">=</span>monitor,mode<span class="token operator">=</span>control -rtc <span class="token assign-left variable">base</span><span class="token operator">=</span>utc -no-shutdown -boot <span class="token assign-left variable">strict</span><span class="token operator">=</span>on -device piix3-usb-uhci,id<span class="token operator">=</span>usb,bus<span class="token operator">=</span>pci.0,addr<span class="token operator">=</span>0x1.0x2 -drive <span class="token assign-left variable">file</span><span class="token operator">=</span>/mnt/vdc/ubuntutest.img,format<span class="token operator">=</span>qcow2,if<span class="token operator">=</span>none,id<span class="token operator">=</span>drive-virtio-disk0 -device virtio-blk-pci,scsi<span class="token operator">=</span>off,bus<span class="token operator">=</span>pci.0,addr<span class="token operator">=</span>0x4,drive<span class="token operator">=</span>drive-virtio-disk0,id<span class="token operator">=</span>virtio-disk0,bootindex<span class="token operator">=</span><span class="token number">1</span> -netdev tap,fd<span class="token operator">=</span><span class="token number">26</span>,id<span class="token operator">=</span>hostnet0 -device virtio-net-pci,netdev<span class="token operator">=</span>hostnet0,id<span class="token operator">=</span>net0,mac<span class="token operator">=</span>fa:16:3e:6e:89:ce,bus<span class="token operator">=</span>pci.0,addr<span class="token operator">=</span>0x3 -chardev pty,id<span class="token operator">=</span>charserial0 -device isa-serial,chardev<span class="token operator">=</span>charserial0,id<span class="token operator">=</span>serial0 -vnc <span class="token number">0.0</span>.0.0:0 -device cirrus-vga,id<span class="token operator">=</span>video0,bus<span class="token operator">=</span>pci.0,addr<span class="token operator">=</span>0x2 -device virtio-balloon-pci,id<span class="token operator">=</span>balloon0,bus<span class="token operator">=</span>pci.0,addr<span class="token operator">=</span>0x5 -msg <span class="token assign-left variable">timestamp</span><span class="token operator">=</span>on<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>从这里，我们可以看到，VNC的设置为0.0.0.0:0。我们可以用VNCViewer工具登录到这个虚拟机的界面，但是这样实在是太麻烦了，其实virsh有一个特别好的工具，但是需要在虚拟机里面配置一些东西。</p>
<p>在虚拟机里面，我们修改/boot/grub/里面的两个文件，一个是grub.cfg，另一个是menu.lst，这里面就是咱们在<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/89739">系统初始化</a>的时候，讲过的那个启动列表。</p>
<p>在grub.cfg中，在submenu ‘Advanced options for Ubuntu’ 这一项，在这一行的linux /boot/vmlinuz-4.15.0-55-generic root=UUID=470f3a42-7a97-4b9d-aaa0-26deb3d234f9 ro console=ttyS0 maybe-ubiquity中，加上了console=ttyS0。</p>
<p>在grub.cfg中，在submenu ‘Advanced options for Ubuntu’ 这一项，在这一行的linux /boot/vmlinuz-4.15.0-55-generic root=UUID=470f3a42-7a97-4b9d-aaa0-26deb3d234f9 ro console=ttyS0 maybe-ubiquity中，加上了console=ttyS0。</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">submenu 'Advanced options for Ubuntu' $menuentry_id_option 'gnulinux-advanced-470f3a42-7a97-4b9d-aaa0-26deb3d234f9' {
    menuentry 'Ubuntu, with Linux 4.15.0-55-generic' --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-4.15.0-55-generic-advanced-470f3a42-7a97-4b9d-aaa0-26deb3d234f9' {
        recordfail
        load_video
        gfxmode $linux_gfx_mode
        insmod gzio
        if [ x$grub_platform = xxen ]; then insmod xzio; insmod lzopio; fi
        insmod part_gpt
        insmod ext2
        set root='hd0,gpt2'
        if [ x$feature_platform_search_hint = xy ]; then
            search --no-floppy --fs-uuid --set=root --hint-bios=hd0,gpt2 --hint-efi=hd0,gpt2 --hint-baremetal=ahci0,gpt2  470f3a42-7a97-4b9d-aaa0-26deb3d234f9
        else
            search --no-floppy --fs-uuid --set=root 470f3a42-7a97-4b9d-aaa0-26deb3d234f9
        fi
        echo    'Loading Linux 4.15.0-55-generic ...'
        linux   /boot/vmlinuz-4.15.0-55-generic root=UUID=470f3a42-7a97-4b9d-aaa0-26deb3d234f9 ro console=ttyS0 maybe-ubiquity
        echo    'Loading initial ramdisk ...'
        initrd  /boot/initrd.img-4.15.0-55-generic
    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在menu.lst文件中，在Ubuntu 18.04.2 LTS, kernel 4.15.0-55-generic这一项，在kernel /boot/vmlinuz-4.15.0-55-generic root=/dev/hda1 ro console=hvc0 console=ttyS0这一行加入console=ttyS0。</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">title           Ubuntu 18.04.2 LTS, kernel 4.15.0-55-generic
root            (hd0)
kernel          /boot/vmlinuz-4.15.0-55-generic root=/dev/hda1 ro console=hvc0 console=ttyS0
initrd          /boot/initrd.img-4.15.0-55-generic<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来，我们重启虚拟机，重启后上面的配置就起作用了。这时候，我们可以通过下面的命令，进入机器的控制台，可以不依赖于SSH和IP地址进行登录。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">virsh</span> console ubuntutest
Connected to domain ubuntutest
Escape character is ^<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>下面，我们可以配置这台机器的IP地址了。对于ubuntu-18.04来讲，IP地址的配置方式为修改/etc/netplan/50-cloud-init.yaml文件。</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">network</span><span class="token punctuation">:</span>
    <span class="token key atrule">ethernets</span><span class="token punctuation">:</span>
        <span class="token key atrule">ens3</span><span class="token punctuation">:</span>
                <span class="token key atrule">addresses</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>192.168.57.100/24<span class="token punctuation">]</span>
                <span class="token key atrule">gateway4</span><span class="token punctuation">:</span> 192.168.57.1
                <span class="token key atrule">dhcp4</span><span class="token punctuation">:</span> no
                <span class="token key atrule">nameservers</span><span class="token punctuation">:</span>
                        <span class="token key atrule">addresses</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>8.8.8.8<span class="token punctuation">,</span>114.114.114.114<span class="token punctuation">]</span>
                <span class="token key atrule">optional</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
    <span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后，我们可以通过netplan apply，让配置生效，这样，虚拟机里面的IP地址就配置好了。现在，我们应该能ping得通公网的一个网站了。</p>
<p>虚拟机就此创建好了，接下来我们需要下载源代码重新编译。</p>
<h4 id="54-2-下载源代码"><a href="#54-2-下载源代码" class="headerlink" title="54.2 下载源代码"></a>54.2 下载源代码</h4><p>首先，我们先下载源代码。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt-get</span> <span class="token function">install</span> linux-source-4.15.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这行命令会将代码下载到/usr/src/目录下，我们可以通过下面的命令解压缩。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> vjxkf linux-source-4.15.0.tar.bz2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>至此，路径/usr/src/linux-source-4.15.0下，就是解压好的内核代码。</p>
<p>准备工作都做好了。这一节，我们先来做第一个实验，也就是，在原有内核代码的基础上加一个我们自己的系统调用。</p>
<p>在哪里加代码呢？如果你忘了，请出门左转，回顾一下<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/90394">系统调用</a>那一节。</p>
<p>第一个要加的地方是arch/x86/entry/syscalls/syscall_64.tbl。这里面登记了所有的系统调用号以及相应的处理函数。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">332</span>     common  statx                   sys_statx
<span class="token number">333</span>     <span class="token number">64</span>      sayhelloworld           sys_sayhelloworld<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在这里，我们找到332号系统调用sys_statx，然后照猫画虎，添加一个sys_sayhelloworld，这里我们只添加64位操作系统的。</p>
<p>第二个要加的地方是include/linux/syscalls.h，也就是系统调用的头文件，然后添加一个系统调用的声明。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">asmlinkage <span class="token keyword">long</span> <span class="token function">sys_statx</span><span class="token punctuation">(</span><span class="token keyword">int</span> dfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> flags<span class="token punctuation">,</span>
                          <span class="token keyword">unsigned</span> mask<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">statx</span> __user <span class="token operator">*</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>

asmlinkage <span class="token keyword">int</span> <span class="token function">sys_sayhelloworld</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span> words<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>同样，我们找到sys_statx的声明，照猫画虎，声明一个sys_sayhelloworld。其中，words参数是用户态传递给内核态的文本的指针，count是数目。</p>
<p>第三个就是对于这个系统调用的实现，方便起见，我们不再用SYSCALL_DEFINEx系列的宏来定义了，直接在kernel/sys.c中实现。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">asmlinkage <span class="token keyword">int</span> <span class="token function">sys_sayhelloworld</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span> words<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">&gt;=</span> <span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">copy_from_user</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> words<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ret<span class="token operator">=</span><span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"User Mode says %s to the Kernel Mode!"</span><span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来就要开始编译内核了。</p>
<h4 id="54-3-编译内核"><a href="#54-3-编译内核" class="headerlink" title="54.3 编译内核"></a>54.3 编译内核</h4><p>编译之前，我们需要安装一些编译要依赖的包。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt-get</span> <span class="token function">install</span> libncurses5-dev libssl-dev bison flex libelf-dev gcc <span class="token function">make</span> openssl libc6-dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>首先，我们要定义编译选项。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> menuconfig<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后，我们能通过选中下面的选项，激活CONFIG_DEBUG_INFO和CONFIG_FRAME_POINTER选项。</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">Kernel hacking  ---&gt;
Compile-time checks and compiler options  ---&gt;
[*] Compile the kernel with debug info
[*] Compile the kernel with frame pointers<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>选择完毕之后，配置会保存在.config文件中。如果我们打开看，能看到这样的配置：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">CONFIG_FRAME_POINTER</span><span class="token operator">=</span>y
<span class="token assign-left variable">CONFIG_DEBUG_INFO</span><span class="token operator">=</span>y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>接下来，我们编译内核。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">nohup</span> <span class="token function">make</span> -j8 <span class="token operator">&gt;</span> make1.log <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;1</span> <span class="token operator">&amp;</span>
<span class="token function">nohup</span> <span class="token function">make</span> modules_install <span class="token operator">&gt;</span> make2.log <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;1</span> <span class="token operator">&amp;</span>
<span class="token function">nohup</span> <span class="token function">make</span> <span class="token function">install</span> <span class="token operator">&gt;</span> make3.log <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;1</span> <span class="token operator">&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这是一个非常长的过程，请耐心等待，可能需要数个小时，因而这里用了nohup，你可以去干别的事情。</p>
<p>当编译完毕之后，grub和menu.lst都会发生改变。例如，grub.conf里面会多一个新内核的项。</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">submenu 'Advanced options for Ubuntu' $menuentry_id_option 'gnulinux-advanced-470f3a42-7a97-4b9d-aaa0-26deb3d234f9' {
        menuentry 'Ubuntu, with Linux 4.15.18' --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-4.15.18-advanced-470f3a42-7a97-4b9d-aaa0-26deb3d234f9' {
                recordfail
                load_video
                gfxmode $linux_gfx_mode
                insmod gzio
                if [ x$grub_platform = xxen ]; then insmod xzio; insmod lzopio; fi
                insmod part_gpt
                insmod ext2
                if [ x$feature_platform_search_hint = xy ]; then
                  search --no-floppy --fs-uuid --set=root  470f3a42-7a97-4b9d-aaa0-26deb3d234f9
                else
                  search --no-floppy --fs-uuid --set=root 470f3a42-7a97-4b9d-aaa0-26deb3d234f9
                fi
                echo    'Loading Linux 4.15.18 ...'
                linux   /boot/vmlinuz-4.15.18 root=UUID=470f3a42-7a97-4b9d-aaa0-26deb3d234f9 ro console=ttyS0 maybe-ubiquity
                echo    'Loading initial ramdisk ...'
                initrd  /boot/initrd.img-4.15.18
        }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例如，menu.lst也多了新的内核的项。</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">title           Ubuntu 18.04.2 LTS, kernel 4.15.18
root            (hd0)
kernel          /boot/vmlinuz-4.15.18 root=/dev/hda1 ro console=hvc0 console=ttyS0
initrd          /boot/initrd.img-4.15.18<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>别忘了，这里面都要加上console=ttyS0。</p>
<p>下面，我们要做的就是重启虚拟机。进入的时候，会出现GRUB界面。我们选择Ubuntu高级选项，然后选择第一项进去，通过uname命令，我们就进入了新的内核。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">uname</span> -a
Linux popsuper <span class="token number">4.15</span>.18 <span class="token comment">#1 SMP Sat Jul 27 13:43:42 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>进入新的系统后，我们写一个测试程序。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kernel.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/syscall.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">char</span> <span class="token operator">*</span> words <span class="token operator">=</span> <span class="token string">"I am liuchao from user mode."</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
  ret <span class="token operator">=</span> <span class="token function">syscall</span><span class="token punctuation">(</span><span class="token number">333</span><span class="token punctuation">,</span> words<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"return %d from kernel mode.\n"</span><span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后，我们能利用gcc编译器编译后运行。如果我们查看日志/var/log/syslog，就能够看到里面打印出来下面的日志，这说明我们的系统调用已经添加成功了。</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">Aug  1 06:33:12 popsuper kernel: [ 2048.873393] User Mode says I am liuchao from user mode. to the Kernel Mode!<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="54-4-总结"><a href="#54-4-总结" class="headerlink" title="54.4 总结"></a>54.4 总结</h4><p>这一节是一节实战课，我们创建了一台虚拟机，在里面下载源代码，尝试修改了Linux内核，添加了一个自己的系统调用，并且进行了编译并安装了新内核。如果你按照这个过程做下来，你会惊喜地发现，原来令我们敬畏的内核，也是能够加以干预，为我而用的呢。没错，这就是你开始逐渐掌握内核的重要一步。</p>
<h3 id="55-搭建操作系统实验环境（下）"><a href="#55-搭建操作系统实验环境（下）" class="headerlink" title="55. 搭建操作系统实验环境（下）"></a>55. 搭建操作系统实验环境（下）</h3><p>上一节我们做了一个实验，添加了一个系统调用，并且编译了内核。这一节，我们来尝试调试内核。这样，我们就可以一步一步来看，内核的代码逻辑执行到哪一步了，对应的变量值是什么。</p>
<h4 id="55-1-了解gdb"><a href="#55-1-了解gdb" class="headerlink" title="55.1 了解gdb"></a>55.1 了解gdb</h4><p>在Linux下面，调试程序使用一个叫作gdb的工具。通过这个工具，我们可以逐行运行程序。</p>
<p>例如，上一节我们写的syscall.c这个程序，我们就可以通过下面的命令编译。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc -g syscall.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>其中，参数-g的意思就是在编译好的二进制程序中，加入debug所需的信息。</p>
<p>接下来，我们安装一下gdb。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt-get</span> <span class="token function">install</span> gdb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后，我们就可以来调试这个程序了。</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">~/syscall# gdb ./a.out
GNU gdb (Ubuntu 8.1-0ubuntu3.1) 8.1.0.20180409-git
......
Reading symbols from ./a.out...done.
(gdb) l
1       #include &lt;stdio.h&gt;
2       #include &lt;stdlib.h&gt;
3       #include &lt;unistd.h&gt;
4       #include &lt;linux/kernel.h&gt;
5       #include &lt;sys/syscall.h&gt;
6       #include &lt;string.h&gt;
7
8       int main ()
9       {
10        char * words = "I am liuchao from user mode.";
(gdb) b 10
Breakpoint 1 at 0x6e2: file syscall.c, line 10.
(gdb) r
Starting program: /root/syscall/a.out

Breakpoint 1, main () at syscall.c:10
10        char * words = "I am liuchao from user mode.";
(gdb) n
12        ret = syscall(333, words, strlen(words)+1);
(gdb) p words
$1 = 0x5555555547c4 "I am liuchao from user mode."
(gdb) s
__strlen_sse2 () at ../sysdeps/x86_64/multiarch/../strlen.S:79
(gdb) bt
#0  __strlen_sse2 () at ../sysdeps/x86_64/multiarch/../strlen.S:79
#1  0x00005555555546f9 in main () at syscall.c:12
(gdb) c
Continuing.
return 63 from kernel mode.
[Inferior 1 (process 1774) exited normally]
(gdb) q<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上面的例子中，我们只要掌握简单的几个gdb的命令就可以了。</p>
<ul>
<li>l，即list，用于显示多行源代码。</li>
<li>b，即break，用于设置断点。</li>
<li>r，即run，用于开始运行程序。</li>
<li>n，即next，用于执行下一条语句。如果该语句为函数调用，则不会进入函数内部执行。</li>
<li>p，即print，用于打印内部变量值。</li>
<li>s，即step，用于执行下一条语句。如果该语句为函数调用，则进入函数，执行其中的第一条语句。</li>
<li>c，即continue，用于继续程序的运行，直到遇到下一个断点。</li>
<li>bt，即backtrace，用于产看函数调用信息。</li>
<li>q，即quit，用于退出gdb环境。</li>
</ul>
<h4 id="55-2-Debug-kernel"><a href="#55-2-Debug-kernel" class="headerlink" title="55.2 Debug kernel"></a>55.2 Debug kernel</h4><p>看了debug一个进程还是简单的，接下来，我们来试着debug整个kernel。</p>
<p>第一步，要想kernel能够被debug，需要向上面编译程序一样，将debug所需信息也放入二进制文件里面去。这个我们在编译内核的时候已经设置过了，也就是把“CONFIG_DEBUG_INFO”和“CONFIG_FRAME_POINTER“两个变量设置为yes。</p>
<p>第二步，就是安装gdb。kernel运行在qemu虚拟机里面，gdb运行在宿主机上，所以我们应该在宿主机上进行安装。</p>
<p>第三步，找到gdb要运行的那个内核的二进制文件。这个文件在哪里呢？根据grub里面的配置，它应该在/boot/vmlinuz-4.15.18这里。</p>
<p>另外，为了方便在debug的过程中查看源代码，我们可以将/usr/src/linux-source-4.15.0整个目录，都拷贝到宿主机上来。因为内核一旦进入debug模式，就不能运行了。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">scp</span> -r popsuper@192.168.57.100:/usr/src/linux-source-4.15.0 ./<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在/usr/src/linux-source-4.15.0这个目录下面，vmlinux文件也是内核的二进制文件。</p>
<p>第四步，修改qemu的启动参数和qemu里面虚拟机的启动参数，从而使得gdb可以远程attach到qemu里面的内核上。</p>
<p>我们知道，gdb debug一个进程的时候，gdb会监控进程的运行，使得进程一行一行地执行二进制文件。如果像syscall.c的二进制文件a.out一样，就在本地，gdb可以通过attach到这个进程上，作为这个进程的父进程，来监控它的运行。</p>
<p>但是，gdb debug一个内核的时候，因为内核在qemu虚拟机里面，所以我们无法监控本地进程，而要通过qemu来监控qemu里面的内核，这就要借助qemu的机制。</p>
<p>qemu有个参数-s，它代表参数-gdb tcp::1234，意思是qemu监听1234端口，gdb可以attach到这个端口上来，debug qemu里面的内核。</p>
<p>为了完成这一点，我们需要修改ubuntutest这个虚拟机的定义文件。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">virsh</span> edit ubuntutest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在这里，我们能将虚拟机的定义文件修改成下面的样子，其中主要改了两项：</p>
<ul>
<li><p>在domain的最后加上了qemu:commandline，里面指定了参数-s；</p>
</li>
<li><p>在domain中添加xmlns:qemu。没有这个XML的namespace，qemu:commandline这个参数libvirt不认。</p>
  <pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>domain</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>qemu<span class="token punctuation">'</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>qemu</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>http://libvirt.org/schemas/domain/qemu/1.0<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">&gt;</span></span>ubuntutest<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>uuid</span><span class="token punctuation">&gt;</span></span>0f0806ab-531d-6134-5def-c5b4955292aa<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>uuid</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>memory</span> <span class="token attr-name">unit</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>KiB<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>8388608<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>memory</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>currentMemory</span> <span class="token attr-name">unit</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>KiB<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>8388608<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>currentMemory</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>vcpu</span> <span class="token attr-name">placement</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>static<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>vcpu</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>os</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span> <span class="token attr-name">arch</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>x86_64<span class="token punctuation">'</span></span> <span class="token attr-name">machine</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>pc-i440fx-trusty<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>hvm<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>boot</span> <span class="token attr-name">dev</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>hd<span class="token punctuation">'</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>os</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>clock</span> <span class="token attr-name">offset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>utc<span class="token punctuation">'</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>on_poweroff</span><span class="token punctuation">&gt;</span></span>destroy<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>on_poweroff</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>on_reboot</span><span class="token punctuation">&gt;</span></span>restart<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>on_reboot</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>on_crash</span><span class="token punctuation">&gt;</span></span>restart<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>on_crash</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>devices</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>emulator</span><span class="token punctuation">&gt;</span></span>/usr/bin/qemu-system-x86_64<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>emulator</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>disk</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>file<span class="token punctuation">'</span></span> <span class="token attr-name">device</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>disk<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>driver</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>qemu<span class="token punctuation">'</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>qcow2<span class="token punctuation">'</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">file</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>/mnt/vdc/ubuntutest.img<span class="token punctuation">'</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>backingStore</span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>target</span> <span class="token attr-name">dev</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>vda<span class="token punctuation">'</span></span> <span class="token attr-name">bus</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>virtio<span class="token punctuation">'</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>alias</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>virtio-disk0<span class="token punctuation">'</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>address</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>pci<span class="token punctuation">'</span></span> <span class="token attr-name">domain</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>0x0000<span class="token punctuation">'</span></span> <span class="token attr-name">bus</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>0x00<span class="token punctuation">'</span></span> <span class="token attr-name">slot</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>0x04<span class="token punctuation">'</span></span> <span class="token attr-name">function</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>0x0<span class="token punctuation">'</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>disk</span><span class="token punctuation">&gt;</span></span>
......
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>interface</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>bridge<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mac</span> <span class="token attr-name">address</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>fa:16:3e:6e:89:ce<span class="token punctuation">'</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">bridge</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>br0<span class="token punctuation">'</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>target</span> <span class="token attr-name">dev</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>tap1<span class="token punctuation">'</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>model</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>virtio<span class="token punctuation">'</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>alias</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>net0<span class="token punctuation">'</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>address</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>pci<span class="token punctuation">'</span></span> <span class="token attr-name">domain</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>0x0000<span class="token punctuation">'</span></span> <span class="token attr-name">bus</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>0x00<span class="token punctuation">'</span></span> <span class="token attr-name">slot</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>0x03<span class="token punctuation">'</span></span> <span class="token attr-name">function</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>0x0<span class="token punctuation">'</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>interface</span><span class="token punctuation">&gt;</span></span>
......
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>devices</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">qemu:</span>commandline</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">qemu:</span>arg</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>-s<span class="token punctuation">'</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">qemu:</span>commandline</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>domain</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另外，为了远程debug成功，我们还需要修改qemu里面的虚拟机的grub和menu.list，在内核命令行中添加nokaslr，来关闭KASLR。KASLR会使得内核地址空间布局随机化，从而会造成我们打的断点不起作用。</p>
</li>
</ul>
<p>对于grub.conf，修改如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">submenu 'Advanced options for Ubuntu' $menuentry_id_option 'gnulinux-advanced-470f3a42-7a97-4b9d-aaa0-26deb3d234f9' {
        menuentry 'Ubuntu, with Linux 4.15.18' --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-4.15.18-advanced-470f3a42-7a97-4b9d-aaa0-26deb3d234f9' {
                recordfail
                load_video
                gfxmode $linux_gfx_mode
                insmod gzio
                if [ x$grub_platform = xxen ]; then insmod xzio; insmod lzopio; fi
                insmod part_gpt
                insmod ext2
                if [ x$feature_platform_search_hint = xy ]; then
                  search --no-floppy --fs-uuid --set=root  470f3a42-7a97-4b9d-aaa0-26deb3d234f9
                else
                  search --no-floppy --fs-uuid --set=root 470f3a42-7a97-4b9d-aaa0-26deb3d234f9
                fi
                echo    'Loading Linux 4.15.18 ...'
                linux   /boot/vmlinuz-4.15.18 root=UUID=470f3a42-7a97-4b9d-aaa0-26deb3d234f9 ro nokaslr console=ttyS0 maybe-ubiquity
                echo    'Loading initial ramdisk ...'
                initrd  /boot/initrd.img-4.15.18
        }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于menu.list，修改如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">title           Ubuntu 18.04.2 LTS, kernel 4.15.18
root            (hd0)
kernel          /boot/vmlinuz-4.15.18 root=/dev/hda1 ro nokaslr console=hvc0 console=ttyS0
initrd          /boot/initrd.img-4.15.18<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>修改完毕后，我们需要在虚拟机里面shutdown -h now，来关闭虚拟机。注意不要reboot，因为虚拟机里面运行reboot，我们改过的那个XML会不起作用。</p>
<p>当我们在宿主机上发现虚拟机关机之后，就可以通过virsh start ubuntutest启动虚拟机，这个时候我们添加的参数-s才起作用。</p>
<p>第五步，使用gdb运行内核的二进制文件，执行gdb vmlinux。</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">/mnt/vdc/linux-source-4.15.0# gdb vmlinux
GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1
......
To enable execution of this file add
        add-auto-load-safe-path /mnt/vdc/linux-source-4.15.0/vmlinux-gdb.py
......
(gdb) b sys_sayhelloworld
Breakpoint 1 at 0xffffffff8109e2f0: file kernel/sys.c, line 192.
(gdb) target remote :1234
Remote debugging using :1234
native_safe_halt () at ./arch/x86/include/asm/irqflags.h:61
61      }
(gdb) c
Continuing.
[Switching to Thread 2]
Thread 2 hit Breakpoint 1, sys_sayhelloworld (words=0x563cbfa907c4 "I am liuchao from user mode.", count=29) at kernel/sys.c:192
192     {
(gdb) bt
#0  sys_sayhelloworld (words=0x55b2811537c4 "I am liuchao from user mode.", count=29) at kernel/sys.c:192
#1  0xffffffff810039f7 in do_syscall_64 (regs=0xffffc9000133bf58) at arch/x86/entry/common.c:290
#2  0xffffffff81a00081 in entry_SYSCALL_64 () at arch/x86/entry/entry_64.S:237
(gdb) n
195             if(count &gt;= 1024){
(gdb) n
198             copy_from_user(buffer, words, count);
(gdb) n
199             ret=printk("User Mode says %s to the Kernel Mode!", buffer);
(gdb) p buffer
$1 = "I am liuchao from user mode.\000\177\000\000\...
(gdb) n
200             return ret;
(gdb) p ret
$2 = 63
(gdb) c
(gdb) n
do_syscall_64 (regs=0xffffc9000133bf58) at arch/x86/entry/common.c:295
295             syscall_return_slowpath(regs);
(gdb) s
syscall_return_slowpath (regs=&lt;optimized out&gt;) at arch/x86/entry/common.c:295
(gdb) n
268             prepare_exit_to_usermode(regs);
(gdb) n
do_syscall_64 (regs=0xffffc9000133bf58) at arch/x86/entry/common.c:296
296     }
(gdb) n
entry_SYSCALL_64 () at arch/x86/entry/entry_64.S:246
246             movq    RCX(%rsp), %rcx
......
(gdb) n
entry_SYSCALL_64 () at arch/x86/entry/entry_64.S:330
330             USERGS_SYSRET64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们先设置一个断点在我们自己写的系统调用上b sys_sayhelloworld，通过执行target remote :1234，来attach到qemu上，然后，执行c，也即continue运行内核。这个时候内核始终在Continuing的状态，也即持续在运行中，这个时候我们可以远程登录到qemu里的虚拟机上，执行各种命令。</p>
<p>如果我们在虚拟机里面运行syscall.c编译好的a.out，这个时候肯定会调用到内核。内核肯定会经过系统调用的过程，到达sys_sayhelloworld这个函数，这就碰到了我们设置的那个断点。</p>
<p>如果执行bt，我们能看到，这个系统调用是从entry_64.S里面的entry_SYSCALL_64 ()函数，调用到do_syscall_64函数，再调用到sys_sayhelloworld函数的。这一点和我们在<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/90394">系统调用</a>那一节分析的过程是一模一样的。</p>
<p>我们可以通过执行next命令，来看sys_sayhelloworld一步一步是怎么执行的，通过p buffer查看buffer里面的内容。在这个过程中，由于内核是逐行运行的，因而我们在虚拟机里面的命令行是卡死的状态。</p>
<p>当我们不断地next，直到执行完毕sys_sayhelloworld的时候，会看到，do_syscall_64会调用syscall_return_slowpath。它会调用prepare_exit_to_usermode，然后会回到entry_SYSCALL_64，然后对于寄存器进行操作，最后调用指令USERGS_SYSRET64回到用户态。这个返回的过程和系统调用那一节也一模一样。</p>
<p>看，通过debug我们能够跟踪系统调用的整个过程。你可以将我们这一门课里面学得的所有的过程都debug一下，看看变量的值，从而对于内核的工作机制有更加深入的了解。</p>
<h4 id="55-3-总结"><a href="#55-3-总结" class="headerlink" title="55.3 总结"></a>55.3 总结</h4><p>在这个课程里面，我们写过一些程序，为了保证程序能够顺利运行，我一般会将代码完整地放到文本中，让你拷贝下来就能编译和运行。如果你运行的时候发现有问题，或者想了解一步一步运行的细节，这一节介绍的gdb是一个很好的工具。</p>
<p>这一节你尤其应该掌握的是，如何通过宿主机上的gdb来debug虚拟机里面的内核。这一点非常重要，会了这个，你就能够返回去，挨个研究每一章每一节的内核数据结构和运行逻辑了。</p>
<p>在这门课中，进程管理、内存管理、文件管理、设备管理网络管理，我们都介绍了从系统调用到底层的整个逻辑。如果你对我前面的代码解析还比较困惑，你可以尝试着去debug这些过程，只要把断点打在系统调用的入口位置就可以了。</p>
<p>从此，开启你的内核debug之旅吧！</p>
<h2 id="十一、知识串讲"><a href="#十一、知识串讲" class="headerlink" title="十一、知识串讲"></a>十一、知识串讲</h2><h3 id="56-用一个创业故事串起操作系统原理（一）"><a href="#56-用一个创业故事串起操作系统原理（一）" class="headerlink" title="56. 用一个创业故事串起操作系统原理（一）"></a>56. 用一个创业故事串起操作系统原理（一）</h3><p>操作系统是一门体系复杂、知识点很多的课程，经过这么多节的讲解，你是否已经感觉自己被淹没在细节的汪洋大海里面了？没关系，从这一节开始，我们用五节的时间，通过一个创业故事，串起来操作系统的整个知识体系。</p>
<p>接下来，我们就来看主人公是如何从小马，变成马哥，再变成马总的吧！</p>
<p>操作系统是一门体系复杂、知识点很多的课程，经过这么多节的讲解，你是否已经感觉自己被淹没在细节的汪洋大海里面了？没关系，从这一节开始，我们用五节的时间，通过一个创业故事，串起来操作系统的整个知识体系。</p>
<p>接下来，我们就来看主人公是如何从小马，变成马哥，再变成马总的吧！</p>
<h4 id="56-1-小马创业选园区，开放标准是第一"><a href="#56-1-小马创业选园区，开放标准是第一" class="headerlink" title="56.1 小马创业选园区，开放标准是第一"></a>56.1 小马创业选园区，开放标准是第一</h4><p>小马最终还是决定走出大公司，自己去创业了。</p>
<p>他之所以这样决定，有两个原因，一方面，大企业多年的工作经验让他练就了从前端到后端，从Web到App，从产品设计到测试交付的全栈能力。他很自信，靠着这些能力，闯荡江湖应该没什么问题；另外一方面，他听说，姓“马”的，创业成功的概率好像比较大。</p>
<p>创业首先要注册公司。注册公司就需要有一个办公地点。所以，小马需要选择一个适合创业的环境。他找了很多地方，发现有的地方政策倾斜大型企业，有的地方倾斜本地企业，有的地方鼓励金融创新。小马感觉这些地方都不太适合他这个IT男。</p>
<p>直到有一天，小马来到了位于杭州滨江的x86创业园区。他被深深地吸引住了，当然首要吸引他的就是园区工作人员的热情。</p>
<p>园区的工作人员向小马介绍了以下信息。</p>
<p>“首先，咱们这个x86园区，主要有三大特点，一是标准，二是开放，三是兼容。像您这种创业者还是非常多的。初次创业不一定有经验，园区提供标准的企业运行流程辅导。”</p>
<p>“另外，我们园区秉承完全开放的态度，对待各种各样的企业。不封闭，不保守。只要您符合国家的法律法规，我们都接纳。而且，整个园区是一种开放合作的生态，也有利于不同企业之间的协作。”</p>
<p>“再就是兼容。我们园区的流程和规则的设计都会兼容历史上的既有政策，既不会朝令夕改，也不会因为变化而影响您公司的运转。总而言之，来了咱们园区，您就埋头干业务就可以啦！”</p>
<p>小马显然对于x86园区的开放性十分满意，于是追问道：“您刚才说的企业运行流程辅导，能详细介绍一下吗？将来我这个企业在这个园区，应该怎么个运转法儿？”</p>
<p>工作人员接着说：“咱们这个园区毗邻全国知名高校，每年都有大量的优秀毕业生来园区找工作，这是企业非常重要的人才来源。葛优说了，二十一世纪了，人才是核心嘛。每年我们园区都会招聘大量的毕业生，先进行一个月的培训，合格毕业的可以推荐给您这种企业。这些人才啊，就是咱们企业的CPU。”</p>
<p>“经过我们园区培训过的‘CPU人才’，具备了三种老板们喜欢的核心竞争力：</p>
<p>第一，实干能力强，干活快，我们称为运算才能——也即指令执行能力；</p>
<p>第二，记忆力好，记得又快又准，我们称为数据才能——也即数据寄存能力；</p>
<p>第三，听话，自控能力强，可以多任务并发执行，我们称为控制才能——也即指令寄存能力。</p>
<p>到时候，你可以根据需求，看雇佣多少个‘CPU人才’。</p>
<p>另外，人才得有个办公的地方，这一片呢，就是我们的办公区域，称为也就是内存区域。您可以包几个工位，或者包一片区域，或者几个会议室，让您公司的人才在里面做项目就可以了。这里面有的是地方，同时运行多少各项目都行。”</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/用一个创业故事串起操作系统原理（一）1.jpeg" alt="用一个创业故事串起操作系统原理（一）1"></p>
<p>跟着工作人员的介绍，小马走在x86园区中，看着这一片片的内存办公区，脑子里已经浮现出将来热火朝天的办公场景了。</p>
<p>“也许不到半年的时间，我肯定能够接两三个大项目，招聘十个八个CPU员工。那项目A的员工就坐在这片内存办公区，项目B的员工就坐在那片内存办公区。我根据积累的人脉，将接到的项目写成一个一个的项目执行计划书，里面是一行行项目执行的指令，这些指令操作数据产生一些结果，我们就可以叫程序啦。”小马这么想着。</p>
<p>“然后呢，我把不同的项目执行计划书，交给不同的项目组去执行。那项目组就叫进程吧！两个项目组，进程A和B，会有独立的内存办公空间，互相隔离，程序会分别加载到进程A和进程B的内存办公空间里面，形成各自的代码段。要操作的数据和产生的结果，就放在数据段里面。“</p>
<p>“除此之外，我应该找一个或者多个CPU员工来运行项目执行计划书，我只要告诉他下一条指令在内存办公区中的地址，经过训练的CPU员工就会很自觉地、不停地将代码段的指令拿进来进行处理。“</p>
<p>“指令一般是分两部分，一部分表示做什么操作，例如是加法还是位移；另一部分是操作哪些数据。数据的部分，CPU员工会从数据段里面读取出来，记在脑子里，然后进行处理，处理完毕的结果，在写回数据段。当项目执行计划书里面的所有指令都执行完毕之后，项目也就完成了，那就可以等着收钱啦。”</p>
<p>小马沉浸在思绪中久久不能自拔，直到工作人员打断了他的思绪：“您觉得园区如何？要不要入住呀？先租几个工位，招聘几个人呢？“</p>
<p>小马想了想，说道：“园区我很满意，以后就在您这里创业了，创业开始，我先不招人，自己先干吧。”</p>
<h4 id="56-2-启动公司有手册，获取内核当宝典"><a href="#56-2-启动公司有手册，获取内核当宝典" class="headerlink" title="56.2 启动公司有手册，获取内核当宝典"></a>56.2 启动公司有手册，获取内核当宝典</h4><p>工作人员说：“感谢您入驻咱们创业园区，由于您是初次创业，这里有一本《创业指导手册》，在这一本叫作BIOS的小册子上，有您启动一家公司的通用流程，你只要按照里面做就可以了。”</p>
<p>小马接过BIOS小册子，开始按照里面的指令启动公司了。</p>
<p>创业初期，小马的办公室肯定很小，只有有1M的内存办公空间。在1M空间最上面的0xF0000到0xFFFFF这64K映射给ROM，通过读这部分地址，可以访问这个BIOS小册子里面的指令。</p>
<p>创业指导手册第一条，BIOS要检查一些系统的硬件是不是都好着呢。创业指导手册第二条，要有个办事大厅，只不过小马自己就是办事员。因为一旦开张营业，就会有人来找到这家公司，因而基本的中断向量表和中断服务程序还是需要的，至少要能够使用键盘和鼠标。</p>
<p>BIOS这个手册空间有限，只能帮小马把公司建立起来，公司如何运转和经营，就需要另外一个东西——《企业经营宝典》，因而BIOS还要做的一件事情，就是帮助小马找到这个宝典，然后让小马以后根据这个宝典里面的方法来经营公司，这个《企业经营宝典》就是这家公司的内核。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/系统启动过程.jpeg" alt="系统启动过程"></p>
<p>运营一个企业非常的复杂，因而这本《企业经营宝典》也很厚，BIOS手册无法直接加载出来，而需要从门卫开始问起，不断打听这本内核的位置，然后才能加载他。</p>
<p>门卫只有巴掌大的一块地方，在启动盘的第一个扇区，512K的大小，我们通常称为MBR（Master Boot Record，主引导记录/扇区）。这里保存了boot.img，BIOS手册会将他加载到内存中的0x7c00来运行。</p>
<p>boot.img做不了太多的事情。他能做的最重要的一个事情，就是加载grub2的另一个镜像core.img。</p>
<p>引导扇区就是小马找到的门卫，虽然他看着档案库的大门，但是知道的事情很少。他不知道宝典在哪里，但是，他知道应该问谁。门卫说，档案库入口处有个管理处，然后把小马领到门口。</p>
<p>core.img就是管理处，他们知道的和能做的事情就多了一些。core.img由lzma_decompress.img、diskboot.img、kernel.img和一系列的模块组成，功能比较丰富，能做很多事情。</p>
<p>boot.img将控制权交给diskboot.img后，diskboot.img的任务就是将core.img的其他部分加载进来，先是解压缩程序lzma_decompress.img，再往下是kernel.img，最后是各个模块module对应的映像。</p>
<p>管理处听说小马要找宝典，知道他将来是要做老板的人。管理处就告诉小马，既然是老板，早晚都要雇人干活的。这不是个体户小打小闹，所以，你需要切换到老板角色，进入保护模式，把哪些是你的权限，哪些是你可以授权给别人的，都分得清清楚楚。</p>
<p>这些，小马都铭记在心，此时此刻，虽然公司还是只有他一个人，但是小马的眼界放宽了，能够管理的内存空间大多了，也开始区分哪些是用户态，哪些是内核态了。</p>
<p>接下来，kernel.img里面的grub_main会给小马展示一个《企业经营宝典》的列表，也即操作系统的列表，让小马进行选择。经营企业的方式也有很多种，到底是人性化的，还是强纪律的，这个时候你要做一个选择。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/用一个创业故事串起操作系统原理（一）3.png" alt="用一个创业故事串起操作系统原理（一）3"></p>
<p>在这里，小马毫不犹豫地选择了《狼性文化》操作系统，至此grub才开始启动《狼性文化》操作系统内核。</p>
<p>拿到了宝典的小马，开始越来越像一个老板了。他要开始以老板的思维，来建立这家公司。</p>
<h4 id="56-3-初创公司有章法，请来兄弟做臂膀"><a href="#56-3-初创公司有章法，请来兄弟做臂膀" class="headerlink" title="56.3 初创公司有章法，请来兄弟做臂膀"></a>56.3 初创公司有章法，请来兄弟做臂膀</h4><p>这注定是一个不眠夜，办公室里面一片漆黑中，唯一亮着的台灯下，小马独自捧着《企业经营宝典》仔细研读，读着读着，小马若有所思，开始书写公司内核的初始化计划。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/用一个创业故事串起操作系统原理（一）4.jpeg" alt="用一个创业故事串起操作系统原理（一）4"></p>
<p>公司首先应该有个项目管理部门，咱们将来肯定要接各种各样的项目，因此，项目管理体系和项目管理流程首先要建立起来。虽然现在还没有项目，但是小马还是弄了一个项目模板init_task。这是公司的第一个项目（进程），是项目管理系统里面的项目列表中的第一个，我们能称为0号进程。这个项目是虚拟的，不对应一个真实的项目（也就是进程）。</p>
<p>项目需要项目管理进行调度，还需要制定一些调度策略。</p>
<p>另外，为了快速响应客户需求，为了各个项目组能够方便地使用公司的公共资源，还应该有一个办事大厅。这里面可以设置了很多中断门（Interrupt Gate），用于处理各种中断，以便快速响应突发事件；还可以提供系统调用，为项目组服务。</p>
<p>如果项目接得多了，为了提高研发效率，对项目内容进行保密，就需要封闭开发，所以将来会有很多的会议室，因而还需要一个会议室管理系统。</p>
<p>项目的执行肯定会留下很多文档，这些是公司的积累，将来的核心竞争力，一定要好好管理，因而应该建立一个项目档案库，也即文件系统。</p>
<p>随着思绪的展开，小马奋笔疾书，已经写了满满的几页纸，小马顿感经营一个公司还是挺复杂的，一旦项目接多了肯定忙不过来。俗话说得好，“一个好汉三个帮”，小马准备找两个兄弟来一起创业。</p>
<p>小马想到的第一个人，是自己的大学室友，外号“周瑜”。大学一毕业，周瑜就转项目管理了，在一家大公司管理着大型项目。将来外部接了项目，可以让他来管。小马想到的第二个人，是自己上一家公司的同事，外号“张昭”，是他们总经理的好帮手，公司的流程、人事、财务打理得都轻轻楚楚，将来公司内部要运行的井井有条，也需要这样一个人。</p>
<p>第二天，小马请周瑜和张昭吃饭，邀请他们加入他的创业公司。小马说，公司要正规运转起来，应该分清内外，外部项目需要有人帮忙管理好——也就是用户态，内部公司的核心资源也需要管理好——也就是内核态。现在我一个人忙不过来，需要两位兄弟的加入，周瑜主外，张昭主内，正所谓，内事不决问张昭，外事不决问周郎嘛。</p>
<p>三个人相谈甚欢，谈及往日友谊、未来前景、上市敲钟……</p>
<p>第三天，周瑜早早就来到公司，开始了他的事业。小马拜托周瑜做的第一件事情是调用kernel_init运行1号项目（进程）。这个1号项目会在用户态运行init项目（进程）。这是第一个以外部项目的名义运行的，之所以叫init，就是做初始化的工作，周瑜根据自己多年的项目管理经验，将这个init项目立为标杆，以后所有外部项目的运行都要按照他来，是外部项目的祖先项目。</p>
<p>下午，张昭也来到了公司，小马拜托张昭做的第一件事情是调用kthreadd运行2号项目（进程）。这个2号项目是内核项目的祖先。将来所有的项目都有父项目、祖先项目，会形成一棵项目树。公司大了之后，周瑜和张昭做的公司VP级别的任务，就可以坐在塔尖上了。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/linux进程树.jpeg" alt="linux进程树"></p>
<p>好了，这一节小马终于将公司的架子搭起来了，兄弟三人如当年桃园三结义一样，开始自己的创业生涯，小马的这家公司能不能顺利接到项目呢？欲知后事，且听下回分解。</p>
<h3 id="57-用一个创业故事串起操作系统原理（二）"><a href="#57-用一个创业故事串起操作系统原理（二）" class="headerlink" title="57. 用一个创业故事串起操作系统原理（二）"></a>57. 用一个创业故事串起操作系统原理（二）</h3><p>上一节说到小马同学的公司已经创立了，还请来了周瑜和张昭作为帮手，所谓“兄弟齐心，其利断金”。可是，现在这家公司，还得从接第一个外部项目开始。</p>
<h4 id="57-1-首个项目虽简单，项目管理成体系"><a href="#57-1-首个项目虽简单，项目管理成体系" class="headerlink" title="57.1 首个项目虽简单，项目管理成体系"></a>57.1 首个项目虽简单，项目管理成体系</h4><p><img src="/images/《趣谈Linux操作系统》学习笔记/进程从代码到二进制到运行的过程.jpeg" alt="进程从代码到二进制到运行的过程"></p>
<p>这第一个项目，还是小马亲自去谈的。其实软件公司了解客户需求还是比较难的，因为客户都说着接近人类的语言，例如C/C++。这些咱们公司招聘的CPU小伙伴们可听不懂，需要有一个人将客户需求，转换为项目执行计划书，CPU小伙伴们才能执行，这个过程我们称为编译。</p>
<p>编译其实是一个需求分析和需求转换的过程。这个过程会将接近人类的C/C++语言，转换为CPU小伙伴能够听懂的二进制语言，并且以一定的文档格式，写成项目执行计划书。这种文档格式是作为一个标准化的公司事先制定好的一种格式，是周瑜从大公司里面借鉴来的，称为ELF格式，这个项目执行计划书有总论ELF Header的部分，有包含指令的代码段的部分，有包含全局变量的数据段的部分。</p>
<p>小马和客户聊了整整一天，确认了项目的每一个细节，保证编译能够通过，才写成项目执行计划书ELF文件，放到档案库中。此时已经半夜了。</p>
<p>第二天，周瑜一到公司，小马就兴奋地给周瑜说，“我昨天接到了第一个项目，而且是一个大项目，项目执行计划书我都写好了，你帮我监督、执行、管理，记得按时交付哦！”</p>
<p>周瑜说，“没问题。”于是，周瑜从父项目开始，fork一个子项目，然后在子项目中，调用exec系统调用， 然后到了内核里面，通过load_elf_binary将项目执行计划书加载到子进程内存中，交给一个CPU执行。</p>
<p>虽然这是第一个项目，以周瑜的项目管理经验，他告诉小马，项目的执行要保质保量，需要有一套项目管理系统来管理项目的状态，而不能靠脑子记。“项目管理系统？当然应该有了”，小马说。他在《企业经营宝典》中看到过。</p>
<p>于是，项目管理系统就搭建起来了。在这里面，所有项目都放在一个task_struct列表中，对于每一个项目，都非常详细地登记了项目方方面面的信息。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/fork复制结构.png" alt="fork复制结构"></p>
<p>每一个项目都应该有一个ID，作为这个项目的唯一标识。到时候排期啊、下发任务啊等等，都按ID来，就不会产生歧义。</p>
<p>项目应该有运行中的状态，TASK_RUNNING并不是说进程正在运行，而是表示进程在时刻准备运行的状态。这个时候，要看CPU小伙伴有没有空，有空就运行他，没空就得等着。</p>
<p>有时候，进程运行到一半，需要等待某个条件才能运行下去，这个时候只能睡眠。睡眠状态有两种。一种是TASK_INTERRUPTIBLE，可中断的睡眠状态。这是一种浅睡眠的状态，也就是说，虽然在睡眠，等条件成熟，进程可以被唤醒。</p>
<p>另一种睡眠是TASK_UNINTERRUPTIBLE，不可中断的睡眠状态。这是一种深度睡眠状态，不可被唤醒，只能死等条件满足。有了一种新的进程睡眠状态，TASK_KILLABLE，可以终止的新睡眠状态。进程处于这种状态中，他的运行原理类似TASK_UNINTERRUPTIBLE，只不过可以响应致命信号，也即虽然在深度睡眠，但是可以被干掉。</p>
<p>一旦一个进程要结束，先进入的是EXIT_ZOMBIE状态，但是这个时候他的父进程还没有使用wait()等系统调用来获知他的终止信息，此时进程就成了僵尸进程。</p>
<p>EXIT_DEAD是进程的最终状态。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/任务状态.jpeg" alt="任务状态"></p>
<p>另外，项目运行的统计信息也非常重要。例如，有的员工很长时间都在做一个任务，这个时候你就需要特别关注一下；再如，有的员工的琐碎任务太多，这会大大影响他的工作效率。</p>
<p>那如何才能知道这些员工的工作情况呢？在进程的运行过程中，会有一些统计量，例如进程在用户态和内核态消耗的时间、上下文切换的次数等等。</p>
<p>项目之间的亲缘关系也需要维护，任何一个进程都有父进程。所以，整个进程其实就是一棵进程树。而拥有同一父进程的所有进程都具有兄弟关系。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/进程亲缘关系.jpeg" alt="进程亲缘关系"></p>
<p>另外，对于项目来讲，项目组权限的控制也很重要。什么是项目组权限控制呢？这么说吧，我这个项目组能否访问某个文件，能否访问其他的项目组，以及我这个项目组能否被其他项目组访问等等</p>
<p>另外，项目运行过程中占用的公司的资源，例如会议室（内存）、档案库（文件系统）也需要在项目管理系统里面登记。</p>
<p>周瑜同学将项目登记好，然后就分配给CPU同学们说，开始执行吧。</p>
<p>好在第一个项目还是比较简单的，一个CPU同学按照项目执行计划书按部就班一条条的执行，很快就完成了，客户评价还不错，很快收到了回款。</p>
<h4 id="57-2-项目大了要并行，项目多了要排期"><a href="#57-2-项目大了要并行，项目多了要排期" class="headerlink" title="57.2 项目大了要并行，项目多了要排期"></a>57.2 项目大了要并行，项目多了要排期</h4><p>小马很开心，可谓开门红。接着，第二个项目就到来了，这可是一个大项目，要帮一家知名公司开发一个交易网站，共200个页面，这下要赚翻了，就是时间要的比较急，要求两个星期搞定。</p>
<p>小马把项目带回来，周瑜同学说，这个项目有点大，估计一个CPU同学干不过来了，估计要多个CPU同学一起协作了。</p>
<p>为了完成这个大的项目（进程），就不能一个人从头干到尾了，这样肯定赶不上工期。于是，周瑜将一个大项目拆分成20个子项目，每个子项目完成10个页面，一个大项目组也分成20个小组，并行开发，都开发完了，再做一次整合，这肯定比依次开发200个页面快多了。如果项目叫进程，那子项目就叫线程。</p>
<p>在Linux里面，无论是进程，还是线程，到了内核里面，我们统一都叫任务，由一个统一的结构task_struct进行管理。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/Linux中的任务.jpeg" alt="Linux中的任务"></p>
<p>不知道是好消息，还是坏消息，这么大一个项目还没有做完，新的项目又找上门了。看来有了前面的标杆客户，名声算是打出去了，一个项目接一个地不停。</p>
<p>小马是既高兴，又犯愁，于是找周瑜和张昭商量应该咋办。要不多招人？多来几个CPU小伙伴，就不搞定了？可是咱们还是在创业阶段，养不起这么多人。另外的办法就是，人力复用，一个CPU小伙伴干多个项目，干不过来，就加加班，实在不行就996，这样应该就没问题了。</p>
<p>一旦涉及一个CPU小伙伴同时参与多个项目，就非常考验项目管理的水平了。如何排期、如何调度，是一个大学问。例如，有的项目比较紧急，应该先进行排期；有的项目可以缓缓，但是也不能让客户等太久。所以这个过程非常复杂，需要平衡。</p>
<p>对于操作系统来讲，他面对的CPU的数量是有限的，干活儿都是他们，但是进程数目远远超过CPU的数目，因而就需要进行进程的调度，有效地分配CPU的时间，既要保证进程的最快响应，也要保证进程之间的公平。</p>
<p>如何调度呢？周瑜能够想到的方式就是排队。每一个CPU小伙伴旁边都有一个白板，上面写着自己需要完成的任务，来了新任务就写到白板上，做完了就擦掉。</p>
<p>一个CPU上有一个队列，队列里面是一系列sched_entity，每个sched_entity都属于一个task_struct，代表进程或者线程。</p>
<p>调度要解决的第一个问题是，每一个CPU小伙伴每过一段时间，都要想一下，白板上这么多项目，我应该干哪一个？CPU的队列里面有这么多的进程或者线程，应该取出哪一个来执行？</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/调度总结（上）.jpeg" alt="调度总结（上）"></p>
<p>这就是调度规则或者调度算法的问题。</p>
<p>周瑜说，他原来在大公司的时候，调度算法常用是这样设计的。</p>
<p>一个是公平性，对于接到的多个项目，不能厚此薄彼。这个算法主要由fair_sched_class实现，fair就是公平的意思。</p>
<p>另一个是优先级，有的项目要急一点，客户出的钱多，所以应该多分配一些精力在高优先级的项目里面。</p>
<p>在Linux里面，讲究的公平可不是一般的公平，而是CFS调度算法，CFS全称是Completely Fair Scheduling，完全公平调度。</p>
<p>为了公平，项目经理需要记录下进程的运行时间。CPU会提供一个时钟，过一段时间就触发一个时钟中断。就像咱们的表滴答一下，这个我们叫Tick。CFS会为每一个进程安排一个虚拟运行时间vruntime。如果一个进程在运行，随着时间的增长，也就是一个个Tick的到来，进程的vruntime将不断增大。没有得到执行的进程vruntime不变。</p>
<p>显然，那些vruntime少的，原来受到了不公平的对待，需要给他补上，所以会优先运行这样的进程。</p>
<p>这有点儿像让你把一筐球平均分到N个口袋里面，你看着哪个少，就多放一些；哪个多了，就先不放。这样经过多轮，虽然不能保证球完全一样多，但是也差不多公平。</p>
<p>有时候，进程会分优先级，如何给优先级高的进程多分时间呢？</p>
<p>这个简单，就相当于N个口袋，优先级高的袋子大，优先级低的袋子小。这样球就不能按照个数分配了，要按照比例来，大口袋的放了一半和小口袋放了一半，里面的球数目虽然差很多，也认为是公平的。</p>
<p>函数update_curr用于更新进程运行的统计量vruntime ，CFS还需要一个数据结构来对vruntime进行排序，找出最小的那个。在这里使用的是红黑树。红黑树的的节点是sched_entity，里面包含vruntime。</p>
<p>调度算法的本质就是解决下一个进程应该轮到谁运行的问题，这个逻辑在fair_sched_class.pick_next_task中完成。</p>
<p>调度要解决的第二个问题是，什么时候切换任务？也即，什么时候，CPU小伙伴应该停下一个进程，换另一个进程运行？</p>
<p>一个人在做A项目，在某个时刻，换成做B项目去了。发生这种情况，主要有两种方式。</p>
<p>方式一，A项目做着做着，里面有一条指令sleep，也就是要休息一下，或者等待某个I/O事件。那没办法了，要主动让出CPU，然后可以开始做B项目。主动让出CPU的进程，会主动调用schedule()函数。</p>
<p>在schedule()函数中，会通过fair_sched_class.pick_next_task，在红黑树形成的队列上取出下一个进程，然后调用context_switch进行进程上下文切换。</p>
<p>进程上下文切换主要干两件事情，一是切换进程空间，也即进程的内存，也即CPU小伙伴不能A项目的会议室里面干活了，要跑到B项目的会议室去。二是切换寄存器和CPU上下文，也即CPU将当期在A项目中干到哪里了，记录下来，方便以后接着干。</p>
<p>方式二，A项目做着做着，旷日持久，实在受不了了。项目经理介入了，说这个项目A先停停，B项目也要做一下，要不然B项目该投诉了。最常见的现象就是，A进程执行时间太长了，是时候切换到B进程了。这个时候叫作A进程被被动抢占。</p>
<p>抢占还要通过CPU的时钟Tick，来衡量进程的运行时间。时钟Tick一下，是很好查看是否需要抢占的时间点。 时钟中断处理函数会调用scheduler_tick()，他会调用fair_sched_class的task_tick_fair，在这里面会调用update_curr更新运行时间。当发现当前进程应该被抢占，不能直接把他踢下来，而是把他标记为应该被抢占，打上一个标签TIF_NEED_RESCHED。</p>
<p>另外一个可能抢占的场景发生在，当一个进程被唤醒的时候。一个进程在等待一个I/O的时候，会主动放弃CPU。但是，当I/O到来的时候，进程往往会被唤醒。这个时候是一个时机。当被唤醒的进程优先级高于CPU上的当前进程，就会触发抢占。如果应该发生抢占，也不是直接踢走当然进程，而也是将当前进程标记为应该被抢占，打上一个标签TIF_NEED_RESCHED。</p>
<p>真正的抢占还是需要上下文切换，也就是需要那么一个时刻，让正在运行中的进程有机会调用一下schedule。调用schedule有以下四个时机。</p>
<ul>
<li>对于用户态的进程来讲，从系统调用中返回的那个时刻，是一个被抢占的时机。</li>
<li>对于用户态的进程来讲，从中断中返回的那个时刻，也是一个被抢占的时机。</li>
<li>对内核态的执行中，被抢占的时机一般发生在preempt_enable()中。在内核态的执行中，有的操作是不能被中断的，所以在进行这些操作之前，总是先调用preempt_disable()关闭抢占。再次打开的时候，就是一次内核态代码被抢占的机会。</li>
<li>在内核态也会遇到中断的情况，当中断返回的时候，返回的仍然是内核态。这个时候也是一个执行抢占的时机。</li>
</ul>
<p>周瑜和张昭商定了这个规则，然后给CPU小伙伴们交代之后，项目虽然越来越多，但是也井井有条起来。CPU小伙伴不会像原来一样火急火燎，不知所从了。</p>
<p>可是其实对于项目的开发，这家公司还是有严重漏洞的，就是项目的保密问题，不管哪家客户将系统外包出去，肯定也不想让其他公司知道详情。如果解决不好这个问题，没人敢把重要的项目交给这家公司，小马的公司也就永远只能接点边角系统，还是不能保证温饱问题。</p>
<p>那接下来，小马会怎么解决项目之间的保密问题呢？欲知后事，且听下回分解。</p>
<h3 id="58-用一个创业故事串起操作系统原理（三）"><a href="#58-用一个创业故事串起操作系统原理（三）" class="headerlink" title="58. 用一个创业故事串起操作系统原理（三）"></a>58. 用一个创业故事串起操作系统原理（三）</h3><p>上一节我们说到，周瑜和张昭商定了调用schedule的时机。尽管项目越来越多，但是也井井有条。可是我们也说了，不管你的事情做得有多好，项目保密问题都是要解决的重要问题。怎么解决呢？今天我们就来看一看。</p>
<h4 id="58-1-保密需封闭开发，空间小巧妙安排"><a href="#58-1-保密需封闭开发，空间小巧妙安排" class="headerlink" title="58.1 保密需封闭开发，空间小巧妙安排"></a>58.1 保密需封闭开发，空间小巧妙安排</h4><p>慢慢地，小马发现，项目接的多了之后，CPU小伙伴的任务调度问题解决了之后，会议室的使用经常陷入混乱。不同的项目使用会议室的时候，经常冲突，一个项目组没用完，另一个项目组就在那里等着，十分耽误开发效率。</p>
<p>小马说：“要不咱们的项目别用会议室封闭开发了，原来总是说封闭开发，就是为了隔离，保密。这对于公司声誉来说很重要，但是能不能通过签订保密协议的方式来，干嘛非得封闭开发呢？”</p>
<p>周瑜说：“马哥，以我在大公司管理项目的经验来看，您还是想简单了。”</p>
<p>“你看，每次你接一个项目，总要写成项目执行计划书，CPU小伙伴们才能执行吧，项目计划书中的一行一行指令运行过程中，免不了要产生一些数据。这些数据要保存在一个地方，这个地方就是会议室（内存）。会议室（内存）被分成一块一块儿的，都编好了号。例如3F-10，就是三楼十号会议室。这个地址是实实在在的地址，通过这个地址我们就能够定位到物理内存的位置。”</p>
<p>“现在问题来了，写项目执行计划书的时候，里面的指令使用的地址是否可以使用物理地址呢？当然不行了，项目执行计划书，都是事先写好的，可以多次运行的。如果里面有个指令是，要把用户输入的数字保存在内存中，那就会有问题。”</p>
<p>“会产生什么问题呢？我举个例子你就明白了。如果我们使用那个实实在在的地址，3F-10，打开三个相同的程序，都执行到某一步。比方说，打开了三个计算器，用户在这三个程序的界面上分别输入了10、100、1000。如果内存中的这个位置只能保存一个数，那应该保存哪个呢？这不就冲突了吗？”</p>
<p>“如果不用这个实实在在的地址，那应该怎么办呢？那就必须用封闭开发的办法。</p>
<p>每个项目的物理地址对于进程不可见，谁也不能直接访问这个物理地址。操作系统会给进程分配一个虚拟地址。所有进程看到的这个地址都是一样的，里面的内存都是从0开始编号。</p>
<p>在程序里面，指令写入的地址是虚拟地址。例如，位置为10M的内存区域，操作系统会提供一种机制，将不同进程的虚拟地址和内存的物理地址映射起来。</p>
<p>当程序要访问虚拟地址的时候，由内核的数据结构进行转换，转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，就不会冲突了。”</p>
<p>小马想想，对啊，这是个好办法，咱们得规划一套会议室管理系统（内存管理）。根据刚才的分析，这个系统应该包含以下三个部分：</p>
<p>第一，物理内存的管理，相当于会议室管理员管理会议室；</p>
<p>第二，虚拟地址的管理，也即在项目组的视角，会议室的虚拟地址应该如何组织；</p>
<p>第三，虚拟地址和物理地址如何映射的问题，也即会议室管理员如果管理映射表。</p>
<p>我们先来盘点一下物理内存的情况。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/SMP和NUMA.jpeg" alt="SMP和NUMA"></p>
<p>不同的园区工位的安排和会议室的布局各不相同。</p>
<p>第一种情况是，CPU小伙伴们坐在一起，会议室在楼层的另一面，大家到会议室里面去都要通过统一的过道，优点简单，缺点是通道会成为瓶颈。</p>
<p>第二种情况是，会议室分成多个节点，离散地分布在CPU小伙伴周围。有的小伙伴去这个会议室近一些，有的小伙伴离另外一些会议室近一些。这样做的优点是，如果CPU小伙伴干活总是能够去离他最近的会议室，则速度非常快，但是一旦离他最近的会议室被占用了，他只能去其他会议室，这样就比较远了。</p>
<p>现在的园区基本都设计成第二种样子，也即会议室（内存）要分节点，每个节点用struct pglist_data表示。</p>
<p>每个节点里面再分区域，用于区分内存不同部分的不同用法。ZONE_NORMAL是最常用的区域。ZONE_MOVABLE是可移动区域。我们通过将物理内存划分为，可移动分配区域和不可移动分配区域，来避免内存碎片。每个区域用struct zone表示，也放在一个数组里面。</p>
<p>每个区域里面再分页。默认的大小为4KB。这就相当于每个会议室的最小单位。</p>
<p>如果有项目要使用会议室，应该如何分配呢？不能任何项目来了，咱都给他整个会议室。会议室也是可以再分割的，例如在中间拼起一堵墙，这样一个会议室就可以分成两个，继续分，可以再分成四个1/4大小的会议室，直到不能再分，我们就能得到一页的大小。</p>
<p>物理页面分配的时候，也可以采取这样的思路，我们称为伙伴系统。</p>
<p>空闲页放在struct free_area里面，每一页用struct page表示。</p>
<p>把所有的空闲页分组为11个页块链表，每个块链表分别包含很多个大小的页块，有1、2、4、8、16、32、64、128、256、512和1024个连续页的页块。最大可以申请1024个连续页，对应4MB大小的连续内存。每个页块的第一个页的物理地址是该页块大小的整数倍。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/物理内存的组织形式.jpeg" alt="物理内存的组织形式"></p>
<p>例如，要请求一个128个页的页块时，我们要先检查128个页的页块链表是否有空闲块。如果没有，则查256个页的页块链表；如果有空闲块的话，则将256个页的页块分成两份，一份使用，一份插入128个页的页块链表中。如果还是没有，就查512个页的页块链表；如果有的话，就分裂为128、128、256三个页块，一个128的使用，剩余两个插入对应页块链表。</p>
<p>把物理页面分成一块一块大小相同的页，这样带来的另一个好处是，当有的内存页面长时间不用了，可以暂时写到硬盘上，我们称为换出。一旦需要的时候，再加载进来，就叫作换入。这样可以扩大可用物理内存的大小，提高物理内存的利用率。在内核里面，也即张昭的管理下，有一个进程kswapd，可以根据物理页面的使用情况，对页面进行换入换出。</p>
<p>小马觉得这种方式太好了，如此高效地使用会议室，公司不用租用多少会议室，就能解决当前的项目问题了。</p>
<h4 id="58-2-会议室排列有序，分视角各有洞天"><a href="#58-2-会议室排列有序，分视角各有洞天" class="headerlink" title="58.2 会议室排列有序，分视角各有洞天"></a>58.2 会议室排列有序，分视角各有洞天</h4><p>周瑜说，“你先别急，这还仅仅是会议室物理地址的管理，每一个项目组能够看到的虚拟地址，咱还没规划呢！这个规划不好，执行项目还是会有问题的。”</p>
<p>每个项目组能看到的虚拟地址怎么规划呢？我们要给项目组这样一种感觉，从项目组的角度，也即从虚的角度来看，这一大片连续的内存空间都是他们的了。</p>
<p>如果是32位，有2^32 = 4G的内存空间都是他们的，不管内存是不是真的有4G。如果是64位，在x86_64下面，其实只使用了48位，那也挺恐怖的。48位地址长度也就是对应了256TB的地址空间。</p>
<p>小马说：“我都没怎么见过256T的硬盘，别说是内存了。”</p>
<p>周瑜接着说：“现在，一个项目组觉得，会议室可比世界首富房子还大。虽然是虚拟的，下面尽情地去排列咱们要放的东西吧！请记住，现在我们是站在一个进程的角度，去看这个虚拟的空间，不用管其他进程。”</p>
<p>首先，这么大的虚拟空间一切二，一部分用来放内核的东西，称为内核空间；一部分用来放进程的东西，称为用户空间。用户空间在下，在低地址，我们假设是0号到29号会议室；内核空间在上，在高地址，我们假设是30号到39号会议室。这两部分空间的分界线，因为32位和64位的不同而不同，我们这里不深究。</p>
<p>对于普通进程来说，内核空间的那部分，虽然虚拟地址在那里，但是不能访问。这就像作为普通员工，你明明知道财务办公室在这个30号会议室门里面，但是门上挂着“闲人免进”，你只能在自己的用户空间里面折腾。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/用一个创业故事串起操作系统原理（三）3.jpeg" alt="用一个创业故事串起操作系统原理（三）3"></p>
<p>我们从最低位开始排起，先是Text Segment、Data Segment和BSS Segment。Text Segment是存放二进制可执行代码的位置，Data Segment存放静态常量，BSS Segment存放未初始化的静态变量。这些都是在项目执行计划书里面有的。</p>
<p>接下来是堆段。堆是往高地址增长的，是用来动态分配内存的区域，malloc就是在这里面分配的。</p>
<p>接下来的区域是Memory Mapping Segment。这块地址可以用来把文件映射进内存用的，如果二进制的执行文件依赖于某个动态链接库，就是在这个区域里面将so文件映射到了内存中。</p>
<p>再下面就是栈地址段了，主线程的函数调用的函数栈就是用这里的。</p>
<p>如果普通进程还想进一步访问内核空间，是没办法的，只能眼巴巴地看着。如果需要进行更高权限的工作，就需要调用系统调用，进入内核。</p>
<p>一旦进入了内核，就换了一副视角。刚才是普通进程的视角，觉着整个空间是它独占的，没有其他进程存在。当然另一个进程也这样认为，因为它们互相看不到对方。这也就是说，不同进程的0号到29号会议室放的东西都不一样。</p>
<p>但是，到了内核里面，无论是从哪个进程进来的，看到的是同一个内核空间，看到的是同一个进程列表。虽然内核栈是各用个的，但是如果想知道的话，还是能够知道每个进程的内核栈在哪里的。所以，如果要访问一些公共的数据结构，需要进行锁保护。也就是说，不同的进程进入到内核后，进入的30号到39号会议室是同一批会议室。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/用一个创业故事串起操作系统原理（三）4.jpeg" alt="用一个创业故事串起操作系统原理（三）4"></p>
<p>内核的代码访问内核的数据结构，大部分的情况下都是使用虚拟地址的。虽然内核代码权限很大，但是能够使用的虚拟地址范围也只能在内核空间，也即内核代码访问内核数据结构，只能用30号到39号这些编号，不能用0到29号，因为这些是被进程空间占用的。而且，进程有很多个。你现在在内核，但是你不知道当前指的0号是哪个进程的0号。</p>
<p>在内核里面也会有内核的代码，同样有Text Segment、Data Segment和BSS Segment，内核代码也是ELF格式的。</p>
<p>不过有了这个规定以后，项目执行计划书要写入数据的时候，就需要符合里面的规定了，数据不能随便乱放了。</p>
<p>小马说，“没问题，这个作为项目章程，每一个新员工来了都培训。”</p>
<h4 id="58-3-管理系统全搞定，至此生存无问题"><a href="#58-3-管理系统全搞定，至此生存无问题" class="headerlink" title="58.3 管理系统全搞定，至此生存无问题"></a>58.3 管理系统全搞定，至此生存无问题</h4><p>周瑜接着说：“物理会议室和虚拟空间都分成大小相同的页，我们还得有一个会议室管理系统，将两者关联起来，这样项目组申请会议室的时候，也有个系统可以统一的管理，要不然会议室还不得老冲突呀。”</p>
<p>对于虚拟内存的访问，也是有一个地址的，我们需要找到一种策略，实现从虚拟地址到物理地址的转换。</p>
<p>为了能够定位和访问每个页，需要有个页表，保存每个页的起始地址，再加上在页内的偏移量，组成线性地址，就能对于内存中的每个位置进行访问了。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/分页机制的原理.jpg" alt="分页机制的原理"></p>
<p>虚拟地址分为两部分，页号和页内偏移。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址。这个基地址与页内偏移的组合就形成了物理内存地址。</p>
<p>下面的图，举了一个简单的页表的例子，虚拟内存中的页通过页表映射对应到物理内存中的页。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/用一个创业故事串起操作系统原理（三）6.jpg" alt="用一个创业故事串起操作系统原理（三）6"></p>
<p>32位环境下，虚拟地址空间共4GB。如果分成4KB一个页，那就是1M个页。每个页表项需要4个字节来存储，那么整个4GB空间的映射就需要4MB的内存来存储映射表。如果每个进程都有自己的映射表，100个进程就需要400MB的内存。对于内核来讲，有点大了 。</p>
<p>页表中所有页表项必须提前建好，并且要求是连续的。如果不连续，就没有办法通过虚拟地址里面的页号找到对应的页表项了。</p>
<p>那怎么办呢？我们可以试着将页表再分页，4G的空间需要4M的页表来存储映射。我们把这4M分成1K（1024）个4K，每个4K又能放在一页里面，这样1K个4K就是1K个页，这1K个页也需要一个表进行管理，我们称为页目录表，这个页目录表里面有1K项，每项4个字节，页目录表大小也是4K。</p>
<p>页目录有1K项，用10位就可以表示访问页目录的哪一项。这一项其实对应的是一整页的页表项，也即4K的页表项。每个页表项也是4个字节，因而一整页的页表项是1k个。再用10位就可以表示访问页表项的哪一项，页表项中的一项对应的就是一个页，是存放数据的页，这个页的大小是4K，用12位可以定位这个页内的任何一个位置。</p>
<p>这样加起来正好32位，也就是用前10位定位到页目录表中的一项。将这一项对应的页表取出来共1k项，再用中间10位定位到页表中的一项，将这一项对应的存放数据的页取出来，再用最后12位定位到页中的具体位置访问数据。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/两级分页.jpg" alt="两级分页"></p>
<p>你可能会问，如果这样的话，映射4GB地址空间就需要4MB+4KB的内存，这样不是更大了吗？ 当然如果页是满的，当时是更大了，但是，我们往往不会为一个进程分配那么多内存。</p>
<p>比如说，上面图中，我们假设只给这个进程分配了一个数据页。如果只使用页表，也需要完整的1M个页表项共4M的内存，但是如果使用了页目录，页目录需要1K个全部分配，占用内存4K，但是里面只有一项使用了。到了页表项，只需要分配能够管理那个数据页的页表项页就可以了，也就是说，最多4K，这样内存就节省多了。</p>
<p>当然对于64位的系统，两级肯定不够了，就变成了四级目录，分别是全局页目录项PGD（Page Global Directory）、上层页目录项PUD（Page Upper Directory）、中间页目录项PMD（Page Middle Directory）和页表项PTE（Page Table Entry）。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/四级分页.jpg" alt="四级分页"></p>
<p>设计完毕会议室管理系统，再加上前面的项目管理系统，对于一家外包公司来讲，无论接什么样的项目都能轻松搞定了。我们常把CPU和内存合称为计算。至此，计算的问题就算搞定了。解决了这两大问题，一家外包公司的生存问题，就算解决了。</p>
<p>小马总算是可以松一口气了，他和周瑜、张昭好好地搓了一顿，喝得昏天黑地。周瑜和张昭纷纷感慨，幸亏当年跟了马哥，今日才有出头之日。</p>
<p>生存问题虽然解决了，马哥可非池中之物，接下来要解决的就是发展问题，马哥能想出什么办法进一步壮大企业呢？欲知后事，且听下回分解。</p>
<h3 id="59-用一个创业故事串起操作系统原理（四）"><a href="#59-用一个创业故事串起操作系统原理（四）" class="headerlink" title="59. 用一个创业故事串起操作系统原理（四）"></a>59. 用一个创业故事串起操作系统原理（四）</h3><p>上一节，小马的公司已经解决了生存问题，成功从小马晋升马哥。</p>
<p>马哥是一个有危机意识的人。尽管公司开始不断盈利，项目像流水一样，一个接一个，赚了点儿钱，但是他感觉还是有点儿像狗熊掰棒子。因为公司没有积累，永远就都是在做小生意，无法实现成倍的增长。</p>
<p>马哥想，公司做了这么多的项目，应该有很多的共同点，能积累下来非常多的资料。如果能够把这些资料归档、总结、积累，形成核心竞争力，就可以随着行业的飞跃，深耕一个行业，实现快速增长。</p>
<h4 id="59-1-公司发展需积累，马哥建立知识库"><a href="#59-1-公司发展需积累，马哥建立知识库" class="headerlink" title="59.1 公司发展需积累，马哥建立知识库"></a>59.1 公司发展需积累，马哥建立知识库</h4><p>这就需要我们有一个存放资料的档案库（文件系统）。档案库应该不依赖于项目而独立存在，应该井井有条、利于查询；应该长久保存，不随人员流动而损失。</p>
<p>公司到了这个阶段，除了周瑜和张昭，应该专门请一个能够积累核心竞争力的人来主持大局了。马哥想到了，前一阵行业交流大会上，他遇到了一个很牛的架构师——鲁肃。他感觉鲁肃在这方面很有想法，于是就请他来主持大局。</p>
<p>鲁肃跟马哥说，构建公司的核心技术能力，这个档案库（文件系统）也可以叫作知识库，这个需要好好规划一下。规划文件系统的时候，需要考虑以下几点。</p>
<p>第一点，文件系统要有严格的组织形式，使得文件能够以块为单位进行存储。</p>
<p>这就像图书馆里，我们会给设置一排排书架，然后再把书架分成一个个小格子。有的项目存放的资料非常多，一个格子放不下，就需要多个格子来进行存放。我们把这个区域称为存放原始资料的仓库区。对于操作系统，硬盘分成相同大小的单元，我们称为块。一块的大小是扇区大小的整数倍，默认是4K，用来存放文件的数据部分。这样一来，如果我们像存放一个文件，就不用给他分配一块连续的空间了。我们可以分散成一个个小块进行存放。这样就灵活得多，也比较容易添加、删除和插入数据。</p>
<p>第二点，文件系统中也要有索引区，用来方便查找一个文件分成的多个块都存放在了什么位置。</p>
<p>这就好比，图书馆的书太多了，为了方便查找，我们需要专门设置一排书架，这里面会写清楚整个档案库有哪些资料，资料在哪个架子的哪个格子上。这样找资料的时候就不用跑遍整个档案库，只要在这个书架上找到后，直奔目标书架就可以了。</p>
<p>在Linux操作系统里面，每一个文件有一个Inode，inode的“i”是index的意思，其实就是“索引”。inode里面有文件的读写权限i_mode，属于哪个用户i_uid，哪个组i_gid，大小是多少i_size_io，占用多少个块i_blocks_io。“某个文件分成几块、每一块在哪里”，这些信息也在inode里面，保存在i_block里面。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/用一个创业故事串起操作系统原理（四）1.png" alt="用一个创业故事串起操作系统原理（四）1"></p>
<p>第三点，如果文件系统中有的文件是热点文件，近期经常被读取和写入，文件系统应该有缓存层。</p>
<p>这就相当于图书馆里面的热门图书区，这里面的书都是畅销书或者是常常被借还的图书。因为借还的次数比较多，那就没必要每次有人还了之后，还放回遥远的货架，我们可以专门开辟一个区域，放置这些借还频次高的图书。这样借还的效率就会提高。</p>
<p>第四点，文件应该用文件夹的形式组织起来，方便管理和查询。</p>
<p>这就像在图书馆里面，你可以给这些资料分门别类，比如分成计算机类、文学类、历史类等等。这样你也容易管理，项目组借阅的时候只要在某个类别中去找就可以了。</p>
<p>在文件系统中，每个文件都有一个名字，我们访问一个文件，希望通过他的名字就可以找到。文件名就是一个普通的文本，所以文件名经常会冲突，不同用户取相同的名字的情况会经常出现的。</p>
<p>要想把很多的文件有序地组织起来，我们就需要把他们做成目录或者文件夹。这样，一个文件夹里可以包含文件夹，也可以包含文件，这样就形成了一种树形结构。我们可以将不同的用户放在不同的用户目录下，就可以一定程度上避免了命名的冲突问题。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/用一个创业故事串起操作系统原理（四）2.png" alt="用一个创业故事串起操作系统原理（四）2"></p>
<p>第五点，Linux内核要在自己的内存里面维护一套数据结构，来保存哪些文件被哪些进程打开和使用。</p>
<p>这就好比，图书馆里会有个图书管理系统，记录哪些书被借阅了，被谁借阅了，借阅了多久，什么时候归还。</p>
<p>这个图书管理系统尤为重要，如果不是很方便使用，以后项目中积累了经验，就没有人愿意往知识库里面放了。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/虚拟文件系统.jpg" alt="虚拟文件系统"></p>
<p>无论哪个项目（进程），都可以通过write系统调用写入知识库。</p>
<p>对于每一个进程，打开的文件都有一个文件描述符。files_struct里面会有文件描述符数组。每个一个文件描述符是这个数组的下标，里面的内容指向一个struct file结构，表示打开的文件。这个结构里面有这个文件对应的inode，最重要的是这个文件对应的操作file_operation。如果操作这个文件，就看这个file_operation里面的定义了。</p>
<p>每一个打开的文件，都有一个dentry对应，虽然我们叫作directory entry，但是他不仅仅表示文件夹，也表示文件。他最重要的作用就是指向这个文件对应的inode。</p>
<p>如果说file结构是一个文件打开以后才创建的，dentry是放在一个dentry cache里面的。文件关闭了，他依然存在，因而他可以更长期的维护内存中的文件的表示和硬盘上文件的表示之间的关系。</p>
<p>inode结构就表示硬盘上的inode，包括块设备号等。这个inode对应的操作保存在inode operations里面。真正写入数据，是写入硬盘上的文件系统，例如ext4文件系统。</p>
<p>马哥听了知识库和档案库的设计，非常开心，对鲁肃说，你这五大秘籍，可是帮了我大忙了。于是马上下令实施。</p>
<h4 id="59-2-有了积累建生态，成立渠道管理部"><a href="#59-2-有了积累建生态，成立渠道管理部" class="headerlink" title="59.2 有了积累建生态，成立渠道管理部"></a>59.2 有了积累建生态，成立渠道管理部</h4><p>有了知识库，公司的面貌果然大为改观。</p>
<p>马哥发现，当知识库积累到一定程度，公司接任何项目都能找到相似的旧项目作为参考，不用重新设计，效率大大提高。而且最重要的一点是，没有知识库的时候，原来项目做的好不好，完全取决于程序员，因为所有的知识都在程序员的脑子里，所以公司必须要招聘高质量的程序员，才能保证项目的质量。一方面优秀的程序员数量很少，这大大限制了公司能够接项目的规模，一方面优秀的程序员实在太贵，大大提高了公司的成本。</p>
<p>有了知识库，依赖于原来积累的体系，只要找到类似的旧项目，哪怕是普通的程序员，只要会照猫画虎，结果就不会太差。</p>
<p>于是，马哥马上想到，现在公司只有百十来号人，能赚这些钱，现在招人门槛降低了，我要是招聘一万人，这能赚多少钱啊！</p>
<p>鲁肃对马哥说，“你可先别急着招人，建立知识库，降低招人成本才是第一步。公司招聘太多人不容易管理。既然项目的执行可以照猫画虎，很多项目可以不用咱们公司来，我们可以建立渠道销售体系（输入和输出系统），让供应商、渠道帮我们卖，形成一个生态。这公司的盈利规模可就不是招一万人这么点儿了，这是指数级的增长啊！”</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/输入输出系统.jpg" alt="输入输出系统"></p>
<p>计算机系统的输入和输出系统都有哪些呢？我们能举出来的，例如键盘、鼠标、显示器、网卡、硬盘、打印机、CD/DVD等等，多种多样。这样，当然方便用户使用了，但是对于操作系统来讲，却是一件复杂的事情，因为这么多设备，形状、用法、功能都不一样，怎么才能统一管理起来呢？我们一层一层来看。</p>
<p>第一层，用设备控制器屏蔽设备差异。</p>
<p>马哥说，“把生意做到全国，我也想过，这个可不容易。咱们客户多种多样，众口难调，不同的地域不一样，不同的行业不一样。如果你不懂某个地方的规矩，根本卖不出去东西；如果你不懂某个具体行业的使用场景，也无法满足客户的需求。”</p>
<p>鲁肃说：“所以说，建议您建立生态，设置很多代理商，让各个地区和各个行业的代理商帮你屏蔽这些差异化。你和代理商之间只要进行简单的标准产品交付就可以了。”</p>
<p>计算机系统就是这样的。CPU并不直接和设备打交道，他们中间有一个叫作设备控制器（Device Control Unit）的组件。例如，硬盘有磁盘控制器、USB有USB控制器、显示器有视频控制器等。这些控制器就像代理商一样，他们知道如何应对硬盘、鼠标、键盘、显示器的行为。</p>
<p>你的代理商往往是小公司。控制器其实有点儿像一台小电脑。他有他的芯片，类似小CPU，执行自己的逻辑。他也有他的寄存器。这样CPU就可以通过写这些寄存器，对控制器下发指令，通过读这些寄存器，查看控制器对于设备的操作状态。</p>
<p>CPU对于寄存器的读写，可比直接控制硬件，要标准和轻松很多。这就相当于你和代理商的标准产品交付。</p>
<p>第二层，用驱动程序屏蔽设备控制器差异。</p>
<p>马哥说：“你这么一说，还真有道理，如果我们能够找到足够多的代理商，那就高枕无忧了。”</p>
<p>鲁肃说：“其实事情还没这么简单，虽然代理商机制能够帮我们屏蔽很多设备的细节，但是从上面的描述我们可以看出，由于每种设备的控制器的寄存器、缓冲区等使用模式，指令都不同。对于咱们公司来讲，就需要有个部门专门对接代理商，向其他部门屏蔽代理商的差异，成立公司的渠道管理部门。”</p>
<p>那对于操作系统来讲，渠道管理部门就是用来对接各个设备控制器的设备驱动程序。</p>
<p>这里需要注意的是，设备控制器不属于操作系统的一部分，但是设备驱动程序属于操作系统的一部分。操作系统的内核代码可以像调用本地代码一样调用驱动程序的代码，而驱动程序的代码需要发出特殊的面向设备控制器的指令，才能操作设备控制器。</p>
<p>设备驱动程序中是一些面向特殊设备控制器的代码。不同的设备不同。但是对于操作系统其他部分的代码而言，设备驱动程序应该有统一的接口。就像下面图中的一样，不同的设备驱动程序，可以以同样的方式接入操作系统，而操作系统的其他部分的代码，也可以无视不同设备的区别，以同样的接口调用设备驱动程序。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/用一个创业故事串起操作系统原理（四）5.png" alt="用一个创业故事串起操作系统原理（四）5"></p>
<p>第三，用中断控制器统一外部事件处理。</p>
<p>马哥听了恍然大悟：“原来代理商也是五花八门，里面有这么多门道啊！”</p>
<p>鲁肃说：“当咱们对接的代理商多了，代理商可能会有各种各样的问题找到我们，例如代理商有了新客户，客户有了新需求，客户交付完毕等事件，都需要有一种机制通知你们公司，当然是中断，那操作系统就需要有一个地方处理这个中断，既然设备驱动程序是用来对接设备控制器的，中断处理也应该在设备驱动里面完成。”</p>
<p>然而，中断的触发最终会到达CPU，会中断操作系统当前运行的程序，所以操作系统也要有一个统一的流程来处理中断，使得不同设备的中断使用统一的流程。</p>
<p>一般的流程是，一个设备驱动程序初始化的时候，要先注册一个该设备的中断处理函数。咱们讲进程切换的时候说过，中断返回的那一刻是进程切换的时机。中断的时候，触发的函数是do_IRQ。这个函数是中断处理的统一入口。在这个函数里面，我们可以找到设备驱动程序注册的中断处理函数Handler，然后执行他进行中断处理。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/设备使用中断的流程.jpg" alt="设备使用中断的流程"></p>
<p>第四，用文件系统接口屏蔽驱动程序的差异。</p>
<p>马哥又问了：“对接了这么多代理商，如果咱们内部的工程师要和他们打交道，有没有一种统一的方式呢？”</p>
<p>鲁肃说：“当然应该了，我们内部员工操作外部设备，可以基于文件系统的接口，制定一个统一的标准。”</p>
<p>其实文件系统的机制是一个非常好的机制，咱们公司应该定下这样的规则，一切皆文件。</p>
<p>所有设备都在/dev/文件夹下面，创建一个特殊的设备文件。这个设备特殊文件也有inode，但是他不关联到硬盘或任何其他存储介质上的数据，而是建立了与某个设备驱动程序的连接。</p>
<p>有了文件系统接口之后，我们不但可以通过文件系统的命令行操作设备，也可以通过程序，调用read、write函数，像读写文件一样操作设备。</p>
<p>对于块设备来讲，在驱动程序之上，文件系统之下，还需要一层通用设备层。比如，咱们讲的文件系统，里面的逻辑和磁盘设备没有什么关系，可以说是通用的逻辑。在写文件的最底层，我们看到了BIO字眼的函数，但是好像和设备驱动也没有什么关系。</p>
<p>是的，因为块设备类型非常多，而Linux操作系统里面一切是文件。我们也不想文件系统以下，就直接对接各种各样的块设备驱动程序，这样会使得文件系统的复杂度非常高。所以，我们在中间加了一层通用块层，将与块设备相关的通用逻辑放在这一层，维护与设备无关的块的大小，然后通用块层下面对接各种各样的驱动程序。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/用一个创业故事串起操作系统原理（四）7.png" alt="用一个创业故事串起操作系统原理（四）7"></p>
<p>鲁肃帮助马哥建立了这套体系之后，果真业务有了很大起色。原来公司只敢接华东区的项目，毕竟比较近，沟通交付都很方便。后来项目扩展到所有一线城市、二线城市、省会城市，项目数量实现了几十倍的增长。</p>
<h4 id="59-3-千万项目难度大，集体合作可断金"><a href="#59-3-千万项目难度大，集体合作可断金" class="headerlink" title="59.3 千万项目难度大，集体合作可断金"></a>59.3 千万项目难度大，集体合作可断金</h4><p>项目接的多了，就不免有大型的项目，涉及多个行业多个领域，需要多个项目组进行合作才能完成。那两个项目组应该通过什么样的方式，进行沟通与合作呢？作为老板，马哥应该如何设计整个流程呢？</p>
<p>马哥叫来周瑜、张昭、鲁肃，一起商量团队间的合作模式。大家一起献计献策。好在有很多成熟的项目管理流程可以参考。</p>
<p>最最传统的模型就是软件开发的瀑布模型。所谓的瀑布模型，其实就是将整个软件开发过程分成多个阶段，往往是上一个阶段完全做完，才将输出结果交给下一个阶段。这种模型类似进程间通信的管道模型。</p>
<p>所谓的管道，就是在两个进程之间建立一条单向的通道，其实是一段缓存，它会将前一个命令的输出，作为后一个命令的输入。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/使用管道实现shell之间的通信结果.png" alt="使用管道实现shell之间的通信结果"></p>
<p>张昭说，瀑布模型的开发流程效率比较低下，现在大部分公司都不使用这种开发模式了，因为团队之间无法频繁地沟通。而且，管道的使用模式，也不适合进程间频繁的交换数据。</p>
<p>于是，他们还得想其他的办法。是不是可以借鉴传统外企的沟通方式——邮件呢？邮件有一定的格式，例如抬头、正文、附件等。发送邮件可以建立收件人列表，所有在这个列表中的人，都可以反复地在此邮件基础上回复，达到频繁沟通的目的。这个啊，就是消息队列模型。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/消息队列模型.png" alt="消息队列模型"></p>
<p>和管道将信息一股脑儿地从一个进程，倒给另一个进程不同，消息队列有点儿像邮件，发送数据时，会分成一个一个独立的数据单元，也就是消息体，每个消息体都是固定大小的存储块，在字节流上不连续。</p>
<p>有了消息这种模型，两个进程之间的通信就像咱们平时发邮件一样，你来一封，我回一封，可以频繁沟通了。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/用一个创业故事串起操作系统原理（四）10.png" alt="用一个创业故事串起操作系统原理（四）10"></p>
<p>但是有时候，项目组之间的沟通需要特别紧密，而且要分享一些比较大的数据。如果使用邮件，就发现，一方面邮件的来去不及时；另外一方面，附件大小也有限制，所以，这个时候，我们经常采取的方式就是，把两个项目组在需要合作的期间，拉到一个会议室进行合作开发，这样大家可以直接交流文档呀，架构图呀，直接在白板上画或者直接扔给对方，就可以直接看到。</p>
<p>可以看出来，共享会议室这种模型，类似进程间通信的共享内存模型。前面咱们讲内存管理的时候，知道每个进程都有自己独立的虚拟内存空间，不同的进程的虚拟内存空间映射到不同的物理内存中去。这个进程访问A地址和另一个进程访问A地址，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。</p>
<p>但是，咱们是不是可以变通一下，拿出一块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去。</p>
<p>马哥说：“共享内存也有问题呀。如果两个进程使用同一个共享内存，大家都往里面写东西，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。”</p>
<p>张昭说：“当然，和共享内存配合的，有另一种保护机制，使得同一个共享的资源，同时只能被一个进程访问叫信号量。”</p>
<p>信号量其实是一个计数器，主要用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</p>
<p>我们可以将信号量初始化为一个数值，来代表某种资源的总体数量。对于信号量来讲，会定义两种原子操作，一个是P操作，我们称为申请资源操作。这个操作会申请将信号量的数值减去N，表示这些数量被他申请使用了，其他人不能用了。另一个是V操作，我们称为归还资源操作，这个操作会申请将信号量加上M，表示这些数量已经还给信号量了，其他人可以使用了。</p>
<p>例如，你有100元钱，就可以将信号量设置为100。其中A向你借80元，就会调用P操作，申请减去80。如果同时B向你借50元，但是B的P操作比A晚，那就没有办法，只好等待A归还钱的时候，B的P操作才能成功。之后，A调用V操作，申请加上30元，也就是还给你30元，这个时候信号量有50元了，这时候B的P操作才能成功，才能借走这50元。</p>
<p>所谓原子操作（Atomic Operation），就是任何一块钱，都只能通过P操作借给一个人，不能同时借给两个人。也就是说，当A的P操作（借80）和B的P操作（借50），几乎同时到达的时候，不能因为大家都看到账户里有100就都成功，必须分个先来后到。</p>
<p>马哥说：“有了上面的这些机制，基本常规状态下的工作模式，对应到咱们平时的工作交接，收发邮件、联合开发等。我还想到，如果发生了异常怎么办？例如出现线上系统故障，这个时候，什么流程都来不及了，不可能发邮件，也来不及开会，所有的架构师、开发、运维都要被通知紧急出动。所以，7乘24小时不间断执行的系统都需要有告警系统，一旦出事情，就要通知到人，哪怕是半夜，也要电话叫起来，处理故障。是不是应该还有一种异常情况下的工作模式。”</p>
<p>张昭说：“当然应该有，我们可以建立像操作系统里面的信号机制。信号没有特别复杂的数据结构，就是用一个代号一样的数字。Linux提供了几十种信号，分别代表不同的意义。信号之间依靠它们的值来区分。这就像咱们看警匪片，对于紧急的行动，都是说，‘1号作战任务’开始执行，警察就开始行动了。情况紧急，不能啰里啰嗦了。”</p>
<p>信号可以在任何时候发送给某一进程，进程需要为这个信号配置信号处理函数。当某个信号发生的时候，就默认执行这个函数就可以了。这就相当于咱们运维一个系统应急手册，当遇到什么情况，做什么事情，都事先准备好，出了事情照着做就可以了。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/通过API注册一个信号处理函数的过程.png" alt="通过API注册一个信号处理函数的过程"></p>
<p>这些项目组合作的流程设计合理，因而推行起来十分顺畅，现在接个千万级别的项目没有任何问题，根据交易量估值市值，起码有十个亿。</p>
<p>马哥有些小激动，原来自己身价这么高了，是不是也能上个市啥的，实现亿万富翁的梦想呢？于是马哥找了一些投资人聊了聊，投资人说，要想冲一把上市，还差点劲，目前的项目虽然大，但是想象力不够丰富。</p>
<p>那接下来，马哥如何做才能满足市场的想象力，最终成功上市呢？预知后事，且听下回分解。</p>
<h3 id="60-用一个创业故事串起操作系统原理（五）"><a href="#60-用一个创业故事串起操作系统原理（五）" class="headerlink" title="60. 用一个创业故事串起操作系统原理（五）"></a>60. 用一个创业故事串起操作系统原理（五）</h3><p>上一节我们说到，马哥的公司现在接个千万级别的项目没有任何问题，但是投资人说，要想冲一把上市，还差点劲，目前的项目虽然大，但是想象力不够丰富。</p>
<h4 id="60-1-亿级项目创品牌，战略合作遵协议"><a href="#60-1-亿级项目创品牌，战略合作遵协议" class="headerlink" title="60.1 亿级项目创品牌，战略合作遵协议"></a>60.1 亿级项目创品牌，战略合作遵协议</h4><p>马哥突然想到，西部有一个智慧城市的打单，金额几个亿，绝对标杆性质的。如果能够参与其中，应该是很有想象力的事情。</p>
<p>可是，甲方明确地说，“整个智慧城市的建设体系非常的大，一家公司做不下来，需要多家公司合作才能完成。你们有多家公司合作的经验和机制吗？”</p>
<p>马哥咬牙说道：“当然有！”先应下来再说呗，可是这心里是真没底。原来公司都是独自接单，现在要和其他公司合作，协议怎么签，价格怎么谈呢？</p>
<p>马哥找到鲁肃。鲁肃说：“我给你推荐一个人吧！这个人人脉广，项目运作能力强，叫陆逊，说不定能帮上忙。”</p>
<p>鲁肃找来陆逊。陆逊说：“这个好办。公司间合作嘛，就是条款谈好，利益分好就行，关键是大家要遵守行规。大家都按统一的规则来，事情就好办。”</p>
<p>这其实就像机器与机器之间合作，一台机器将自己想要表达的内容，按照某种约定好的格式发送出去。当另外一台机器收到这些信息后，也能够按照约定好的格式解析出来，从而准确、可靠地获得发送方想要表达的内容。这种约定好的格式就是网络协议。</p>
<p>现在业内知名的有两种网络协议模型，一种是OSI的标准七层模型，一种是业界标准的TCP/IP模型。它们的对应关系如下图所示：</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/网络协议模型.png" alt="网络协议模型"></p>
<p>我们先从第三层网络层开始，因为这一层有我们熟悉的IP地址，所以这一层我们也叫IP层。</p>
<p>连接到网络上的每一个设备都至少有一个IP地址，用于定位这个设备。无论是近在咫尺的、你旁边同学的电脑，还是远在天边的电商网站，都可以通过IP地址进行定位。因此，IP地址类似互联网上的邮寄地址，是有全局定位功能的。</p>
<p>就算你要访问美国的一个地址，也可以从你身边的网络出发，通过不断地打听道儿，经过多个网络，最终到达目的地址，和快递员送包裹的过程差不多。打听道儿的协议也在第三层，我们称为路由协议。将网络包从一个网络转发给另一个网络的设备，我们称为路由器。</p>
<p>总而言之，第三层干的事情，就是网络包从一个起始的IP地址，沿着路由协议指的道儿，经过多个网络，通过多次路由器转发，到达目标IP地址。</p>
<p>从第三层，我们往下看。第二层是数据链路层。有时候我们简称为二层或者MAC层。所谓MAC，就是每个网卡都有的唯一的硬件地址（不绝对唯一，相对大概率唯一即可，类比UUID）。这虽然也是一个地址，但是这个地址是没有全局定位功能的。</p>
<p>就像给你送外卖的小哥，不可能根据手机尾号找到你家，但是手机尾号有本地定位功能的，只不过这个定位主要靠“吼“。外卖小哥到了你的楼层就开始大喊：“尾号xxxx的，你外卖到了！“</p>
<p>MAC地址的定位功能局限在一个网络里面，也即同一个网络号下的IP地址之间，可以通过MAC进行定位和通信。从IP地址获取MAC地址要通过ARP协议，是通过在本地发送广播包，也就是“吼“，获得的MAC地址。</p>
<p>由于同一个网络内的机器数量有限，通过MAC地址的好处就是简单。匹配上MAC地址就接收，匹配不上就不接收，没有什么所谓路由协议这样复杂的协议。当然坏处就是，MAC地址的作用范围不能出本地网络，所以一旦跨网络通信，虽然IP地址保持不变，但是MAC地址每经过一个路由器就要换一次。</p>
<p>所以第二层干的事情，就是网络包在本地网络中的服务器之间定位及通信的机制。</p>
<p>我们再往下看第一层，物理层。这一层就是物理设备。例如，连着电脑的网线，我们能连上的WiFi。</p>
<p>从第三层往上看，第四层是传输层，这里面有两个著名的协议，TCP和UDP。尤其是TCP，更是广泛使用，在IP层的代码逻辑中，仅仅负责数据从一个IP地址发送给另一个IP地址，丢包、乱序、重传、拥塞，这些IP层都不管。处理这些问题的代码逻辑写在了传输层的TCP协议里面。</p>
<p>我们常说，TCP是可靠传输协议，也是难为它了。因为从第一层到第三层都不可靠，网络包说丢就丢，是TCP这一层通过各种编号、重传等机制，让本来不可靠的网络对于更上层来讲，变得“看起来”可靠。哪有什么应用层的岁月静好，只不过是TCP层在负重前行。</p>
<p>传输层再往上就是应用层，例如，咱们在浏览器里面输入的HTTP，Java服务端写的Servlet，都是这一层的。</p>
<p>二层到四层都是在Linux内核里面处理的，应用层例如浏览器、Nginx、Tomcat都是用户态的。内核里面对于网络包的处理是不区分应用的。</p>
<p>从四层再往上，就需要区分网络包发给哪个应用。在传输层的TCP和UDP协议里面，都有端口的概念，不同的应用监听不同的端口。例如，服务端Nginx监听80、Tomcat监听8080；再如客户端浏览器监听一个随机端口，FTP客户端监听另外一个随机端口。</p>
<p>应用层和内核互通的机制，就是通过Socket系统调用。所以经常有人会问，Socket属于哪一层，其实它哪一层都不属于，它属于操作系统的概念，而非网络协议分层的概念。</p>
<p>操作系统对于网络协议的实现模式是这样的：二到四层的处理代码在内核里面，七层的处理代码让应用自己去做。两者需要跨内核态和用户态通信，就需要一个系统调用完成这个衔接，这就是Socket。</p>
<p>如果公司想要和其他公司沟通，我们将请求封装为HTTP协议，通过Socket发送到内核。内核的网络协议栈里面，在TCP层创建用于维护连接、序列号、重传、拥塞控制的数据结构，将HTTP包加上TCP头，发送给IP层，IP层加上IP头，发送给MAC层，MAC层加上MAC头，从硬件网卡发出去。</p>
<p>最终网络包会被转发到目标服务器，它发现MAC地址匹配，就将MAC头取下来，交给上一层。IP层发现IP地址匹配，将IP头取下来，交给上一层。TCP层会根据TCP头中的序列号等信息，发现它是一个正确的网络包，就会将网络包缓存起来，等待应用层的读取。</p>
<p>应用层通过Socket监听某个端口，因而读取的时候，内核会根据TCP头中的端口号，将网络包发给相应的应用。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/socket系统调用.png" alt="socket系统调用"></p>
<p>这样一个大项目中，各个公司都按协议来，别说两家公司合作，二十家也没有问题。</p>
<p>于是陆逊带着马哥，到甲方那里，将自己的方案，以及和其他公司的合作模式讲述清楚。马哥成功入围。</p>
<p>这次参与竞标的公司可不少，马哥公司的竞争力和专业性一点都不差，最后终于拿下了智慧生态合作平台的建设部分。这下不得了，一提马哥的公司，业内无人不知，无人不晓，大家纷纷称呼他为“马总”。</p>
<h4 id="60-2-公司大了不灵活，鼓励创新有妙招"><a href="#60-2-公司大了不灵活，鼓励创新有妙招" class="headerlink" title="60.2 公司大了不灵活，鼓励创新有妙招"></a>60.2 公司大了不灵活，鼓励创新有妙招</h4><p>慢慢地，马总发现，公司大有大的好处，自然也有大的毛病，也就是咱们常见的“大公司病”——不灵活。</p>
<p>这里面的不灵活，就像Linux服务器，越来越强大的时候，无论是计算、网络、存储，都越来越牛。例如，内存动不动就是百G内存，网络设备一个端口的带宽就能有几十G甚至上百G。存储在数据中心至少是PB级别的，自然也有不灵活的毛病。</p>
<p>资源大小不灵活：有时候我们不需要这么大规格的机器，可能只想尝试一下某些新业务，申请个4核8G的服务器试一下，但是不可能采购这么小规格的机器。无论每个项目需要多大规格的机器，公司统一采购就限制几种，全部是上面那种大规格的。</p>
<p>资源申请不灵活：规格定死就定死吧，可是每次申请机器都要重新采购，周期很长。</p>
<p>资源复用不灵活：反正我需要的资源不多，和别人共享一台机器吧，这样不同的进程可能会产生冲突，例如socket的端口冲突。另外就是别人用过的机器，不知道上面做过哪些操作，有很多的历史包袱，如果重新安装则代价太大。</p>
<p>按说，大事情流程严禁没问题，很多小事情也要被拖累走整个流程，而且很容易出现资源冲突，每天跨部门的协调很累人，历史包袱严重，创新没有办法轻装上阵。</p>
<p>很多公司处理这种问题采取的策略是成立独立的子公司，独立决策，独立运营。这种办法往往会用在创新型的项目上。</p>
<p>Linux也采取了这样的手段，就是在物理机上面创建虚拟机。每个虚拟机有自己单独的操作系统、灵活的规格，一个命令就能启动起来。每次创建都是新的操作系统，很好地解决了上面不灵活的问题。</p>
<p>在物理机上的操作系统看来，虚拟机是一个普通的应用，他和Excel一样，只能运行在用户态。但是对于虚拟机里面的操作系统内核来讲，运行在内核态，应该有高的权限。</p>
<p>要做到这件事情，第一种方式，完全虚拟化。其实说白了，这是一种“骗人”的方式。虚拟化软件会模拟假的CPU、内存、网络、硬盘给到虚拟机，让虚拟机里面的内核自我感觉良好，感觉他终于又像个内核了。在Linux上，一个叫作qemu的工具可以做到这一点。</p>
<p>qemu向虚拟机里面的客户机操作系统模拟CPU和其他的硬件，骗客户机，GuestOS认为自己和硬件直接打交道，其实是同qemu模拟出来的硬件打交道，qemu会将这些指令转译给真正的硬件。由于所有的指令都要从qemu里面过一手，因而性能就会比较差。</p>
<p>第二种方式，硬件辅助虚拟化。可以使用硬件CPU的Intel-VT和AMD-V技术，需要CPU硬件开启这个标志位（一般在BIOS里面设置）。当确认开始了标志位之后，通过内核模块KVM，GuestOS的CPU指令将不用经过Qemu转译，直接运行，大大提高了速度。qemu和KVM融合以后，就是qemu-kvm。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/qemu的半虚拟化.png" alt="qemu的半虚拟化"></p>
<p>第三种方式称为半虚拟化。对于网络或者硬盘的访问，我们让虚拟机内核加载特殊的驱动，重新定位自己的身份。虚拟机操作系统的内核知道自己不是物理机内核，没那么高的权限。他很可能要和很多虚拟机共享物理资源，所以学会了排队。虚拟机写硬盘其实写的是一个物理机上的文件，那我的写文件的缓存方式是不是可以变一下。我发送网络包，根本就不是发给真正的网络设备，而是给虚拟的设备，我可不可以直接在内存里面拷贝给它，等等等等。</p>
<p>网络半虚拟化方式是virtio_net，存储是virtio_blk。客户机需要安装这些半虚拟化驱动。客户机内核知道自己是虚拟机，所以会直接把数据发送给半虚拟化设备，然后经过特殊处理（例如排队、缓存、批量处理等性能优化方式），最终发送给真正的硬件。这在一定程度上提高了性能。</p>
<p>有了虚拟化的技术，公司的状态改观了不少，在主要的经营方向之外，公司还推出了很多新的创新方向，都是通过虚拟机创建子公司的方式进行的，例如跨境电商、工业互联网、社交等。一方面，能够享受大公司的支持；一方面，也可以和灵活的创业公司进行竞争。</p>
<p>于是，公司就变成集团公司了。</p>
<h4 id="60-3-独占鳌头定格局，上市敲钟责任重"><a href="#60-3-独占鳌头定格局，上市敲钟责任重" class="headerlink" title="60.3 独占鳌头定格局，上市敲钟责任重"></a>60.3 独占鳌头定格局，上市敲钟责任重</h4><p>随着公司越来越大，钱赚的越来越多，马总的公司慢慢从行业的追随者，变成了领导者。这一方面，让马总觉得“会当凌绝顶，一览众山小”；另一方面，马总也觉得“高处不胜寒”。原来公司总是追着别人跑，产业格局，市场格局从来不用自己操心，只要自己的公司能赚钱就行。现在做了领头羊，马总也就慢慢成了各种政府论坛、产业论坛，甚至国际论坛的座上宾。</p>
<p>穷则独善其身，达则兼济天下。马总的决策可能关系到产业的发展、地方的GDP和就业，甚至未来的国际竞争力。因此，即便是和原来相同的事情，现在来做，方式和层次都不一样了。</p>
<p>就像对于单台Linux服务器，最重要的四种硬件资源是CPU、内存、存储和网络。面对整个数据中心成千上万台机器，我们只要重点关注这四种硬件资源就可以了。如果运维数据中心依然像的运维一台台物理机的前辈一样，天天关心哪个程序放在了哪台机器上，使用多少内存、多少硬盘，每台机器总共有多少内存、多少硬盘，还剩多少内存和硬盘，那头就大了。</p>
<p>对于数据中心，我们需要一个调度器，将运维人员从指定物理机或者虚拟机的痛苦中解放出来，实现对于物理资源的统一管理，这就是Kubernetes，也就是数据中心的操作系统。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/数据中心操作系统的功能总结.jpg" alt="数据中心操作系统的功能总结"></p>
<p>对于CPU和内存这两种计算资源的管理，我们可以通过Docker技术完成。</p>
<p>容器实现封闭的环境主要要靠两种技术，一种是看起来是隔离的技术，称为namespace。在每个namespace中的应用看到的，都是不同的 IP地址、用户空间、进程ID等。另一种是用起来是隔离的技术，称为cgroup，即明明整台机器有很多的 CPU、内存，但是一个应用只能用其中的一部分。</p>
<p>另外，容器里还有镜像。也就是说，在你焊好集装箱的那一刻，将集装箱的状态保存下来的样子。就像孙悟空说“定！”，集装箱里的状态就被“定”在了那一刻。然后，这一刻的状态会被保存成一系列文件。无论在哪里运行这个镜像，都能完整地还原当时的情况。</p>
<p>通过容器，我们可以将CPU和内存资源，从大的资源池里面隔离出来，并通过镜像技术，在数据中心里面实现计算资源的自由漂移。</p>
<p>没有操作系统的时候，汇编程序员需要指定程序运行的CPU和内存物理地址。同理，数据中心的管理员，原来也需要指定程序运行的服务器以及使用的CPU和内存。现在，Kubernetes里面有一个调度器Scheduler，你只需要告诉它，你想运行10个4核8G的Java程序，它会自动帮你选择空闲的、有足够资源的服务器，去运行这些程序。</p>
<p>对于存储，无论是分布式文件系统和分布式块存储，需要对接到Kubernetes，让Kubernetes管理它们。如何对接呢？Kubernetes会提供CSI接口。这是一个标准接口，不同的存储可以实现这个接口来对接Kubernetes。是不是特别像设备驱动程序呀？操作系统只要定义统一的接口，不同的存储设备的驱动实现这些接口，就能被操作系统使用了。</p>
<p>对于网络，也是类似的机制，Kubernetes同样是提供统一的接口CNI。无论你用哪种方式实现网络模型，只要对接这个统一的接口，Kubernetes就可以管理容器的网络。</p>
<p>到此，有了这套鼎定市场格局的策略，作为龙头企业，马总的公司终于可以顺利上市敲钟，走向人生巅峰。从此，江湖人称“马爸爸”。</p>
<p>好了，马同学的创业故事就讲到这里了，操作系统的原理也给你串了一遍。你是否真的记住了这些原理呢？试着将这个创业故事讲给你的朋友听吧！</p>
<h2 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h2><ol>
<li>《自己动手写操作系统》</li>
<li>《UNIX 环境高级编程》</li>
<li>《一个操作系统的实现》</li>
<li>《系统虚拟化原理与实现》</li>
<li>《深入理解Linux虚拟内存管理》</li>
<li>《深入理解Linux内核》</li>
<li>《深入Linux内核架构》</li>
<li>《穿越计算机的迷雾》</li>
<li>《程序员的自我修养：链接、装载与库》</li>
<li>《操作系统真象还原》</li>
<li>《操作系统设计与实现》</li>
<li>《x86汇编语言：从实模式到保护模式》</li>
<li>《linux内核设计的艺术图解》</li>
<li>《Linux设备驱动开发详解》</li>
<li>《Linux内核完全注释》</li>
<li>《Linux内核设计与实现》</li>
<li>《Linux多线程服务端编程》</li>
<li>《Linux 内核分析及编程》</li>
<li>《IBM PC汇编语言程序设计》</li>
<li>《深入理解计算机系统》</li>
<li>《性能之巅：洞悉系统、企业与云计算》</li>
<li>《Linux内核协议栈源代码解析》</li>
<li>《UNIX网络编程》</li>
<li>《Linux/UNIX系统编程手册》</li>
<li>《深入Linux设备驱动程序内核机制》</li>
<li>《深入理解Linux驱动程序设计》</li>
<li>《Linux Device Drivers》</li>
<li>《TCP/IP详解卷》</li>
<li>《The TCP/IP Guide》</li>
<li>《深入理解LINUX网络技术内幕》</li>
<li>《Linux内核源代码情景分析》</li>
<li>《UNIX/Linux系统管理技术手册》</li>
</ol>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://kibazen.cn" rel="external nofollow noreferrer">Kiba Amor</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                    </span>
                <span class="reprint-info">
                    <a href="https://kibazen.cn/qu-tan-linux-cao-zuo-xi-tong-xue-xi-bi-ji/">https://kibazen.cn/qu-tan-linux-cao-zuo-xi-tong-xue-xi-bi-ji/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY-NC-ND 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://kibazen.cn" target="_blank">Kiba Amor</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                                    <span class="chip bg-color">极客时间</span>
                                </a>
                            
                                <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                                    <span class="chip bg-color">操作系统</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="qq,wechat,weibo,douban" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/ji-suan-liang-ge-3d-fang-xiang-zhi-jian-xuan-zhuan-de-si-yuan-shu/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/3.jpg" class="responsive-img" alt="计算两个3D方向之间旋转的四元数">
                        
                        <span class="card-title">计算两个3D方向之间旋转的四元数</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-12-27
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E7%AE%97%E6%B3%95/" class="post-category">
                                    算法
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%9B%9B%E5%85%83%E6%95%B0/">
                        <span class="chip bg-color">四元数</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/linux-xing-neng-you-hua-shi-zhan-xue-xi-bi-ji/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/7.jpg" class="responsive-img" alt="《Linux性能优化实战》学习笔记">
                        
                        <span class="card-title">《Linux性能优化实战》学习笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-11-04
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                    学习笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/">
                        <span class="chip bg-color">性能分析</span>
                    </a>
                    
                    <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                        <span class="chip bg-color">极客时间</span>
                    </a>
                    
                    <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">
                        <span class="chip bg-color">性能优化</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (true) {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 木叶禅<br />'
            + '文章作者: Kiba Amor<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者木叶禅所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('2'),
            headingSelector: 'h2, h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2022</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">Kiba Amor</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">625.2k</span>&nbsp;字
            
            
            
            
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/kibaamor" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>









    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=562236616" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 562236616" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>





    <a href="https://www.zhihu.com/people/kibaamor" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/kibaamor" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    

    

    

	
    

    

    

    
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
