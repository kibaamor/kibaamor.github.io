<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <meta name="keywords" content="《趣谈Linux操作系统》学习笔记, kiba, zen, amor, kibazen, kibaamor, 木叶, 木叶禅">
    <meta name="description" content="一个普通游戏程序员的博客">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>《趣谈Linux操作系统》学习笔记 | 木叶禅</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/css/my.css">

    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="木叶禅" type="application/atom+xml">
</head>



   <style>
    body{
       background-image: url(/medias/background.jpg);
       background-repeat:no-repeat;
       background-size:cover;
       background-attachment:fixed;
    }
</style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">木叶禅</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/leetcode/" class="waves-effect waves-light">
      
      <i class="fas fa-code" style="zoom: 0.6;"></i>
      
      <span>LeetCode</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/learn/" class="waves-effect waves-light">
      
      <i class="fas fa-book" style="zoom: 0.6;"></i>
      
      <span>学习</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tool/" class="waves-effect waves-light">
      
      <i class="fas fa-toolbox" style="zoom: 0.6;"></i>
      
      <span>工具</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories/" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags/" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about/" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">木叶禅</div>
        <div class="logo-desc">
            
            一个普通游戏程序员的博客
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/leetcode/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-code"></i>
			
			LeetCode
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/learn/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-book"></i>
			
			学习
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tool/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-toolbox"></i>
			
			工具
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    
<script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = 'f65e070788a2647953051a7a1b70ada7fd2b3f70cd4d93c977207f5b762987d4';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/17.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">《趣谈Linux操作系统》学习笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                                <span class="chip bg-color">极客时间</span>
                            </a>
                        
                            <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                                <span class="chip bg-color">操作系统</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                学习笔记
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-11-25
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2021-12-24
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    48.4k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    190 分
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="一、x86架构"><a href="#一、x86架构" class="headerlink" title="一、x86架构"></a>一、x86架构</h2><h3 id="1-1-8086的原理"><a href="#1-1-8086的原理" class="headerlink" title="1.1 8086的原理"></a>1.1 8086的原理</h3><p><img src="/images/《趣谈Linux操作系统》学习笔记/8086CPU.jpeg" alt="8086CPU"></p>
<ol>
<li><p>数据单元</p>
<p> 为了暂存数据，8086处理器内部有8个16位的通用寄存器，分别是AX、BX、CX、DX、SP、BP、SI、DI。这些寄存器主要用于在计算过程中暂存数据。</p>
<p> 其中AX、BX、CX、DX可以分成两个8位的寄存器来使用，分别是AH、AL、BH、BL、CH、CL、DH、DL，其中H就是High（高位），L就是Low（低位）的意思。</p>
</li>
<li><p>控制单元</p>
<p> IP寄存器就是指令指针寄存器（Instruction Pointer Register)，指向代码段中下一条指令的位置。CPU会根据它来不断地将指令从内存的代码段中，加载到CPU的指令队列中，然后交给运算单元去执行。</p>
<p> 如果需要切换进程呢？每个进程都分代码段和数据段，为了指向不同进程的地址空间，有四个16位的段寄存器，分别是CS、DS、SS、ES。</p>
<p> 其中，CS就是代码段寄存器（Code Segment Register），通过它可以找到代码在内存中的位置；DS是数据段的寄存器，通过它可以找到数据在内存中的位置。</p>
<p> SS是栈寄存器（Stack Register）。栈是程序运行中一个特殊的数据结构，数据的存取只能从一端进行，秉承后进先出的原则，push就是入栈，pop就是出栈。</p>
<p> ES为扩展段寄存器。</p>
<p> 在CS和DS中都存放着一个段的起始地址。代码段的偏移量在IP寄存器中，数据段的偏移量会放在通用寄存器中。</p>
<p> 这时候问题来了，CS和DS都是16位的，也就是说，起始地址都是16位的，IP寄存器和通用寄存器都是16位的，偏移量也是16位的，但是8086的地址总线地址是20位。怎么凑够这20位呢？方法就是“起始地址*16+偏移量”，也就是把CS和DS中的值左移4位，变成20位的，加上16位的偏移量，这样就可以得到最终20位的数据地址。</p>
<p> 因为偏移量只能是16位的，所以一个段最大的大小是2^16=64k。</p>
</li>
</ol>
<h3 id="1-2-32位处理器"><a href="#1-2-32位处理器" class="headerlink" title="1.2 32位处理器"></a>1.2 32位处理器</h3><p>在32位处理器中，有32根地址总线，可以访问2^32=4G的内存。</p>
<p>首先，通用寄存器有扩展，可以将8个16位的扩展到8个32位的，但是依然可以保留16位的和8位的使用方式。你可能会问，为什么高16位不分成两个8位使用呢？因为这样就不兼容了呀！</p>
<p>其中，指向下一条指令的指令指针寄存器IP，就会扩展成32位的，同样也兼容16位的。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/32位处理器.jpeg" alt="32位处理器"></p>
<p>而改动比较大，有点不兼容的就是段寄存器（Segment Register）。</p>
<p>CS、SS、DS、ES仍然是16位的，但是不再是段的起始地址。段的起始地址放在内存的某个地方。这个地方是一个表格，表格中的一项一项是段描述符（Segment Descriptor）。这里面才是真正的段的起始地址。而段寄存器里面保存的是在这个表格中的哪一项，称为选择子（Selector）。</p>
<p>这样，将一个从段寄存器直接拿到的段起始地址，就变成了先间接地从段寄存器找到表格中的一项，再从表格中的一项中拿到段起始地址。</p>
<blockquote>
<p>为了快速拿到段起始地址，段寄存器会从内存中拿到CPU的描述符高速缓存器中。</p>
</blockquote>
<p>32位的系统架构下，我们将前一种模式称为实模式（Real Pattern），后一种模式称为保护模式（Protected Pattern）。</p>
<p>当系统刚刚启动的时候，CPU是处于实模式的。</p>
<h3 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3 总结"></a>1.3 总结</h3><p><img src="/images/《趣谈Linux操作系统》学习笔记/x86架构.jpeg" alt="x86架构"></p>
<h2 id="二、系统启动过程"><a href="#二、系统启动过程" class="headerlink" title="二、系统启动过程"></a>二、系统启动过程</h2><p><img src="/images/《趣谈Linux操作系统》学习笔记/x86系统中的1M空间.jpeg" alt="x86系统中的1M空间"></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/quan0311/p/15292110.html">谈谈Linux系统启动流程</a></p>
<ol>
<li><p>系统加电后，CPU 运行在实模式下，且 CS 重置为 0xFFFF ，IP 为 0x0000。</p>
<p> 实模式下，内存地址的计算方式是：<code>段寄存器 * 16 + 偏移量</code> 。所以系统加电后运行的第一条指令在 <code>CS * 16 + IP = 0xFFFF0</code> 。</p>
<blockquote>
<p>实模式只有 1MB 内存寻址空间(X86)。</p>
</blockquote>
</li>
<li><p>在 x86 系统中，内存 <code>0xF0000-0xFFFFF</code> 映射到 BIOS 程序（存储在 ROM 中），BIOS 主要做三件事：</p>
<ol>
<li>检查硬件。</li>
<li>提供基本输入（中断）输出（显存映射）服务。</li>
<li><p>把 MBR（Master Boot Record，主引导记录/扇区）装载到内存 0x7C00 开始的 512 字节大小的内存区域，并设置 CS:IP 为 0x0000:7C00 。</p>
<blockquote>
<p>MBR 指启动盘的第一个扇区，大小 512 字节，并且以 0xAA55 结束。</p>
<p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2015/09/0x7c00.html">为什么主引导记录的内存地址是0x7C00？</a></p>
</blockquote>
</li>
</ol>
</li>
<li><p>MBR中存放的一般是由 Grub2 写入的 boot.img。</p>
</li>
<li><p>boot.img 加载 Grub2 的 core.img 。</p>
<blockquote>
<p>boot.img 由 <a target="_blank" rel="noopener" href="https://github.com/rhboot/grub2/blob/master/grub-core/boot/i386/pc/boot.S">boot.S</a> 编译而成。</p>
<p>core.img 包括 diskroot.img, lzma_decompress.img, kernel.img 以及其他模块。</p>
</blockquote>
</li>
<li><p>硬盘启动时，boot.img 先加载运行 diskroot.img, 再由 diskroot.img 加载 core.img 的其他内容。</p>
</li>
<li><p>diskroot.img 解压运行 lzma_compress.img 。</p>
<blockquote>
<p>diskroot.img 由 <a target="_blank" rel="noopener" href="https://github.com/rhboot/grub2/blob/master/grub-core/boot/i386/pc/diskboot.S">diskboot.S</a> 编译而成。</p>
</blockquote>
</li>
<li><p>lzma_compress.img 首先切换到保护模式。然后再解压运行 grub 内核 kernel.img。</p>
<blockquote>
<p>lzma_compress.img 由 <a target="_blank" rel="noopener" href="https://github.com/rhboot/grub2/blob/master/grub-core/boot/i386/pc/startup_raw.S">startup_raw.S</a> 编译而成。</p>
</blockquote>
<p> 调用 <code>real_to_prot</code> 切换到保护模式需要做三件事：</p>
<ul>
<li>启用分段, 辅助进程管理。在内存里面建立段描述符表，将寄存器里面的段寄存器变成段选择子，指向某个段描述符，这样就能实现不同进程的切换了。</li>
<li>启动分页, 辅助内存管理；将内存分成相等大小的块。</li>
<li>打开其他地址线。打开Gate A20，也就是第21根地址线的控制线。</li>
</ul>
</li>
<li><p>kernel.img 主要做的是根据配置信息，加载用户选择 linux kernel 并传递内核启动参数。</p>
<p> kernel.img 对应的代码是 <a target="_blank" rel="noopener" href="https://github.com/rhboot/grub2/blob/master/grub-core/kern/i386/pc/startup.S">startup.S</a> 以及一堆 c 文件，在 startup.S 中会调用 <code>grub_main</code> ，这是 grub kernel 的主函数。</p>
<p> 将真正的操作系统的 kernel 镜像加载执行，Linux Kernel的启动入口是 <code>start_kernel()</code> 。</p>
</li>
<li><p><code>start_kernel()</code> 中会进行一部分初始化工作，最后调用 <code>rest_init()</code> 来完成其他的初始化工作。</p>
</li>
<li><p><code>rest_init()</code> 中会创建系统 1 号进程 kernel_init ， kernel_init 会执行 ramdisk 中的 init 程序，并切换至用户态，加载驱动后执行真正的根文件系统中的 init 程序。</p>
</li>
<li><p><code>rest_init()</code> 中会创建系统 2 号进程 kthread ，负责所有内核态线程的调度和管理，是内核态所有运行线程的祖先。</p>
</li>
</ol>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/系统启动过程.jpeg" alt="系统启动过程"></p>
<h2 id="三、内核初始化"><a href="#三、内核初始化" class="headerlink" title="三、内核初始化"></a>三、内核初始化</h2><p>内核的启动从入口函数start_kernel()开始。在init/main.c文件中，start_kernel相当于内核的main函数。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/内核初始化.jpeg" alt="内核初始化"></p>
<h3 id="3-1-初始化任务管理"><a href="#3-1-初始化任务管理" class="headerlink" title="3.1 初始化任务管理"></a>3.1 初始化任务管理</h3><p>在操作系统里面，先要有个创始进程，有一行指令set_task_stack_end_magic(&amp;init_task)。这里面有一个参数init_task，它的定义是struct task_struct init_task = INIT_TASK(init_task)。它是系统创建的第一个进程，我们称为 <strong>0号进程</strong> 。这是唯一一个没有通过fork或者kernel_thread产生的进程，是进程列表的第一个。</p>
<h3 id="3-2-初始化中断处理"><a href="#3-2-初始化中断处理" class="headerlink" title="3.2 初始化中断处理"></a>3.2 初始化中断处理</h3><p>对应的函数是trap_init()，里面设置了很多中断门（Interrupt Gate），用于处理各种中断。其中有一个set_system_intr_gate(IA32_SYSCALL_VECTOR, entry_INT80_32)，这是系统调用的中断门。系统调用也是通过发送中断的方式进行的。</p>
<blockquote>
<p>64位的有另外的系统调用方法。</p>
</blockquote>
<h3 id="3-3-初始化内存管理"><a href="#3-3-初始化内存管理" class="headerlink" title="3.3 初始化内存管理"></a>3.3 初始化内存管理</h3><p>对应的，mm_init()就是用来初始化内存管理模块。</p>
<h3 id="3-4-初始化调度模块"><a href="#3-4-初始化调度模块" class="headerlink" title="3.4 初始化调度模块"></a>3.4 初始化调度模块</h3><p>sched_init()就是用于初始化调度模块。</p>
<h3 id="3-5-初始化-rootfs-文件系统"><a href="#3-5-初始化-rootfs-文件系统" class="headerlink" title="3.5 初始化 rootfs 文件系统"></a>3.5 初始化 rootfs 文件系统</h3><p>vfs_caches_init()会用来初始化基于内存的文件系统rootfs。在这个函数里面，会调用mnt_init()-&gt;init_rootfs()。这里面有一行代码，register_filesystem(&amp;rootfs_fs_type)。在VFS虚拟文件系统里面注册了一种类型，我们定义为struct file_system_type rootfs_fs_type。</p>
<h3 id="3-6-其他初始化"><a href="#3-6-其他初始化" class="headerlink" title="3.6 其他初始化"></a>3.6 其他初始化</h3><p>最后，start_kernel()调用的是rest_init()，用来做其他方面的初始化，这里面做了好多的工作。</p>
<h4 id="3-6-1-初始化1号进程"><a href="#3-6-1-初始化1号进程" class="headerlink" title="3.6.1 初始化1号进程"></a>3.6.1 初始化1号进程</h4><p>rest_init的第一大工作是，用kernel_thread(kernel_init, NULL, CLONE_FS)创建第二个进程，这个是 <strong>1号进程</strong> 。</p>
<p>1号进程对于操作系统来讲，有“划时代”的意义。因为它将运行一个用户进程。</p>
<p>x86提供了分层的权限机制，把区域分成了四个Ring，越往里权限越高，越往外权限越低。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/x86提供的分层权限机制.jpg" alt="x86提供的分层权限机制"></p>
<p>操作系统很好地利用了这个机制，将能够访问关键资源的代码放在Ring0，我们称为 <strong>内核态（Kernel Mode）</strong> ；将普通的程序代码放在Ring3，我们称为 <strong>用户态（User Mode）</strong> 。</p>
<ol>
<li><p>从内核态到用户态</p>
<p> 当执行kernel_thread这个函数的时候，系统在内核态。</p>
<p> kernel_thread的参数是一个函数kernel_init，也就是这个进程会运行这个函数。在kernel_init里面，会调用kernel_init_freeable()，里面有这样的代码：</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ramdisk_execute_command<span class="token punctuation">)</span>
    ramdisk_execute_command <span class="token operator">=</span> <span class="token string">"/init"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 先不管ramdisk是啥，我们回到kernel_init里面。这里面有这样的代码块：</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c">    <span class="token keyword">if</span> <span class="token punctuation">(</span>ramdisk_execute_command<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ret <span class="token operator">=</span> <span class="token function">run_init_process</span><span class="token punctuation">(</span>ramdisk_execute_command<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">try_to_run_init_process</span><span class="token punctuation">(</span><span class="token string">"/sbin/init"</span><span class="token punctuation">)</span> <span class="token operator">||</span>
        <span class="token operator">!</span><span class="token function">try_to_run_init_process</span><span class="token punctuation">(</span><span class="token string">"/etc/init"</span><span class="token punctuation">)</span> <span class="token operator">||</span>
        <span class="token operator">!</span><span class="token function">try_to_run_init_process</span><span class="token punctuation">(</span><span class="token string">"/bin/init"</span><span class="token punctuation">)</span> <span class="token operator">||</span>
        <span class="token operator">!</span><span class="token function">try_to_run_init_process</span><span class="token punctuation">(</span><span class="token string">"/bin/sh"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 这就说明，1号进程运行的是一个文件。如果我们打开run_init_process函数，会发现它调用的是do_execve。</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">run_init_process</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>init_filename<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    argv_init<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> init_filename<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">do_execve</span><span class="token punctuation">(</span><span class="token function">getname_kernel</span><span class="token punctuation">(</span>init_filename<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token keyword">const</span> __user <span class="token operator">*</span><span class="token punctuation">)</span>argv_init<span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token keyword">const</span> __user <span class="token operator">*</span><span class="token punctuation">)</span>envp_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> execve是一个系统调用，它的作用是运行一个执行文件。加一个do_的往往是内核系统调用的实现。没错，这就是一个系统调用，它会尝试运行ramdisk的“/init”，或者普通文件系统上的“/sbin/init”“/etc/init”“/bin/init”“/bin/sh”。不同版本的Linux会选择不同的文件启动，但是只要有一个起来了就可以。</p>
</li>
<li><p>如何利用执行init文件的机会，从内核态回到用户态呢？</p>
<p> 从系统调用的过程可以得到启发，“用户态-系统调用-保存寄存器-内核态执行系统调用-恢复寄存器-返回用户态”，然后接着运行。而咱们刚才运行init，是调用do_execve，正是上面的过程的后半部分，从内核态执行系统调用开始。</p>
<p> do_execve-&gt;do_execveat_common-&gt;exec_binprm-&gt;search_binary_handler，这里面会调用这段内容：</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">search_binary_handler</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">linux_binprm</span> <span class="token operator">*</span>bprm<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">struct</span> <span class="token class-name">linux_binfmt</span> <span class="token operator">*</span>fmt<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    retval <span class="token operator">=</span> fmt<span class="token operator">-&gt;</span><span class="token function">load_binary</span><span class="token punctuation">(</span>bprm<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 要运行一个程序，需要加载这个二进制文件，它是有一定格式的。Linux下一个常用的格式是ELF（Executable and Linkable Format，可执行与可链接格式）。于是我们就有了下面这个定义：</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">linux_binfmt</span> elf_format <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>module <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>load_binary <span class="token operator">=</span> load_elf_binary<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>load_shlib <span class="token operator">=</span> load_elf_library<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>core_dump <span class="token operator">=</span> elf_core_dump<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>min_coredump <span class="token operator">=</span> ELF_EXEC_PAGESIZE<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 这其实就是先调用load_elf_binary，最后调用start_thread。</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span>
<span class="token function">start_thread</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span>regs<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> new_ip<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> new_sp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token function">set_user_gs</span><span class="token punctuation">(</span>regs<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
regs<span class="token operator">-&gt;</span>fs    <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
regs<span class="token operator">-&gt;</span>ds    <span class="token operator">=</span> __USER_DS<span class="token punctuation">;</span>
regs<span class="token operator">-&gt;</span>es    <span class="token operator">=</span> __USER_DS<span class="token punctuation">;</span>
regs<span class="token operator">-&gt;</span>ss    <span class="token operator">=</span> __USER_DS<span class="token punctuation">;</span>
regs<span class="token operator">-&gt;</span>cs    <span class="token operator">=</span> __USER_CS<span class="token punctuation">;</span>
regs<span class="token operator">-&gt;</span>ip    <span class="token operator">=</span> new_ip<span class="token punctuation">;</span>
regs<span class="token operator">-&gt;</span>sp    <span class="token operator">=</span> new_sp<span class="token punctuation">;</span>
regs<span class="token operator">-&gt;</span>flags <span class="token operator">=</span> X86_EFLAGS_IF<span class="token punctuation">;</span>
<span class="token function">force_iret</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">EXPORT_SYMBOL_GPL</span><span class="token punctuation">(</span>start_thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> struct pt_regs，看名字里的register，就是寄存器啊！这个结构就是在系统调用的时候，内核中保存用户态运行上下文的，里面将用户态的代码段CS设置为<strong>USER_CS，将用户态的数据段DS设置为</strong>USER_DS，以及指令指针寄存器IP、栈指针寄存器SP。这里相当于补上了原来系统调用里，保存寄存器的一个步骤。</p>
<p> 最后的iret是用于从系统调用中返回。这个时候会恢复寄存器。从哪里恢复呢？按说是从进入系统调用的时候，保存的寄存器里面拿出。好在上面的函数补上了寄存器。CS和指令指针寄存器IP恢复了，指向用户态下一个要执行的语句。DS和函数栈指针SP也被恢复了，指向用户态函数栈的栈顶。所以，下一条指令，就从用户态开始运行了。</p>
</li>
<li><p>ramdisk的作用</p>
<p> init终于从内核到用户态了。一开始到用户态的是ramdisk的init，后来会启动真正根文件系统上的init，成为所有用户态进程的祖先。</p>
<p> 为什么会有ramdisk这个东西呢？内核启动的时候，一般会配置参数：</p>
 <pre class="line-numbers language-text" data-language="text"><code class="language-text">initrd16 /boot/initramfs-3.10.0-862.el7.x86_64.img<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 就是这个东西，这是一个基于内存的文件系统。为啥会有这个呢？</p>
<p> 是因为刚才那个init程序是在文件系统上的，文件系统一定是在一个存储设备上的，例如硬盘。Linux访问存储设备，要有驱动才能访问。如果存储系统数目很有限，那驱动可以直接放到内核里面，反正前面我们加载过内核到内存里了，现在可以直接对存储系统进行访问。</p>
<p> 但是存储系统越来越多了，如果所有市面上的存储系统的驱动都默认放进内核，内核就太大了。这该怎么办呢？</p>
<p> 我们只好先弄一个基于内存的文件系统。内存访问是不需要驱动的，这个就是ramdisk。这个时候，ramdisk是根文件系统。</p>
<p> 然后，我们开始运行ramdisk上的/init。等它运行完了就已经在用户态了。/init这个程序会先根据存储系统的类型加载驱动，有了驱动就可以设置真正的根文件系统了。有了真正的根文件系统，ramdisk上的/init会启动文件系统上的init。</p>
<p> 接下来就是各种系统的初始化。启动系统的服务，启动控制台，用户就可以登录进来了。</p>
<p> 先别忙着高兴，rest_init的第一个大事情才完成。我们仅仅形成了用户态所有进程的祖先。</p>
</li>
</ol>
<h4 id="3-6-2-创建2号进程"><a href="#3-6-2-创建2号进程" class="headerlink" title="3.6.2 创建2号进程"></a>3.6.2 创建2号进程</h4><p>kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES)又一次使用kernel_thread函数创建进程。这里需要指出一点，函数名thread可以翻译成“线程”，这也是操作系统很重要的一个概念。它和进程有什么区别呢？为什么这里创建的是进程，函数名却是线程呢？</p>
<p>从用户态来看，创建进程其实就是立项，也就是启动一个项目。这个项目需要人去执行。有多个人并行执行不同的部分，这就叫 <strong>多线程（Multithreading）</strong> 。如果只有一个人，那它就是这个项目的主线程。</p>
<p>但是从内核态来看，无论是进程，还是线程，我们都可以统称为任务（Task），都使用相同的数据结构，平放在同一个链表中。</p>
<p>这里的函数kthreadd，负责所有内核态的线程的调度和管理，是内核态所有线程运行的祖先。</p>
<h2 id="四、系统调用"><a href="#四、系统调用" class="headerlink" title="四、系统调用"></a>四、系统调用</h2><h3 id="4-1-glibc对系统调用的封装"><a href="#4-1-glibc对系统调用的封装" class="headerlink" title="4.1 glibc对系统调用的封装"></a>4.1 glibc对系统调用的封装</h3><p>在glibc的源代码中，有个文件syscalls.list，里面列着所有glibc的函数对应的系统调用，就像下面这个样子：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text"># File name Caller  Syscall name    Args    Strong name Weak names
open        -       open            Ci:siv  __libc_open __open open<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>另外，glibc还有一个脚本make-syscall.sh，可以根据上面的配置文件，对于每一个封装好的系统调用，生成一个文件。这个文件里面定义了一些宏，例如#define SYSCALL_NAME open。</p>
<p>glibc还有一个文件syscall-template.S，使用上面这个宏，定义了这个系统调用的调用方式。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">T_PSEUDO</span> <span class="token punctuation">(</span>SYSCALL_SYMBOL<span class="token punctuation">,</span> SYSCALL_NAME<span class="token punctuation">,</span> SYSCALL_NARGS<span class="token punctuation">)</span>
    ret
<span class="token function">T_PSEUDO_END</span> <span class="token punctuation">(</span>SYSCALL_SYMBOL<span class="token punctuation">)</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">T_PSEUDO</span><span class="token punctuation">(</span>SYMBOL<span class="token punctuation">,</span> NAME<span class="token punctuation">,</span> N<span class="token punctuation">)</span>       <span class="token function">PSEUDO</span> <span class="token punctuation">(</span>SYMBOL<span class="token punctuation">,</span> NAME<span class="token punctuation">,</span> N<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里的PSEUDO也是一个宏，它的定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">PSEUDO</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> syscall_name<span class="token punctuation">,</span> args<span class="token punctuation">)</span>        </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token punctuation">.</span>text<span class="token punctuation">;</span>                                        </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token function">ENTRY</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span>                                  </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token function">DO_CALL</span> <span class="token punctuation">(</span>syscall_name<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>               </span><span class="token punctuation">\</span>
    <span class="token expression">cmpl $<span class="token operator">-</span><span class="token number">4095</span><span class="token punctuation">,</span> <span class="token operator">%</span>eax<span class="token punctuation">;</span>                          </span><span class="token punctuation">\</span>
    <span class="token expression">jae SYSCALL_ERROR_LABEL</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>里面对于任何一个系统调用，会调用DO_CALL。这也是一个宏，这个宏32位和64位的定义是不一样的。</p>
<h3 id="4-2-32位系统调用过程"><a href="#4-2-32位系统调用过程" class="headerlink" title="4.2 32位系统调用过程"></a>4.2 32位系统调用过程</h3><p>我们先来看32位的情况（i386目录下的sysdep.h文件）。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Linux takes system call arguments in registers:
    syscall number  %eax         call-clobbered
    arg 1           %ebx         call-saved
    arg 2           %ecx         call-clobbered
    arg 3           %edx         call-clobbered
    arg 4           %esi         call-saved
    arg 5           %edi         call-saved
    arg 6           %ebp         call-saved
......
*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">DO_CALL</span><span class="token punctuation">(</span>syscall_name<span class="token punctuation">,</span> args<span class="token punctuation">)</span>                 </span><span class="token punctuation">\</span>
    <span class="token expression">PUSHARGS_</span><span class="token punctuation">##</span><span class="token expression">args                                 </span><span class="token punctuation">\</span>
    <span class="token expression">DOARGS_</span><span class="token punctuation">##</span><span class="token expression">args                                   </span><span class="token punctuation">\</span>
    <span class="token expression">movl $<span class="token function">SYS_ify</span> <span class="token punctuation">(</span>syscall_name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>eax<span class="token punctuation">;</span>             </span><span class="token punctuation">\</span>
    <span class="token expression">ENTER_KERNEL                                    </span><span class="token punctuation">\</span>
    <span class="token expression">POPARGS_</span><span class="token punctuation">##</span><span class="token expression">args</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里，我们将请求参数放在寄存器里面，根据系统调用的名称，得到系统调用号，放在寄存器eax里面，然后执行ENTER_KERNEL。</p>
<p>在Linux的源代码注释里面，我们可以清晰地看到，这些寄存器是如何传递系统调用号和参数的。</p>
<p>这里面的ENTER_KERNEL是什么呢？</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span> <span class="token expression">ENTER_KERNEL <span class="token keyword">int</span> $<span class="token number">0x80</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>int就是interrupt，也就是“中断”的意思。int $0x80就是触发一个软中断，通过它就可以陷入（trap）内核。</p>
<p>在内核启动的时候，还记得有一个trap_init()，其中有这样的代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">set_system_intr_gate</span><span class="token punctuation">(</span>IA32_SYSCALL_VECTOR<span class="token punctuation">,</span> entry_INT80_32<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这是一个软中断的陷入门。当接收到一个系统调用的时候，entry_INT80_32就被调用了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">ENTRY</span><span class="token punctuation">(</span>entry_INT80_32<span class="token punctuation">)</span>
        ASM_CLAC
        pushl   <span class="token operator">%</span>eax                    <span class="token comment">/* pt_regs-&gt;orig_ax */</span>
        SAVE_ALL pt_regs_ax<span class="token operator">=</span>$<span class="token operator">-</span>ENOSYS    <span class="token comment">/* save rest */</span>
        movl    <span class="token operator">%</span>esp<span class="token punctuation">,</span> <span class="token operator">%</span>eax
        call    do_syscall_32_irqs_on
<span class="token punctuation">.</span>Lsyscall_32_done<span class="token operator">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">.</span>Lirq_return<span class="token operator">:</span>
    INTERRUPT_RETURN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过push和SAVE_ALL将当前用户态的寄存器，保存在pt_regs结构里面。</p>
<p>进入内核之前，保存所有的寄存器，然后调用do_syscall_32_irqs_on。它的实现如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token function">do_syscall_32_irqs_on</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span>regs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">thread_info</span> <span class="token operator">*</span>ti <span class="token operator">=</span> <span class="token function">current_thread_info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>regs<span class="token operator">-&gt;</span>orig_ax<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>nr <span class="token operator">&lt;</span> IA32_NR_syscalls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        regs<span class="token operator">-&gt;</span>ax <span class="token operator">=</span> ia32_sys_call_table<span class="token punctuation">[</span>nr<span class="token punctuation">]</span><span class="token punctuation">(</span>
            <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>regs<span class="token operator">-&gt;</span>bx<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>regs<span class="token operator">-&gt;</span>cx<span class="token punctuation">,</span>
            <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>regs<span class="token operator">-&gt;</span>dx<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>regs<span class="token operator">-&gt;</span>si<span class="token punctuation">,</span>
            <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>regs<span class="token operator">-&gt;</span>di<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>regs<span class="token operator">-&gt;</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">syscall_return_slowpath</span><span class="token punctuation">(</span>regs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里，我们看到，将系统调用号从eax里面取出来，然后根据系统调用号，在系统调用表中找到相应的函数进行调用，并将寄存器中保存的参数取出来，作为函数参数。如果仔细比对，就能发现，这些参数所对应的寄存器，和Linux的注释是一样的。</p>
<p>根据宏定义，#define ia32_sys_call_table sys_call_table，系统调用就是放在这个表里面。至于这个表是如何形成的，我们后面讲。</p>
<p>当系统调用结束之后，在entry_INT80_32之后，紧接着调用的是INTERRUPT_RETURN，我们能够找到它的定义，也就是iret。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">INTERRUPT_RETURN                iret</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>iret指令将原来用户态保存的现场恢复回来，包含代码段、指令指针寄存器等。这时候用户态进程恢复执行。</p>
<p>这里我总结一下32位的系统调用是如何执行的。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/32位系统调用执行过程.jpg" alt="32位系统调用执行过程"></p>
<h3 id="4-3-64位系统调用过程"><a href="#4-3-64位系统调用过程" class="headerlink" title="4.3 64位系统调用过程"></a>4.3 64位系统调用过程</h3><p>我们再来看64位的情况（x86_64下的sysdep.h文件）。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* The Linux/x86-64 kernel expects the system call parameters in
   registers according to the following table:
    syscall number  rax
    arg 1           rdi
    arg 2           rsi
    arg 3           rdx
    arg 4           r10
    arg 5           r8
    arg 6           r9
......
*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">DO_CALL</span><span class="token punctuation">(</span>syscall_name<span class="token punctuation">,</span> args<span class="token punctuation">)</span>                       </span><span class="token punctuation">\</span>
  <span class="token expression">lea <span class="token function">SYS_ify</span> <span class="token punctuation">(</span>syscall_name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>rax<span class="token punctuation">;</span>                       </span><span class="token punctuation">\</span>
  <span class="token expression">syscall</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>和之前一样，还是将系统调用名称转换为系统调用号，放到寄存器rax。这里是真正进行调用，不是用中断了，而是改用syscall指令了。并且，通过注释我们也可以知道，传递参数的寄存器也变了。</p>
<p>syscall指令还使用了一种特殊的寄存器，我们叫 <strong>特殊模块寄存器（Model Specific Registers，简称MSR）</strong> 。这种寄存器是CPU为了完成某些特殊控制功能为目的的寄存器，其中就有系统调用。</p>
<p>在系统初始化的时候，trap_init除了初始化上面的中断模式，这里面还会调用cpu_init-&gt;syscall_init。这里面有这样的代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">wrmsrl</span><span class="token punctuation">(</span>MSR_LSTAR<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span>entry_SYSCALL_64<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>rdmsr和wrmsr是用来读写特殊模块寄存器的。MSR_LSTAR就是这样一个特殊的寄存器，当syscall指令调用的时候，会从这个寄存器里面拿出函数地址来调用，也就是调用entry_SYSCALL_64。</p>
<p>在arch/x86/entry/entry_64.S中定义了entry_SYSCALL_64。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">ENTRY</span><span class="token punctuation">(</span>entry_SYSCALL_64<span class="token punctuation">)</span>
    <span class="token comment">/* Construct struct pt_regs on stack */</span>
    pushq   $__USER_DS                      <span class="token comment">/* pt_regs-&gt;ss */</span>
    pushq   <span class="token function">PER_CPU_VAR</span><span class="token punctuation">(</span>rsp_scratch<span class="token punctuation">)</span>        <span class="token comment">/* pt_regs-&gt;sp */</span>
    pushq   <span class="token operator">%</span>r11                            <span class="token comment">/* pt_regs-&gt;flags */</span>
    pushq   $__USER_CS                      <span class="token comment">/* pt_regs-&gt;cs */</span>
    pushq   <span class="token operator">%</span>rcx                            <span class="token comment">/* pt_regs-&gt;ip */</span>
    pushq   <span class="token operator">%</span>rax                            <span class="token comment">/* pt_regs-&gt;orig_ax */</span>
    pushq   <span class="token operator">%</span>rdi                            <span class="token comment">/* pt_regs-&gt;di */</span>
    pushq   <span class="token operator">%</span>rsi                            <span class="token comment">/* pt_regs-&gt;si */</span>
    pushq   <span class="token operator">%</span>rdx                            <span class="token comment">/* pt_regs-&gt;dx */</span>
    pushq   <span class="token operator">%</span>rcx                            <span class="token comment">/* pt_regs-&gt;cx */</span>
    pushq   $<span class="token operator">-</span>ENOSYS                        <span class="token comment">/* pt_regs-&gt;ax */</span>
    pushq   <span class="token operator">%</span>r8                             <span class="token comment">/* pt_regs-&gt;r8 */</span>
    pushq   <span class="token operator">%</span>r9                             <span class="token comment">/* pt_regs-&gt;r9 */</span>
    pushq   <span class="token operator">%</span>r10                            <span class="token comment">/* pt_regs-&gt;r10 */</span>
    pushq   <span class="token operator">%</span>r11                            <span class="token comment">/* pt_regs-&gt;r11 */</span>
    sub     $<span class="token punctuation">(</span><span class="token number">6</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>rsp                    <span class="token comment">/* pt_regs-&gt;bp, bx, r12-15 not saved */</span>
    movq    <span class="token function">PER_CPU_VAR</span><span class="token punctuation">(</span>current_task<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>r11
    testl   $_TIF_WORK_SYSCALL_ENTRY<span class="token operator">|</span>_TIF_ALLWORK_MASK<span class="token punctuation">,</span> <span class="token function">TASK_TI_flags</span><span class="token punctuation">(</span><span class="token operator">%</span>r11<span class="token punctuation">)</span>
    jnz     entry_SYSCALL64_slow_path
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
entry_SYSCALL64_slow_path<span class="token operator">:</span>
    <span class="token comment">/* IRQs are off. */</span>
    SAVE_EXTRA_REGS
    movq    <span class="token operator">%</span>rsp<span class="token punctuation">,</span> <span class="token operator">%</span>rdi
    call    do_syscall_64           <span class="token comment">/* returns with IRQs disabled */</span>
return_from_SYSCALL_64<span class="token operator">:</span>
    RESTORE_EXTRA_REGS
    TRACE_IRQS_IRETQ
    movq    <span class="token function">RCX</span><span class="token punctuation">(</span><span class="token operator">%</span>rsp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>rcx
    movq    <span class="token function">RIP</span><span class="token punctuation">(</span><span class="token operator">%</span>rsp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>r11
    movq    <span class="token function">R11</span><span class="token punctuation">(</span><span class="token operator">%</span>rsp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>r11
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
syscall_return_via_sysret<span class="token operator">:</span>
    <span class="token comment">/* rcx and r11 are already restored (see code above) */</span>
    RESTORE_C_REGS_EXCEPT_RCX_R11
    movq    <span class="token function">RSP</span><span class="token punctuation">(</span><span class="token operator">%</span>rsp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>rsp
    USERGS_SYSRET64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里先保存了很多寄存器到pt_regs结构里面，例如用户态的代码段、数据段、保存参数的寄存器，然后调用entry_SYSCALL64_slow_pat-&gt;do_syscall_64。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">__visible <span class="token keyword">void</span> <span class="token function">do_syscall_64</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span>regs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">thread_info</span> <span class="token operator">*</span>ti <span class="token operator">=</span> <span class="token function">current_thread_info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> nr <span class="token operator">=</span> regs<span class="token operator">-&gt;</span>orig_ax<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token punctuation">(</span>nr <span class="token operator">&amp;</span> __SYSCALL_MASK<span class="token punctuation">)</span> <span class="token operator">&lt;</span> NR_syscalls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            regs<span class="token operator">-&gt;</span>ax <span class="token operator">=</span> sys_call_table<span class="token punctuation">[</span>nr <span class="token operator">&amp;</span> __SYSCALL_MASK<span class="token punctuation">]</span><span class="token punctuation">(</span>
                    regs<span class="token operator">-&gt;</span>di<span class="token punctuation">,</span> regs<span class="token operator">-&gt;</span>si<span class="token punctuation">,</span> regs<span class="token operator">-&gt;</span>dx<span class="token punctuation">,</span>
                    regs<span class="token operator">-&gt;</span>r10<span class="token punctuation">,</span> regs<span class="token operator">-&gt;</span>r8<span class="token punctuation">,</span> regs<span class="token operator">-&gt;</span>r9<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">syscall_return_slowpath</span><span class="token punctuation">(</span>regs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在do_syscall_64里面，从rax里面拿出系统调用号，然后根据系统调用号，在系统调用表sys_call_table中找到相应的函数进行调用，并将寄存器中保存的参数取出来，作为函数参数。如果仔细比对，你就能发现，这些参数所对应的寄存器，和Linux的注释又是一样的。</p>
<p>所以，无论是32位，还是64位，都会到系统调用表sys_call_table这里来。</p>
<p>在研究系统调用表之前，我们看64位的系统调用返回的时候，执行的是USERGS_SYSRET64。定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">USERGS_SYSRET64     </span><span class="token punctuation">\</span>
    <span class="token expression">swapgs<span class="token punctuation">;</span>                 </span><span class="token punctuation">\</span>
    <span class="token expression">sysretq<span class="token punctuation">;</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这里，返回用户态的指令变成了sysretq。</p>
<p>我们这里总结一下64位的系统调用是如何执行的。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/64位系统调用执行过程.jpg" alt="64位系统调用执行过程.jpg"></p>
<h3 id="4-4-系统调用表"><a href="#4-4-系统调用表" class="headerlink" title="4.4 系统调用表"></a>4.4 系统调用表</h3><p>32位的系统调用表定义在面arch/x86/entry/syscalls/syscall_32.tbl文件里。例如open是这样定义的：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">5   i386    open            sys_open  compat_sys_open<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>64位的系统调用定义在另一个文件arch/x86/entry/syscalls/syscall_64.tbl里。例如open是这样定义的：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">2   common  open            sys_open<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>第一列的数字是系统调用号。可以看出，32位和64位的系统调用号是不一样的。第三列是系统调用的名字，第四列是系统调用在内核的实现函数。不过，它们都是以sys_开头。</p>
<p>系统调用在内核中的实现函数要有一个声明。声明往往在include/linux/syscalls.h文件中。例如sys_open是这样声明的：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">asmlinkage <span class="token keyword">long</span> <span class="token function">sys_open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>filename<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> umode_t mode<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>真正的实现这个系统调用，一般在一个.c文件里面，例如sys_open的实现在fs/open.c里面，但是你会发现样子很奇怪。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>open<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> filename<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> flags<span class="token punctuation">,</span> umode_t<span class="token punctuation">,</span> mode<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">force_o_largefile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        flags <span class="token operator">|=</span> O_LARGEFILE<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">do_sys_open</span><span class="token punctuation">(</span>AT_FDCWD<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>SYSCALL_DEFINE3是一个宏系统调用最多六个参数，根据参数的数目选择宏。具体是这样定义的：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">SYSCALL_DEFINE1</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">SYSCALL_DEFINEx</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> _</span><span class="token punctuation">##</span><span class="token expression">name<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">SYSCALL_DEFINE2</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">SYSCALL_DEFINEx</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> _</span><span class="token punctuation">##</span><span class="token expression">name<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">SYSCALL_DEFINEx</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> _</span><span class="token punctuation">##</span><span class="token expression">name<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">SYSCALL_DEFINE4</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">SYSCALL_DEFINEx</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> _</span><span class="token punctuation">##</span><span class="token expression">name<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">SYSCALL_DEFINE5</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">SYSCALL_DEFINEx</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> _</span><span class="token punctuation">##</span><span class="token expression">name<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">SYSCALL_DEFINE6</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">SYSCALL_DEFINEx</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> _</span><span class="token punctuation">##</span><span class="token expression">name<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span>


<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">SYSCALL_DEFINEx</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> sname<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>                          </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">SYSCALL_METADATA</span><span class="token punctuation">(</span>sname<span class="token punctuation">,</span> x<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span>                 </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">__SYSCALL_DEFINEx</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> sname<span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span>


<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">__PROTECT</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">asmlinkage_protect</span><span class="token punctuation">(</span>__VA_ARGS__<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">__SYSCALL_DEFINEx</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>                                 </span><span class="token punctuation">\</span>
        <span class="token expression">asmlinkage <span class="token keyword">long</span> sys</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_DECL<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span>       </span><span class="token punctuation">\</span>
                <span class="token expression"><span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">alias</span><span class="token punctuation">(</span><span class="token function">__stringify</span><span class="token punctuation">(</span>SyS</span><span class="token punctuation">##</span><span class="token expression">name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">long</span> SYSC</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_DECL<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </span><span class="token punctuation">\</span>
        <span class="token expression">asmlinkage <span class="token keyword">long</span> SyS</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_LONG<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      </span><span class="token punctuation">\</span>
        <span class="token expression">asmlinkage <span class="token keyword">long</span> SyS</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_LONG<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span>       </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token punctuation">{</span>                                                               </span><span class="token punctuation">\</span>
                <span class="token expression"><span class="token keyword">long</span> ret <span class="token operator">=</span> SYSC</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_CAST<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </span><span class="token punctuation">\</span>
                <span class="token expression"><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_TEST<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">;</span>                         </span><span class="token punctuation">\</span>
                <span class="token expression"><span class="token function">__PROTECT</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> ret<span class="token punctuation">,</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_ARGS<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       </span><span class="token punctuation">\</span>
                <span class="token expression"><span class="token keyword">return</span> ret<span class="token punctuation">;</span>                                             </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token punctuation">}</span>                                                               </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">long</span> SYSC</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">name</span><span class="token punctuation">(</span><span class="token function">__MAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>__SC_DECL<span class="token punctuation">,</span>__VA_ARGS__<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果我们把宏展开之后，实现如下，和声明的是一样的。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">asmlinkage <span class="token keyword">long</span> <span class="token function">sys_open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span> filename<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> mode<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">long</span> ret<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">force_o_largefile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        flags <span class="token operator">|=</span> O_LARGEFILE<span class="token punctuation">;</span>

    ret <span class="token operator">=</span> <span class="token function">do_sys_open</span><span class="token punctuation">(</span>AT_FDCWD<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">asmlinkage_protect</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> ret<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>声明和实现都好了。接下来，在编译的过程中，需要根据syscall_32.tbl和syscall_64.tbl生成自己的unistd_32.h和unistd_64.h。生成方式在arch/x86/entry/syscalls/Makefile中。</p>
<p>声明和实现都好了。接下来，在编译的过程中，需要根据syscall_32.tbl和syscall_64.tbl生成自己的unistd_32.h和unistd_64.h。生成方式在arch/x86/entry/syscalls/Makefile中。</p>
<p>这里面会使用两个脚本，其中第一个脚本arch/x86/entry/syscalls/syscallhdr.sh，会在文件中生成#define <strong>NR_open；第二个脚本arch/x86/entry/syscalls/syscalltbl.sh，会在文件中生成</strong>SYSCALL(__NR_open, sys_open)。这样，unistd_32.h和unistd_64.h是对应的系统调用号和系统调用实现函数之间的对应关系。</p>
<p>在文件arch/x86/entry/syscall_32.c，定义了这样一个表，里面include了这个头文件，从而所有的sys_系统调用都在这个表里面了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">__visible <span class="token keyword">const</span> sys_call_ptr_t ia32_sys_call_table<span class="token punctuation">[</span>__NR_syscall_compat_max<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">/*
        * Smells like a compiler bug -- it doesn't work
        * when the &amp; below is removed.
        */</span>
    <span class="token punctuation">[</span><span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> __NR_syscall_compat_max<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>sys_ni_syscall<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;asm/syscalls_32.h&gt;</span></span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同理，在文件arch/x86/entry/syscall_64.c，定义了这样一个表，里面include了这个头文件，这样所有的sys_系统调用就都在这个表里面了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* System call table for x86-64. */</span>
asmlinkage <span class="token keyword">const</span> sys_call_ptr_t sys_call_table<span class="token punctuation">[</span>__NR_syscall_max<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">/*
     * Smells like a compiler bug -- it doesn't work
     * when the &amp; below is removed.
     */</span>
    <span class="token punctuation">[</span><span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> __NR_syscall_max<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>sys_ni_syscall<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;asm/syscalls_64.h&gt;</span></span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="五、进程"><a href="#五、进程" class="headerlink" title="五、进程"></a>五、进程</h2><h3 id="5-1-源码编译"><a href="#5-1-源码编译" class="headerlink" title="5.1 源码编译"></a>5.1 源码编译</h3><p>CPU是不能执行文本文件里面的指令的，这些指令只有人能看懂，CPU能够执行的命令是二进制的，比如“0101”这种，所以这些指令还需要翻译一下，这个翻译的过程就是编译（Compile）。</p>
<p>在Linux下面，二进制的程序也要有严格的格式，这个格式我们称为ELF（Executeable and Linkable Format，可执行与可链接格式）。这个格式可以根据编译的结果不同，分为不同的格式。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/从文本文件编译成二进制格式.jpeg" alt="从文本文件编译成二进制格式"></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc -c -fPIC mylib.c
gcc -c -fPIC test_mylib.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ol>
<li><p>可重定位文件<br> 在编译的时候，先做预处理工作，例如将头文件嵌入到正文中，将定义的宏展开，然后就是真正的编译过程，最终编译成为.o文件，这就是ELF的第一种类型，<strong>可重定位文件（Relocatable File）</strong> 。</p>
<p> <img src="/images/《趣谈Linux操作系统》学习笔记/可重定位文件格式.jpg" alt="可重定位文件格式.jpg"></p>
<p> ELF文件的头是用于描述整个文件的。这个文件格式在内核中有定义，分别为struct elf32_hdr和struct elf64_hdr。</p>
<p> 接下来来看一个一个的section，也叫节。</p>
<ul>
<li>.text：放编译好的二进制可执行代码</li>
<li>.data：已经初始化好的全局变量</li>
<li>.rodata：只读数据，例如字符串常量、const的变量</li>
<li>.bss：未初始化全局变量，运行时会置0</li>
<li>.symtab：符号表，记录的则是函数和变量</li>
<li><p>.strtab：字符串表、字符串常量和变量名</p>
<p>这些节的元数据信息也需要有一个地方保存，就是最后的节头部表（Section Header Table）。在这个表里面，每一个section都有一项，在代码里面也有定义struct elf32_shdr和struct elf64_shdr。在ELF的头里面，有描述这个文件的节头部表的位置，有多少个表项等等信息。</p>
<p>.o里面的位置是不确定的，但是必须是可重新定位的，因为它将来是要做函数库的。有的section，例如.rel.text, .rel.data就与重定位有关。</p>
<p>要想让代码被重用，不能以.o的形式存在，而是要形成库文件，最简单的类型是静态链接库.a文件（Archives），仅仅将一系列对象文件（.o）归档为一个文件，使用命令ar创建。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ar cr libstatic_mylib.a mylib.o<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>虽然这里libstatic_mylib.a里面只有一个.o，但是实际情况可以有多个.o。当有程序要使用这个静态连接库的时候，会将.o文件提取出来，链接到程序中。</p>
</li>
</ul>
</li>
<li><p>可执行文件</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc -o static_test_mylib test_mylib.o -L. -lstatic_mylib<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 在这个命令里，-L表示在当前目录下找.a文件，-lstatic_mylib会自动补全文件名，比如加前缀lib，后缀.a，变成libstatic_mylib.a，找到这个.a文件后，将里面的mylib.o取出来，和test_mylib.o做一个链接，形成二进制执行文件static_test_mylib。</p>
<p> 形成的二进制文件叫可执行文件，是ELF的第二种格式，格式如下：</p>
<p> <img src="/images/《趣谈Linux操作系统》学习笔记/可执行文件格式.jpg" alt="可执行文件格式"></p>
<p> 这个格式和.o文件大致相似，还是分成一个个的section，并且被节头表描述。只不过这些section是多个.o文件合并过的。但是这个时候，这个文件已经是马上就可以加载到内存里面执行的文件了，因而这些section被分成了需要加载到内存里面的代码段、数据段和不需要加载到内存里面的部分，将小的section合成了大的段segment，并且在最前面加一个段头表（Segment Header Table）。在代码里面的定义为struct elf32_phdr和struct elf64_phdr，这里面除了有对于段的描述之外，最重要的是p_vaddr，这个是这个段加载到内存的虚拟地址。</p>
<p> 在ELF头里面，有一项e_entry，也是个虚拟地址，是这个程序运行的入口。</p>
<p> 静态链接库一旦链接进去，代码和变量的section都合并了，因而程序运行的时候，就不依赖于这个库是否存在。但是这样有一个缺点，就是相同的代码段，如果被多个程序使用的话，在内存里面就有多份，而且一旦静态链接库更新了，如果二进制执行文件不重新编译，也不随着更新。</p>
</li>
<li><p>动态链接库</p>
<p> 因而就出现了另一种，<strong>动态链接库（Shared Libraries）</strong>，不仅仅是一组对象文件的简单归档，而是多个对象文件的重新组合，可被多个程序共享。</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c">gcc <span class="token operator">-</span>shared <span class="token operator">-</span>fPIC <span class="token operator">-</span>o libdynamic_mylib<span class="token punctuation">.</span>so mylib<span class="token punctuation">.</span>o<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 当一个动态链接库被链接到一个程序文件中的时候，最后的程序文件并不包括动态链接库中的代码，而仅仅包括对动态链接库的引用，并且不保存动态链接库的全路径，仅仅保存动态链接库的名称。</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c">gcc <span class="token operator">-</span>o dynamic_test_mylib test_mylib<span class="token punctuation">.</span>o <span class="token operator">-</span>L<span class="token punctuation">.</span> <span class="token operator">-</span>ldynamic_mylib<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 当运行这个程序的时候，首先寻找动态链接库，然后加载它。默认情况下，系统在/lib和/usr/lib文件夹下寻找动态链接库。如果找不到就会报错，我们可以设定LD_LIBRARY_PATH环境变量，程序运行时会在此环境变量指定的文件夹下寻找动态链接库。</p>
<p> 动态链接库，就是ELF的第三种类型， <strong>共享对象文件（Shared Object）</strong> 。</p>
<p> 基于动态连接库创建出来的二进制文件格式还是ELF，但是稍有不同。</p>
<p> 首先，多了一个.interp的Segment，这里面是ld-linux.so，这是动态链接器，也就是说，运行时的链接动作都是它做的。</p>
<p> 另外，ELF文件中还多了两个section，一个是.plt，过程链接表（Procedure Linkage Table，PLT），一个是.got.plt，全局偏移量表（Global Offset Table，GOT）。</p>
<p> 它们是怎么工作的，使得程序运行的时候，可以将so文件动态链接到进程空间的呢？</p>
<p> dynamic_test_mylib这个程序要调用libdynamic_mylib.so里的函数。由于是运行时才去找，编译的时候，压根不知道这个函数在哪里，所以就在PLT里面建立一项PLT[x]。这一项也是一些代码，有点像一个本地的代理，在二进制程序dynamic_test_mylib里面，不直接调用libdynamic_mylib.so里的函数，而是调用PLT[x]里面的代理代码，这个代理代码会在运行的时候找真正的函数。</p>
<p> 去哪里找代理代码呢？这就用到了GOT，这里面也会为libdynamic_mylib.so中的函数创建一项GOT[y]。这一项是运行时libdynamic_mylib.so中的函数在内存中真正的地址。</p>
<p> 如果这个地址在，dynamic_test_mylib调用PLT[x]里面的代理代码，代理代码调用GOT表中对应项GOT[y]，调用的就是加载到内存中的libdynamic_mylib.so里面的对应函数了。</p>
<p> 但是GOT怎么知道的呢？对于libdynamic_mylib.so中的函数，GOT一开始就会创建一项GOT[y]，但是这里面没有真正的地址，因为它也不知道，但是它有办法，它又回调PLT，告诉它，你里面的代理代码来找我要libdynamic_mylib.so中函数的真实地址，我不知道，你想想办法吧。</p>
<p> PLT这个时候会转而调用PLT[0]，也即第一项，PLT[0]转而调用GOT[2]，这里面是ld-linux.so的入口函数，这个函数会找到加载到内存中的libdynamic_mylib.so里面的对应函数的地址，然后把这个地址放在GOT[y]里面。下次，PLT[x]的代理函数就能够直接调用了。</p>
</li>
</ol>
<h3 id="5-2-运行程序为进程"><a href="#5-2-运行程序为进程" class="headerlink" title="5.2 运行程序为进程"></a>5.2 运行程序为进程</h3><p>在内核中，有这样一个数据结构，用来定义加载二进制文件的方法。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">linux_binfmt</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">list_head</span> lh<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">module</span> <span class="token operator">*</span>module<span class="token punctuation">;</span>
        <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>load_binary<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">linux_binprm</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>load_shlib<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>core_dump<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">coredump_params</span> <span class="token operator">*</span>cprm<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> min_coredump<span class="token punctuation">;</span>     <span class="token comment">/* minimal dump size */</span>
<span class="token punctuation">}</span> __randomize_layout<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于ELF文件格式，有对应的实现。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">linux_binfmt</span> elf_format <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span>module         <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>load_binary    <span class="token operator">=</span> load_elf_binary<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>load_shlib     <span class="token operator">=</span> load_elf_library<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>core_dump      <span class="token operator">=</span> elf_core_dump<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>min_coredump   <span class="token operator">=</span> ELF_EXEC_PAGESIZE<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>load_elf_binary是不是你很熟悉？没错，我们加载内核镜像的时候，用的也是这种格式。</p>
<p>还记得当时是谁调用的load_elf_binary函数吗？具体是这样的：do_execve-&gt;do_execveat_common-&gt;exec_binprm-&gt;search_binary_handler。</p>
<p>那do_execve又是被谁调用的呢？我们看下面的代码。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>execve<span class="token punctuation">,</span>
        <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> filename<span class="token punctuation">,</span>
        <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token keyword">const</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> argv<span class="token punctuation">,</span>
        <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token keyword">const</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> envp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">do_execve</span><span class="token punctuation">(</span><span class="token function">getname</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">,</span> argv<span class="token punctuation">,</span> envp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>学过了系统调用一节，你会发现，原理是exec这个系统调用最终调用的load_elf_binary。</p>
<p>exec比较特殊，它是一组函数：</p>
<ul>
<li>包含p的函数（execvp, execlp）会在PATH路径下面寻找程序；</li>
<li>不包含p的函数需要输入程序的全路径；</li>
<li>包含v的函数（execv, execvp, execve）以数组的形式接收参数；</li>
<li>包含l的函数（execl, execlp, execle）以列表的形式接收参数；</li>
<li>包含e的函数（execve, execle）以数组的形式接收环境变量。</li>
</ul>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/exec系列函数.jpg" alt="exec系列函数"></p>
<h3 id="5-3-进程树"><a href="#5-3-进程树" class="headerlink" title="5.3 进程树"></a>5.3 进程树</h3><p>既然所有的进程都是从父进程fork过来的，那总归有一个祖宗进程，这就是咱们系统启动的init进程。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/linux进程树.jpeg" alt="linux进程树"></p>
<p>在解析Linux的启动过程的时候，1号进程是/sbin/init。如果在centOS 7里面，我们ls一下，可以看到，这个进程是被软链接到systemd的。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/sbin/init -<span class="token operator">&gt;</span> <span class="token punctuation">..</span>/lib/systemd/systemd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>系统启动之后，init进程会启动很多的daemon进程，为系统运行提供服务，然后就是启动getty，让用户登录，登录后运行shell，用户启动的进程都是通过shell运行的，从而形成了一棵进程树。</p>
<p>我们可以通过ps -ef命令查看当前系统启动的进程，我们会发现有三类进程。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ps</span> -ef
<span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
root         <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?        00:00:29 /usr/lib/systemd/systemd --system --deserialize <span class="token number">21</span>
root         <span class="token number">2</span>     <span class="token number">0</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?        00:00:00 <span class="token punctuation">[</span>kthreadd<span class="token punctuation">]</span>
root         <span class="token number">3</span>     <span class="token number">2</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?        00:00:00 <span class="token punctuation">[</span>ksoftirqd/0<span class="token punctuation">]</span>
root         <span class="token number">5</span>     <span class="token number">2</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?        00:00:00 <span class="token punctuation">[</span>kworker/0:0H<span class="token punctuation">]</span>
root         <span class="token number">9</span>     <span class="token number">2</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?        00:00:40 <span class="token punctuation">[</span>rcu_sched<span class="token punctuation">]</span>
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
root       <span class="token number">337</span>     <span class="token number">2</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?        00:00:01 <span class="token punctuation">[</span>kworker/3:1H<span class="token punctuation">]</span>
root       <span class="token number">380</span>     <span class="token number">1</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?        00:00:00 /usr/lib/systemd/systemd-udevd
root       <span class="token number">415</span>     <span class="token number">1</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?        00:00:01 /sbin/auditd
root       <span class="token number">498</span>     <span class="token number">1</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?        00:00:03 /usr/lib/systemd/systemd-logind
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
root       <span class="token number">852</span>     <span class="token number">1</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?        00:06:25 /usr/sbin/rsyslogd -n
root      <span class="token number">2580</span>     <span class="token number">1</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?        00:00:00 /usr/sbin/sshd -D
root     <span class="token number">29058</span>     <span class="token number">2</span>  <span class="token number">0</span> Jan03 ?        00:00:01 <span class="token punctuation">[</span>kworker/1:2<span class="token punctuation">]</span>
root     <span class="token number">29672</span>     <span class="token number">2</span>  <span class="token number">0</span> Jan04 ?        00:00:09 <span class="token punctuation">[</span>kworker/2:1<span class="token punctuation">]</span>
root     <span class="token number">30467</span>     <span class="token number">1</span>  <span class="token number">0</span> Jan06 ?        00:00:00 /usr/sbin/crond -n
root     <span class="token number">31574</span>     <span class="token number">2</span>  <span class="token number">0</span> Jan08 ?        00:00:01 <span class="token punctuation">[</span>kworker/u128:2<span class="token punctuation">]</span>
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
root     <span class="token number">32792</span>  <span class="token number">2580</span>  <span class="token number">0</span> Jan10 ?        00:00:00 sshd: root@pts/0
root     <span class="token number">32794</span> <span class="token number">32792</span>  <span class="token number">0</span> Jan10 pts/0    00:00:00 -bash
root     <span class="token number">32901</span> <span class="token number">32794</span>  <span class="token number">0</span> 00:01 pts/0    00:00:00 <span class="token function">ps</span> -ef<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>你会发现，PID 1的进程就是我们的init进程systemd，PID 2的进程是内核线程kthreadd，这两个我们在内核启动的时候都见过。其中用户态的不带中括号，内核态的带中括号。</p>
<p>接下来进程号依次增大，但是你会看所有带中括号的内核态的进程，祖先都是2号进程。而用户态的进程，祖先都是1号进程。tty那一列，是问号的，说明不是前台启动的，一般都是后台的服务。</p>
<p>pts的父进程是sshd，bash的父进程是pts，ps -ef这个命令的父进程是bash。这样整个链条都比较清晰了。</p>
<h3 id="5-4-总结"><a href="#5-4-总结" class="headerlink" title="5.4 总结"></a>5.4 总结</h3><p>我们首先通过图右边的文件编译过程，生成so文件和可执行文件，放在硬盘上。下图左边的用户态的进程A执行fork，创建进程B，在进程B的处理逻辑中，执行exec系列系统调用。这个系统调用会通过load_elf_binary方法，将刚才生成的可执行文件，加载到进程B的内存中执行。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/进程从代码到二进制到运行的过程.jpeg" alt="进程从代码到二进制到运行的过程"></p>
<h2 id="六、线程"><a href="#六、线程" class="headerlink" title="六、线程"></a>六、线程</h2><h3 id="6-1-为什么要有线程？"><a href="#6-1-为什么要有线程？" class="headerlink" title="6.1 为什么要有线程？"></a>6.1 为什么要有线程？</h3><p>对于任何一个进程来讲，即便我们没有主动去创建线程，进程也是默认有一个主线程的。线程是负责执行二进制指令的，一行一行执行下去。进程要比线程管的宽多了，除了执行指令之外，内存、文件系统等等都要它来管。</p>
<p><strong>进程相当于一个项目，而线程就是为了完成项目需求，而建立的一个个开发任务。</strong></p>
<p>使用进程实现并行执行的问题也有两个。第一，创建进程占用资源太多；第二，进程之间的通信需要数据在不同的内存空间传来传去，无法共享。</p>
<h3 id="6-2-如何创建线程？"><a href="#6-2-如何创建线程？" class="headerlink" title="6.2 如何创建线程？"></a>6.2 如何创建线程？</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">NUM_OF_TASKS <span class="token number">5</span></span></span>

<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">downloadfile</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>filename<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am downloading the file %s!\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">long</span> downloadtime <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">100</span><span class="token punctuation">;</span>
   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I finish downloading the file within %d minutes!\n"</span><span class="token punctuation">,</span> downloadtime<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>downloadtime<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token keyword">char</span> files<span class="token punctuation">[</span>NUM_OF_TASKS<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">"file1.avi"</span><span class="token punctuation">,</span><span class="token string">"file2.rmvb"</span><span class="token punctuation">,</span><span class="token string">"file3.mp4"</span><span class="token punctuation">,</span><span class="token string">"file4.wmv"</span><span class="token punctuation">,</span><span class="token string">"file5.flv"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
   pthread_t threads<span class="token punctuation">[</span>NUM_OF_TASKS<span class="token punctuation">]</span><span class="token punctuation">;</span>
   <span class="token keyword">int</span> rc<span class="token punctuation">;</span>
   <span class="token keyword">int</span> t<span class="token punctuation">;</span>
   <span class="token keyword">int</span> downloadtime<span class="token punctuation">;</span>

   pthread_attr_t thread_attr<span class="token punctuation">;</span>
   <span class="token function">pthread_attr_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_attr<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token function">pthread_attr_setdetachstate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_attr<span class="token punctuation">,</span>PTHREAD_CREATE_JOINABL<span class="token punctuation">)</span><span class="token punctuation">;</span>

   <span class="token keyword">for</span><span class="token punctuation">(</span>t<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>t<span class="token operator">&lt;</span>NUM_OF_TASKS<span class="token punctuation">;</span>t<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"creating thread %d, please help me to download %s\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> files<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     rc <span class="token operator">=</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>threads<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>thread_attr<span class="token punctuation">,</span> downloadfile<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>files<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>rc<span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ERROR; return code from pthread_create() is %d\n"</span><span class="token punctuation">,</span> rc<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

   <span class="token function">pthread_attr_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_attr<span class="token punctuation">)</span><span class="token punctuation">;</span>

   <span class="token keyword">for</span><span class="token punctuation">(</span>t<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>t<span class="token operator">&lt;</span>NUM_OF_TASKS<span class="token punctuation">;</span>t<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token function">pthread_join</span><span class="token punctuation">(</span>threads<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>downloadtime<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Thread %d downloads the file %s in %d minutes.\n"</span><span class="token punctuation">,</span>t<span class="token punctuation">,</span>files<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">,</span>downloadtime<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

   <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一个运行中的线程可以调用pthread_exit退出线程。这个函数可以传入一个参数转换为(void *)类型。这是线程退出的返回值。</p>
<p>接下来，我们来看主线程。在这里面，我列了五个文件名。接下来声明了一个数组，里面有五个pthread_t类型的线程对象。</p>
<p>接下来，声明一个线程属性pthread_attr_t。我们通过pthread_attr_init初始化这个属性，并且设置属性PTHREAD_CREATE_JOINABLE。这表示将来主线程程等待这个线程的结束，并获取退出时的状态。</p>
<p>接下来是一个循环。对于每一个文件和每一个线程，可以调用pthread_create创建线程。一共有四个参数，第一个参数是线程对象，第二个参数是线程的属性，第三个参数是线程运行函数，第四个参数是线程运行函数的参数。主线程就是通过第四个参数，将自己的任务派给子线程。</p>
<p>任务分配完毕，每个线程下载一个文件，接下来主线程要做的事情就是等待这些子任务完成。当一个线程退出的时候，就会发送信号给其他所有同进程的线程。有一个线程使用pthread_join获取这个线程退出的返回值。线程的返回值通过pthread_join传给主线程，这样子线程就将自己下载文件所耗费的时间，告诉给主线程。</p>
<p>好了，程序写完了，开始编译。多线程程序要依赖于libpthread.so。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc download.c -lpthread<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>总结一下，一个普通线程的创建和运行过程。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/线程的创建和运行过程.jpg" alt="线程的创建和运行过程"></p>
<h3 id="6-3-线程的数据"><a href="#6-3-线程的数据" class="headerlink" title="6.3 线程的数据"></a>6.3 线程的数据</h3><p>我们把线程访问的数据细分成三类。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/线程访问的数据.jpg" alt="线程访问的数据"></p>
<ol>
<li><p>线程栈上的本地数据</p>
<p> 比如函数执行过程中的局部变量。前面我们说过，函数的调用会使用栈的模型，这在线程里面是一样的。只不过每个线程都有自己的栈空间。</p>
<p> 栈的大小可以通过命令ulimit -a查看，默认情况下线程栈大小为8192（8MB）。我们可以使用命令ulimit -s修改。</p>
<p> 对于线程栈，可以通过下面这个函数pthread_attr_t，修改线程栈的大小。</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pthread_attr_setstacksize</span><span class="token punctuation">(</span>pthread_attr_t <span class="token operator">*</span>attr<span class="token punctuation">,</span> size_t stacksize<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 主线程在内存中有一个栈空间，其他线程栈也拥有独立的栈空间。为了避免线程之间的栈空间踩踏，线程栈之间还会有小块区域，用来隔离保护各自的栈空间。一旦另一个线程踏入到这个隔离区，就会引发段错误。</p>
</li>
<li><p>在整个进程里共享的全局数据</p>
<p> 例如全局变量，虽然在不同进程中是隔离的，但是在一个进程中是共享的。</p>
</li>
<li><p>线程私有数据（Thread Specific Data）</p>
<p> 可以通过以下函数创建：</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pthread_key_create</span><span class="token punctuation">(</span>pthread_key_t <span class="token operator">*</span>key<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>destructor<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 可以看到，创建一个key，伴随着一个析构函数。</p>
<p> key一旦被创建，所有线程都可以访问它，但各线程可根据自己的需要往key中填入不同的值，这就相当于提供了一个同名而不同值的全局变量。</p>
<p> 我们可以通过下面的函数设置key对应的value。</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pthread_setspecific</span><span class="token punctuation">(</span>pthread_key_t key<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>value<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 我们还可以通过下面的函数获取key对应的value。</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">pthread_getspecific</span><span class="token punctuation">(</span>pthread_key_t key<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 而等到线程退出的时候，就会调用析构函数释放value。</p>
</li>
</ol>
<h3 id="6-4-数据的保护"><a href="#6-4-数据的保护" class="headerlink" title="6.4 数据的保护"></a>6.4 数据的保护</h3><p>Mutex，全称Mutual Exclusion，中文叫互斥。顾名思义，有你没我，有我没你。它的模式就是在共享数据访问的时候，去申请加把锁，谁先拿到锁，谁就拿到了访问权限，其他人就只好在门外等着，等这个人访问结束，把锁打开，其他人再去争夺，还是遵循谁先拿到谁访问。</p>
<p>使用Mutex，首先要使用pthread_mutex_init函数初始化这个mutex，初始化后，就可以用它来保护共享变量了。</p>
<p>pthread_mutex_lock() 就是去抢那把锁的函数，如果抢到了，就可以执行下一行程序，对共享变量进行访；如果没抢到，就被阻塞在那里等待。</p>
<p>如果不想被阻塞，可以使用pthread_mutex_trylock去抢那把锁，如果抢到了，就可以执行下一行程序，对共享变量进行访问；如果没抢到，不会被阻塞，而是返回一个错误码。</p>
<p>当共享数据访问结束了，别忘了使用pthread_mutex_unlock释放锁，让给其他人使用，最终调用pthread_mutex_destroy销毁掉这把锁。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/Mutex的使用流程.jpg" alt="Mutex的使用流程"></p>
<p>在使用Mutex的时候，有个问题是如果使用pthread_mutex_lock()，那就需要一直在那里等着。如果是pthread_mutex_trylock()，就可以不用等着，去干点儿别的，但是我怎么知道什么时候回来再试一下，是不是轮到我了呢？能不能在轮到我的时候，通知我一下呢？</p>
<p>这其实就是条件变量，也就是说如果没事儿，就让大家歇着，有事儿了就去通知，别让人家没事儿就来问问，浪费大家的时间。</p>
<p>但是当它接到了通知，来操作共享资源的时候，还是需要抢互斥锁，因为可能很多人都受到了通知，都来访问了，所以 <strong>条件变量和互斥锁是配合使用的</strong> 。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/条件变量和互斥锁配合使用流程.jpeg" alt="条件变量和互斥锁配合使用流程"></p>
<h3 id="6-5-总结"><a href="#6-5-总结" class="headerlink" title="6.5 总结"></a>6.5 总结</h3><p><img src="/images/《趣谈Linux操作系统》学习笔记/多线程总结.png" alt="多线程总结"></p>
<h2 id="七、进程数据结构（上）"><a href="#七、进程数据结构（上）" class="headerlink" title="七、进程数据结构（上）"></a>七、进程数据结构（上）</h2><p>在Linux里面，无论是进程，还是线程，到了内核里面，我们统一都叫任务（Task），由一个统一的结构task_struct进行管理。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/Linux中的任务.jpeg" alt="Linux中的任务"></p>
<p>Linux内核有一个链表，将所有的task_struct串起来。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">list_head</span>        tasks<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>接下来，我们来看每一个任务都应该包含哪些字段。</p>
<h3 id="7-1-任务ID"><a href="#7-1-任务ID" class="headerlink" title="7.1 任务ID"></a>7.1 任务ID</h3><p>每一个任务都应该有一个ID，作为这个任务的唯一标识。到时候排期啊、下发任务啊等等，都按ID来，就不会产生歧义。</p>
<p>task_struct里面涉及任务ID的，有下面几个：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">pid_t pid<span class="token punctuation">;</span>
pid_t tgid<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>group_leader<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>你可能觉得奇怪，既然是ID，有一个就足以做唯一标识了，这个怎么看起来这么麻烦？这是因为，上面的进程和线程到了内核这里，统一变成了任务，这就带来两个问题。</p>
<ol>
<li><p>任务展示</p>
<p> 前面我们学习命令行的时候，知道ps命令可以展示出所有的进程。但是如果你是这个命令的实现者，到了内核，按照上面的任务列表把这些命令都显示出来，把所有的线程全都平摊开来显示给用户。用户肯定觉得既复杂又困惑。复杂在于，列表这么长；困惑在于，里面出现了很多并不是自己创建的线程。</p>
</li>
<li><p>给任务下发指令</p>
<p> 可以通过kill来给进程发信号，通知进程退出。如果发给了其中一个线程，我们就不能只退出这个线程，而是应该退出整个进程。当然，有时候，我们希望只给某个线程发信号。</p>
<p> 所以在内核中，它们虽然都是任务，但是应该加以区分。其中，pid是process id，tgid是thread group ID。</p>
<p> 任何一个进程，如果只有主线程，那pid是自己，tgid是自己，group_leader指向的还是自己。</p>
<p> 但是，如果一个进程创建了其他线程，那就会有所变化了。线程有自己的pid，tgid就是进程的主线程的pid，group_leader指向的就是进程的主线程。</p>
<p> 好了，有了tgid，我们就知道tast_struct代表的是一个进程还是代表一个线程了。</p>
</li>
</ol>
<h3 id="7-2-信号处理"><a href="#7-2-信号处理" class="headerlink" title="7.2 信号处理"></a>7.2 信号处理</h3><p>task_struct里面关于信号处理的字段。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Signal handlers: */</span>
<span class="token keyword">struct</span> <span class="token class-name">signal_struct</span>    <span class="token operator">*</span>signal<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">sighand_struct</span>   <span class="token operator">*</span>sighand<span class="token punctuation">;</span>
sigset_t                blocked<span class="token punctuation">;</span>
sigset_t                real_blocked<span class="token punctuation">;</span>
sigset_t                saved_sigmask<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">sigpending</span>       pending<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span>           sas_ss_sp<span class="token punctuation">;</span>
size_t                  sas_ss_size<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span>            sas_ss_flags<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里定义了哪些信号被阻塞暂不处理（blocked），哪些信号尚等待处理（pending），哪些信号正在通过信号处理函数进行处理（sighand）。处理的结果可以是忽略，可以是结束进程等等。</p>
<p>信号处理函数默认使用用户态的函数栈，当然也可以开辟新的栈专门用于信号处理，这就是sas_ss_xxx这三个变量的作用。</p>
<p>上面我说了下发信号的时候，需要区分进程和线程。从这里我们其实也能看出一些端倪。</p>
<p>task_struct里面有一个struct sigpending pending。如果我们进入struct signal_struct *signal去看的话，还有一个struct sigpending shared_pending。它们一个是本任务的，一个是线程组共享的。</p>
<h3 id="7-3-任务状态"><a href="#7-3-任务状态" class="headerlink" title="7.3 任务状态"></a>7.3 任务状态</h3><p>在task_struct里面，涉及任务状态的是下面这几个变量：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">volatile</span> <span class="token keyword">long</span> state<span class="token punctuation">;</span>    <span class="token comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span>
<span class="token keyword">int</span> exit_state<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> flags<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>state（状态）可以取的值定义在include/linux/sched.h头文件中。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Used in tsk-&gt;state: */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">TASK_RUNNING                    <span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">TASK_INTERRUPTIBLE              <span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">TASK_UNINTERRUPTIBLE            <span class="token number">2</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">__TASK_STOPPED                  <span class="token number">4</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">__TASK_TRACED                   <span class="token number">8</span></span></span>
<span class="token comment">/* Used in tsk-&gt;exit_state: */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">EXIT_DEAD                       <span class="token number">16</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">EXIT_ZOMBIE                     <span class="token number">32</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">EXIT_TRACE</span>                      <span class="token punctuation">(</span>EXIT_ZOMBIE <span class="token operator">|</span> EXIT_DEAD<span class="token punctuation">)</span></span></span>
<span class="token comment">/* Used in tsk-&gt;state again: */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">TASK_DEAD                       <span class="token number">64</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">TASK_WAKEKILL                   <span class="token number">128</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">TASK_WAKING                     <span class="token number">256</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">TASK_PARKED                     <span class="token number">512</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">TASK_NOLOAD                     <span class="token number">1024</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">TASK_NEW                        <span class="token number">2048</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">TASK_STATE_MAX                  <span class="token number">4096</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从定义的数值很容易看出来，flags是通过bitset的方式设置的也就是说，当前是什么状态，哪一位就置一。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/任务状态.jpeg" alt="任务状态"></p>
<p>TASK_RUNNING并不是说进程正在运行，而是表示进程在时刻准备运行的状态。当处于这个状态的进程获得时间片的时候，就是在运行中；如果没有获得时间片，就说明它被其他进程抢占了，在等待再次分配时间片。</p>
<p>在运行中的进程，一旦要进行一些I/O操作，需要等待I/O完毕，这个时候会释放CPU，进入睡眠状态。</p>
<p>在Linux中，有两种睡眠状态。</p>
<ol>
<li><p>TASK_INTERRUPTIBLE，可中断的睡眠状态。</p>
<p> 这是一种浅睡眠的状态，也就是说，虽然在睡眠，等待I/O完成，但是这个时候一个信号来的时候，进程还是要被唤醒。只不过唤醒后，不是继续刚才的操作，而是进行信号处理。当然程序员可以根据自己的意愿，来写信号处理函数，例如收到某些信号，就放弃等待这个I/O操作完成，直接退出，也可也收到某些信息，继续等待。</p>
</li>
<li><p>TASK_UNINTERRUPTIBLE，不可中断的睡眠状态。</p>
<p> 这是一种深度睡眠状态，不可被信号唤醒，只能死等I/O操作完成。一旦I/O操作因为特殊原因不能完成，这个时候，谁也叫不醒这个进程了。你可能会说，我kill它呢？别忘了，kill本身也是一个信号，既然这个状态不可被信号唤醒，kill信号也被忽略了。除非重启电脑，没有其他办法。</p>
<p> 因此，这其实是一个比较危险的事情，除非程序员极其有把握，不然还是不要设置成TASK_UNINTERRUPTIBLE。</p>
</li>
</ol>
<p>于是，我们就有了一种新的进程睡眠状态，TASK_KILLABLE，可以终止的新睡眠状态。进程处于这种状态中，它的运行原理类似TASK_UNINTERRUPTIBLE，只不过可以响应致命信号。</p>
<p>从定义可以看出，TASK_WAKEKILL用于在接收到致命信号时唤醒进程，而TASK_KILLABLE相当于这两位都设置了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">TASK_KILLABLE</span>           <span class="token punctuation">(</span>TASK_WAKEKILL <span class="token operator">|</span> TASK_UNINTERRUPTIBLE<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>TASK_STOPPED是在进程接收到SIGSTOP、SIGTTIN、SIGTSTP或者SIGTTOU信号之后进入该状态。</p>
<p>TASK_TRACED表示进程被debugger等进程监视，进程执行被调试程序所停止。当一个进程被另外的进程所监视，每一个信号都会让进程进入该状态。</p>
<p>一旦一个进程要结束，先进入的是EXIT_ZOMBIE状态，但是这个时候它的父进程还没有使用wait()等系统调用来获知它的终止信息，此时进程就成了僵尸进程。</p>
<p>EXIT_DEAD是进程的最终状态。</p>
<p>EXIT_ZOMBIE和EXIT_DEAD也可以用于exit_state。</p>
<p>上面的进程状态和进程的运行、调度有关系，还有其他的一些状态，我们称为标志。放在flags字段中，这些字段都被定义称为宏，以PF开头。我这里举几个例子。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">PF_EXITING      <span class="token number">0x00000004</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">PF_VCPU         <span class="token number">0x00000010</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">PF_FORKNOEXEC   <span class="token number">0x00000040</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li><strong>PF_EXITING</strong> 表示正在退出。当有这个flag的时候，在函数find_alive_thread中，找活着的线程，遇到有这个flag的，就直接跳过。</li>
<li><strong>PF_VCPU</strong> 表示进程运行在虚拟CPU上。在函数account_system_time中，统计进程的系统运行时间，如果有这个flag，就调用account_guest_time，按照客户机的时间进行统计。</li>
<li><strong>PF_FORKNOEXEC</strong> 表示fork完了，还没有exec。在_do_fork函数里面调用copy_process，这个时候把flag设置为PF_FORKNOEXEC。当exec中调用了load_elf_binary的时候，又把这个flag去掉。</li>
</ul>
<h3 id="7-4-进程调度"><a href="#7-4-进程调度" class="headerlink" title="7.4 进程调度"></a>7.4 进程调度</h3><p>进程的状态切换往往涉及调度，下面这些字段都是用于调度的。为了让你理解task_struct进程管理的全貌，我先在这里列一下，咱们后面会有单独的章节讲解，这里你只要大概看一下里面的注释就好了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//是否在运行队列上</span>
<span class="token keyword">int</span>                         on_rq<span class="token punctuation">;</span>
<span class="token comment">//优先级</span>
<span class="token keyword">int</span>                         prio<span class="token punctuation">;</span>
<span class="token keyword">int</span>                         static_prio<span class="token punctuation">;</span>
<span class="token keyword">int</span>                         normal_prio<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span>                rt_priority<span class="token punctuation">;</span>
<span class="token comment">//调度器类</span>
<span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span>    <span class="token operator">*</span>sched_class<span class="token punctuation">;</span>
<span class="token comment">//调度实体</span>
<span class="token keyword">struct</span> <span class="token class-name">sched_entity</span>         se<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">sched_rt_entity</span>      rt<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">sched_dl_entity</span>      dl<span class="token punctuation">;</span>
<span class="token comment">//调度策略</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span>                policy<span class="token punctuation">;</span>
<span class="token comment">//可以使用哪些CPU</span>
<span class="token keyword">int</span>                         nr_cpus_allowed<span class="token punctuation">;</span>
cpumask_t                   cpus_allowed<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">sched_info</span>           sched_info<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="7-5-总结"><a href="#7-5-总结" class="headerlink" title="7.5 总结"></a>7.5 总结</h3><p>画一个图总结一下。这个图是进程管理task_struct的的结构图。其中红色的部分是今天讲的部分，你可以对着这张图说出它们的含义。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/进程管理task_struct的结构图（上）.jpeg" alt="进程管理task_struct的结构图（上）"></p>
<h2 id="八、进程数据结构（中）"><a href="#八、进程数据结构（中）" class="headerlink" title="八、进程数据结构（中）"></a>八、进程数据结构（中）</h2><h3 id="8-1-运行统计信息"><a href="#8-1-运行统计信息" class="headerlink" title="8.1 运行统计信息"></a>8.1 运行统计信息</h3><p>在进程的运行过程中，会有一些统计量，具体你可以看下面的列表。这里面有进程在用户态和内核态消耗的时间、上下文切换的次数等等。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">u64             utime<span class="token punctuation">;</span><span class="token comment">//用户态消耗的CPU时间</span>
u64             stime<span class="token punctuation">;</span><span class="token comment">//内核态消耗的CPU时间</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span>   nvcsw<span class="token punctuation">;</span><span class="token comment">//自愿(voluntary)上下文切换计数</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span>   nivcsw<span class="token punctuation">;</span><span class="token comment">//非自愿(involuntary)上下文切换计数</span>
u64             start_time<span class="token punctuation">;</span><span class="token comment">//进程启动时间，不包含睡眠时间</span>
u64             real_start_time<span class="token punctuation">;</span><span class="token comment">//进程启动时间，包含睡眠时间</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="8-2-进程亲缘关系"><a href="#8-2-进程亲缘关系" class="headerlink" title="8.2 进程亲缘关系"></a>8.2 进程亲缘关系</h3><p>从我们之前讲的创建进程的过程，可以看出，任何一个进程都有父进程。所以，整个进程其实就是一棵进程树。而拥有同一父进程的所有进程都具有兄弟关系。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> __rcu <span class="token operator">*</span>real_parent<span class="token punctuation">;</span> <span class="token comment">/* real parent process */</span>
<span class="token keyword">struct</span> <span class="token class-name">task_struct</span> __rcu <span class="token operator">*</span>parent<span class="token punctuation">;</span> <span class="token comment">/* recipient of SIGCHLD, wait4() reports */</span>
<span class="token keyword">struct</span> <span class="token class-name">list_head</span> children<span class="token punctuation">;</span>      <span class="token comment">/* list of my children */</span>
<span class="token keyword">struct</span> <span class="token class-name">list_head</span> sibling<span class="token punctuation">;</span>       <span class="token comment">/* linkage in my parent's children list */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>parent指向其父进程。当它终止时，必须向它的父进程发送信号。</li>
<li>children表示链表的头部。链表中的所有元素都是它的子进程。</li>
<li>sibling用于把当前进程插入到兄弟链表中。</li>
</ul>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/进程亲缘关系.jpeg" alt="进程亲缘关系"></p>
<p>通常情况下，real_parent和parent是一样的，但是也会有另外的情况存在。例如，bash创建一个进程，那进程的parent和real_parent就都是bash。如果在bash上使用GDB来debug一个进程，这个时候GDB是real_parent，bash是这个进程的parent。</p>
<h3 id="8-3-进程权限"><a href="#8-3-进程权限" class="headerlink" title="8.3 进程权限"></a>8.3 进程权限</h3><p>在Linux里面，对于进程权限的定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Objective and real subjective task credentials (COW): */</span>
<span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">cred</span> __rcu         <span class="token operator">*</span>real_cred<span class="token punctuation">;</span>
<span class="token comment">/* Effective (overridable) subjective task credentials (COW): */</span>
<span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">cred</span> __rcu         <span class="token operator">*</span>cred<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个结构的注释里，有两个名词比较拗口，Objective和Subjective。事实上，所谓的权限，就是我能操纵谁，谁能操纵我。</p>
<p>“谁能操作我”，很显然，这个时候我就是被操作的对象，就是Objective，那个想操作我的就是Subjective。“我能操作谁”，这个时候我就是Subjective，那个要被我操作的就是Objectvie。</p>
<p>“操作”，就是一个对象对另一个对象进行某些动作。当动作要实施的时候，就要审核权限，当两边的权限匹配上了，就可以实施操作。其中，real_cred就是说明谁能操作我这个进程，而cred就是说明我这个进程能够操作谁。</p>
<p>这里cred的定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">cred</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        kuid_t          uid<span class="token punctuation">;</span>            <span class="token comment">/* real UID of the task */</span>
        kgid_t          gid<span class="token punctuation">;</span>            <span class="token comment">/* real GID of the task */</span>
        kuid_t          suid<span class="token punctuation">;</span>           <span class="token comment">/* saved UID of the task */</span>
        kgid_t          sgid<span class="token punctuation">;</span>           <span class="token comment">/* saved GID of the task */</span>
        kuid_t          euid<span class="token punctuation">;</span>           <span class="token comment">/* effective UID of the task */</span>
        kgid_t          egid<span class="token punctuation">;</span>           <span class="token comment">/* effective GID of the task */</span>
        kuid_t          fsuid<span class="token punctuation">;</span>          <span class="token comment">/* UID for VFS ops */</span>
        kgid_t          fsgid<span class="token punctuation">;</span>          <span class="token comment">/* GID for VFS ops */</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        kernel_cap_t    cap_inheritable<span class="token punctuation">;</span> <span class="token comment">/* caps our children can inherit */</span>
        kernel_cap_t    cap_permitted<span class="token punctuation">;</span>  <span class="token comment">/* caps we're permitted */</span>
        kernel_cap_t    cap_effective<span class="token punctuation">;</span>  <span class="token comment">/* caps we can actually use */</span>
        kernel_cap_t    cap_bset<span class="token punctuation">;</span>       <span class="token comment">/* capability bounding set */</span>
        kernel_cap_t    cap_ambient<span class="token punctuation">;</span>    <span class="token comment">/* Ambient capability set */</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span> __randomize_layout<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从这里的定义可以看出，大部分是关于 <strong>用户和用户所属的用户组信息</strong> 。</p>
<ol>
<li><p>第一个是uid和gid，注释是real user/group id。一般情况下，谁启动的进程，就是谁的ID。但是权限审核的时候，往往不比较这两个，也就是说不大起作用。</p>
</li>
<li><p>第二个是euid和egid，注释是effective user/group id。一看这个名字，就知道这个是起“作用”的。当这个进程要操作消息队列、共享内存、信号量等对象的时候，其实就是在比较这个用户和组是否有权限。</p>
</li>
<li><p>第三个是fsuid和fsgid，也就是filesystem user/group id。这个是对文件操作会审核的权限。</p>
</li>
</ol>
<p>一般说来，fsuid、euid，和uid是一样的，fsgid、egid，和gid也是一样的。因为谁启动的进程，就应该审核启动的用户到底有没有这个权限。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/进程权限举例.jpeg" alt="进程权限举例"></p>
<p>例如，用户A想玩一个游戏，这个游戏的程序是用户B安装的。游戏这个程序文件的权限为rwxr–r—。A是没有权限运行这个程序的，因而用户B要给用户A权限才行。用户B说没问题，都是朋友嘛，于是用户B就给这个程序设定了所有的用户都能执行的权限rwxr-xr-x，说兄弟你玩吧。</p>
<p>例如，用户A想玩一个游戏，这个游戏的程序是用户B安装的。游戏这个程序文件的权限为rwxr–r—。A是没有权限运行这个程序的，因而用户B要给用户A权限才行。用户B说没问题，都是朋友嘛，于是用户B就给这个程序设定了所有的用户都能执行的权限rwxr-xr-x，说兄弟你玩吧。</p>
<p>于是，用户A就获得了运行这个游戏的权限。当游戏运行起来之后，游戏进程的uid、euid、fsuid都是用户A。看起来没有问题，玩的很开心。</p>
<p>用户A好不容易通过一关，想保存通关数据的时候，发现坏了，这个游戏的玩家数据是保存在另一个文件里面的。这个文件权限rw———-，只给用户B开了写入权限，而游戏进程的euid和fsuid都是用户A，当然写不进去了。完了，这一局白玩儿了。</p>
<p>那怎么解决这个问题呢？我们可以通过chmod u+s program命令，给这个游戏程序设置set-user-ID的标识位，把游戏的权限变成rwsr-xr-x。这个时候，用户A再启动这个游戏的时候，创建的进程uid当然还是用户A，但是euid和fsuid就不是用户A了，因为看到了set-user-id标识，就改为文件的所有者的ID，也就是说，euid和fsuid都改成用户B了，这样就能够将通关结果保存下来。</p>
<p>在Linux里面，一个进程可以随时通过setuid设置用户ID，所以，游戏程序的用户B的ID还会保存在一个地方，这就是suid和sgid，也就是saved uid和save gid。这样就可以很方便地使用setuid，通过设置uid或者suid来改变权限。</p>
<p>除了以用户和用户组控制权限，Linux还有另一个机制就是 <strong>capabilities</strong> 。</p>
<p>原来控制进程的权限，要么是高权限的root用户，要么是一般权限的普通用户，这时候的问题是，root用户权限太大，而普通用户权限太小。有时候一个普通用户想做一点高权限的事情，必须给他整个root的权限。这个太不安全了。</p>
<p>于是，我们引入新的机制capabilities，用位图表示权限，在capability.h可以找到定义的权限。我这里列举几个。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">CAP_CHOWN            <span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">CAP_KILL             <span class="token number">5</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">CAP_NET_BIND_SERVICE <span class="token number">10</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">CAP_NET_RAW          <span class="token number">13</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">CAP_SYS_MODULE       <span class="token number">16</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">CAP_SYS_RAWIO        <span class="token number">17</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">CAP_SYS_BOOT         <span class="token number">22</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">CAP_SYS_TIME         <span class="token number">25</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">CAP_AUDIT_READ       <span class="token number">37</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">CAP_LAST_CAP         CAP_AUDIT_READ</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于普通用户运行的进程，当有这个权限的时候，就能做这些操作；没有的时候，就不能做，这样粒度要小很多。</p>
<p>cap_permitted表示进程能够使用的权限。但是真正起作用的是cap_effective。cap_permitted中可以包含cap_effective中没有的权限。一个进程可以在必要的时候，放弃自己的某些权限，这样更加安全。假设自己因为代码漏洞被攻破了，但是如果啥也干不了，就没办法进一步突破。</p>
<p>cap_inheritable表示当可执行文件的扩展属性设置了inheritable位时，调用exec执行该程序会继承调用者的inheritable集合，并将其加入到permitted集合。但在非root用户下执行exec时，通常不会保留inheritable集合，但是往往又是非root用户，才想保留权限，所以非常鸡肋。</p>
<p>cap_bset，也就是capability bounding set，是系统中所有进程允许保留的权限。如果这个集合中不存在某个权限，那么系统中的所有进程都没有这个权限。即使以超级用户权限执行的进程，也是一样的。</p>
<p>这样有很多好处。例如，系统启动以后，将加载内核模块的权限去掉，那所有进程都不能加载内核模块。这样，即便这台机器被攻破，也做不了太多有害的事情。</p>
<p>cap_ambient是比较新加入内核的，就是为了解决cap_inheritable鸡肋的状况，也就是，非root用户进程使用exec执行一个程序的时候，如何保留权限的问题。当执行exec的时候，cap_ambient会被添加到cap_permitted中，同时设置到cap_effective中。</p>
<h3 id="8-4-内存管理"><a href="#8-4-内存管理" class="headerlink" title="8.4 内存管理"></a>8.4 内存管理</h3><p>每个进程都有自己独立的虚拟内存空间，这需要有一个数据结构来表示，就是mm_struct。这个我们在内存管理那一节详细讲述。这里你先有个印象。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">mm_struct</span>                <span class="token operator">*</span>mm<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">mm_struct</span>                <span class="token operator">*</span>active_mm<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="8-5-文件与文件系统"><a href="#8-5-文件与文件系统" class="headerlink" title="8.5 文件与文件系统"></a>8.5 文件与文件系统</h3><p>每个进程有一个文件系统的数据结构，还有一个打开文件的数据结构。这个我们放到文件系统那一节详细讲述。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Filesystem information: */</span>
<span class="token keyword">struct</span> <span class="token class-name">fs_struct</span>                <span class="token operator">*</span>fs<span class="token punctuation">;</span>
<span class="token comment">/* Open file information: */</span>
<span class="token keyword">struct</span> <span class="token class-name">files_struct</span>             <span class="token operator">*</span>files<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="8-6-总结"><a href="#8-6-总结" class="headerlink" title="8.6 总结"></a>8.6 总结</h3><p>这一节，我们终于把进程管理复杂的数据结构基本讲完了，请你重点记住以下两点：</p>
<ul>
<li>进程亲缘关系维护的数据结构，是一种很有参考价值的实现方式，在内核中会多个地方出现类似的结构；</li>
<li>进程权限中setuid的原理，这一点比较难理解，但是很重要，面试经常会考。</li>
</ul>
<p>你可以对着下面这张图，看看自己是否真的理解了，进程树是如何组织的，以及如何控制进程的权限的。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/进程管理task_struct的结构图（中）.jpeg" alt="进程管理task_struct的结构图（中）"></p>
<h2 id="九、进程数据结构（下）"><a href="#九、进程数据结构（下）" class="headerlink" title="九、进程数据结构（下）"></a>九、进程数据结构（下）</h2><p>在程序执行过程中，一旦调用到系统调用，就需要进入内核继续执行。那如何将用户态的执行和内核态的执行串起来呢？</p>
<p>这就需要以下两个重要的成员变量：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">thread_info</span>  thread_info<span class="token punctuation">;</span>
<span class="token keyword">void</span>                <span class="token operator">*</span>stack<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="9-1-用户态函数栈"><a href="#9-1-用户态函数栈" class="headerlink" title="9.1 用户态函数栈"></a>9.1 用户态函数栈</h3><p>在用户态中，程序的执行往往是一个函数调用另一个函数。函数调用都是通过栈来进行的。</p>
<p>在进程的内存空间里面，栈是一个从高地址到低地址，往下增长的结构，也就是上面是栈底，下面是栈顶，入栈和出栈的操作都是从下面的栈顶开始的。</p>
<blockquote>
<p>以下栈操作，都是在进程的内存空间里面进行的。</p>
</blockquote>
<h4 id="9-1-1-32位操作系统"><a href="#9-1-1-32位操作系统" class="headerlink" title="9.1.1 32位操作系统"></a>9.1.1 32位操作系统</h4><p><img src="/images/《趣谈Linux操作系统》学习笔记/32位操作系统用户态函数栈.jpg" alt="32位操作系统用户态函数栈"></p>
<p>在CPU里，ESP（Extended Stack Pointer）是栈顶指针寄存器，入栈操作Push和出栈操作Pop指令，会自动调整ESP的值。另外有一个寄存器EBP（Extended Base Pointer），是栈基地址指针寄存器，指向当前栈帧的最底部。</p>
<p>例如，A调用B，A的栈里面包含A函数的局部变量，然后是调用B的时候要传给它的参数，然后返回A的地址，这个地址也应该入栈，这就形成了A的栈帧。接下来就是B的栈帧部分了，先保存的是A栈帧的栈底位置，也就是EBP。因为在B函数里面获取A传进来的参数，就是通过这个指针获取的，接下来保存的是B的局部变量等等。</p>
<p>当B返回的时候，返回值会保存在EAX寄存器中，从栈中弹出返回地址，将指令跳转回去，参数也从栈中弹出，然后继续执行A。</p>
<h4 id="9-1-2-64位操作系统"><a href="#9-1-2-64位操作系统" class="headerlink" title="9.1.2 64位操作系统"></a>9.1.2 64位操作系统</h4><p>对于64位操作系统，模式多少有些不一样。因为64位操作系统的寄存器数目比较多。rax用于保存函数调用的返回结果。栈顶指针寄存器变成了rsp，指向栈顶位置。堆栈的Pop和Push操作会自动调整rsp，栈基指针寄存器变成了rbp，指向当前栈帧的起始位置。</p>
<p>改变比较多的是参数传递。rdi、rsi、rdx、rcx、r8、r9这6个寄存器，用于传递存储函数调用时的6个参数。如果超过6的时候，还是需要放到栈里面。</p>
<p>然而，前6个参数有时候需要进行寻址，但是如果在寄存器里面，是没有地址的，因而还是会放到栈里面，只不过放到栈里面的操作是被调用函数做的。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/64位操作系统用户态函数栈.jpg" alt="64位操作系统用户态函数栈"></p>
<h3 id="9-2-内核态函数栈"><a href="#9-2-内核态函数栈" class="headerlink" title="9.2 内核态函数栈"></a>9.2 内核态函数栈</h3><p>接下来，我们通过系统调用，从进程的内存空间到内核中了。内核中也有各种各样的函数调用来调用去的，也需要这样一个机制，这该怎么办呢？</p>
<p>这时候，上面的成员变量stack，也就是内核栈，就派上了用场。</p>
<p>Linux给每个task都分配了内核栈。在32位系统上arch/x86/include/asm/page_32_types.h，是这样定义的：一个PAGE_SIZE是4K，左移一位就是乘以2，也就是8K。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">THREAD_SIZE_ORDER   <span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">THREAD_SIZE</span>         <span class="token punctuation">(</span>PAGE_SIZE <span class="token operator">&lt;&lt;</span> THREAD_SIZE_ORDER<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>内核栈在64位系统上arch/x86/include/asm/page_64_types.h，是这样定义的：在PAGE_SIZE的基础上左移两位，也即16K，并且要求起始地址必须是8192的整数倍。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_KASAN</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">KASAN_STACK_ORDER <span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">KASAN_STACK_ORDER <span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">THREAD_SIZE_ORDER</span>   <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">+</span> KASAN_STACK_ORDER<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">THREAD_SIZE</span>         <span class="token punctuation">(</span>PAGE_SIZE <span class="token operator">&lt;&lt;</span> THREAD_SIZE_ORDER<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>内核栈是一个非常特殊的结构，如下图所示：</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/内核栈结构.jpeg" alt="内核栈结构"></p>
<p>这段空间的最低位置，是一个thread_info结构。这个结构是对task_struct结构的补充。因为task_struct结构庞大但是通用，不同的体系结构就需要保存不同的东西，所以往往与体系结构有关的，都放在thread_info里面。</p>
<p>在内核代码里面有这样一个union，将thread_info和stack放在一起，在include/linux/sched.h文件中就有。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">union</span> thread_union <span class="token punctuation">{</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">CONFIG_THREAD_INFO_IN_TASK</span></span>
    <span class="token keyword">struct</span> <span class="token class-name">thread_info</span> thread_info<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> stack<span class="token punctuation">[</span>THREAD_SIZE<span class="token operator">/</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个union就是这样定义的，开头是thread_info，后面是stack。</p>
<p>在内核栈的最高地址端，存放的是另一个结构pt_regs，定义如下。其中，32位和64位的定义不一样。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__i386__</span></span>
<span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> bx<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> cx<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> dx<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> si<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> di<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> bp<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ax<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ds<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> es<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> fs<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> gs<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> orig_ax<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ip<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> cs<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sp<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ss<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
<span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> r15<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> r14<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> r13<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> r12<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> bp<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> bx<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> r11<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> r10<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> r9<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> r8<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ax<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> cx<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> dx<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> si<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> di<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> orig_ax<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ip<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> cs<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sp<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ss<span class="token punctuation">;</span>
<span class="token comment">/* top of stack page */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当系统调用从用户态到内核态的时候，首先要做的第一件事情，就是将用户态运行过程中的CPU上下文保存起来，其实主要就是保存在这个结构的寄存器变量里。这样当从内核系统调用返回的时候，才能让进程在刚才的地方接着运行下去。</p>
<p>如果我们对比系统调用那一节的内容，你会发现系统调用的时候，压栈的值的顺序和struct pt_regs中寄存器定义的顺序是一样的。</p>
<p>在内核中，CPU的寄存器ESP或者RSP，已经指向内核栈的栈顶，在内核态里的调用都有和用户态相似的过程。</p>
<h3 id="9-3-通过task-struct找内核栈"><a href="#9-3-通过task-struct找内核栈" class="headerlink" title="9.3 通过task_struct找内核栈"></a>9.3 通过task_struct找内核栈</h3><p>如果有一个task_struct的stack指针在手，你可以通过下面的函数找到这个线程内核栈：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">task_stack_page</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>task<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> task<span class="token operator">-&gt;</span>stack<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>从task_struct如何得到相应的pt_regs呢？我们可以通过下面的函数：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * TOP_OF_KERNEL_STACK_PADDING reserves 8 bytes on top of the ring0 stack.
 * This is necessary to guarantee that the entire "struct pt_regs"
 * is accessible even if the CPU haven't stored the SS/ESP registers
 * on the stack (interrupt gate does not save these registers
 * when switching to the same priv ring).
 * Therefore beware: accessing the ss/esp fields of the
 * "struct pt_regs" is possible, but they may contain the
 * completely wrong values.
 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">task_pt_regs</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span>                                      </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">{</span>                                                              </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">unsigned</span> <span class="token keyword">long</span> __ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token function">task_stack_page</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span> </span><span class="token punctuation">\</span>
    <span class="token expression">__ptr <span class="token operator">+=</span> THREAD_SIZE <span class="token operator">-</span> TOP_OF_KERNEL_STACK_PADDING<span class="token punctuation">;</span>         </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span><span class="token punctuation">)</span>__ptr<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                              </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">}</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>你会发现，这是先从task_struct找到内核栈的开始位置。然后这个位置加上THREAD_SIZE就到了最后的位置，然后转换为struct pt_regs，再减一，就相当于减少了一个pt_regs的位置，就到了这个结构的首地址。</p>
<p>这里面有一个TOP_OF_KERNEL_STACK_PADDING，这个的定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_X86_32</span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_VM86</span></span>
<span class="token macro property"><span class="token directive-hash">#</span>  <span class="token directive keyword">define</span> <span class="token expression">TOP_OF_KERNEL_STACK_PADDING <span class="token number">16</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">else</span></span>
<span class="token macro property"><span class="token directive-hash">#</span>  <span class="token directive keyword">define</span> <span class="token expression">TOP_OF_KERNEL_STACK_PADDING <span class="token number">8</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span> <span class="token expression">TOP_OF_KERNEL_STACK_PADDING <span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也就是说，32位机器上是8，其他是0。这是为什么呢？因为压栈pt_regs有两种情况。我们知道，CPU用ring来区分权限，从而Linux可以区分内核态和用户态。</p>
<p>因此，第一种情况，我们拿涉及从用户态到内核态的变化的系统调用来说。因为涉及权限的改变，会压栈保存SS、ESP寄存器的，这两个寄存器共占用8个byte。</p>
<p>另一种情况是，不涉及权限的变化，就不会压栈这8个byte。这样就会使得两种情况不兼容。如果没有压栈还访问，就会报错，所以还不如预留在这里，保证安全。在64位上，修改了这个问题，变成了定长的。</p>
<p>好了，现在如果你task_struct在手，就能够轻松得到内核栈和内核寄存器。</p>
<h3 id="9-4-通过内核栈找task-struct"><a href="#9-4-通过内核栈找task-struct" class="headerlink" title="9.4 通过内核栈找task_struct"></a>9.4 通过内核栈找task_struct</h3><p>那如果一个当前在某个CPU上执行的进程，想知道自己的task_struct在哪里，又该怎么办呢？</p>
<p>这个艰巨的任务要交给thread_info这个结构。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">thread_info</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span>  <span class="token operator">*</span>task<span class="token punctuation">;</span>      <span class="token comment">/* main task structure */</span>
    __u32               flags<span class="token punctuation">;</span>      <span class="token comment">/* low level flags */</span>
    __u32               status<span class="token punctuation">;</span>     <span class="token comment">/* thread synchronous flags */</span>
    __u32               cpu<span class="token punctuation">;</span>        <span class="token comment">/* current CPU */</span>
    mm_segment_t        addr_limit<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        sig_on_uaccess_error<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        uaccess_err<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">/* uaccess failed */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面有个成员变量task指向task_struct，所以我们常用current_thread_info()-&gt;task来获取task_struct。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">thread_info</span> <span class="token operator">*</span><span class="token function">current_thread_info</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">thread_info</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">current_top_of_stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> THREAD_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>而thread_info的位置就是内核栈的最高位置，减去THREAD_SIZE，就到了thread_info的起始地址。</p>
<p>但是现在变成这样了，只剩下一个flags。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">thread_info</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>       flags<span class="token punctuation">;</span>      <span class="token comment">/* low level flags */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>那这时候怎么获取当前运行中的task_struct呢？current_thread_info有了新的实现方式。</p>
<p>在include/linux/thread_info.h中定义了current_thread_info。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;asm/current.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">current_thread_info</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">thread_info</span> <span class="token operator">*</span><span class="token punctuation">)</span>current<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>那current又是什么呢？在arch/x86/include/asm/current.h中定义了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token punctuation">;</span>

<span class="token function">DECLARE_PER_CPU</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token punctuation">,</span> current_task<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> __always_inline <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token function">get_current</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">this_cpu_read_stable</span><span class="token punctuation">(</span>current_task<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">current get_current</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>到这里，你会发现，新的机制里面，每个CPU运行的task_struct不通过thread_info获取了，而是直接放在Per CPU 变量里面了。</p>
<p>多核情况下，CPU是同时运行的，但是它们共同使用其他的硬件资源的时候，我们需要解决多个CPU之间的同步问题。</p>
<p>Per CPU变量是内核中一种重要的同步机制。顾名思义，Per CPU变量就是为每个CPU构造一个变量的副本，这样多个CPU各自操作自己的副本，互不干涉。比如，当前进程的变量current_task就被声明为Per CPU变量。</p>
<p>要使用Per CPU变量，首先要声明这个变量，在arch/x86/include/asm/current.h中有：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">DECLARE_PER_CPU</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token punctuation">,</span> current_task<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后是定义这个变量，在arch/x86/kernel/cpu/common.c中有：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">DEFINE_PER_CPU</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token punctuation">,</span> current_task<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>init_task<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>也就是说，系统刚刚初始化的时候，current_task都指向init_task。</p>
<p>当某个CPU上的进程进行切换的时候，current_task被修改为将要切换到的目标进程。例如，进程切换函数__switch_to就会改变current_task。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">__visible __notrace_funcgraph <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>
<span class="token function">__switch_to</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev_p<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>next_p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">this_cpu_write</span><span class="token punctuation">(</span>current_task<span class="token punctuation">,</span> next_p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> prev_p<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当要获取当前的运行中的task_struct的时候，就需要调用this_cpu_read_stable进行读取。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">this_cpu_read_stable</span><span class="token punctuation">(</span>var<span class="token punctuation">)</span>       <span class="token function">percpu_stable_op</span><span class="token punctuation">(</span></span><span class="token string">"mov"</span><span class="token expression"><span class="token punctuation">,</span> var<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>好了，现在如果你是一个进程，正在某个CPU上运行，就能够轻松得到task_struct了。</p>
<h3 id="9-5-总结"><a href="#9-5-总结" class="headerlink" title="9.5 总结"></a>9.5 总结</h3><p>这一节虽然只介绍了内核栈，但是内容更加重要。如果说task_struct的其他成员变量都是和进程管理有关的，内核栈是和进程运行有关系的。</p>
<p>我这里画了一张图总结一下32位和64位的工作模式，左边是32位的，右边是64位的。</p>
<ul>
<li>在用户态，应用程序进行了至少一次函数调用。32位和64的传递参数的方式稍有不同，32位的就是用函数栈，64位的前6个参数用寄存器，其他的用函数栈。</li>
<li>在内核态，32位和64位都使用内核栈，格式也稍有不同，主要集中在pt_regs结构上。</li>
<li>在内核态，32位和64位的内核栈和task_struct的关联关系不同。32位主要靠thread_info，64位主要靠Per-CPU变量。</li>
</ul>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/32位和64位函数栈.jpeg" alt="32位和64位函数栈"></p>
<h2 id="十、调度（上）"><a href="#十、调度（上）" class="headerlink" title="十、调度（上）"></a>十、调度（上）</h2><p>对于操作系统来讲，它面对的CPU的数量是有限的，干活儿都是它们，但是进程数目远远超过CPU的数目，因而就需要进行进程的调度，有效地分配CPU的时间，既要保证进程的最快响应，也要保证进程之间的公平。这也是一个非常复杂的、需要平衡的事情。</p>
<h3 id="10-1-调度策略与调度类"><a href="#10-1-调度策略与调度类" class="headerlink" title="10.1 调度策略与调度类"></a>10.1 调度策略与调度类</h3><p>在Linux里面，进程大概可以分成两种。</p>
<p>一种称为 <strong>实时进程</strong> ，也就是需要尽快执行返回结果的那种。<br>另一种是 <strong>普通进程</strong> ，大部分的进程其实都是这种。</p>
<p>对于这两种进程，我们的调度策略肯定是不同的。</p>
<p>在task_struct中，有一个成员变量，我们叫调度策略。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> policy<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>它有以下几个定义：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">SCHED_NORMAL        <span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">SCHED_FIFO          <span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">SCHED_RR            <span class="token number">2</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">SCHED_BATCH         <span class="token number">3</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">SCHED_IDLE          <span class="token number">5</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">SCHED_DEADLINE      <span class="token number">6</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>配合调度策略的，还有我们刚才说的优先级，也在task_struct中。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> prio<span class="token punctuation">,</span> static_prio<span class="token punctuation">,</span> normal_prio<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> rt_priority<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>优先级其实就是一个数值，对于实时进程，优先级的范围是0～99；对于普通进程，优先级的范围是100～139。数值越小，优先级越高。从这里可以看出，所有的实时进程都比普通进程优先级要高。</p>
<h3 id="10-2-实时调度策略"><a href="#10-2-实时调度策略" class="headerlink" title="10.2 实时调度策略"></a>10.2 实时调度策略</h3><p>对于调度策略，其中SCHED_FIFO、SCHED_RR、SCHED_DEADLINE是实时进程的调度策略。</p>
<ul>
<li><strong>SCHED_FIFO</strong> 就是先来先服务，可以分配更高的优先级，也就是说，高优先级的进程可以抢占低优先级的进程，而相同优先级的进程，我们遵循先来先得。</li>
<li><strong>SCHED_RR</strong> 轮流调度算法。采用时间片，相同优先级的任务当用完时间片会被放到队列尾部，以保证公平性，而高优先级的任务也是可以抢占低优先级的任务。</li>
<li><strong>SCHED_DEADLINE</strong> 按照任务的deadline进行调度的。当产生一个调度点的时候，DL调度器总是选择其deadline距离当前时间点最近的那个任务，并调度它执行。</li>
</ul>
<h3 id="10-3-普通调度策略"><a href="#10-3-普通调度策略" class="headerlink" title="10.3 普通调度策略"></a>10.3 普通调度策略</h3><p>对于普通进程的调度策略有，SCHED_NORMAL、SCHED_BATCH、SCHED_IDLE。</p>
<ul>
<li><strong>SCHED_NORMAL</strong> 是普通的进程。</li>
<li><strong>SCHED_BATCH</strong> 是后台进程，几乎不需要和前端进行交互。不要影响需要交互的进程，可以降低他的优先级。</li>
<li><strong>SCHED_IDLE</strong> 是特别空闲的时候才跑的进程。</li>
</ul>
<p>上面无论是policy还是priority，都设置了一个变量，变量仅仅表示了应该这样这样干，但事情总要有人去干，谁呢？在task_struct里面，还有这样的成员变量：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> <span class="token operator">*</span>sched_class<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>调度策略的执行逻辑，就封装在这里面，它是真正干活的那个。</p>
<p>sched_class有几种实现：</p>
<ul>
<li>stop_sched_class 优先级最高的任务会使用这种策略，会中断所有其他线程，且不会被其他任务打断；</li>
<li>dl_sched_class就对应上面的deadline调度策略；</li>
<li>rt_sched_class就对应RR算法或者FIFO算法的调度策略，具体调度策略由进程的task_struct-&gt;policy指定；</li>
<li>fair_sched_class就是普通进程的调度策略；</li>
<li>idle_sched_class就是空闲进程的调度策略。</li>
</ul>
<p>这里实时进程的调度策略RR和FIFO相对简单一些，而且由于咱们平时常遇到的都是普通进程，在这里，咱们就重点分析普通进程的调度问题。普通进程使用的调度策略是fair_sched_class，顾名思义，对于普通进程来讲，公平是最重要的。</p>
<h3 id="10-4-完全公平调度算法"><a href="#10-4-完全公平调度算法" class="headerlink" title="10.4 完全公平调度算法"></a>10.4 完全公平调度算法</h3><p>在Linux里面，实现了一个基于CFS的调度算法。CFS全称Completely Fair Scheduling，叫完全公平调度。听起来很“公平”。那这个算法的原理是什么呢？我们来看看。</p>
<p>首先，你需要记录下进程的运行时间。CPU会提供一个时钟，过一段时间就触发一个时钟中断。就像咱们的表滴答一下，这个我们叫Tick。CFS会为每一个进程安排一个虚拟运行时间vruntime。如果一个进程在运行，随着时间的增长，也就是一个个tick的到来，进程的vruntime将不断增大。没有得到执行的进程vruntime不变。</p>
<p>显然，那些vruntime少的，原来受到了不公平的对待，需要给它补上，所以会优先运行这样的进程。</p>
<p>这有点像让你把一筐球平均分到N个口袋里面，你看着哪个少，就多放一些；哪个多了，就先不放。这样经过多轮，虽然不能保证球完全一样多，但是也差不多公平。</p>
<p>你可能会说，不还有优先级呢？如何给优先级高的进程多分时间呢？</p>
<p>这个简单，就相当于N个口袋，优先级高的袋子大，优先级低的袋子小。这样球就不能按照个数分配了，要按照比例来，大口袋的放了一半和小口袋放了一半，里面的球数目虽然差很多，也认为是公平的。</p>
<p>在更新进程运行的统计量的时候，我们其实就可以看出这个逻辑。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * Update the current task's runtime statistics.
 */</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">update_curr</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>curr <span class="token operator">=</span> cfs_rq<span class="token operator">-&gt;</span>curr<span class="token punctuation">;</span>
    u64 now <span class="token operator">=</span> <span class="token function">rq_clock_task</span><span class="token punctuation">(</span><span class="token function">rq_of</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    u64 delta_exec<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    delta_exec <span class="token operator">=</span> now <span class="token operator">-</span> curr<span class="token operator">-&gt;</span>exec_start<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    curr<span class="token operator">-&gt;</span>exec_start <span class="token operator">=</span> now<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    curr<span class="token operator">-&gt;</span>sum_exec_runtime <span class="token operator">+=</span> delta_exec<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    curr<span class="token operator">-&gt;</span>vruntime <span class="token operator">+=</span> <span class="token function">calc_delta_fair</span><span class="token punctuation">(</span>delta_exec<span class="token punctuation">,</span> curr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">update_min_vruntime</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token comment">/*
 * delta /= w
 */</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> u64 <span class="token function">calc_delta_fair</span><span class="token punctuation">(</span>u64 delta<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>se<span class="token operator">-&gt;</span>load<span class="token punctuation">.</span>weight <span class="token operator">!=</span> NICE_0_LOAD<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment">/* delta_exec * weight / lw.weight */</span>
        delta <span class="token operator">=</span> <span class="token function">__calc_delta</span><span class="token punctuation">(</span>delta<span class="token punctuation">,</span> NICE_0_LOAD<span class="token punctuation">,</span> <span class="token operator">&amp;</span>se<span class="token operator">-&gt;</span>load<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> delta<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里得到当前的时间，以及这次的时间片开始的时间，两者相减就是这次运行的时间delta_exec ，但是得到的这个时间其实是实际运行的时间，需要做一定的转化才作为虚拟运行时间vruntime。转化方法如下：</p>
<p><code>虚拟运行时间vruntime += 实际运行时间delta_exec * NICE_0_LOAD/权重</code></p>
<p>这就是说，同样的实际运行时间，给高权重的算少了，低权重的算多了，但是当选取下一个运行进程的时候，还是按照最小的vruntime来的，这样高权重的获得的实际运行时间自然就多了。这就相当于给一个体重(权重)200斤的胖子吃两个馒头，和给一个体重100斤的瘦子吃一个馒头，然后说，你们两个吃的是一样多。这样虽然总体胖子比瘦子多吃了一倍，但是还是公平的。</p>
<h3 id="10-5-调度队列与调度实体"><a href="#10-5-调度队列与调度实体" class="headerlink" title="10.5 调度队列与调度实体"></a>10.5 调度队列与调度实体</h3><p>看来CFS需要一个数据结构来对vruntime进行排序，找出最小的那个。这个能够排序的数据结构不但需要查询的时候，能够快速找到最小的，更新的时候也需要能够快速的调整排序，要知道vruntime可是经常在变的，变了再插入这个数据结构，就需要重新排序。</p>
<p>能够平衡查询和更新速度的是树，在这里使用的是红黑树。</p>
<p>红黑树的的节点是应该包括vruntime的，称为调度实体。</p>
<p>在task_struct中有这样的成员变量：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> se<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">sched_rt_entity</span> rt<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">sched_dl_entity</span> dl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这里有实时调度实体sched_rt_entity，Deadline调度实体sched_dl_entity，以及完全公平算法调度实体sched_entity。</p>
<p>看来不光CFS调度策略需要有这样一个数据结构进行排序，其他的调度策略也同样有自己的数据结构进行排序，因为任何一个策略做调度的时候，都是要区分谁先运行谁后运行。</p>
<p>而进程根据自己是实时的，还是普通的类型，通过这个成员变量，将自己挂在某一个数据结构里面，和其他的进程排序，等待被调度。如果这个进程是个普通进程，则通过sched_entity，将自己挂在这棵红黑树上。</p>
<p>对于普通进程的调度实体定义如下，这里面包含了vruntime和权重load_weight，以及对于运行时间的统计。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">load_weight</span>      load<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span>          run_node<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>        group_node<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>            on_rq<span class="token punctuation">;</span>
    u64                     exec_start<span class="token punctuation">;</span>
    u64                     sum_exec_runtime<span class="token punctuation">;</span>
    u64                     vruntime<span class="token punctuation">;</span>
    u64                     prev_sum_exec_runtime<span class="token punctuation">;</span>
    u64                     nr_migrations<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_statistics</span> statistics<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下图是一个红黑树的例子。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/调度队列红黑树示例.jpeg" alt="调度队列红黑树示例"></p>
<p>所有可运行的进程通过不断地插入操作最终都存储在以时间为顺序的红黑树中，vruntime最小的在树的左侧，vruntime最多的在树的右侧。 CFS调度策略会选择红黑树最左边的叶子节点作为下一个将获得cpu的任务。</p>
<p>每个CPU都有自己的 struct rq 结构，其用于描述在此CPU上所运行的所有进程，其包括一个实时进程队列rt_rq和一个CFS运行队列cfs_rq，在调度时，调度器首先会先去实时进程队列找是否有实时进程需要运行，如果没有才会去CFS运行队列找是否有进行需要运行。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token punctuation">{</span>
    <span class="token comment">/* runqueue lock: */</span>
    raw_spinlock_t lock<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nr_running<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> cpu_load<span class="token punctuation">[</span>CPU_LOAD_IDX_MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">struct</span> <span class="token class-name">load_weight</span> load<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> nr_load_updates<span class="token punctuation">;</span>
    u64 nr_switches<span class="token punctuation">;</span>


    <span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> cfs<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rt_rq</span> rt<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">dl_rq</span> dl<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token operator">*</span>idle<span class="token punctuation">,</span> <span class="token operator">*</span>stop<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于普通进程公平队列cfs_rq，定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* CFS-related fields in a runqueue */</span>
<span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">load_weight</span> load<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nr_running<span class="token punctuation">,</span> h_nr_running<span class="token punctuation">;</span>

    u64 exec_clock<span class="token punctuation">;</span>
    u64 min_vruntime<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">CONFIG_64BIT</span></span>
    u64 min_vruntime_copy<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_root</span> tasks_timeline<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>rb_leftmost<span class="token punctuation">;</span>

    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token operator">*</span>next<span class="token punctuation">,</span> <span class="token operator">*</span>last<span class="token punctuation">,</span> <span class="token operator">*</span>skip<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面rb_root指向的就是红黑树的根节点，这个红黑树在CPU看起来就是一个队列，不断的取下一个应该运行的进程。rb_leftmost指向的是最左面的节点。</p>
<p>到这里终于凑够数据结构了，上面这些数据结构的关系如下图：</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/调度队列与调度实体.jpeg" alt="调度队列与调度实体"></p>
<h3 id="10-6-调度类是如何工作的？"><a href="#10-6-调度类是如何工作的？" class="headerlink" title="10.6 调度类是如何工作的？"></a>10.6 调度类是如何工作的？</h3><p>调度类的定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sched_class</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>enqueue_task<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>dequeue_task<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>yield_task<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">bool</span> <span class="token punctuation">(</span><span class="token operator">*</span>yield_to_task<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> bool preempt<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>check_preempt_curr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>pick_next_task<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span>
                        <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span>
                        <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> <span class="token operator">*</span>rf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>put_prev_task<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>set_curr_task<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>task_tick<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> queued<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>task_fork<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>task_dead<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>switched_from<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>this_rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>switched_to<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>this_rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>prio_changed<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>this_rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>task<span class="token punctuation">,</span> <span class="token keyword">int</span> oldprio<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>get_rr_interval<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span>
                     <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>update_curr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个结构定义了很多种方法，用于在队列上操作任务。这里请大家注意第一个成员变量，是一个指针，指向下一个调度类。</p>
<p>上面我们讲了，调度类分为下面这几种：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> stop_sched_class<span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> dl_sched_class<span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> rt_sched_class<span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> fair_sched_class<span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> idle_sched_class<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>它们其实是放在一个链表上的。这里我们以调度最常见的操作，取下一个任务为例，来解析一下。可以看到，这里面有一个for_each_class循环，沿着上面的顺序，依次调用每个调度类的方法。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * Pick up the highest-prio task:
 */</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>
<span class="token function">pick_next_task</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> <span class="token operator">*</span>rf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> <span class="token operator">*</span>class<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">for_each_class</span><span class="token punctuation">(</span>class<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        p <span class="token operator">=</span> class<span class="token operator">-&gt;</span><span class="token function">pick_next_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> rf<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>p <span class="token operator">==</span> RETRY_TASK<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">goto</span> again<span class="token punctuation">;</span>
            <span class="token keyword">return</span> p<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这就说明，调度的时候是从优先级最高的调度类到优先级低的调度类，依次执行。而对于每种调度类，有自己的实现，例如，CFS就有fair_sched_class。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> fair_sched_class <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>next               <span class="token operator">=</span> <span class="token operator">&amp;</span>idle_sched_class<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>enqueue_task       <span class="token operator">=</span> enqueue_task_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>dequeue_task       <span class="token operator">=</span> dequeue_task_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>yield_task         <span class="token operator">=</span> yield_task_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>yield_to_task      <span class="token operator">=</span> yield_to_task_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>check_preempt_curr <span class="token operator">=</span> check_preempt_wakeup<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>pick_next_task     <span class="token operator">=</span> pick_next_task_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>put_prev_task      <span class="token operator">=</span> put_prev_task_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>set_curr_task      <span class="token operator">=</span> set_curr_task_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>task_tick          <span class="token operator">=</span> task_tick_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>task_fork          <span class="token operator">=</span> task_fork_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>prio_changed       <span class="token operator">=</span> prio_changed_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>switched_from      <span class="token operator">=</span> switched_from_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>switched_to        <span class="token operator">=</span> switched_to_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>get_rr_interval    <span class="token operator">=</span> get_rr_interval_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>update_curr        <span class="token operator">=</span> update_curr_fair<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于同样的pick_next_task选取下一个要运行的任务这个动作，不同的调度类有自己的实现。fair_sched_class的实现是pick_next_task_fair，rt_sched_class的实现是pick_next_task_rt。</p>
<p>我们会发现这两个函数是操作不同的队列，pick_next_task_rt操作的是rt_rq，pick_next_task_fair操作的是cfs_rq。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>
<span class="token function">pick_next_task_rt</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> <span class="token operator">*</span>rf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rt_rq</span> <span class="token operator">*</span>rt_rq <span class="token operator">=</span> <span class="token operator">&amp;</span>rq<span class="token operator">-&gt;</span>rt<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>


<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>
<span class="token function">pick_next_task_fair</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> <span class="token operator">*</span>rf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq <span class="token operator">=</span> <span class="token operator">&amp;</span>rq<span class="token operator">-&gt;</span>cfs<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样整个运行的场景就串起来了，在每个CPU上都有一个队列rq，这个队列里面包含多个子队列，例如rt_rq和cfs_rq，不同的队列有不同的实现方式，cfs_rq就是用红黑树实现的。</p>
<p>当有一天，某个CPU需要找下一个任务执行的时候，会按照优先级依次调用调度类，不同的调度类操作不同的队列。当然rt_sched_class先被调用，它会在rt_rq上找下一个任务，只有找不到的时候，才轮到fair_sched_class被调用，它会在cfs_rq上找下一个任务。这样保证了实时任务的优先级永远大于普通任务。</p>
<p>下面我们仔细看一下sched_class定义的与调度有关的函数。</p>
<ul>
<li>enqueue_task 向就绪队列中添加一个进程，当某个进程进入可运行状态时，调用这个函数；</li>
<li>dequeue_task 将一个进程从就就绪队列中删除；</li>
<li>pick_next_task 选择接下来要运行的进程；</li>
<li>put_prev_task 用另一个进程代替当前运行的进程；</li>
<li>set_curr_task 用于修改调度策略；</li>
<li>task_tick 每次周期性时钟到的时候，这个函数被调用，可能触发调度。</li>
</ul>
<p>在这里面，我们重点看fair_sched_class对于pick_next_task的实现pick_next_task_fair，获取下一个进程。调用路径如下：pick_next_task_fair-&gt;pick_next_entity-&gt;__pick_first_entity。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span><span class="token function">__pick_first_entity</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>left <span class="token operator">=</span> <span class="token function">rb_first_cached</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cfs_rq<span class="token operator">-&gt;</span>tasks_timeline<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>left<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token function">rb_entry</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span><span class="token punctuation">,</span> run_node<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从这个函数的实现可以看出，就是从红黑树里面取最左面的节点。</p>
<h3 id="10-7-总结"><a href="#10-7-总结" class="headerlink" title="10.7 总结"></a>10.7 总结</h3><p>一个CPU上有一个队列，CFS的队列是一棵红黑树，树的每一个节点都是一个sched_entity，每个sched_entity都属于一个task_struct，task_struct里面有指针指向这个进程属于哪个调度类。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/调度总结（上）.jpeg" alt="调度总结（上）"></p>
<p>在调度的时候，依次调用调度类的函数，从CPU的队列中取出下一个进程。上面图中的调度器、上下文切换这一节我们没有讲，下一节我们讲讲基于这些数据结构，如何实现调度。</p>
<h2 id="十一、调度（中）"><a href="#十一、调度（中）" class="headerlink" title="十一、调度（中）"></a>十一、调度（中）</h2><p>所谓进程调度，其实就是一个人在做A项目，在某个时刻，换成做B项目去了。发生这种情况，主要有两种方式。</p>
<p><strong>方式一</strong>：A项目做着做着，发现里面有一条指令sleep，也就是要休息一下，或者在等待某个I/O事件。那没办法了，就要主动让出CPU，然后可以开始做B项目。</p>
<p><strong>方式二</strong>：A项目做着做着，旷日持久，实在受不了了。项目经理介入了，说这个项目A先停停，B项目也要做一下，要不然B项目该投诉了。</p>
<h3 id="11-1-主动调度"><a href="#11-1-主动调度" class="headerlink" title="11.1 主动调度"></a>11.1 主动调度</h3><p>我们这一节先来看方式一，主动调度。</p>
<p>这里我找了几个代码片段。 <strong>第一个片段是Btrfs，等待一个写入</strong> 。 Btrfs（B-Tree）是一种文件系统。</p>
<p>这个片段可以看作写入块设备的一个典型场景。写入需要一段时间，这段时间用不上CPU，还不如主动让给其他进程。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">btrfs_wait_for_no_snapshoting_writes</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">btrfs_root</span> <span class="token operator">*</span>root<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        <span class="token function">prepare_to_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>root<span class="token operator">-&gt;</span>subv_writers<span class="token operator">-&gt;</span>wait<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait<span class="token punctuation">,</span>
                TASK_UNINTERRUPTIBLE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        writers <span class="token operator">=</span> <span class="token function">percpu_counter_sum</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>root<span class="token operator">-&gt;</span>subv_writers<span class="token operator">-&gt;</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>writers<span class="token punctuation">)</span>
            <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">finish_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>root<span class="token operator">-&gt;</span>subv_writers<span class="token operator">-&gt;</span>wait<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>writers<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另外一个例子是， <strong>从Tap网络设备等待一个读取</strong> 。Tap网络设备是虚拟机使用的网络设备。当没有数据到来的时候，它也需要等待，所以也会选择把CPU让给其他进程。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> ssize_t <span class="token function">tap_do_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">tap_queue</span> <span class="token operator">*</span>q<span class="token punctuation">,</span>
               <span class="token keyword">struct</span> <span class="token class-name">iov_iter</span> <span class="token operator">*</span>to<span class="token punctuation">,</span>
               <span class="token keyword">int</span> noblock<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>noblock<span class="token punctuation">)</span>
            <span class="token function">prepare_to_wait</span><span class="token punctuation">(</span><span class="token function">sk_sleep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-&gt;</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait<span class="token punctuation">,</span>
                    TASK_INTERRUPTIBLE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token comment">/* Nothing to read, let's sleep */</span>
        <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来，我们就来看 <strong>schedule函数的调用过程</strong>。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">asmlinkage __visible <span class="token keyword">void</span> __sched <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk <span class="token operator">=</span> current<span class="token punctuation">;</span>

    <span class="token function">sched_submit_work</span><span class="token punctuation">(</span>tsk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        <span class="token function">preempt_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">__schedule</span><span class="token punctuation">(</span>false<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sched_preempt_enable_no_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">need_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这段代码的主要逻辑是在__schedule函数中实现的。这个函数比较复杂，我们分几个部分来讲解。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> __sched notrace <span class="token function">__schedule</span><span class="token punctuation">(</span>bool preempt<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span>switch_count<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> rf<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">;</span>
    <span class="token keyword">int</span> cpu<span class="token punctuation">;</span>

    cpu <span class="token operator">=</span> <span class="token function">smp_processor_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    rq <span class="token operator">=</span> <span class="token function">cpu_rq</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
    prev <span class="token operator">=</span> rq<span class="token operator">-&gt;</span>curr<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先，在当前的CPU上，我们取出任务队列rq。</p>
<p>task_struct *prev指向这个CPU的任务队列上面正在运行的那个进程curr。为啥是prev？因为一旦将来它被切换下来，那它就成了前任了。</p>
<p>接下来代码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">next <span class="token operator">=</span> <span class="token function">pick_next_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">clear_tsk_need_resched</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">clear_preempt_need_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>第二步，获取下一个任务，task_struct <em>next指向下一个任务，这就是 <em>*继任</em></em> 。</p>
<p>pick_next_task的实现如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>
<span class="token function">pick_next_task</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> <span class="token operator">*</span>rf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> <span class="token operator">*</span>class<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
    <span class="token comment">/*
     * Optimization: we know that if all tasks are in the fair class we can call that function directly, but only if the @prev task wasn't of a higher scheduling class, because otherwise those loose the opportunity to pull in more work from other CPUs.
     */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token punctuation">(</span>prev<span class="token operator">-&gt;</span>sched_class <span class="token operator">==</span> <span class="token operator">&amp;</span>idle_sched_class <span class="token operator">||</span>
            prev<span class="token operator">-&gt;</span>sched_class <span class="token operator">==</span> <span class="token operator">&amp;</span>fair_sched_class<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
           rq<span class="token operator">-&gt;</span>nr_running <span class="token operator">==</span> rq<span class="token operator">-&gt;</span>cfs<span class="token punctuation">.</span>h_nr_running<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        p <span class="token operator">=</span> fair_sched_class<span class="token punctuation">.</span><span class="token function">pick_next_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> rf<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>p <span class="token operator">==</span> RETRY_TASK<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">goto</span> again<span class="token punctuation">;</span>
        <span class="token comment">/* Assumes fair_sched_class-&gt;next == idle_sched_class */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span>
            p <span class="token operator">=</span> idle_sched_class<span class="token punctuation">.</span><span class="token function">pick_next_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> rf<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> p<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
again<span class="token operator">:</span>
    <span class="token function">for_each_class</span><span class="token punctuation">(</span>class<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        p <span class="token operator">=</span> class<span class="token operator">-&gt;</span><span class="token function">pick_next_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> rf<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>p <span class="token operator">==</span> RETRY_TASK<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">goto</span> again<span class="token punctuation">;</span>
            <span class="token keyword">return</span> p<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们来看again这里，就是咱们上一节讲的依次调用调度类。但是这里有了一个优化，因为大部分进程是普通进程，所以大部分情况下会调用上面的逻辑，调用的就是fair_sched_class.pick_next_task。</p>
<p>根据上一节对于fair_sched_class的定义，它调用的是pick_next_task_fair，代码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>
<span class="token function">pick_next_task_fair</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> <span class="token operator">*</span>rf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq <span class="token operator">=</span> <span class="token operator">&amp;</span>rq<span class="token operator">-&gt;</span>cfs<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
    <span class="token keyword">int</span> new_tasks<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于CFS调度类，取出相应的队列cfs_rq，这就是我们上一节讲的那棵红黑树。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">        <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>curr <span class="token operator">=</span> cfs_rq<span class="token operator">-&gt;</span>curr<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>curr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>curr<span class="token operator">-&gt;</span>on_rq<span class="token punctuation">)</span>
                <span class="token function">update_curr</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                curr <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">}</span>
        se <span class="token operator">=</span> <span class="token function">pick_next_entity</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> curr<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>取出当前正在运行的任务curr，如果依然是可运行的状态，也即处于进程就绪状态，则调用update_curr更新vruntime。update_curr咱们上一节就见过了，它会根据实际运行时间算出vruntime来。</p>
<p>接着，pick_next_entity从红黑树里面，取最左边的一个节点。这个函数的实现我们上一节也讲过了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">    p <span class="token operator">=</span> <span class="token function">task_of</span><span class="token punctuation">(</span>se<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">!=</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>pse <span class="token operator">=</span> <span class="token operator">&amp;</span>prev<span class="token operator">-&gt;</span>se<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token function">put_prev_entity</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> pse<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">set_next_entity</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> se<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>task_of得到下一个调度实体对应的task_struct，如果发现继任和前任不一样，这就说明有一个更需要运行的进程了，就需要更新红黑树了。前面前任的vruntime更新过了，put_prev_entity放回红黑树，会找到相应的位置，然后set_next_entity将继任者设为当前任务。</p>
<p>第三步，当选出的继任者和前任不同，就要进行上下文切换，继任者进程正式进入运行。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>prev <span class="token operator">!=</span> next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        rq<span class="token operator">-&gt;</span>nr_switches<span class="token operator">++</span><span class="token punctuation">;</span>
        rq<span class="token operator">-&gt;</span>curr <span class="token operator">=</span> next<span class="token punctuation">;</span>
        <span class="token operator">++</span><span class="token operator">*</span>switch_count<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        rq <span class="token operator">=</span> <span class="token function">context_switch</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> next<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rf<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="11-2-进程上下文切换"><a href="#11-2-进程上下文切换" class="headerlink" title="11.2 进程上下文切换"></a>11.2 进程上下文切换</h3><p>上下文切换主要干两件事情，一是切换进程空间，也即虚拟内存；二是切换寄存器和CPU上下文。</p>
<p>我们先来看context_switch的实现。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * context_switch - switch to the new MM and the new thread's register state.
 */</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>
<span class="token function">context_switch</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span>
           <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>next<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> <span class="token operator">*</span>rf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>mm<span class="token punctuation">,</span> <span class="token operator">*</span>oldmm<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    mm <span class="token operator">=</span> next<span class="token operator">-&gt;</span>mm<span class="token punctuation">;</span>
    oldmm <span class="token operator">=</span> prev<span class="token operator">-&gt;</span>active_mm<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">switch_mm_irqs_off</span><span class="token punctuation">(</span>oldmm<span class="token punctuation">,</span> mm<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* Here we just switch the register state and the stack. */</span>
    <span class="token function">switch_to</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">,</span> prev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">barrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">finish_task_switch</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里首先是内存空间的切换，里面涉及内存管理的内容比较多。内存管理后面我们会有专门的章节来讲，这里你先知道有这么一回事就行了。</p>
<p>接下来，我们看switch_to。它就是寄存器和栈的切换，它调用到了__switch_to_asm。这是一段汇编代码，主要用于栈的切换。</p>
<p>对于32位操作系统来讲，切换的是栈顶指针esp。</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">/*
 * %eax: prev task
 * %edx: next task
 */
ENTRY(__switch_to_asm)
......
    /* switch stack */
    movl    %esp, TASK_threadsp(%eax)
    movl    TASK_threadsp(%edx), %esp
......
    jmp     __switch_to
END(__switch_to_asm)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于64位操作系统来讲，切换的是栈顶指针rsp。</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">/*
 * %rdi: prev task
 * %rsi: next task
 */
ENTRY(__switch_to_asm)
......
    /* switch stack */
    movq    %rsp, TASK_threadsp(%rdi)
    movq    TASK_threadsp(%rsi), %rsp
......
    jmp     __switch_to
END(__switch_to_asm)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最终，都返回了__switch_to这个函数。这个函数对于32位和64位操作系统虽然有不同的实现，但里面做的事情是差不多的。所以我这里仅仅列出64位操作系统做的事情。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">__visible __notrace_funcgraph <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>
<span class="token function">__switch_to</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev_p<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>next_p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">thread_struct</span> <span class="token operator">*</span>prev <span class="token operator">=</span> <span class="token operator">&amp;</span>prev_p<span class="token operator">-&gt;</span>thread<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">thread_struct</span> <span class="token operator">*</span>next <span class="token operator">=</span> <span class="token operator">&amp;</span>next_p<span class="token operator">-&gt;</span>thread<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">int</span> cpu <span class="token operator">=</span> <span class="token function">smp_processor_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">tss_struct</span> <span class="token operator">*</span>tss <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">per_cpu</span><span class="token punctuation">(</span>cpu_tss<span class="token punctuation">,</span> cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">load_TLS</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">this_cpu_write</span><span class="token punctuation">(</span>current_task<span class="token punctuation">,</span> next_p<span class="token punctuation">)</span><span class="token punctuation">;</span>


    <span class="token comment">/* Reload esp0 and ss1.  This changes current_thread_info(). */</span>
    <span class="token function">load_sp0</span><span class="token punctuation">(</span>tss<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> prev_p<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面有一个Per CPU的结构体tss。这是个什么呢？</p>
<p>在x86体系结构中，提供了一种以硬件的方式进行进程切换的模式，对于每个进程，x86希望在内存里面维护一个TSS（Task State Segment，任务状态段）结构。这里面有所有的寄存器。</p>
<p>另外，还有一个特殊的寄存器TR（Task Register，任务寄存器），指向某个进程的TSS。更改TR的值，将会触发硬件保存CPU所有寄存器的值到当前进程的TSS中，然后从新进程的TSS中读出所有寄存器值，加载到CPU对应的寄存器中。</p>
<p>下图就是32位的TSS结构。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/32位的TSS结构.png" alt="32位的TSS结构"></p>
<blockquote>
<p>图片来自Intel® 64 and IA-32 Architectures Software Developer’s Manual Combined Volumes</p>
</blockquote>
<p>但是这样有个缺点。我们做进程切换的时候，没必要每个寄存器都切换，这样每个进程一个TSS，就需要全量保存，全量切换，动作太大了。</p>
<p>于是，Linux操作系统想了一个办法。还记得在系统初始化的时候，会调用cpu_init吗？这里面会给每一个CPU关联一个TSS，然后将TR指向这个TSS，然后在操作系统的运行过程中，TR就不切换了，永远指向这个TSS。TSS用数据结构tss_struct表示，在x86_hw_tss中可以看到和上图相应的结构。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">cpu_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> cpu <span class="token operator">=</span> <span class="token function">smp_processor_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>curr <span class="token operator">=</span> current<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">tss_struct</span> <span class="token operator">*</span>t <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">per_cpu</span><span class="token punctuation">(</span>cpu_tss<span class="token punctuation">,</span> cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">load_sp0</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">set_tss_desc</span><span class="token punctuation">(</span>cpu<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">load_TR_desc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">tss_struct</span> <span class="token punctuation">{</span>
    <span class="token comment">/*
     * The hardware state:
     */</span>
    <span class="token keyword">struct</span> <span class="token class-name">x86_hw_tss</span>   x86_tss<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>       io_bitmap<span class="token punctuation">[</span>IO_BITMAP_LONGS <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在Linux中，真的参与进程切换的寄存器很少，主要的就是栈顶寄存器。</p>
<p>于是，在task_struct里面，还有一个我们原来没有注意的成员变量thread。这里面保留了要切换进程的时候需要修改的寄存器。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* CPU-specific state of this task: */</span>
<span class="token keyword">struct</span> <span class="token class-name">thread_struct</span>        thread<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>所谓的进程切换，就是将某个进程的thread_struct里面的寄存器的值，写入到CPU的TR指向的tss_struct，对于CPU来讲，这就算是完成了切换。</p>
<p>例如__switch_to中的load_sp0，就是将下一个进程的thread_struct的sp0的值加载到tss_struct里面去。</p>
<h3 id="11-3-指令指针的保存与恢复"><a href="#11-3-指令指针的保存与恢复" class="headerlink" title="11.3 指令指针的保存与恢复"></a>11.3 指令指针的保存与恢复</h3><p>你是不是觉得，这样真的就完成切换了吗？是的，不信我们来 <strong>盘点</strong> 一下。</p>
<p>从进程A切换到进程B，用户栈要不要切换呢？当然要，其实早就已经切换了，就在切换内存空间的时候。每个进程的用户栈都是独立的，都在内存空间里面。</p>
<p>那内核栈呢？已经在__switch_to里面切换了，也就是将current_task指向当前的task_struct。里面的void *stack指针，指向的就是当前的内核栈。</p>
<p>内核栈的栈顶指针呢？在<strong>switch_to_asm里面已经切换了栈顶指针，并且将栈顶指针在</strong>switch_to加载到了TSS里面。</p>
<p>用户栈的栈顶指针呢？如果当前在内核里面的话，它当然是在内核栈顶部的pt_regs结构里面呀。当从内核返回用户态运行的时候，pt_regs里面有所有当时在用户态的时候运行的上下文信息，就可以开始运行了。</p>
<p>唯一让人不容易理解的是指令指针寄存器，它应该指向下一条指令的，那它是如何切换的呢？这里有点绕，请你仔细看。</p>
<p>这里我先明确一点，进程的调度都最终会调用到__schedule函数。为了方便你记住，我姑且给它起个名字，就叫“ <strong>进程调度第一定律</strong> ”。后面我们会多次用到这个定律，你一定要记住。</p>
<p>我们用最前面的例子仔细分析这个过程。本来一个进程A在用户态是要写一个文件的，写文件的操作用户态没办法完成，就要通过系统调用到达内核态。在这个切换的过程中，用户态的指令指针寄存器是保存在pt_regs里面的，到了内核态，就开始沿着写文件的逻辑一步一步执行，结果发现需要等待，于是就调用__schedule函数。</p>
<p>这个时候，进程A在内核态的指令指针是指向<strong>schedule了。这里请记住，A进程的内核栈会保存这个</strong>schedule的调用，而且知道这是从btrfs_wait_for_no_snapshoting_writes这个函数里面进去的。</p>
<p>__schedule里面经过上面的层层调用，到达了context_switch的最后三行指令（其中barrier语句是一个编译器指令，用于保证switch_to和finish_task_switch的执行顺序，不会因为编译阶段优化而改变，这里咱们可以忽略它）。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">switch_to</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">,</span> prev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">barrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> <span class="token function">finish_task_switch</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>当进程A在内核里面执行switch_to的时候，内核态的指令指针也是指向这一行的。但是在switch_to里面，将寄存器和栈都切换到成了进程B的，唯一没有变的就是指令指针寄存器。当switch_to返回的时候，指令指针寄存器指向了下一条语句finish_task_switch。</p>
<p>但这个时候的finish_task_switch已经不是进程A的finish_task_switch了，而是进程B的finish_task_switch了。</p>
<p>这样合理吗？你怎么知道进程B当时被切换下去的时候，执行到哪里了？恢复B进程执行的时候一定在这里呢？这时候就要用到咱的“进程调度第一定律”了。</p>
<p>当年B进程被别人切换走的时候，也是调用__schedule，也是调用到switch_to，被切换成为C进程的，所以，B进程当年的下一个指令也是finish_task_switch，这就说明指令指针指到这里是没有错的。</p>
<p>接下来，我们要从finish_task_switch完毕后，返回__schedule的调用了。返回到哪里呢？按照函数返回的原理，当然是从内核栈里面去找，是返回到btrfs_wait_for_no_snapshoting_writes吗？当然不是了，因为btrfs_wait_for_no_snapshoting_writes是在A进程的内核栈里面的，它早就被切换走了，应该从B进程的内核栈里面找。</p>
<p>假设，B就是最前面例子里面调用tap_do_read读网卡的进程。它当年调用__schedule的时候，是从tap_do_read这个函数调用进去的。</p>
<p>当然，B进程的内核栈里面放的是tap_do_read。于是，从__schedule返回之后，当然是接着tap_do_read运行，然后在内核运行完毕后，返回用户态。这个时候，B进程内核栈的pt_regs也保存了用户态的指令指针寄存器，就接着在用户态的下一条指令开始运行就可以了。</p>
<p>假设，我们只有一个CPU，从B切换到C，从C又切换到A。在C切换到A的时候，还是按照“进程调度第一定律”，C进程还是会调用__schedule到达switch_to，在里面切换成为A的内核栈，然后运行finish_task_switch。</p>
<p>这个时候运行的finish_task_switch，才是A进程的finish_task_switch。运行完毕从__schedule返回的时候，从内核栈上才知道，当年是从btrfs_wait_for_no_snapshoting_writes调用进去的，因而应该返回btrfs_wait_for_no_snapshoting_writes继续执行，最后内核执行完毕返回用户态，同样恢复pt_regs，恢复用户态的指令指针寄存器，从用户态接着运行。</p>
<p>到这里你是不是有点理解为什么switch_to有三个参数呢？为啥有两个prev呢？其实我们从定义就可以看到。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">switch_to</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">,</span> last<span class="token punctuation">)</span>                 </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span>                                                </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token function">prepare_switch_to</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>                  </span><span class="token punctuation">\</span>
                                                    <span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span>last<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">__switch_to_asm</span><span class="token punctuation">(</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上面的例子中，A切换到B的时候，运行到<strong>switch_to_asm这一行的时候，是在A的内核栈上运行的，prev是A，next是B。但是，A执行完</strong>switch_to_asm之后就被切换走了，当C再次切换到A的时候，运行到<strong>switch_to_asm，是从C的内核栈运行的。这个时候，prev是C，next是A，但是</strong>switch_to_asm里面切换成为了A当时的内核栈。</p>
<p>还记得当年的场景“prev是A，next是B”，__switch_to_asm里面return prev的时候，还没return的时候，prev这个变量里面放的还是C，因而它会把C放到返回结果中。但是，一旦return，就会弹出A当时的内核栈。这个时候，prev变量就变成了A，next变量就变成了B。这就还原了当年的场景，好在返回值里面的last还是C。</p>
<p>通过三个变量switch_to(prev = A, next=B, last=C)，A进程就明白了，我当时被切换走的时候，是切换成B，这次切换回来，是从C回来的。</p>
<h3 id="11-4-总结"><a href="#11-4-总结" class="headerlink" title="11.4 总结"></a>11.4 总结</h3><p>这一节我们讲主动调度的过程，也即一个运行中的进程主动调用<strong>schedule让出CPU。在</strong>schedule里面会做两件事情，第一是选取下一个进程，第二是进行上下文切换。而上下文切换又分用户态进程空间的切换和内核态的切换。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/主动调度.png" alt="主动调度"></p>
<h2 id="十二、调度（下）"><a href="#十二、调度（下）" class="headerlink" title="十二、调度（下）"></a>十二、调度（下）</h2><h3 id="12-1-抢占式调度"><a href="#12-1-抢占式调度" class="headerlink" title="12.1 抢占式调度"></a>12.1 抢占式调度</h3><p>上一节我们讲的主动调度是第一种方式，第二种方式，就是抢占式调度。什么情况下会发生抢占呢？</p>
<p>最常见的现象就是 <strong>一个进程执行时间太长了，是时候切换到另一个进程了</strong> 。那怎么衡量一个进程的运行时间呢？在计算机里面有一个时钟，会过一段时间触发一次时钟中断，通知操作系统，时间又过去一个时钟周期，这是个很好的方式，可以查看是否是需要抢占的时间点。</p>
<p>时钟中断处理函数会调用scheduler_tick()，它的代码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">scheduler_tick</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> cpu <span class="token operator">=</span> <span class="token function">smp_processor_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq <span class="token operator">=</span> <span class="token function">cpu_rq</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>curr <span class="token operator">=</span> rq<span class="token operator">-&gt;</span>curr<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    curr<span class="token operator">-&gt;</span>sched_class<span class="token operator">-&gt;</span><span class="token function">task_tick</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> curr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">cpu_load_update_active</span><span class="token punctuation">(</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">calc_global_load_tick</span><span class="token punctuation">(</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个函数先取出当前cpu的运行队列，然后得到这个队列上当前正在运行中的进程的task_struct，然后调用这个task_struct的调度类的task_tick函数，顾名思义这个函数就是来处理时钟事件的。</p>
<p>如果当前运行的进程是普通进程，调度类为fair_sched_class，调用的处理时钟的函数为task_tick_fair。我们来看一下它的实现。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">task_tick_fair</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token keyword">int</span> queued<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se <span class="token operator">=</span> <span class="token operator">&amp;</span>curr<span class="token operator">-&gt;</span>se<span class="token punctuation">;</span>

    <span class="token function">for_each_sched_entity</span><span class="token punctuation">(</span>se<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cfs_rq <span class="token operator">=</span> <span class="token function">cfs_rq_of</span><span class="token punctuation">(</span>se<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">entity_tick</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> se<span class="token punctuation">,</span> queued<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>根据当前进程的task_struct，找到对应的调度实体sched_entity和cfs_rq队列，调用entity_tick。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span>
<span class="token function">entity_tick</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token keyword">int</span> queued<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">update_curr</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">update_load_avg</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> UPDATE_TG<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">update_cfs_shares</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cfs_rq<span class="token operator">-&gt;</span>nr_running <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token function">check_preempt_tick</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> curr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在entity_tick里面，我们又见到了熟悉的update_curr。它会更新当前进程的vruntime，然后调用check_preempt_tick。顾名思义就是，检查是否是时候被抢占了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span>
<span class="token function">check_preempt_tick</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>curr<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ideal_runtime<span class="token punctuation">,</span> delta_exec<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se<span class="token punctuation">;</span>
    s64 delta<span class="token punctuation">;</span>

    ideal_runtime <span class="token operator">=</span> <span class="token function">sched_slice</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> curr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    delta_exec <span class="token operator">=</span> curr<span class="token operator">-&gt;</span>sum_exec_runtime <span class="token operator">-</span> curr<span class="token operator">-&gt;</span>prev_sum_exec_runtime<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>delta_exec <span class="token operator">&gt;</span> ideal_runtime<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">resched_curr</span><span class="token punctuation">(</span><span class="token function">rq_of</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    se <span class="token operator">=</span> <span class="token function">__pick_first_entity</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
    delta <span class="token operator">=</span> curr<span class="token operator">-&gt;</span>vruntime <span class="token operator">-</span> se<span class="token operator">-&gt;</span>vruntime<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>delta <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>delta <span class="token operator">&gt;</span> ideal_runtime<span class="token punctuation">)</span>
        <span class="token function">resched_curr</span><span class="token punctuation">(</span><span class="token function">rq_of</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>check_preempt_tick先是调用sched_slice函数计算出的ideal_runtime，他是一个调度周期中，这个进程应该运行的实际时间。</p>
<p>sum_exec_runtime指进程总共执行的实际时间，prev_sum_exec_runtime指上次该进程被调度时已经占用的实际时间。每次在调度一个新的进程时都会把它的se-&gt;prev_sum_exec_runtime = se-&gt;sum_exec_runtime，所以sum_exec_runtime-prev_sum_exec_runtime就是这次调度占用实际时间。如果这个时间大于ideal_runtime，则应该被抢占了。</p>
<p>除了这个条件之外，还会通过__pick_first_entity取出红黑树中最小的进程。如果当前进程的vruntime大于红黑树中最小的进程的vruntime，且差值大于ideal_runtime，也应该被抢占了。</p>
<p>当发现当前进程应该被抢占，不能直接把它踢下来，而是把它标记为应该被抢占。为什么呢？因为进程调度第一定律呀，一定要等待正在运行的进程调用__schedule才行啊，所以这里只能先标记一下。</p>
<p>标记一个进程应该被抢占，都是调用resched_curr，它会调用set_tsk_need_resched，标记进程应该被抢占，但是此时此刻，并不真的抢占，而是打上一个标签TIF_NEED_RESCHED。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">set_tsk_need_resched</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">set_tsk_thread_flag</span><span class="token punctuation">(</span>tsk<span class="token punctuation">,</span>TIF_NEED_RESCHED<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>另外一个可能抢占的场景是 <strong>当一个进程被唤醒的时候</strong> 。</p>
<p>我们前面说过，当一个进程在等待一个I/O的时候，会主动放弃CPU。但是当I/O到来的时候，进程往往会被唤醒。这个时候是一个时机。当被唤醒的进程优先级高于CPU上的当前进程，就会触发抢占。try_to_wake_up()调用ttwu_queue将这个唤醒的任务添加到队列当中。ttwu_queue再调用ttwu_do_activate激活这个任务。ttwu_do_activate调用ttwu_do_wakeup。这里面调用了check_preempt_curr检查是否应该发生抢占。如果应该发生抢占，也不是直接踢走当然进程，而也是将当前进程标记为应该被抢占。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">ttwu_do_wakeup</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> wake_flags<span class="token punctuation">,</span>
               <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> <span class="token operator">*</span>rf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">check_preempt_curr</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> p<span class="token punctuation">,</span> wake_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>state <span class="token operator">=</span> TASK_RUNNING<span class="token punctuation">;</span>
    <span class="token function">trace_sched_wakeup</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>到这里，你会发现，抢占问题只做完了一半。就是标识当前运行中的进程应该被抢占了，但是真正的抢占动作并没有发生。</p>
<h3 id="12-2-抢占的时机"><a href="#12-2-抢占的时机" class="headerlink" title="12.2 抢占的时机"></a>12.2 抢占的时机</h3><p>真正的抢占还需要时机，也就是需要那么一个时刻，让正在运行中的进程有机会调用一下__schedule。</p>
<p>你可以想象，不可能某个进程代码运行着，突然要去调用__schedule，代码里面不可能这么写，所以一定要规划几个时机，这个时机分为用户态和内核态。</p>
<h4 id="12-2-1-用户态的抢占时机"><a href="#12-2-1-用户态的抢占时机" class="headerlink" title="12.2.1 用户态的抢占时机"></a>12.2.1 用户态的抢占时机</h4><p>对于用户态的进程来讲，从系统调用中返回的那个时刻，是一个被抢占的时机。</p>
<p>前面讲系统调用的时候，64位的系统调用的链路位do_syscall_64-&gt;syscall_return_slowpath-&gt;prepare_exit_to_usermode-&gt;exit_to_usermode_loop，当时我们还没关注exit_to_usermode_loop这个函数，现在我们来看一下。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">exit_to_usermode_loop</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span>regs<span class="token punctuation">,</span> u32 cached_flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* We have work to do. */</span>
        <span class="token function">local_irq_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>cached_flags <span class="token operator">&amp;</span> _TIF_NEED_RESCHED<span class="token punctuation">)</span>
            <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在我们看到在exit_to_usermode_loop函数中，上面打的标记起了作用，如果被打了_TIF_NEED_RESCHED，调用schedule进行调度，调用的过程和上一节解析的一样，会选择一个进程让出CPU，做上下文切换。</p>
<p>对于用户态的进程来讲，从中断中返回的那个时刻，也是一个被抢占的时机。</p>
<p>在arch/x86/entry/entry_64.S中有中断的处理过程。又是一段汇编语言代码，你重点领会它的意思就行，不要纠结每一行都看懂。</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">common_interrupt:
        ASM_CLAC
        addq    $-0x80, (%rsp)
        interrupt do_IRQ
ret_from_intr:
        popq    %rsp
        testb   $3, CS(%rsp)
        jz      retint_kernel
/* Interrupt came from user space */
GLOBAL(retint_user)
        mov     %rsp,%rdi
        call    prepare_exit_to_usermode
        TRACE_IRQS_IRETQ
        SWAPGS
        jmp     restore_regs_and_iret
/* Returning to kernel space */
retint_kernel:
#ifdef CONFIG_PREEMPT
        bt      $9, EFLAGS(%rsp)
        jnc     1f
0:      cmpl    $0, PER_CPU_VAR(__preempt_count)
        jnz     1f
        call    preempt_schedule_irq
        jmp     0b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>中断处理调用的是do_IRQ函数，中断完毕后分为两种情况，一个是返回用户态，一个是返回内核态。这个通过注释也能看出来。</p>
<p>咱们先来来看返回用户态这一部分，先不管返回内核态的那部分代码，retint_user会调用prepare_exit_to_usermode，最终调用exit_to_usermode_loop，和上面的逻辑一样，发现有标记则调用schedule()。</p>
<h4 id="12-2-2-内核态的抢占时机"><a href="#12-2-2-内核态的抢占时机" class="headerlink" title="12.2.2 内核态的抢占时机"></a>12.2.2 内核态的抢占时机</h4><p>对内核态的执行中，被抢占的时机一般发生在在preempt_enable()中。</p>
<p>在内核态的执行中，有的操作是不能被中断的，所以在进行这些操作之前，总是先调用preempt_disable()关闭抢占，当再次打开的时候，就是一次内核态代码被抢占的机会。</p>
<p>就像下面代码中展示的一样，preempt_enable()会调用preempt_count_dec_and_test()，判断preempt_count和TIF_NEED_RESCHED看是否可以被抢占。如果可以，就调用preempt_schedule-&gt;preempt_schedule_common-&gt;__schedule进行调度。还是满足进程调度第一定律的。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">preempt_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                        </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span>                                            </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token function">preempt_count_dec_and_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">__preempt_schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">preempt_count_dec_and_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token function">preempt_count_sub</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">should_resched</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span></span></span>

<span class="token keyword">static</span> __always_inline bool <span class="token function">should_resched</span><span class="token punctuation">(</span><span class="token keyword">int</span> preempt_offset<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token function">preempt_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> preempt_offset <span class="token operator">&amp;&amp;</span>
            <span class="token function">tif_need_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">tif_need_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">test_thread_flag</span><span class="token punctuation">(</span>TIF_NEED_RESCHED<span class="token punctuation">)</span></span></span>

<span class="token keyword">static</span> <span class="token keyword">void</span> __sched notrace <span class="token function">preempt_schedule_common</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token function">__schedule</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">need_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在内核态也会遇到中断的情况，当中断返回的时候，返回的仍然是内核态。这个时候也是一个执行抢占的时机，现在我们再来上面中断返回的代码中返回内核的那部分代码，调用的是preempt_schedule_irq。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">asmlinkage __visible <span class="token keyword">void</span> __sched <span class="token function">preempt_schedule_irq</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        <span class="token function">preempt_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">local_irq_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">__schedule</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">local_irq_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sched_preempt_enable_no_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">need_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>preempt_schedule_irq调用__schedule进行调度。还是满足进程调度第一定律的。</p>
<h3 id="12-3-总结"><a href="#12-3-总结" class="headerlink" title="12.3 总结"></a>12.3 总结</h3><p>第一条就是总结了进程调度第一定律的核心函数__schedule的执行过程，这是上一节讲的，因为要切换的东西比较多，需要你详细了解每一部分是如何切换的。</p>
<p>第二条总结了标记为可抢占的场景，第三条是所有的抢占发生的时机，这里是真正验证了进程调度第一定律的。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/进程的调度体系.png" alt="进程的调度体系"></p>
<h2 id="十三、进程的创建"><a href="#十三、进程的创建" class="headerlink" title="十三、进程的创建"></a>十三、进程的创建</h2><p>fork是一个系统调用，根据咱们讲过的系统调用的流程，流程的最后会在sys_call_table中找到相应的系统调用sys_fork。</p>
<p>根据SYSCALL_DEFINE0这个宏的定义，下面这段代码就定义了sys_fork。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE0</span><span class="token punctuation">(</span>fork<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> <span class="token function">_do_fork</span><span class="token punctuation">(</span>SIGCHLD<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>sys_fork会调用_do_fork。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">long</span> <span class="token function">_do_fork</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> clone_flags<span class="token punctuation">,</span>
          <span class="token keyword">unsigned</span> <span class="token keyword">long</span> stack_start<span class="token punctuation">,</span>
          <span class="token keyword">unsigned</span> <span class="token keyword">long</span> stack_size<span class="token punctuation">,</span>
          <span class="token keyword">int</span> __user <span class="token operator">*</span>parent_tidptr<span class="token punctuation">,</span>
          <span class="token keyword">int</span> __user <span class="token operator">*</span>child_tidptr<span class="token punctuation">,</span>
          <span class="token keyword">unsigned</span> <span class="token keyword">long</span> tls<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
    <span class="token keyword">int</span> trace <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> nr<span class="token punctuation">;</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    p <span class="token operator">=</span> <span class="token function">copy_process</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> stack_start<span class="token punctuation">,</span> stack_size<span class="token punctuation">,</span>
             child_tidptr<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> trace<span class="token punctuation">,</span> tls<span class="token punctuation">,</span> NUMA_NO_NODE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">pid</span> <span class="token operator">*</span>pid<span class="token punctuation">;</span>
        pid <span class="token operator">=</span> <span class="token function">get_task_pid</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> PIDTYPE_PID<span class="token punctuation">)</span><span class="token punctuation">;</span>
        nr <span class="token operator">=</span> <span class="token function">pid_vnr</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>


        <span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_PARENT_SETTID<span class="token punctuation">)</span>
            <span class="token function">put_user</span><span class="token punctuation">(</span>nr<span class="token punctuation">,</span> parent_tidptr<span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token function">wake_up_new_task</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token function">put_pid</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="13-1-fork的第一件大事：复制结构"><a href="#13-1-fork的第一件大事：复制结构" class="headerlink" title="13.1 fork的第一件大事：复制结构"></a>13.1 fork的第一件大事：复制结构</h3><p>_do_fork里面做的第一件大事就是copy_process。</p>
<p>这里我们再把task_struct的结构图拿出来，对比着看如何一个个复制。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/fork复制结构.png" alt="fork复制结构"></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> __latent_entropy <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token function">copy_process</span><span class="token punctuation">(</span>
                    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> clone_flags<span class="token punctuation">,</span>
                    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> stack_start<span class="token punctuation">,</span>
                    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> stack_size<span class="token punctuation">,</span>
                    <span class="token keyword">int</span> __user <span class="token operator">*</span>child_tidptr<span class="token punctuation">,</span>
                    <span class="token keyword">struct</span> <span class="token class-name">pid</span> <span class="token operator">*</span>pid<span class="token punctuation">,</span>
                    <span class="token keyword">int</span> trace<span class="token punctuation">,</span>
                    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> tls<span class="token punctuation">,</span>
                    <span class="token keyword">int</span> node<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> retval<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    p <span class="token operator">=</span> <span class="token function">dup_task_struct</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>dup_task_struct主要做了下面几件事情：</p>
<ul>
<li>调用alloc_task_struct_node分配一个task_struct结构；</li>
<li>调用alloc_thread_stack_node来创建内核栈，这里面调用__vmalloc_node_range分配一个连续的THREAD_SIZE的内存空间，赋值给task_struct的void *stack成员变量；</li>
<li>调用arch_dup_task_struct(struct task_struct <em>dst, struct task_struct </em>src)，将task_struct进行复制，其实就是调用memcpy；</li>
<li>调用setup_thread_stack设置thread_info。</li>
</ul>
<p>到这里，整个task_struct复制了一份，而且内核栈也创建好了。</p>
<p>我们再接着看copy_process。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">retval <span class="token operator">=</span> <span class="token function">copy_creds</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> clone_flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>轮到权限相关了，copy_creds主要做了下面几件事情：</p>
<ul>
<li>调用prepare_creds，准备一个新的struct cred *new。如何准备呢？其实还是从内存中分配一个新的struct cred结构，然后调用memcpy复制一份父进程的cred；</li>
<li>接着p-&gt;cred = p-&gt;real_cred = get_cred(new)，将新进程的“我能操作谁”和“谁能操作我”两个权限都指向新的cred。</li>
</ul>
<p>接下来，copy_process重新设置进程运行的统计量。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">p<span class="token operator">-&gt;</span>utime <span class="token operator">=</span> p<span class="token operator">-&gt;</span>stime <span class="token operator">=</span> p<span class="token operator">-&gt;</span>gtime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>start_time <span class="token operator">=</span> <span class="token function">ktime_get_ns</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>real_start_time <span class="token operator">=</span> <span class="token function">ktime_get_boot_ns</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>接下来，copy_process开始设置调度相关的变量。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">retval <span class="token operator">=</span> <span class="token function">sched_fork</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>sched_fork主要做了下面几件事情：</p>
<ul>
<li>调用__sched_fork，在这里面将on_rq设为0，初始化sched_entity，将里面的exec_start、sum_exec_runtime、prev_sum_exec_runtime、vruntime都设为0。你还记得吗，这几个变量涉及进程的实际运行时间和虚拟运行时间。是否到时间应该被调度了，就靠它们几个；</li>
<li>设置进程的状态p-&gt;state = TASK_NEW；</li>
<li>初始化优先级prio、normal_prio、static_prio；</li>
<li>设置调度类，如果是普通进程，就设置为p-&gt;sched_class = &amp;fair_sched_class；</li>
<li>调用调度类的task_fork函数，对于CFS来讲，就是调用task_fork_fair。在这个函数里，先调用update_curr，对于当前的进程进行统计量更新，然后把子进程和父进程的vruntime设成一样，最后调用place_entity，初始化sched_entity。这里有一个变量sysctl_sched_child_runs_first，可以设置父进程和子进程谁先运行。如果设置了子进程先运行，即便两个进程的vruntime一样，也要把子进程的sched_entity放在前面，然后调用resched_curr，标记当前运行的进程TIF_NEED_RESCHED，也就是说，把父进程设置为应该被调度，这样下次调度的时候，父进程会被子进程抢占。</li>
</ul>
<p>接下来，copy_process开始初始化与文件和文件系统相关的变量。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">retval <span class="token operator">=</span> <span class="token function">copy_files</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
retval <span class="token operator">=</span> <span class="token function">copy_fs</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>copy_files主要用于复制一个进程打开的文件信息。这些信息用一个结构files_struct来维护，每个打开的文件都有一个文件描述符。在copy_files函数里面调用dup_fd，在这里面会创建一个新的files_struct，然后将所有的文件描述符数组fdtable拷贝一份。</p>
<p>copy_fs主要用于复制一个进程的目录信息。这些信息用一个结构fs_struct来维护。一个进程有自己的根目录和根文件系统root，也有当前目录pwd和当前目录的文件系统，都在fs_struct里面维护。copy_fs函数里面调用copy_fs_struct，创建一个新的fs_struct，并复制原来进程的fs_struct。</p>
<p>接下来，copy_process开始初始化与信号相关的变量。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">init_sigpending</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>pending<span class="token punctuation">)</span><span class="token punctuation">;</span>
retval <span class="token operator">=</span> <span class="token function">copy_sighand</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
retval <span class="token operator">=</span> <span class="token function">copy_signal</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>copy_sighand会分配一个新的sighand_struct。这里最主要的是维护信号处理函数，在copy_sighand里面会调用memcpy，将信号处理函数sighand-&gt;action从父进程复制到子进程。</p>
<p>init_sigpending和copy_signal用于初始化，并且复制用于维护发给这个进程的信号的数据结构。copy_signal函数会分配一个新的signal_struct，并进行初始化。</p>
<p>接下来，copy_process开始复制进程内存空间。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">retval <span class="token operator">=</span> <span class="token function">copy_mm</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>进程都自己的内存空间，用mm_struct结构来表示。copy_mm函数中调用dup_mm，分配一个新的mm_struct结构，调用memcpy复制这个结构。dup_mmap用于复制内存空间中内存映射的部分。前面讲系统调用的时候，我们说过，mmap可以分配大块的内存，其实mmap也可以将一个文件映射到内存中，方便可以像读写内存一样读写文件，这个在内存管理那节我们讲。</p>
<p>接下来，copy_process开始分配pid，设置tid，group_leader，并且建立进程之间的亲缘关系。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">    <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>children<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>sibling<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    p<span class="token operator">-&gt;</span>pid <span class="token operator">=</span> <span class="token function">pid_nr</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_THREAD<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        p<span class="token operator">-&gt;</span>exit_signal <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        p<span class="token operator">-&gt;</span>group_leader <span class="token operator">=</span> current<span class="token operator">-&gt;</span>group_leader<span class="token punctuation">;</span>
        p<span class="token operator">-&gt;</span>tgid <span class="token operator">=</span> current<span class="token operator">-&gt;</span>tgid<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_PARENT<span class="token punctuation">)</span>
            p<span class="token operator">-&gt;</span>exit_signal <span class="token operator">=</span> current<span class="token operator">-&gt;</span>group_leader<span class="token operator">-&gt;</span>exit_signal<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            p<span class="token operator">-&gt;</span>exit_signal <span class="token operator">=</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CSIGNAL<span class="token punctuation">)</span><span class="token punctuation">;</span>
        p<span class="token operator">-&gt;</span>group_leader <span class="token operator">=</span> p<span class="token punctuation">;</span>
        p<span class="token operator">-&gt;</span>tgid <span class="token operator">=</span> p<span class="token operator">-&gt;</span>pid<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span>CLONE_PARENT<span class="token operator">|</span>CLONE_THREAD<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        p<span class="token operator">-&gt;</span>real_parent <span class="token operator">=</span> current<span class="token operator">-&gt;</span>real_parent<span class="token punctuation">;</span>
        p<span class="token operator">-&gt;</span>parent_exec_id <span class="token operator">=</span> current<span class="token operator">-&gt;</span>parent_exec_id<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        p<span class="token operator">-&gt;</span>real_parent <span class="token operator">=</span> current<span class="token punctuation">;</span>
        p<span class="token operator">-&gt;</span>parent_exec_id <span class="token operator">=</span> current<span class="token operator">-&gt;</span>self_exec_id<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>好了，copy_process要结束了，上面图中的组件也初始化的差不多了。</p>
<h3 id="13-2-fork的第二件大事：唤醒新进程"><a href="#13-2-fork的第二件大事：唤醒新进程" class="headerlink" title="13.2 fork的第二件大事：唤醒新进程"></a>13.2 fork的第二件大事：唤醒新进程</h3><p>_do_fork做的第二件大事是wake_up_new_task。新任务刚刚建立，有没有机会抢占别人，获得CPU呢？</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">wake_up_new_task</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> rf<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    p<span class="token operator">-&gt;</span>state <span class="token operator">=</span> TASK_RUNNING<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">activate_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> p<span class="token punctuation">,</span> ENQUEUE_NOCLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>on_rq <span class="token operator">=</span> TASK_ON_RQ_QUEUED<span class="token punctuation">;</span>
    <span class="token function">trace_sched_wakeup_new</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">check_preempt_curr</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> p<span class="token punctuation">,</span> WF_FORK<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先，我们需要将进程的状态设置为TASK_RUNNING。</p>
<p>activate_task函数中会调用enqueue_task。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">enqueue_task</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    p<span class="token operator">-&gt;</span>sched_class<span class="token operator">-&gt;</span><span class="token function">enqueue_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> p<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果是CFS的调度类，则执行相应的enqueue_task_fair。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span>
<span class="token function">enqueue_task_fair</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se <span class="token operator">=</span> <span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>se<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    cfs_rq <span class="token operator">=</span> <span class="token function">cfs_rq_of</span><span class="token punctuation">(</span>se<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">enqueue_entity</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> se<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    cfs_rq<span class="token operator">-&gt;</span>h_nr_running<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在enqueue_task_fair中取出的队列就是cfs_rq，然后调用enqueue_entity。</p>
<p>在enqueue_entity函数里面，会调用update_curr，更新运行的统计量，然后调用__enqueue_entity，将sched_entity加入到红黑树里面，然后将se-&gt;on_rq = 1设置在队列上。</p>
<p>回到enqueue_task_fair后，将这个队列上运行的进程数目加一。然后，wake_up_new_task会调用check_preempt_curr，看是否能够抢占当前进程。</p>
<p>在check_preempt_curr中，会调用相应的调度类的rq-&gt;curr-&gt;sched_class-&gt;check_preempt_curr(rq, p, flags)。对于CFS调度类来讲，调用的是check_preempt_wakeup。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">check_preempt_wakeup</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> wake_flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>curr <span class="token operator">=</span> rq<span class="token operator">-&gt;</span>curr<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se <span class="token operator">=</span> <span class="token operator">&amp;</span>curr<span class="token operator">-&gt;</span>se<span class="token punctuation">,</span> <span class="token operator">*</span>pse <span class="token operator">=</span> <span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>se<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq <span class="token operator">=</span> <span class="token function">task_cfs_rq</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">test_tsk_need_resched</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">find_matching_se</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>se<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pse<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">update_curr</span><span class="token punctuation">(</span><span class="token function">cfs_rq_of</span><span class="token punctuation">(</span>se<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">wakeup_preempt_entity</span><span class="token punctuation">(</span>se<span class="token punctuation">,</span> pse<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">goto</span> preempt<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
preempt<span class="token operator">:</span>
    <span class="token function">resched_curr</span><span class="token punctuation">(</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在check_preempt_wakeup函数中，前面调用task_fork_fair的时候，设置sysctl_sched_child_runs_first了，已经将当前父进程的TIF_NEED_RESCHED设置了，则直接返回。</p>
<p>否则，check_preempt_wakeup还是会调用update_curr更新一次统计量，然后wakeup_preempt_entity将父进程和子进程PK一次，看是不是要抢占，如果要则调用resched_curr标记父进程为TIF_NEED_RESCHED。</p>
<p>如果新创建的进程应该抢占父进程，在什么时间抢占呢？别忘了fork是一个系统调用，从系统调用返回的时候，是抢占的一个好时机，如果父进程判断自己已经被设置为TIF_NEED_RESCHED，就让子进程先跑，抢占自己。</p>
<h3 id="13-3-总结"><a href="#13-3-总结" class="headerlink" title="13.3 总结"></a>13.3 总结</h3><p>fork系统调用的过程咱们就解析完了。它包含两个重要的事件，一个是将task_struct结构复制一份并且初始化，另一个是试图唤醒新创建的子进程。</p>
<p>这个过程我画了一张图，你可以对照着这张图回顾进程创建的过程。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/进程创建的过程.jpeg" alt="进程创建的过程"></p>
<p>这个图的上半部分是复制task_struct结构，你可以对照着右面的task_struct结构图，看这里面的成员是如何一部分一部分的被复制的。图的下半部分是唤醒新创建的子进程，如果条件满足，就会将当前进程设置应该被调度的标识位，就等着当前进程执行__schedule了。</p>
<h2 id="十四、线程的创建"><a href="#十四、线程的创建" class="headerlink" title="十四、线程的创建"></a>十四、线程的创建</h2><h3 id="14-1-用户态创建线程"><a href="#14-1-用户态创建线程" class="headerlink" title="14.1 用户态创建线程"></a>14.1 用户态创建线程</h3><p>无论是进程还是线程，在内核里面都是任务。</p>
<p>其实，线程不是一个完全由内核实现的机制，它是由内核态和用户态合作完成的。pthread_create不是一个系统调用，是Glibc库的一个函数，所以我们还要去Glibc里面去找线索。</p>
<p>在nptl/pthread_create.c里面可以找到这个函数：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">__pthread_create_2_1</span> <span class="token punctuation">(</span>pthread_t <span class="token operator">*</span>newthread<span class="token punctuation">,</span> <span class="token keyword">const</span> pthread_attr_t <span class="token operator">*</span>attr<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>start_routine<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span class="token function">versioned_symbol</span> <span class="token punctuation">(</span>libpthread<span class="token punctuation">,</span> __pthread_create_2_1<span class="token punctuation">,</span> pthread_create<span class="token punctuation">,</span> GLIBC_2_1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面我们依次来看这个函数做了些啥。</p>
<p>首先处理的是线程的属性参数。例如前面写程序的时候，我们设置的线程栈大小。如果没有传入线程属性，就取默认值。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">pthread_attr</span> <span class="token operator">*</span>iattr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pthread_attr</span> <span class="token operator">*</span><span class="token punctuation">)</span> attr<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">pthread_attr</span> default_attr<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>iattr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
iattr <span class="token operator">=</span> <span class="token operator">&amp;</span>default_attr<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来，就像在内核里一样，每一个进程或者线程都有一个task_struct结构，在用户态也有一个用于维护线程的结构，就是这个pthread结构。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">pthread</span> <span class="token operator">*</span>pd <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>凡是涉及函数的调用，都要使用到栈。每个线程也有自己的栈。那接下来就是创建线程栈了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> err <span class="token operator">=</span> <span class="token function">ALLOCATE_STACK</span> <span class="token punctuation">(</span>iattr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pd<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>ALLOCATE_STACK是一个宏，我们找到它的定义之后，发现它其实就是一个函数。只是，这个函数有些复杂，所以我这里把主要的代码列一下。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span> <span class="token expression"><span class="token function">ALLOCATE_STACK</span><span class="token punctuation">(</span>attr<span class="token punctuation">,</span> pd<span class="token punctuation">)</span> <span class="token function">allocate_stack</span> <span class="token punctuation">(</span>attr<span class="token punctuation">,</span> pd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>stackaddr<span class="token punctuation">)</span></span></span>


<span class="token keyword">static</span> <span class="token keyword">int</span>
<span class="token function">allocate_stack</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">pthread_attr</span> <span class="token operator">*</span>attr<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">pthread</span> <span class="token operator">*</span><span class="token operator">*</span>pdp<span class="token punctuation">,</span>
                ALLOCATE_STACK_PARMS<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">pthread</span> <span class="token operator">*</span>pd<span class="token punctuation">;</span>
  size_t size<span class="token punctuation">;</span>
  size_t pagesize_m1 <span class="token operator">=</span> <span class="token function">__getpagesize</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  size <span class="token operator">=</span> attr<span class="token operator">-&gt;</span>stacksize<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">/* Allocate some anonymous memory.  If possible use the cache.  */</span>
  size_t guardsize<span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token operator">*</span>mem<span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span> prot <span class="token operator">=</span> <span class="token punctuation">(</span>PROT_READ <span class="token operator">|</span> PROT_WRITE
                   <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">GL</span><span class="token punctuation">(</span>dl_stack_flags<span class="token punctuation">)</span> <span class="token operator">&amp;</span> PF_X<span class="token punctuation">)</span> <span class="token operator">?</span> PROT_EXEC <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* Adjust the stack size for alignment.  */</span>
  size <span class="token operator">&amp;=</span> <span class="token operator">~</span>__static_tls_align_m1<span class="token punctuation">;</span>
  <span class="token comment">/* Make sure the size of the stack is enough for the guard and
  eventually the thread descriptor.  */</span>
  guardsize <span class="token operator">=</span> <span class="token punctuation">(</span>attr<span class="token operator">-&gt;</span>guardsize <span class="token operator">+</span> pagesize_m1<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span>pagesize_m1<span class="token punctuation">;</span>
  size <span class="token operator">+=</span> guardsize<span class="token punctuation">;</span>
  pd <span class="token operator">=</span> <span class="token function">get_cached_stack</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>size<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mem<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>pd <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token comment">/* If a guard page is required, avoid committing memory by first
    allocate with PROT_NONE and then reserve with required permission
    excluding the guard page.  */</span>
    mem <span class="token operator">=</span> <span class="token function">__mmap</span> <span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token punctuation">(</span>guardsize <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> prot <span class="token operator">:</span> PROT_NONE<span class="token punctuation">,</span>
            MAP_PRIVATE <span class="token operator">|</span> MAP_ANONYMOUS <span class="token operator">|</span> MAP_STACK<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* Place the thread descriptor at the end of the stack.  */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">TLS_TCB_AT_TP</span></span>
    pd <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pthread</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> mem <span class="token operator">+</span> size<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">elif</span> <span class="token expression">TLS_DTV_AT_TP</span></span>
    pd <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pthread</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uintptr_t<span class="token punctuation">)</span> mem <span class="token operator">+</span> size <span class="token operator">-</span> __static_tls_size<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span>__static_tls_align_m1<span class="token punctuation">)</span> <span class="token operator">-</span> TLS_PRE_TCB_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token comment">/* Now mprotect the required region excluding the guard area. */</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>guard <span class="token operator">=</span> <span class="token function">guard_position</span> <span class="token punctuation">(</span>mem<span class="token punctuation">,</span> size<span class="token punctuation">,</span> guardsize<span class="token punctuation">,</span> pd<span class="token punctuation">,</span> pagesize_m1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setup_stack_prot</span> <span class="token punctuation">(</span>mem<span class="token punctuation">,</span> size<span class="token punctuation">,</span> guard<span class="token punctuation">,</span> guardsize<span class="token punctuation">,</span> prot<span class="token punctuation">)</span><span class="token punctuation">;</span>
    pd<span class="token operator">-&gt;</span>stackblock <span class="token operator">=</span> mem<span class="token punctuation">;</span>
    pd<span class="token operator">-&gt;</span>stackblock_size <span class="token operator">=</span> size<span class="token punctuation">;</span>
    pd<span class="token operator">-&gt;</span>guardsize <span class="token operator">=</span> guardsize<span class="token punctuation">;</span>
    pd<span class="token operator">-&gt;</span>specific<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> pd<span class="token operator">-&gt;</span>specific_1stblock<span class="token punctuation">;</span>
    <span class="token comment">/* And add to the list of stacks in use.  */</span>
    <span class="token function">stack_list_add</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>pd<span class="token operator">-&gt;</span>list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>stack_used<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token operator">*</span>pdp <span class="token operator">=</span> pd<span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token operator">*</span>stacktop<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">if</span> <span class="token expression">TLS_TCB_AT_TP</span></span>
  <span class="token comment">/* The stack begins before the TCB and the static TLS block.  */</span>
  stacktop <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>pd <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> __static_tls_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">elif</span> <span class="token expression">TLS_DTV_AT_TP</span></span>
  stacktop <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>pd <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">endif</span></span>
  <span class="token operator">*</span>stack <span class="token operator">=</span> stacktop<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们来看一下，allocate_stack主要做了以下这些事情：</p>
<ul>
<li>如果你在线程属性里面设置过栈的大小，需要你把设置的值拿出来；</li>
<li>为了防止栈的访问越界，在栈的末尾会有一块空间guardsize，一旦访问到这里就错误了；</li>
<li>其实线程栈是在进程的堆里面创建的。如果一个进程不断地创建和删除线程，我们不可能不断地去申请和清除线程栈使用的内存块，这样就需要有一个缓存。get_cached_stack就是根据计算出来的size大小，看一看已经有的缓存中，有没有已经能够满足条件的；</li>
<li>如果缓存里面没有，就需要调用<strong>mmap创建一块新的，系统调用那一节我们讲过，如果要在堆里面malloc一块内存，比较大的话，用</strong>mmap；</li>
<li>线程栈也是自顶向下生长的，还记得每个线程要有一个pthread结构，这个结构也是放在栈的空间里面的。在栈底的位置，其实是地址最高位；</li>
<li>计算出guard内存的位置，调用setup_stack_prot设置这块内存的是受保护的；</li>
<li>接下来，开始填充pthread这个结构里面的成员变量stackblock、stackblock_size、guardsize、specific。这里的specific是用于存放Thread Specific Data的，也即属于线程的全局变量；</li>
<li>将这个线程栈放到stack_used链表中，其实管理线程栈总共有两个链表，一个是stack_used，也就是这个栈正被使用；另一个是stack_cache，就是上面说的，一旦线程结束，先缓存起来，不释放，等有其他的线程创建的时候，给其他的线程用。</li>
</ul>
<p>搞定了用户态栈的问题，其实用户态的事情基本搞定了一半。</p>
<h3 id="14-2-内核态创建任务"><a href="#14-2-内核态创建任务" class="headerlink" title="14.2 内核态创建任务"></a>14.2 内核态创建任务</h3><p>接下来，我们接着pthread_create看。其实有了用户态的栈，接着需要解决的就是用户态的程序从哪里开始运行的问题。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">pd<span class="token operator">-&gt;</span>start_routine <span class="token operator">=</span> start_routine<span class="token punctuation">;</span>
pd<span class="token operator">-&gt;</span>arg <span class="token operator">=</span> arg<span class="token punctuation">;</span>
pd<span class="token operator">-&gt;</span>schedpolicy <span class="token operator">=</span> self<span class="token operator">-&gt;</span>schedpolicy<span class="token punctuation">;</span>
pd<span class="token operator">-&gt;</span>schedparam <span class="token operator">=</span> self<span class="token operator">-&gt;</span>schedparam<span class="token punctuation">;</span>
<span class="token comment">/* Pass the descriptor to the caller.  */</span>
<span class="token operator">*</span>newthread <span class="token operator">=</span> <span class="token punctuation">(</span>pthread_t<span class="token punctuation">)</span> pd<span class="token punctuation">;</span>
<span class="token function">atomic_increment</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>__nptl_nthreads<span class="token punctuation">)</span><span class="token punctuation">;</span>
retval <span class="token operator">=</span> <span class="token function">create_thread</span> <span class="token punctuation">(</span>pd<span class="token punctuation">,</span> iattr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>stopped_start<span class="token punctuation">,</span> STACK_VARIABLES_ARGS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>thread_ran<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>start_routine就是咱们给线程的函数，start_routine，start_routine的参数arg，以及调度策略都要赋值给pthread。</p>
<p>接下来__nptl_nthreads加一，说明有多了一个线程。</p>
<p>真正创建线程的是调用create_thread函数，这个函数定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span>
<span class="token function">create_thread</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pthread</span> <span class="token operator">*</span>pd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">pthread_attr</span> <span class="token operator">*</span>attr<span class="token punctuation">,</span>
bool <span class="token operator">*</span>stopped_start<span class="token punctuation">,</span> STACK_VARIABLES_PARMS<span class="token punctuation">,</span> bool <span class="token operator">*</span>thread_ran<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span> clone_flags <span class="token operator">=</span> <span class="token punctuation">(</span>CLONE_VM <span class="token operator">|</span> CLONE_FS <span class="token operator">|</span> CLONE_FILES <span class="token operator">|</span> CLONE_SYSVSEM <span class="token operator">|</span> CLONE_SIGHAND <span class="token operator">|</span> CLONE_THREAD <span class="token operator">|</span> CLONE_SETTLS <span class="token operator">|</span> CLONE_PARENT_SETTID <span class="token operator">|</span> CLONE_CHILD_CLEARTID <span class="token operator">|</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">ARCH_CLONE</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>start_thread<span class="token punctuation">,</span> STACK_VARIABLES_ARGS<span class="token punctuation">,</span> clone_flags<span class="token punctuation">,</span> pd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pd<span class="token operator">-&gt;</span>tid<span class="token punctuation">,</span> tp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pd<span class="token operator">-&gt;</span>tid<span class="token punctuation">)</span>；
  <span class="token comment">/* It's started now, so if we fail below, we'll have to cancel it
and let it clean itself up.  */</span>
  <span class="token operator">*</span>thread_ran <span class="token operator">=</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面有很长的clone_flags，这些咱们原来一直没注意，不过接下来的过程，我们要特别的关注一下这些标志位。</p>
<p>然后就是ARCH_CLONE，其实调用的是__clone。看到这里，你应该就有感觉了，马上就要到系统调用了。</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm"># define ARCH_CLONE __clone


/* The userland implementation is:
   int clone (int (*fn)(void *arg), void *child_stack, int flags, void *arg),
   the kernel entry is:
   int clone (long flags, void *child_stack).


   The parameters are passed in register and on the stack from userland:
   rdi: fn
   rsi: child_stack
   rdx: flags
   rcx: arg
   r8d: TID field in parent
   r9d: thread pointer
%esp+8: TID field in child


   The kernel expects:
   rax: system call number
   rdi: flags
   rsi: child_stack
   rdx: TID field in parent
   r10: TID field in child
   r8:  thread pointer  */

        .text
ENTRY (__clone)
        movq    $-EINVAL,%rax
......
        /* Insert the argument onto the new stack.  */
        subq    $16,%rsi
        movq    %rcx,8(%rsi)


        /* Save the function pointer.  It will be popped off in the
           child in the ebx frobbing below.  */
        movq    %rdi,0(%rsi)


        /* Do the system call.  */
        movq    %rdx, %rdi
        movq    %r8, %rdx
        movq    %r9, %r8
        mov     8(%rsp), %R10_LP
        movl    $SYS_ify(clone),%eax
......
        syscall
......
PSEUDO_END (__clone)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>能看到最后调用了syscall，这一点clone和我们原来熟悉的其他系统调用几乎是一致的。但是，也有少许不一样的地方。</p>
<p>如果在进程的主线程里面调用其他系统调用，当前用户态的栈是指向整个进程的栈，栈顶指针也是指向进程的栈，指令指针也是指向进程的主线程的代码。此时此刻执行到这里，调用clone的时候，用户态的栈、栈顶指针、指令指针和其他系统调用一样，都是指向主线程的。</p>
<p>但是对于线程来说，这些都要变。因为我们希望当clone这个系统调用成功的时候，除了内核里面有这个线程对应的task_struct，当系统调用返回到用户态的时候，用户态的栈应该是线程的栈，栈顶指针应该指向线程的栈，指令指针应该指向线程将要执行的那个函数。</p>
<p>所以这些都需要我们自己做，将线程要执行的函数的参数和指令的位置都压到栈里面，当从内核返回，从栈里弹出来的时候，就从这个函数开始，带着这些参数执行下去。</p>
<p>接下来我们就要进入内核了。内核里面对于clone系统调用的定义是这样的：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE5</span><span class="token punctuation">(</span>clone<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> clone_flags<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> newsp<span class="token punctuation">,</span>
         <span class="token keyword">int</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> parent_tidptr<span class="token punctuation">,</span>
         <span class="token keyword">int</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> child_tidptr<span class="token punctuation">,</span>
         <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> tls<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">_do_fork</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> newsp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> parent_tidptr<span class="token punctuation">,</span> child_tidptr<span class="token punctuation">,</span> tls<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>看到这里，发现了熟悉的面孔_do_fork。</p>
<p>第一个是上面 <strong>复杂的标志位设定</strong> ，我们来看都影响了什么。</p>
<p>对于copy_files，原来是调用dup_fd复制一个files_struct的，现在因为CLONE_FILES标识位变成将原来的files_struct引用计数加一。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">copy_files</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> clone_flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">files_struct</span> <span class="token operator">*</span>oldf<span class="token punctuation">,</span> <span class="token operator">*</span>newf<span class="token punctuation">;</span>
    oldf <span class="token operator">=</span> current<span class="token operator">-&gt;</span>files<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_FILES<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">atomic_inc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>oldf<span class="token operator">-&gt;</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> out<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    newf <span class="token operator">=</span> <span class="token function">dup_fd</span><span class="token punctuation">(</span>oldf<span class="token punctuation">,</span> <span class="token operator">&amp;</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
    tsk<span class="token operator">-&gt;</span>files <span class="token operator">=</span> newf<span class="token punctuation">;</span>
out<span class="token operator">:</span>
    <span class="token keyword">return</span> error<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于copy_fs，原来是调用copy_fs_struct复制一个fs_struct，现在因为CLONE_FS标识位变成将原来的fs_struct的用户数加一。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">copy_fs</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> clone_flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">fs_struct</span> <span class="token operator">*</span>fs <span class="token operator">=</span> current<span class="token operator">-&gt;</span>fs<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_FS<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        fs<span class="token operator">-&gt;</span>users<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    tsk<span class="token operator">-&gt;</span>fs <span class="token operator">=</span> <span class="token function">copy_fs_struct</span><span class="token punctuation">(</span>fs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于copy_sighand，原来是创建一个新的sighand_struct，现在因为CLONE_SIGHAND标识位变成将原来的sighand_struct引用计数加一。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">copy_sighand</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> clone_flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">sighand_struct</span> <span class="token operator">*</span>sig<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_SIGHAND<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">atomic_inc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>current<span class="token operator">-&gt;</span>sighand<span class="token operator">-&gt;</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    sig <span class="token operator">=</span> <span class="token function">kmem_cache_alloc</span><span class="token punctuation">(</span>sighand_cachep<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">atomic_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sig<span class="token operator">-&gt;</span>count<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">memcpy</span><span class="token punctuation">(</span>sig<span class="token operator">-&gt;</span>action<span class="token punctuation">,</span> current<span class="token operator">-&gt;</span>sighand<span class="token operator">-&gt;</span>action<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sig<span class="token operator">-&gt;</span>action<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于copy_signal，原来是创建一个新的signal_struct，现在因为CLONE_THREAD直接返回了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">copy_signal</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> clone_flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">signal_struct</span> <span class="token operator">*</span>sig<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_THREAD<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    sig <span class="token operator">=</span> <span class="token function">kmem_cache_zalloc</span><span class="token punctuation">(</span>signal_cachep<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    tsk<span class="token operator">-&gt;</span>signal <span class="token operator">=</span> sig<span class="token punctuation">;</span>
    <span class="token function">init_sigpending</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sig<span class="token operator">-&gt;</span>shared_pending<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于copy_mm，原来是调用dup_mm复制一个mm_struct，现在因为CLONE_VM标识位而直接指向了原来的mm_struct</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">copy_mm</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> clone_flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>mm<span class="token punctuation">,</span> <span class="token operator">*</span>oldmm<span class="token punctuation">;</span>
    oldmm <span class="token operator">=</span> current<span class="token operator">-&gt;</span>mm<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_VM<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">mmget</span><span class="token punctuation">(</span>oldmm<span class="token punctuation">)</span><span class="token punctuation">;</span>
        mm <span class="token operator">=</span> oldmm<span class="token punctuation">;</span>
        <span class="token keyword">goto</span> good_mm<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    mm <span class="token operator">=</span> <span class="token function">dup_mm</span><span class="token punctuation">(</span>tsk<span class="token punctuation">)</span><span class="token punctuation">;</span>
good_mm<span class="token operator">:</span>
    tsk<span class="token operator">-&gt;</span>mm <span class="token operator">=</span> mm<span class="token punctuation">;</span>
    tsk<span class="token operator">-&gt;</span>active_mm <span class="token operator">=</span> mm<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>第二个就是 <strong>对于亲缘关系的影响</strong> ，毕竟我们要识别多个线程是不是属于一个进程。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">p<span class="token operator">-&gt;</span>pid <span class="token operator">=</span> <span class="token function">pid_nr</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_THREAD<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    p<span class="token operator">-&gt;</span>exit_signal <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>group_leader <span class="token operator">=</span> current<span class="token operator">-&gt;</span>group_leader<span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>tgid <span class="token operator">=</span> current<span class="token operator">-&gt;</span>tgid<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_PARENT<span class="token punctuation">)</span>
        p<span class="token operator">-&gt;</span>exit_signal <span class="token operator">=</span> current<span class="token operator">-&gt;</span>group_leader<span class="token operator">-&gt;</span>exit_signal<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        p<span class="token operator">-&gt;</span>exit_signal <span class="token operator">=</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CSIGNAL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>group_leader <span class="token operator">=</span> p<span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>tgid <span class="token operator">=</span> p<span class="token operator">-&gt;</span>pid<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
    <span class="token comment">/* CLONE_PARENT re-uses the old parent */</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span>CLONE_PARENT<span class="token operator">|</span>CLONE_THREAD<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    p<span class="token operator">-&gt;</span>real_parent <span class="token operator">=</span> current<span class="token operator">-&gt;</span>real_parent<span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>parent_exec_id <span class="token operator">=</span> current<span class="token operator">-&gt;</span>parent_exec_id<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    p<span class="token operator">-&gt;</span>real_parent <span class="token operator">=</span> current<span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>parent_exec_id <span class="token operator">=</span> current<span class="token operator">-&gt;</span>self_exec_id<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从上面的代码可以看出，使用了CLONE_THREAD标识位之后，使得亲缘关系有了一定的变化。</p>
<ul>
<li>如果是新进程，那这个进程的group_leader就是他自己，tgid是它自己的pid，这就完全重打锣鼓另开张了，自己是线程组的头。如果是新线程，group_leader是当前进程的，group_leader，tgid是当前进程的tgid，也就是当前进程的pid，这个时候还是拜原来进程为老大。</li>
<li>如果是新进程，新进程的real_parent是当前的进程，在进程树里面又见一辈人；如果是新线程，线程的real_parent是当前的进程的real_parent，其实是平辈的。</li>
</ul>
<p>第三， <strong>对于信号的处理</strong> ，如何保证发给进程的信号虽然可以被一个线程处理，但是影响范围应该是整个进程的。例如，kill一个进程，则所有线程都要被干掉。如果一个信号是发给一个线程的pthread_kill，则应该只有线程能够收到。</p>
<p>在copy_process的主流程里面，无论是创建进程还是线程，都会初始化struct sigpending pending，也就是每个task_struct，都会有这样一个成员变量。这就是一个信号列表。如果这个task_struct是一个线程，这里面的信号就是发给这个线程的；如果这个task_struct是一个进程，这里面的信号是发给主线程的。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">init_sigpending</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>pending<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>另外，上面copy_signal的时候，我们可以看到，在创建进程的过程中，会初始化signal_struct里面的struct sigpending shared_pending。但是，在创建线程的过程中，连signal_struct都共享了。也就是说，整个进程里的所有线程共享一个shared_pending，这也是一个信号列表，是发给整个进程的，哪个线程处理都一样。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">init_sigpending</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sig<span class="token operator">-&gt;</span>shared_pending<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>至此，clone在内核的调用完毕，要返回系统调用，回到用户态。</p>
<h3 id="14-3-用户态执行线程"><a href="#14-3-用户态执行线程" class="headerlink" title="14.3 用户态执行线程"></a>14.3 用户态执行线程</h3><p>根据__clone的第一个参数，回到用户态也不是直接运行我们指定的那个函数，而是一个通用的start_thread，这是所有线程在用户态的统一入口。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">START_THREAD_DEFN </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>noreturn<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">start_thread</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span></span></span>


START_THREAD_DEFN
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">pthread</span> <span class="token operator">*</span>pd <span class="token operator">=</span> START_THREAD_SELF<span class="token punctuation">;</span>
    <span class="token comment">/* Run the code the user provided.  */</span>
    <span class="token function">THREAD_SETMEM</span> <span class="token punctuation">(</span>pd<span class="token punctuation">,</span> result<span class="token punctuation">,</span> pd<span class="token operator">-&gt;</span><span class="token function">start_routine</span> <span class="token punctuation">(</span>pd<span class="token operator">-&gt;</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* Call destructors for the thread_local TLS variables.  */</span>
    <span class="token comment">/* Run the destructor for the thread-local data.  */</span>
    <span class="token function">__nptl_deallocate_tsd</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__glibc_unlikely</span> <span class="token punctuation">(</span><span class="token function">atomic_decrement_and_test</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>__nptl_nthreads<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment">/* This was the last thread.  */</span>
        <span class="token function">exit</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">__free_tcb</span> <span class="token punctuation">(</span>pd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">__exit_thread</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在start_thread入口函数中，才真正的调用用户提供的函数，在用户的函数执行完毕之后，会释放这个线程相关的数据。例如，线程本地数据thread_local variables，线程数目也减一。如果这是最后一个线程了，就直接退出进程，另外__free_tcb用于释放pthread。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span>
internal_function
<span class="token function">__free_tcb</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pthread</span> <span class="token operator">*</span>pd<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token function">__deallocate_stack</span> <span class="token punctuation">(</span>pd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">void</span>
internal_function
<span class="token function">__deallocate_stack</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pthread</span> <span class="token operator">*</span>pd<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment">/* Remove the thread from the list of threads with user defined
     stacks.  */</span>
  <span class="token function">stack_list_del</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>pd<span class="token operator">-&gt;</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* Not much to do.  Just free the mmap()ed memory.  Note that we do
     not reset the 'used' flag in the 'tid' field.  This is done by
     the kernel.  If no thread has been created yet this field is
     still zero.  */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__glibc_likely</span> <span class="token punctuation">(</span><span class="token operator">!</span> pd<span class="token operator">-&gt;</span>user_stack<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token function">queue_stack</span> <span class="token punctuation">(</span>pd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>free_tcb会调用</strong>deallocate_stack来释放整个线程栈，这个线程栈要从当前使用线程栈的列表stack_used中拿下来，放到缓存的线程栈列表stack_cache中。</p>
<p>好了，整个线程的生命周期到这里就结束了。</p>
<h3 id="14-4-总结"><a href="#14-4-总结" class="headerlink" title="14.4 总结"></a>14.4 总结</h3><p>线程的调用过程解析完毕了，我画了一个图总结一下。这个图对比了创建进程和创建线程在用户态和内核态的不同。</p>
<p>创建进程的话，调用的系统调用是fork，在copy_process函数里面，会将五大结构files_struct、fs_struct、sighand_struct、signal_struct、mm_struct都复制一遍，从此父进程和子进程各用各的数据结构。而创建线程的话，调用的是系统调用clone，在copy_process函数里面， 五大结构仅仅是引用计数加一，也即线程共享进程的数据结构。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/创建进程和创建线程过程对比.jpeg" alt="创建进程和创建线程过程对比"></p>
<h2 id="十五、内存管理（上）"><a href="#十五、内存管理（上）" class="headerlink" title="十五、内存管理（上）"></a>十五、内存管理（上）</h2><p>平时我们说计算机的“计算”两个字，其实说的就是两方面，第一，进程和线程对于CPU的使用；第二，对于内存的管理。</p>
<h3 id="15-1-独享内存空间的原理"><a href="#15-1-独享内存空间的原理" class="headerlink" title="15.1 独享内存空间的原理"></a>15.1 独享内存空间的原理</h3><p>内存都被分成一块一块儿的，都编好了号。</p>
<p>操作系统会给进程分配一个虚拟地址。所有进程看到的这个地址都是一样的，里面的内存都是从0开始编号。</p>
<p>在程序里面，指令写入的地址是虚拟地址。例如，位置为10M的内存区域，操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。</p>
<p>当程序要访问虚拟地址的时候，由内核的数据结构进行转换，转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。</p>
<h3 id="15-2-规划虚拟地址空间"><a href="#15-2-规划虚拟地址空间" class="headerlink" title="15.2 规划虚拟地址空间"></a>15.2 规划虚拟地址空间</h3><p>操作系统的内存管理，主要分为三个方面。</p>
<ul>
<li>第一，物理内存的管理；</li>
<li>第二，虚拟地址的管理；</li>
<li>第三，虚拟地址和物理地址如何映射。</li>
</ul>
<p>接下来，我们都会围绕虚拟地址和物理地址展开。这两个概念有点绕，很多时候你可能会犯糊涂：这个地方，我们用的是虚拟地址呢，还是物理地址呢？所以，请你在学习这一章节的时候，时刻问自己这个问题。</p>
<p>一个程序：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token keyword">int</span> max_length <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span>

<span class="token keyword">char</span> <span class="token operator">*</span> <span class="token function">generate</span><span class="token punctuation">(</span><span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">int</span> i<span class="token punctuation">;</span>
  <span class="token keyword">char</span> <span class="token operator">*</span> buffer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span> <span class="token punctuation">(</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>buffer <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    buffer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">26</span><span class="token operator">+</span><span class="token string">'a'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  buffer<span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'\0'</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> buffer<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> num<span class="token punctuation">;</span>
  <span class="token keyword">char</span> <span class="token operator">*</span> buffer<span class="token punctuation">;</span>

  <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"Input the string length : "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">scanf</span> <span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span><span class="token punctuation">(</span>num <span class="token operator">&gt;</span> max_length<span class="token punctuation">)</span><span class="token punctuation">{</span>
    num <span class="token operator">=</span> max_length<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  buffer <span class="token operator">=</span> <span class="token function">generate</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"Random string is: %s\n"</span><span class="token punctuation">,</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">free</span> <span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个程序比较简单，就是根据用户输入的整数来生成字符串，最长是128。由于字符串的长度不是固定的，因而不能提前知道，需要动态地分配内存，使用malloc函数。当然用完了需要释放内存，这就要使用free函数。</p>
<p>我们来总结一下，这个简单的程序使用哪些内存的几种方式：</p>
<ul>
<li>代码需要放在内存里面；</li>
<li>全局变量，例如max_length；</li>
<li>常量字符串”Input the string length : “；</li>
<li>函数栈，例如局部变量num是作为参数传给generate函数的，这里面涉及了函数调用，局部变量，函数参数等都是保存在函数栈上面的；</li>
<li>堆，malloc分配的内存在堆里面；</li>
<li>这里面涉及对glibc的调用，所以glibc的代码是以so文件的形式存在的，也需要放在内存里面。</li>
</ul>
<p>这就完了吗？还没有呢，别忘了malloc会调用系统调用，进入内核，所以这个程序一旦运行起来，内核部分还需要分配内存：</p>
<ul>
<li>内核的代码要在内存里面；</li>
<li>内核中也有全局变量；</li>
<li>每个进程都要有一个task_struct；</li>
<li>每个进程还有一个内核栈；</li>
<li>在内核里面也有动态分配的内存；</li>
<li>虚拟地址到物理地址的映射表放在哪里？</li>
</ul>
<p>对于内存的访问，用户态的进程使用虚拟地址，这点毫无疑问，内核态的也基本都是使用虚拟地址，只有最后一项容易让人产生疑问。虚拟地址到物理地址的映射表，这个感觉起来是内存管理模块的一部分，这个是“实”是“虚”呢？这个问题先保留，我们暂不讨论，放到内存映射那一节见分晓。</p>
<p>既然都是虚拟地址，我们就先不管映射到物理地址以后是如何布局的，反正现在至少从“虚”的角度来看，这一大片连续的内存空间都是我的了。</p>
<p>首先，这么大的虚拟空间一切二，一部分用来放内核的东西，称为 <strong>内核空间</strong> ，一部分用来放进程的东西，称为 <strong>用户空间</strong> 。用户空间在下，在低地址，内核空间在上，在高地址。这两部分空间的分界线因为32位和64位的不同而不同。</p>
<p>对于普通进程来说，内核空间的那部分虽然虚拟地址在那里，但是不能访问。</p>
<p>我们从最低位开始排起，先是 <strong>Text Segment</strong> 、 <strong>Data Segment</strong> 和 <strong>BSS Segment</strong> 。Text Segment是存放二进制可执行代码的位置，Data Segment存放静态常量，BSS Segment存放未初始化的静态变量。是不是觉得这几个名字很熟悉？没错，咱们前面讲ELF格式的时候提到过，在二进制执行文件里面，就有这三个部分。这里就是把二进制执行文件的三个部分加载到内存里面。</p>
<p>接下来是 <strong>堆（Heap）段</strong> 。堆是往高地址增长的，是用来动态分配内存的区域，malloc就是在这里面分配的。</p>
<p>接下来的区域是 <strong>Memory Mapping Segment</strong> 。这块地址可以用来把文件映射进内存用的，如果二进制的执行文件依赖于某个动态链接库，就是在这个区域里面将so文件映射到了内存中。</p>
<p>再下面就是 <strong>栈（Stack）地址段</strong> 。主线程的函数调用的函数栈就是用这里的。</p>
<p>如果需要进行更高权限的工作，就需要调用系统调用，进入内核。</p>
<p>到了内核里面，无论是从哪个进程进来的，看到的都是同一个内核空间，看到的都是同一个进程列表。虽然内核栈是各用个的，但是如果想知道的话，还是能够知道每个进程的内核栈在哪里的。所以，如果要访问一些公共的数据结构，需要进行锁保护。</p>
<p>内核的代码访问内核的数据结构，大部分的情况下都是使用虚拟地址的，虽然内核代码权限很大，但是能够使用的虚拟地址范围也只能在内核空间，也即内核代码访问内核数据结构（不能访问用户空间）。</p>
<p>在内核里面也会有内核的代码，同样有Text Segment、Data Segment和BSS Segment，别忘了咱们讲内核启动的时候，内核代码也是ELF格式的。</p>
<h2 id="十六、内存管理（下）"><a href="#十六、内存管理（下）" class="headerlink" title="十六、内存管理（下）"></a>十六、内存管理（下）</h2><p>接下来，我们需要知道，如何将其映射成为物理地址呢？</p>
<p>你可能已经想到了，咱们前面讲x86 CPU的时候，讲过分段机制，咱们规划虚拟空间的时候，也是将空间分成多个段进行保存。</p>
<p>那就直接用分段机制呗。我们来看看分段机制的原理。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/分段机制的原理.jpg" alt="分段机制的原理"></p>
<p>分段机制下的虚拟地址由两部分组成， <strong>段选择子</strong> 和 <strong>段内偏移量</strong> 。段选择子就保存在咱们前面讲过的段寄存器里面。段选择子里面最重要的是段号，用作段表的索引。段表里面保存的是这个段的 <strong>基地址</strong> 、 <strong>段的界限</strong> 和 <strong>特权等级</strong> 等。虚拟地址中的段内偏移量应该位于0和段界限之间。如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。</p>
<p>我们来看看Linux是如何使用这个机制的。</p>
<p>在Linux里面，段表全称 <strong>段描述符表（segment descriptors）</strong> ，放在 <strong>全局描述符表GDT（Global Descriptor Table）</strong> 里面，会有下面的宏来初始化段描述符表里面的表项。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">GDT_ENTRY_INIT</span><span class="token punctuation">(</span>flags<span class="token punctuation">,</span> base<span class="token punctuation">,</span> limit<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">{</span> <span class="token punctuation">{</span> </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>limit<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xffff</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>base<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xffff</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>base<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff0000</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xf0ff</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> </span><span class="token punctuation">\</span>
            <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span>limit<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xf0000</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>base<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff000000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一个段表项由段基地址base、段界限limit，还有一些标识符组成。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">DEFINE_PER_CPU_PAGE_ALIGNED</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">gdt_page</span><span class="token punctuation">,</span> gdt_page<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span>gdt <span class="token operator">=</span> <span class="token punctuation">{</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_X86_64</span></span>
    <span class="token punctuation">[</span>GDT_ENTRY_KERNEL32_CS<span class="token punctuation">]</span>         <span class="token operator">=</span> <span class="token function">GDT_ENTRY_INIT</span><span class="token punctuation">(</span><span class="token number">0xc09b</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0xfffff</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>GDT_ENTRY_KERNEL_CS<span class="token punctuation">]</span>           <span class="token operator">=</span> <span class="token function">GDT_ENTRY_INIT</span><span class="token punctuation">(</span><span class="token number">0xa09b</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0xfffff</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>GDT_ENTRY_KERNEL_DS<span class="token punctuation">]</span>           <span class="token operator">=</span> <span class="token function">GDT_ENTRY_INIT</span><span class="token punctuation">(</span><span class="token number">0xc093</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0xfffff</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>GDT_ENTRY_DEFAULT_USER32_CS<span class="token punctuation">]</span>   <span class="token operator">=</span> <span class="token function">GDT_ENTRY_INIT</span><span class="token punctuation">(</span><span class="token number">0xc0fb</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0xfffff</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>GDT_ENTRY_DEFAULT_USER_DS<span class="token punctuation">]</span>     <span class="token operator">=</span> <span class="token function">GDT_ENTRY_INIT</span><span class="token punctuation">(</span><span class="token number">0xc0f3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0xfffff</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>GDT_ENTRY_DEFAULT_USER_CS<span class="token punctuation">]</span>     <span class="token operator">=</span> <span class="token function">GDT_ENTRY_INIT</span><span class="token punctuation">(</span><span class="token number">0xa0fb</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0xfffff</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
    <span class="token punctuation">[</span>GDT_ENTRY_KERNEL_CS<span class="token punctuation">]</span>           <span class="token operator">=</span> <span class="token function">GDT_ENTRY_INIT</span><span class="token punctuation">(</span><span class="token number">0xc09a</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0xfffff</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>GDT_ENTRY_KERNEL_DS<span class="token punctuation">]</span>           <span class="token operator">=</span> <span class="token function">GDT_ENTRY_INIT</span><span class="token punctuation">(</span><span class="token number">0xc092</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0xfffff</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>GDT_ENTRY_DEFAULT_USER_CS<span class="token punctuation">]</span>     <span class="token operator">=</span> <span class="token function">GDT_ENTRY_INIT</span><span class="token punctuation">(</span><span class="token number">0xc0fa</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0xfffff</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>GDT_ENTRY_DEFAULT_USER_DS<span class="token punctuation">]</span>     <span class="token operator">=</span> <span class="token function">GDT_ENTRY_INIT</span><span class="token punctuation">(</span><span class="token number">0xc0f2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0xfffff</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">EXPORT_PER_CPU_SYMBOL_GPL</span><span class="token punctuation">(</span>gdt_page<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面对于64位的和32位的，都定义了内核代码段、内核数据段、用户代码段和用户数据段。</p>
<p>另外，还会定义下面四个段选择子，指向上面的段描述符表项。这四个段选择子看着是不是有点眼熟？咱们讲内核初始化的时候，启动第一个用户态的进程，就是将这四个值赋值给段寄存器。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">__KERNEL_CS</span>         <span class="token punctuation">(</span>GDT_ENTRY_KERNEL_CS<span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">__KERNEL_DS</span>         <span class="token punctuation">(</span>GDT_ENTRY_KERNEL_DS<span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">__USER_DS</span>           <span class="token punctuation">(</span>GDT_ENTRY_DEFAULT_USER_DS<span class="token operator">*</span><span class="token number">8</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">__USER_CS</span>           <span class="token punctuation">(</span>GDT_ENTRY_DEFAULT_USER_CS<span class="token operator">*</span><span class="token number">8</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过分析，我们发现，所有的段的起始地址都是一样的，都是0。这算哪门子分段嘛！所以，在Linux操作系统中，并没有使用到全部的分段功能。那分段是不是完全没有用处呢？分段可以做权限审核，例如用户态DPL是3，内核态DPL是0。当用户态试图访问内核态的时候，会因为权限不足而报错。</p>
<p>其实Linux倾向于另外一种从虚拟地址到物理地址的转换方式，称为 <strong>分页（Paging）</strong> 。</p>
<p>对于物理内存，操作系统把它分成一块一块大小相同的页，这样更方便管理，例如有的内存页面长时间不用了，可以暂时写到硬盘上，称为 <strong>换出</strong> 。一旦需要的时候，再加载进来，叫作 <strong>换入</strong> 。这样可以扩大可用物理内存的大小，提高物理内存的利用率。</p>
<p>这个换入和换出都是以页为单位的。页面的大小一般为4KB。为了能够定位和访问每个页，需要有个页表，保存每个页的起始地址，再加上在页内的偏移量，组成线性地址，就能对于内存中的每个位置进行访问了。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/分页机制的原理.jpg" alt="分页机制的原理"></p>
<p>32位环境下，虚拟地址空间共4GB。如果分成4KB一个页，那就是1M个页。每个页表项需要4个字节来存储，那么整个4GB空间的映射就需要4MB的内存来存储映射表。如果每个进程都有自己的映射表，100个进程就需要400MB的内存。对于内核来讲，有点大了 。</p>
<p>页表中所有页表项必须提前建好，并且要求是连续的。如果不连续，就没有办法通过虚拟地址里面的页号找到对应的页表项了。</p>
<p>那怎么办呢？我们可以试着将页表再分页，4G的空间需要4M的页表来存储映射。我们把这4M分成1K（1024）个4K，每个4K又能放在一页里面，这样1K个4K就是1K个页，这1K个页也需要一个表进行管理，我们称为页目录表，这个页目录表里面有1K项，每项4个字节，页目录表大小也是4K。</p>
<p>页目录有1K项，用10位就可以表示访问页目录的哪一项。这一项其实对应的是一整页的页表项，也即4K的页表项。每个页表项也是4个字节，因而一整页的页表项是1K个。再用10位就可以表示访问页表项的哪一项，页表项中的一项对应的就是一个页，是存放数据的页，这个页的大小是4K，用12位可以定位这个页内的任何一个位置。</p>
<p>这样加起来正好32位，也就是用前10位定位到页目录表中的一项。将这一项对应的页表取出来共1k项，再用中间10位定位到页表中的一项，将这一项对应的存放数据的页取出来，再用最后12位定位到页中的具体位置访问数据。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/两级分页.jpg" alt="两级分页"></p>
<p>比如说，上面图中，我们假设只给这个进程分配了一个数据页。如果只使用页表，也需要完整的1M个页表项共4M的内存，但是如果使用了页目录，页目录需要1K个全部分配，占用内存4K，但是里面只有一项使用了。到了页表项，只需要分配能够管理那个数据页的页表项页就可以了，也就是说，最多4K，这样内存就节省多了。</p>
<p>当然对于64位的系统，两级肯定不够了，就变成了四级目录，分别是全局页目录项PGD（Page Global Directory）、上层页目录项PUD（Page Upper Directory）、中间页目录项PMD（Page Middle Directory）和页表项PTE（Page Table Entry）。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/四级分页.jpg" alt="四级分页"></p>
<h2 id="十七、进程空间管理"><a href="#十七、进程空间管理" class="headerlink" title="十七、进程空间管理"></a>十七、进程空间管理</h2><p>来详细看看进程的虚拟内存空间是如何管理的。</p>
<p>32位系统和64位系统的内存布局有的地方相似，有的地方差别比较大。</p>
<h3 id="17-1-用户态和内核态的划分"><a href="#17-1-用户态和内核态的划分" class="headerlink" title="17.1 用户态和内核态的划分"></a>17.1 用户态和内核态的划分</h3><p>task_struct里面有一个struct mm_struct结构来管理内存。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">mm_struct</span>        <span class="token operator">*</span>mm<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在struct mm_struct里面，有这样一个成员变量：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">long</span> task_size<span class="token punctuation">;</span>        <span class="token comment">/* size of task vm space */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>我们之前讲过，整个虚拟内存空间要一分为二，一部分是用户态地址空间，一部分是内核态地址空间，那这两部分的分界线在哪里呢？这就要task_size来定义。</p>
<p>对于32位的系统，内核里面是这样定义TASK_SIZE的：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_X86_32</span></span>
<span class="token comment">/*
 * User space process size: 3GB (default).
 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">TASK_SIZE           PAGE_OFFSET</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">TASK_SIZE_MAX       TASK_SIZE</span></span>
<span class="token comment">/*
config PAGE_OFFSET
        hex
        default 0xC0000000
        depends on X86_32
*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
<span class="token comment">/*
 * User space process size. 47bits minus one guard page.
*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">TASK_SIZE_MAX</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1UL</span> <span class="token operator">&lt;&lt;</span> <span class="token number">47</span><span class="token punctuation">)</span> <span class="token operator">-</span> PAGE_SIZE<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">TASK_SIZE</span>       <span class="token punctuation">(</span><span class="token function">test_thread_flag</span><span class="token punctuation">(</span>TIF_ADDR32<span class="token punctuation">)</span> <span class="token operator">?</span> </span><span class="token punctuation">\</span>
                            <span class="token expression">IA32_PAGE_OFFSET <span class="token operator">:</span> TASK_SIZE_MAX<span class="token punctuation">)</span></span></span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当执行一个新的进程的时候，会做以下的设置：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">current<span class="token operator">-&gt;</span>mm<span class="token operator">-&gt;</span>task_size <span class="token operator">=</span> TASK_SIZE<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>对于32位系统，最大能够寻址2^32=4G，其中用户态虚拟地址空间是3G，内核态是1G。</p>
<p>对于64位系统，虚拟地址只使用了48位。就像代码里面写的一样，1左移了47位，就相当于48位地址空间一半的位置，0x0000800000000000，然后减去一个页，就是0x00007FFFFFFFF000，共128T。同样，内核空间也是128T。内核空间和用户空间之间隔着很大的空隙，以此来进行隔离。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/用户态和内核态的划分.jpg" alt="用户态和内核态的划分"></p>
<h3 id="17-2-用户态布局"><a href="#17-2-用户态布局" class="headerlink" title="17.2 用户态布局"></a>17.2 用户态布局</h3><p>之前我们讲了用户态虚拟空间里面有几类数据，例如代码、全局变量、堆、栈、内存映射区等。在struct mm_struct里面，有下面这些变量定义了这些区域的统计信息和位置。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">long</span> mmap_base<span class="token punctuation">;</span>    <span class="token comment">/* base of mmap area */</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> total_vm<span class="token punctuation">;</span>     <span class="token comment">/* Total pages mapped */</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> locked_vm<span class="token punctuation">;</span>    <span class="token comment">/* Pages that have PG_mlocked set */</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> pinned_vm<span class="token punctuation">;</span>    <span class="token comment">/* Refcount permanently increased */</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> data_vm<span class="token punctuation">;</span>      <span class="token comment">/* VM_WRITE &amp; ~VM_SHARED &amp; ~VM_STACK */</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> exec_vm<span class="token punctuation">;</span>      <span class="token comment">/* VM_EXEC &amp; ~VM_WRITE &amp; ~VM_STACK */</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> stack_vm<span class="token punctuation">;</span>     <span class="token comment">/* VM_STACK */</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> start_code<span class="token punctuation">,</span> end_code<span class="token punctuation">,</span> start_data<span class="token punctuation">,</span> end_data<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> start_brk<span class="token punctuation">,</span> brk<span class="token punctuation">,</span> start_stack<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> arg_start<span class="token punctuation">,</span> arg_end<span class="token punctuation">,</span> env_start<span class="token punctuation">,</span> env_end<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，total_vm是总共映射的页的数目。我们知道，这么大的虚拟地址空间，不可能都有真实内存对应，所以这里是映射的数目。当内存吃紧的时候，有些页可以换出到硬盘上，有的页因为比较重要，不能换出。locked_vm就是被锁定不能换出，pinned_vm是不能换出，也不能移动。</p>
<p>data_vm是存放数据的页的数目，exec_vm是存放可执行文件的页的数目，stack_vm是栈所占的页的数目。</p>
<p>start_code和end_code表示可执行代码的开始和结束位置，start_data和end_data表示已初始化数据的开始位置和结束位置。</p>
<p>start_brk是堆的起始位置，brk是堆当前的结束位置。前面咱们讲过malloc申请一小块内存的话，就是通过改变brk位置实现的。</p>
<p>start_stack是栈的起始位置，栈的结束位置在寄存器的栈顶指针中。</p>
<p>arg_start和arg_end是参数列表的位置， env_start和env_end是环境变量的位置。它们都位于栈中最高地址的地方。</p>
<p>mmap_base表示虚拟地址空间中用于内存映射的起始地址。一般情况下，这个空间是从高地址到低地址增长的。前面咱们讲malloc申请一大块内存的时候，就是通过mmap在这里映射一块区域到物理内存。咱们加载动态链接库so文件，也是在这个区域里面，映射一块区域到so文件。</p>
<p>这下所有用户态的区域的位置基本上都描述清楚了。整个布局就像下面这张图这样。虽然32位和64位的空间相差很大，但是区域的类别和布局是相似的。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/用户态内存布局.jpg" alt="用户态内存布局"></p>
<p>除了位置信息之外，struct mm_struct里面还专门有一个结构vm_area_struct，来描述这些区域的属性。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span>mmap<span class="token punctuation">;</span>        <span class="token comment">/* list of VMAs */</span>
<span class="token keyword">struct</span> <span class="token class-name">rb_root</span> mm_rb<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这里面一个是单链表，用于将这些区域串起来。另外还有一个红黑树。又是这个数据结构，在进程调度的时候我们用的也是红黑树。它的好处就是查找和修改都很快。这里用红黑树，就是为了快速查找一个内存区域，并在需要改变的时候，能够快速修改。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token punctuation">{</span>
    <span class="token comment">/* The first cache line has the info for VMA tree walking. */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> vm_start<span class="token punctuation">;</span>     <span class="token comment">/* Our start address within vm_mm. */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> vm_end<span class="token punctuation">;</span>       <span class="token comment">/* The first byte after our end address within vm_mm. */</span>
    <span class="token comment">/* linked list of VM areas per task, sorted by address */</span>
    <span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span>vm_next<span class="token punctuation">,</span> <span class="token operator">*</span>vm_prev<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> vm_rb<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>vm_mm<span class="token punctuation">;</span>    <span class="token comment">/* The address space we belong to. */</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> anon_vma_chain<span class="token punctuation">;</span> <span class="token comment">/* Serialized by mmap_sem &amp;
                      * page_table_lock */</span>
    <span class="token keyword">struct</span> <span class="token class-name">anon_vma</span> <span class="token operator">*</span>anon_vma<span class="token punctuation">;</span>  <span class="token comment">/* Serialized by page_table_lock */</span>
    <span class="token comment">/* Function pointers to deal with this struct. */</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">vm_operations_struct</span> <span class="token operator">*</span>vm_ops<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span> vm_file<span class="token punctuation">;</span>      <span class="token comment">/* File we map to (can be NULL). */</span>
    <span class="token keyword">void</span> <span class="token operator">*</span> vm_private_data<span class="token punctuation">;</span>     <span class="token comment">/* was vm_pte (shared mem) */</span>
<span class="token punctuation">}</span> __randomize_layout<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>vm_start和vm_end指定了该区域在用户空间中的起始和结束地址。vm_next和vm_prev将这个区域串在链表上。vm_rb将这个区域放在红黑树上。vm_ops里面是对这个内存区域可以做的操作的定义。</p>
<p>虚拟内存区域可以映射到物理内存，也可以映射到文件，映射到物理内存的时候称为匿名映射，anon_vma中，anoy就是anonymous，匿名的意思，映射到文件就需要有vm_file指定被映射的文件。</p>
<p>那这些vm_area_struct是如何和上面的内存区域关联的呢？</p>
<p>这个事情是在load_elf_binary里面实现的。没错，就是它。加载内核的是它，启动第一个用户态进程init的是它，fork完了以后，调用exec运行一个二进制程序的也是它。</p>
<p>当exec运行一个二进制程序的时候，除了解析ELF的格式之外，另外一个重要的事情就是建立内存映射。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">load_elf_binary</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">linux_binprm</span> <span class="token operator">*</span>bprm<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token function">setup_new_exec</span><span class="token punctuation">(</span>bprm<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  retval <span class="token operator">=</span> <span class="token function">setup_arg_pages</span><span class="token punctuation">(</span>bprm<span class="token punctuation">,</span> <span class="token function">randomize_stack_top</span><span class="token punctuation">(</span>STACK_TOP<span class="token punctuation">)</span><span class="token punctuation">,</span>
                 executable_stack<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  error <span class="token operator">=</span> <span class="token function">elf_map</span><span class="token punctuation">(</span>bprm<span class="token operator">-&gt;</span>file<span class="token punctuation">,</span> load_bias <span class="token operator">+</span> vaddr<span class="token punctuation">,</span> elf_ppnt<span class="token punctuation">,</span>
                elf_prot<span class="token punctuation">,</span> elf_flags<span class="token punctuation">,</span> total_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  retval <span class="token operator">=</span> <span class="token function">set_brk</span><span class="token punctuation">(</span>elf_bss<span class="token punctuation">,</span> elf_brk<span class="token punctuation">,</span> bss_prot<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  elf_entry <span class="token operator">=</span> <span class="token function">load_elf_interp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loc<span class="token operator">-&gt;</span>interp_elf_ex<span class="token punctuation">,</span>
                        interpreter<span class="token punctuation">,</span>
                        <span class="token operator">&amp;</span>interp_map_addr<span class="token punctuation">,</span>
                        load_bias<span class="token punctuation">,</span> interp_elf_phdata<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  current<span class="token operator">-&gt;</span>mm<span class="token operator">-&gt;</span>end_code <span class="token operator">=</span> end_code<span class="token punctuation">;</span>
  current<span class="token operator">-&gt;</span>mm<span class="token operator">-&gt;</span>start_code <span class="token operator">=</span> start_code<span class="token punctuation">;</span>
  current<span class="token operator">-&gt;</span>mm<span class="token operator">-&gt;</span>start_data <span class="token operator">=</span> start_data<span class="token punctuation">;</span>
  current<span class="token operator">-&gt;</span>mm<span class="token operator">-&gt;</span>end_data <span class="token operator">=</span> end_data<span class="token punctuation">;</span>
  current<span class="token operator">-&gt;</span>mm<span class="token operator">-&gt;</span>start_stack <span class="token operator">=</span> bprm<span class="token operator">-&gt;</span>p<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>load_elf_binary会完成以下的事情：</p>
<ul>
<li>调用setup_new_exec，设置内存映射区mmap_base；</li>
<li>调用setup_arg_pages，设置栈的vm_area_struct，这里面设置了mm-&gt;arg_start是指向栈底的，current-&gt;mm-&gt;start_stack就是栈底；</li>
<li>elf_map会将ELF文件中的代码部分映射到内存中来；</li>
<li>set_brk设置了堆的vm_area_struct，这里面设置了current-&gt;mm-&gt;start_brk = current-&gt;mm-&gt;brk，也即堆里面还是空的；</li>
<li>load_elf_interp将依赖的so映射到内存中的内存映射区域。</li>
</ul>
<p>最终就形成下面这个内存映射图。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/load_elf_binary建立的内存映射图.jpeg" alt="load_elf_binary建立的内存映射图"></p>
<p>映射完毕后，什么情况下会修改呢？</p>
<p>第一种情况是函数的调用，涉及函数栈的改变，主要是改变栈顶指针。</p>
<p>第二种情况是通过malloc申请一个堆内的空间，当然底层要么执行brk，要么执行mmap。关于内存映射的部分，我们后面的章节讲，这里我们重点看一下brk是怎么做的。</p>
<p>brk系统调用实现的入口是sys_brk函数，就像下面代码定义的一样。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE1</span><span class="token punctuation">(</span>brk<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> brk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> retval<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> newbrk<span class="token punctuation">,</span> oldbrk<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>mm <span class="token operator">=</span> current<span class="token operator">-&gt;</span>mm<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    newbrk <span class="token operator">=</span> <span class="token function">PAGE_ALIGN</span><span class="token punctuation">(</span>brk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    oldbrk <span class="token operator">=</span> <span class="token function">PAGE_ALIGN</span><span class="token punctuation">(</span>mm<span class="token operator">-&gt;</span>brk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldbrk <span class="token operator">==</span> newbrk<span class="token punctuation">)</span>
        <span class="token keyword">goto</span> set_brk<span class="token punctuation">;</span>

    <span class="token comment">/* Always allow shrinking brk. */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>brk <span class="token operator">&lt;=</span> mm<span class="token operator">-&gt;</span>brk<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">do_munmap</span><span class="token punctuation">(</span>mm<span class="token punctuation">,</span> newbrk<span class="token punctuation">,</span> oldbrk<span class="token operator">-</span>newbrk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>uf<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">goto</span> set_brk<span class="token punctuation">;</span>
        <span class="token keyword">goto</span> out<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* Check against existing mmap mappings. */</span>
    next <span class="token operator">=</span> <span class="token function">find_vma</span><span class="token punctuation">(</span>mm<span class="token punctuation">,</span> oldbrk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">&amp;&amp;</span> newbrk <span class="token operator">+</span> PAGE_SIZE <span class="token operator">&gt;</span> <span class="token function">vm_start_gap</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">goto</span> out<span class="token punctuation">;</span>

    <span class="token comment">/* Ok, looks good - let it rip. */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">do_brk</span><span class="token punctuation">(</span>oldbrk<span class="token punctuation">,</span> newbrk<span class="token operator">-</span>oldbrk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>uf<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">goto</span> out<span class="token punctuation">;</span>

set_brk<span class="token operator">:</span>
    mm<span class="token operator">-&gt;</span>brk <span class="token operator">=</span> brk<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> brk<span class="token punctuation">;</span>
out<span class="token operator">:</span>
    retval <span class="token operator">=</span> mm<span class="token operator">-&gt;</span>brk<span class="token punctuation">;</span>
    <span class="token keyword">return</span> retval<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>前面我们讲过了，堆是从低地址向高地址增长的，sys_brk函数的参数brk是新的堆顶位置，而当前的mm-&gt;brk是原来堆顶的位置。</p>
<p>首先要做的第一个事情，将原来的堆顶和现在的堆顶，都按照页对齐地址，然后比较大小。如果两者相同，说明这次增加的堆的量很小，还在一个页里面，不需要另行分配页，直接跳到set_brk那里，设置mm-&gt;brk为新的brk就可以了。</p>
<p>如果发现新旧堆顶不在一个页里面，麻烦了，这下要跨页了。如果发现新堆顶小于旧堆顶，这说明不是新分配内存了，而是释放内存了，释放的还不小，至少释放了一页，于是调用do_munmap将这一页的内存映射去掉。</p>
<p>如果堆将要扩大，就要调用find_vma。如果打开这个函数，看到的是对红黑树的查找，找到的是原堆顶所在的vm_area_struct的下一个vm_area_struct，看当前的堆顶和下一个vm_area_struct之间还能不能分配一个完整的页。如果不能，没办法只好直接退出返回，内存空间都被占满了。</p>
<p>如果还有空间，就调用do_brk进一步分配堆空间，从旧堆顶开始，分配计算出的新旧堆顶之间的页数。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">do_brk</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> addr<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">list_head</span> <span class="token operator">*</span>uf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">do_brk_flags</span><span class="token punctuation">(</span>addr<span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> uf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">do_brk_flags</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> addr<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> request<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">list_head</span> <span class="token operator">*</span>uf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>mm <span class="token operator">=</span> current<span class="token operator">-&gt;</span>mm<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span>vma<span class="token punctuation">,</span> <span class="token operator">*</span>prev<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span><span class="token operator">*</span>rb_link<span class="token punctuation">,</span> <span class="token operator">*</span>rb_parent<span class="token punctuation">;</span>
    pgoff_t pgoff <span class="token operator">=</span> addr <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">;</span>
    <span class="token keyword">int</span> error<span class="token punctuation">;</span>


    len <span class="token operator">=</span> <span class="token function">PAGE_ALIGN</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">find_vma_links</span><span class="token punctuation">(</span>mm<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> addr <span class="token operator">+</span> len<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rb_link<span class="token punctuation">,</span>
                  <span class="token operator">&amp;</span>rb_parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    vma <span class="token operator">=</span> <span class="token function">vma_merge</span><span class="token punctuation">(</span>mm<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> addr <span class="token operator">+</span> len<span class="token punctuation">,</span> flags<span class="token punctuation">,</span>
            <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> pgoff<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> NULL_VM_UFFD_CTX<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>vma<span class="token punctuation">)</span>
        <span class="token keyword">goto</span> out<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    vma <span class="token operator">=</span> <span class="token function">kmem_cache_zalloc</span><span class="token punctuation">(</span>vm_area_cachep<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vma<span class="token operator">-&gt;</span>anon_vma_chain<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vma<span class="token operator">-&gt;</span>vm_mm <span class="token operator">=</span> mm<span class="token punctuation">;</span>
    vma<span class="token operator">-&gt;</span>vm_start <span class="token operator">=</span> addr<span class="token punctuation">;</span>
    vma<span class="token operator">-&gt;</span>vm_end <span class="token operator">=</span> addr <span class="token operator">+</span> len<span class="token punctuation">;</span>
    vma<span class="token operator">-&gt;</span>vm_pgoff <span class="token operator">=</span> pgoff<span class="token punctuation">;</span>
    vma<span class="token operator">-&gt;</span>vm_flags <span class="token operator">=</span> flags<span class="token punctuation">;</span>
    vma<span class="token operator">-&gt;</span>vm_page_prot <span class="token operator">=</span> <span class="token function">vm_get_page_prot</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">vma_link</span><span class="token punctuation">(</span>mm<span class="token punctuation">,</span> vma<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> rb_link<span class="token punctuation">,</span> rb_parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
out<span class="token operator">:</span>
    <span class="token function">perf_event_mmap</span><span class="token punctuation">(</span>vma<span class="token punctuation">)</span><span class="token punctuation">;</span>
    mm<span class="token operator">-&gt;</span>total_vm <span class="token operator">+=</span> len <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">;</span>
    mm<span class="token operator">-&gt;</span>data_vm <span class="token operator">+=</span> len <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> VM_LOCKED<span class="token punctuation">)</span>
        mm<span class="token operator">-&gt;</span>locked_vm <span class="token operator">+=</span> <span class="token punctuation">(</span>len <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vma<span class="token operator">-&gt;</span>vm_flags <span class="token operator">|=</span> VM_SOFTDIRTY<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在do_brk中，调用find_vma_links找到将来的vm_area_struct节点在红黑树的位置，找到它的父节点、前序节点。接下来调用vma_merge，看这个新节点是否能够和现有树中的节点合并。如果地址是连着的，能够合并，则不用创建新的vm_area_struct了，直接跳到out，更新统计值即可；如果不能合并，则创建新的vm_area_struct，既加到anon_vma_chain链表中，也加到红黑树中。</p>
<h3 id="17-3-内核态的布局"><a href="#17-3-内核态的布局" class="headerlink" title="17.3 内核态的布局"></a>17.3 内核态的布局</h3><p>内核态的虚拟空间和某一个进程没有关系，所有进程通过系统调用进入到内核之后，看到的虚拟地址空间都是一样的。</p>
<p>这里强调一下，千万别以为到了内核里面，咱们就会直接使用物理内存地址了，想当然地认为下面讨论的都是物理内存地址，不是的，这里讨论的还是虚拟内存地址，但是由于内核总是涉及管理物理内存，因而总是隐隐约约发生关系，所以这里必须思路清晰，分清楚物理内存地址和虚拟内存地址。</p>
<p>在内核态，32位和64位的布局差别比较大，主要是因为32位内核态空间太小了。</p>
<p>我们来看32位的内核态的布局。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/32位内核态的布局.jpg" alt="32位内核态的布局"></p>
<p>32位的内核态虚拟地址空间一共就1G，占绝大部分的前896M，我们称为 <strong>直接映射区</strong> 。</p>
<p>所谓的直接映射区，就是这一块空间是连续的，和物理内存是非常简单的映射关系，其实就是虚拟内存地址减去3G，就得到物理内存的位置。</p>
<p>在内核里面，有两个宏：</p>
<ul>
<li>__pa(vaddr) 返回与虚拟地址 vaddr 相关的物理地址；</li>
<li>__va(paddr) 则计算出对应于物理地址 paddr 的虚拟地址。</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">__va</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>                 <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">+</span>PAGE_OFFSET<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">__pa</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>                 <span class="token function">__phys_addr</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">__phys_addr</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>          <span class="token function">__phys_addr_nodebug</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">__phys_addr_nodebug</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">-</span> PAGE_OFFSET<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>但是你要注意，这里虚拟地址和物理地址发生了关联关系，在物理内存的开始的896M的空间，会被直接映射到3G至3G+896M的虚拟地址，这样容易给你一种感觉，是这些内存访问起来和物理内存差不多，别这样想，在大部分情况下，对于这一段内存的访问，在内核中，还是会使用虚拟地址的，并且将来也会为这一段空间建设页表，对这段地址的访问也会走上一节我们讲的分页地址的流程，只不过页表里面比较简单，是直接的一一对应而已。</p>
<p>这896M还需要仔细分解。在系统启动的时候，物理内存的前1M已经被占用了，从1M开始加载内核代码段，然后就是内核的全局变量、BSS等，也是ELF里面涵盖的。这样内核的代码段，全局变量，BSS也就会被映射到3G后的虚拟地址空间里面。具体的物理内存布局可以查看/proc/iomem。</p>
<p>在内核运行的过程中，如果碰到系统调用创建进程，会创建task_struct这样的实例，内核的进程管理代码会将实例创建在3G至3G+896M的虚拟空间中，当然也会被放在物理内存里面的前896M里面，相应的页表也会被创建。</p>
<p>在内核运行的过程中，会涉及内核栈的分配，内核的进程管理的代码会将内核栈创建在3G至3G+896M的虚拟空间中，当然也就会被放在物理内存里面的前896M里面，相应的页表也会被创建。</p>
<p>896M这个值在内核中被定义为high_memory，在此之上常称为“高端内存”。这是个很笼统的说法，到底是虚拟内存的3G+896M以上的是高端内存，还是物理内存896M以上的是高端内存呢？</p>
<p>这里仍然需要辨析一下，高端内存是物理内存的概念。它仅仅是内核中的内存管理模块看待物理内存的时候的概念。前面我们也说过，在内核中，除了内存管理模块直接操作物理地址之外，内核的其他模块，仍然要操作虚拟地址，而虚拟地址是需要内存管理模块分配和映射好的。</p>
<p>假设咱们的电脑有2G内存，现在如果内核的其他模块想要访问物理内存1.5G的地方，应该怎么办呢？如果你觉得，我有32位的总线，访问个2G还不小菜一碟，这就错了。</p>
<p>首先，你不能使用物理地址。你需要使用内存管理模块给你分配的虚拟地址，但是虚拟地址的0到3G已经被用户态进程占用去了，你作为内核不能使用。因为你写1.5G的虚拟内存位置，一方面你不知道应该根据哪个进程的页表进行映射；另一方面，就算映射了也不是你真正想访问的物理内存的地方，所以你发现你作为内核，能够使用的虚拟内存地址，只剩下1G减去896M的空间了。</p>
<p>于是，我们可以将剩下的虚拟内存地址分成下面这几个部分。</p>
<ul>
<li>在896M到VMALLOC_START之间有8M的空间。</li>
<li>VMALLOC_START到VMALLOC_END之间称为内核动态映射空间，也即内核想像用户态进程一样malloc申请内存，在内核里面可以使用vmalloc。假设物理内存里面，896M到1.5G之间已经被用户态进程占用了，并且映射关系放在了进程的页表中，内核vmalloc的时候，只能从分配物理内存1.5G开始，就需要使用这一段的虚拟地址进行映射，映射关系放在专门给内核自己用的页表里面。</li>
<li>PKMAP_BASE到FIXADDR_START的空间称为持久内核映射。使用alloc_pages()函数的时候，在物理内存的高端内存得到struct page结构，可以调用kmap将其在映射到这个区域。</li>
<li>FIXADDR_START到FIXADDR_TOP(0xFFFF F000)的空间，称为固定映射区域，主要用于满足特殊需求。</li>
<li>在最后一个区域可以通过kmap_atomic实现临时内核映射。假设用户态的进程要映射一个文件到内存中，先要映射用户态进程空间的一段虚拟地址到物理内存，然后将文件内容写入这个物理内存供用户态进程访问。给用户态进程分配物理内存页可以通过alloc_pages()，分配完毕后，按说将用户态进程虚拟地址和物理内存的映射关系放在用户态进程的页表中，就完事大吉了。这个时候，用户态进程可以通过用户态的虚拟地址，也即0至3G的部分，经过页表映射后访问物理内存，并不需要内核态的虚拟地址里面也划出一块来，映射到这个物理内存页。但是如果要把文件内容写入物理内存，这件事情要内核来干了，这就只好通过kmap_atomic做一个临时映射，写入物理内存完毕后，再kunmap_atomic来解映射即可。</li>
</ul>
<p>32位的内核态布局我们看完了，接下来我们再来看64位的内核布局。</p>
<p>其实64位的内核布局反而简单，因为虚拟空间实在是太大了，根本不需要所谓的高端内存，因为内核是128T，根本不可能有物理内存超过这个值。</p>
<p>64位的内存布局如图所示。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/64位内核态的布局.jpg" alt="64位内核态的布局"></p>
<p>64位的内核主要包含以下几个部分。</p>
<ul>
<li>从0xffff800000000000开始就是内核的部分，只不过一开始有8T的空档区域。</li>
<li>从__PAGE_OFFSET_BASE(0xffff880000000000)开始的64T的虚拟地址空间是直接映射区域，也就是减去PAGE_OFFSET就是物理地址。虚拟地址和物理地址之间的映射在大部分情况下还是会通过建立页表的方式进行映射。</li>
<li>从VMALLOC_START（0xffffc90000000000）开始到VMALLOC_END（0xffffe90000000000）的32T的空间是给vmalloc的。</li>
<li>从VMEMMAP_START（0xffffea0000000000）开始的1T空间用于存放物理页面的描述结构struct page的。</li>
<li>从<strong>START_KERNEL_map（0xffffffff80000000）开始的512M用于存放内核代码段、全局变量、BSS等。这里对应到物理内存开始的位置，减去</strong>START_KERNEL_map就能得到物理内存的地址。这里和直接映射区有点像，但是不矛盾，因为直接映射区之前有8T的空当区域，早就过了内核代码在物理内存中加载的位置。</li>
</ul>
<p>到这里内核中虚拟空间的布局就介绍完了。</p>
<h3 id="17-4-总结"><a href="#17-4-总结" class="headerlink" title="17.4 总结"></a>17.4 总结</h3><p>一个进程要运行起来需要以下的内存结构。</p>
<p>用户态：</p>
<ul>
<li>代码段、全局变量、BSS</li>
<li>函数栈</li>
<li>堆</li>
<li>内存映射区</li>
</ul>
<p>内核态：</p>
<ul>
<li>内核的代码、全局变量、BSS</li>
<li>内核数据结构例如task_struct</li>
<li>内核栈</li>
<li>内核中动态分配的内存</li>
</ul>
<p>我画了一个图，总结一下进程运行状态在32位下对应关系。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/进程运行状态在32位下对应关系.jpeg" alt="进程运行状态在32位下对应关系"></p>
<p>对于64位的对应关系，只是稍有区别，我这里也画了一个图，方便你对比理解。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/进程运行状态在64位下对应关系.jpeg" alt="进程运行状态在64位下对应关系"></p>
<h2 id="十八、物理内存管理（上）"><a href="#十八、物理内存管理（上）" class="headerlink" title="十八、物理内存管理（上）"></a>十八、物理内存管理（上）</h2><h3 id="18-1-物理内存的组织方式"><a href="#18-1-物理内存的组织方式" class="headerlink" title="18.1 物理内存的组织方式"></a>18.1 物理内存的组织方式</h3><p>前面咱们讲虚拟内存，涉及物理内存的映射的时候，我们总是把内存想象成它是由连续的一页一页的块组成的。我们可以从0开始对物理页编号，这样每个物理页都会有个页号。</p>
<p>由于物理地址是连续的，页也是连续的，每个页大小也是一样的。因而对于任何一个地址，只要直接除一下每页的大小，很容易直接算出在哪一页。每个页有一个结构struct page表示，这个结构也是放在一个数组里面，这样根据页号，很容易通过下标找到相应的struct page结构。</p>
<p>如果是这样，整个物理内存的布局就非常简单、易管理，这就是最经典的 <strong>平坦内存模型（Flat Memory Model）</strong> 。</p>
<p>我们讲x86的工作模式的时候，讲过CPU是通过总线去访问内存的，这就是最经典的内存使用方式。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/CPU是通过总线去访问内存.jpeg" alt="CPU是通过总线去访问内存"></p>
<p>在这种模式下，CPU也会有多个，在总线的一侧。所有的内存条组成一大片内存，在总线的另一侧，所有的CPU访问内存都要过总线，而且距离都是一样的，这种模式称为 <strong>SMP（Symmetric multiprocessing）</strong> ，即对称多处理器。当然，它也有一个显著的缺点，就是总线会成为瓶颈，因为数据都要走它。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/SMP和NUMA.jpeg" alt="SMP和NUMA"></p>
<p>为了提高性能和可扩展性，后来有了一种更高级的模式， <strong>NUMA（Non-uniform memory access）</strong> ，非一致内存访问。在这种模式下，内存不是一整块。每个CPU都有自己的本地内存，CPU访问本地内存不用过总线，因而速度要快很多， <strong>每个CPU和内存在一起，称为一个NUMA节点</strong> 。但是，在本地内存不足的情况下，每个CPU都可以去另外的NUMA节点申请内存，这个时候访问延时就会比较长。</p>
<p>这样，内存被分成了多个节点，每个节点再被分成一个一个的页面。由于页需要全局唯一定位，页还是需要有全局唯一的页号的。但是由于物理内存不是连起来的了，页号也就不再连续了。于是内存模型就变成了非连续内存模型，管理起来就复杂一些。</p>
<p>这里需要指出的是，NUMA往往是非连续内存模型。而非连续内存模型不一定就是NUMA，有时候一大片内存的情况下，也会有物理内存地址不连续的情况。</p>
<p>后来内存技术牛了，可以支持热插拔了。这个时候，不连续成为常态，于是就有了稀疏内存模型。</p>
<h3 id="18-2-节点"><a href="#18-2-节点" class="headerlink" title="18.2 节点"></a>18.2 节点</h3><p>我们主要解析当前的主流场景，NUMA方式。我们首先要能够表示NUMA节点的概念，于是有了下面这个结构typedef struct pglist_data pg_data_t，它里面有以下的成员变量：</p>
<ul>
<li>每一个节点都有自己的ID：node_id；</li>
<li>node_mem_map就是这个节点的struct page数组，用于描述这个节点里面的所有的页；</li>
<li>node_start_pfn是这个节点的起始页号；</li>
<li>node_spanned_pages是这个节点中包含不连续的物理内存地址的页面数；</li>
<li>node_present_pages是真正可用的物理页面的数目。</li>
</ul>
<p>例如，64M物理内存隔着一个4M的空洞，然后是另外的64M物理内存。这样换算成页面数目就是，16K个页面隔着1K个页面，然后是另外16K个页面。这种情况下，node_spanned_pages就是33K个页面，node_present_pages就是32K个页面。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">pglist_data</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">zone</span> node_zones<span class="token punctuation">[</span>MAX_NR_ZONES<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">zonelist</span> node_zonelists<span class="token punctuation">[</span>MAX_ZONELISTS<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> nr_zones<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>node_mem_map<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> node_start_pfn<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> node_present_pages<span class="token punctuation">;</span> <span class="token comment">/* total number of physical pages */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> node_spanned_pages<span class="token punctuation">;</span> <span class="token comment">/* total size of physical page range, including holes */</span>
    <span class="token keyword">int</span> node_id<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span> pg_data_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>每一个节点分成一个个区域zone，放在数组node_zones里面。这个数组的大小为MAX_NR_ZONES。我们来看区域的定义。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span> <span class="token class-name">zone_type</span> <span class="token punctuation">{</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_ZONE_DMA</span></span>
    ZONE_DMA<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_ZONE_DMA32</span></span>
    ZONE_DMA32<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    ZONE_NORMAL<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_HIGHMEM</span></span>
    ZONE_HIGHMEM<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    ZONE_MOVABLE<span class="token punctuation">,</span>
    __MAX_NR_ZONES
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>ZONE_DMA是指可用于作DMA（Direct Memory Access，直接内存存取）的内存。DMA是这样一种机制：要把外设的数据读入内存或把内存的数据传送到外设，原来都要通过CPU控制完成，但是这会占用CPU，影响CPU处理其他事情，所以有了DMA模式。CPU只需向DMA控制器下达指令，让DMA控制器来处理数据的传送，数据传送完毕再把信息反馈给CPU，这样就可以解放CPU。</p>
<p>对于64位系统，有两个DMA区域。除了上面说的ZONE_DMA，还有ZONE_DMA32。在这里你大概理解DMA的原理就可以，不必纠结，我们后面会讲DMA的机制。</p>
<p>ZONE_NORMAL是直接映射区，就是上一节讲的，从物理内存到虚拟内存的内核区域，通过加上一个常量直接映射。</p>
<p>ZONE_HIGHMEM是高端内存区，就是上一节讲的，对于32位系统来说超过896M的地方，对于64位没必要有的一段区域。</p>
<p>ZONE_MOVABLE是可移动区域，通过将物理内存划分为可移动分配区域和不可移动分配区域来避免内存碎片。</p>
<p>这里你需要注意一下，我们刚才对于区域的划分，都是针对物理内存的。</p>
<p>nr_zones表示当前节点的区域的数量。node_zonelists是备用节点和它的内存区域的情况。前面讲NUMA的时候，我们讲了CPU访问内存，本节点速度最快，但是如果本节点内存不够怎么办，还是需要去其他节点进行分配。毕竟，就算在备用节点里面选择，慢了点也比没有强。</p>
<p>既然整个内存被分成了多个节点，那pglist_data应该放在一个数组里面。每个节点一项，就像下面代码里面一样：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">pglist_data</span> <span class="token operator">*</span>node_data<span class="token punctuation">[</span>MAX_NUMNODES<span class="token punctuation">]</span> __read_mostly<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="18-3-区域"><a href="#18-3-区域" class="headerlink" title="18.3 区域"></a>18.3 区域</h3><p>到这里，我们把内存分成了节点，把节点分成了区域。接下来我们来看，一个区域里面是如何组织的。</p>
<p>表示区域的数据结构zone的定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">zone</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">struct</span> <span class="token class-name">pglist_data</span>  <span class="token operator">*</span>zone_pgdat<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">per_cpu_pageset</span> __percpu <span class="token operator">*</span>pageset<span class="token punctuation">;</span>


    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>       zone_start_pfn<span class="token punctuation">;</span>


    <span class="token comment">/*
     * spanned_pages is the total pages spanned by the zone, including
     * holes, which is calculated as:
     *  spanned_pages = zone_end_pfn - zone_start_pfn;
     *
     * present_pages is physical pages existing within the zone, which
     * is calculated as:
     *  present_pages = spanned_pages - absent_pages(pages in holes);
     *
     * managed_pages is present pages managed by the buddy system, which
     * is calculated as (reserved_pages includes pages allocated by the
     * bootmem allocator):
     *  managed_pages = present_pages - reserved_pages;
     *
     */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>       managed_pages<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>       spanned_pages<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>       present_pages<span class="token punctuation">;</span>


    <span class="token keyword">const</span> <span class="token keyword">char</span>          <span class="token operator">*</span>name<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* free areas of different sizes */</span>
    <span class="token keyword">struct</span> <span class="token class-name">free_area</span>    free_area<span class="token punctuation">[</span>MAX_ORDER<span class="token punctuation">]</span><span class="token punctuation">;</span>


    <span class="token comment">/* zone flags, see below */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>       flags<span class="token punctuation">;</span>


    <span class="token comment">/* Primarily protects free_area */</span>
    spinlock_t          lock<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span> ____cacheline_internodealigned_in_<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在一个zone里面，zone_start_pfn表示属于这个zone的第一个页。</p>
<p>如果我们仔细看代码的注释，可以看到，spanned_pages = zone_end_pfn - zone_start_pfn，也即spanned_pages指的是不管中间有没有物理内存空洞，反正就是最后的页号减去起始的页号。</p>
<p>present_pages = spanned_pages - absent_pages(pages in holes)，也即present_pages是这个zone在物理内存中真实存在的所有page数目。</p>
<p>managed_pages = present_pages - reserved_pages，也即managed_pages是这个zone被伙伴系统管理的所有的page数目，伙伴系统的工作机制我们后面会讲。</p>
<p>per_cpu_pageset用于区分冷热页。什么叫冷热页呢？咱们讲x86体系结构的时候讲过，为了让CPU快速访问段描述符，在CPU里面有段描述符缓存。CPU访问这个缓存的速度比内存快得多。同样对于页面来讲，也是这样的。如果一个页被加载到CPU高速缓存里面，这就是一个热页（Hot Page），CPU读起来速度会快很多，如果没有就是冷页（Cold Page）。由于每个CPU都有自己的高速缓存，因而per_cpu_pageset也是每个CPU一个。</p>
<h3 id="18-4-页"><a href="#18-4-页" class="headerlink" title="18.4 页"></a>18.4 页</h3><p>了解了区域zone，接下来我们就到了组成物理内存的基本单位，页的数据结构struct page。这是一个特别复杂的结构，里面有很多的union，union结构是在C语言中被用于同一块内存根据情况保存不同类型数据的一种方式。这里之所以用了union，是因为一个物理页面使用模式有多种。</p>
<p>第一种模式，要用就用一整页。这一整页的内存，或者直接和虚拟地址空间建立映射关系，我们把这种称为 <strong>匿名页（Anonymous Page）</strong> 。或者用于关联一个文件，然后再和虚拟地址空间建立映射关系，这样的文件，我们称为 <strong>内存映射文件（Memory-mapped File）</strong> 。</p>
<ul>
<li>struct address_space *mapping就是用于内存映射，如果是匿名页，最低位为1；如果是映射文件，最低位为0；</li>
<li>pgoff_t index是在映射区的偏移量；</li>
<li>atomic_t _mapcount，每个进程都有自己的页表，这里指有多少个页表项指向了这个页；</li>
<li>struct list_head lru表示这一页应该在一个链表上，例如这个页面被换出，就在换出页的链表中；</li>
<li>compound相关的变量用于复合页（Compound Page），就是将物理上连续的两个或多个页看成一个独立的大页。</li>
</ul>
<p>第二种模式，仅需分配小块内存。有时候，我们不需要一下子分配这么多的内存，例如分配一个task_struct结构，只需要分配小块的内存，去存储这个进程描述结构的对象。为了满足对这种小内存块的需要，Linux系统采用了一种被称为 <strong>slab allocator</strong> 的技术，用于分配称为slab的一小块内存。它的基本原理是从内存管理模块申请一整块页，然后划分成多个小块的存储池，用复杂的队列来维护这些小块的状态（状态包括：被分配了/被放回池子/应该被回收）。</p>
<p>也正是因为slab allocator对于队列的维护过于复杂，后来就有了一种不使用队列的分配器slub allocator，后面我们会解析这个分配器。但是你会发现，它里面还是用了很多slab的字眼，因为它保留了slab的用户接口，可以看成slab allocator的另一种实现。</p>
<p>还有一种小块内存的分配器称为 <strong>slob</strong> ，非常简单，主要使用在小型的嵌入式系统。</p>
<p>如果某一页是用于分割成一小块一小块的内存进行分配的使用模式，则会使用union中的以下变量：</p>
<ul>
<li>s_mem是已经分配了正在使用的slab的第一个对象；</li>
<li>freelist是池子中的空闲对象；</li>
<li>rcu_head是需要释放的列表。</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">address_space</span> <span class="token operator">*</span>mapping<span class="token punctuation">;</span>
        <span class="token keyword">void</span> <span class="token operator">*</span>s_mem<span class="token punctuation">;</span>                <span class="token comment">/* slab first object */</span>
        atomic_t compound_mapcount<span class="token punctuation">;</span> <span class="token comment">/* first tail page */</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        pgoff_t index<span class="token punctuation">;</span>          <span class="token comment">/* Our offset within mapping. */</span>
        <span class="token keyword">void</span> <span class="token operator">*</span>freelist<span class="token punctuation">;</span>         <span class="token comment">/* sl[aou]b first free object */</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token keyword">unsigned</span> counters<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token punctuation">{</span>
            <span class="token keyword">union</span> <span class="token punctuation">{</span>
                atomic_t _mapcount<span class="token punctuation">;</span>
                <span class="token keyword">unsigned</span> <span class="token keyword">int</span> active<span class="token punctuation">;</span>        <span class="token comment">/* SLAB */</span>
                <span class="token keyword">struct</span> <span class="token punctuation">{</span>                    <span class="token comment">/* SLUB */</span>
                    <span class="token keyword">unsigned</span> inuse<span class="token operator">:</span><span class="token number">16</span><span class="token punctuation">;</span>
                    <span class="token keyword">unsigned</span> objects<span class="token operator">:</span><span class="token number">15</span><span class="token punctuation">;</span>
                    <span class="token keyword">unsigned</span> frozen<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token punctuation">;</span>
                <span class="token keyword">int</span> units<span class="token punctuation">;</span>                  <span class="token comment">/* SLOB */</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
            atomic_t _refcount<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">list_head</span> lru<span class="token punctuation">;</span>   <span class="token comment">/* Pageout list  */</span>
        <span class="token keyword">struct</span> <span class="token class-name">dev_pagemap</span> <span class="token operator">*</span>pgmap<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token punctuation">{</span>                <span class="token comment">/* slub per cpu partial pages */</span>
            <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>  <span class="token comment">/* Next partial slab */</span>
            <span class="token keyword">int</span> pages<span class="token punctuation">;</span>          <span class="token comment">/* Nr of partial slabs left */</span>
            <span class="token keyword">int</span> pobjects<span class="token punctuation">;</span>       <span class="token comment">/* Approximate # of objects */</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">rcu_head</span> rcu_head<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token punctuation">{</span>
            <span class="token keyword">unsigned</span> <span class="token keyword">long</span> compound_head<span class="token punctuation">;</span> <span class="token comment">/* If bit zero is set */</span>
            <span class="token keyword">unsigned</span> <span class="token keyword">int</span> compound_dtor<span class="token punctuation">;</span>
            <span class="token keyword">unsigned</span> <span class="token keyword">int</span> compound_order<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> private<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>slab_cache<span class="token punctuation">;</span>  <span class="token comment">/* SL[AU]B: Pointer to slab */</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="18-5-页的分配"><a href="#18-5-页的分配" class="headerlink" title="18.5 页的分配"></a>18.5 页的分配</h3><p>对于要分配比较大的内存，例如到分配页级别的，可以使用 <strong>伙伴系统（Buddy System）</strong> 。</p>
<p>Linux中的内存管理的“页”大小为4KB。把所有的空闲页分组为11个页块链表，每个块链表分别包含很多个大小的页块，有1、2、4、8、16、32、64、128、256、512和1024个连续页的页块。最大可以申请1024个连续页，对应4MB大小的连续内存。每个页块的第一个页的物理地址是该页块大小的整数倍。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/伙伴系统.jpeg" alt="伙伴系统"></p>
<p>第i个页块链表中，页块中页的数目为2^i。</p>
<p>在struct zone里面有以下的定义：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">free_area</span>    free_area<span class="token punctuation">[</span>MAX_ORDER<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>MAX_ORDER就是指数。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">MAX_ORDER <span class="token number">11</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当向内核请求分配(2^(i-1)，2^i]数目的页块时，按照2^i页块请求处理。如果对应的页块链表中没有空闲页块，那我们就在更大的页块链表中去找。当分配的页块中有多余的页时，伙伴系统会根据多余的页块大小插入到对应的空闲页块链表中。</p>
<p>例如，要请求一个128个页的页块时，先检查128个页的页块链表是否有空闲块。如果没有，则查256个页的页块链表；如果有空闲块的话，则将256个页的页块分成两份，一份使用，一份插入128个页的页块链表中。如果还是没有，就查512个页的页块链表；如果有的话，就分裂为128、128、256三个页块，一个128的使用，剩余两个插入对应页块链表。</p>
<p>上面这个过程，我们可以在分配页的函数alloc_pages中看到。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>
<span class="token function">alloc_pages</span><span class="token punctuation">(</span>gfp_t gfp_mask<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> order<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">alloc_pages_current</span><span class="token punctuation">(</span>gfp_mask<span class="token punctuation">,</span> order<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">/**
 *  alloc_pages_current - Allocate pages.
 *
 *  @gfp:
 *      %GFP_USER   user allocation,
 *          %GFP_KERNEL kernel allocation,
 *          %GFP_HIGHMEM highmem allocation,
 *          %GFP_FS     don't call back into a file system.
 *          %GFP_ATOMIC don't sleep.
 *  @order: Power of two of allocation size in pages. 0 is a single page.
 *
 *  Allocate a page from the kernel page pool.  When not in
 *  interrupt context and apply the current process NUMA policy.
 *  Returns NULL when no page can be allocated.
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span><span class="token function">alloc_pages_current</span><span class="token punctuation">(</span>gfp_t gfp<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> order<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">mempolicy</span> <span class="token operator">*</span>pol <span class="token operator">=</span> <span class="token operator">&amp;</span>default_policy<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    page <span class="token operator">=</span> <span class="token function">__alloc_pages_nodemask</span><span class="token punctuation">(</span>gfp<span class="token punctuation">,</span> order<span class="token punctuation">,</span>
                <span class="token function">policy_node</span><span class="token punctuation">(</span>gfp<span class="token punctuation">,</span> pol<span class="token punctuation">,</span> <span class="token function">numa_node_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token function">policy_nodemask</span><span class="token punctuation">(</span>gfp<span class="token punctuation">,</span> pol<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> page<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>alloc_pages会调用alloc_pages_current，这里面的注释比较容易看懂了，gfp表示希望在哪个区域中分配这个内存：</p>
<ul>
<li>GFP_USER用于分配一个页映射到用户进程的虚拟地址空间，并且希望直接被内核或者硬件访问，主要用于一个用户进程希望通过内存映射的方式，访问某些硬件的缓存，例如显卡缓存；</li>
<li>GFP_KERNEL用于内核中分配页，主要分配ZONE_NORMAL区域，也即直接映射区；</li>
<li>GFP_HIGHMEM，顾名思义就是主要分配高端区域的内存。</li>
</ul>
<p>另一个参数order，就是表示分配2的order次方个页。</p>
<p>接下来调用__alloc_pages_nodemask。这是伙伴系统的核心方法。它会调用get_page_from_freelist。这里面的逻辑也很容易理解，就是在一个循环中先看当前节点的zone。如果找不到空闲页，则再看备用节点的zone。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>
<span class="token function">get_page_from_freelist</span><span class="token punctuation">(</span>gfp_t gfp_mask<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> order<span class="token punctuation">,</span> <span class="token keyword">int</span> alloc_flags<span class="token punctuation">,</span>
                        <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">alloc_context</span> <span class="token operator">*</span>ac<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">for_next_zone_zonelist_nodemask</span><span class="token punctuation">(</span>zone<span class="token punctuation">,</span> z<span class="token punctuation">,</span> ac<span class="token operator">-&gt;</span>zonelist<span class="token punctuation">,</span> ac<span class="token operator">-&gt;</span>high_zoneidx<span class="token punctuation">,</span> ac<span class="token operator">-&gt;</span>nodemask<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        page <span class="token operator">=</span> <span class="token function">rmqueue</span><span class="token punctuation">(</span>ac<span class="token operator">-&gt;</span>preferred_zoneref<span class="token operator">-&gt;</span>zone<span class="token punctuation">,</span> zone<span class="token punctuation">,</span> order<span class="token punctuation">,</span>
                gfp_mask<span class="token punctuation">,</span> alloc_flags<span class="token punctuation">,</span> ac<span class="token operator">-&gt;</span>migratetype<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>每一个zone，都有伙伴系统维护的各种大小的队列，就像上面伙伴系统原理里讲的那样。这里调用rmqueue就很好理解了，就是找到合适大小的那个队列，把页面取下来。</p>
<p>接下来的调用链是rmqueue-&gt;<strong>rmqueue-&gt;</strong>rmqueue_smallest。在这里，我们能清楚看到伙伴系统的逻辑。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span>
<span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span><span class="token function">__rmqueue_smallest</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">zone</span> <span class="token operator">*</span>zone<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> order<span class="token punctuation">,</span>
                        <span class="token keyword">int</span> migratetype<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> current_order<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">free_area</span> <span class="token operator">*</span>area<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>


    <span class="token comment">/* Find a page of the appropriate size in the preferred list */</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>current_order <span class="token operator">=</span> order<span class="token punctuation">;</span> current_order <span class="token operator">&lt;</span> MAX_ORDER<span class="token punctuation">;</span> <span class="token operator">++</span>current_order<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        area <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>zone<span class="token operator">-&gt;</span>free_area<span class="token punctuation">[</span>current_order<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        page <span class="token operator">=</span> <span class="token function">list_first_entry_or_null</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>area<span class="token operator">-&gt;</span>free_list<span class="token punctuation">[</span>migratetype<span class="token punctuation">]</span><span class="token punctuation">,</span>
                            <span class="token keyword">struct</span> <span class="token class-name">page</span><span class="token punctuation">,</span> lru<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>page<span class="token punctuation">)</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token function">list_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>page<span class="token operator">-&gt;</span>lru<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">rmv_page_order</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span>
        area<span class="token operator">-&gt;</span>nr_free<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token function">expand</span><span class="token punctuation">(</span>zone<span class="token punctuation">,</span> page<span class="token punctuation">,</span> order<span class="token punctuation">,</span> current_order<span class="token punctuation">,</span> area<span class="token punctuation">,</span> migratetype<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">set_pcppage_migratetype</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> migratetype<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> page<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从当前的order，也即指数开始，在伙伴系统的free_area找2^order大小的页块。如果链表的第一个不为空，就找到了；如果为空，就到更大的order的页块链表里面去找。找到以后，除了将页块从链表中取下来，我们还要把多余的的部分放到其他页块链表里面。expand就是干这个事情的。area–就是伙伴系统那个表里面的前一项，前一项里面的页块大小是当前项的页块大小除以2，size右移一位也就是除以2，list_add就是加到链表上，nr_free++就是计数加1。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">expand</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">zone</span> <span class="token operator">*</span>zone<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">,</span>
    <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">free_area</span> <span class="token operator">*</span>area<span class="token punctuation">,</span>
    <span class="token keyword">int</span> migratetype<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> high<span class="token punctuation">;</span>


    <span class="token keyword">while</span> <span class="token punctuation">(</span>high <span class="token operator">&gt;</span> low<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        area<span class="token operator">--</span><span class="token punctuation">;</span>
        high<span class="token operator">--</span><span class="token punctuation">;</span>
        size <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token function">list_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>page<span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">.</span>lru<span class="token punctuation">,</span> <span class="token operator">&amp;</span>area<span class="token operator">-&gt;</span>free_list<span class="token punctuation">[</span>migratetype<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        area<span class="token operator">-&gt;</span>nr_free<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token function">set_page_order</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>page<span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="18-6-总结"><a href="#18-6-总结" class="headerlink" title="18.6 总结"></a>18.6 总结</h3><p>如果有多个CPU，那就有多个节点。每个节点用struct pglist_data表示，放在一个数组里面。</p>
<p>每个节点分为多个区域，每个区域用struct zone表示，也放在一个数组里面。</p>
<p>每个区域分为多个页。为了方便分配，空闲页放在struct free_area里面，使用伙伴系统进行管理和分配，每一页用struct page表示。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/物理内存的组织形式.jpeg" alt="物理内存的组织形式"></p>
<h2 id="十九、物理内存管理（下）"><a href="#十九、物理内存管理（下）" class="headerlink" title="十九、物理内存管理（下）"></a>十九、物理内存管理（下）</h2><h3 id="19-1-小内存的分配"><a href="#19-1-小内存的分配" class="headerlink" title="19.1 小内存的分配"></a>19.1 小内存的分配</h3><p>前面我们讲过，如果遇到小的对象，会使用slub分配器进行分配。那我们就先来解析它的工作原理。</p>
<p>还记得咱们创建进程的时候，会调用dup_task_struct，它想要试图复制一个task_struct对象，需要先调用alloc_task_struct_node，分配一个task_struct对象。</p>
<p>从这段代码可以看出，它调用了kmem_cache_alloc_node函数，在task_struct的缓存区域task_struct_cachep分配了一块内存。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>task_struct_cachep<span class="token punctuation">;</span>

task_struct_cachep <span class="token operator">=</span> <span class="token function">kmem_cache_create</span><span class="token punctuation">(</span><span class="token string">"task_struct"</span><span class="token punctuation">,</span>
            arch_task_struct_size<span class="token punctuation">,</span> align<span class="token punctuation">,</span>
            SLAB_PANIC<span class="token operator">|</span>SLAB_NOTRACK<span class="token operator">|</span>SLAB_ACCOUNT<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token function">alloc_task_struct_node</span><span class="token punctuation">(</span><span class="token keyword">int</span> node<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">kmem_cache_alloc_node</span><span class="token punctuation">(</span>task_struct_cachep<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">free_task_struct</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">kmem_cache_free</span><span class="token punctuation">(</span>task_struct_cachep<span class="token punctuation">,</span> tsk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在系统初始化的时候，task_struct_cachep会被kmem_cache_create函数创建。这个函数也比较容易看懂，专门用于分配task_struct对象的缓存。这个缓存区的名字就叫task_struct。缓存区中每一块的大小正好等于task_struct的大小，也即arch_task_struct_size。</p>
<p>有了这个缓存区，每次创建task_struct的时候，我们不用到内存里面去分配，先在缓存里面看看有没有直接可用的，这就是 <strong>kmem_cache_alloc_node</strong> 的作用。</p>
<p>当一个进程结束，task_struct也不用直接被销毁，而是放回到缓存中，这就是 <strong>kmem_cache_free</strong> 的作用。这样，新进程创建的时候，我们就可以直接用现成的缓存中的task_struct了。</p>
<p>我们来仔细看看，缓存区struct kmem_cache到底是什么样子。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_cpu</span> __percpu <span class="token operator">*</span>cpu_slab<span class="token punctuation">;</span>
    <span class="token comment">/* Used for retriving partial slabs etc */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> min_partial<span class="token punctuation">;</span>
    <span class="token keyword">int</span> size<span class="token punctuation">;</span>               <span class="token comment">/* The size of an object including meta data */</span>
    <span class="token keyword">int</span> object_size<span class="token punctuation">;</span>        <span class="token comment">/* The size of an object without meta data */</span>
    <span class="token keyword">int</span> offset<span class="token punctuation">;</span>             <span class="token comment">/* Free pointer offset. */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_SLUB_CPU_PARTIAL</span></span>
    <span class="token keyword">int</span> cpu_partial<span class="token punctuation">;</span>        <span class="token comment">/* Number of per cpu partial objects to keep around */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_order_objects</span> oo<span class="token punctuation">;</span>
    <span class="token comment">/* Allocation and freeing of slabs */</span>
    <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_order_objects</span> max<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_order_objects</span> min<span class="token punctuation">;</span>
    gfp_t allocflags<span class="token punctuation">;</span>       <span class="token comment">/* gfp flags to use on each alloc */</span>
    <span class="token keyword">int</span> refcount<span class="token punctuation">;</span>           <span class="token comment">/* Refcount for slab cache destroy */</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>ctor<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>       <span class="token comment">/* Name (only for display!) */</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> list<span class="token punctuation">;</span>  <span class="token comment">/* List of slab caches */</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_node</span> <span class="token operator">*</span>node<span class="token punctuation">[</span>MAX_NUMNODES<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在struct kmem_cache里面，有个变量struct list_head list，这个结构我们已经看到过多次了。我们可以想象一下，对于操作系统来讲，要创建和管理的缓存绝对不止task_struct。难道mm_struct就不需要吗？fs_struct就不需要吗？都需要。因此，所有的缓存最后都会放在一个链表里面，也就是LIST_HEAD(slab_caches)。</p>
<p>对于缓存来讲，其实就是分配了连续几页的大内存块，然后根据缓存对象的大小，切成小内存块。</p>
<p>所以，我们这里有三个kmem_cache_order_objects类型的变量。这里面的order，就是2的order次方个页面的大内存块，objects就是能够存放的缓存对象的数量。</p>
<p>最终，我们将大内存块切分成小内存块，样子就像下面这样。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/将大内存块切分成小内存块.jpeg" alt="将大内存块切分成小内存块"></p>
<p>每一项的结构都是缓存对象后面跟一个下一个空闲对象的指针，这样非常方便将所有的空闲对象链成一个链。其实，这就相当于咱们数据结构里面学的， <strong>用数组实现一个可随机插入和删除的链表</strong> 。</p>
<p>所以，这里面就有三个变量：size是包含这个指针的大小，object_size是纯对象的大小，offset就是把下一个空闲对象的指针存放在这一项里的偏移量。</p>
<p>那这些缓存对象哪些被分配了、哪些在空着，什么情况下整个大内存块都被分配完了，需要向伙伴系统申请几个页形成新的大内存块？这些信息该由谁来维护呢？</p>
<p>接下来就是最重要的两个成员变量出场的时候了。kmem_cache_cpu和kmem_cache_node，它们都是每个NUMA节点上有一个，我们只需要看一个节点里面的情况。</p>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/kmem_cache_cpu和kmem_cache_node.jpeg" alt="kmem_cache_cpu和kmem_cache_node"></p>
<p>在分配缓存块的时候，要分两种路径，<strong>fast path</strong>和<strong>slow path</strong>，也就是<strong>快速通道</strong>和<strong>普通通道</strong>。其中kmem_cache_cpu就是快速通道，kmem_cache_node是普通通道。每次分配的时候，要先从kmem_cache_cpu进行分配。如果kmem_cache_cpu里面没有空闲的块，那就到kmem_cache_node中进行分配；如果还是没有空闲的块，才去伙伴系统分配新的页。</p>
<p>我们来看一下，kmem_cache_cpu里面是如何存放缓存块的。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">kmem_cache_cpu</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>freelist<span class="token punctuation">;</span>        <span class="token comment">/* Pointer to next available object */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> tid<span class="token punctuation">;</span>      <span class="token comment">/* Globally unique transaction id */</span>
    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>      <span class="token comment">/* The slab from which we are allocating */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_SLUB_CPU_PARTIAL</span></span>
    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>partial<span class="token punctuation">;</span>   <span class="token comment">/* Partially allocated frozen slabs */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里，page指向大内存块的第一个页，缓存块就是从里面分配的。freelist指向大内存块里面第一个空闲的项。按照上面说的，这一项会有指针指向下一个空闲的项，最终所有空闲的项会形成一个链表。</p>
<p>partial指向的也是大内存块的第一个页，之所以名字叫partial（部分），就是因为它里面部分被分配出去了，部分是空的。这是一个备用列表，当page满了，就会从这里找。</p>
<p>我们再来看kmem_cache_node的定义。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">kmem_cache_node</span> <span class="token punctuation">{</span>
    spinlock_t list_lock<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_SLUB</span></span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> nr_partial<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> partial<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面也有一个partial，是一个链表。这个链表里存放的是部分空闲的大内存块。这是kmem_cache_cpu里面的partial的备用列表，如果那里没有，就到这里来找。</p>
<p>下面我们就来看看这个分配过程。kmem_cache_alloc_node会调用slab_alloc_node。你还是先重点看这里面的注释，这里面说的就是快速通道和普通通道的概念。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * Inlined fastpath so that allocation functions (kmalloc, kmem_cache_alloc)
 * have the fastpath folded into their functions. So no function call
 * overhead for requests that can be satisfied on the fastpath.
 *
 * The fastpath works by first checking if the lockless freelist can be used.
 * If not then __slab_alloc is called for slow processing.
 *
 * Otherwise we can simply pick the next object from the lockless free list.
 */</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">slab_alloc_node</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>s<span class="token punctuation">,</span>
        gfp_t gfpflags<span class="token punctuation">,</span> <span class="token keyword">int</span> node<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> addr<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>object<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_cpu</span> <span class="token operator">*</span>c<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> tid<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    tid <span class="token operator">=</span> <span class="token function">this_cpu_read</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>cpu_slab<span class="token operator">-&gt;</span>tid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    c <span class="token operator">=</span> <span class="token function">raw_cpu_ptr</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>cpu_slab<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    object <span class="token operator">=</span> c<span class="token operator">-&gt;</span>freelist<span class="token punctuation">;</span>
    page <span class="token operator">=</span> c<span class="token operator">-&gt;</span>page<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>object <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">node_match</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        object <span class="token operator">=</span> <span class="token function">__slab_alloc</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> gfpflags<span class="token punctuation">,</span> node<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">stat</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> ALLOC_SLOWPATH<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> object<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>快速通道很简单，取出cpu_slab也即kmem_cache_cpu的freelist，这就是第一个空闲的项，可以直接返回了。如果没有空闲的了，则只好进入普通通道，调用__slab_alloc。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">___slab_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> gfp_t gfpflags<span class="token punctuation">,</span> <span class="token keyword">int</span> node<span class="token punctuation">,</span>
              <span class="token keyword">unsigned</span> <span class="token keyword">long</span> addr<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_cpu</span> <span class="token operator">*</span>c<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>freelist<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
redo<span class="token operator">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* must check again c-&gt;freelist in case of cpu migration or IRQ */</span>
    freelist <span class="token operator">=</span> c<span class="token operator">-&gt;</span>freelist<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>freelist<span class="token punctuation">)</span>
        <span class="token keyword">goto</span> load_freelist<span class="token punctuation">;</span>

    freelist <span class="token operator">=</span> <span class="token function">get_freelist</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> page<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>freelist<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        c<span class="token operator">-&gt;</span>page <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token function">stat</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> DEACTIVATE_BYPASS<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> new_slab<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

load_freelist<span class="token operator">:</span>
    c<span class="token operator">-&gt;</span>freelist <span class="token operator">=</span> <span class="token function">get_freepointer</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> freelist<span class="token punctuation">)</span><span class="token punctuation">;</span>
    c<span class="token operator">-&gt;</span>tid <span class="token operator">=</span> <span class="token function">next_tid</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>tid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> freelist<span class="token punctuation">;</span>

new_slab<span class="token operator">:</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">slub_percpu_partial</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        page <span class="token operator">=</span> c<span class="token operator">-&gt;</span>page <span class="token operator">=</span> <span class="token function">slub_percpu_partial</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">slub_set_percpu_partial</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> page<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">stat</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> CPU_PARTIAL_ALLOC<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> redo<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    freelist <span class="token operator">=</span> <span class="token function">new_slab_objects</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> gfpflags<span class="token punctuation">,</span> node<span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> freeli<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里，我们首先再次尝试一下kmem_cache_cpu的freelist。为什么呢？万一当前进程被中断，等回来的时候，别人已经释放了一些缓存，说不定又有空间了呢。如果找到了，就跳到load_freelist，在这里将freelist指向下一个空闲项，返回就可以了。</p>
<p>如果freelist还是没有，则跳到new_slab里面去。这里面我们先去kmem_cache_cpu的partial里面看。如果partial不是空的，那就将kmem_cache_cpu的page，也就是快速通道的那一大块内存，替换为partial里面的大块内存。然后redo，重新试下。这次应该就可以成功了。</p>
<p>如果真的还不行，那就要到new_slab_objects了。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">new_slab_objects</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> gfp_t flags<span class="token punctuation">,</span>
            <span class="token keyword">int</span> node<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_cpu</span> <span class="token operator">*</span><span class="token operator">*</span>pc<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>freelist<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_cpu</span> <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token operator">*</span>pc<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>

    freelist <span class="token operator">=</span> <span class="token function">get_partial</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> node<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>freelist<span class="token punctuation">)</span>
        <span class="token keyword">return</span> freelist<span class="token punctuation">;</span>

    page <span class="token operator">=</span> <span class="token function">new_slab</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>page<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        c <span class="token operator">=</span> <span class="token function">raw_cpu_ptr</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>cpu_slab<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>page<span class="token punctuation">)</span>
            <span class="token function">flush_slab</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>

        freelist <span class="token operator">=</span> page<span class="token operator">-&gt;</span>freelist<span class="token punctuation">;</span>
        page<span class="token operator">-&gt;</span>freelist <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

        <span class="token function">stat</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> ALLOC_SLAB<span class="token punctuation">)</span><span class="token punctuation">;</span>
        c<span class="token operator">-&gt;</span>page <span class="token operator">=</span> page<span class="token punctuation">;</span>
        <span class="token operator">*</span>pc <span class="token operator">=</span> c<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span>
        freelist <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> freelis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里面，get_partial会根据node id，找到相应的kmem_cache_node，然后调用get_partial_node，开始在这个节点进行分配。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * Try to allocate a partial slab from a specific node.
 */</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">get_partial_node</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_node</span> <span class="token operator">*</span>n<span class="token punctuation">,</span>
                <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_cpu</span> <span class="token operator">*</span>c<span class="token punctuation">,</span> gfp_t flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">,</span> <span class="token operator">*</span>page2<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>object <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> available <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> objects<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">list_for_each_entry_safe</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> page2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token operator">-&gt;</span>partial<span class="token punctuation">,</span> lru<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">void</span> <span class="token operator">*</span>t<span class="token punctuation">;</span>

        t <span class="token operator">=</span> <span class="token function">acquire_slab</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> n<span class="token punctuation">,</span> page<span class="token punctuation">,</span> object <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>objects<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>t<span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>

        available <span class="token operator">+=</span> objects<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>object<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            c<span class="token operator">-&gt;</span>page <span class="token operator">=</span> page<span class="token punctuation">;</span>
            <span class="token function">stat</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> ALLOC_FROM_PARTIAL<span class="token punctuation">)</span><span class="token punctuation">;</span>
            object <span class="token operator">=</span> t<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">put_cpu_partial</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> page<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">stat</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> CPU_PARTIAL_NODE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">kmem_cache_has_cpu_partial</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
            <span class="token operator">||</span> available <span class="token operator">&gt;</span> <span class="token function">slub_cpu_partial</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> object<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>acquire_slab会从kmem_cache_node的partial链表中拿下一大块内存来，并且将freelist，也就是第一块空闲的缓存块，赋值给t。并且当第一轮循环的时候，将kmem_cache_cpu的page指向取下来的这一大块内存，返回的object就是这块内存里面的第一个缓存块t。如果kmem_cache_cpu也有一个partial，就会进行第二轮，再次取下一大块内存来，这次调用put_cpu_partial，放到kmem_cache_cpu的partial里面。</p>
<p>如果kmem_cache_node里面也没有空闲的内存，这就说明原来分配的页里面都放满了，就要回到new_slab_objects函数，里面new_slab函数会调用allocate_slab。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span><span class="token function">allocate_slab</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> gfp_t flags<span class="token punctuation">,</span> <span class="token keyword">int</span> node<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_order_objects</span> oo <span class="token operator">=</span> s<span class="token operator">-&gt;</span>oo<span class="token punctuation">;</span>
    gfp_t alloc_gfp<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>start<span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
    <span class="token keyword">int</span> idx<span class="token punctuation">,</span> order<span class="token punctuation">;</span>
    bool shuffle<span class="token punctuation">;</span>

    flags <span class="token operator">&amp;=</span> gfp_allowed_mask<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    page <span class="token operator">=</span> <span class="token function">alloc_slab_page</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> alloc_gfp<span class="token punctuation">,</span> node<span class="token punctuation">,</span> oo<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>page<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        oo <span class="token operator">=</span> s<span class="token operator">-&gt;</span>min<span class="token punctuation">;</span>
        alloc_gfp <span class="token operator">=</span> flags<span class="token punctuation">;</span>
        <span class="token comment">/*
         * Allocation may have failed due to fragmentation.
         * Try a lower order alloc if possible
         */</span>
        page <span class="token operator">=</span> <span class="token function">alloc_slab_page</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> alloc_gfp<span class="token punctuation">,</span> node<span class="token punctuation">,</span> oo<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>page<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">goto</span> out<span class="token punctuation">;</span>
        <span class="token function">stat</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> ORDER_FALLBACK<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> page<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里，我们看到了alloc_slab_page分配页面。分配的时候，要按kmem_cache_order_objects里面的order来。如果第一次分配不成功，说明内存已经很紧张了，那就换成min版本的kmem_cache_order_objects。</p>
<p>好了，这个复杂的层层分配机制，我们就讲到这里，你理解到这里也就够用了。</p>
<h3 id="19-2-页面换出"><a href="#19-2-页面换出" class="headerlink" title="19.2 页面换出"></a>19.2 页面换出</h3><p>另一个物理内存管理必须要处理的事情就是，页面换出。每个进程都有自己的虚拟地址空间，无论是32位还是64位，虚拟地址空间都非常大，物理内存不可能有这么多的空间放得下。所以，一般情况下，页面只有在被使用的时候，才会放在物理内存中。如果过了一段时间不被使用，即便用户进程并没有释放它，物理内存管理也有责任做一定的干预。例如，将这些物理内存中的页面换出到硬盘上去；将空出的物理内存，交给活跃的进程去使用。</p>
<p>什么情况下会触发页面换出呢？</p>
<p>可以想象，最常见的情况就是，分配内存的时候，发现没有地方了，就试图回收一下。例如，咱们解析申请一个页面的时候，会调用get_page_from_freelist，接下来的调用链为get_page_from_freelist-&gt;node_reclaim-&gt;__node_reclaim-&gt;shrink_node，通过这个调用链可以看出，页面换出也是以内存节点为单位的。</p>
<p>当然还有一种情况，就是作为内存管理系统应该主动去做的，而不能等真的出了事儿再做，这就是内核线程<strong>kswapd</strong>。这个内核线程，在系统初始化的时候就被创建。这样它会进入一个无限循环，直到系统停止。在这个循环中，如果内存使用没有那么紧张，那它就可以放心睡大觉；如果内存紧张了，就需要去检查一下内存，看看是否需要换出一些内存页。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * The background pageout daemon, started as a kernel thread
 * from the init process.
 *
 * This basically trickles out pages so that we have _some_
 * free memory available even if there is no other activity
 * that frees anything up. This is needed for things like routing
 * etc, where we otherwise might have all activity going on in
 * asynchronous contexts that cannot page things out.
 *
 * If there are applications that are active memory-allocators
 * (most normal use), this basically shouldn't matter.
 */</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">kswapd</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> alloc_order<span class="token punctuation">,</span> reclaim_order<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> classzone_idx <span class="token operator">=</span> MAX_NR_ZONES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    pg_data_t <span class="token operator">*</span>pgdat <span class="token operator">=</span> <span class="token punctuation">(</span>pg_data_t<span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk <span class="token operator">=</span> current<span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token function">kswapd_try_to_sleep</span><span class="token punctuation">(</span>pgdat<span class="token punctuation">,</span> alloc_order<span class="token punctuation">,</span> reclaim_order<span class="token punctuation">,</span>
                    classzone_idx<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        reclaim_order <span class="token operator">=</span> <span class="token function">balance_pgdat</span><span class="token punctuation">(</span>pgdat<span class="token punctuation">,</span> alloc_order<span class="token punctuation">,</span> classzone_idx<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里的调用链是balance_pgdat-&gt;kswapd_shrink_node-&gt;shrink_node，是以内存节点为单位的，最后也是调用shrink_node。</p>
<p>shrink_node会调用shrink_node_memcg。这里面有一个循环处理页面的列表，看这个函数的注释，其实和上面我们想表达的内存换出是一样的。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * This is a basic per-node page freer.  Used by both kswapd and direct reclaim.
 */</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">shrink_node_memcg</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pglist_data</span> <span class="token operator">*</span>pgdat<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">mem_cgroup</span> <span class="token operator">*</span>memcg<span class="token punctuation">,</span>
                  <span class="token keyword">struct</span> <span class="token class-name">scan_control</span> <span class="token operator">*</span>sc<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span>lru_pages<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> nr<span class="token punctuation">[</span>NR_LRU_LISTS<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">enum</span> <span class="token class-name">lru_list</span> lru<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>nr<span class="token punctuation">[</span>LRU_INACTIVE_ANON<span class="token punctuation">]</span> <span class="token operator">||</span> nr<span class="token punctuation">[</span>LRU_ACTIVE_FILE<span class="token punctuation">]</span> <span class="token operator">||</span>
                    nr<span class="token punctuation">[</span>LRU_INACTIVE_FILE<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> nr_anon<span class="token punctuation">,</span> nr_file<span class="token punctuation">,</span> percentage<span class="token punctuation">;</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> nr_scanned<span class="token punctuation">;</span>

        <span class="token function">for_each_evictable_lru</span><span class="token punctuation">(</span>lru<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nr<span class="token punctuation">[</span>lru<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                nr_to_scan <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>nr<span class="token punctuation">[</span>lru<span class="token punctuation">]</span><span class="token punctuation">,</span> SWAP_CLUSTER_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>
                nr<span class="token punctuation">[</span>lru<span class="token punctuation">]</span> <span class="token operator">-=</span> nr_to_scan<span class="token punctuation">;</span>

                nr_reclaimed <span class="token operator">+=</span> <span class="token function">shrink_list</span><span class="token punctuation">(</span>lru<span class="token punctuation">,</span> nr_to_scan<span class="token punctuation">,</span>
                                lruvec<span class="token punctuation">,</span> memcg<span class="token punctuation">,</span> sc<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面有个lru列表。从下面的定义，我们可以想象，所有的页面都被挂在LRU列表中。LRU是Least Recent Use，也就是最近最少使用。也就是说，这个列表里面会按照活跃程度进行排序，这样就容易把不怎么用的内存页拿出来做处理。</p>
<p>内存页总共分两类，一类是<strong>匿名页</strong>，和虚拟地址空间进行关联；一类是<strong>内存映射</strong>，不但和虚拟地址空间关联，还和文件管理关联。</p>
<p>它们每一类都有两个列表，一个是active，一个是inactive。顾名思义，active就是比较活跃的，inactive就是不怎么活跃的。这两个里面的页会变化，过一段时间，活跃的可能变为不活跃，不活跃的可能变为活跃。如果要换出内存，那就是从不活跃的列表中找出最不活跃的，换出到硬盘上。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span> <span class="token class-name">lru_list</span> <span class="token punctuation">{</span>
    LRU_INACTIVE_ANON <span class="token operator">=</span> LRU_BASE<span class="token punctuation">,</span>
    LRU_ACTIVE_ANON <span class="token operator">=</span> LRU_BASE <span class="token operator">+</span> LRU_ACTIVE<span class="token punctuation">,</span>
    LRU_INACTIVE_FILE <span class="token operator">=</span> LRU_BASE <span class="token operator">+</span> LRU_FILE<span class="token punctuation">,</span>
    LRU_ACTIVE_FILE <span class="token operator">=</span> LRU_BASE <span class="token operator">+</span> LRU_FILE <span class="token operator">+</span> LRU_ACTIVE<span class="token punctuation">,</span>
    LRU_UNEVICTABLE<span class="token punctuation">,</span>
    NR_LRU_LISTS
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">for_each_evictable_lru</span><span class="token punctuation">(</span>lru<span class="token punctuation">)</span> <span class="token keyword">for</span> <span class="token punctuation">(</span>lru <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> lru <span class="token operator">&lt;=</span> LRU_ACTIVE_FILE<span class="token punctuation">;</span> lru<span class="token operator">++</span><span class="token punctuation">)</span></span></span>

<span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">shrink_list</span><span class="token punctuation">(</span><span class="token keyword">enum</span> <span class="token class-name">lru_list</span> lru<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> nr_to_scan<span class="token punctuation">,</span>
                 <span class="token keyword">struct</span> <span class="token class-name">lruvec</span> <span class="token operator">*</span>lruvec<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">mem_cgroup</span> <span class="token operator">*</span>memcg<span class="token punctuation">,</span>
                 <span class="token keyword">struct</span> <span class="token class-name">scan_control</span> <span class="token operator">*</span>sc<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_active_lru</span><span class="token punctuation">(</span>lru<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">inactive_list_is_low</span><span class="token punctuation">(</span>lruvec<span class="token punctuation">,</span> <span class="token function">is_file_lru</span><span class="token punctuation">(</span>lru<span class="token punctuation">)</span><span class="token punctuation">,</span>
                     memcg<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> true<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token function">shrink_active_list</span><span class="token punctuation">(</span>nr_to_scan<span class="token punctuation">,</span> lruvec<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> lru<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token function">shrink_inactive_list</span><span class="token punctuation">(</span>nr_to_scan<span class="token punctuation">,</span> lruvec<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> lru<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从上面的代码可以看出，shrink_list会先缩减活跃页面列表，再压缩不活跃的页面列表。对于不活跃列表的缩减，shrink_inactive_list就需要对页面进行回收；对于匿名页来讲，需要分配swap，将内存页写入文件系统；对于内存映射关联了文件的，我们需要将在内存中对于文件的修改写回到文件中。</p>
<h3 id="19-3-总结"><a href="#19-3-总结" class="headerlink" title="19.3 总结"></a>19.3 总结</h3><p>对于物理内存来讲，从下层到上层的关系及分配模式如下：</p>
<ul>
<li>物理内存分NUMA节点，分别进行管理；</li>
<li>每个NUMA节点分成多个内存区域；</li>
<li>每个内存区域分成多个物理页面；</li>
<li>伙伴系统将多个连续的页面作为一个大的内存块分配给上层；</li>
<li>kswapd负责物理页面的换入换出；</li>
<li>Slub Allocator将从伙伴系统申请的大内存块切成小块，分配给其他系统。</li>
</ul>
<p><img src="/images/《趣谈Linux操作系统》学习笔记/物理内存的管理.jpeg" alt="物理内存的管理"></p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://kibazen.cn" rel="external nofollow noreferrer">Kiba Amor</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                    </span>
                <span class="reprint-info">
                    <a href="https://kibazen.cn/qu-tan-linux-cao-zuo-xi-tong-xue-xi-bi-ji/">https://kibazen.cn/qu-tan-linux-cao-zuo-xi-tong-xue-xi-bi-ji/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY-NC-ND 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://kibazen.cn" target="_blank">Kiba Amor</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                                    <span class="chip bg-color">极客时间</span>
                                </a>
                            
                                <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                                    <span class="chip bg-color">操作系统</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="qq,wechat,weibo,douban" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/qu-tan-linux-cao-zuo-xi-tong-xue-xi-bi-ji/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/17.jpg" class="responsive-img" alt="《趣谈Linux操作系统》学习笔记">
                        
                        <span class="card-title">《趣谈Linux操作系统》学习笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-11-25
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                    学习笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                        <span class="chip bg-color">极客时间</span>
                    </a>
                    
                    <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                        <span class="chip bg-color">操作系统</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/linux-xing-neng-you-hua-shi-zhan-xue-xi-bi-ji/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/7.jpg" class="responsive-img" alt="《Linux性能优化实战》学习笔记">
                        
                        <span class="card-title">《Linux性能优化实战》学习笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-11-04
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                    学习笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/">
                        <span class="chip bg-color">性能分析</span>
                    </a>
                    
                    <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                        <span class="chip bg-color">极客时间</span>
                    </a>
                    
                    <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">
                        <span class="chip bg-color">性能优化</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (true) {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 木叶禅<br />'
            + '文章作者: Kiba Amor<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者木叶禅所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('2'),
            headingSelector: 'h2, h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2021</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">Kiba Amor</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">454.8k</span>&nbsp;字
            
            
            
            
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/kibaamor" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>









    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=562236616" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 562236616" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>





    <a href="https://www.zhihu.com/people/kibaamor" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/kibaamor" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    

    

    

	
    

    

    

    
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
