<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <meta name="keywords" content="《透视HTTP协议》学习笔记, kiba, zen, amor, kibazen, kibaamor, 木叶, 木叶禅">
    <meta name="description" content="You are too concerned with what was and what will be">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>《透视HTTP协议》学习笔记 | 木叶禅</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/css/my.css">

    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="木叶禅" type="application/atom+xml">
</head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">木叶禅</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/learn/" class="waves-effect waves-light">
      
      <i class="fas fa-book" style="zoom: 0.6;"></i>
      
      <span>Learn</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/memo/" class="waves-effect waves-light">
      
      <i class="fas fa-sticky-note" style="zoom: 0.6;"></i>
      
      <span>Memo</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories/" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags/" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about/" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">木叶禅</div>
        <div class="logo-desc">
            
            You are too concerned with what was and what will be
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/learn/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-book"></i>
			
			Learn
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/memo/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-sticky-note"></i>
			
			Memo
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    
<script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = 'f65e070788a2647953051a7a1b70ada7fd2b3f70cd4d93c977207f5b762987d4';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/9.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">《透视HTTP协议》学习笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/HTTP/">
                                <span class="chip bg-color">HTTP</span>
                            </a>
                        
                            <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                                <span class="chip bg-color">极客时间</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                学习笔记
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-08-26
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2024-08-30
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    19.3k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    71 分
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone git@github.com:kibaamor/http_study.git

<span class="token builtin class-name">cd</span> http_study/www

./run.sh start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编辑hosts，添加</p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">127.0.0.1       www.chrono.com
127.0.0.1       www.metroid.net
127.0.0.1       origin.io<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>浏览器使用 firefox 测试。</p>
</blockquote>
<h2 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h2><p>RFC 标准把状态码分成了五类：</p>
<ul>
<li><p><code>1××</code>：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；</p>
<p>  我们偶尔能够见到的是”101 Switching Protocols”。它的意思是客户端使用 Upgrade 头字段，要求在 HTTP 协议的基础上改成其他的协议继续通信，比如 WebSocket。而如果服务器也同意变更协议，就会发送状态码 101，但这之后的数据传输就不会再使用 HTTP 了。</p>
</li>
<li><p><code>2××</code>：成功，报文已经收到并被正确处理；</p>
<p>  “200 OK” 是最常见的成功状态码，表示一切正常，服务器如客户端所期望的那样返回了处理结果，如果是非 HEAD 请求，通常在响应头后都会有 body 数据。</p>
<p>  “204 No Content” 是另一个很常见的成功状态码，它的含义与”200 OK”基本相同，但响应头后没有 body 数据。所以对于 Web 服务器来说，正确地区分 200 和 204 是很必要的。</p>
<p>  “206 Partial Content” 是 HTTP 分块下载或断点续传的基础，在客户端发送”范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分。</p>
<p>  状态码 206 通常还会伴随着头字段 “Content-Range”，表示响应报文里 body 数据的具体范围，供客户端确认，例如 “Content-Range: bytes 0-99/2000”，意思是此次获取的是总计 2000 个字节的前 100 个字节。</p>
</li>
<li><p><code>3××</code>：重定向，资源位置发生变动，需要客户端重新发送请求；</p>
<p>  “301 Moved Permanently”俗称”永久重定向”，含义是此次请求的资源已经不存在了，需要改用改用新的 URI 再次访问。</p>
<p>  与它类似的是”302 Found”，曾经的描述短语是”Moved Temporarily”，俗称”临时重定向”，意思是请求的资源还在，但需要暂时用另一个 URI 来访问。</p>
<p>  “304 Not Modified” 是一个比较有意思的状态码，它用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成”重定向已到缓存的文件”（即”缓存重定向”）。</p>
<blockquote>
<p>301 和 302 还另有两个等价的状态码 “308Permanent Redirect” 和 “307 TemporaryRedirect”，但这两个状态码不允许后续的请求更改请求方法。</p>
</blockquote>
</li>
<li><p><code>4××</code>：客户端错误，请求报文有误，服务器无法处理；</p>
<p>  “400 Bad Request”是一个通用的错误码，表示请求报文有错误，但具体是数据格式错误、缺少请求头还是 URI 超长它没有明确说，只是一个笼统的错误，客户端看到 400 只会是”一头雾水””不知所措”。所以，在开发 Web 应用时应当尽量避免给客户端返回 400，而是要用其他更有明确含义的状态码。</p>
<p>  “403 Forbidden”实际上不是客户端的请求出错，而是表示服务器禁止访问资源。原因可能多种多样，例如信息敏感、法律禁止等，如果服务器友好一点，可以在 body 里详细说明拒绝请求的原因，不过现实中通常都是直接给一个”闭门羹”。</p>
<p>  “404 Not Found”可能是我们最常看见也是最不愿意看到的一个状态码，它的原意是资源在本服务器上未找到，所以无法提供给客户端。但现在已经被”用滥了”，只要服务器”不高兴”就可以给出个 404，而我们也无从得知后面到底是真的未找到，还是有什么别的原因，某种程度上它比 403 还要令人讨厌。</p>
<p>  <code>4××</code> 里剩下的一些代码较明确地说明了错误的原因，都很好理解，开发中常用的有：</p>
<ul>
<li>405 Method Not Allowed：不允许使用某些方法操作资源，例如不允许 POST 只能 GET；</li>
<li>406 Not Acceptable：资源无法满足客户端请求的条件，例如请求中文但只有英文；</li>
<li>408 Request Timeout：请求超时，服务器等待了过长的时间；</li>
<li>409 Conflict：多个请求发生了冲突，可以理解为多线程并发时的竞态；</li>
<li>413 Request Entity Too Large：请求报文里的 body 太大；</li>
<li>414 Request-URI Too Long：请求行里的 URI 太大；</li>
<li>429 Too Many Requests：客户端发送了太多的请求，通常是由于服务器的限连策略；</li>
<li>431 Request Header Fields Too Large：请求头某个字段或总体太大；</li>
</ul>
</li>
<li><p><code>5××</code>：服务器错误，服务器在处理请求时内部发生了错误。</p>
<p>  “500 Internal Server Error”与 400 类似，也是一个通用的错误码，服务器究竟发生了什么错误我们是不知道的。不过对于服务器来说这应该算是好事，通常不应该把服务器内部的详细信息，例如出错的函数调用栈告诉外界。虽然不利于调试，但能够防止黑客的窥探或者分析。</p>
<p>  “501 Not Implemented”表示客户端请求的功能还不支持，这个错误码比 500 要”温和”一些，和”即将开业，敬请期待”的意思差不多，不过具体什么时候”开业”就不好说了。</p>
<p>  “502 Bad Gateway”通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的。</p>
<p>  “503 Service Unavailable”表示服务器当前很忙，暂时无法响应服务，我们上网时有时候遇到的”网络服务正忙，请稍后重试”的提示信息就是状态码 503。</p>
<p>  503 是一个”临时”的状态，很可能过几秒钟后服务器就不那么忙了，可以继续提供服务，所以 503 响应报文里通常还会有一个”Retry-After”字段，指示客户端可以在多久以后再次尝试发送请求。</p>
</li>
</ul>
<h2 id="HTTP-的实体数据"><a href="#HTTP-的实体数据" class="headerlink" title="HTTP 的实体数据"></a>HTTP 的实体数据</h2><h3 id="MIME"><a href="#MIME" class="headerlink" title="MIME"></a>MIME</h3><p>MIME 用在电子邮件系统里的，让电子邮件可以发送 ASCII 码以外的任意数据，方案的名字叫做”多用途互联网邮件扩展”（Multipurpose Internet Mail Extensions），简称为 MIME。</p>
<p>MIME 是一个很大的标准规范，但 HTTP 只”顺手牵羊”取了其中的一部分，用来标记 body 的数据类型，这就是我们平常总能听到的”MIME type”。</p>
<p>MIME 把数据分成了八大类，每个大类下再细分出多个子类，形式是”type/subtype”的字符串。</p>
<h3 id="Encoding-type"><a href="#Encoding-type" class="headerlink" title="Encoding type"></a>Encoding type</h3><p>HTTP 在传输时为了节约带宽，有时候还会压缩数据，为了不要让浏览器继续”猜”，还需要有一个”Encoding type”，告诉数据是用的什么编码格式，这样对方才能正确解压缩，还原出原始的数据。</p>
<p>常用的只有下面三种：</p>
<ul>
<li>gzip：GNU zip 压缩格式，也是互联网上最流行的压缩格式；</li>
<li>deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip；</li>
<li>br：一种专门为 HTTP 优化的新压缩算法（Brotli）。</li>
</ul>
<h3 id="Accept-Content-头"><a href="#Accept-Content-头" class="headerlink" title="Accept/Content 头"></a>Accept/Content 头</h3><p>Accept字段标记的是客户端可理解的 MIME type，可以用”,”做分隔符列出多个类型，让服务器有更多的选择余地，例如下面的这个头：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">Accept: text/html,application/xml,image/webp,image/png<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>相应的，服务器会在响应报文里用头字段Content-Type告诉实体数据的真实类型：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">Content-Type: text/html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="Accept-Encoding-Content-Encoding-头"><a href="#Accept-Encoding-Content-Encoding-头" class="headerlink" title="Accept-Encoding/Content-Encoding 头"></a>Accept-Encoding/Content-Encoding 头</h3><p>Accept-Encoding字段标记的是客户端支持的压缩格式，例如上面说的 gzip、deflate 等，同样也可以用”,”列出多个，服务器可以选择其中一种来压缩数据，实际使用的压缩格式放在响应头字段Content-Encoding里。</p>
<p>不过这两个字段是可以省略的，如果请求报文里没有 Accept-Encoding 字段，就表示客户端不支持压缩数据；如果响应报文里没有 Content-Encoding 字段，就表示响应数据没有被压缩。</p>
<h3 id="Accept-Language-Content-Language-头"><a href="#Accept-Language-Content-Language-头" class="headerlink" title="Accept-Language/Content-Language 头"></a>Accept-Language/Content-Language 头</h3><p>“语言类型”就是人类使用的自然语言，例如英语、汉语、日语等，而这些自然语言可能还有下属的地区性方言，所以在需要明确区分的时候也要使用”type-subtype”的形式，不过这里的格式与数据类型不同，分隔符不是”/“，而是”-“。</p>
<p>同样的，HTTP 协议也使用 Accept 请求头字段和 Content 实体头字段，用于客户端和服务器就语言与编码进行”内容协商”。</p>
<p>Accept-Language字段标记了客户端可理解的自然语言，也允许用”,”做分隔符列出多个类型，例如：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">Accept-Language: zh-CN, zh, en<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个请求头会告诉服务器：”最好给我 zh-CN 的汉语文字，如果没有就用其他的汉语方言，如果还没有就给英文”。</p>
<p>相应的，服务器应该在响应报文里用头字段Content-Language告诉客户端实体数据使用的实际语言类型：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">Content-Language: zh-CN<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="Accept-Charset-Content-Type-头"><a href="#Accept-Charset-Content-Type-头" class="headerlink" title="Accept-Charset/Content-Type 头"></a>Accept-Charset/Content-Type 头</h3><p>字符集在 HTTP 里使用的请求头字段是Accept-Charset，但响应头里却没有对应的 Content-Charset，而是在Content-Type字段的数据类型后面用”charset=xxx”来表示，这点需要特别注意。</p>
<p>例如，浏览器请求 GBK 或 UTF-8 的字符集，然后服务器返回的是 UTF-8 编码，就是下面这样：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">Accept-Charset: gbk, utf-8
Content-Type: text/html; charset=utf-8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>不过现在的浏览器都支持多种字符集，通常不会发送 Accept-Charset，而服务器也不会发送 Content-Language，因为使用的语言完全可以由字符集推断出来，所以在请求头里一般只会有 Accept-Language 字段，响应头里只会有 Content-Type 字段。</p>
<h3 id="内容协商的质量值"><a href="#内容协商的质量值" class="headerlink" title="内容协商的质量值"></a>内容协商的质量值</h3><p>在 HTTP 协议里用 Accept、Accept-Encoding、Accept-Language 等请求头字段进行内容协商的时候，还可以用一种特殊的”q”参数表示权重来设定优先级，这里的”q”是”quality factor”的意思。</p>
<p>权重的最大值是 1，最小值是 0.01，默认值是 1，如果值是 0 就表示拒绝。具体的形式是在数据类型或语言代码后面加一个”;”，然后是”q=value”。</p>
<p>这里要提醒的是”;”的用法，在大多数编程语言里”;”的断句语气要强于”,”，而在 HTTP 的内容协商里却恰好反了过来，”;”的意义是小于”,”的。</p>
<p>例如下面的 Accept 字段：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">Accept: text/html,application/xml;q=0.9,*/*;q=0.8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>它表示浏览器最希望使用的是 HTML 文件，权重是 1，其次是 XML 文件，权重是 0.9，最后是任意数据类型，权重是 0.8。服务器收到请求头后，就会计算权重，再根据自己的实际情况优先输出 HTML 或者 XML。</p>
<h3 id="内容协商的结果"><a href="#内容协商的结果" class="headerlink" title="内容协商的结果"></a>内容协商的结果</h3><p>内容协商的过程是不透明的，每个 Web 服务器使用的算法都不一样。但有的时候，服务器会在响应头里多加一个Vary字段，记录服务器在内容协商时参考的请求头字段，给出一点信息，例如：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">Vary: Accept-Encoding,User-Agent,Accept<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个 Vary 字段表示服务器依据了 Accept-Encoding、User-Agent 和 Accept 这三个头字段，然后决定了发回的响应报文。</p>
<p>Vary 字段可以认为是响应报文的一个特殊的”版本标记”。每当 Accept 等请求头变化时，Vary 也会随着响应报文一起变化。也就是说，同一个 URI 可能会有多个不同的”版本”，主要用在传输链路中间的代理服务器实现缓存服务。</p>
<h2 id="HTTP传输大文件的方法"><a href="#HTTP传输大文件的方法" class="headerlink" title="HTTP传输大文件的方法"></a>HTTP传输大文件的方法</h2><p>压缩 HTML 等文本文件是传输大文件最基本的方法。</p>
<h3 id="分块传输"><a href="#分块传输" class="headerlink" title="分块传输"></a>分块传输</h3><p>“化整为零”的思路在 HTTP 协议里就是”chunked”分块传输编码，在响应报文里用头字段”Transfer-Encoding: chunked”来表示，意思是报文里的 body 部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送。</p>
<p>分块传输可以流式收发数据，节约内存和带宽，使用响应头字段”Transfer-Encoding: chunked”来表示，分块的格式是 16 进制长度头 + 数据块。</p>
<p>“Transfer-Encoding: chunked”和”Content-Length”这两个字段是互斥的，也就是说响应报文里这两个字段不能同时出现，一个响应报文的传输要么是长度已知，要么是长度未知（chunked）。</p>
<h3 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h3><p>HTTP 协议允许客户端在请求头里使用专用字段来表示只获取文件的一部分，相当于是客户端的”化整为零”。</p>
<p>服务器必须在响应头里使用字段”Accept-Ranges: bytes”明确告知客户端：”我是支持范围请求的”。如果不支持的话该怎么办呢？服务器可以发送”Accept-Ranges: none”，或者干脆不发送”Accept-Ranges”字段。</p>
<p>请求头Range是 HTTP 范围请求的专用字段，格式是”bytes=x-y”，其中的 x 和 y 是以字节为单位的数据范围。</p>
<p>要注意 x、y 表示的是”偏移量”，范围必须从 0 计数，例如前 10 个字节表示为”0-9”，第二个 10 字节表示为”10-19”，而”0-10”实际上是前 11 个字节。</p>
<p>Range 的格式也很灵活，起点 x 和终点 y 可以省略，能够很方便地表示正数或者倒数的范围。假设文件是 100 个字节，那么：</p>
<ul>
<li>“0-“表示从文档起点到文档终点，相当于”0-99”，即整个文件；</li>
<li>“10-“是从第 10 个字节开始到文档末尾，相当于”10-99”；</li>
<li>“-1”是文档的最后一个字节，相当于”99-99”；</li>
<li>“-10”是从文档末尾倒数 10 个字节，相当于”90-99”。</li>
</ul>
<p>服务器收到 Range 字段后，需要做四件事。</p>
<p>第一，它必须检查范围是否合法，比如文件只有 100 个字节，但请求”200-300”，这就是范围越界了。服务器就会返回状态码416，意思是”你的范围请求有误，我无法处理，请再检查一下”。</p>
<p>第二，如果范围正确，服务器就可以根据 Range 头计算偏移量，读取文件的片段了，返回状态码”206 Partial Content”，和 200 的意思差不多，但表示 body 只是原数据的一部分。</p>
<p>第三，服务器要添加一个响应头字段Content-Range，告诉片段的实际偏移量和资源的总大小，格式是”bytes x-y/length”，与 Range 头区别在没有”=”，范围后多了总长度。例如，对于”0-10”的范围请求，值就是”bytes 0-10/100”。</p>
<p>最后剩下的就是发送数据了，直接把片段用 TCP 发给客户端，一个范围请求就算是处理完了。</p>
<p>有了范围请求之后，HTTP 处理大文件就更加轻松了，看视频时可以根据时间点计算出文件的 Range，不用下载整个文件，直接精确获取片段所在的数据内容。</p>
<p>不仅看视频的拖拽进度需要范围请求，常用的下载工具里的多段下载、断点续传也是基于它实现的，要点是：</p>
<ul>
<li>先发个 HEAD，看服务器是否支持范围请求，同时获取文件的大小；</li>
<li>开 N 个线程，每个线程使用 Range 字段划分出各自负责下载的片段，发请求传输数据；</li>
<li>下载意外中断也不怕，不必重头再来一遍，只要根据上次的下载记录，用 Range 请求剩下的那一部分就可以了。</li>
</ul>
<h3 id="多段数据"><a href="#多段数据" class="headerlink" title="多段数据"></a>多段数据</h3><p>刚才说的范围请求一次只获取一个片段，其实它还支持在 Range 头里使用多个”x-y”，一次性获取多个片段数据。</p>
<p>这种情况需要使用一种特殊的 MIME 类型：”multipart/byteranges”，表示报文的 body 是由多段字节序列组成的，并且还要用一个参数”boundary=xxx”给出段之间的分隔标记。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《透视HTTP协议》学习笔记/多段数据.png" alt="多段数据"></p>
<p>每一个分段必须以”—boundary”开始（前面加两个”-“），之后要用”Content-Type”和”Content-Range”标记这段数据的类型和所在范围，然后就像普通的响应头一样以回车换行结束，再加上分段数据，最后用一个”- -boundary- -“（前后各有两个”-“）表示所有的分段结束。</p>
<p>例如，请求</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">GET /16-2 HTTP/1.1
Host: www.chrono.com
Range: bytes=0-9, 20-29<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>响应</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">HTTP/1.1 206 Partial Content
Content-Type: multipart/byteranges; boundary=00000000001
Content-Length: 189
Connection: keep-alive
Accept-Ranges: bytes

--00000000001
Content-Type: text/plain
Content-Range: bytes 0-9/96

// this is
--00000000001
Content-Type: text/plain
Content-Range: bytes 20-29/96

ext json d
--00000000001--<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="课外小贴士"><a href="#课外小贴士" class="headerlink" title="课外小贴士"></a>课外小贴士</h3><ol>
<li>gzip 的压缩率通常能够超过 60%，而 br 算法是专为 HTML 设计的，压缩效率和性能比 gzip还要好，能够再提高 20%的压缩密度。</li>
<li>Nginx 的”gzip on”指令很智能，只会压缩文本数据，不会压缩图片、音频、视频。</li>
<li>Transfer-Encoding 字段最常见的值是chunked，但也可以用 gzip、deflate 等，表示传输时使用了压缩编码。注意这与 Content-Encoding 不同，Transfer-Encoding 在传输后会被自动解码还原出原始数据，而 Content-Encoding 则必须由应用自行解码</li>
<li>分块传输在未尾还允许有”拖尾数据”，由响应头字段 Trailer 指定。</li>
</ol>
<h2 id="HTTP-的连接管理"><a href="#HTTP-的连接管理" class="headerlink" title="HTTP 的连接管理"></a>HTTP 的连接管理</h2><h3 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h3><p>客户端发送请求前需要先与服务器建立连接，收到响应报文后会立即关闭连接。</p>
<blockquote>
<p>是客户端主动关闭的连接。</p>
</blockquote>
<h3 id="连接相关的头字段"><a href="#连接相关的头字段" class="headerlink" title="连接相关的头字段"></a>连接相关的头字段</h3><p>客户端可以在请求头里明确地要求使用长连接机制，使用的字段是Connection，值是”keep-alive”。</p>
<p>如果服务器支持长连接，它总会在响应报文里放一个”Connection: keep-alive”字段，告诉客户端服务器是支持长连接的。</p>
<p>长连接也需要在恰当的时间关闭，不能永远保持与服务器的连接，这在客户端或者服务器都可以做到。</p>
<p>在客户端，可以在请求头里加上”Connection: close”字段，告诉服务器：”这次通信后就关闭连接”。服务器看到这个字段，就知道客户端要主动关闭连接，于是在响应报文里也加上这个字段，发送之后就调用 Socket API 关闭 TCP 连接。</p>
<p>服务器端通常不会主动关闭连接，但也可以使用一些策略。拿 Nginx 来举例，它有两种方式：</p>
<ul>
<li>使用”keepalive_timeout”指令，设置长连接的超时时间，如果在一段时间内连接上没有任何数据收发就主动断开连接，避免空闲连接占用系统资源。</li>
<li>使用”keepalive_requests”指令，设置长连接上可发送的最大请求次数。比如设置成 1000，那么当 Nginx 在这个连接上处理了 1000 个请求后，也会主动断开连接。</li>
</ul>
<p>另外，客户端和服务器都可以在报文里附加通用头字段”Keep-Alive: timeout=value”，限定长连接的超时时间。但这个字段的约束力并不强，通信的双方可能并不会遵守，所以不太常见。</p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>因为”请求 - 应答”模型不能变，所以”队头阻塞”问题在 HTTP/1.1 里无法解决，只能缓解，有什么办法呢？</p>
<p>这在 HTTP 里就是”并发连接”（concurrent connections），也就是同时对一个域名发起多个长连接，用数量来解决质量的问题。</p>
<p>但这种方式也存在缺陷。如果每个客户端都想自己快，建立很多个连接，用户数×并发数就会是个天文数字。服务器的资源根本就扛不住，或者被服务器认为是恶意攻击，反而会造成”拒绝服务”。</p>
<p>所以，HTTP 协议建议客户端使用并发，但不能”滥用”并发。RFC2616 里明确限制每个客户端最多并发 2 个连接。不过实践证明这个数字实在是太小了，众多浏览器都”无视”标准，把这个上限提高到了 6~8。后来修订的 RFC7230 也就”顺水推舟”，取消了这个”2”的限制。</p>
<p>但”并发连接”所压榨出的性能也跟不上高速发展的互联网无止境的需求，还有什么别的办法吗？</p>
<p>这个就是”域名分片”（domain sharding）技术，还是用数量来解决质量的思路。</p>
<p>HTTP 协议和浏览器不是限制并发连接数量吗？好，那我就多开几个域名，比如 shard1.chrono.com、shard2.chrono.com，而这些域名都指向同一台服务器 www.chrono.com。</p>
<h3 id="课外小贴士-1"><a href="#课外小贴士-1" class="headerlink" title="课外小贴士"></a>课外小贴士</h3><ol>
<li>因为 TCP 协议还有” 慢启动 “” 拥塞窗口”等特性，通常新建立的”冷连接”会比打开了一段时间的”热连接”要慢一些，所以长连接比短连接还多了这一层的优势。</li>
<li>在长连接中的一个重要问题是如何正确地区分多个报文的开始和结束，所以最好总使用”Content-Length”头明确响应实体的长度正确标记报文结束。如果是流式传输，body长度不能立即确定，就必须用分块传输编码。</li>
<li>利用 HTTP 的长连接特性对服务器发起大量请求，导致服务器最终耗尽资源”拒绝服务”这就是常说的 DDoS</li>
<li>HTTP 的连接管理还有第三种方式 pipeline(管道，或者叫流水线)，它在长连接的基础上又进了一步，可以批量发送请求批量接收响应，但因为存在一些问题，Chrome、Firefox等浏览器都没有实现它，已经被事实上”废弃”了。</li>
<li>Connection 字段还有一个取值 “Connection: Upgrade”,配合状态码 101 表示协议升级,例如从 HTTP 切换到 WebSocket.</li>
</ol>
<h2 id="HTTP的重定向和跳转"><a href="#HTTP的重定向和跳转" class="headerlink" title="HTTP的重定向和跳转"></a>HTTP的重定向和跳转</h2><h3 id="重定向的过程"><a href="#重定向的过程" class="headerlink" title="重定向的过程"></a>重定向的过程</h3><p>重定向是服务器发起的跳转，要求客户端改用新的 URI 重新发送请求，通常会自动进行，用户是无感知的；</p>
<p>“Location”字段属于响应字段，必须出现在响应报文里。但只有配合 301/302 状态码才有意义，它标记了服务器要求重定向的 URI。</p>
<p>响应头字段 Location 指示了要跳转的 URI，可以用绝对或相对的形式；</p>
<h3 id="重定向状态码"><a href="#重定向状态码" class="headerlink" title="重定向状态码"></a>重定向状态码</h3><p>301俗称”永久重定向”（Moved Permanently），意思是原 URI 已经”永久”性地不存在了，今后的所有请求都必须改用新的 URI。</p>
<p>浏览器看到 301，就知道原来的 URI”过时”了，就会做适当的优化。比如历史记录、更新书签，下次可能就会直接用新的 URI 访问，省去了再次跳转的成本。搜索引擎的爬虫看到 301，也会更新索引库，不再使用老的 URI。</p>
<p>302俗称”临时重定向”（”Moved Temporarily”），意思是原 URI 处于”临时维护”状态，新的 URI 是起”顶包”作用的”临时工”。</p>
<p>浏览器或者爬虫看到 302，会认为原来的 URI 仍然有效，但暂时不可用，所以只会执行简单的跳转页面，不记录新的 URI，也不会有其他的多余动作，下次访问还是用原 URI。</p>
<p>301/302 是最常用的重定向状态码，在 3××里剩下的几个还有：</p>
<ul>
<li>303 See Other：类似 302，但要求重定向后的请求改为 GET 方法，访问一个结果页面，避免 POST/PUT 重复操作；</li>
<li>307 Temporary Redirect：类似 302，但重定向后请求里的方法和实体不允许变动，含义比 302 更明确；</li>
<li>308 Permanent Redirect：类似 307，不允许重定向后的请求变动，但它是 301”永久重定向”的含义。</li>
</ul>
<p>不过这三个状态码的接受程度较低，有的浏览器和服务器可能不支持，开发时应当慎重，测试确认浏览器的实际效果后才能使用。</p>
<p>HTTP 协议特别规定，浏览器必须具有检测”循环跳转”的能力，在发现这种情况时应当停止发送请求并给出错误提示。</p>
<h3 id="重定向的相关问题"><a href="#重定向的相关问题" class="headerlink" title="重定向的相关问题"></a>重定向的相关问题</h3><p>HTTP 协议特别规定，浏览器必须具有检测”循环跳转”的能力，在发现这种情况时应当停止发送请求并给出错误提示。</p>
<h3 id="课外小贴士-2"><a href="#课外小贴士-2" class="headerlink" title="课外小贴士"></a>课外小贴士</h3><ol>
<li>网页的”入链接”和”出链接”也是标记网页重要性的关键指标，最著名的就是 Google 发明的 PageRank。</li>
<li>“300 Multiple Choices”也是一个特殊的重定向状态码，它会返回一个有多个链接选项的页面，由用户自行选择要跳转的链接，用的较少</li>
<li>重定向报文里还可以用 Refresh 字段，实现延时重定向，例如”Refresh: 5;url=xxx”告诉浏览器 5 秒钟后再跳转。</li>
<li>与跳转有关的还有一个”Referer”和(注意前者是个拼写错误”Referrer-Policy”但已经”将错就错”)，表示浏览器跳转的来源(即引用地址)，可用于统计分析和防盗链。</li>
</ol>
<h2 id="HTTP的Cookie机制"><a href="#HTTP的Cookie机制" class="headerlink" title="HTTP的Cookie机制"></a>HTTP的Cookie机制</h2><p>Cookie 是服务器委托浏览器存储的一些数据，让服务器有了”记忆能力”。</p>
<h3 id="Cookie-的工作过程"><a href="#Cookie-的工作过程" class="headerlink" title="Cookie 的工作过程"></a>Cookie 的工作过程</h3><p>Cookie 是由浏览器负责存储的，而不是操作系统。所以，它是”浏览器绑定”的，只能在本浏览器内生效。</p>
<p>服务器有时会在响应头里添加多个 Set-Cookie，存储多个”key=value”。但浏览器这边发送时不需要用多个 Cookie 字段，只要在一行里用”;”隔开就行。</p>
<h3 id="Cookie-的属性"><a href="#Cookie-的属性" class="headerlink" title="Cookie 的属性"></a>Cookie 的属性</h3><h4 id="有效期"><a href="#有效期" class="headerlink" title="有效期"></a>有效期</h4><p>Cookie 的有效期可以使用 Expires 和 Max-Age 两个属性来设置。</p>
<p>“Expires”俗称”过期时间”，用的是绝对时间点，可以理解为”截止日期”（deadline）。”Max-Age”用的是相对时间，单位是秒，浏览器用 <strong>收到报文的时间点</strong> 再加上 Max-Age，就可以得到失效的绝对时间。</p>
<p>Expires 和 Max-Age 可以同时出现，两者的失效时间可以一致，也可以不一致，但浏览器会优先采用 Max-Age 计算失效期。</p>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>设置 Cookie 的作用域，让浏览器仅发送给特定的服务器和 URI，避免被其他网站盗用。</p>
<p>作用域的设置比较简单，”Domain”和”Path”指定了 Cookie 所属的域名和路径，浏览器在发送 Cookie 前会从 URI 中提取出 host 和 path 部分，对比 Cookie 的属性。如果不满足条件，就不会在请求头里发送 Cookie。</p>
<p>不过现实中为了省事，通常 Path 就用一个”/“或者直接省略，表示域名下的任意路径都允许使用 Cookie，让服务器自己去挑。</p>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>写过前端的同学一定知道，在 JS 脚本里可以用 document.cookie 来读写 Cookie 数据，这就带来了安全隐患，有可能会导致”跨站脚本”（XSS）攻击窃取数据。</p>
<p>属性”HttpOnly”会告诉浏览器，此 Cookie 只能通过浏览器 HTTP 协议传输，禁止其他方式访问，浏览器的 JS 引擎就会禁用 document.cookie 等一切相关的 API，脚本攻击也就无从谈起了。</p>
<p>另一个属性”SameSite”可以防范”跨站请求伪造”（XSRF）攻击，设置成”SameSite=Strict”可以严格限定 Cookie 不能随着跳转链接跨站发送，而”SameSite=Lax”则略宽松一点，允许 GET/HEAD 等安全方法，但禁止 POST 跨站发送。</p>
<p>还有一个属性叫”Secure”，表示这个 Cookie 仅能用 HTTPS 协议加密传输，明文的 HTTP 协议会禁止发送。但 Cookie 本身不是加密的，浏览器里还是以明文的形式存在。</p>
<h3 id="Cookie-的应用"><a href="#Cookie-的应用" class="headerlink" title="Cookie 的应用"></a>Cookie 的应用</h3><p>Cookie 最基本的一个用途就是身份识别，保存用户的登录信息，实现会话事务。</p>
<p>Cookie 的另一个常见用途是广告跟踪。</p>
<p>你上网的时候肯定看过很多的广告图片，这些图片背后都是广告商网站（例如 Google），它会”偷偷地”给你贴上 Cookie 小纸条，这样你上其他的网站，别的广告就能用 Cookie 读出你的身份，然后做行为分析，再推给你广告。</p>
<p>这种 Cookie 不是由访问的主站存储的，所以又叫”第三方 Cookie”（third-party cookie）。如果广告商势力很大，广告到处都是，那么就比较”恐怖”了，无论你走到哪里它都会通过 Cookie 认出你来，实现广告”精准打击”。</p>
<p>为了防止滥用 Cookie 搜集用户隐私，互联网组织相继提出了 DNT（Do Not Track）和 P3P（Platform for Privacy Preferences Project），但实际作用不大。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>因为 Cookie 并不属于 HTTP 标准（RFC6265，而不是 RFC2616/7230），所以语法上与其他字段不太一致，使用的分隔符是”;”，与 Accept 等字段的”,”不同，小心不要弄错了。</p>
<h3 id="课外小贴士-3"><a href="#课外小贴士-3" class="headerlink" title="课外小贴士"></a>课外小贴士</h3><ol>
<li>如果Cookie的Max-Age属性设置为0，它的效果是立即删除该Cookie。</li>
<li>如果不指定 Expires 或 Max-Age 属性，那么Cookie 仅在浏览器运行时有效，一旦浏览器关闭就会失效，这被称为会话 Cookie(sessioncookie)或内存 Cookie(in-memory cookie)在 Chrome 里过期时间会显示为”Session”或”N/A” 。</li>
</ol>
<h2 id="HTTP的缓存控制"><a href="#HTTP的缓存控制" class="headerlink" title="HTTP的缓存控制"></a>HTTP的缓存控制</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/cUqkG3NETmJbglDXfSf0tg">【第1398期】一文读懂前端缓存</a></p>
<p><a href="https://kibazen.cn/zhou-zhi-ming-de-ruan-jian-jia-gou-ke-xue-xi-bi-ji/#toc-heading-89">17 | 客户端缓存是如何帮助服务器分担流量的？</a></p>
<h3 id="服务器的缓存控制"><a href="#服务器的缓存控制" class="headerlink" title="服务器的缓存控制"></a>服务器的缓存控制</h3><p>服务器标记资源有效期使用的头字段是”Cache-Control”，里面的值”max-age=30”就是资源的有效时间，相当于告诉浏览器，”这个页面只能缓存 30 秒，之后就算是过期，不能用。”</p>
<p>“Cache-Control”字段里的”max-age”和上一讲里 Cookie 有点像，都是标记资源的有效期。</p>
<p>但我必须提醒你注意，这里的 max-age 是”生存时间”（又叫”新鲜度””缓存寿命”，类似 TTL，Time-To-Live），时间的计算起点是响应报文的创建时刻（即 Date 字段，也就是离开服务器的时刻），而不是客户端收到报文的时刻，也就是说包含了在链路传输过程中所有节点所停留的时间。</p>
<blockquote>
<p>Cookie 里的max-age是从客户端收到响应开始算。</p>
</blockquote>
<p>“max-age”是 HTTP 缓存控制最常用的属性，此外在响应报文里还可以用其他的属性来更精确地指示浏览器应该如何使用缓存：</p>
<ul>
<li>no_store：不允许缓存，用于某些变化非常频繁的数据，例如秒杀页面；</li>
<li>no_cache：它的字面含义容易与 no_store 搞混，实际的意思并不是不允许缓存，而是可以缓存，但在使用之前必须要去服务器验证是否过期，是否有最新的版本；</li>
<li>must-revalidate：又是一个和 no_cache 相似的词，它的意思是如果缓存不过期就可以继续使用，但过期了如果还想用就必须去服务器验证。</li>
</ul>
<p>听的有点糊涂吧。没关系，我拿生鲜速递来举例说明一下：</p>
<ul>
<li>no_store：买来的西瓜不允许放进冰箱，要么立刻吃，要么立刻扔掉；</li>
<li>no_cache：可以放进冰箱，但吃之前必须问超市有没有更新鲜的，有就吃超市里的；</li>
<li>must-revalidate：可以放进冰箱，保鲜期内可以吃，过期了就要问超市让不让吃。</li>
</ul>
<p>服务器的缓存控制策略画了一个流程图，对照着它你就可以在今后的后台开发里明确”Cache-Control”的用法了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《透视HTTP协议》学习笔记/服务器缓存控制策略流程图.png" alt="服务器缓存控制策略流程图"></p>
<h3 id="客户端的缓存控制"><a href="#客户端的缓存控制" class="headerlink" title="客户端的缓存控制"></a>客户端的缓存控制</h3><p>不止服务器可以发”Cache-Control”头，浏览器也可以发”Cache-Control”，也就是说请求 - 应答的双方都可以用这个字段进行缓存控制，互相协商缓存的使用策略。</p>
<p>当你点”刷新”按钮的时候，浏览器会在请求头里加一个”Cache-Control: max-age=0”。因为 max-age 是”生存时间”，max-age=0 的意思就是”我要一个最最新鲜的西瓜”，而本地缓存里的数据至少保存了几秒钟，所以浏览器就不会使用缓存，而是向服务器发请求。服务器看到 max-age=0，也就会用一个最新生成的报文回应浏览器。</p>
<p>Ctrl+F5 的”强制刷新”又是什么样的呢？</p>
<p>它其实是发了一个”Cache-Control: no-cache”，含义和”max-age=0”基本一样，就看后台的服务器怎么理解，通常两者的效果是相同的。</p>
<p>那么，浏览器的缓存究竟什么时候才能生效呢？</p>
<p>别着急，试着点一下浏览器的”前进””后退”按钮，再看开发者工具，你就会惊喜地发现”from disk cache”的字样，意思是没有发送网络请求，而是读取的磁盘上的缓存。</p>
<p>另外，如果用重定向跳转功能，也可以发现浏览器使用了缓存。</p>
<p>其实也很简单，在”前进””后退””跳转”这些重定向动作中浏览器不会”夹带私货”，只用最基本的请求头，没有”Cache-Control”，所以就会检查缓存，直接利用之前的资源，不再进行网络通信。</p>
<h3 id="条件请求"><a href="#条件请求" class="headerlink" title="条件请求"></a>条件请求</h3><p>浏览器用”Cache-Control”做缓存控制只能是刷新数据，不能很好地利用缓存数据，又因为缓存会失效，使用前还必须要去服务器验证是否是最新版。</p>
<p>条件请求一共有 5 个头字段，我们最常用的是”if-Modified-Since”和”If-None-Match”这两个。需要第一次的响应报文预先提供”Last-modified”和”ETag”，然后第二次请求时就可以带上缓存里的原值，验证资源是否是最新的。</p>
<p>如果资源没有变，服务器就回应一个”304 Not Modified”，表示缓存依然有效，浏览器就可以更新一下有效期，然后放心大胆地使用缓存了。</p>
<p>“Last-modified”很好理解，就是文件的最后修改时间。ETag 是什么呢？</p>
<p>ETag 是”实体标签”（Entity Tag）的缩写，是资源的一个唯一标识，主要是用来解决修改时间无法准确区分文件变化的问题。</p>
<p>比如，一个文件在一秒内修改了多次，但因为修改时间是秒级，所以这一秒内的新版本无法区分。</p>
<p>再比如，一个文件定期更新，但有时会是同样的内容，实际上没有变化，用修改时间就会误以为发生了变化，传送给浏览器就会浪费带宽。</p>
<p>使用 ETag 就可以精确地识别资源的变动情况，让浏览器能够更有效地利用缓存。</p>
<p>ETag 还有”强””弱”之分。</p>
<p>强 ETag 要求资源在字节级别必须完全相符，弱 ETag 在值前有个”W/“标记，只要求资源在语义上没有变化，但内部可能会有部分发生了改变（例如 HTML 里的标签顺序调整，或者多了几个空格）。</p>
<p>条件请求里其他的三个头字段是”If-Unmodified-Since””If-Match”和”If-Range”，其实只要你掌握了”if-Modified-Since”和”If-None-Match”，可以轻易地”举一反三”。</p>
<h3 id="课外小贴士-4"><a href="#课外小贴士-4" class="headerlink" title="课外小贴士"></a>课外小贴士</h3><ol>
<li>“no-cache”属性可以理解为*max-age=0,must-revalidate</li>
<li>除了”Cache-Control”,服务器也可以用”Expires”字段来标记资源的有效期，它的形式和 Cookie 的差不多，同样属于”过时”的属性，优先级低于”Cache-Control”。还有一个历史遗留字段”Pragma: no-cache”，它相当于”Cache-Control: no-cache”，除非为了兼容 HTTP/1.0 否则不建议使用。</li>
<li>如果响应报文里提供了”Last-modifed”，但浏览器没有”Cache-Control”或”Expires”，会使用”启发”(Heuristic)算法计算一个缓存时间，在 RFC 里的建议是:(Date -Last-modifed)*10%,</li>
<li>每个Web 服务器对 ETag 的计算方法都不一样只要保证数据变化后值不一样就好，但复杂的计算会增加服务器的负担。Nginx的算法是”修改时间+长度”，实际上和 Last-modifed 基本等价。</li>
</ol>
<h2 id="HTTP的代理服务"><a href="#HTTP的代理服务" class="headerlink" title="HTTP的代理服务"></a>HTTP的代理服务</h2><h3 id="代理相关头字段"><a href="#代理相关头字段" class="headerlink" title="代理相关头字段"></a>代理相关头字段</h3><p>代理服务器需要用字段”Via”标明代理的身份。</p>
<p>Via 是一个通用字段，请求头或响应头里都可以出现。每当报文经过一个代理节点，代理服务器就会把自身的信息追加到字段的末尾，就像是经手人盖了一个章。</p>
<p>“X-Forwarded-For”的字面意思是”为谁而转发”，形式上和”Via”差不多，也是每经过一个代理节点就会在字段里追加一个信息。但”Via”追加的是代理主机名（或者域名），而”X-Forwarded-For”追加的是请求方的 IP 地址。所以，在字段里最左边的 IP 地址就客户端的地址。</p>
<p>“X-Real-IP”是另一种获取客户端真实 IP 的手段，它的作用很简单，就是记录客户端 IP 地址，没有中间的代理信息，相当于是”X-Forwarded-For”的简化版。如果客户端和源服务器之间只有一个代理，那么这两个字段的值就是相同的。</p>
<h3 id="代理协议"><a href="#代理协议" class="headerlink" title="代理协议"></a>代理协议</h3><p>有了”X-Forwarded-For”等头字段，源服务器就可以拿到准确的客户端信息了。但对于代理服务器来说它并不是一个最佳的解决方案。</p>
<p>因为通过”X-Forwarded-For”操作代理信息必须要解析 HTTP 报文头，这对于代理来说成本比较高，原本只需要简单地转发消息就好，而现在却必须要费力解析数据再修改数据，会降低代理的转发性能。</p>
<p>另一个问题是”X-Forwarded-For”等头必须要修改原始报文，而有些情况下是不允许甚至不可能的（比如使用 HTTPS 通信被加密）。</p>
<p>所以就出现了一个专门的”代理协议”（The PROXY protocol），它由知名的代理软件 HAProxy 所定义，也是一个”事实标准”，被广泛采用（注意并不是 RFC）。</p>
<p>“代理协议”有 v1 和 v2 两个版本，v1 和 HTTP 差不多，也是明文，而 v2 是二进制格式。今天只介绍比较好理解的 v1，它在 HTTP 报文前增加了一行 ASCII 码文本，相当于又多了一个头。</p>
<p>这一行文本其实非常简单，开头必须是”PROXY”五个大写字母，然后是”TCP4”或者”TCP6”，表示客户端的 IP 地址类型，再后面是请求方地址、应答方地址、请求方端口号、应答方端口号，最后用一个回车换行（\r\n）结束。</p>
<p>例如下面的这个例子，在 GET 请求行前多出了 PROXY 信息行，客户端的真实 IP 地址是”1.1.1.1”，端口号是 55555。</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">PROXY TCP4 1.1.1.1 2.2.2.2 55555 80\r\n
GET / HTTP/1.1\r\n
Host: www.xxx.com\r\n
\r\n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>服务器看到这样的报文，只要解析第一行就可以拿到客户端地址，不需要再去理会后面的 HTTP 数据，省了很多事情。</p>
<h3 id="课外小贴士-5"><a href="#课外小贴士-5" class="headerlink" title="课外小贴士"></a>课外小贴士</h3><ol>
<li>“Via”是 HTTP 协议里规定的标准头字段，但有的服务器返回的响应报文里会使用”x-Via”含义是相同的。</li>
<li>因为 HTTP 是明文传输，请求头很容易被窜改所以”X-Forwarded-For”也不是完全可信的。</li>
<li>RFC7239 定义了字段”Forwarded”，它可以代替”X-Forwarded-For””X-Forwarded-Host”等字段，但应用得不多</li>
</ol>
<h2 id="HTTP的缓存代理"><a href="#HTTP的缓存代理" class="headerlink" title="HTTP的缓存代理"></a>HTTP的缓存代理</h2><h3 id="源服务器的缓存控制"><a href="#源服务器的缓存控制" class="headerlink" title="源服务器的缓存控制"></a>源服务器的缓存控制</h3><p>之前介绍的服务器端的”Cache-Control”属性：max-age、no_store、no_cache 和 must-revalidate，你应该还有印象吧？</p>
<p>这 4 种缓存属性可以约束客户端，也可以约束代理。</p>
<p>但客户端和代理是不一样的，客户端的缓存只是用户自己使用，而代理的缓存可能会为非常多的客户端提供服务。所以，需要对它的缓存再多一些限制条件。</p>
<p>首先，我们要区分客户端上的缓存和代理上的缓存，可以使用两个新属性”private”和”public”。</p>
<p>“private”表示缓存只能在客户端保存，是用户”私有”的，不能放在代理上与别人共享。而”public”的意思就是缓存完全开放，谁都可以存，谁都可以用。</p>
<p>比如你登录论坛，返回的响应报文里用”Set-Cookie”添加了论坛 ID，这就属于私人数据，不能存在代理上。不然，别人访问代理获取了被缓存的响应就麻烦了。</p>
<p>其次，缓存失效后的重新验证也要区分开（即使用条件请求”Last-modified”和”ETag”），”must-revalidate”是只要过期就必须回源服务器验证，而新的”proxy-revalidate”只要求代理的缓存过期后必须验证，客户端不必回源，只验证到代理这个环节就行了。</p>
<p>再次，缓存的生存时间可以使用新的”s-maxage”（s 是 share 的意思，注意 maxage 中间没有”-“），只限定在代理上能够存多久，而客户端仍然使用”max_age”。</p>
<p>还有一个代理专用的属性”no-transform”。代理有时候会对缓存下来的数据做一些优化，比如把图片生成 png、webp 等几种格式，方便今后的请求处理，而”no-transform”就会禁止这样做，不许”偷偷摸摸搞小动作”。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《透视HTTP协议》学习笔记/服务器端缓存控制策略.png" alt="服务器端缓存控制策略"></p>
<h3 id="客户端的缓存控制-1"><a href="#客户端的缓存控制-1" class="headerlink" title="客户端的缓存控制"></a>客户端的缓存控制</h3><p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《透视HTTP协议》学习笔记/客户端的缓存控制.png" alt="客户端的缓存控制"></p>
<p>max-age、no_store、no_cache 这三个属性在[第 20 讲]已经介绍过了，它们也是同样作用于代理和源服务器。</p>
<p>关于缓存的生存时间，多了两个新属性”max-stale”和”min-fresh”。</p>
<p>“max-stale”的意思是如果代理上的缓存过期了也可以接受，但不能过期太多，超过 x 秒也会不要。”min-fresh”的意思是缓存必须有效，而且必须在 x 秒后依然有效。</p>
<p>比如，草莓上贴着标签”max-age=5”，现在已经在冰柜里存了 7 天。如果有请求”max-stale=2”，意思是过期两天也能接受，所以刚好能卖出去。</p>
<p>但要是”min-fresh=1”，这是绝对不允许过期的，就不会买走。这时如果有另外一个菠萝是”max-age=10”，那么”7+1&lt;10”，在一天之后还是新鲜的，所以就能卖出去。</p>
<p>有的时候客户端还会发出一个特别的”only-if-cached”属性，表示只接受代理缓存的数据，不接受源服务器的响应。如果代理上没有缓存或者缓存过期，就应该给客户端返回一个 504（Gateway Timeout）。</p>
<h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><p>缓存代理的知识就快讲完了，下面再简单说两个相关的问题。</p>
<p>第一个是”Vary”字段，在[第 15 讲]曾经说过，它是内容协商的结果，相当于报文的一个版本标记。</p>
<p>同一个请求，经过内容协商后可能会有不同的字符集、编码、浏览器等版本。比如，”Vary: Accept-Encoding””Vary: User-Agent”，缓存代理必须要存储这些不同的版本。</p>
<p>当再收到相同的请求时，代理就读取缓存里的”Vary”，对比请求头里相应的” Accept-Encoding””User-Agent”等字段，如果和上一个请求的完全匹配，比如都是”gzip””Chrome”，就表示版本一致，可以返回缓存的数据。</p>
<p>另一个问题是”Purge”，也就是”缓存清理”，它对于代理也是非常重要的功能，例如：</p>
<ul>
<li>过期的数据应该及时淘汰，避免占用空间；</li>
<li>源站的资源有更新，需要删除旧版本，主动换成最新版（即刷新）；</li>
<li>有时候会缓存了一些本不该存储的信息，例如网络谣言或者危险链接，必须尽快把它们删除。</li>
</ul>
<p>清理缓存的方法有很多，比较常用的一种做法是使用自定义请求方法”PURGE”，发给代理服务器，要求删除 URI 对应的缓存数据。</p>
<h3 id="课后小贴士"><a href="#课后小贴士" class="headerlink" title="课后小贴士"></a>课后小贴士</h3><ol>
<li>有的缓存代理在”Cache Hit”的时候会在响应报文里加一个 Age 头字段，表示报文的生存时间，即已经在缓存里存了多久，通常它会小于”Cache-Control”里的 max-age 值，如果大于就意味着数据是”陈日的”(stale)。</li>
<li>判断缓存是否命中(Hit)类似于查询 hash 表使用的 key 通常就是 URI，在 Nginx 里可以用指令”proxy_cache_key”自定义。</li>
<li>Nginx 对 Vary 的处理实际上是做了 MD5，把Vary 头摘要后写入缓存，请求时不仅比较URI，也比较摘要。</li>
</ol>
<h2 id="SSLTLS"><a href="#SSLTLS" class="headerlink" title="SSLTLS"></a>SSLTLS</h2><h3 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h3><p>SSL 即安全套接层（Secure Sockets Layer），在 OSI 模型中处于第 5 层（会话层），由网景公司于 1994 年发明，有 v2 和 v3 两个版本，而 v1 因为有严重的缺陷从未公开过。</p>
<p>SSL 发展到 v3 时已经证明了它自身是一个非常好的安全通信协议，于是互联网工程组 IETF 在 1999 年把它改名为 TLS（传输层安全，Transport Layer Security），正式标准化，版本号从 1.0 重新算起，所以 TLS1.0 实际上就是 SSLv3.1。</p>
<p>到今天 TLS 已经发展出了三个版本，分别是 2006 年的 1.1、2008 年的 1.2 和去年（2018）的 1.3，每个新版本都紧跟密码学的发展和互联网的现状，持续强化安全和性能，已经成为了信息安全领域中的权威标准。</p>
<p>目前应用的最广泛的 TLS 是 1.2，而之前的协议（TLS1.1⁄1.0、SSLv3/v2）都已经被认为是不安全的，各大浏览器即将在 2020 年左右停止支持，所以接下来的讲解都针对的是 TLS1.2。</p>
<p>TLS 由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术。</p>
<p>浏览器和服务器在使用 TLS 建立连接时需要选择一组恰当的加密算法来实现安全通信，这些算法的组合被称为”密码套件”（cipher suite，也叫加密套件）。</p>
<p>你可以访问实验环境的 URI”/23-1”，对 TLS 和密码套件有个感性的认识。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《透视HTTP协议》学习笔记/23-1.png" alt="23-1"></p>
<p>你可以看到，实验环境使用的 TLS 是 1.2，客户端和服务器都支持非常多的密码套件，而最后协商选定的是”ECDHE-RSA-AES256-GCM-SHA384”。</p>
<p>这么长的名字看着有点晕吧，不用怕，其实 TLS 的密码套件命名非常规范，格式很固定。基本的形式是”密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法”，比如刚才的密码套件的意思就是：</p>
<p>“握手时使用 ECDHE 算法进行密钥交换，用 RSA 签名和身份认证，握手后的通信使用 AES 对称算法，密钥长度 256 位，分组模式是 GCM，摘要算法 SHA384 用于消息认证和产生随机数。”</p>
<h3 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h3><p>说到 TLS，就不能不谈到 OpenSSL，它是一个著名的开源密码学程序库和工具包，几乎支持所有公开的加密算法和协议，已经成为了事实上的标准，许多应用软件都会使用它作为底层库来实现 TLS 功能，包括常用的 Web 服务器 Apache、Nginx 等。</p>
<p>OpenSSL 是从另一个开源库 SSLeay 发展出来的，曾经考虑命名为”OpenTLS”，但当时（1998 年）TLS 还未正式确立，而 SSL 早已广为人知，所以最终使用了”OpenSSL”的名字。</p>
<p>OpenSSL 目前有三个主要的分支，1.0.2 和 1.1.0 都将在今年（2019）年底不再维护，最新的长期支持版本是 1.1.1，我们的实验环境使用的 OpenSSL 是”1.1.0j”。</p>
<p>由于 OpenSSL 是开源的，所以它还有一些代码分支，比如 Google 的 BoringSSL、OpenBSD 的 LibreSSL，这些分支在 OpenSSL 的基础上删除了一些老旧代码，也增加了一些新特性，虽然背后有”大金主”，但离取代 OpenSSL 还差得很远。</p>
<h3 id="课外小贴士-6"><a href="#课外小贴士-6" class="headerlink" title="课外小贴士"></a>课外小贴士</h3><ol>
<li>一个有趣的事实，当前所有 TLS 的 RFC 文档末尾数字都是”46”(2246、4346、5246.8846)</li>
<li>除了 HTTP，SSL/TLS 也可以承载其他的应用协议，例如 FTP=&gt;FTPS，LDAP=&gt;LDAPS 等</li>
<li>OpenSSL前身”SSLeay”的名字来源于其作者之-“Eric A. Young”</li>
<li>关于 OpenSSL 有一个著名的”心脏出血(Heart Bleed)”漏洞，出现在 1.0.1 版里。</li>
<li>OpenSSL 里的密码套件定义与 TLS 略有不同TLS 里的形式是”TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384”，加了前缀”TLS”，并用”WITH”分开了握手和通信的算法。</li>
<li>另一个比较著名的开源密码库是 NSS(Network Security Services),由Mozilla 开发。</li>
<li>比特币、以太坊等区块链技术里也用到了ECC，它们选择的曲线是 secp 256k1。</li>
<li>由于密码学界普遍不信任 NIST 和 NSA，怀疑 secp 系列曲线有潜在的弱点，所以研究出了 “x25519”，它的名字来源于曲线方程里的参数”2^255 - 19”。另有一个更高强度的曲线”x448”，参数是”2^448-2^224-1”。</li>
<li>在 Linux 上可以使用 OpenSSL 的命令行工具来测试算法的加解密速度，例如”openssspeed aes”，”openssl speed rsa2048”等</li>
<li>TLS1.2 要求必须实现 TLS RSA WITH AES128 CBC SHA，TLS1.3 要求必须实现 TLSAES 128 GCM SHA256，并且因为前向安全的原因废除了 DH 和 RSA 密钥交换算法。</li>
<li>SHA-2 实际上是一系列摘要算法的统称，总共有 6 种，常用的有 SHA224、SHA256、SHA384，分别能够生成 28 字节、32 字节、48 字节的摘要。 </li>
<li>虽然 SHA-2 很安全，但出于”未雨绸缪”的考虑，又出现了 SHA-3，它也有6种算法，名字与 SHA-2 差不多，比如 SHA3-224、SHA3-256，目前还未纳入 TLS。</li>
</ol>
<h2 id="TLS1-2连接过程解析"><a href="#TLS1-2连接过程解析" class="headerlink" title="TLS1.2连接过程解析"></a>TLS1.2连接过程解析</h2><h3 id="TLS-协议的组成"><a href="#TLS-协议的组成" class="headerlink" title="TLS 协议的组成"></a>TLS 协议的组成</h3><p>TLS 包含几个子协议，你也可以理解为它是由几个不同职责的模块组成，比较常用的有记录协议、警报协议、握手协议、变更密码规范协议等。</p>
<ul>
<li><p>记录协议（Record Protocol）规定了 TLS 收发数据的基本单位：记录（record）。它有点像是 TCP 里的 segment，所有的其他子协议都需要通过记录协议发出。但多个记录数据可以在一个 TCP 包里一次性发出，也并不需要像 TCP 那样返回 ACK。</p>
</li>
<li><p>警报协议（Alert Protocol）的职责是向对方发出警报信息，有点像是 HTTP 协议里的状态码。比如，protocol_version 就是不支持旧版本，bad_certificate 就是证书有问题，收到警报后另一方可以选择继续，也可以立即终止连接。</p>
</li>
<li><p>握手协议（Handshake Protocol）是 TLS 里最复杂的子协议，要比 TCP 的 SYN/ACK 复杂的多，浏览器和服务器会在握手过程中协商 TLS 版本号、随机数、密码套件等信息，然后交换证书和密钥参数，最终双方协商得到会话密钥，用于后续的混合加密系统。</p>
</li>
<li><p>最后一个是变更密码规范协议（Change Cipher Spec Protocol），它非常简单，就是一个”通知”，告诉对方，后续的数据都将使用加密保护。那么反过来，在它之前，数据都是明文的。</p>
</li>
</ul>
<p>下面的这张图简要地描述了 TLS 的握手过程，其中每一个”框”都是一个记录，多个记录组合成一个 TCP 包发送。所以，最多经过两次消息往返（4 个消息）就可以完成握手，然后就可以在安全的通信环境里发送 HTTP 报文，实现 HTTPS 协议。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《透视HTTP协议》学习笔记/TLS1.2的握手过程.png" alt="TLS1.2的握手过程"></p>
<h3 id="抓包的准备工作"><a href="#抓包的准备工作" class="headerlink" title="抓包的准备工作"></a>抓包的准备工作</h3><p>新增一个系统变量”SSLKEYLOGFILE”，设置浏览器日志文件的路径。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《透视HTTP协议》学习笔记/设置SSLKEYLOGFILE.png" alt="设置SSLKEYLOGFILE"></p>
<p>后在 Wireshark 里设置”Protocols-TLS”（较早版本的 Wireshark 里是”SSL”），在”(Pre)-Master-Secret log filename”里填上刚才的日志文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《透视HTTP协议》学习笔记/使用SSLKEYLOGFILE.png" alt="使用SSLKEYLOGFILE"></p>
<h3 id="ECDHE-握手过程"><a href="#ECDHE-握手过程" class="headerlink" title="ECDHE 握手过程"></a>ECDHE 握手过程</h3><p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《透视HTTP协议》学习笔记/TLS1.2ECDHE握手过程.png" alt="TLS1.2ECDHE握手过程"></p>
<p>访问 <a target="_blank" rel="noopener" href="https://www.chrono.com/26-1">https://www.chrono.com/26-1</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《透视HTTP协议》学习笔记/TLS1.2ECDHE握手过程Wireshark截图.png" alt="TLS1.2ECDHE握手过程Wireshark截图.png"></p>
<p>TCP 建立连接之后，浏览器会首先发一个”Client Hello”消息，也就是跟服务器”打招呼”。里面有客户端的版本号、支持的密码套件，还有一个随机数（Client Random），用于后续生成会话密钥。</p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">Handshake Protocol: Client Hello
    Version: TLS 1.2 (0x0303)
    Random: 1cbf803321fd2623408dfe…
    Cipher Suites (17 suites)
        Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (0xc02f)
        Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (0xc030)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>服务器收到”Client Hello”后，会返回一个”Server Hello”消息。把版本号对一下，也给出一个随机数（Server Random），然后从客户端的列表里选一个作为本次通信使用的密码套件，在这里它选择了”TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384”。</p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">Handshake Protocol: Server Hello
    Version: TLS 1.2 (0x0303)
    Random: 0e6320f21bae50842e96…
    Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (0xc030)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后，服务器为了证明自己的身份，就把证书也发给了客户端（Server Certificate）。</p>
<p>因为服务器选择了 ECDHE 算法，所以它会在证书后发送”Server Key Exchange”消息，里面是椭圆曲线的公钥（Server Params），用来实现密钥交换算法，再加上自己的私钥签名认证。</p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">Handshake Protocol: Server Key Exchange
    EC Diffie-Hellman Server Params
        Curve Type: named_curve (0x03)
        Named Curve: x25519 (0x001d)
        Pubkey: 3b39deaf00217894e...
        Signature Algorithm: rsa_pkcs1_sha512 (0x0601)
        Signature: 37141adac38ea4...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>之后是”Server Hello Done”消息，服务器说：”我的信息就是这些，打招呼完毕。”</p>
<p>这样第一个消息往返就结束了（两个 TCP 包），结果是客户端和服务器通过明文共享了三个信息：<strong>Client Random</strong>、<strong>Server Random</strong> 和 <strong>Server Params</strong>。</p>
<p>客户端在验证了服务器的证书后，客户端按照密码套件的要求，也生成一个椭圆曲线的公钥（Client Params），用”Client Key Exchange”消息发给服务器。</p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">Handshake Protocol: Client Key Exchange
    EC Diffie-Hellman Client Params
        Pubkey: 8c674d0e08dc27b5eaa…<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>现在客户端和服务器手里都拿到了密钥交换算法的两个参数（Client Params、Server Params），就用 ECDHE 算法一阵算，算出了一个新的东西，叫”Pre-Master”，其实也是一个随机数。</p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">master_secret = PRF(pre_master_secret, "master secret", ClientHello.random + ServerHello.random)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>至于具体的计算原理和过程，因为太复杂就不细说了，但算法可以保证即使黑客截获了之前的参数，也是绝对算不出这个随机数的。</p>
<p>现在客户端和服务器手里有了三个随机数：Client Random、Server Random 和 Pre-Master。用这三个作为原始材料，就可以生成用于加密会 话的主密钥，叫”Master Secret”。而黑客因为拿不到”Pre-Master”，所以也就得不到主密钥。</p>
<p>主密钥有 48 字节，但它也不是最终用于通信的会话密钥，还会再用 PRF 扩展出更多的密钥，比如客户端发送用的会话密钥（client_write_key）、服务器发送用的会话密钥（server_write_key）等等，避免只用一个密钥带来的安全隐患。</p>
<p>有了主密钥和派生的会话密钥，握手就快结束了。客户端发一个”Change Cipher Spec”，然后再发一个”Finished”消息，把之前所有发送的数据做个摘要，再加密一下，让服务器做个验证。</p>
<p>意思就是告诉服务器：”后面都改用对称算法加密通信了啊，用的就是打招呼时说的 AES，加密对不对还得你测一下。”</p>
<p>服务器也是同样的操作，发”Change Cipher Spec”和”Finished”消息，双方都验证加密解密 OK，握手正式结束，后面就收发被加密的 HTTP 请求和响应了。</p>
<h3 id="RSA-握手过程"><a href="#RSA-握手过程" class="headerlink" title="RSA 握手过程"></a>RSA 握手过程</h3><p>整个握手过程可真是够复杂的，但你可能会问了，好像这个过程和其他地方看到的不一样呢？</p>
<p>刚才说的其实是如今主流的 TLS 握手过程，这与传统的握手有两点不同。</p>
<p>第一个，使用 ECDHE 实现密钥交换，而不是 RSA，所以会在服务器端发出”Server Key Exchange”消息。</p>
<p>第二个，因为使用了 ECDHE，客户端可以不用等到服务器发回”Finished”确认握手完毕，立即就发出 HTTP 报文，省去了一个消息往返的时间浪费。这个叫”TLS False Start”，意思就是”抢跑”，和”TCP Fast Open”有点像，都是不等连接完全建立就提前发应用数据，提高传输的效率。</p>
<p>实验环境在 440 端口 <a target="_blank" rel="noopener" href="https://www.chrono.com:440/26-1">https://www.chrono.com:440/26-1</a> 实现了传统的 RSA 密钥交换，没有”False Start”</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《透视HTTP协议》学习笔记/TLS1.2RSA握手过程.png" alt="TLS1.2RSA握手过程"></p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《透视HTTP协议》学习笔记/TLS1.2RSA握手过程Wireshark截图.png" alt="TLS1.2RSA握手过程Wireshark截图"></p>
<p>大体的流程没有变，只是”Pre-Master”不再需要用算法生成，而是客户端直接生成随机数，然后用服务器的公钥加密，通过”Client Key Exchange”消息发给服务器。服务器再用私钥解密，这样双方也实现了共享三个随机数，就可以生成主密钥。</p>
<h3 id="双向认证"><a href="#双向认证" class="headerlink" title="双向认证"></a>双向认证</h3><p>双向认证的流程也没有太多变化，只是在”Server Hello Done”之后，”Client Key Exchange”之前，客户端要发送”Client Certificate”消息，服务器收到后也把证书链走一遍，验证客户端的身份。</p>
<h3 id="课外小贴士-7"><a href="#课外小贴士-7" class="headerlink" title="课外小贴士"></a>课外小贴士</h3><ol>
<li>TLS 中记录协议原本定义有压缩方式，但后来发现存在安全漏洞(CRIME 攻击)，所以现在这个字段总是 NULL，即不压缩。</li>
<li>在 TLS1.2 里，客户端和随机数的长度都是 28字节，前面的四个字节是 UNIX 时间戳，但并没有实际意义。</li>
<li>Chrome 开发者工具的”Security”面板里可以看到 HTTPS 握手时选择的版本号、密码套件和椭圆曲线，例如”ECDHE RSA withX25519,and AES 256 GCM”</li>
<li>ECDHE 即”短暂-椭圆曲线-迪菲-赫尔曼(ephemeral Elliptic Curve Diffie-Hellman)”算法，使用椭圆曲线增强了 DH 算法的安全性和性能，公钥和私钥都是临时生成的。</li>
<li>在 Wireshark 抓包里你还会看见”Session ID”，”Extension”等字段，涉及会话复用和扩展协议，后面会讲到。</li>
</ol>
<h2 id="TLS1-3特性解析"><a href="#TLS1-3特性解析" class="headerlink" title="TLS1.3特性解析"></a>TLS1.3特性解析</h2><h3 id="最大化兼容性"><a href="#最大化兼容性" class="headerlink" title="最大化兼容性"></a>最大化兼容性</h3><p>由于 1.1、1.2 等协议已经出现了很多年，很多应用软件、中间代理（官方称为”MiddleBox”）只认老的记录协议格式，更新改造很困难，甚至是不可行（设备僵化）。</p>
<p>在早期的试验中发现，一旦变更了记录头字段里的版本号，也就是由 0x303（TLS1.2）改为 0x304（TLS1.3）的话，大量的代理服务器、网关都无法正确处理，最终导致 TLS 握手失败。</p>
<p>为了保证这些被广泛部署的”老设备”能够继续使用，避免新协议带来的”冲击”，TLS1.3 不得不做出妥协，保持现有的记录格式不变，通过”伪装”来实现兼容，使得 TLS1.3 看上去”像是”TLS1.2。</p>
<p>那么，该怎么区分 1.2 和 1.3 呢？</p>
<p>这要用到一个新的扩展协议（Extension Protocol），它有点”补充条款”的意思，通过在记录末尾添加一系列的”扩展字段”来增加新的功能，老版本的 TLS 不认识它可以直接忽略，这就实现了”后向兼容”。</p>
<p>在记录头的 Version 字段被兼容性”固定”的情况下，只要是 TLS1.3 协议，握手的”Hello”消息后面就必须有”supported_versions”扩展，它标记了 TLS 的版本号，使用它就能区分新旧协议。</p>
<p>其实上一讲 Chrome 在握手时发的就是 TLS1.3 协议，你可以看一下”Client Hello”消息后面的扩展，只是因为服务器不支持 1.3，所以就”后向兼容”降级成了 1.2。</p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">Handshake Protocol: Client Hello
    Version: TLS 1.2 (0x0303)
    Extension: supported_versions (len=11)
        Supported Version: TLS 1.3 (0x0304)
        Supported Version: TLS 1.2 (0x0303)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>TLS1.3 利用扩展实现了许多重要的功能，比如”supported_groups””key_share””signature_algorithms””server_name”等。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《透视HTTP协议》学习笔记/supported_versions.png" alt="supported_versions"></p>
<h3 id="强化安全"><a href="#强化安全" class="headerlink" title="强化安全"></a>强化安全</h3><p>TLS1.2 在十来年的应用中获得了许多宝贵的经验，陆续发现了很多的漏洞和加密算法的弱点，所以 TLS1.3 就在协议里修补了这些不安全因素。</p>
<p>比如：</p>
<ul>
<li>伪随机数函数由 PRF 升级为 HKDF（HMAC-based Extract-and-Expand Key Derivation Function）；</li>
<li>明确禁止在记录协议里使用压缩；</li>
<li>废除了 RC4、DES 对称加密算法；</li>
<li>废除了 ECB、CBC 等传统分组模式；</li>
<li>废除了 MD5、SHA1、SHA-224 摘要算法；</li>
<li>废除了 RSA、DH 密钥交换算法和许多命名曲线。</li>
</ul>
<p>经过这一番”减肥瘦身”之后，TLS1.3 里只保留了 AES、ChaCha20 对称加密算法，分组模式只能用 AEAD 的 GCM、CCM 和 Poly1305，摘要算法只能用 SHA256、SHA384，密钥交换算法只有 ECDHE 和 DHE，椭圆曲线也被”砍”到只剩 P-256 和 x25519 等 5 种。</p>
<p>减肥可以让人变得更轻巧灵活，TLS 也是这样。</p>
<p>算法精简后带来了一个意料之中的好处：原来众多的算法、参数组合导致密码套件非常复杂，难以选择，而现在的 TLS1.3 里只有 5 个套件，无论是客户端还是服务器都不会再犯”选择困难症”了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《透视HTTP协议》学习笔记/TLS1.3里的5个密码套件.jpg" alt="TLS1.3里的5个密码套件"></p>
<p>这里还要特别说一下废除 RSA 和 DH 密钥交换算法的原因。</p>
<p>上一讲用 Wireshark 抓包时你一定看到了，浏览器默认会使用 ECDHE 而不是 RSA 做密钥交换，这是因为它不具有”前向安全”（Forward Secrecy）。</p>
<p>假设有这么一个很有耐心的黑客，一直在长期收集混合加密系统收发的所有报文。如果加密系统使用服务器证书里的 RSA 做密钥交换，一旦私钥泄露或被破解（使用社会工程学或者巨型计算机），那么黑客就能够使用私钥解密出之前所有报文的”Pre-Master”，再算出会话密钥，破解所有密文。</p>
<p>这就是所谓的”今日截获，明日破解”。</p>
<p>而 ECDHE 算法在每次握手时都会生成一对临时的公钥和私钥，每次通信的密钥对都是不同的，也就是”一次一密”，即使黑客花大力气破解了这一次的会话密钥，也只是这次通信被攻击，之前的历史消息不会受到影响，仍然是安全的。</p>
<p>所以现在主流的服务器和浏览器在握手阶段都已经不再使用 RSA，改用 ECDHE，而 TLS1.3 在协议里明确废除 RSA 和 DH 则在标准层面保证了”前向安全”。</p>
<h3 id="提升性能"><a href="#提升性能" class="headerlink" title="提升性能"></a>提升性能</h3><p>HTTPS 建立连接时除了要做 TCP 握手，还要做 TLS 握手，在 1.2 中会多花两个消息往返（2-RTT），可能导致几十毫秒甚至上百毫秒的延迟，在移动网络中延迟还会更严重。</p>
<p>现在因为密码套件大幅度简化，也就没有必要再像以前那样走复杂的协商流程了。TLS1.3 压缩了以前的”Hello”协商过程，删除了”Key Exchange”消息，把握手时间减少到了”1-RTT”，效率提高了一倍。</p>
<p>那么它是怎么做的呢？</p>
<p>其实具体的做法还是利用了扩展。客户端在”Client Hello”消息里直接用”supported_groups”带上支持的曲线，比如 P-256、x25519，用”key_share”带上曲线对应的客户端公钥参数，用”signature_algorithms”带上签名算法。</p>
<p>服务器收到后在这些扩展里选定一个曲线和参数，再用”key_share”扩展返回服务器这边的公钥参数，就实现了双方的密钥交换，后面的流程就和 1.2 基本一样了。</p>
<p>我为 1.3 的握手过程画了一张图，你可以对比 1.2 看看区别在哪里。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《透视HTTP协议》学习笔记/TLS1.3握手过程.png" alt="TLS1.3握手过程"></p>
<p>除了标准的”1-RTT”握手，TLS1.3 还引入了”0-RTT”握手，用”pre_shared_key”和”early_data”扩展，在 TCP 连接后立即就建立安全连接发送加密消息，不过这需要有一些前提条件，今天暂且不说。</p>
<h3 id="握手分析"><a href="#握手分析" class="headerlink" title="握手分析"></a>握手分析</h3><p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《透视HTTP协议》学习笔记/TLS1.3握手过程分析.png" alt="TLS1.3握手过程分析"></p>
<p>在 TCP 建立连接之后，浏览器首先还是发一个”Client Hello”。</p>
<p>因为 1.3 的消息兼容 1.2，所以开头的版本号、支持的密码套件和随机数（Client Random）结构都是一样的（不过这时的随机数是 32 个字节）。</p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">Handshake Protocol: Client Hello
    Version: TLS 1.2 (0x0303)
    Random: cebeb6c05403654d66c2329…
    Cipher Suites (18 suites)
        Cipher Suite: TLS_AES_128_GCM_SHA256 (0x1301)
        Cipher Suite: TLS_CHACHA20_POLY1305_SHA256 (0x1303)
        Cipher Suite: TLS_AES_256_GCM_SHA384 (0x1302)
    Extension: supported_versions (len=9)
        Supported Version: TLS 1.3 (0x0304)
        Supported Version: TLS 1.2 (0x0303)
    Extension: supported_groups (len=14)
        Supported Groups (6 groups)
            Supported Group: x25519 (0x001d)
            Supported Group: secp256r1 (0x0017)
    Extension: key_share (len=107)
        Key Share extension
            Client Key Share Length: 105
            Key Share Entry: Group: x25519
            Key Share Entry: Group: secp256r1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意”Client Hello”里的扩展，”supported_versions”表示这是 TLS1.3，”supported_groups”是支持的曲线，”key_share”是曲线对应的参数。</p>
<p>服务器收到”Client Hello”同样返回”Server Hello”消息，还是要给出一个随机数（Server Random）和选定密码套件。</p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">Handshake Protocol: Server Hello
    Version: TLS 1.2 (0x0303)
    Random: 12d2bce6568b063d3dee2…
    Cipher Suite: TLS_AES_128_GCM_SHA256 (0x1301)
    Extension: supported_versions (len=2)
        Supported Version: TLS 1.3 (0x0304)
    Extension: key_share (len=36)
        Key Share extension
            Key Share Entry: Group: x25519, Key Exchange length: 32<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>表面上看和 TLS1.2 是一样的，重点是后面的扩展。”supported_versions”里确认使用的是 TLS1.3，然后在”key_share”扩展带上曲线和对应的公钥参数。</p>
<p>这时只交换了两条消息，客户端和服务器就拿到了四个共享信息：Client Random和Server Random、Client Params和Server Params，两边就可以各自用 ECDHE 算出”Pre-Master”，再用 HKDF 生成主密钥”Master Secret”，效率比 TLS1.2 提高了一大截。</p>
<p>在算出主密钥后，服务器立刻发出”Change Cipher Spec”消息，比 TLS1.2 提早进入加密通信，后面的证书等就都是加密的了，减少了握手时的明文信息泄露。</p>
<p>这里 TLS1.3 还有一个安全强化措施，多了个”Certificate Verify”消息，用服务器的私钥把前面的曲线、套件、参数等握手数据加了签名，作用和”Finished”消息差不多。但由于是私钥签名，所以强化了身份认证和和防窜改。</p>
<p>这两个”Hello”消息之后，客户端验证服务器证书，再发”Finished”消息，就正式完成了握手，开始收发 HTTP 报文。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《透视HTTP协议》学习笔记/supported_versions.png" alt="supported_versions"></p>
<h3 id="课外小贴士-8"><a href="#课外小贴士-8" class="headerlink" title="课外小贴士"></a>课外小贴士</h3><ol>
<li>对 TLS1.2 已知的攻击有 BEAST、BREACH,CRIME、FREAK、LUCKY13、POODLE、ROBOT 等。</li>
<li>在 TLS1.3 的 RFC 文档里已经删除了”ChangeCipher Spec”子协议，但用 Wireshark 抓包却还能看到，这里以抓包为准。</li>
<li>TLS1.3 还提供了”降级保护机制”，如果”中间人”恶意降级到 1.2，服务器的随机数最后 8个字节会被设置为”44 4F 57 4E 47 52 4401”，即”DOWNGRD01”，支持 TLS1.3 的客户端就可以检查发现被降级，然后发出警报终止连接。</li>
</ol>
<h2 id="HTTPS的优化"><a href="#HTTPS的优化" class="headerlink" title="HTTPS的优化"></a>HTTPS的优化</h2><p>HTTPS 连接大致上可以划分为两个部分，第一个是建立连接时的非对称加密握手，第二个是握手后的对称加密报文传输。</p>
<p>由于目前流行的 AES、ChaCha20 性能都很好，还有硬件优化，报文传输的性能损耗可以说是非常地小，小到几乎可以忽略不计了。所以，通常所说的”HTTPS 连接慢”指的就是刚开始建立连接的那段时间。</p>
<p>在 TCP 建连之后，正式数据传输之前，HTTPS 比 HTTP 增加了一个 TLS 握手的步骤，这个步骤最长可以花费两个消息往返，也就是 2-RTT。而且在握手消息的网络耗时之外，还会有其他的一些”隐形”消耗，比如：</p>
<p>产生用于密钥交换的临时公私钥对（ECDHE）；<br>验证证书时访问 CA 获取 CRL 或者 OCSP；<br>非对称加密解密处理”Pre-Master”。<br>在最差的情况下，也就是不做任何的优化措施，HTTPS 建立连接可能会比 HTTP 慢上几百毫秒甚至几秒，这其中既有网络耗时，也有计算耗时，就会让人产生”打开一个 HTTPS 网站好慢啊”的感觉。</p>
<p>不过刚才说的情况早就是”过去时”了，现在已经有了很多行之有效的 HTTPS 优化手段，运用得好可以把连接的额外耗时降低到几十毫秒甚至是”零”。</p>
<p>我画了一张图，把 TLS 握手过程中影响性能的部分都标记了出来，对照着它就可以”有的放矢”地来优化 HTTPS。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《透视HTTP协议》学习笔记/TLS握手过程中影响性能的部分.png" alt="TLS握手过程中影响性能的部分"></p>
<h3 id="硬件优化"><a href="#硬件优化" class="headerlink" title="硬件优化"></a>硬件优化</h3><ol>
<li><p>更快的 CPU</p>
<p> 最好还内建 AES 优化，这样即可以加速握手，也可以加速传输。</p>
</li>
<li><p>SSL 加速卡</p>
<p> 加解密时调用它的 API，让专门的硬件来做非对称加解密，分担 CPU 的计算压力。</p>
</li>
<li><p>SSL 加速服务器</p>
<p> 用专门的服务器集群来彻底”卸载”TLS 握手时的加密解密计算。</p>
</li>
</ol>
<h3 id="软件优化"><a href="#软件优化" class="headerlink" title="软件优化"></a>软件优化</h3><p>软件方面的优化还可以再分成两部分：一个是软件升级，一个是协议优化。</p>
<h3 id="协议优化"><a href="#协议优化" class="headerlink" title="协议优化"></a>协议优化</h3><p>如果有可能，应当尽量采用 TLS1.3，它大幅度简化了握手的过程，完全握手只要 1-RTT，而且更加安全。</p>
<p>如果暂时不能升级到 1.3，只能用 1.2，那么握手时使用的密钥交换协议应当尽量选用椭圆曲线的 ECDHE 算法。它不仅运算速度快，安全性高，还支持”False Start”，能够把握手的消息往返由 2-RTT 减少到 1-RTT，达到与 TLS1.3 类似的效果。</p>
<p>另外，椭圆曲线也要选择高性能的曲线，最好是 x25519，次优选择是 P-256。对称加密算法方面，也可以选用”AES_128_GCM”，它能比”AES_256_GCM”略快一点点。</p>
<p>在 Nginx 里可以用”ssl_ciphers””ssl_ecdh_curve”等指令配置服务器使用的密码套件和椭圆曲线，把优先使用的放在前面，例如：</p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">ssl_ciphers     TLS13-AES-256-GCM-SHA384:TLS13-CHACHA20-POLY1305-SHA256:EECDH+CHACHA20；
ssl_ecdh_curve  X25519:P-256;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="证书优化"><a href="#证书优化" class="headerlink" title="证书优化"></a>证书优化</h3><p>这里就有两个优化点，一个是证书传输，一个是证书验证。</p>
<p>服务器的证书可以选择椭圆曲线（ECDSA）证书而不是 RSA 证书，因为 224 位的 ECC 相当于 2048 位的 RSA，所以椭圆曲线证书的”个头”要比 RSA 小很多，即能够节约带宽也能减少客户端的运算量，可谓”一举两得”。</p>
<p>客户端的证书验证其实是个很复杂的操作，除了要公钥解密验证多个证书签名外，因为证书还有可能会被撤销失效，客户端有时还会再去访问 CA，下载 CRL 或者 OCSP 数据，这又会产生 DNS 查询、建立连接、收发数据等一系列网络通信，增加好几个 RTT。</p>
<p>CRL（Certificate revocation list，证书吊销列表）由 CA 定期发布，里面是所有被撤销信任的证书序号，查询这个列表就可以知道证书是否有效。</p>
<p>但 CRL 因为是”定期”发布，就有”时间窗口”的安全隐患，而且随着吊销证书的增多，列表会越来越大，一个 CRL 经常会上 MB。想象一下，每次需要预先下载几 M 的”无用数据”才能连接网站，实用性实在是太低了。</p>
<p>所以，现在 CRL 基本上不用了，取而代之的是 OCSP（在线证书状态协议，Online Certificate Status Protocol），向 CA 发送查询请求，让 CA 返回证书的有效状态。</p>
<p>但 OCSP 也要多出一次网络请求的消耗，而且还依赖于 CA 服务器，如果 CA 服务器很忙，那响应延迟也是等不起的。</p>
<p>于是又出来了一个”补丁”，叫”OCSP Stapling”（OCSP 装订），它可以让服务器预先访问 CA 获取 OCSP 响应，然后在握手时随着证书一起发给客户端，免去了客户端连接 CA 服务器查询的时间。</p>
<h3 id="会话复用"><a href="#会话复用" class="headerlink" title="会话复用"></a>会话复用</h3><p>回想一下 HTTPS 建立连接的过程：先是 TCP 三次握手，然后是 TLS 一次握手。这后一次握手的重点是算出主密钥”Master Secret”，而主密钥每次连接都要重新计算，未免有点太浪费了，如果能够把”辛辛苦苦”算出来的主密钥缓存一下”重用”，不就可以免去了握手和计算的成本了吗？</p>
<p>这种做法就叫”会话复用”（TLS session resumption），和 HTTP Cache 一样，也是提高 HTTPS 性能的”大杀器”，被浏览器和服务器广泛应用。</p>
<p>会话复用分两种，第一种叫”Session ID”，就是客户端和服务器首次连接后各自保存一个会话的 ID 号，内存里存储主密钥和其他相关的信息。当客户端再次连接时发一个 ID 过来，服务器就在内存里找，找到就直接用主密钥恢复会话状态，跳过证书验证和密钥交换，只用一个消息往返就可以建立安全通信。</p>
<p>实验环境的端口 441 实现了”Session ID”的会话复用，你可以访问 URI <a target="_blank" rel="noopener" href="https://www.chrono.com:441/28-1">https://www.chrono.com:441/28-1</a>，刷新几次，用 Wireshark 抓包看看实际的效果。</p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">Handshake Protocol: Client Hello
    Version: TLS 1.2 (0x0303)
    Session ID: 13564734eeec0a658830cd…
    Cipher Suites Length: 34
 
 
Handshake Protocol: Server Hello
    Version: TLS 1.2 (0x0303)
    Session ID: 13564734eeec0a658830cd…
    Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (0xc030)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过抓包可以看到，服务器在”ServerHello”消息后直接发送了”Change Cipher Spec”和”Finished”消息，复用会话完成了握手。</p>
<p>实际复现方法：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token string">"GET /28-1"</span> <span class="token operator">|</span> openssl s_client -connect www.chrono.com:441 -tls1_2 -sess_out session.pem
ssl handshake by TLSv1.2

ssl session <span class="token function">id</span> is <span class="token punctuation">[</span>62ca9b2ef960760e6b3a5f84bc9a21eb3bfd28dbd171e9a7a336ba1c08495261<span class="token punctuation">]</span>

reused? <span class="token boolean">false</span>

$ <span class="token builtin class-name">echo</span> <span class="token string">"GET /28-1"</span> <span class="token operator">|</span> openssl s_client -connect www.chrono.com:441 -tls1_2 -sess_in session.pem
ssl handshake by TLSv1.2

ssl session <span class="token function">id</span> is <span class="token punctuation">[</span>62ca9b2ef960760e6b3a5f84bc9a21eb3bfd28dbd171e9a7a336ba1c08495261<span class="token punctuation">]</span>

reused? <span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《透视HTTP协议》学习笔记/TLS1.2会话复用.png" alt="TLS1.2会话复用"></p>
<h3 id="会话票证"><a href="#会话票证" class="headerlink" title="会话票证"></a>会话票证</h3><p>“Session ID”是最早出现的会话复用技术，也是应用最广的，但它也有缺点，服务器必须保存每一个客户端的会话数据，对于拥有百万、千万级别用户的网站来说存储量就成了大问题，加重了服务器的负担。</p>
<p>于是，又出现了第二种”Session Ticket”方案。</p>
<p>它有点类似 HTTP 的 Cookie，存储的责任由服务器转移到了客户端，服务器加密会话信息，用”New Session Ticket”消息发给客户端，让客户端保存。</p>
<p>重连的时候，客户端使用扩展”session_ticket”发送”Ticket”而不是”Session ID”，服务器解密后验证有效期，就可以恢复会话，开始加密通信。</p>
<p>这个过程也可以在实验环境里测试，端口号是 442，URI 是 <a target="_blank" rel="noopener" href="https://www.chrono.com:442/28-1">https://www.chrono.com:442/28-1</a>。</p>
<p>不过”Session Ticket”方案需要使用一个固定的密钥文件（ticket_key）来加密 Ticket，为了防止密钥被破解，保证”前向安全”，密钥文件需要定期轮换，比如设置为一小时或者一天。</p>
<p>实际复现方法：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token string">"GET /28-1"</span> <span class="token operator">|</span> openssl s_client -connect www.chrono.com:442 -tls1_2 -sess_out session.pem
ssl handshake by TLSv1.2

ssl session <span class="token function">id</span> is <span class="token punctuation">[</span><span class="token punctuation">]</span>

reused? <span class="token boolean">false</span>

$ <span class="token builtin class-name">echo</span> <span class="token string">"GET /28-1"</span> <span class="token operator">|</span> openssl s_client -connect www.chrono.com:442 -tls1_2 -sess_in session.pem
ssl handshake by TLSv1.2

ssl session <span class="token function">id</span> is <span class="token punctuation">[</span>154a4f087c9afd9c386d18e50b98be58beaf5205df1946e9475a0919a427d0bf<span class="token punctuation">]</span>

reused? <span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="预共享密钥"><a href="#预共享密钥" class="headerlink" title="预共享密钥"></a>预共享密钥</h3><p>“False Start””Session ID””Session Ticket”等方式只能实现 1-RTT，而 TLS1.3 更进一步实现了”0-RTT”，原理和”Session Ticket”差不多，但在发送 Ticket 的同时会带上应用数据（Early Data），免去了 1.2 里的服务器确认步骤，这种方式叫”Pre-shared Key”，简称为”PSK”。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《透视HTTP协议》学习笔记/TLS预共享密钥.png" alt="TLS预共享密钥"></p>
<p>但”PSK”也不是完美的，它为了追求效率而牺牲了一点安全性，容易受到”重放攻击”（Replay attack）的威胁。黑客可以截获”PSK”的数据，像复读机那样反复向服务器发送。</p>
<p>解决的办法是只允许安全的 GET/HEAD 方法（参见[第 10 讲]），在消息里加入时间戳、”nonce”验证，或者”一次性票证”限制重放。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">rm</span> -f session.pem <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">echo</span> <span class="token string">"GET /28-1"</span> <span class="token operator">|</span> openssl s_client -connect www.chrono.com:444 -tls1_3 -sess_out session.pem
ssl handshake by TLSv1.3

ssl session <span class="token function">id</span> is <span class="token punctuation">[</span>4686648639a518eee07db85218bd6c5a8bdf0df5ffb03e751c3612d27028a012<span class="token punctuation">]</span>

reused? <span class="token boolean">false</span>

$ <span class="token builtin class-name">echo</span> <span class="token string">"GET /28-1"</span> <span class="token operator">&gt;</span> early_data.txt <span class="token operator">&amp;&amp;</span> openssl s_client -connect www.chrono.com:444 -tls1_3 -sess_in session.pem -early_data early_data.txt
ssl handshake by TLSv1.3

ssl session <span class="token function">id</span> is <span class="token punctuation">[</span>4686648639a518eee07db85218bd6c5a8bdf0df5ffb03e751c3612d27028a012<span class="token punctuation">]</span>

reused? <span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="课外小贴士-9"><a href="#课外小贴士-9" class="headerlink" title="课外小贴士"></a>课外小贴士</h3><ol>
<li>使用”SSL 加速卡”的一个案例是阿里的Tengine，它基于 Intel QAT 加速卡，定制了Nginx和 OpenSSL.</li>
<li>因为 OCSP 会增加额外的网络连接成本，所以Chrome 等浏览器的策略是只对 EV 证书使用OCSP 检查有效性，普通网站使用 DV、OV 证书省略了这个操作，就会略微快一点。</li>
<li>在 Nginx 里可以用指令”ssl_stapling on”开启”OCSP Stapling”，而在 OpenResty 里更可以编写 Lua 代码灵活定制。</li>
<li>“Session ID”和”Session Ticket”这两种会话复用技术在 TLS1.3 中均已经被废除，只能使用 PSK 实现会话复用。</li>
</ol>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://kibazen.cn" rel="external nofollow noreferrer">Kiba Amor</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                    </span>
                <span class="reprint-info">
                    <a href="https://kibazen.cn/tou-shi-http-xie-yi-xue-xi-bi-ji/">https://kibazen.cn/tou-shi-http-xie-yi-xue-xi-bi-ji/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY-NC-ND 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://kibazen.cn" target="_blank">Kiba Amor</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/HTTP/">
                                    <span class="chip bg-color">HTTP</span>
                                </a>
                            
                                <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                                    <span class="chip bg-color">极客时间</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/share/css/share.min.css">
<div id="article-share">

    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/tou-shi-http-xie-yi-xue-xi-bi-ji/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/9.jpg" class="responsive-img" alt="《透视HTTP协议》学习笔记">
                        
                        <span class="card-title">《透视HTTP协议》学习笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-08-26
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                    学习笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/HTTP/">
                        <span class="chip bg-color">HTTP</span>
                    </a>
                    
                    <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                        <span class="chip bg-color">极客时间</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/service-mesh-shi-zhan-xue-xi-bi-ji/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/13.jpg" class="responsive-img" alt="《Service Mesh实战》学习笔记">
                        
                        <span class="card-title">《Service Mesh实战》学习笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-08-09
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                    学习笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                        <span class="chip bg-color">极客时间</span>
                    </a>
                    
                    <a href="/tags/ServiceMesh/">
                        <span class="chip bg-color">ServiceMesh</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('2'),
            headingSelector: 'h2, h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2024</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">Kiba Amor</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/kibaamor" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:5093911+kibaamor@users.noreply.github.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>













    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

    
    

    

    

	
    

    

    

    
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
