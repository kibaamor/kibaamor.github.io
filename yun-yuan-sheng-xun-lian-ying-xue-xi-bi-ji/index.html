<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <meta name="keywords" content="《云原生训练营》学习笔记, kiba, zen, amor, kibazen, kibaamor, 木叶, 木叶禅">
    <meta name="description" content="You are too concerned with what was and what will be">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>《云原生训练营》学习笔记 | 木叶禅</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/css/my.css">

    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="木叶禅" type="application/atom+xml">
</head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">木叶禅</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/learn/" class="waves-effect waves-light">
      
      <i class="fas fa-book" style="zoom: 0.6;"></i>
      
      <span>Learn</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/memo/" class="waves-effect waves-light">
      
      <i class="fas fa-sticky-note" style="zoom: 0.6;"></i>
      
      <span>Memo</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories/" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags/" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about/" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">木叶禅</div>
        <div class="logo-desc">
            
            You are too concerned with what was and what will be
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/learn/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-book"></i>
			
			Learn
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/memo/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-sticky-note"></i>
			
			Memo
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    
<script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = 'f65e070788a2647953051a7a1b70ada7fd2b3f70cd4d93c977207f5b762987d4';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/7.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">《云原生训练营》学习笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                                <span class="chip bg-color">极客时间</span>
                            </a>
                        
                            <a href="/tags/kubernetes/">
                                <span class="chip bg-color">kubernetes</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                学习笔记
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-03-16
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2024-05-03
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    15.6k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    61 分
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>课程资源： <a target="_blank" rel="noopener" href="https://github.com/kibaamor/101">https://github.com/kibaamor/101</a></p>
<h2 id="Go-语言特性"><a href="#Go-语言特性" class="headerlink" title="Go 语言特性"></a>Go 语言特性</h2><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h4 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h4><ul>
<li>并发（concurrency）：两个或多个事件在同一时间间隔发生。</li>
<li>并行（parallellism）：两个或者多个事件在同一时刻发生。</li>
</ul>
<h2 id="Go-语言进阶"><a href="#Go-语言进阶" class="headerlink" title="Go 语言进阶"></a>Go 语言进阶</h2><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><h4 id="深入理解-Go-语言线程调度"><a href="#深入理解-Go-语言线程调度" class="headerlink" title="深入理解 Go 语言线程调度"></a>深入理解 Go 语言线程调度</h4><ul>
<li>进程：资源分配的基本单位</li>
<li>线程：调度的基本单位</li>
<li>无论是线程还是进程，在 linux 中都以 task_struct 描述，从内核角度看，与进程无本质区别</li>
<li>Glibc 中的 pthread 库提供 NPTL（Native POSIX Threading Library）支持</li>
</ul>
<h4 id="进程切换开销"><a href="#进程切换开销" class="headerlink" title="进程切换开销"></a>进程切换开销</h4><ol>
<li>直接开销<ul>
<li>切换页表全局目录（PGD）</li>
<li>切换内核态堆栈</li>
<li>切换硬件上下文（进程恢复前，必须装入寄存器的数据统称为硬件上下文）</li>
<li>刷新TLB</li>
<li>系统调度器的代码执行</li>
</ul>
</li>
<li>间接开销<ul>
<li>CPU 缓存失效导致的进程需要到内存直接访问的IO 操作变多</li>
</ul>
</li>
</ol>
<h4 id="线程切换开销"><a href="#线程切换开销" class="headerlink" title="线程切换开销"></a>线程切换开销</h4><ul>
<li>线程本质上只是一批共享资源的进程，线程切换本质上依然需要内核进行进程切换。</li>
<li>一组线程因为共享内存资源，因此一个进程的所有线程共享虚拟地址空间，线程切换相比进程切换，<strong>主要节省了虚拟地址空间的切换</strong>。</li>
</ul>
<h4 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h4><p>Go 语言基于 GMP 模型实现用户态线程</p>
<ul>
<li>G：表示 goroutine，每个 goroutine 都有自己的栈空间，定时器，初始化的栈空间在2k 左右，空间会随着需求增长。</li>
<li>M：抽象化代表内核线程，记录内核线程栈信息，当 goroutine 调度到线程时，使用该 goroutine 自己的栈信息。</li>
<li>P：代表调度器，负责调度 goroutine，维护一个本地 goroutine 队列，M 从 P 上获得 goroutine 并执行，同时还负责部分内存的管理。</li>
</ul>
<h4 id="GMP模型细节"><a href="#GMP模型细节" class="headerlink" title="GMP模型细节"></a>GMP模型细节</h4><p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/GMP模型细节.png" alt="GMP模型细节"></p>
<h4 id="G-所处的位置"><a href="#G-所处的位置" class="headerlink" title="G 所处的位置"></a>G 所处的位置</h4><ul>
<li>进程都有一个全局的 G 队列</li>
<li>每个 P 拥有自己的本地执行队列</li>
<li>有不在运行队列中的 G<ul>
<li>处于 channel 阻塞态的 G 被放在 sudog</li>
<li>脱离 P 绑定在 M 上的 G，如系统调用</li>
<li>为了复用，执行结束进入 P 的 gFree 列表中的 G</li>
</ul>
</li>
</ul>
<h4 id="Goroutine-创建过程"><a href="#Goroutine-创建过程" class="headerlink" title="Goroutine 创建过程"></a>Goroutine 创建过程</h4><ul>
<li>获取或者创建新的 Goroutine 结构体<ul>
<li>从处理器的 gFree 列表中查找空闲的 Goroutine</li>
<li>如果不存在空闲的 Goroutine，会通过 runtime.malg 创建一个栈大小足够的新结构体</li>
</ul>
</li>
<li>将函数传入的参数移到 Goroutine 的栈上</li>
<li>更新 Goroutine 调度相关的属性，更新状态为 _Grunnable</li>
<li>返回的 Goroutine 会存储到全局变量 allgs 中</li>
</ul>
<h4 id="将-Goroutine-放到运行队列上"><a href="#将-Goroutine-放到运行队列上" class="headerlink" title="将 Goroutine 放到运行队列上"></a>将 Goroutine 放到运行队列上</h4><blockquote>
<p>关键函数 <code>func runqput(pp *p, gp *g, next bool)</code></p>
</blockquote>
<ul>
<li>Goroutine 设置到处理器的 runnext 作为下一个处理器执行的任务</li>
<li>当处理器的本地运行队列已经没有剩余空间时，就会把本地队列中的前一半 Goroutine 和待加入的 Goroutine 一起打乱顺序后通过 <code>runtime.runqputslow</code> 添加到调度器持有的全局运行队列上</li>
</ul>
<h4 id="调度器行为"><a href="#调度器行为" class="headerlink" title="调度器行为"></a>调度器行为</h4><blockquote>
<p>关键函数 <code>func schedule()</code></p>
<p>可以参考的资料<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/586236582">《深入分析Go1.18 GMP调度器底层原理》</a></p>
</blockquote>
<ul>
<li>为了保证公平，当全局运行队列中有待执行的 Goroutine 时，通过 schedtick 保证有一定几率(1/61) 通过 <code>runtime.globrunqget</code> 从全局的运行队列中查找一个的 Goroutine 来运行</li>
<li>从处理器本地的运行队列中查找待执行的 Goroutine</li>
<li>如果前两种方法都没有找到 Goroutine，会通过 <code>runtime.findrunnable</code> 进行阻塞地查找 Goroutine</li>
<li>从本地运行队列、全局运行队列中查找</li>
<li>从网络轮询器中查找是否有 Goroutine 等待运行</li>
<li>通过 runtime.runqsteal 尝试从其他随机的处理器中窃取待运行的 Goroutine</li>
</ul>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="TCMalloc"><a href="#TCMalloc" class="headerlink" title="TCMalloc"></a>TCMalloc</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://goog-perftools.sourceforge.net/doc/tcmalloc.html">TCMalloc : Thread-Caching Malloc</a></p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/TCMalloc.png" alt="TCMalloc"></p>
<ul>
<li>page: 内存页，一块 8K 大小的内存空间。Go 与操作系统之间的内存申请和释放，都是以 page 为单位的</li>
<li>span: 内存块，一个或多个连续的 page 组成一个 span</li>
<li>sizeclass: 空间规格，每个 span 都带有一个 sizeclass ，标记着该 span 中的 page 应该如何使用</li>
<li><p>object: 对象，用来存储一个变量数据内存空间，一个 span 在初始化时，会被切割成一堆等大的 object ；假设 object 的大小是 16B ，span 大小是 8K ，那么就会把 span 中的 page 就会被初始化 8K / 16B = 512 个 object 。所谓内存分配，就是分配一个object 出去</p>
</li>
<li><p>对象大小定义</p>
<ul>
<li>小对象大小：0~256KB</li>
<li>中对象大小：256KB~1MB</li>
<li>大对象大小：&gt;1MB</li>
</ul>
</li>
<li>小对象的分配流程<ul>
<li>ThreadCache -&gt; CentralCache -&gt; PageHeap，大部分时候，ThreadCache 缓存都是足够的，不需要去访问 CentralCache 和 PageHeap，无系统调用配合无锁分配，分配效率是非常高的</li>
</ul>
</li>
<li>中对象分配流程<ul>
<li>直接在 PageHeap 中选择适当的大小即可，128 Page 的 Span 所保存的最大内存就是 1MB</li>
</ul>
</li>
<li>大对象分配流程<ul>
<li>从 large span set 选择合适数量的页面组成 span，用来存储数据</li>
</ul>
</li>
</ul>
<h4 id="Go-语言内存分配"><a href="#Go-语言内存分配" class="headerlink" title="Go 语言内存分配"></a>Go 语言内存分配</h4><blockquote>
<p>关键函数 <code>func mallocgc</code></p>
<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.22.1/src/runtime/malloc.go#L7">Go 语言的内存分配器是基于 TCMalloc 实现的</a>。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/coldnight/go-memory-allocator-visual-guide">Go 语言内存分配可视化指南（A visual guide to Go Memory Allocator from scratch (Golang)）</a></p>
<p><a target="_blank" rel="noopener" href="https://www.sobyte.net/post/2021-12/golang-memory-allocator/">Principle of memory allocator implementation in Go language</a></p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/Go语言内存分配.png" alt="Go语言内存分配"></p>
<ul>
<li><p>对象大小定义</p>
<ul>
<li>小（Small）对象：&lt;=32KB<ul>
<li>其中大小 &lt;16B 且不是指针的对象称为微（Tiny）对象</li>
</ul>
</li>
<li>大（Large）对象：&gt;32KB</li>
</ul>
</li>
<li><p>mcache：小对象的内存分配直接走</p>
<ul>
<li>size class 从 1 到 66，每个 class 两个 span （scan 和 noscan）</li>
<li>Span 大小是 8KB，按 span class 大小切分</li>
</ul>
</li>
<li>mcentral<ul>
<li>Span 内的所有内存块都被占用时，没有剩余空间继续分配对象，mcache 会向 mcentral 申请 1 个 span，mcache 拿到 span 后继续分配对象</li>
<li>当 mcentral 向 mcache 提供 span 时，如果没有符合条件的 span，mcentral 会向 mheap 申请 span</li>
</ul>
</li>
<li>mheap<ul>
<li>当 mheap 没有足够的内存时，mheap 会向 OS 申请内存</li>
<li>mheap 把 Span 组织成了树结构，而不是链表</li>
<li>然后把 Span 分配到 heapArena 进行管理，它包含地址映射和 span 是否包含指针等位图<ul>
<li>为了更高效的分配、回收和再利用内存</li>
</ul>
</li>
</ul>
</li>
<li>mspan<ul>
<li>allocBits<ul>
<li>记录了每块内存分配的情况</li>
</ul>
</li>
<li>gcmarkBits<ul>
<li>记录了每块内存的引用情况，标记阶段对每块内存进行标记，有对象引用的内存标记为 1，没有的标记为 0</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Go-语言-GC"><a href="#Go-语言-GC" class="headerlink" title="Go 语言 GC"></a>Go 语言 GC</h4><blockquote>
<p>Golang 的汇编看不懂时可以看 <a target="_blank" rel="noopener" href="https://go.dev/doc/asm">A Quick Guide to Go’s Assembler</a></p>
<p>可以参考的资料<a target="_blank" rel="noopener" href="https://liqingqiya.github.io/golang/gc/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/2020/06/02/gc1.html">《Golang 垃圾回收（一）概述》</a>、<a target="_blank" rel="noopener" href="https://liqingqiya.github.io/golang/gc/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/2020/06/02/gc2.html">《golang 垃圾回收（二）屏障技术》</a>、<a target="_blank" rel="noopener" href="https://liqingqiya.github.io/golang/gc/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/2020/06/03/gc3.html">《golang 垃圾回收（三）插入写屏障》</a>、<a target="_blank" rel="noopener" href="https://liqingqiya.github.io/golang/gc/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/2020/06/13/gc4.html">《golang 垃圾回收（四）删除写屏障》</a>、<a target="_blank" rel="noopener" href="https://liqingqiya.github.io/golang/gc/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%86%99%E5%B1%8F%E9%9A%9C/2020/07/24/gc5.html">《golang 垃圾回收（五）混合写屏障》</a></p>
</blockquote>
<p>混合写屏障伪代码</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// src/runtime/mbarrier.go</span>

<span class="token comment">// Go uses a hybrid barrier that combines a Yuasa-style deletion</span>
<span class="token comment">// barrier—which shades the object whose reference is being</span>
<span class="token comment">// overwritten—with Dijkstra insertion barrier—which shades the object</span>
<span class="token comment">// whose reference is being written. The insertion part of the barrier</span>
<span class="token comment">// is necessary while the calling goroutine's stack is grey. In</span>
<span class="token comment">// pseudocode, the barrier is:</span>
<span class="token function">writePointer</span><span class="token punctuation">(</span>slot<span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token function">shade</span><span class="token punctuation">(</span><span class="token operator">*</span>slot<span class="token punctuation">)</span>    <span class="token comment">// 删除写屏障（Yuasa-style 屏障）</span>
    <span class="token keyword">if</span> current stack is grey<span class="token punctuation">:</span>
        <span class="token function">shade</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span>  <span class="token comment">// 插入写屏障（Dijkstra屏障）</span>
    <span class="token operator">*</span>slot <span class="token operator">=</span> ptr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Go 实际实现为</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token function">writePointer</span><span class="token punctuation">(</span>slot<span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token function">shade</span><span class="token punctuation">(</span><span class="token operator">*</span>slot<span class="token punctuation">)</span>
    <span class="token function">shade</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span>
    <span class="token operator">*</span>slot <span class="token operator">=</span> ptr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="垃圾回收触发机制"><a href="#垃圾回收触发机制" class="headerlink" title="垃圾回收触发机制"></a>垃圾回收触发机制</h4><ul>
<li>内存分配量达到阀值触发 GC<ul>
<li>每次内存分配时都会检查当前内存分配量是否已达到阀值，如果达到阀值则立即启动 GC。<ul>
<li>阀值 = 上次 GC 内存分配量 * 内存增长率</li>
<li>内存增长率由环境变量 GOGC 控制，默认为 100，即每当内存扩大一倍时启动 GC。</li>
</ul>
</li>
</ul>
</li>
<li>定期触发 GC<ul>
<li>默认情况下，最长 2 分钟触发一次 GC，这个间隔在 <code>src/runtime/proc.go:forcegcperiod</code> 变量中被声明</li>
</ul>
</li>
<li>手动触发<ul>
<li>程序代码中也可以使用 <code>runtime.GC()</code> 来手动触发 GC。这主要用于 GC 性能测试和统计。</li>
</ul>
</li>
</ul>
<h3 id="动手编写一个-HTTP-Server"><a href="#动手编写一个-HTTP-Server" class="headerlink" title="动手编写一个 HTTP Server"></a>动手编写一个 HTTP Server</h3><h4 id="Linux-epoll"><a href="#Linux-epoll" class="headerlink" title="Linux epoll"></a>Linux epoll</h4><p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/LinuxEpoll.png" alt="LinuxEpoll"></p>
<h4 id="HttpServer-的实现细节"><a href="#HttpServer-的实现细节" class="headerlink" title="HttpServer 的实现细节"></a>HttpServer 的实现细节</h4><p>Go 语言将协程与 fd 资源绑定</p>
<ul>
<li>一个 socket fd 与一个协程绑定</li>
<li>当 socket fd 未就绪时，将对应协程设置为 Gwaiting 状态，将 CPU 时间片让给其他协程</li>
<li>Go 语言 runtime 调度器进行调度唤醒协程时，检查 fd 是否就绪，如果就绪则将协程置为 Grunnable 并加入执行队列</li>
<li>协程被调度后处理 fd 数据</li>
</ul>
<h2 id="Docker-核心技术"><a href="#Docker-核心技术" class="headerlink" title="Docker 核心技术"></a>Docker 核心技术</h2><h3 id="理解Docker"><a href="#理解Docker" class="headerlink" title="理解Docker"></a>理解Docker</h3><h4 id="Linux-内核代码中-Namespace-的实现"><a href="#Linux-内核代码中-Namespace-的实现" class="headerlink" title="Linux 内核代码中 Namespace 的实现"></a>Linux 内核代码中 Namespace 的实现</h4><p>进程数据结构</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// include/linux/sched.h</span>
<span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token punctuation">{</span>
    <span class="token comment">//...</span>

    <span class="token comment">/* Namespaces: */</span>
    <span class="token keyword">struct</span> <span class="token class-name">nsproxy</span> <span class="token operator">*</span>nsproxy<span class="token punctuation">;</span>

    <span class="token comment">//...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Namespace 数据结构</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// include/linux/nsproxy.h</span>

<span class="token comment">/*
 * A structure to contain pointers to all per-process
 * namespaces - fs (mount), uts, network, sysvipc, etc.
 *
 * The pid namespace is an exception -- it's accessed using
 * task_active_pid_ns.  The pid namespace here is the
 * namespace that children will use.
 *
 * 'count' is the number of tasks holding a reference.
 * The count for each namespace, then, will be the number
 * of nsproxies pointing to it, not the number of tasks.
 *
 * The nsproxy is shared by tasks which share all namespaces.
 * As soon as a single namespace is cloned or unshared, the
 * nsproxy is copied.
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">nsproxy</span> <span class="token punctuation">{</span>
    refcount_t count<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">uts_namespace</span> <span class="token operator">*</span>uts_ns<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">ipc_namespace</span> <span class="token operator">*</span>ipc_ns<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">mnt_namespace</span> <span class="token operator">*</span>mnt_ns<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">pid_namespace</span> <span class="token operator">*</span>pid_ns_for_children<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">net</span> <span class="token operator">*</span>net_ns<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">time_namespace</span> <span class="token operator">*</span>time_ns<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">time_namespace</span> <span class="token operator">*</span>time_ns_for_children<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">cgroup_namespace</span> <span class="token operator">*</span>cgroup_ns<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="Linux-对-Namespace-操作方法"><a href="#Linux-对-Namespace-操作方法" class="headerlink" title="Linux 对 Namespace 操作方法"></a>Linux 对 Namespace 操作方法</h4><h5 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h5><p>在创建新进程的系统调用时，可以通过 flags 参数指定需要新建的 Namespace 类型：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// CLONE_NEWCGROUP / CLONE_NEWIPC / CLONE_NEWNET / CLONE_NEWNS / CLONE_NEWPID / CLONE_NEWUSER / CLONE_NEWUTS</span>
<span class="token keyword">int</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>fn<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>child_stack<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h5 id="setns"><a href="#setns" class="headerlink" title="setns"></a>setns</h5><p>该系统调用可以让调用进程加入某个已经存在的 Namespace 中：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">Int <span class="token function">setns</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> nstype<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h5 id="unshare"><a href="#unshare" class="headerlink" title="unshare"></a>unshare</h5><p>该系统调用可以将调用进程移动到新的 Namespace 下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">unshare</span><span class="token punctuation">(</span><span class="token keyword">int</span> flags<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="关于-namespace-的常用操作"><a href="#关于-namespace-的常用操作" class="headerlink" title="关于 namespace 的常用操作"></a>关于 namespace 的常用操作</h4><ul>
<li>查看当前系统的 namespace：<code>lsns -t &lt;type&gt;</code></li>
<li>查看某进程的 namespace：<code>ls -la /proc/&lt;pid&gt;/ns/</code></li>
<li>查看某命令的 namespace: <code>sudo lsns | grep &lt;command name&gt;</code></li>
<li>进入某 namespace 运行命令：<code>nsenter -t &lt;pid&gt; -n ip addr</code></li>
<li>在新 network namespace 运行命令：<code>unshare -fn sleep 60</code></li>
</ul>
<h4 id="Linux-内核代码中-Cgroups-的实现"><a href="#Linux-内核代码中-Cgroups-的实现" class="headerlink" title="Linux 内核代码中 Cgroups 的实现"></a>Linux 内核代码中 Cgroups 的实现</h4><p>进程数据结构</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// include/linux/sched.h</span>
<span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token punctuation">{</span>
    <span class="token comment">//...</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_CGROUPS</span></span>
    <span class="token comment">/* Control Group info protected by css_set_lock: */</span>
    <span class="token keyword">struct</span> <span class="token class-name">css_set</span> __rcu <span class="token operator">*</span>cgroups<span class="token punctuation">;</span>
    <span class="token comment">/* cg_list protected by css_set_lock and tsk-&gt;alloc_lock: */</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> cg_list<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

    <span class="token comment">//...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>css_set</code> 是 <code>cgroup_subsys_state</code> 对象的集合数据结构</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// include/linux/cgroup-defs.h</span>

<span class="token comment">/*
 * A css_set is a structure holding pointers to a set of
 * cgroup_subsys_state objects. This saves space in the task struct
 * object and speeds up fork()/exit(), since a single inc/dec and a
 * list_add()/del() can bump the reference count on the entire cgroup
 * set for a task.
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">css_set</span> <span class="token punctuation">{</span>
    <span class="token comment">/*
    * Set of subsystem states, one for each subsystem. This array is
    * immutable after creation apart from the init_css_set during
    * subsystem registration (at boot time).
    */</span>
    <span class="token keyword">struct</span> <span class="token class-name">cgroup_subsys_state</span> <span class="token operator">*</span>subsys<span class="token punctuation">[</span>CGROUP_SUBSYS_COUNT<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment">//...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="cgroups"><a href="#cgroups" class="headerlink" title="cgroups"></a>cgroups</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/resource_management_guide/ch-subsystems_and_tunable_parameters">Chapter 3. Subsystems and Tunable Parameters</a></p>
</blockquote>
<p>cgroups 实现了对资源的配额和度量</p>
<ul>
<li>blkio： 这个子系统设置限制每个块设备的输入输出控制。例如:磁盘，光盘以及 USB 等等。</li>
<li>CPU： 这个子系统使用调度程序为 cgroup 任务提供 CPU 的访问。</li>
<li>cpuacct： 产生 cgroup 任务的CPU 资源报告。</li>
<li>cpuset： 如果是多核心的 CPU，这个子系统会为 cgroup 任务分配单独的 CPU 和内存。</li>
<li>devices： 允许或拒绝 cgroup 任务对设备的访问。</li>
<li>freezer： 暂停和恢复 cgroup 任务。</li>
<li>memory： 设置每个 cgroup 的内存限制以及产生内存资源报告。</li>
<li>net_cls： 标记每个网络包以供 cgroup 方便使用。</li>
<li>ns： 名称空间子系统。</li>
<li>pid: 进程标识子系统。</li>
</ul>
<h4 id="CPU-子系统"><a href="#CPU-子系统" class="headerlink" title="CPU 子系统"></a>CPU 子系统</h4><ul>
<li>cpu.shares： 可出让的能获得 CPU 使用时间的相对值。<br>  <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/cpu-shares.png" alt="cpu-shares"></li>
<li>cpu.cfs_period_us：cfs_period_us 用来配置时间周期长度，单位为 us（微秒）。<br>  <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/cpu-period-quota.png" alt="cpu-period-quota"></li>
<li>cpu.cfs_quota_us：cfs_quota_us 用来配置当前 Cgroup 在 cfs_period_us 时间内最多能使用的 CPU 时间数，单位为 us（微秒）。</li>
<li>cpu.stat ： Cgroup 内的进程使用的 CPU 时间统计。</li>
<li>nr_periods ： 经过 cpu.cfs_period_us 的时间周期数量。</li>
<li>nr_throttled ： 在经过的周期内，有多少次因为进程在指定的时间周期内用光了配额时间而受到限制。</li>
<li>throttled_time ： Cgroup 中的进程被限制使用CPU 的总用时，单位是 ns（纳秒）</li>
</ul>
<h4 id="Linux-调度器"><a href="#Linux-调度器" class="headerlink" title="Linux 调度器"></a>Linux 调度器</h4><p>内核默认提供了 5 个调度器，Linux 内核使用 <code>struct sched_class</code> 来对调度器进行抽象：</p>
<ul>
<li>Stop 调度器，<code>stop_sched_class</code>：优先级最高的调度类，可以抢占其他所有进程，不能被其他进程抢占；</li>
<li>Deadline 调度器，<code>dl_sched_class</code>：使用红黑树，把进程按照绝对截止期限进行排序，选择最小进程进行调度运行；</li>
<li>RT 调度器， <code>rt_sched_class</code>：实时调度器，为每个优先级维护一个队列；</li>
<li>CFS 调度器， <code>cfs_sched_class</code>：完全公平调度器，采用完全公平调度算法，引入虚拟运行时间概念；</li>
<li>IDLE-Task 调度器， <code>idle_sched_class</code>：空闲调度器，每个 CPU 都会有一个 idle 线程，当没有其他进程可以调度时，调度运行 idle 线程。</li>
</ul>
<h4 id="CFS-调度器"><a href="#CFS-调度器" class="headerlink" title="CFS 调度器"></a>CFS 调度器</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/XiaoliBoy/p/10410686.html">Linux内核CFS调度器</a>, <a target="_blank" rel="noopener" href="http://www.wowotech.net/process_management/451.html">CFS调度器（5）-带宽控制</a></p>
</blockquote>
<p>CFS 是 Completely Fair Scheduler 简称，即完全公平调度器。</p>
<ul>
<li>CFS 实现的主要思想是维护为任务提供处理器时间方面的平衡，这意味着应给进程分配相当数量的处理器。</li>
<li>分给某个任务的时间失去平衡时，应给失去平衡的任务分配时间，让其执行。</li>
<li><p>CFS 通过虚拟运行时间（vruntime）来实现平衡，维护提供给某个任务的时间量。</p>
<p>  <code>vruntime = 实际运行时间 * 1024 / 进程权重</code></p>
</li>
<li><p>进程按照各自不同的速率在物理时钟节拍内前进，优先级高则权重大，其虚拟时钟比真实时钟跑得慢，但获得比较多的运行时间。</p>
</li>
</ul>
<h4 id="vruntime-红黑树"><a href="#vruntime-红黑树" class="headerlink" title="vruntime 红黑树"></a>vruntime 红黑树</h4><p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/vruntime红黑树.png" alt="vruntime红黑树"></p>
<h4 id="CFS进程调度"><a href="#CFS进程调度" class="headerlink" title="CFS进程调度"></a>CFS进程调度</h4><p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/CFS进程调度.png" alt="CFS进程调度"></p>
<h4 id="cpuacct-子系统"><a href="#cpuacct-子系统" class="headerlink" title="cpuacct 子系统"></a>cpuacct 子系统</h4><p>用于统计 Cgroup 及其子 Cgroup 下进程的 CPU 的使用情况。</p>
<ul>
<li>cpuacct.usage</li>
</ul>
<p>包含该 Cgroup 及其子 Cgroup 下进程使用 CPU 的时间，单位是 ns（纳秒）。</p>
<ul>
<li>cpuacct.stat</li>
</ul>
<p>包含该 Cgroup 及其子 Cgroup 下进程使用的 CPU 时间，以及用户态和内核态的时间。</p>
<h4 id="Memory-子系统"><a href="#Memory-子系统" class="headerlink" title="Memory 子系统"></a>Memory 子系统</h4><ul>
<li><p>memory.usage_in_bytes</p>
<p>  cgroup 下进程使用的内存，包含 cgroup 及其子 cgroup 下的进程使用的内存</p>
</li>
<li><p>memory.max_usage_in_bytes</p>
<p>  cgroup 下进程使用内存的最大值，包含子 cgroup 的内存使用量。</p>
</li>
<li><p>memory.limit_in_bytes</p>
<p>  设置 Cgroup 下进程最多能使用的内存。如果设置为 -1，表示对该 cgroup 的内存使用不做限制。</p>
</li>
<li><p>memory.soft_limit_in_bytes</p>
<p>  这个限制并不会阻止进程使用超过限额的内存，只是在系统内存足够时，会优先回收超过限额的内存，使之向限定值靠拢。</p>
</li>
<li><p>memory.oom_control</p>
<p>  设置是否在 Cgroup 中使用 OOM（Out of Memory）Killer，默认为使用。当属于该 cgroup 的进程使用的内存超过最大的限定值时，会立刻被 OOM Killer 处理。</p>
</li>
</ul>
<h4 id="Cgroup-driver"><a href="#Cgroup-driver" class="headerlink" title="Cgroup driver"></a>Cgroup driver</h4><p>systemd:</p>
<ul>
<li>当操作系统使用 systemd 作为 init system 时，初始化进程生成一个根 cgroup 目录结构并作为 cgroup 管理器。</li>
<li>systemd 与 cgroup 紧密结合，并且为每个 systemd unit 分配 cgroup。</li>
</ul>
<p>cgroupfs:</p>
<ul>
<li>docker 默认用 cgroupfs 作为 cgroup 驱动。</li>
</ul>
<p>存在问题：</p>
<ul>
<li>在 systemd 作为 init system 的系统中，默认并存着两套 groupdriver。</li>
<li>这会使得系统中 Docker 和 kubelet 管理的进程被 cgroupfs 驱动管，而 systemd 拉起的服务由 systemd 驱动管，让 cgroup 管理混乱且容易在资源紧张时引发问题。</li>
</ul>
<p>因此 kubelet 会默认 —cgroup-driver=systemd，若运行时 cgroup 不一致时，kubelet 会报错。</p>
<h4 id="Cgroup-的使用"><a href="#Cgroup-的使用" class="headerlink" title="Cgroup 的使用"></a>Cgroup 的使用</h4><p>可以使用 <code>cgroup-tools</code> 来管理 Cgroup</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 创建一个名为 k 的 CPU 子系统</span>
<span class="token operator">&gt;</span> cgcreate -g cpu:k

<span class="token comment"># 创建后的路径为</span>
<span class="token operator">&gt;</span> <span class="token function">ls</span> /sys/fs/cgroup/cpu/k
cgroup.clone_children  cgroup.procs  cpu.cfs_burst_us  cpu.cfs_period_us  cpu.cfs_quota_us  cpu.idle  cpu.rt_period_us  cpu.rt_runtime_us  cpu.shares  cpu.stat  notify_on_release  tasks

<span class="token comment"># 获取 CPU 配额</span>
<span class="token operator">&gt;</span> cgget -r cpu.cfs_period_us -r cpu.cfs_quota_us k
k:
cpu.cfs_period_us: <span class="token number">100000</span>
cpu.cfs_quota_us: -1

<span class="token comment"># 限制 CPU 使用率为 50%</span>
<span class="token operator">&gt;</span> cgset -r cpu.cfs_quota_us<span class="token operator">=</span><span class="token number">50000</span> k

<span class="token comment"># 确认设置生效</span>
<span class="token operator">&gt;</span> cgget -r cpu.cfs_period_us -r cpu.cfs_quota_us k
k:
cpu.cfs_period_us: <span class="token number">100000</span>
cpu.cfs_quota_us: <span class="token number">50000</span>

<span class="token comment"># 测试</span>
<span class="token operator">&gt;</span> <span class="token function">top</span> -p <span class="token variable"><span class="token variable">$(</span><span class="token function">ps</span> -ef <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'bash -c while : ; do : ; done'</span> <span class="token operator">|</span> <span class="token function">grep</span> -v <span class="token function">grep</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print <span class="token variable">$2</span>}'</span><span class="token variable">)</span></span> -b -n <span class="token number">1</span>
<span class="token function">top</span> - <span class="token number">22</span>:48:54 up  <span class="token number">1</span>:25,  <span class="token number">2</span> users,  load average: <span class="token number">1.54</span>, <span class="token number">1.41</span>, <span class="token number">1.21</span>
Tasks:   <span class="token number">1</span> total,   <span class="token number">1</span> running,   <span class="token number">0</span> sleeping,   <span class="token number">0</span> stopped,   <span class="token number">0</span> zombie
%Cpu<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:  <span class="token number">8.4</span> us,  <span class="token number">0.8</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">86.8</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">4.0</span> si,  <span class="token number">0.0</span> st
MiB Mem <span class="token builtin class-name">:</span>   <span class="token number">7898.4</span> total,    <span class="token number">141.7</span> free,   <span class="token number">2822.3</span> used,   <span class="token number">4934.4</span> buff/cache
MiB Swap:   <span class="token number">2048.0</span> total,   <span class="token number">2042.7</span> free,      <span class="token number">5.3</span> used.   <span class="token number">4779.8</span> avail Mem

    PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
  <span class="token number">33693</span> root      <span class="token number">20</span>   <span class="token number">0</span>    <span class="token number">4784</span>   <span class="token number">3224</span>   <span class="token number">2976</span> R  <span class="token number">53.3</span>   <span class="token number">0.0</span>   <span class="token number">4</span>:32.59 <span class="token function">bash</span>

<span class="token comment"># 删除 CPU 子系统 k</span>
<span class="token operator">&gt;</span> cgdelete cpu:k<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p>Union FS</p>
<ul>
<li>将不同目录挂载到同一个虚拟文件系统下（unite several directories into a single virtual filesystem）的文件系统</li>
<li>支持为每一个成员目录（类似 Git Branch）设定 readonly、readwrite 和 whiteout-able 权限</li>
<li>文件系统分层, 对 readonly 权限的 branch 可以逻辑上进行修改(增量地, 不影响 readonly 部分的)。</li>
<li>通常 Union FS 有两个用途, 一方面可以将多个 disk 挂到同一个目录下, 另一个更常用的就是将一个 readonly 的 branch 和一个 writeable 的 branch 联合在一起。</li>
</ul>
<h4 id="Docker-的文件系统"><a href="#Docker-的文件系统" class="headerlink" title="Docker 的文件系统"></a>Docker 的文件系统</h4><p>典型的 Linux 文件系统组成：</p>
<ul>
<li>Bootfs（boot file system）<ul>
<li>Bootloader - 引导加载 kernel，</li>
<li>Kernel - 当 kernel 被加载到内存中后 umount bootfs。</li>
</ul>
</li>
<li>rootfs （root file system）<ul>
<li>/dev，/proc，/bin，/etc 等标准目录和文件。</li>
<li>对于不同的 linux 发行版, bootfs 基本是一致的，但 rootfs 会有差别。</li>
</ul>
</li>
</ul>
<h4 id="Docker-启动"><a href="#Docker-启动" class="headerlink" title="Docker 启动"></a>Docker 启动</h4><p>Linux</p>
<ul>
<li>在启动后，首先将 rootfs 设置为 readonly, 进行一系列检查, 然后将其切换为 “readwrite” 供用户使用。</li>
</ul>
<p>Docker 启动</p>
<ul>
<li>初始化时也是将 rootfs 以 readonly 方式加载并检查，然而接下来利用 union mount 的方式将一个 readwrite 文件系统挂载在 readonly 的 rootfs 之上；</li>
<li>并且允许再次将下层的 FS（file system） 设定为 readonly 并且向上叠加。</li>
<li>这样一组 readonly 和一个 writeable 的结构构成一个 container 的运行时态, 每一个 FS 被称作一个 FS 层。</li>
</ul>
<h4 id="Docker-写操作"><a href="#Docker-写操作" class="headerlink" title="Docker 写操作"></a>Docker 写操作</h4><p>由于镜像具有共享特性，所以对容器可写层的操作需要依赖存储驱动提供的写时复制和用时分配机制，以此来支持对容器可写层的修改，进而提高对存储和内存资源的利用率。</p>
<ul>
<li>写时复制<ul>
<li>写时复制，即 Copy-on-Write。</li>
<li>一个镜像可以被多个容器使用，但是不需要在内存和磁盘上做多个拷贝。</li>
<li>在需要对镜像提供的文件进行修改时，该文件会从镜像的文件系统被复制到容器的可写层的文件系统进行修改，而镜像里面的文件不会改变。</li>
<li>不同容器对文件的修改都相互独立、互不影响。</li>
</ul>
</li>
<li>用时分配<ul>
<li>按需分配空间，而非提前分配，即当一个文件被创建出来后，才会分配空间。</li>
</ul>
</li>
</ul>
<h4 id="Docker-引擎架构"><a href="#Docker-引擎架构" class="headerlink" title="Docker 引擎架构"></a>Docker 引擎架构</h4><p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/Docker引擎架构.png" alt="Docker引擎架构"></p>
<p>需要注意的是，在这个架构中，运行的 Docker 容器的父进程不是 Docker daemon ，这样就能避免重启 daemon 导致容器也必须重启。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&gt;</span> docker inspect c07 <span class="token operator">|</span> <span class="token function">grep</span> -i pid
            <span class="token string">"Pid"</span><span class="token builtin class-name">:</span> <span class="token number">5621</span>,
            <span class="token string">"PidMode"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,
            <span class="token string">"PidsLimit"</span><span class="token builtin class-name">:</span> null,

<span class="token operator">&gt;</span> <span class="token function">ps</span> -ef <span class="token operator">|</span> <span class="token function">grep</span> <span class="token number">5621</span>
root        <span class="token number">5621</span>    <span class="token number">5600</span>  <span class="token number">0</span> <span class="token number">11</span>:45 pts/0    00:00:00 <span class="token function">zsh</span>

<span class="token operator">&gt;</span> <span class="token function">ps</span> -ef <span class="token operator">|</span> <span class="token function">grep</span> <span class="token number">5600</span>
root        <span class="token number">5600</span>       <span class="token number">1</span>  <span class="token number">0</span> <span class="token number">11</span>:45 ?        00:00:00 /snap/docker/2915/bin/containerd-shim-runc-v2 -namespace moby -id c07f841e7a66cb54f78f72445cb5baf7d479a3c27e8ea03966da1841e3605151 -address /run/snap.docker/containerd/containerd.sock

<span class="token operator">&gt;</span> pstree -H <span class="token number">5600</span> -p -s -T
systemd<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>───containerd-shim<span class="token punctuation">(</span><span class="token number">5600</span><span class="token punctuation">)</span>───zsh<span class="token punctuation">(</span><span class="token number">5621</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h4><ul>
<li>Null(—net=None)<ul>
<li>把容器放入独立的网络空间但不做任何网络配置；</li>
<li>用户需要通过运行 docker network 命令来完成网络配置。</li>
</ul>
</li>
<li>Host<ul>
<li>使用主机网络名空间，复用主机网络。</li>
</ul>
</li>
<li>Container<ul>
<li>重用其他容器的网络。</li>
</ul>
</li>
<li>Bridge(—net=bridge)<ul>
<li>使用 Linux 网桥和 iptables 提供容器互联，Docker 在每台主机上创建一个名叫 docker0 的网桥，通过 veth pair 来连接该主机的每一个 EndPoint。</li>
</ul>
</li>
<li>Overlay(libnetwork, libkv)<ul>
<li>通过网络封包实现。</li>
</ul>
</li>
<li>Remote(work with remote drivers)<ul>
<li>Underlay：使用现有底层网络，为每一个容器配置可路由的网络 IP。</li>
<li>Overlay：通过网络封包实现。</li>
</ul>
</li>
</ul>
<h4 id="Null-模式"><a href="#Null-模式" class="headerlink" title="Null 模式"></a>Null 模式</h4><ol>
<li>Null 模式是一个空实现；</li>
<li>可以通过 Null 模式启动容器并在宿主机上通过命令为容器配置网络。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://github.com/kibaamor/101/blob/master/module3/setup-network.md">https://github.com/kibaamor/101/blob/master/module3/setup-network.md</a></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 以后台的方式运行一个名为 nginx 的 nginx 容器，但不配置网络</span>
<span class="token operator">&gt;</span> docker run --network<span class="token operator">=</span>none --name nginx -d nginx

<span class="token comment"># 获取刚刚运行的 nginx 容器中 nginx 进程在主机上的 Pid</span>
<span class="token operator">&gt;</span> docker inspect -f <span class="token string">'{{.State.Pid}}'</span> nginx
<span class="token number">63648</span>

<span class="token comment"># 查看 nginx 容器的网络配置</span>
<span class="token operator">&gt;</span> nsenter -t <span class="token number">63648</span> -n <span class="token function">ip</span> addr
<span class="token number">1</span>: lo: <span class="token operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="token operator">&gt;</span> mtu <span class="token number">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class="token number">1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet <span class="token number">127.0</span>.0.1/8 scope <span class="token function">host</span> lo
       valid_lft forever preferred_lft forever

<span class="token comment"># 将 nginx 容器进程所使用的 network namespace 连接到 /var/run/netns，这样才能使用 ip netns 命令查看和修改</span>
<span class="token comment"># 创建目录</span>
<span class="token operator">&gt;</span> <span class="token function">mkdir</span> -p /var/run/netns
<span class="token comment"># 链接</span>
<span class="token operator">&gt;</span> <span class="token function">ln</span> -s /proc/63648/ns/net /var/run/netns/63648
<span class="token comment"># 确认链接成功</span>
<span class="token operator">&gt;</span> <span class="token function">ip</span> netns list
<span class="token number">63648</span>

<span class="token comment"># 查看主机上网桥的配置</span>
<span class="token operator">&gt;</span> brctl show
bridge name     bridge <span class="token function">id</span>               STP enabled     interfaces
docker0         <span class="token number">8000</span>.0242b3da2420       no

<span class="token comment"># 显示主机上 docker0 网口的 ip 信息</span>
<span class="token operator">&gt;</span> <span class="token function">ip</span> address show dev docker0
<span class="token number">3</span>: docker0: <span class="token operator">&lt;</span>NO-CARRIER,BROADCAST,MULTICAST,UP<span class="token operator">&gt;</span> mtu <span class="token number">1500</span> qdisc noqueue state DOWN group default
    link/ether 02:42:b3:da:24:20 brd ff:ff:ff:ff:ff:ff
    inet <span class="token number">172.17</span>.0.1/16 brd <span class="token number">172.17</span>.255.255 scope global docker0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:b3ff:feda:2420/64 scope <span class="token function">link</span>
       valid_lft forever preferred_lft forever

<span class="token comment"># 创建 veth pair</span>
<span class="token operator">&gt;</span> <span class="token function">ip</span> <span class="token function">link</span> <span class="token function">add</span> A <span class="token builtin class-name">type</span> veth peer name B

<span class="token comment"># 配置 A</span>
<span class="token comment"># 把 A 添加到网桥 docker0</span>
<span class="token operator">&gt;</span> brctl addif docker0 A
<span class="token comment"># 启动 A</span>
<span class="token operator">&gt;</span> <span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> A up

<span class="token comment"># 配置 B</span>
<span class="token comment"># 将 B 的 network namespace 移动到进程 63648 中</span>
<span class="token operator">&gt;</span> <span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> B netns <span class="token number">63648</span>
<span class="token comment"># 将 B 改名为 eth0</span>
<span class="token operator">&gt;</span> <span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> <span class="token number">63648</span> <span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> dev B name eth0
<span class="token comment"># 启动 eth0</span>
<span class="token operator">&gt;</span> <span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> <span class="token number">63648</span> <span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> eth0 up
<span class="token comment"># 设置 eth0 的 IP 和子网掩码（根据 docker0 信息来）</span>
<span class="token operator">&gt;</span> <span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> <span class="token number">63648</span> <span class="token function">ip</span> addr <span class="token function">add</span> <span class="token number">172.17</span>.0.100/16 dev eth0
<span class="token comment"># 设置 eth0 的默认网关（即为 docker0 的 IP 地址）</span>
<span class="token operator">&gt;</span> <span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> <span class="token number">63648</span> <span class="token function">ip</span> route <span class="token function">add</span> default via <span class="token number">172.17</span>.0.1

<span class="token comment"># 测试能访问 nginx（如果失败，检查一下 HTTP_PROXY 等配置）</span>
<span class="token operator">&gt;</span> <span class="token function">curl</span> <span class="token number">172.17</span>.0.100
<span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>html<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>head<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>title<span class="token operator">&gt;</span>Welcome to nginx<span class="token operator">!</span><span class="token operator">&lt;</span>/title<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>style<span class="token operator">&gt;</span>
html <span class="token punctuation">{</span> color-scheme: light dark<span class="token punctuation">;</span> <span class="token punctuation">}</span>
body <span class="token punctuation">{</span> width: 35em<span class="token punctuation">;</span> margin: <span class="token number">0</span> auto<span class="token punctuation">;</span>
font-family: Tahoma, Verdana, Arial, sans-serif<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token operator">&lt;</span>/style<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/head<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>body<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>h<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>Welcome to nginx<span class="token operator">!</span><span class="token operator">&lt;</span>/h<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>
<span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.<span class="token operator">&lt;</span>/p<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>For online documentation and support please refer to
<span class="token operator">&lt;</span>a <span class="token assign-left variable">href</span><span class="token operator">=</span><span class="token string">"http://nginx.org/"</span><span class="token operator">&gt;</span>nginx.org<span class="token operator">&lt;</span>/a<span class="token operator">&gt;</span>.<span class="token operator">&lt;</span>br/<span class="token operator">&gt;</span>
Commercial support is available at
<span class="token operator">&lt;</span>a <span class="token assign-left variable">href</span><span class="token operator">=</span><span class="token string">"http://nginx.com/"</span><span class="token operator">&gt;</span>nginx.com<span class="token operator">&lt;</span>/a<span class="token operator">&gt;</span>.<span class="token operator">&lt;</span>/p<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>p<span class="token operator">&gt;</span><span class="token operator">&lt;</span>em<span class="token operator">&gt;</span>Thank you <span class="token keyword">for</span> using nginx.<span class="token operator">&lt;</span>/em<span class="token operator">&gt;</span><span class="token operator">&lt;</span>/p<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/body<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/html<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="默认模式-网桥和-NAT"><a href="#默认模式-网桥和-NAT" class="headerlink" title="默认模式 - 网桥和 NAT"></a>默认模式 - 网桥和 NAT</h4><p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/DockerNAT.png" alt="DockerNAT"></p>
<h4 id="Underlay"><a href="#Underlay" class="headerlink" title="Underlay"></a>Underlay</h4><p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/Underlay.png" alt="Underlay"></p>
<h4 id="Overlay"><a href="#Overlay" class="headerlink" title="Overlay"></a>Overlay</h4><ul>
<li>Docker overlay 网络驱动原生支持多主机网络；</li>
<li>Libnetwork 是一个内置的基于 VXLAN 的网络驱动。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/VXLAN.png" alt="VXLAN"></p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/Flannel.png" alt="Flannel"></p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/FlannelPacketSample.png" alt="FlannelPacketSample"></p>
<h3 id="Dockerfile-的最佳实践"><a href="#Dockerfile-的最佳实践" class="headerlink" title="Dockerfile 的最佳实践"></a>Dockerfile 的最佳实践</h3><h4 id="回顾12-Factor-之进程"><a href="#回顾12-Factor-之进程" class="headerlink" title="回顾12 Factor 之进程"></a>回顾12 Factor 之进程</h4><ul>
<li>运行环境中，应用程序通常是以一个和多个<strong>进程</strong>运行的。<ul>
<li>12-Factor 应用的进程必须无状态（Stateless）且无共享（Share nothing）。</li>
</ul>
</li>
<li>任何需要持久化的数据都要存储在后端服务内，比如数据库。<ul>
<li>应在构建阶段将源代码编译成待执行应用。</li>
</ul>
</li>
<li>Session Sticky 是 12-Factor 极力反对的。<ul>
<li>Session 中的数据应该保存在诸如 Memcached 或 Redis 这样的带有过期时间的缓存中。</li>
</ul>
</li>
</ul>
<p><strong>Docker 遵循以上原则管理和构建应用。</strong></p>
<h4 id="理解构建上下文（Build-Context）"><a href="#理解构建上下文（Build-Context）" class="headerlink" title="理解构建上下文（Build Context）"></a>理解构建上下文（Build Context）</h4><ul>
<li>当运行docker build 命令时，当前工作目录被称为构建上下文。</li>
<li>docker build 默认查找当前目录的Dockerfile 作为构建输入，也可以通过 -f 指定Dockerfile。<ul>
<li><code>docker build -f ./Dockerfile</code></li>
</ul>
</li>
<li>当docker build 运行时，首先会把构建上下文传输给 docker daemon，把没用的文件包含在构建上下文时，会导致传输时间长，构建需要的资源多，构建出的镜像大等问题。<ul>
<li>试着到一个包含文件很多的目录运行下面的命令，会感受到差异；</li>
<li><code>docker build -f $GOPATH/src/github.com/cncamp/golang/httpserver/Dockerfile</code> ；</li>
<li><code>docker build $GOPATH/src/github.com/cncamp/golang/httpserver/</code>；</li>
<li>可以通过 <code>.dockerignore</code> 文件从编译上下文排除某些文件。</li>
</ul>
</li>
<li>因此需要确保构建上下文清晰，比如创建一个专门的目录放置 Dockerfile，并在目录中运行 <code>docker build</code>。</li>
</ul>
<h4 id="Build-Cache"><a href="#Build-Cache" class="headerlink" title="Build Cache"></a>Build Cache</h4><p>构建容器镜像时，Docker 依次读取 Dockerfile 中的指令，并按顺序依次执行构建指令。<br>Docker 读取指令后，会先判断缓存中是否有可用的已存镜像，只有已存镜像不存在时才会重新构建。</p>
<ul>
<li>通常 Docker 简单判断 Dockerfile 中的指令与镜像。</li>
<li>针对 ADD 和 COPY 指令，Docker 判断该镜像层每一个文件的内容并生成一个 checksum，与现存镜像比较时，Docker 比较的是二者的 checksum。</li>
<li>其他指令，比如 <code>RUN apt-get -y update</code>，Docker 简单比较与现存镜像中的指令字串是否一致。</li>
<li>当某一层 cache 失效以后，所有所有层级的 cache 均一并失效，后续指令都重新构建镜像。</li>
</ul>
<h4 id="Dockerfile-常用指令"><a href="#Dockerfile-常用指令" class="headerlink" title="Dockerfile 常用指令"></a>Dockerfile 常用指令</h4><ul>
<li><p>FROM：选择基础镜像，推荐alpine</p>
<p>  <code>FROM [--platform=&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]</code></p>
</li>
<li><p>LABELS：按标签组织项目</p>
<p>  LABEL multi.label1=”value1” multi.label2=”value2” other=”value3”</p>
<p>  配合label filter 可过滤镜像查询结果</p>
<p>  <code>docker images -f label=multi.label1="value1"</code></p>
</li>
<li><p>RUN：执行命令</p>
<p>  最常见的用法是 RUN apt-get update &amp;&amp; apt-get install，这两条命令应该永远用 &amp;&amp; 连接，如果分开执行，RUN apt-get update 构建层被缓存，可能会导致新 package 无法安装</p>
</li>
<li><p>CMD：容器镜像中包含应用的运行命令，需要带参数</p>
<p>  CMD [“executable”, “param1”, “param2”…]</p>
</li>
<li><p>EXPOSE：发布端口</p>
<p>  <code>EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</code></p>
<ul>
<li><p>是镜像创建者和使用者的约定</p>
</li>
<li><p>在 docker run -P 时，docker 会自动映射 expose 的端口到主机大端口，如 0.0.0.0:32768-&gt;80/tcp</p>
</li>
</ul>
</li>
<li><p>ENV 设置环境变量</p>
<p>  <code>ENV &lt;key&gt;=&lt;value&gt;</code> …</p>
</li>
<li><p>ADD：从源地址（文件，目录或者URL）复制文件到目标路径</p>
<p>  <code>ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</code></p>
<p>  <code>ADD [--chown=&lt;user&gt;:&lt;group&gt;] ["&lt;src&gt;",... "&lt;dest&gt;"]</code> （路径中有空格时使用）</p>
<ul>
<li><p>ADD 支持 Go 风格的通配符，如 ADD check* /testdir/</p>
</li>
<li><p>src 如果是文件，则必须包含在编译上下文中，ADD 指令无法添加编译上下文之外的文件</p>
</li>
<li><p>src 如果是URL</p>
<ul>
<li>如果 dest 结尾没有 /，那么 dest 是目标文件名，如果 dest 结尾有 /，那么 dest 是目标目录名</li>
</ul>
</li>
<li><p>如果 src 是一个目录，则所有文件都会被复制至 dest</p>
</li>
<li><p><strong>如果 src 是一个本地压缩文件，则在 ADD 的同时完整解压操作</strong></p>
</li>
<li><p>如果 dest 不存在，则 ADD 指令会创建目标目录</p>
</li>
<li><p>应尽量减少通过 ADD URL 添加 remote 文件，建议使用 curl 或者 wget &amp;&amp; untar （维护起来理解成本高）</p>
</li>
</ul>
</li>
<li><p>COPY：从源地址（文件，目录或者URL）复制文件到目标路径</p>
<p>  <code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</code></p>
<p>  <code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] ["&lt;src&gt;",... "&lt;dest&gt;"]</code> // 路径中有空格时使用</p>
<ul>
<li><p>COPY 的使用与 ADD 类似，但有如下区别</p>
<ul>
<li><p>COPY 只支持本地文件的复制，不支持URL</p>
</li>
<li><p><strong>COPY 不解压文件</strong></p>
</li>
<li><p>COPY 可以用于多阶段编译场景，可以用前一个临时镜像中拷贝文件</p>
<p>  COPY —from=build /bin/project /bin/project</p>
</li>
</ul>
</li>
<li><p>COPY 语义上更直白，复制本地文件时，优先使用 COPY</p>
</li>
</ul>
</li>
<li><p>ENTRYPOINT：定义可以执行的容器镜像入口命令</p>
<p>  ENTRYPOINT [“executable”, “param1”, “param2”] // docker run参数追加模式</p>
<p>  ENTRYPOINT command param1 param2 // docker run 参数替换模式</p>
<ul>
<li><p>docker run -entrypoint 可替换 Dockerfile 中定义的 ENTRYPOINT</p>
</li>
<li><p>ENTRYPOINT 的最佳实践是用 ENTRYPOINT 定义镜像主命令，并通过 CMD 定义主要参数，如下所示</p>
<p>  ENTRYPOINT [“s3cmd”]</p>
<p>  CMD [“—help”]</p>
</li>
</ul>
</li>
<li><p>VOLUME： 将指定目录定义为外挂存储卷，Dockerfile 中在该指令之后所有对同一目录的修改都无效</p>
<p>  VOLUME [“/data”]</p>
<p>  等价于docker run -v /data，可通过docker inspect 查看主机的mount point，<code>/var/lib/docker/volumes/&lt;containerid&gt;/_data</code></p>
</li>
<li><p>USER：切换运行镜像的用户和用户组，因安全性要求，越来越多的场景要求容器应用要以 non-root 身份运行</p>
<p>  <code>USER &lt;user&gt;[:&lt;group&gt;]</code></p>
</li>
<li><p>WORKDIR：等价于cd，切换工作目录</p>
<p>  WORKDIR /path/to/workdir</p>
</li>
<li><p>其他非常用指令</p>
<ul>
<li>ARG</li>
<li>ONBUILD</li>
<li>STOPSIGNAL</li>
<li>HEALTHCHECK</li>
<li>SHELL</li>
</ul>
</li>
</ul>
<h4 id="Dockerfile-最佳实践"><a href="#Dockerfile-最佳实践" class="headerlink" title="Dockerfile 最佳实践"></a>Dockerfile 最佳实践</h4><p><strong>目标：易管理、少漏洞、镜像小、层级少、利用缓存。</strong></p>
<ul>
<li>不要安装无效软件包。</li>
<li>应简化镜像中同时运行的进程数，理想状况下，每个镜像应该只有一个进程。</li>
<li>当无法避免同一镜像运行多进程时，应选择合理的初始化进程（init process）。</li>
<li>最小化层级数<ul>
<li>最新的 docker 只有 RUN，COPY，ADD 创建新层，其他指令创建临时层，不会增加镜像大小。<ul>
<li>比如 EXPOSE 指令就不会生成新层。</li>
</ul>
</li>
<li>多条RUN 命令可通过连接符连接成一条指令集以减少层数。</li>
<li>通过多段构建减少镜像层数。</li>
</ul>
</li>
<li>把多行参数按字母排序，可以减少可能出现的重复参数，并且提高可读性。</li>
<li>编写 dockerfile 的时候，应该把变更频率低的编译指令优先构建以便放在镜像底层以有效利用 build cache。</li>
<li>复制文件时，每个文件应独立复制，这确保某个文件变更时，只影响改文件对应的缓存。</li>
</ul>
<h4 id="多进程的容器镜像"><a href="#多进程的容器镜像" class="headerlink" title="多进程的容器镜像"></a>多进程的容器镜像</h4><ul>
<li>选择适当的 init 进程<ul>
<li>需要捕获 SIGTERM 信号并完成子进程的优雅终止</li>
<li>负责清理退出的子进程以避免僵尸进程</li>
</ul>
</li>
</ul>
<p>开源项目</p>
<p><a target="_blank" rel="noopener" href="https://github.com/krallin/tini">https://github.com/krallin/tini</a></p>
<h4 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h4><p>创建私有镜像仓库</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://distribution.github.io/distribution/">https://distribution.github.io/distribution/</a></p>
<p> <code>docker run -d -p 5000:5000 registry</code></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://goharbor.io/">https://goharbor.io/</a></p>
</li>
</ol>
<h2 id="Kubernetes-架构原则和对象设计"><a href="#Kubernetes-架构原则和对象设计" class="headerlink" title="Kubernetes 架构原则和对象设计"></a>Kubernetes 架构原则和对象设计</h2><h3 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h3><h4 id="什么是云计算"><a href="#什么是云计算" class="headerlink" title="什么是云计算"></a>什么是云计算</h4><p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/云计算.png" alt="云计算"></p>
<p>云计算是对所有计算资源、网络资源和存储资源的一种抽象。</p>
<p>怎么理解呢？</p>
<p>比如，有 5000 台机器。</p>
<ol>
<li>我们可以从网络上打通，把它们形成一个集群。</li>
<li>我们可以有一个用于控制的控制平面，把这些计算资源抽象出来。</li>
</ol>
<p>我们就能知道这 5000 个节点，每个节点上有多少 CPU、内存等。对于整个集群来说，我们也知道哪些节点是健康的，哪些节点是不健康的。谁能参与计算，谁不能参与计算等。这样我们就拥有了一个大的计算池。</p>
<p>上面是从云平台侧考虑的，做了资源的抽象。</p>
<p>另一方面，从业务的角度来说，业务也不用管作业实际部署在哪儿，只用告诉云平台某个业务需要多少实例，每个实例需要多少 CPU 和内存等资源信息即可。云平台会自动找合适节点来运行业务。</p>
<p>这就是云计算，对计算资源做一个抽象，让业务面向抽象的计算资源来部署应用。</p>
<h4 id="云计算平台的分类"><a href="#云计算平台的分类" class="headerlink" title="云计算平台的分类"></a>云计算平台的分类</h4><p>以 Openstack 为典型的<strong>虚拟化平台</strong></p>
<ul>
<li>虚拟机构建和业务代码部署分离。</li>
<li>可变的基础架构使后续维护风险变大。</li>
</ul>
<p>以谷歌 borg 为典型的<strong>基于进程的作业调度平台</strong></p>
<ul>
<li>技术的迭代引发 borg 的换代需求。</li>
<li>早期的隔离依靠 chroot jail 实现，一些不合理的设计需要在新产品中改进。<ul>
<li>对象之间的强依赖 job 和 task 是强包含关系，不利于重组。</li>
<li>所有容器共享 IP，会导致端口冲突，隔离困难等问题。</li>
<li>为超级用户添加复杂逻辑导致系统过于复杂。</li>
</ul>
</li>
</ul>
<h3 id="Kubernetes-架构基础"><a href="#Kubernetes-架构基础" class="headerlink" title="Kubernetes 架构基础"></a>Kubernetes 架构基础</h3><h4 id="Google-Borg"><a href="#Google-Borg" class="headerlink" title="Google Borg"></a>Google Borg</h4><blockquote>
<p>建议对原论文</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/GoogleBorg.png" alt="GoogleBorg"></p>
<p>特性</p>
<ul>
<li>物理资源利用率高。</li>
<li>服务器共享，在进程级别做隔离。</li>
<li>应用高可用，故障恢复时间短。</li>
<li>调度策略灵活。</li>
<li>应用接入和使用方便，提供了完备的 Job 描述语言，服务发现，实时状态监控和诊断工具。</li>
</ul>
<p>优势</p>
<ul>
<li>对外隐藏底层资源管理和调度、故障处理等。</li>
<li>实现应用的高可靠和高可用。</li>
<li>足够弹性，支持应用跑在成千上万的机器上。</li>
</ul>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li><p>Workload</p>
<ul>
<li>prod：在线任务，长期运行、对延时敏感、面向终端用户等，比如 Gmail, Google Docs,Web Search 服务等。</li>
<li>non-prod ： 离线任务，也称为批处理任务（Batch），比如一些分布式计算服务等。</li>
</ul>
</li>
<li><p>Cell</p>
<blockquote>
<p>相当于一个集群</p>
</blockquote>
<ul>
<li>一个 Cell 上跑一个<strong>集群</strong>管理系统 Borg。</li>
<li>通过定义 Cell 可以让 Borg 对服务器资源进行统一抽象，作为用户就无需知道自己的应用跑在哪台机器上，也不用关心资源分配、程序安装、依赖管理、健康检查及故障恢复等。</li>
</ul>
</li>
<li><p>Job 和 Task</p>
<blockquote>
<p>相当于 k8s 中的 pod 和 container</p>
</blockquote>
<ul>
<li>用户以 Job 的形式提交应用部署请求。一个 Job 包含一个或多个相同的 Task，每个 Task 运行相同的应用程序，Task 数量就是应用的副本数。</li>
<li>每个 Job 可以定义属性、元信息和优先级，优先级涉及到抢占式调度过程。</li>
</ul>
</li>
<li><p>Naming</p>
<ul>
<li>Borg 的服务发现通过 BNS （ Borg NameService）来实现。</li>
<li>50.jfoo.ubar.cc.borg.google.com 可表示在一个名为 cc 的 Cell 中由用户 uBar 部署的一个名为 jFoo 的 Job下的第 50 个 Task。</li>
</ul>
</li>
</ul>
<h4 id="Borg-架构"><a href="#Borg-架构" class="headerlink" title="Borg 架构"></a>Borg 架构</h4><p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/Borg架构.png" alt="Borg架构"></p>
<h4 id="应用高可用"><a href="#应用高可用" class="headerlink" title="应用高可用"></a>应用高可用</h4><ul>
<li>被抢占的 non-prod 任务放回 pending queue，等待重新调度。</li>
<li>多副本应用跨故障域部署。所谓故障域有大有小，比如相同机器、相同机架或相同电源插座等，一挂全挂。</li>
<li>对于类似服务器或操作系统升级的维护操作，避免大量服务器同时进行。</li>
<li>支持幂等性，支持客户端重复操作。</li>
<li>当服务器状态变为不可用时，要控制重新调度任务的速率。因为 Borg 无法区分是节点故障还是出现了短暂的网络分区，如果是后者，静静地等待网络恢复更利于保障服务可用性。</li>
<li>当某种”任务 @ 服务器”的组合出现故障时，下次重新调度时需避免这种组合再次出现，因为极大可能会再次出现相同故障。</li>
<li>记录详细的内部信息，便于故障排查和分析。</li>
<li>保障应用高可用的关键性设计原则：无论何种原因，即使 Borgmaster 或者 Borglet 挂掉、失联，都不能杀掉正在运行的服务（Task）。</li>
</ul>
<h4 id="Borg-系统自身高可用"><a href="#Borg-系统自身高可用" class="headerlink" title="Borg 系统自身高可用"></a>Borg 系统自身高可用</h4><ul>
<li>Borgmaster 组件多副本设计。</li>
<li>采用一些简单的和底层（low-level）的工具来部署 Borg 系统实例，避免引入过多的外部依赖。</li>
<li>每个 Cell 的 Borg 均独立部署，避免不同 Borg 系统相互影响。</li>
</ul>
<h4 id="资源利用率"><a href="#资源利用率" class="headerlink" title="资源利用率"></a>资源利用率</h4><ul>
<li>通过将在线任务（prod）和离线任务（non-prod，Batch）混合部署，空闲时，离线任务可以充分利用计算资源；繁忙时，在线任务通过抢占的方式保证优先得到执行，合理地利用资源。</li>
<li>98% 的服务器实现了混部。</li>
<li>90% 的服务器中跑了超过25 个 Task 和 4500 个线程。</li>
<li>在一个中等规模的 Cell 里，在线任务和离线任务独立部署比混合部署所需的服务器数量多出约20%-30%。</li>
</ul>
<p>可以简单算一笔账，Google 的服务器数量在千万级别，按 20% 算也是百万级别，大概能省下的服务器采购费用就是百亿级别了，这还不包括省下的机房等基础设施和电费等费用。</p>
<h4 id="Brog-调度原理"><a href="#Brog-调度原理" class="headerlink" title="Brog 调度原理"></a>Brog 调度原理</h4><p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/Brog调度原理.png" alt="Brog调度原理"></p>
<h4 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h4><p>安全性隔离：</p>
<ul>
<li>早期采用 Chroot jail，后期版本基于 Namespace。</li>
</ul>
<p>性能隔离：</p>
<ul>
<li>采用基于 Cgroup 的容器技术实现。</li>
<li>在线任务（prod）是延时敏感（latency-sensitive）型的，优先级高，而离线任务（non-prod，Batch）优先级低。</li>
<li>Borg 通过不同优先级之间的抢占式调度来优先保障在线任务的性能，牺牲离线任务。</li>
<li>Borg 将资源类型分成两类：</li>
<li>可压榨的（compressible），CPU 是可压榨资源，资源耗尽不会终止进程；</li>
<li>不可压榨的（non-compressible），内存是不可压榨资源，资源耗尽进程会被终止。</li>
</ul>
<h4 id="什么是Kubernetes（K8s）"><a href="#什么是Kubernetes（K8s）" class="headerlink" title="什么是Kubernetes（K8s）"></a>什么是Kubernetes（K8s）</h4><p>Kubernetes 是谷歌开源的容器集群管理系统，是 Google 多年大规模容器管理技术 Borg 的开源版本，主要功能包括：</p>
<ul>
<li>基于容器的应用部署、维护和滚动升级；</li>
<li>负载均衡和服务发现；</li>
<li>跨机器和跨地区的集群调度；</li>
<li>自动伸缩；</li>
<li>无状态服务和有状态服务；</li>
<li>插件机制保证扩展性。</li>
</ul>
<h4 id="命令式（-Imperative）vs-声明式（-Declarative）"><a href="#命令式（-Imperative）vs-声明式（-Declarative）" class="headerlink" title="命令式（ Imperative）vs 声明式（ Declarative）"></a>命令式（ Imperative）vs 声明式（ Declarative）</h4><p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/命令式和声明式.png" alt="命令式和声明式"></p>
<h4 id="声明式（Declaritive）系统规范"><a href="#声明式（Declaritive）系统规范" class="headerlink" title="声明式（Declaritive）系统规范"></a>声明式（Declaritive）系统规范</h4><p>命令式：</p>
<ul>
<li>我要你做什么，怎么做，请严格按照我说的做。</li>
</ul>
<p>声明式：</p>
<ul>
<li>我需要你帮我做点事，但是我只告诉你我需要你做什么，不是你应该怎么做。</li>
<li>直接声明：我直接告诉你我需要什么。</li>
<li>间接声明：我不直接告诉你我的需求，我会把我的需求放在特定的地方，请在方便的时候拿出来处理。</li>
</ul>
<p>幂等性：</p>
<ul>
<li>状态固定，每次我要你做事，请给我返回相同结果。</li>
</ul>
<p>面向对象的：</p>
<ul>
<li>把一切抽象成对象。</li>
</ul>
<h4 id="Kubernetes：声明式系统"><a href="#Kubernetes：声明式系统" class="headerlink" title="Kubernetes：声明式系统"></a>Kubernetes：声明式系统</h4><p>Kubernetes 的所有管理能力构建在对象抽象的基础上，核心对象包括：</p>
<ul>
<li>Node：计算节点的抽象，用来描述计算节点的资源抽象、健康状态等。</li>
<li>Namespace：资源隔离的基本单位，可以简单理解为文件系统中的目录结构。</li>
<li>Pod：用来描述应用实例，包括镜像地址、资源需求等。Kubernetes 中最核心的对象，也是打通应用和基础架构的秘密武器。</li>
<li>Service：服务如何将应用发布成服务，本质上是负载均衡和域名服务的声明。</li>
</ul>
<h4 id="Kubernetes-架构"><a href="#Kubernetes-架构" class="headerlink" title="Kubernetes 架构"></a>Kubernetes 架构</h4><p>Kubernetes 采用与 Borg 类似的架构</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/k8s架构.png" alt="k8s架构"></p>
<p>主要组件</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/k8s主要组件.png" alt="k8s主要组件"></p>
<h4 id="Kubernetes-的主节点（Master-Node）"><a href="#Kubernetes-的主节点（Master-Node）" class="headerlink" title="Kubernetes 的主节点（Master Node）"></a>Kubernetes 的主节点（Master Node）</h4><ol>
<li><p>API 服务器（API Server）</p>
<blockquote>
<p>API Server 的主要作用是对请求做认证、鉴权以及准入（验证请求内容的合法性），无其他逻辑。</p>
</blockquote>
<p> 这是Kubernetes 控制面板中唯一带有用户可访问API 以及用户可交互的组件。API 服务器会暴露一个RESTful 的Kubernetes API 并使用JSON 格式的清单文件（manifest files）。</p>
</li>
<li><p>群的数据存储（Cluster Data Store）</p>
<p> Kubernetes 使用 “etcd” 。这是一个强大的、稳定的、高可用的键值存储， 被 Kubernetes 用于长久储存所有的API 对象。</p>
</li>
<li><p>控制管理器（Controller Manager）</p>
<p> 被称为 “kube-controller manager”，它运行着所有处理集群日常任务的控制器。包括了节点控制器、副本控制器、端点（endpoint）控制器以及服务账户等。</p>
</li>
<li><p>调度器（Scheduler）</p>
<p> 调度器会监控新建的 pods（一组或一个容器）并将其分配给节点。</p>
</li>
</ol>
<h4 id="Kubernetes-的工作节点（Worker-Node）"><a href="#Kubernetes-的工作节点（Worker-Node）" class="headerlink" title="Kubernetes 的工作节点（Worker Node）"></a>Kubernetes 的工作节点（Worker Node）</h4><ol>
<li><p>Kubelet</p>
<p> 负责调度到对应节点的 Pod 的生命周期管理，执行任务并将 Pod 状态报告给主节点的渠道，通过容器运行时（拉取镜像、启动和停止容器等）来运行这些容器。它还会定期执行被请求的容器的健康探测程序。</p>
</li>
<li><p>Kube-proxy</p>
<p> 它负责节点的网络，在主机上维护网络规则并执行连接转发。它还负责对正在服务的 pods 进行负载平衡。</p>
</li>
</ol>
<h4 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h4><p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/etcd.png" alt="etcd"></p>
<h4 id="直接访问-etcd-的数据"><a href="#直接访问-etcd-的数据" class="headerlink" title="直接访问 etcd 的数据"></a>直接访问 etcd 的数据</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 启动一个 minikube 集群</span>
<span class="token operator">&gt;</span> minikube start

<span class="token comment"># 获取 kube-system 中所有 pods</span>
<span class="token operator">&gt;</span> kubectl -n kube-system get pods
NAME                               READY   STATUS    RESTARTS       AGE
coredns-7db6d8ff4d-z2rlw           <span class="token number">1</span>/1     Running   <span class="token number">0</span>              4h10m
etcd-minikube                      <span class="token number">1</span>/1     Running   <span class="token number">0</span>              4h10m
kube-apiserver-minikube            <span class="token number">1</span>/1     Running   <span class="token number">0</span>              4h10m
kube-controller-manager-minikube   <span class="token number">1</span>/1     Running   <span class="token number">0</span>              4h10m
kube-proxy-m5fjm                   <span class="token number">1</span>/1     Running   <span class="token number">0</span>              4h10m
kube-scheduler-minikube            <span class="token number">1</span>/1     Running   <span class="token number">0</span>              4h10m
storage-provisioner                <span class="token number">1</span>/1     Running   <span class="token number">1</span> <span class="token punctuation">(</span>4h9m ago<span class="token punctuation">)</span>   4h10m

<span class="token comment"># 进入集群 etcd 所在的容器</span>
<span class="token operator">&gt;</span> kubectl -n kube-system <span class="token builtin class-name">exec</span> -it etcd-minikube /bin/sh

<span class="token comment"># 查看 etcd 中的数据</span>
<span class="token operator">&gt;</span> etcdctl <span class="token punctuation">\</span>
    --endpoints https://localhost:2379 <span class="token punctuation">\</span>
    --cacert<span class="token operator">=</span>/var/lib/minikube/certs/etcd/ca.crt <span class="token punctuation">\</span>
    --cert /var/lib/minikube/certs/etcd/server.crt <span class="token punctuation">\</span>
    --key /var/lib/minikube/certs/etcd/server.key <span class="token punctuation">\</span>
    get --prefix / --keys-only

<span class="token comment"># 监听 default 命名空间中名为 nginx-svc 的 service 的变化</span>
etcdctl <span class="token punctuation">\</span>
    --endpoints https://localhost:2379 <span class="token punctuation">\</span>
    --cacert<span class="token operator">=</span>/var/lib/minikube/certs/etcd/ca.crt <span class="token punctuation">\</span>
    --cert /var/lib/minikube/certs/etcd/server.crt <span class="token punctuation">\</span>
    --key /var/lib/minikube/certs/etcd/server.key <span class="token punctuation">\</span>
    <span class="token function">watch</span> --prefix /registry/services/specs/default/nginx-svc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="APIServer"><a href="#APIServer" class="headerlink" title="APIServer"></a>APIServer</h4><p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/APIServer.png" alt="APIServer"></p>
<h4 id="APIServer-展开"><a href="#APIServer-展开" class="headerlink" title="APIServer 展开"></a>APIServer 展开</h4><p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/APIServer展开.png" alt="APIServer展开"></p>
<h4 id="Controller-Manager"><a href="#Controller-Manager" class="headerlink" title="Controller Manager"></a>Controller Manager</h4><ul>
<li>Controller Manager 是集群的大脑，是确保整个集群动起来的关键；</li>
<li>作用是确保 Kubernetes 遵循声明式系统规范，确保系统的真实状态（Actual State）与用户定义的期望状态（Desired State）一致；</li>
<li>Controller Manager 是多个控制器的组合，每个 Controller 事实上都是一个 control loop，负责侦听其管控的对象，当对象发生变更时完成配置；</li>
<li>Controller 配置失败通常会触发自动重试，整个集群会在控制器不断重试的机制下确保最终一致性（ Eventual Consistency）。</li>
</ul>
<h4 id="控制器的工作流程"><a href="#控制器的工作流程" class="headerlink" title="控制器的工作流程"></a>控制器的工作流程</h4><p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/控制器的工作流程.png" alt="控制器的工作流程"></p>
<h4 id="Informer-的内部机制"><a href="#Informer-的内部机制" class="headerlink" title="Informer 的内部机制"></a>Informer 的内部机制</h4><p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/Informer的内部机制.png" alt="Informer的内部机制"></p>
<h4 id="控制器的协同工作原理"><a href="#控制器的协同工作原理" class="headerlink" title="控制器的协同工作原理"></a>控制器的协同工作原理</h4><p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/控制器的协同工作原理.png" alt="控制器的协同工作原理"></p>
<h4 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h4><p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/Scheduler.png" alt="Scheduler"></p>
<h4 id="Kubelet"><a href="#Kubelet" class="headerlink" title="Kubelet"></a>Kubelet</h4><p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/Kubelet.png" alt="Kubelet"></p>
<h4 id="Kube-Proxy"><a href="#Kube-Proxy" class="headerlink" title="Kube-Proxy"></a>Kube-Proxy</h4><p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/Kube-Proxy.png" alt="Kube-Proxy"></p>
<h4 id="推荐的-Add-ons"><a href="#推荐的-Add-ons" class="headerlink" title="推荐的 Add-ons"></a>推荐的 Add-ons</h4><ul>
<li>kube-dns：负责为整个集群提供 DNS 服务；</li>
<li>Ingress Controller：为服务提供外网入口；</li>
<li>MetricsServer：提供资源监控；</li>
<li>Dashboard：提供GUI；</li>
<li>Fluentd-Elasticsearch：提供集群日志采集、存储与查询。</li>
</ul>
<h3 id="了解-kubectl"><a href="#了解-kubectl" class="headerlink" title="了解 kubectl"></a>了解 kubectl</h3><h4 id="Kubectl-命令和-kubeconfig"><a href="#Kubectl-命令和-kubeconfig" class="headerlink" title="Kubectl 命令和 kubeconfig"></a>Kubectl 命令和 kubeconfig</h4><ul>
<li>kubectl 是一个 Kubernetes 的命令行工具，它允许 Kubernetes 用户以命令行的方式与 Kubernetes 交互，其默认读取配置文件 ~/.kube/config。</li>
<li>kubectl 会将接收到的用户请求转化为 rest 调用以 rest client 的形式与 apiserver 通讯。</li>
<li>apiserver 的地址，用户信息等配置在 kubeconfig。</li>
</ul>
<p>可以在命令后加 <code>-v 9</code> 来开启详细的日志，如 <code>kubectl get namespace default -v 9</code>。</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">clusters</span><span class="token punctuation">:</span>
<span class="token punctuation">-</span> <span class="token key atrule">cluster</span><span class="token punctuation">:</span>
    <span class="token key atrule">certificate-authority</span><span class="token punctuation">:</span> /home/k/.minikube/ca.crt
    <span class="token key atrule">extensions</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">extension</span><span class="token punctuation">:</span>
        <span class="token key atrule">last-update</span><span class="token punctuation">:</span> Thu<span class="token punctuation">,</span> 02 May 2024 21<span class="token punctuation">:</span>50<span class="token punctuation">:</span>24 CST
        <span class="token key atrule">provider</span><span class="token punctuation">:</span> minikube.sigs.k8s.io
        <span class="token key atrule">version</span><span class="token punctuation">:</span> v1.33.0
      <span class="token key atrule">name</span><span class="token punctuation">:</span> cluster_info
    <span class="token key atrule">server</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//127.0.0.1<span class="token punctuation">:</span><span class="token number">32774</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> minikube
<span class="token key atrule">contexts</span><span class="token punctuation">:</span>
<span class="token punctuation">-</span> <span class="token key atrule">context</span><span class="token punctuation">:</span>
    <span class="token key atrule">cluster</span><span class="token punctuation">:</span> minikube
    <span class="token key atrule">extensions</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">extension</span><span class="token punctuation">:</span>
        <span class="token key atrule">last-update</span><span class="token punctuation">:</span> Thu<span class="token punctuation">,</span> 02 May 2024 21<span class="token punctuation">:</span>50<span class="token punctuation">:</span>24 CST
        <span class="token key atrule">provider</span><span class="token punctuation">:</span> minikube.sigs.k8s.io
        <span class="token key atrule">version</span><span class="token punctuation">:</span> v1.33.0
      <span class="token key atrule">name</span><span class="token punctuation">:</span> context_info
    <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default
    <span class="token key atrule">user</span><span class="token punctuation">:</span> minikube
  <span class="token key atrule">name</span><span class="token punctuation">:</span> minikube
<span class="token key atrule">current-context</span><span class="token punctuation">:</span> minikube
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Config
<span class="token key atrule">preferences</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token key atrule">users</span><span class="token punctuation">:</span>
<span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> minikube
  <span class="token key atrule">user</span><span class="token punctuation">:</span>
    <span class="token key atrule">client-certificate</span><span class="token punctuation">:</span> /home/k/.minikube/profiles/minikube/client.crt
    <span class="token key atrule">client-key</span><span class="token punctuation">:</span> /home/k/.minikube/profiles/minikube/client.key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="kubectl-常用命令"><a href="#kubectl-常用命令" class="headerlink" title="kubectl 常用命令"></a>kubectl 常用命令</h4><p><strong>kubectl get po -oyaml -w</strong></p>
<ul>
<li>kubectl 可查看对象。</li>
<li>-oyaml 输出详细信息为 yaml 格式。</li>
<li>-w watch 该对象的后续变化。</li>
<li>-owide 以详细列表的格式查看对象。</li>
</ul>
<p><strong>kubectl describe 展示资源的详细信息和相关 Event。</strong></p>
<p><strong>kubectl exec 提供进入运行容器的通道，可以进入容器进行 debug 操作。</strong></p>
<p><strong>Kubectl logs 可查看 pod 的标准输入（stdout, stderr），与 tail 用法类似。</strong></p>
<h3 id="深入理解-Kubernetes"><a href="#深入理解-Kubernetes" class="headerlink" title="深入理解 Kubernetes"></a>深入理解 Kubernetes</h3><h4 id="云计算的传统分类"><a href="#云计算的传统分类" class="headerlink" title="云计算的传统分类"></a>云计算的传统分类</h4><p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/云计算的传统分类.png" alt="云计算的传统分类"></p>
<h4 id="Kubernetes-生态系统"><a href="#Kubernetes-生态系统" class="headerlink" title="Kubernetes 生态系统"></a>Kubernetes 生态系统</h4><p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/Kubernetes生态系统.png" alt="Kubernetes生态系统"></p>
<h4 id="Kubernetes-设计理念"><a href="#Kubernetes-设计理念" class="headerlink" title="Kubernetes 设计理念"></a>Kubernetes 设计理念</h4><p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/Kubernetes设计理念.png" alt="Kubernetes设计理念"></p>
<h4 id="Kubernetes-Master"><a href="#Kubernetes-Master" class="headerlink" title="Kubernetes Master"></a>Kubernetes Master</h4><p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/KubernetesMaster.png" alt="KubernetesMaster"></p>
<h4 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h4><ul>
<li>核心层：Kubernetes 最核心的功能，对外提供 API 构建高层的应用，对内提供插件式应用执行环境。</li>
<li>应用层：部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、DNS 解析等）。</li>
<li>管理层：系统度量（如基础设施、容器和网络的度量）、自动化（如自动扩展、动态 Provision 等）、策略管理（RBAC、Quota、PSP、NetworkPolicy 等）。</li>
<li>接口层：Kubectl 命令行工具、客户端 SDK 以及集群联邦。</li>
<li>生态系统：在接口层之上的庞大容器集群管理调度的生态系统，可以划分为两个范畴：<ul>
<li>Kubernetes 外部：日志、监控、配置管理、CI、CD、Workflow、FaaS、OTS 应用、ChatOps 等；</li>
<li>Kubernetes 内部：CRI、CNI、CVI、镜像仓库、Cloud Provider、集群自身的配置和管理等。</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/分层架构一.png" alt="分层架构一"></p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/分层架构二.png" alt="分层架构二"></p>
<h4 id="API-设计原则"><a href="#API-设计原则" class="headerlink" title="API 设计原则"></a>API 设计原则</h4><ul>
<li>所有 API 都应是声明式的<ul>
<li>相对于命令式操作，声明式操作对于重复操作的效果是稳定的，这对于容易出现数据丢失或重复的分布式环境来说是很重要的。</li>
<li>声明式操作更易被用户使用，可以使系统向用户隐藏实现的细节，同时也保留了系统未来持续优化的可能性。</li>
<li>此外，声明式的 API 还隐含了所有的 API 对象都是名词性质的，例如 Service、Volume 这些 API 都是名词，这些名词描述了用户所期望得到的一个目标对象。</li>
</ul>
</li>
<li>API 对象是彼此互补而且可组合的<ul>
<li>这实际上鼓励 API 对象尽量实现面向对象设计时的要求，即”高内聚，松耦合”，对业务相关的概念有一个合适的分解，提高分解出来的对象的可重用性。</li>
</ul>
</li>
<li>高层 API 以操作意图为基础设计<ul>
<li>如何能够设计好 API，跟如何能用面向对象的方法设计好应用系统有相通的地方，高层设计一定是从业务出发，而不是过早的从技术实现出发。</li>
<li>因此，针对 Kubernetes 的高层 API 设计，一定是以 Kubernetes 的业务为基础出发，也就是以系统调度管理容器的操作意图为基础设计。</li>
</ul>
</li>
<li>低层 API 根据高层 API 的控制需要设计<ul>
<li>设计实现低层 API 的目的，是为了被高层 API 使用，考虑减少冗余、提高重用性的目的，低层 API 的设计也要以需求为基础，要尽量抵抗受技术实现影响的诱惑。</li>
</ul>
</li>
<li>尽量避免简单封装，不要有在外部 API 无法显式知道的内部隐藏的机制<ul>
<li>简单的封装，实际没有提供新的功能，反而增加了对所封装 API 的依赖性。</li>
<li>例如 StatefulSet 和 ReplicaSet，本来就是两种 Pod 集合，那么 Kubernetes 就用不同 API 对象来定义它们，而不会说只用同一个 ReplicaSet，内部通过特殊的算法再来区分这个 ReplicaSet 是有状态的还是无状态。</li>
</ul>
</li>
<li>API 操作复杂度与对象数量成正比<ul>
<li>API 的操作复杂度不能超过 O(N)，否则系统就不具备水平伸缩性了。</li>
</ul>
</li>
<li>API 对象状态不能依赖于网络连接状态<ul>
<li>由于众所周知，在分布式环境下，网络连接断开是经常发生的事情，因此要保证 API 对象状态能应对网络的不稳定，API 对象的状态就不能依赖于网络连接状态。</li>
</ul>
</li>
<li>尽量避免让操作机制依赖于全局状态<ul>
<li>因为在分布式系统中要保证全局状态的同步是非常困难的。</li>
</ul>
</li>
</ul>
<h4 id="Kubernetes-如何通过对象的组合完成业务描述"><a href="#Kubernetes-如何通过对象的组合完成业务描述" class="headerlink" title="Kubernetes 如何通过对象的组合完成业务描述"></a>Kubernetes 如何通过对象的组合完成业务描述</h4><blockquote>
<p>引用依赖：一个对象中有个属性的名字指向了另一个对象。</p>
<p>基于命名规范：Deployment 根据 PodTemplate 的 hash 值来作为 Replicaset 名字的一部分，这个关系是写在代码中的。</p>
<p>基于标签：根据标签来筛选。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/Kubernetes如何通过对象的组合完成业务描述.png" alt="Kubernetes如何通过对象的组合完成业务描述"></p>
<h4 id="架构设计原则"><a href="#架构设计原则" class="headerlink" title="架构设计原则"></a>架构设计原则</h4><ul>
<li>只有 APIServer 可以直接访问 etcd 存储，其他服务必须通过 Kubernetes API 来访问集群状态；</li>
<li>单节点故障不应该影响集群的状态；</li>
<li>在没有新请求的情况下，所有组件应该在故障恢复后继续执行上次最后收到的请求（比如网络分区或服务重启等）；</li>
<li>所有组件都应该在内存中保持所需要的状态，APIServer 将状态写入 etcd 存储，而其他组件则通过 API Server 更新并监听所有的变化；</li>
<li>优先使用事件监听而不是轮询。</li>
</ul>
<h4 id="引导（Bootstrapping）原则"><a href="#引导（Bootstrapping）原则" class="headerlink" title="引导（Bootstrapping）原则"></a>引导（Bootstrapping）原则</h4><ul>
<li>Self-hosting 是目标。</li>
<li>减少依赖，特别是稳态运行的依赖。</li>
<li>通过分层的原则管理依赖。</li>
<li>循环依赖问题的原则：<ul>
<li>同时还接受其他方式的数据输入（比如本地文件等），这样在其他服务不可用时还可以手动配置引导服务；</li>
<li>状态应该是可恢复或可重新发现的；</li>
<li>支持简单的启动临时实例来创建稳态运行所需要的状态，使用分布式锁或文件锁等来协调不同状态的切换（通常称为 pivoting 技术）；</li>
<li>自动重启异常退出的服务，比如副本或者进程管理器等。</li>
</ul>
</li>
</ul>
<h4 id="核心技术概念和-API-对象"><a href="#核心技术概念和-API-对象" class="headerlink" title="核心技术概念和 API 对象"></a>核心技术概念和 API 对象</h4><p>API 对象是 Kubernetes 集群中的管理操作单元。</p>
<p>Kubernetes 集群系统每支持一项新功能，引入一项新技术，一定会新引入对应的API 对象，支持对该功能的管理操作。</p>
<p>每个 API 对象都有四大类属性：</p>
<ul>
<li>TypeMeta</li>
<li>MetaData</li>
<li>Spec</li>
<li>Status</li>
</ul>
<h4 id="TypeMeta"><a href="#TypeMeta" class="headerlink" title="TypeMeta"></a>TypeMeta</h4><p>Kubernetes对象的最基本定义，它通过引入 GKV（Group，Kind，Version）模型定义了一个对象的类型。</p>
<ol>
<li>Group<br> Kubernetes 定义了非常多的对象，如何将这些对象进行归类是一门学问，将对象依据其功能范围归入不同的分组，比如把支撑最基本功能的对象归入 core 组，把与应用部署有关的对象归入 apps 组，会使这些对象的可维护性和可理解性更高。</li>
<li>Kind<br> 定义一个对象的基本类型，比如 Node、Pod、Deployment 等。</li>
<li>Version<br> 社区每个季度会推出一个 Kubernetes 版本，随着 Kubernetes 版本的演进，对象从创建之初到能够完全生产化就绪的版本是不断变化的。与软件版本类似，通常社区提出一个模型定义以后，随着该对象不断成熟，其版本可能会从 v1alpha1 到 v1alpha2，或者到 v1beta1，最终变成生产就绪版本 v1。</li>
</ol>
<h4 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h4><p>Metadata 中有两个最重要的属性：Namespace 和 Name，分别定义了对象的 Namespace 归属及名字，这两个属性唯一定义了某个对象实例。</p>
<ol>
<li><p>Label</p>
<p> 顾名思义就是给对象打标签，一个对象可以有任意对标签，其存在形式是键值对。Label 定义了对象的可识别属性，Kubernetes API 支持以 Label 作为过滤条件查询对象。</p>
</li>
<li><p>Annotation</p>
<p> Annotation 与 Label 一样用键值对来定义，但 Annotation 是作为属性扩展，更多面向于系统管理员和开发人员，因此需要像其他属性一样做合理归类。</p>
</li>
<li><p>Finalizer</p>
<p> Finalizer 本质上是一个资源锁，Kubernetes 在接收某对象的删除请求时，会检查 Finalizer 是否为空，如果不为空则只对其做逻辑删除，即只会更新对象中的 metadata.deletionTimestamp 字段。</p>
<p> 主要用于避免某个资源控制器意外终止，而无法监听到对应资源删除事件的情况。一旦某个资源设置了 Finalizer，那么这个资源删除时将不会消除，需要删除资源上的 Finalizer 后这个资源才会真正的删除，这就给了对应资源控制器处理的机会。</p>
</li>
<li><p>ResourceVersion</p>
<p> ResourceVersion 可以被看作一种乐观锁，每个对象在任意时刻都有其 ResourceVersion，当 Kubernetes 对象被客户端读取以后，ResourceVersion 信息也被一并读取。此机制确保了分布式系统中任意多线程能够无锁并发访问对象，极大提升了系统的整体效率。</p>
</li>
</ol>
<h5 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h5><ul>
<li>Label 是识别 Kubernetes 对象的标签，以 key/value 的方式附加到对象上。</li>
<li>key 最长不能超过 63 字节，value 可以为空，也可以是不超过 253 字节的字符串。</li>
<li>Label 不提供唯一性，并且实际上经常是很多对象（如 Pods）都使用相同的 label 来标志具体的应用。</li>
<li>Label 定义好后其他对象可以使用 Label Selector 来选择一组相同 label 的对象</li>
<li>Label Selector 支持以下几种方式：<ul>
<li>等式，如 app=nginx 和 env!=production；</li>
<li>集合，如 env in (production, qa)；</li>
<li>多个 label（它们之间是 AND 关系），如 app=nginx,env=test。</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/Label.png" alt="Label"></p>
<blockquote>
<p>图片来源：<a target="_blank" rel="noopener" href="https://draveness.me/kubernetes-object-intro/">https://draveness.me/kubernetes-object-intro/</a></p>
</blockquote>
<h5 id="Annotations"><a href="#Annotations" class="headerlink" title="Annotations"></a>Annotations</h5><ul>
<li>Annotations 是 key/value 形式附加于对象的注解。</li>
<li>不同于 Labels 用于标志和选择对象，Annotations 则是用来记录一些附加信息，用来辅助应用部署、安全策略以及调度策略等。</li>
<li>比如 deployment 使用 annotations 来记录 rolling update 的状态。</li>
</ul>
<h5 id="Spec-和-Status"><a href="#Spec-和-Status" class="headerlink" title="Spec 和 Status"></a>Spec 和 Status</h5><ul>
<li>Spec 和 Status 才是对象的核心。</li>
<li>Spec 是用户的期望状态，由创建对象的用户端来定义。</li>
<li>Status 是对象的实际状态，由对应的控制器收集实际状态并更新。</li>
<li>与 TypeMeta 和 Metadata 等通用属性不同，Spec 和 Status 是每个对象独有的。</li>
</ul>
<h4 id="常用Kubernetes-对象及其分组"><a href="#常用Kubernetes-对象及其分组" class="headerlink" title="常用Kubernetes 对象及其分组"></a>常用Kubernetes 对象及其分组</h4><p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/常用Kubernetes对象及其分组.png" alt="常用Kubernetes对象及其分组.png"></p>
<h3 id="核心对象概览"><a href="#核心对象概览" class="headerlink" title="核心对象概览"></a>核心对象概览</h3><h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><ul>
<li>Node 是 Pod 真正运行的主机，可以物理机，也可以是虚拟机。</li>
<li>为了管理 Pod，每个 Node 节点上至少要运行 container runtime（比如Docker 或者Rkt）、Kubelet 和 Kube-proxy 服务。</li>
</ul>
<h4 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h4><p>Namespace 是对一组资源和对象的抽象集合，比如可以用来将系统内部的对象划分为不同的项目组或用户组。</p>
<p>常见的 pods, services, replication controllers 和 deployments 等都是属于某一个 Namespace 的（默认是 default），而 Node, persistentVolumes 等则不属于任何 Namespace。</p>
<h4 id="什么是-Pod"><a href="#什么是-Pod" class="headerlink" title="什么是 Pod"></a>什么是 Pod</h4><ul>
<li>Pod 是一组紧密关联的容器集合，它们共享 PID、IPC、Network 和 UTS namespace，是 Kubernetes 调度的基本单位。</li>
<li>Pod 的设计理念是支持多个容器在一个 Pod 中共享网络和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。</li>
<li>同一个 Pod 中的不同容器可共享资源：<ul>
<li>共享网络 Namespace；</li>
<li>可通过挂载存储卷共享存储；</li>
<li>共享 Security Context。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> hello
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span><span class="token number">1.15</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="如何通过Pod-对象定义支撑应用运行"><a href="#如何通过Pod-对象定义支撑应用运行" class="headerlink" title="如何通过Pod 对象定义支撑应用运行"></a>如何通过Pod 对象定义支撑应用运行</h4><p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/如何通过Pod对象定义支撑应用运行.png" alt="如何通过Pod对象定义支撑应用运行"></p>
<h4 id="存储卷"><a href="#存储卷" class="headerlink" title="存储卷"></a>存储卷</h4><ul>
<li>通过存储卷可以将外挂存储挂载到 Pod 内部使用。</li>
<li>存储卷定义包括两个部分: Volume 和 VolumeMounts。<ul>
<li>Volume：定义 Pod 可以使用的存储卷来源；</li>
<li>VolumeMounts：定义存储卷如何 Mount 到容器内部。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> hello<span class="token punctuation">-</span>volume
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span><span class="token number">1.15</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx
  <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> data
    <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /data
  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> data
    <span class="token key atrule">emptyDir</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="Pod-网络"><a href="#Pod-网络" class="headerlink" title="Pod 网络"></a>Pod 网络</h4><p>Pod 的多个容器是共享网络 Namespace 的，这意味着：</p>
<ul>
<li>同一个 Pod 中的不同容器可以彼此通过 Loopback 地址访问：<ul>
<li>在第一个容器中起了一个服务 <a target="_blank" rel="noopener" href="http://127.0.0.1">http://127.0.0.1</a> 。</li>
<li>在第二个容器内，是可以通过 httpGet <a target="_blank" rel="noopener" href="http://172.0.0.1">http://172.0.0.1</a> 访问到该地址的。</li>
</ul>
</li>
<li>这种方法常用于不同容器的互相协作。</li>
</ul>
<h4 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h4><p>Kubernetes 通过 Cgroups 提供容器资源管理的功能，可以限制每个容器的 CPU 和内存使用，比如对于刚才创建的 deployment，可以通过下面的命令限制 nginx 容器最多只用 50% 的CPU 和 128MB 的内存：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&gt;</span> kubectl <span class="token builtin class-name">set</span> resources deployment nginx-app -c<span class="token operator">=</span>nginx --limits<span class="token operator">=</span>cpu<span class="token operator">=</span>500m,memory<span class="token operator">=</span>128Mi
deployment <span class="token string">"nginx"</span> resource requirements updated<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>等同于在每个 Pod 中设置 resources limits</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">labels</span><span class="token punctuation">:</span>
    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx
  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx
    <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx
    <span class="token key atrule">resources</span><span class="token punctuation">:</span>
      <span class="token key atrule">limits</span><span class="token punctuation">:</span>
        <span class="token key atrule">cpu</span><span class="token punctuation">:</span> <span class="token string">"500m"</span>
        <span class="token key atrule">memory</span><span class="token punctuation">:</span> <span class="token string">"128Mi"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h4><p>Kubernetes 作为一个面向应用的集群管理工具，需要确保容器在部署后确实处在正常的运行状态。</p>
<ol>
<li>探针类型：</li>
</ol>
<ul>
<li>LivenessProbe<ul>
<li>探测应用是否处于健康状态，如果不健康则删除并重新创建容器。</li>
</ul>
</li>
<li>ReadinessProbe<ul>
<li>探测应用是否就绪并且处于正常服务状态，如果不正常则不会接收来自 Kubernetes Service 的流量。</li>
</ul>
</li>
<li>StartupProbe<ul>
<li>探测应用是否启动完成，如果在 <code>failureThreshold * periodSeconds</code> 周期内未就绪，则会应用进程会被重启。</li>
</ul>
</li>
</ul>
<ol>
<li>探活方式：</li>
</ol>
<ul>
<li>Exec</li>
<li>TCP socket</li>
<li>HTTP</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/健康检查spec.png" alt="健康检查spec"></p>
<h4 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h4><ul>
<li>ConfigMap 用来将非机密性的数据保存到键值对中。</li>
<li>使用时， Pods 可以将其用作环境变量、命令行参数或者存储卷中的配置文件。</li>
<li>ConfigMap 将环境配置信息和容器镜像解耦，便于应用配置的修改。</li>
</ul>
<h4 id="密钥对象（Secret）"><a href="#密钥对象（Secret）" class="headerlink" title="密钥对象（Secret）"></a>密钥对象（Secret）</h4><ul>
<li>Secret 是用来保存和传递密码、密钥、认证凭证这些敏感信息的对象。</li>
<li>使用 Secret 的好处是可以避免把敏感信息明文写在配置文件里。</li>
<li>Kubernetes 集群中配置和使用服务不可避免的要用到各种敏感信息实现登录、认证等功能，例\如访问 AWS 存储的用户名密码。</li>
<li>为了避免将类似的敏感信息明文写在所有需要使用的配置文件中，可以将这些信息存入一个 Secret 对象，而在配置文件中通过 Secret 对象引用这些敏感信息。</li>
<li>这种方式的好处包括：意图明确，避免重复，减少暴漏机会。</li>
</ul>
<h4 id="用户（User-Account）-amp-服务帐户（Service-Account）"><a href="#用户（User-Account）-amp-服务帐户（Service-Account）" class="headerlink" title="用户（User Account）&amp; 服务帐户（Service Account）"></a>用户（User Account）&amp; 服务帐户（Service Account）</h4><ul>
<li>顾名思义，用户帐户为人提供账户标识，而服务账户为计算机进程和 Kubernetes 集群中运行的 Pod 提供账户标识。</li>
<li>用户帐户和服务帐户的一个区别是作用范围：<ul>
<li>用户帐户对应的是人的身份，人的身份与服务的 Namespace 无关，所以用户账户是跨 Namespace 的；</li>
<li>而服务帐户对应的是一个运行中程序的身份，与特定 Namespace 是相关的。</li>
</ul>
</li>
</ul>
<h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p>Service 是应用服务的抽象，通过 labels 为应用提供负载均衡和服务发现。匹配 labels 的 Pod IP 和端口列表组成 <code>endpoints</code>，由 Kube-proxy 负责将服务 IP 负载均衡到这些 endpoints 上。</p>
<p>每个 Service 都会自动分配一个 cluster IP（仅在集群内部可访问的虚拟地址）和 DNS 名，其他容器可以通过该地址或 DNS 来访问服务，而不需要了解后端容器的运行。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/Service.png" alt="Service"></p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">ports</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8078</span> <span class="token comment"># the port that this service should serve on</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> http
    <span class="token comment"># the container on each pod to connect to, can be a name</span>
    <span class="token comment"># (e.g. 'www') or a number (e.g. 80)</span>
    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">80</span>
    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP
  <span class="token key atrule">selector</span><span class="token punctuation">:</span>
    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="副本集（Replica-Set）"><a href="#副本集（Replica-Set）" class="headerlink" title="副本集（Replica Set）"></a>副本集（Replica Set）</h4><ul>
<li>Pod 只是单个应用实例的抽象，要构建高可用应用，通常需要构建多个同样的副本，提供同一个服务。</li>
<li>Kubernetes 为此抽象出副本集 ReplicaSet，其允许用户定义 Pod 的副本数，每一个 Pod 都会被当作一个无状态的成员进行管理，Kubernetes 保证总是有用户期望的数量的 Pod 正常运行。</li>
<li>当某个副本宕机以后，控制器将会创建一个新的副本。</li>
<li>当因业务负载发生变更而需要调整扩缩容时，可以方便地调整副本数量。</li>
</ul>
<p>RS 创建出来的名字分为三个部分，如：<code>nginx-deploy-59dc7f9d89-k9rj9</code></p>
<ol>
<li>第一个部分 <code>nginx-deploy</code> 是 deployment 的名字。</li>
<li>第二个部分 <code>59dc7f9d89</code> 是配置字符串的 hash 值。</li>
<li>第三个部分 <code>k9rj9</code> 是随机值，因为是无状态的，所以给任何值都是可以的。</li>
</ol>
<h4 id="部署（Deployment）"><a href="#部署（Deployment）" class="headerlink" title="部署（Deployment）"></a>部署（Deployment）</h4><ul>
<li>部署表示用户对 Kubernetes 集群的一次更新操作。</li>
<li>部署是一个比 RS 应用模式更广的 API 对象，可以是创建一个新的服务，更新一个新的服务，也可以是滚动升级一个服务。</li>
<li>滚动升级一个服务，实际是创建一个新的 RS，然后逐渐将新 RS 中副本数增加到理想状态，将旧 RS 中的副本数减小到 0 的复合操作。</li>
<li>这样一个复合操作用一个 RS 是不太好描述的，所以用一个更通用的 Deployment 来描述。</li>
<li>以 Kubernetes 的发展方向，未来对所有长期伺服型的的业务的管理，都会通过 Deployment 来管理。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/Deployment.png" alt="Deployment"></p>
<h4 id="有状态服务集（StatefulSet）"><a href="#有状态服务集（StatefulSet）" class="headerlink" title="有状态服务集（StatefulSet）"></a>有状态服务集（StatefulSet）</h4><ul>
<li>对于 StatefulSet 中的 Pod，每个 Pod 挂载自己独立的存储，如果一个 Pod 出现故障，从其他节点启动一个同样名字的 Pod，要挂载上原来 Pod 的存储继续以它的状态提供服务。</li>
<li>适合于 StatefulSet 的业务包括数据库服务 MySQL 和 PostgreSQL，集群化管理服务 ZooKeeper、etcd 等有状态服务。</li>
<li>使用 StatefulSet，Pod 仍然可以通过漂移到不同节点提供高可用，而存储也可以通过外挂的存储来提供高可靠性，StatefulSet 做的只是将确定的 Pod 与确定的存储关联起来保证状态的连续性。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/StatefulSet.png" alt="StatefulSet"></p>
<h4 id="Statefulset-与Deployment-的差异"><a href="#Statefulset-与Deployment-的差异" class="headerlink" title="Statefulset 与Deployment 的差异"></a>Statefulset 与Deployment 的差异</h4><ul>
<li>身份标识<ul>
<li>StatefulSet Controller 为每个 Pod 编号，序号从 0 开始。</li>
</ul>
</li>
<li>数据存储<ul>
<li>StatefulSet 允许用户定义volumeClaimTemplates，Pod 被创建的同时，Kubernetes 会以 volumeClaimTemplates 中定义的模板创建存储卷，并挂载给Pod。</li>
</ul>
</li>
<li>StatefulSet 的升级策略不同<ul>
<li>onDelete</li>
<li>滚动升级</li>
<li>分片升级</li>
</ul>
</li>
</ul>
<h4 id="任务（Job）"><a href="#任务（Job）" class="headerlink" title="任务（Job）"></a>任务（Job）</h4><ul>
<li>Job 是 Kubernetes 用来控制批处理型任务的 API 对象。</li>
<li>Job 管理的 Pod 根据用户的设置把任务成功完成后就自动退出。</li>
<li>成功完成的标志根据不同的 spec.completions 策略而不同：<ul>
<li>单 Pod 型任务有一个 Pod 成功就标志完成；</li>
<li>定数成功型任务保证有 N 个任务全部成功；</li>
<li>工作队列型任务根据应用确认的全局成功而标志成功。</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/Job.png" alt="Job"></p>
<h4 id="后台支撑服务集（DaemonSet）"><a href="#后台支撑服务集（DaemonSet）" class="headerlink" title="后台支撑服务集（DaemonSet）"></a>后台支撑服务集（DaemonSet）</h4><ul>
<li>长期伺服型和批处理型服务的核心在业务应用，可能有些节点运行多个同类业务的 Pod，有些节点上又没有这类 Pod 运行；</li>
<li>而后台支撑型服务的核心关注点在 Kubernetes 集群中的节点（物理机或虚拟机），要保证每个节点上都有一个此类 Pod 运行。</li>
<li>节点可能是所有集群节点也可能是通过 nodeSelector 选定的一些特定节点。</li>
<li>典型的后台支撑型服务包括存储、日志和监控等在每个节点上支撑 Kubernetes 集群运行的服务。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《云原生训练营》学习笔记/DaemonSet.png" alt="DaemonSet"></p>
<h4 id="存储-PV-和-PVC"><a href="#存储-PV-和-PVC" class="headerlink" title="存储 PV 和 PVC"></a>存储 PV 和 PVC</h4><ul>
<li>PersistentVolume（PV）是集群中的一块存储卷，可以由管理员手动设置，或当用户创建 PersistentVolumeClaim（PVC）时根据 StorageClass 动态设置。</li>
<li>PV 和 PVC 与 Pod 生命周期无关。也就是说，当 Pod 中的容器重新启动、Pod 重新调度或者删除时，PV 和 PVC 不会受到影响，Pod 存储于 PV 里的数据得以保留。</li>
<li>对于不同的使用场景，用户通常需要不同属性（例如性能、访问模式等）的 PV。</li>
</ul>
<h4 id="CustomResourceDefinition"><a href="#CustomResourceDefinition" class="headerlink" title="CustomResourceDefinition"></a>CustomResourceDefinition</h4><ul>
<li>CRD 就像数据库的开放式表结构，允许用户自定义 Schema。</li>
<li>有了这种开放式设计，用户可以基于 CRD 定义一切需要的模型，满足不同业务的需求。</li>
<li>社区鼓励基于 CRD 的业务抽象，众多主流的扩展应用都是基于 CRD 构建的，比如 Istio、Knative。</li>
<li>甚至基于 CRD 推出了 Operator Mode 和 Operator SDK，可以以极低的开发成本定义新对象，并构建新对象的控制器。</li>
</ul>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://kibazen.cn" rel="external nofollow noreferrer">Kiba Amor</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                    </span>
                <span class="reprint-info">
                    <a href="https://kibazen.cn/yun-yuan-sheng-xun-lian-ying-xue-xi-bi-ji/">https://kibazen.cn/yun-yuan-sheng-xun-lian-ying-xue-xi-bi-ji/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY-NC-ND 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://kibazen.cn" target="_blank">Kiba Amor</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                                    <span class="chip bg-color">极客时间</span>
                                </a>
                            
                                <a href="/tags/kubernetes/">
                                    <span class="chip bg-color">kubernetes</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/share/css/share.min.css">
<div id="article-share">

    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/yun-yuan-sheng-xun-lian-ying-xue-xi-bi-ji/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/7.jpg" class="responsive-img" alt="《云原生训练营》学习笔记">
                        
                        <span class="card-title">《云原生训练营》学习笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-03-16
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                    学习笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                        <span class="chip bg-color">极客时间</span>
                    </a>
                    
                    <a href="/tags/kubernetes/">
                        <span class="chip bg-color">kubernetes</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/ling-yu-qu-dong-she-ji-xiang-guan-de-ruan-jian-jia-gou/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/21.jpg" class="responsive-img" alt="领域驱动设计相关的软件架构">
                        
                        <span class="card-title">领域驱动设计相关的软件架构</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-11-01
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" class="post-category">
                                    软件工程
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/">
                        <span class="chip bg-color">领域驱动设计</span>
                    </a>
                    
                    <a href="/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/">
                        <span class="chip bg-color">软件架构</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('2'),
            headingSelector: 'h2, h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2024</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">Kiba Amor</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/kibaamor" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:5093911+kibaamor@users.noreply.github.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>













    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

    
    

    

    

	
    

    

    

    
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
