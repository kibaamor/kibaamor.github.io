<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <meta name="keywords" content="《现代C++实战30讲》学习笔记, kiba, zen, amor, kibazen, kibaamor, 木叶, 木叶禅">
    <meta name="description" content="一个普通游戏程序员的博客">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>《现代C++实战30讲》学习笔记 | 木叶禅</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/css/my.css">

    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="木叶禅" type="application/atom+xml">
</head>



   <style>
    body{
       background-image: url(/medias/background.jpg);
       background-repeat:no-repeat;
       background-size:cover;
       background-attachment:fixed;
    }
</style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">木叶禅</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/leetcode/" class="waves-effect waves-light">
      
      <i class="fas fa-code" style="zoom: 0.6;"></i>
      
      <span>LeetCode</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/learn/" class="waves-effect waves-light">
      
      <i class="fas fa-book" style="zoom: 0.6;"></i>
      
      <span>学习</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tool/" class="waves-effect waves-light">
      
      <i class="fas fa-toolbox" style="zoom: 0.6;"></i>
      
      <span>工具</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories/" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags/" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about/" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">木叶禅</div>
        <div class="logo-desc">
            
            一个普通游戏程序员的博客
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/leetcode/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-code"></i>
			
			LeetCode
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/learn/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-book"></i>
			
			学习
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tool/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-toolbox"></i>
			
			工具
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    
<script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = 'f65e070788a2647953051a7a1b70ada7fd2b3f70cd4d93c977207f5b762987d4';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/4.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">《现代C++实战30讲》学习笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/CPP/">
                                <span class="chip bg-color">CPP</span>
                            </a>
                        
                            <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                                <span class="chip bg-color">极客时间</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                学习笔记
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-01-26
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2022-01-27
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    3.8k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    16 分
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>C++11 之后，C++ 以每三年一版的频度发布着新的语言标准，每一版都在基本保留向后兼容性的同时，提供着改进和新功能。<strong>本专栏主要就是讲这些新特性以及相关的编程实践</strong>。</p>
<p>作为专栏而非具体的工具参考书，我会重点讲是什么和为什么，而不是语法细节。</p>
<h2 id="01丨基础篇"><a href="#01丨基础篇" class="headerlink" title="01丨基础篇"></a>01丨基础篇</h2><h3 id="01-堆、栈、RAII：C-里该如何管理资源？"><a href="#01-堆、栈、RAII：C-里该如何管理资源？" class="headerlink" title="01 | 堆、栈、RAII：C++里该如何管理资源？"></a>01 | 堆、栈、RAII：C++里该如何管理资源？</h3><h4 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h4><p><strong>堆</strong>，英文是 heap，在内存管理的语境下，指的是动态分配内存的区域。</p>
<p>C++ 标准里一个相关概念是自由存储区，英文是 free store，特指使用 new 和 delete 来分配和释放内存的区域。一般而言，这是堆的一个子集：</p>
<ul>
<li>new 和 delete 操作的区域是 free store</li>
<li>malloc 和 free 操作的区域是 heap</li>
</ul>
<p>但 new 和 delete 通常底层使用 malloc 和 free 来实现，所以 free store 也是 heap。鉴于对其区分的实际意义并不大，在本专栏里，除非另有特殊说明，我会只使用堆这一术语。</p>
<p><strong>栈</strong>，英文是 stack，在内存管理的语境下，指的是函数调用过程中产生的本地变量和调用数据的区域。这个栈和数据结构里的栈高度相似，都满足“后进先出”（last-in-first-out 或 LIFO）。</p>
<p><strong>RAII</strong>，完整的英文是 Resource Acquisition Is Initialization，是 C++ 所特有的资源管理方式。有少量其他语言，如 D、Ada 和 Rust 也采纳了 RAII，但主流的编程语言中， C++ 是唯一一个依赖 RAII 来做资源管理的。</p>
<h4 id="1-2-堆"><a href="#1-2-堆" class="headerlink" title="1.2 堆"></a>1.2 堆</h4><h4 id="1-3-栈"><a href="#1-3-栈" class="headerlink" title="1.3 栈"></a>1.3 栈</h4><p>编译器会自动调用析构函数，包括在函数执行发生异常的情况。在发生异常时对析构函数的调用，还有一个专门的术语，叫栈展开（stack unwinding）。</p>
<h4 id="1-4-RAII"><a href="#1-4-RAII" class="headerlink" title="1.4 RAII"></a>1.4 RAII</h4><h4 id="1-5-参考资料"><a href="#1-5-参考资料" class="headerlink" title="1.5 参考资料"></a>1.5 参考资料</h4><ol>
<li>Wikipedia, “Memory management”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Memory_management">https://en.wikipedia.org/wiki/Memory_management</a></li>
<li>Wikipedia, “Stack-based memory allocation”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Stack-based_memory_allocation">https://en.wikipedia.org/wiki/Stack-based_memory_allocation</a></li>
<li>Wikipedia, “Resource acquisition is initialization”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/RAII">https://en.wikipedia.org/wiki/RAII</a></li>
<li>Wikipedia, “Call stack”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Call_stack">https://en.wikipedia.org/wiki/Call_stack</a></li>
<li>Wikipedia, “Object slicing”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Object_slicing">https://en.wikipedia.org/wiki/Object_slicing</a></li>
<li>Stack Overflow, “Why does the stack address grow towards decreasing memory addresses?” <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/4560720/why-doesthe-stack-address-grow-towards-decreasing-memory-addresses">https://stackoverflow.com/questions/4560720/why-doesthe-stack-address-grow-towards-decreasing-memory-addresses</a></li>
</ol>
<h3 id="02-自己动手，实现C-的智能指针"><a href="#02-自己动手，实现C-的智能指针" class="headerlink" title="02 | 自己动手，实现C++的智能指针"></a>02 | 自己动手，实现C++的智能指针</h3><h4 id="2-1-回顾"><a href="#2-1-回顾" class="headerlink" title="2.1 回顾"></a>2.1 回顾</h4><p>上一讲给出了下面这个类：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">shape_wrapper</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">explicit</span> <span class="token function">shape_wrapper</span><span class="token punctuation">(</span>shape<span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
        <span class="token operator">:</span> <span class="token function">ptr_</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">shape_wrapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">delete</span> ptr_<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    shape<span class="token operator">*</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> ptr_<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    shape<span class="token operator">*</span> ptr_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个类可以完成智能指针的最基本的功能：对超出作用域的对象进行释放。但它缺了点东西：</p>
<ol>
<li>这个类只适用于 shape 类</li>
<li>该类对象的行为不够像指针</li>
<li>拷贝该类对象会引发程序行为异常</li>
</ol>
<p>下面我们来逐一看一下怎么弥补这些问题。</p>
<h4 id="2-2-模板化和易用性"><a href="#2-2-模板化和易用性" class="headerlink" title="2.2 模板化和易用性"></a>2.2 模板化和易用性</h4><p>要让这个类能够包装任意类型的指针，我们需要把它变成一个类模板。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">smart_ptr</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">explicit</span> <span class="token function">smart_ptr</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
        <span class="token operator">:</span> <span class="token function">ptr_</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">smart_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">delete</span> ptr_<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    T<span class="token operator">*</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> ptr_<span class="token punctuation">;</span> <span class="token punctuation">}</span>

    T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span>ptr_<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    T<span class="token operator">*</span> <span class="token keyword">operator</span><span class="token operator">-&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> ptr_<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">operator</span> <span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> ptr_<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    T<span class="token operator">*</span> ptr_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="2-3-拷贝构造和赋值"><a href="#2-3-拷贝构造和赋值" class="headerlink" title="2.3 拷贝构造和赋值"></a>2.3 拷贝构造和赋值</h4><p>试试在拷贝时转移指针的所有权？大致实现如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">smart_ptr</span> <span class="token punctuation">{</span>
    <span class="token comment">//…</span>
    <span class="token function">smart_ptr</span><span class="token punctuation">(</span>smart_ptr<span class="token operator">&amp;</span> other<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        ptr_ <span class="token operator">=</span> other<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    smart_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>smart_ptr<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">smart_ptr</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//…</span>
    T<span class="token operator">*</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        T<span class="token operator">*</span> ptr <span class="token operator">=</span> ptr_<span class="token punctuation">;</span>
        ptr_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> ptr<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>smart_ptr<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">using</span> std<span class="token operator">::</span>swap<span class="token punctuation">;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>ptr_<span class="token punctuation">,</span> rhs<span class="token punctuation">.</span>ptr_<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//…</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在拷贝构造函数中，通过调用 other 的 release 方法来释放它对指针的所有权。在赋值函数中，则通过拷贝构造产生一个临时对象并调用 swap 来交换对指针的所有权。实现上是不复杂的。</p>
<p>如果你学到的赋值函数还有一个类似于 if (this != &amp;rhs) 的判断的话，那种用法更啰嗦，而且异常安全性不够好——如果在赋值过程中发生异常的话，this 对象的内容可能已经被部分破坏了，对象不再处于一个完整的状态。</p>
<p>目前这种惯用法（见参考资料 [1]）则保证了强异常安全性：赋值分为拷贝构造和交换两步，异常只可能在第一步发生；而第一步如果发生异常的话，this 对象完全不受任何影响。无论拷贝构造成功与否，结果只有赋值成功和赋值没有效果两种状态，而不会发生因为赋值破坏了当前对象这种场景。</p>
<p>上面实现的最大问题是，它的行为会让程序员非常容易犯错。一不小心把它传递给另外一个 smart_ptr，你就不再拥有这个对象了……</p>
<h4 id="2-4-“移动”指针？"><a href="#2-4-“移动”指针？" class="headerlink" title="2.4 “移动”指针？"></a>2.4 “移动”指针？</h4><p>在下一讲我们将完整介绍一下移动语义。这一讲，我们先简单看一下 smart_ptr 可以如何使用“移动”来改善其行为。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">smart_ptr</span> <span class="token punctuation">{</span>
    <span class="token comment">//…</span>
    <span class="token function">smart_ptr</span><span class="token punctuation">(</span>smart_ptr<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        ptr_ <span class="token operator">=</span> other<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    smart_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>smart_ptr rhs<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        rhs<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//…</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>改了两个地方：</p>
<ul>
<li>把拷贝构造函数中的参数类型 smart_ptr&amp; 改成了 smart_ptr&amp;&amp;；现在它成了移动构造函数。</li>
<li>把赋值函数中的参数类型 smart_ptr&amp; 改成了 smart_ptr，在构造参数时直接生成新的智能指针，从而不再需要在函数体中构造临时对象。现在赋值函数的行为是移动还是拷贝，完全依赖于构造参数时走的是移动构造还是拷贝构造。</li>
</ul>
<p>根据 C++ 的规则，如果我提供了移动构造函数而没有手动提供拷贝构造函数，那后者自动被禁用（记住，C++ 里那些复杂的规则也是为方便编程而设立的）。于是，我们自然地得到了以下结果：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">smart_ptr<span class="token operator">&lt;</span>shape<span class="token operator">&gt;</span> ptr1<span class="token punctuation">{</span><span class="token function">create_shape</span><span class="token punctuation">(</span>shape_type<span class="token operator">::</span>circle<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
smart_ptr<span class="token operator">&lt;</span>shape<span class="token operator">&gt;</span> ptr2<span class="token punctuation">{</span>ptr1<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 编译出错</span>
smart_ptr<span class="token operator">&lt;</span>shape<span class="token operator">&gt;</span> ptr3<span class="token punctuation">;</span>
ptr3 <span class="token operator">=</span> ptr1<span class="token punctuation">;</span> <span class="token comment">// 编译出错</span>
ptr3 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK，可以</span>
smart_ptr<span class="token operator">&lt;</span>shape<span class="token operator">&gt;</span> ptr4<span class="token punctuation">{</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr3<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// OK，可以</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这也是 C++11 的 unique_ptr 的基本行为。</p>
<h4 id="2-5-子类指针向基类指针的转换"><a href="#2-5-子类指针向基类指针的转换" class="headerlink" title="2.5 子类指针向基类指针的转换"></a>2.5 子类指针向基类指针的转换</h4><p>不知道你注意到没有，一个 <code>circle*</code> 是可以隐式转换成 <code>shape*</code> 的，但上面的 <code>smart_ptr&lt;circle&gt;</code> 却无法自动转换成 <code>smart_ptr&lt;shape&gt;</code>。</p>
<p>只需要修改我们的移动构造函数一处即可。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
<span class="token function">smart_ptr</span><span class="token punctuation">(</span>smart_ptr<span class="token operator">&lt;</span>U<span class="token operator">&gt;</span><span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    ptr_ <span class="token operator">=</span> other<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在 <code>smart_ptr&lt;circle&gt;</code> 可以移动给 <code>smart_ptr&lt;shape&gt;</code>，但不能移动给 <code>smart_ptr&lt;triangle&gt;</code>。不正确的转换会在代码编译时直接报错。</p>
<p>至于非隐式的转换，因为本来就是要写特殊的转换函数的，我们留到这一讲的最后再讨论。</p>
<h4 id="2-6-引用计数"><a href="#2-6-引用计数" class="headerlink" title="2.6 引用计数"></a>2.6 引用计数</h4><p>unique_ptr 和 shared_ptr 的主要区别如下图所示：</p>
<p><img src="/images/《现代C++实战30讲》学习笔记/unique_ptr和shared_ptr的主要区别.png" alt="unique_ptr和shared_ptr的主要区别"></p>
<p>先来写出共享计数的接口：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">shared_count</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">shared_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">add_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> <span class="token function">reduce_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> <span class="token function">get_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于真正多线程安全的版本需要用到我们目前还没学到的知识，我们目前先实现一个简单化的版本：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">shared_count</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">shared_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token operator">:</span> <span class="token function">count_</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">add_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token operator">++</span>count_<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">long</span> <span class="token function">reduce_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">--</span>count_<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">long</span> <span class="token function">get_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> count_<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">long</span> count_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在我们可以实现我们的引用计数智能指针了。首先是构造函数、析构函数和私有成员变量：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">smart_ptr</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">explicit</span> <span class="token function">smart_ptr</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
        <span class="token operator">:</span> <span class="token function">ptr_</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            shared_count_ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">shared_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">smart_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr_ <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>shared_count_<span class="token operator">-&gt;</span><span class="token function">reduce_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">delete</span> ptr_<span class="token punctuation">;</span>
            <span class="token keyword">delete</span> shared_count_<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    T<span class="token operator">*</span> ptr_<span class="token punctuation">;</span>
    shared_count<span class="token operator">*</span> shared_count_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了方便实现赋值（及其他一些惯用法），我们需要一个新的 swap 成员函数：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>smart_ptr<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">using</span> std<span class="token operator">::</span>swap<span class="token punctuation">;</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>ptr_<span class="token punctuation">,</span> rhs<span class="token punctuation">.</span>ptr_<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>shared_count_<span class="token punctuation">,</span> rhs<span class="token punctuation">.</span>shared_count_<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>赋值函数可以跟前面一样，保持不变，但拷贝构造和移动构造函数是需要更新一下的：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
<span class="token function">smart_ptr</span><span class="token punctuation">(</span><span class="token keyword">const</span> smart_ptr<span class="token operator">&lt;</span>U<span class="token operator">&gt;</span><span class="token operator">&amp;</span> other<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    ptr_ <span class="token operator">=</span> other<span class="token punctuation">.</span>ptr_<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        other<span class="token punctuation">.</span>shared_count_<span class="token operator">-&gt;</span><span class="token function">add_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        shared_count_ <span class="token operator">=</span> other<span class="token punctuation">.</span>shared_count_<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
<span class="token function">smart_ptr</span><span class="token punctuation">(</span>smart_ptr<span class="token operator">&lt;</span>U<span class="token operator">&gt;</span><span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    ptr_ <span class="token operator">=</span> other<span class="token punctuation">.</span>ptr_<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        shared_count_ <span class="token operator">=</span> other<span class="token punctuation">.</span>shared_count_<span class="token punctuation">;</span>
        other<span class="token punctuation">.</span>ptr_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不过，上面的代码有个问题：它不能正确编译。编译器会报错，像：</p>
<blockquote>
<p><code>fatal error: ‘ptr_’ is a private member of ‘smart_ptr&lt;circle&gt;’</code></p>
</blockquote>
<p>错误原因是模板的各个实例间并不天然就有 friend 关系，因而不能互访私有成员 <code>ptr_</code> 和 <code>shared_count_</code>。我们需要在 smart_ptr 的定义中显式声明：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
<span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">smart_ptr</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>此外，我们之前的实现（类似于单一所有权的 unique_ptr ）中用 release 来手工释放所有权。在目前的引用计数实现中，它就不太合适了，应当删除。但我们要加一个对调试非常有用的函数，返回引用计数值。定义如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">long</span> <span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> shared_count_<span class="token operator">-&gt;</span><span class="token function">get_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="2-7-指针类型转换"><a href="#2-7-指针类型转换" class="headerlink" title="2.7 指针类型转换"></a>2.7 指针类型转换</h4><p>对应于 C++ 里的不同的类型强制转换：</p>
<ul>
<li>static_cast</li>
<li>reinterpret_cast</li>
<li>const_cast</li>
<li>dynamic_cast</li>
</ul>
<p>智能指针需要实现类似的函数模板。实现本身并不复杂，但为了实现这些转换，我们需要添加构造函数，允许在对智能指针内部的指针对象赋值时，使用一个现有的智能指针的共享计数。如下所示：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
<span class="token function">smart_ptr</span><span class="token punctuation">(</span><span class="token keyword">const</span> smart_ptr<span class="token operator">&lt;</span>U<span class="token operator">&gt;</span><span class="token operator">&amp;</span> other<span class="token punctuation">,</span> T<span class="token operator">*</span> ptr<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    ptr_ <span class="token operator">=</span> ptr<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        other<span class="token punctuation">.</span>shared_count_<span class="token operator">-&gt;</span><span class="token function">add_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        shared_count_ <span class="token operator">=</span> other<span class="token punctuation">.</span>shared_count_<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样我们就可以实现转换所需的函数模板了。下面实现一个 dynamic_pointer_cast 来示例一下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
smart_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">dynamic_pointer_cast</span><span class="token punctuation">(</span><span class="token keyword">const</span> smart_ptr<span class="token operator">&lt;</span>U<span class="token operator">&gt;</span><span class="token operator">&amp;</span> other<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    T<span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span>T<span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> smart_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">(</span>other<span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="2-8-代码列表"><a href="#2-8-代码列表" class="headerlink" title="2.8 代码列表"></a>2.8 代码列表</h4><p>完整的 smart_ptr 代码：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;utility&gt;</span> <span class="token comment">// std::swap</span></span>

<span class="token keyword">class</span> <span class="token class-name">shared_count</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">shared_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span>
        <span class="token operator">:</span> <span class="token function">count_</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">add_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span>
    <span class="token punctuation">{</span>
        <span class="token operator">++</span>count_<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">long</span> <span class="token function">reduce_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">--</span>count_<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">long</span> <span class="token function">get_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> count_<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">long</span> count_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">smart_ptr</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
    <span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">smart_ptr</span><span class="token punctuation">;</span>

    <span class="token keyword">explicit</span> <span class="token function">smart_ptr</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
        <span class="token operator">:</span> <span class="token function">ptr_</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            shared_count_ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">shared_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">smart_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"~smart_ptr(): %p\n"</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr_ <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>shared_count_<span class="token operator">-&gt;</span><span class="token function">reduce_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">delete</span> ptr_<span class="token punctuation">;</span>
            <span class="token keyword">delete</span> shared_count_<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
    <span class="token function">smart_ptr</span><span class="token punctuation">(</span><span class="token keyword">const</span> smart_ptr<span class="token operator">&lt;</span>U<span class="token operator">&gt;</span><span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>
    <span class="token punctuation">{</span>
        ptr_ <span class="token operator">=</span> other<span class="token punctuation">.</span>ptr_<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            other<span class="token punctuation">.</span>shared_count_<span class="token operator">-&gt;</span><span class="token function">add_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            shared_count_ <span class="token operator">=</span> other<span class="token punctuation">.</span>shared_count_<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
    <span class="token function">smart_ptr</span><span class="token punctuation">(</span>smart_ptr<span class="token operator">&lt;</span>U<span class="token operator">&gt;</span><span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>
    <span class="token punctuation">{</span>
        ptr_ <span class="token operator">=</span> other<span class="token punctuation">.</span>ptr_<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            shared_count_ <span class="token operator">=</span> other<span class="token punctuation">.</span>shared_count_<span class="token punctuation">;</span>
            other<span class="token punctuation">.</span>ptr_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
    <span class="token function">smart_ptr</span><span class="token punctuation">(</span><span class="token keyword">const</span> smart_ptr<span class="token operator">&lt;</span>U<span class="token operator">&gt;</span><span class="token operator">&amp;</span> other<span class="token punctuation">,</span> T<span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>
    <span class="token punctuation">{</span>
        ptr_ <span class="token operator">=</span> ptr<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            other<span class="token punctuation">.</span>shared_count_<span class="token operator">-&gt;</span><span class="token function">add_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            shared_count_ <span class="token operator">=</span> other<span class="token punctuation">.</span>shared_count_<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    smart_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>smart_ptr rhs<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>
    <span class="token punctuation">{</span>
        rhs<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    T<span class="token operator">*</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> ptr_<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">long</span> <span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> shared_count_<span class="token operator">-&gt;</span><span class="token function">get_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>smart_ptr<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">using</span> std<span class="token operator">::</span>swap<span class="token punctuation">;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>ptr_<span class="token punctuation">,</span> rhs<span class="token punctuation">.</span>ptr_<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>shared_count_<span class="token punctuation">,</span> rhs<span class="token punctuation">.</span>shared_count_<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">*</span>ptr_<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    T<span class="token operator">*</span> <span class="token keyword">operator</span><span class="token operator">-&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> ptr_<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">operator</span> <span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> ptr_<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    T<span class="token operator">*</span> ptr_<span class="token punctuation">;</span>
    shared_count<span class="token operator">*</span> shared_count_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>smart_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> smart_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>
<span class="token punctuation">{</span>
    lhs<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
smart_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">static_pointer_cast</span><span class="token punctuation">(</span><span class="token keyword">const</span> smart_ptr<span class="token operator">&lt;</span>U<span class="token operator">&gt;</span><span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>
<span class="token punctuation">{</span>
    T<span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>T<span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> smart_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">(</span>other<span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
smart_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">reinterpret_pointer_cast</span><span class="token punctuation">(</span><span class="token keyword">const</span> smart_ptr<span class="token operator">&lt;</span>U<span class="token operator">&gt;</span><span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>
<span class="token punctuation">{</span>
    T<span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span>T<span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> smart_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">(</span>other<span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
smart_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">const_pointer_cast</span><span class="token punctuation">(</span><span class="token keyword">const</span> smart_ptr<span class="token operator">&lt;</span>U<span class="token operator">&gt;</span><span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>
<span class="token punctuation">{</span>
    T<span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span>T<span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> smart_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">(</span>other<span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
smart_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">dynamic_pointer_cast</span><span class="token punctuation">(</span><span class="token keyword">const</span> smart_ptr<span class="token operator">&lt;</span>U<span class="token operator">&gt;</span><span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>
<span class="token punctuation">{</span>
    T<span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span>T<span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> smart_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">(</span>other<span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果你足够细心的话，你会发现我在代码里加了不少 noexcept。这对这个智能指针在它的目标场景能正确使用是十分必要的。</p>
<h4 id="2-9-参考资料"><a href="#2-9-参考资料" class="headerlink" title="2.9 参考资料"></a>2.9 参考资料</h4><ol>
<li>Stack Overflow, GManNickG’s answer to “What is the copy-and-swapidiom?”. <a target="_blank" rel="noopener" href="https://stackoverflow.com/a/3279550/816999">https://stackoverflow.com/a/3279550/816999</a></li>
<li>cppreference.com, “std::shared_ptr”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/memory/shared_ptr">https://en.cppreference.com/w/cpp/memory/shared_ptr</a></li>
</ol>
<h3 id="03-右值和移动究竟解决了什么问题？"><a href="#03-右值和移动究竟解决了什么问题？" class="headerlink" title="03 | 右值和移动究竟解决了什么问题？"></a>03 | 右值和移动究竟解决了什么问题？</h3><p>移动语义是 C++11 里引入的一个重要概念；理解这个概念，是理解很多现代 C++ 里的优化的基础。</p>
<h4 id="3-1-值分左右"><a href="#3-1-值分左右" class="headerlink" title="3.1 值分左右"></a>3.1 值分左右</h4><p>C++标准里规定了下面这些值类别（value categories）：</p>
<p><img src="/images/《现代C++实战30讲》学习笔记/CPP表达式值类别.png" alt="CPP表达式值类别"></p>
<p>先理解一下这些名词的字面含义：</p>
<ul>
<li>一个 lvalue 是通常可以放在等号左边的表达式，左值</li>
<li>一个 rvalue 是通常只能放在等号右边的表达式，右值</li>
<li>一个 glvalue 是 generalized lvalue，广义左值</li>
<li>一个 xvalue 是 expiring lvalue，将亡值</li>
<li>一个 prvalue 是 pure rvalue，纯右值</li>
</ul>
<p>暂且抛开这些概念，只看其中两个：lvalue 和 prvalue。</p>
<p>左值 lvalue 是有标识符、可以取地址的表达式，最常见的情况有：</p>
<ul>
<li>变量、函数或数据成员的名字</li>
<li>返回左值引用的表达式，如 ++x、x = 1、cout &lt;&lt; ‘ ‘</li>
<li>字符串字面量如 “hello world”</li>
</ul>
<p>在函数调用时，左值可以绑定到左值引用的参数，如 T&amp;。一个常量只能绑定到常左值引用，如 const T&amp;。</p>
<p>反之，纯右值 prvalue 是没有标识符、不可以取地址的表达式，一般也称之为“临时对象”。最常见的情况有：</p>
<ul>
<li>返回非引用类型的表达式，如 x++、x + 1、make_shared<int>(42)</int></li>
<li>除字符串字面量之外的字面量，如 42、true</li>
</ul>
<p>在 C++11 之前，右值可以绑定到常左值引用（const lvalue reference）的参数，如 const T&amp;，但不可以绑定到非常左值引用（non-const lvalue reference），如 T&amp;。从 C++11 开始，C++ 语言里多了一种引用类型——右值引用。右值引用的形式是 T&amp;&amp;，比左值引用多一个 &amp; 符号。跟左值引用一样，我们可以使用 const 和 volatile 来进行修饰，但最常见的情况是，我们不会用 const 和 volatile 来修饰右值。本专栏就属于这种情况。</p>
<p>引入一种额外的引用类型当然增加了语言的复杂性，但也带来了很多优化的可能性。由于 C++ 有重载，我们就可以根据不同的引用类型，来选择不同的重载函数，来完成不同的行为。回想一下，在上一讲中，我们就利用了重载，让 smart_ptr 的构造函数可以有不同的行为：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
<span class="token function">smart_ptr</span><span class="token punctuation">(</span><span class="token keyword">const</span> smart_ptr<span class="token operator">&lt;</span>U<span class="token operator">&gt;</span><span class="token operator">&amp;</span> other<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    ptr_ <span class="token operator">=</span> other<span class="token punctuation">.</span>ptr_<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        other<span class="token punctuation">.</span>shared_count_<span class="token operator">-&gt;</span><span class="token function">add_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        shared_count_ <span class="token operator">=</span> other<span class="token punctuation">.</span>shared_count_<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
<span class="token function">smart_ptr</span><span class="token punctuation">(</span>smart_ptr<span class="token operator">&lt;</span>U<span class="token operator">&gt;</span><span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    ptr_ <span class="token operator">=</span> other<span class="token punctuation">.</span>ptr_<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        shared_count_ <span class="token operator">=</span> other<span class="token punctuation">.</span>shared_count_<span class="token punctuation">;</span>
        other<span class="token punctuation">.</span>ptr_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用右值引用的第二个重载函数中的变量 other 算是左值还是右值呢？根据定义，other 是个变量的名字，变量有标识符、有地址，所以它还是一个左值——虽然它的类型是右值引用。</p>
<p>尤其重要的是，拿这个 other 去调用函数时，它匹配的也会是左值引用。也就是说，<strong>类型是右值引用的变量是一个左值！</strong>这点可能有点反直觉，但跟 C++ 的其他方面是一致的。毕竟对于一个右值引用的变量，你是可以取地址的，这点上它和左值完全一致。稍后我们再回到这个话题上来。</p>
<p>再看一下下面的代码：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">smart_ptr<span class="token operator">&lt;</span>shape<span class="token operator">&gt;</span> ptr1<span class="token punctuation">{</span><span class="token keyword">new</span> <span class="token function">circle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
smart_ptr<span class="token operator">&lt;</span>shape<span class="token operator">&gt;</span> ptr2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>第一个表达式里的 new circle() 就是一个纯右值；但对于指针，我们通常使用值传递，并不关心它是左值还是右值。</p>
<p>第二个表达式里的 std::move(ptr) 就有趣点了。它的作用是把一个左值引用强制转换成一个右值引用，而并不改变其内容。从实用的角度，在我们这儿 std::move(ptr1) 等价于 static_cast<smart_ptr<shape>&amp;&amp;&gt;(ptr1)。因此，std::move(ptr1) 的结果是指向 ptr1 的一个右值引用，这样构造 ptr2 时就会选择上面第二个重载。</smart_ptr<shape></p>
<p>我们可以把 std::move(ptr1) 看作是一个有名字的右值。为了跟无名的纯右值 prvalue 相区别，C++ 里目前就把这种表达式叫做 xvalue。跟左值 lvalue 不同，xvalue 仍然是不能取地址的——这点上，xvalue 和 prvalue 相同。所以，xvalue 和 prvalue 都被归为右值 rvalue。我们用下面的图来表示会更清楚一点：</p>
<p><img src="/images/《现代C++实战30讲》学习笔记/换角度看的表达式值类别.png" alt="换角度看的表达式值类别"></p>
<p>另外请注意，“值类别”（value category）和“值类型”（value type）是两个看似相似、却毫不相干的术语。前者指的是上面这些左值、右值相关的概念，后者则是与引用类型（reference type）相对而言，表明一个变量是代表实际数值，还是引用另外一个数值。在 C++ 里，所有的原生类型、枚举、结构、联合、类都代表值类型，只有引用（&amp;）和指针（*）才是引用类型。在 Java 里，数字等原生类型是值类型，类则属于引用类型。在 Python 里，一切类型都是引用类型。</p>
<h4 id="3-2-生命周期和表达式类型"><a href="#3-2-生命周期和表达式类型" class="headerlink" title="3.2 生命周期和表达式类型"></a>3.2 生命周期和表达式类型</h4><p>一个变量的生命周期在超出作用域时结束。如果一个变量代表一个对象，当然这个对象的生命周期也在那时结束。那临时对象（prvalue）呢？在这儿，C++ 的规则是：一个临时对象会在包含这个临时对象的完整表达式估值完成后、按生成顺序的逆序被销毁，除非有生命周期延长发生。我们先看一个没有生命周期延长的基本情况：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">shape</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">shape</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">circle</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">shape</span></span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">circle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"circle()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">circle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"~circle()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">triangle</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">shape</span></span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">triangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"triangle()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">triangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"~triangle()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">result</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">result</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"result()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">result</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"~result()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

result <span class="token function">process_shape</span><span class="token punctuation">(</span><span class="token keyword">const</span> shape<span class="token operator">&amp;</span> shape1<span class="token punctuation">,</span> <span class="token keyword">const</span> shape<span class="token operator">&amp;</span> shape2<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"process_shape()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"main()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">process_shape</span><span class="token punctuation">(</span><span class="token function">circle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">triangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"something else"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出结果可能会是（circle 和 triangle 的顺序在标准中没有规定）：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">main()
circle()
triangle()
process_shape()
result()
~result()
~triangle()
~circle()
something else<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>目前我让 process_shape 也返回了一个结果，这是为了下一步演示的需要。你可以看到结果的临时对象最后生成、最先析构。</p>
<p>为了方便对临时对象的使用，C++ 对临时对象有特殊的生命周期延长规则。这条规则是：</p>
<blockquote>
<p>如果一个 prvalue 被绑定到一个引用上，它的生命周期则会延长到跟这个引用变量一样长。</p>
</blockquote>
<p>我们对上面的代码只要改一行就能演示这个效果。把 process_shape 那行改成：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">result<span class="token operator">&amp;&amp;</span> r <span class="token operator">=</span> <span class="token function">process_shape</span><span class="token punctuation">(</span><span class="token function">circle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">triangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>我们就能看到不同的结果了：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">main()
circle()
triangle()
process_shape()
result()
~triangle()
~circle()
something else
~result()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在 result 的生成还在原来的位置，但析构被延到了 main 的最后。</p>
<p>需要万分注意的是，这条生命期延长规则只对 prvalue 有效，而对 xvalue 无效。如果由于某种原因，prvalue 在绑定到引用以前已经变成了 xvalue，那生命期就不会延长。不注意这点的话，代码就可能会产生隐秘的 bug。比如，我们如果这样改一下代码，结果就不对了：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;utility&gt;</span> <span class="token comment">// std::move</span></span>
…
result<span class="token operator">&amp;&amp;</span> r <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token function">process_shape</span><span class="token punctuation">(</span><span class="token function">circle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">triangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这时的代码输出就回到了前一种情况。虽然执行到 something else 那儿我们仍然有一个有效的变量 r，但它指向的对象已经不存在了，对 r 的解引用是一个未定义行为。由于 r 指向的是栈空间，通常不会立即导致程序崩溃，而会在某些复杂的组合条件下才会引致问题……</p>
<p>对 C++ 的这条生命期延长规则，在后面讲到视图（view）的时候会十分有用。那时我们会看到，有些 C++ 的用法实际上会隐式地利用这条规则。</p>
<p>此外，参考资料 [5] 中提到了一个有趣的事实：你可以把一个没有虚析构函数的子类对象绑定到基类的引用变量上，这个子类对象的析构仍然是完全正常的——这是因为这条规则只是延后了临时对象的析构而已，不是利用引用计数等复杂的方法，因而只要引用绑定成功，其类型并没有什么影响。</p>
<h4 id="3-3-移动的意义"><a href="#3-3-移动的意义" class="headerlink" title="3.3 移动的意义"></a>3.3 移动的意义</h4><p>对于 smart_ptr，我们使用右值引用的目的是实现移动，而实现移动的意义是减少运行的开销——在引用计数指针的场景下，这个开销并不大。移动构造和拷贝构造的差异仅在于：</p>
<ul>
<li>少了一次 other.shared_count_-&gt;add_count() 的调用</li>
<li>被移动的指针被清空，因而析构时也少了一次 shared_count_-&gt;reduce_count() 的调用</li>
</ul>
<p>在使用容器类的情况下，移动更有意义。我们可以尝试分析一下下面这个假想的语句（假设 name 是 string 类型）：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string result <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"Hello, "</span><span class="token punctuation">)</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">"."</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在 C++11 之前的年代里，这种写法是绝对不推荐的。因为它会引入很多额外开销，执行流程大致如下：</p>
<ol>
<li>调用构造函数 string(const char*)，生成临时对象 1；”Hello, “ 复制 1 次。</li>
<li>调用 operator+(const string&amp;, const string&amp;)，生成临时对象 2；”Hello,” 复制 2 次，name 复制 1 次。</li>
<li>调用 operator+(const string&amp;, const char*)，生成对象 3；”Hello, “ 复制 3 次，name 复制 2 次，”.” 复制 1 次。</li>
<li>假设返回值优化能够生效（最佳情况），对象 3 可以直接在 result 里构造完成。</li>
<li>临时对象 2 析构，释放指向 string(“Hello, “) + name 的内存。</li>
<li>临时对象 1 析构，释放指向 string(“Hello, “) 的内存。</li>
</ol>
<p>既然 C++ 是一门追求性能的语言，一个合格的 C++ 程序员会写：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string result <span class="token operator">=</span> <span class="token string">"Hello, "</span><span class="token punctuation">;</span>
result <span class="token operator">+=</span> name<span class="token punctuation">;</span>
result <span class="token operator">+=</span> <span class="token string">"."</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这样的话，只会调用构造函数一次和 string::operator+= 两次，没有任何临时对象需要生成和析构，所有的字符串都只复制了一次。但显然代码就啰嗦多了——尤其如果拼接的步骤比较多的话。从 C++11 开始，这不再是必须的。同样上面那个单行的语句，执行流程大致如下：</p>
<ol>
<li>调用构造函数 string(const char*)，生成临时对象 1；”Hello, “ 复制 1 次。</li>
<li>调用 operator+(string&amp;&amp;, const string&amp;)，直接在临时对象 1 上面执行追加操作，并把结果移动到临时对象 2；name 复制 1 次。</li>
<li>调用 operator+(string&amp;&amp;, const char*)，直接在临时对象 2 上面执行追加操作，并把结果移动到 result；”.” 复制 1 次。</li>
<li>临时对象 2 析构，内容已经为空，不需要释放任何内存。</li>
<li>临时对象 1 析构，内容已经为空，不需要释放任何内存。</li>
</ol>
<p>性能上，所有的字符串只复制了一次；虽然比啰嗦的写法仍然要增加临时对象的构造和析构，但由于这些操作不牵涉到额外的内存分配和释放，是相当廉价的。程序员只需要牺牲一点点性能，就可以大大增加代码的可读性。而且，所谓的性能牺牲，也只是相对于优化得很好的 C 或 C++ 代码而言——这样的 C++ 代码的性能仍然完全可以超越 Python 类的语言的相应代码。</p>
<p>一句话总结，移动语义使得在 C++ 里返回大对象（如容器）的函数和运算符成为现实，因而可以提高代码的简洁性和可读性，提高程序员的生产率。</p>
<h4 id="3-4-如何实现移动？"><a href="#3-4-如何实现移动？" class="headerlink" title="3.4 如何实现移动？"></a>3.4 如何实现移动？</h4><p>要让你设计的对象支持移动的话，通常需要下面几步：</p>
<ul>
<li>你的对象应该有分开的拷贝构造和移动构造函数（除非你只打算支持移动，不支持拷贝——如 unique_ptr）。</li>
<li>你的对象应该有 swap 成员函数，支持和另外一个对象快速交换成员。</li>
<li>在你的对象的名空间下，应当有一个全局的 swap 函数，调用成员函数 swap 来实现交换。支持这种用法会方便别人（包括你自己在将来）在其他对象里包含你的对象，并快速实现它们的 swap 函数。</li>
<li>实现通用的 operator=。</li>
<li>上面各个函数如果不抛异常的话，应当标为 noexcept。这对移动构造函数尤为重要。</li>
</ul>
<p>具体写法可以参考我们当前已经实现的 smart_ptr：</p>
<ul>
<li>smart_ptr 有拷贝构造和移动构造函数（虽然此处我们的模板构造函数严格来说不算拷贝或移动构造函数）。移动构造函数应当从另一个对象获取资源，清空其资源，并将其置为一个可析构的状态。</li>
</ul>
<h4 id="3-5-不要返回本地变量的引用"><a href="#3-5-不要返回本地变量的引用" class="headerlink" title="3.5 不要返回本地变量的引用"></a>3.5 不要返回本地变量的引用</h4><p>在 C++11 之前，返回一个本地对象意味着这个对象会被拷贝，除非编译器发现可以做返回值优化（named return value optimization，或 NRVO），能把对象直接构造到调用者的栈上。从 C++11 开始，返回值优化仍可以发生，但在没有返回值优化的情况下，编译器将试图把本地对象移动出去，而不是拷贝出去。这一行为不需要程序员手工用 std::move 进行干预——使用std::move 对于移动行为没有帮助，反而会影响返回值优化。</p>
<p>下面是个例子：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span> <span class="token comment">// std::cout/endl</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;utility&gt;</span> <span class="token comment">// std::move</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Obj</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Obj</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Obj()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">Obj</span><span class="token punctuation">(</span><span class="token keyword">const</span> Obj<span class="token operator">&amp;</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Obj(const Obj&amp;)"</span>
             <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">Obj</span><span class="token punctuation">(</span>Obj<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Obj(Obj&amp;&amp;)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Obj <span class="token function">simple</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Obj obj<span class="token punctuation">;</span>
    <span class="token comment">// 简单返回对象；一般有 NRVO</span>
    <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
Obj <span class="token function">simple_with_move</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Obj obj<span class="token punctuation">;</span>
    <span class="token comment">// move 会禁止 NRVO</span>
    <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
Obj <span class="token function">complicated</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Obj obj1<span class="token punctuation">;</span>
    Obj obj2<span class="token punctuation">;</span>
    <span class="token comment">// 有分支，一般无 NRVO</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> obj1<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> obj2<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"*** 1 ***"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">auto</span> obj1 <span class="token operator">=</span> <span class="token function">simple</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"*** 2 ***"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">auto</span> obj2 <span class="token operator">=</span> <span class="token function">simple_with_move</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"*** 3 ***"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">auto</span> obj3 <span class="token operator">=</span> <span class="token function">complicated</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出通常为：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">*** 1 ***
Obj()
*** 2 ***
Obj()
Obj(Obj&amp;&amp;)
*** 3 ***
Obj()
Obj()
Obj(Obj&amp;&amp;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也就是，用了 std::move 反而妨碍了返回值优化。</p>
<h4 id="3-6-引用坍缩和完美转发"><a href="#3-6-引用坍缩和完美转发" class="headerlink" title="3.6 引用坍缩和完美转发"></a>3.6 引用坍缩和完美转发</h4><p>引用坍缩（又称“引用折叠”）。</p>
<p>我们已经讲了对于一个实际的类型 T，它的左值引用是 T&amp;，右值引用是 T&amp;&amp;。那么：</p>
<ol>
<li>是不是看到 T&amp;，就一定是个左值引用？</li>
<li>是不是看到 T&amp;&amp;，就一定是个右值引用？</li>
</ol>
<p>对于前者的回答是“是”，对于后者的回答为“否”。</p>
<p>关键在于，在有模板的代码里，对于类型参数的推导结果可能是引用。我们可以略过一些繁复的语法规则，要点是：</p>
<ul>
<li>对于 <code>template &lt;typename T&gt; foo(T&amp;&amp;)</code> 这样的代码，如果传递过去的参数是左值，T 的推导结果是左值引用；如果传递过去的参数是右值，T 的推导结果是参数的类型本身。</li>
<li>如果 T 是左值引用，那 T&amp;&amp; 的结果仍然是左值引用——即 type&amp; &amp;&amp; 坍缩成了 type&amp;。</li>
<li>如果 T 是一个实际类型，那 T&amp;&amp; 的结果自然就是一个右值引用。</li>
</ul>
<p>我们之前提到过，右值引用变量仍然会匹配到左值引用上去。下面的代码会验证这一行为：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">const</span> shape<span class="token operator">&amp;</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"foo(const shape&amp;)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>shape<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"foo(shape&amp;&amp;)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token keyword">const</span> shape<span class="token operator">&amp;</span> s<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"bar(const shape&amp;)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">foo</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span>shape<span class="token operator">&amp;&amp;</span> s<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"bar(shape&amp;&amp;)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">foo</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">bar</span><span class="token punctuation">(</span><span class="token function">circle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出为：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">bar(shape&amp;&amp;)
foo(const shape&amp;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果我们要让 bar 调用右值引用的那个 foo 的重载，我们必须写成：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">foo</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>或：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>shape<span class="token operator">&amp;&amp;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>可如果两个 bar 的重载除了调用 foo 的方式不一样，其他都差不多的话，我们为什么要提供两个不同的 bar 呢？</p>
<p>事实上，很多标准库里的函数，连目标的参数类型都不知道，但我们仍然需要能够保持参数的值类型：左值的仍然是左值，右值的仍然是右值。这个功能在 C++ 标准库中已经提供了，叫 std::forward。它和 std::move 一样都是利用引用坍缩机制来实现。此处，我们不介绍其实现细节，而是重点展示其用法。我们可以把我们的两个 bar 函数简化成：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> s<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">foo</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于下面这样的代码：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">circle temp<span class="token punctuation">;</span>
<span class="token function">bar</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token function">circle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>现在的输出是：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">foo(const shape&amp;)
foo(shape&amp;&amp;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>因为在 T 是模板参数时，T&amp;&amp; 的作用主要是保持值类别进行转发，它有个名字就叫“转发引用”（forwarding reference）。因为既可以是左值引用，也可以是右值引用，它也曾经被叫做“万能引用”（universal reference）。</p>
<h4 id="3-7-参考资料"><a href="#3-7-参考资料" class="headerlink" title="3.7 参考资料"></a>3.7 参考资料</h4><ol>
<li>cppreference.com, “Value categories”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/value_category">https://en.cppreference.com/w/cpp/language/value_category</a></li>
<li>Anders Schau Knatten, “lvalues, rvalues, glvalues, prvalues, xvalues, help!”. <a target="_blank" rel="noopener" href="https://blog.knatten.org/2018/03/09/lvalues-rvalues-glvalues-prvalues-xvalueshelp/">https://blog.knatten.org/2018/03/09/lvalues-rvalues-glvalues-prvalues-xvalueshelp/</a></li>
<li>Jeaye, “Value category cheat-sheet”. <a target="_blank" rel="noopener" href="https://blog.jeaye.com/2017/03/19/xvalues/">https://blog.jeaye.com/2017/03/19/xvalues/</a></li>
<li>Thomas Becker, “C++ rvalue references explained”. <a target="_blank" rel="noopener" href="http://thbecker.net/articles/rvalue_references/section_01.html">http://thbecker.net/articles/rvalue_references/section_01.html</a></li>
<li>Herb Sutter, “GotW #88: A candidate for the ‘most important const’”. <a target="_blank" rel="noopener" href="https://herbsutter.com/2008/01/01/gotw-88-a-candidate-for-the-mostimportant-const/">https://herbsutter.com/2008/01/01/gotw-88-a-candidate-for-the-mostimportant-const/</a></li>
</ol>
<h3 id="04-容器汇编-I：比较简单的若干容器"><a href="#04-容器汇编-I：比较简单的若干容器" class="headerlink" title="04 | 容器汇编 I：比较简单的若干容器"></a>04 | 容器汇编 I：比较简单的若干容器</h3><h4 id="4-1-string"><a href="#4-1-string" class="headerlink" title="4.1 string"></a>4.1 string</h4><p>在 string 的情况下，由于考虑到和 C 字符串的兼容，end 指向代表字符串结尾的 \0 字符。</p>
<p>string 的内存布局大致如下图所示：</p>
<p><img src="/images/《现代C++实战30讲》学习笔记/string的内存布局.png" alt="string的内存布局"></p>
<p>一些策略：</p>
<ul>
<li>如果不修改字符串的内容，使用 const string&amp; 或 C++17 的 string_view 作为参数类型。后者是最理想的情况，因为即使在只有 C 字符串的情况，也不会引发不必要的内存复制。</li>
<li>如果需要在函数内修改字符串内容、但不影响调用者的该字符串，使用 string 作为参数类型（自动拷贝）。</li>
<li>如果需要改变调用者的字符串内容，使用 string&amp; 作为参数类型（通常不推荐）。</li>
</ul>
<h4 id="4-2-vector"><a href="#4-2-vector" class="headerlink" title="4.2 vector"></a>4.2 vector</h4><p><img src="/images/《现代C++实战30讲》学习笔记/vector的内存布局.png" alt="vector的内存布局"></p>
<p>vector 通常保证强异常安全性，如果元素类型没有提供一个<strong>保证不抛异常的移动构造函数</strong>，vector 通常会使用拷贝构造函数。因此，对于拷贝代价较高的自定义元素类型，我们应当定义移动构造函数，并标其为 noexcept，或只在容器中放置对象的智能指针。这就是为什么我之前需要在 smart_ptr 的实现中标上 noexcept 的原因。</p>
<p>下面的代码可以演示这一行为：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Obj1</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Obj1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Obj1()\n"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">Obj1</span><span class="token punctuation">(</span><span class="token keyword">const</span> Obj1<span class="token operator">&amp;</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Obj1(const Obj1&amp;)\n"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">Obj1</span><span class="token punctuation">(</span>Obj1<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Obj1(Obj1&amp;&amp;)\n"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Obj2</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Obj2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Obj2()\n"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">Obj2</span><span class="token punctuation">(</span><span class="token keyword">const</span> Obj2<span class="token operator">&amp;</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Obj2(const Obj2&amp;)\n"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">Obj2</span><span class="token punctuation">(</span>Obj2<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Obj2(Obj2&amp;&amp;)\n"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    vector<span class="token operator">&lt;</span>Obj1<span class="token operator">&gt;</span> v1<span class="token punctuation">;</span>
    v1<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    v1<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    v1<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    v1<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    vector<span class="token operator">&lt;</span>Obj2<span class="token operator">&gt;</span> v2<span class="token punctuation">;</span>
    v2<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    v2<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    v2<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    v2<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们可以立即得到下面的输出：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">Obj1()
Obj1()
Obj1()
Obj1(const Obj1&amp;)
Obj1(const Obj1&amp;)
Obj2()
Obj2()
Obj2()
Obj2(Obj2&amp;&amp;)
Obj2(Obj2&amp;&amp;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Obj1 和 Obj2 的定义只差了一个 noexcept，但这个小小的差异就导致了 vector 是否会移动对象。这点非常重要。</p>
<p>C++11 开始提供的 emplace… 系列函数是为了提升容器的性能而设计的。你可以试试把 v1.emplace_back() 改成 v1.push_back(Obj1())。对于 vector 里的内容，结果是一样的；但使用 push_back 会额外生成临时对象，多一次拷贝构造和一次析构。</p>
<h4 id="4-3-deque"><a href="#4-3-deque" class="headerlink" title="4.3 deque"></a>4.3 deque</h4><p>deque 的内存布局一般是这样的：</p>
<p><img src="/images/《现代C++实战30讲》学习笔记/deque的内存布局.png" alt="deque的内存布局"></p>
<h4 id="4-4-list"><a href="#4-4-list" class="headerlink" title="4.4 list"></a>4.4 list</h4><p>list 的内存布局一般是下图这个样子：</p>
<p><img src="/images/《现代C++实战30讲》学习笔记/list的内存布局.png" alt="list的内存布局"></p>
<p>某些标准算法在 list 上会导致问题，list 提供了成员函数作为替代，包括下面几个：</p>
<ul>
<li>merge</li>
<li>remove</li>
<li>remove_if</li>
<li>reverse</li>
<li>sort</li>
<li>unique</li>
</ul>
<h4 id="4-5-forward-list"><a href="#4-5-forward-list" class="headerlink" title="4.5 forward_list"></a>4.5 forward_list</h4><p>从 C++11 开始，前向列表 forward_list 成了标准的一部分。</p>
<p>它的内存布局：</p>
<p><img src="/images/《现代C++实战30讲》学习笔记/forward_list的内存布局.png" alt="forward_list的内存布局"></p>
<h4 id="4-6-queue"><a href="#4-6-queue" class="headerlink" title="4.6 queue"></a>4.6 queue</h4><p>queue 缺省用 deque 来实现。</p>
<p>从概念上讲，它的结构可如下所示：</p>
<p><img src="/images/《现代C++实战30讲》学习笔记/queue概念上的结构.png" alt="queue概念上的结构"></p>
<h4 id="4-7-stack"><a href="#4-7-stack" class="headerlink" title="4.7 stack"></a>4.7 stack</h4><p>queue 缺省也是用 deque 来实现。</p>
<p>一般图形表示法会把 stack 表示成一个竖起的 vector：</p>
<p><img src="/images/《现代C++实战30讲》学习笔记/stack概念上的结构.png" alt="stack概念上的结构.png"></p>
<h4 id="4-8-参考资料"><a href="#4-8-参考资料" class="headerlink" title="4.8 参考资料"></a>4.8 参考资料</h4><ol>
<li>cppreference.com, “Containers library”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/container">https://en.cppreference.com/w/cpp/container</a></li>
<li>QuantStack, xeus-cling. <a target="_blank" rel="noopener" href="https://github.com/QuantStack/xeus-cling">https://github.com/QuantStack/xeus-cling</a></li>
<li>吴咏炜, output_container. <a target="_blank" rel="noopener" href="https://github.com/adah1972/output_container/blob/master/output_container.h">https://github.com/adah1972/output_container/blob/master/output_container.h</a></li>
</ol>
<h3 id="05-容器汇编-II：需要函数对象的容器"><a href="#05-容器汇编-II：需要函数对象的容器" class="headerlink" title="05 | 容器汇编 II：需要函数对象的容器"></a>05 | 容器汇编 II：需要函数对象的容器</h3><h4 id="5-1-函数对象及其特化"><a href="#5-1-函数对象及其特化" class="headerlink" title="5.1 函数对象及其特化"></a>5.1 函数对象及其特化</h4><p>在讲容器之前，我们需要首先来讨论一下两个重要的函数对象，less 和 hash。</p>
<p>在标准库里，通用的 less 大致是这样定义的：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">less</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">binary_function</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> y<span class="token punctuation">)</span> <span class="token keyword">const</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> x <span class="token operator">&lt;</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也就是说，less 是一个函数对象，并且是个二元函数，执行对任意类型的值的比较，返回布尔类型。作为函数对象，它定义了函数调用运算符（operator()），并且缺省行为是对指定类型的对象进行 &lt; 的比较操作。</p>
<p>在需要大小比较的场合，C++ 通常默认会使用 less，包括我们今天会讲到的若干容器和排序算法 sort。如果我们需要产生相反的顺序的话，则可以使用 greater，大于关系。</p>
<p>计算哈希值的函数对象 hash 的目的是把一个某种类型的值转换成一个无符号整数哈希值，类型为 size_t。它没有一个可用的默认实现。对于常用的类型，系统提供了需要的特化 [2]，类似于：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">hash</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">hash</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">:</span> <span class="token keyword">public</span> unary_function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> size_t<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    size_t <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>size_t<span class="token operator">&gt;</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要点是，对于每个类，类的作者都可以提供 hash 的特化，使得对于不同的对象值，函数调用运算符都能得到尽可能均匀分布的不同数值。</p>
<p>用下面这个例子来加深一下理解：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span> <span class="token comment">// std::sort</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional&gt;</span> <span class="token comment">// std::less/greater/hash</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span> <span class="token comment">// std::cout/endl</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span> <span class="token comment">// std::string</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span> <span class="token comment">// std::vector</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"output_container.h"</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 初始数组</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v <span class="token punctuation">{</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">29</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> v <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token comment">// 从小到大排序</span>
    <span class="token function">sort</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> v <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token comment">// 从大到小排序</span>
    <span class="token function">sort</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> v <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> hex<span class="token punctuation">;</span>
    <span class="token keyword">auto</span> hp <span class="token operator">=</span> hash<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hash(nullptr) = "</span>
         <span class="token operator">&lt;&lt;</span> <span class="token function">hp</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hash(v.data()) = "</span>
         <span class="token operator">&lt;&lt;</span> <span class="token function">hp</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"v.data() = "</span>
         <span class="token operator">&lt;&lt;</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
         <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">auto</span> hs <span class="token operator">=</span> hash<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hash(\"hello\") = "</span>
         <span class="token operator">&lt;&lt;</span> <span class="token function">hs</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hash(\"hellp\") = "</span>
         <span class="token operator">&lt;&lt;</span> <span class="token function">hs</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"hellp"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 MSVC 下的某次运行结果如下所示：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">{ 13, 6, 4, 11, 29 }
{ 4, 6, 11, 13, 29 }
{ 29, 13, 11, 6, 4 }
hash(nullptr) = a8c7f832281a39c5
hash(v.data()) = 7a0bdfd7df0923d2
v.data() = 000001EFFB10EAE0
hash("hello") = a430d84680aabd0b
hash("hellp") = a430e54680aad322<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到，在这个实现里，空指针的哈希值是一个非零的数值，指针的哈希值也和指针的数值不一样。要注意不同的实现处理的方式会不一样。事实上，我的测试结果是 GCC、Clang 和 MSVC 对常见类型的哈希方式都各有不同。</p>
<p>在上面的例子里，我们同时可以看到，这两个函数对象的值不重要。我们甚至可以认为，每个 less（或 greater 或 hash）对象都是等价的。关键在于其类型。以 sort 为例，第三个参数的类型确定了其排序行为。</p>
<p>对于容器也是如此，函数对象的类型确定了容器的行为。</p>
<h4 id="5-2-priority-queue"><a href="#5-2-priority-queue" class="headerlink" title="5.2 priority_queue"></a>5.2 priority_queue</h4><p>priority_queue 也是一个容器适配器。上一讲没有和其他容器适配器一起讲的原因就在于它用到了比较函数对象（默认是 less）。在使用缺省的 less 作为其 Compare 模板参数时，最大的数值会出现在容器的“顶部”。如果需要最小的数值出现在容器顶部，则可以传递 greater 作为其 Compare 模板参数。</p>
<h4 id="5-3-关联容器"><a href="#5-3-关联容器" class="headerlink" title="5.3 关联容器"></a>5.3 关联容器</h4><p>关联容器有 set（集合）、map（映射）、multiset（多重集）和 multimap（多重映射）。跳出 C++ 的语境，map（映射）的更常见的名字是关联数组和字典 [3]，而在 JSON里直接被称为对象（object）。在 C++ 外这些容器常常是无序的；在 C++ 里关联容器则被认为是有序的。</p>
<p>关联容器都有 find、lower_bound、upper_bound 等查找函数，结果是一个迭代器：</p>
<ul>
<li>find(k) 可以找到任何一个等价于查找键 k 的元素（!(x &lt; k || k &lt; x)）</li>
<li>lower_bound(k) 找到第一个不小于查找键 k 的元素（!(x &lt; k)）</li>
<li>upper_bound(k) 找到第一个大于查找键 k 的元素（k &lt; x）</li>
</ul>
<p>如果你需要在 multimap 里精确查找满足某个键的区间的话，建议使用 equal_range，可以一次性取得上下界（半开半闭）。</p>
<p>对于自定义类型，我推荐尽量使用标准的 less 实现，通过重载 &lt;（及其他标准比较运算符）对该类型的对象进行排序。存储在关联容器中的键一般应满足严格弱序关系（strict weak ordering；[4]），即：</p>
<ul>
<li>对于任何该类型的对象 x：!(x &lt; x)（非自反）</li>
<li>对于任何该类型的对象 x 和 y：如果 x &lt; y，则 !(y &lt; x)（非对称）</li>
<li>对于任何该类型的对象 x、y 和 z：如果 x &lt; y 并且 y &lt; z，则 x &lt; z（传递性）</li>
<li>对于任何该类型的对象 x、y 和 z：如果 x 和 y 不可比（!(x &lt; y) 并且 !(y &lt; x)）并且 y 和 z 不可比，则 x 和 z 不可比（不可比的传递性）</li>
</ul>
<h4 id="5-4-无序关联容器"><a href="#5-4-无序关联容器" class="headerlink" title="5.4 无序关联容器"></a>5.4 无序关联容器</h4><p>从 C++11 开始，每一个关联容器都有一个对应的无序关联容器，它们是：</p>
<ul>
<li>unordered_set</li>
<li>unordered_map</li>
<li>unordered_multiset</li>
<li>unordered_multimap</li>
</ul>
<p>一个示例：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;complex&gt;</span> <span class="token comment">// std::complex</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span> <span class="token comment">// std::cout/endl</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unordered_map&gt;</span> <span class="token comment">// std::unordered_map</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unordered_set&gt;</span> <span class="token comment">// std::unordered_set</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"output_container.h"</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">namespace</span> std <span class="token punctuation">{</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">hash</span><span class="token operator">&lt;</span>complex<span class="token operator">&lt;</span>T<span class="token operator">&gt;&gt;</span> <span class="token punctuation">{</span>
    size_t <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> complex<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span>
    <span class="token punctuation">{</span>
        hash<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> h<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">real</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">h</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">imag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">// namespace std</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> s <span class="token punctuation">{</span>
        <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">21</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    unordered_map<span class="token operator">&lt;</span>complex<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">&gt;</span> umc <span class="token punctuation">{</span>
        <span class="token punctuation">{</span> <span class="token punctuation">{</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1.4142</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span> <span class="token punctuation">{</span> <span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token number">4.0</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">5.0</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> umc <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出可能是（顺序不能保证）：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">{ 21, 5, 8, 3, 13, 2, 1 }
{ (3,4) =&gt; 5, (1,1) =&gt; 1.4142 }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>请注意我们在 std 名空间中添加了特化，这是少数用户可以向 std 名空间添加内容的情况之一。正常情况下，向 std 名空间添加声明或定义是禁止的，属于未定义行为。</p>
<h4 id="5-5-array"><a href="#5-5-array" class="headerlink" title="5.5 array"></a>5.5 array</h4><p>C 数组在 C++ 里继续存在，主要是为了保留和 C 的向后兼容性。C 数组本身和 C++ 的容器相差是非常大的：</p>
<ul>
<li>C 数组没有 begin 和 end 成员函数（虽然可以使用全局的 begin 和 end 函数）</li>
<li>C 数组没有 size 成员函数（得用一些模板技巧来获取其长度）</li>
<li>C 数组作为参数有退化行为，传递给另外一个函数后那个函数不再能获得 C 数组的长度和结束位置</li>
</ul>
<p>在 C 的年代，大家有时候会定义这样一个宏来获得数组的长度：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">ARRAY_LEN</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果在一个函数内部对数组参数使用这个宏，结果肯定是错的。现在 GCC 会友好地发出警告：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token function">ARRAY_LEN</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>warning: sizeof on array function parameter will return size of ‘int *’ instead of ‘int [8]’ [-Wsizeof-array-argument]</p>
<p>cout &lt;&lt; ARRAY_LEN(a) &lt;&lt; endl;</p>
</blockquote>
<p>C++17 直接提供了一个 size 方法，可以用于提供数组长度，并且在数组退化成指针的情况下会直接失败：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span> <span class="token comment">// std::cout/endl</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span> <span class="token comment">// std::size</span></span>

<span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 不能编译</span>
    <span class="token comment">// std::cout &lt;&lt; std::size(arr)</span>
    <span class="token comment">// &lt;&lt; std::endl;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"The array length is "</span>
              <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span><span class="token function">size</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>
              <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token function">test</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此外，C 数组也没有良好的复制行为。</p>
<p>array 可以避免 C 数组的种种怪异行径。</p>
<h4 id="5-6-参考资料"><a href="#5-6-参考资料" class="headerlink" title="5.6 参考资料"></a>5.6 参考资料</h4><ol>
<li>cppreference.com, “Containers library”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/container">https://en.cppreference.com/w/cpp/container</a></li>
<li>cppreference.com, “Explicit (full) template specialization”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/template_specialization">https://en.cppreference.com/w/cpp/language/template_specialization</a></li>
<li>Wikipedia, “Associative array”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Associative_array">https://en.wikipedia.org/wiki/Associative_array</a></li>
<li><p>Wikipedia, “Weak ordering”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Weak_ordering">https://en.wikipedia.org/wiki/Weak_ordering</a></p>
</li>
<li><p>Wikipedia, “Hash table”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Hash_table">https://en.wikipedia.org/wiki/Hash_table</a></p>
</li>
</ol>
<h3 id="06-异常：用还是不用，这是个问题"><a href="#06-异常：用还是不用，这是个问题" class="headerlink" title="06 | 异常：用还是不用，这是个问题"></a>06 | 异常：用还是不用，这是个问题</h3><p>首先，开宗明义，如果你不知道到底该不该用异常的话，那答案就是该用。如果你需要避免使用异常，原因必须是你有明确的需要避免使用异常的理由。</p>
<h4 id="6-1-没有异常的世界"><a href="#6-1-没有异常的世界" class="headerlink" title="6.1 没有异常的世界"></a>6.1 没有异常的世界</h4><p>我们先来看看没有异常的世界是什么样子的。最典型的情况就是 C 了。</p>
<p>假设我们要做一些矩阵的操作，定义了下面这个矩阵的数据结构：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token keyword">float</span><span class="token operator">*</span> data<span class="token punctuation">;</span>
    size_t nrows<span class="token punctuation">;</span>
    size_t ncols<span class="token punctuation">;</span>
<span class="token punctuation">}</span> matrix<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们至少需要有初始化和清理的代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span> <span class="token class-name">matrix_err_code</span> <span class="token punctuation">{</span>
    MATRIX_SUCCESS<span class="token punctuation">,</span>
    MATRIX_ERR_MEMORY_INSUFFICIENT<span class="token punctuation">,</span>
    <span class="token comment">//…</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">matrix_alloc</span><span class="token punctuation">(</span>matrix<span class="token operator">*</span> ptr<span class="token punctuation">,</span> size_t nrows<span class="token punctuation">,</span> size_t ncols<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    size_t size <span class="token operator">=</span> nrows <span class="token operator">*</span> ncols <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span><span class="token operator">*</span> data <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> MATRIX_ERR_MEMORY_INSUFFICIENT<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    ptr<span class="token operator">-&gt;</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
    ptr<span class="token operator">-&gt;</span>nrows <span class="token operator">=</span> nrows<span class="token punctuation">;</span>
    ptr<span class="token operator">-&gt;</span>ncols <span class="token operator">=</span> ncols<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">matrix_dealloc</span><span class="token punctuation">(</span>matrix<span class="token operator">*</span> ptr<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr<span class="token operator">-&gt;</span>data <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">free</span><span class="token punctuation">(</span>ptr<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ptr<span class="token operator">-&gt;</span>data <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    ptr<span class="token operator">-&gt;</span>nrows <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    ptr<span class="token operator">-&gt;</span>ncols <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后，我们做一下矩阵乘法吧。函数定义大概会是这个样子：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">matrix_multiply</span><span class="token punctuation">(</span>matrix<span class="token operator">*</span> result<span class="token punctuation">,</span> <span class="token keyword">const</span> matrix<span class="token operator">*</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> matrix<span class="token operator">*</span> rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> errcode<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>lhs<span class="token operator">-&gt;</span>ncols <span class="token operator">!=</span> rhs<span class="token operator">-&gt;</span>nrows<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> MATRIX_ERR_MISMATCHED_MATRIX_SIZE<span class="token punctuation">;</span>
        <span class="token comment">// 呃，得把这个错误码添到 enum matrix_err_code 里</span>
    <span class="token punctuation">}</span>
    errcode <span class="token operator">=</span> <span class="token function">matrix_alloc</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> lhs<span class="token operator">-&gt;</span>nrows<span class="token punctuation">,</span> rhs<span class="token operator">-&gt;</span>ncols<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>errcode <span class="token operator">!=</span> MATRIX_SUCCESS<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> errcode<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 进行矩阵乘法运算</span>
    <span class="token keyword">return</span> MATRIX_SUCCESS<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>调用代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">matrix c<span class="token punctuation">;</span>

<span class="token function">memset</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
errcode <span class="token operator">=</span> <span class="token function">matrix_multiply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>errcode <span class="token operator">!=</span> MATRIX_SUCCESS<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">goto</span> error_exit<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 使用乘法的结果做其他处理</span>

error_exit<span class="token operator">:</span>
    <span class="token function">matrix_dealloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> errcode<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到，我们有大量需要判断错误的代码，零散分布在代码各处。</p>
<p>可这是 C 啊。我们用 C++、不用异常可以吗？</p>
<p>当然可以，但你会发现结果好不了多少。毕竟，C++ 的构造函数是不能返回错误码的，所以你根本不能用构造函数来做可能出错的事情。你不得不定义一个只能清零的构造函数，再使用一个 init 函数来做真正的构造操作。C++ 虽然支持运算符重载，可你也不能使用，因为你没法返回一个新矩阵……</p>
<h4 id="6-2-使用异常"><a href="#6-2-使用异常" class="headerlink" title="6.2 使用异常"></a>6.2 使用异常</h4><p>如果使用异常的话，我们就可以在构造函数里做真正的初始化工作了。假设我们的矩阵类有下列的数据成员：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">matrix</span> <span class="token punctuation">{</span>
    <span class="token comment">//…</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">float</span><span class="token operator">*</span> data_<span class="token punctuation">;</span>
    size_t nrows_<span class="token punctuation">;</span>
    size_t ncols_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>构造函数和析构函数我们可以这样写：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">matrix<span class="token operator">::</span><span class="token function">matrix</span><span class="token punctuation">(</span>size_t nrows<span class="token punctuation">,</span> size_t ncols<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    data_ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">float</span><span class="token punctuation">[</span>nrows <span class="token operator">*</span> ncols<span class="token punctuation">]</span><span class="token punctuation">;</span>
    nrows_ <span class="token operator">=</span> nrows<span class="token punctuation">;</span>
    ncols_ <span class="token operator">=</span> ncols<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">matrix</span><span class="token operator">::</span><span class="token operator">~</span><span class="token function">matrix</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>乘法函数可以这样写：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">matrix</span> <span class="token punctuation">{</span>
    <span class="token comment">//…</span>
    <span class="token keyword">friend</span> matrix <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> matrix<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> matrix<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

matrix <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> matrix<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> matrix<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>ncols <span class="token operator">!=</span> rhs<span class="token punctuation">.</span>nrows<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"matrix sizes mismatch"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    matrix <span class="token function">result</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>nrows<span class="token punctuation">,</span> rhs<span class="token punctuation">.</span>ncols<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 进行矩阵乘法运算</span>

    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用乘法的代码则更是简单：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">matrix c <span class="token operator">=</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>你可能已经非常疑惑了：错误处理在哪儿呢？只有一个 throw，跟前面的 C 代码能等价吗？</p>
<p>异常处理并不意味着需要写显式的 try 和 catch。<strong>异常安全的代码，可以没有任何 try 和 catch</strong>。</p>
<p>如果你不确定什么是“异常安全”，我们先来温习一下概念：异常安全是指当异常发生时，既不会发生资源泄漏，系统也不会处于一个不一致的状态。</p>
<p>我们看看可能会出现错误 / 异常的地方：</p>
<ul>
<li>首先是内存分配。如果 new 出错，按照 C++ 的规则，一般会得到异常 bad_alloc，对象的构造也就失败了。这种情况下，在 catch 捕捉到这个异常之前，所有的栈上对象会全部被析构，资源全部被自动清理。</li>
<li>如果是矩阵的长宽不合适不能做乘法呢？我们同样会得到一个异常，这样，在使用乘法的地方，对象 c 根本不会被构造出来。</li>
<li>如果在乘法函数里内存分配失败呢？一样，result 对象根本没有构造出来，也就没有 c 对象了。还是一切正常。</li>
<li>如果 a、b 是本地变量，然后乘法失败了呢？析构函数会自动释放其空间，我们同样不会有任何资源泄漏。</li>
</ul>
<p>总而言之，只要我们适当地组织好代码、利用好 RAII，实现矩阵的代码和使用矩阵的代码都可以更短、更清晰。我们可以统一在外层某个地方处理异常——通常会记日志、或在界面上向用户报告错误了。</p>
<h4 id="6-3-避免异常的风格指南？"><a href="#6-3-避免异常的风格指南？" class="headerlink" title="6.3 避免异常的风格指南？"></a>6.3 避免异常的风格指南？</h4><p>但大名鼎鼎的 Google 的 C++ 风格指南不是说要避免异常吗 [1]？这又是怎么回事呢？</p>
<p>答案实际已经在 Google 的文档里了：</p>
<blockquote>
<p>Given that Google’s existing code is not exception-tolerant, the costs of using<br>exceptions are somewhat greater than the costs in a new project. The conversion<br>process would be slow and error-prone. We don’t believe that the available<br>alternatives to exceptions, such as error codes and assertions, introduce a<br>significant burden.</p>
<p>Our advice against using exceptions is not predicated on philosophical or moral<br>grounds, but practical ones. Because we’d like to use our open-source projects<br>at Google and it’s difficult to do so if those projects use exceptions, we need to<br>advise against exceptions in Google open-source projects as well. Things would<br>probably be different if we had to do it all over again from scratch.</p>
</blockquote>
<p>我来翻译一下（我的加重）：</p>
<blockquote>
<p>鉴于 Google 的现有代码不能承受异常，<strong>使用异常的代价要比在全新的项目中使用异常</strong><br><strong>大一些。</strong> 转换 [代码来使用异常的] 过程会缓慢而容易出错。我们不认为可代替异常的方<br>法，如错误码或断言，会带来明显的负担。</p>
<p>我们反对异常的建议并非出于哲学或道德的立场，而是出于实际考虑。因为我们希望在<br>Google 使用我们的开源项目，而如果这些项目使用异常的话就会对我们的使用带来困<br>难，我们也需要反对在 Google 的开源项目中使用异常。<strong>如果我们从头再来一次的话，</strong><br><strong>事情可能就会不一样了。</strong></p>
</blockquote>
<p>这个如果还比较官方、委婉的话，Reddit 上还能找到一个更个人化的表述 [2]：</p>
<blockquote>
<p>I use [sic] to work at Google, and Craig Silverstein, who wrote the first draft of<br>the style guideline, said that he regretted the ban on exceptions, but he had no<br>choice; when he wrote it, it wasn’t only that the compiler they had at the time<br>did a very bad job on exceptions, but that they already had a huge volume of<br>non-exception-safe code.</p>
</blockquote>
<p>我的翻译（同样，我的加重）：</p>
<blockquote>
<p>我过去在 Google 工作，写了风格指南初稿的 Craig Silverstein 说过 <strong>他对禁用异常感到</strong><br><strong>遗憾</strong> ，但他当时别无选择。在他写风格指南的时候，不仅<strong>他们使用的编译器在异常上工</strong><br><strong>作得很糟糕，而且他们已经有了一大堆异常不安全的代码了。</strong></p>
</blockquote>
<p>当然，除了历史原因以外，也有出于性能等其他原因禁用异常的。美国国防部的联合攻击战斗机（JSF）项目的 C++ 编码规范就禁用异常，因为工具链不能保证抛出异常时的实时性能。不过在那种项目里，被禁用的 C++ 特性就多了，比如动态内存分配都不能使用。</p>
<p>一些游戏项目为了追求高性能，也禁用异常。这个实际上也有一定的历史原因，因为今天的主流 C++ 编译器，在异常关闭和开启时应该已经能够产生性能差不多的代码（在异常未抛出时）。代价是产生的二进制文件大小的增加，因为异常产生的位置决定了需要如何做栈展开，这些数据需要存储在表里。典型情况，使用异常和不使用异常比，二进制文件大小会有约百分之十到二十的上升。LLVM 项目的编码规范里就明确指出这是不使用 RTTI 和异常的原因 [3]：</p>
<blockquote>
<p>In an effort to reduce code and executable size, LLVM does not use RTTI (e.g. dynamic_cast&lt;&gt;;) or exceptions.</p>
</blockquote>
<h4 id="6-4-异常的问题"><a href="#6-4-异常的问题" class="headerlink" title="6.4 异常的问题"></a>6.4 异常的问题</h4><p>异常当然不是一个完美的特性，否则也不会招来这些批评和禁用了。对它的批评主要有两条：</p>
<ul>
<li>异常违反了“你不用就不需要付出代价”的 C++ 原则。只要开启了异常，即使不使用异常你编译出的二进制代码通常也会膨胀。</li>
<li>异常比较隐蔽，不容易看出来哪些地方会发生异常和发生什么异常。</li>
</ul>
<p>对于第一条，开发者没有什么可做的。事实上，这也算是 C++ 实现的一个折中了。目前的主流异常实现中，都倾向于牺牲可执行文件大小、提高主流程（happy path）的性能。只要程序不抛异常，C++ 代码的性能比起完全不做错误检查的代码，都只有几个百分点的性能损失 [4]。除了非常有限的一些场景，可执行文件大小通常不会是个问题。</p>
<p>第二条可以算作是一个真正有效的批评。和 Java 不同，C++ 里不会对异常规约进行编译时的检查。从 C++17 开始，C++ 甚至完全禁止了以往的动态异常规约，你不再能在函数声明里写你可能会抛出某某异常。你唯一能声明的，就是某函数不会抛出异常—— noexcept、noexcept(true) 或 throw()。这也是 C++ 的运行时唯一会检查的东西了。如果一个函数声明了不会抛出异常、结果却抛出了异常，C++ 运行时会调用 std::terminate 来终止应用程序。不管是程序员的声明，还是编译器的检查，都不会告诉你哪些函数会抛出哪些异常。</p>
<p>当然，不声明异常是有理由的。特别是在泛型编程的代码里，几乎不可能预知会发生些什么异常。我个人对避免异常带来的问题有几点建议：</p>
<ol>
<li>写异常安全的代码，尤其在模板里。可能的话，提供强异常安全保证 [5]，在任何第三方代码发生异常的情况下，不改变对象的内容，也不产生任何资源泄漏。</li>
<li>如果你的代码可能抛出异常的话，在文档里明确声明可能发生的异常类型和发生条件。确保使用你的代码的人，能在不检查你的实现的情况，了解需要准备处理哪些异常。</li>
<li>对于肯定不会抛出异常的代码，将其标为 noexcept。注意类的特殊成员（构造函数、析构函数、赋值函数等）会自动成为 noexcept，如果它们调用的代码都是 noexcept 的话。所以，像 swap 这样的成员函数应当尽可能标成 noexcept。</li>
</ol>
<h4 id="6-5-使用异常的理由"><a href="#6-5-使用异常的理由" class="headerlink" title="6.5 使用异常的理由"></a>6.5 使用异常的理由</h4><p>虽然后面我们会描述到一些不使用异常、也不使用错误返回码的错误处理方式，但异常是渗透在 C++ 中的标准错误处理方式。标准库的错误处理方式就是异常。其中不仅包括运行时错误，甚至包括一些逻辑错误。比如，在说容器的时候，有一个我没提的地方是，在能使用 [] 运算符的地方，C++ 的标准容器也提供了 at 成员函数，能够在下标不存在的时候抛出异常，作为一种额外的帮助调试的手段。</p>
<p>C++ 的标准容器在大部分情况下提供了强异常保证，即，一旦异常发生，现场会恢复到调用函数之前的状态，容器的内容不会发生改变，也没有任何资源泄漏。前面提到过， vector 会在元素类型没有提供保证不抛异常的移动构造函数的情况下，在移动元素时会使用拷贝构造函数。这是因为一旦某个操作发生了异常，被移动的元素已经被破坏，处于只能析构的状态，异常安全性就不能得到保证了。</p>
<p>只要你使用了标准容器，不管你自己用不用异常，你都得处理标准容器可能引发的异常——至少有 bad_alloc，除非你明确知道你的目标运行环境不会产生这个异常。这对普通配置的 Linux 环境而言，倒确实是对的……这也算是 Google 这么规定的一个底气吧。</p>
<p>虽然对于运行时错误，开发者并没有什么选择余地；但对于代码中的逻辑错误，开发者则是可以选择不同的处理方式的：你可以使用异常，也可以使用 assert，在调试环境中报告错误并中断程序运行。由于测试通常不能覆盖所有的代码和分支，assert 在发布模式下一般被禁用，两者并不是完全的替代关系。在允许异常的情况下，使用异常可以获得在调试和发布模式下都良好、一致的效果。</p>
<p>标准 C++ 可能会产生哪些异常，可以查看参考资料 [6]。</p>
<h4 id="6-6-参考资料"><a href="#6-6-参考资料" class="headerlink" title="6.6 参考资料"></a>6.6 参考资料</h4><ol>
<li>Google, “Google C++ style guide”. <a target="_blank" rel="noopener" href="https://google.github.io/styleguide/cppguide.html#Exceptions">https://google.github.io/styleguide/cppguide.html#Exceptions</a></li>
<li>Reddit, Discussion on “Examples of C++ projects which embrace exceptions?”. <a target="_blank" rel="noopener" href="https://www.reddit.com/r/cpp/comments/4wkkge/examples_of_c_projects_which_embrace_exceptions/">https://www.reddit.com/r/cpp/comments/4wkkge/examples_of_c_projects_which_embrace_exceptions/</a></li>
<li>LLVM Project, “LLVM coding standards”. <a target="_blank" rel="noopener" href="https://llvm.org/docs/CodingStandards.html#do-not-use-rtti-or-exceptions">https://llvm.org/docs/CodingStandards.html#do-not-use-rtti-or-exceptions</a></li>
<li>Standard C++ Foundation, “FAQ—exceptions and error handling”. <a target="_blank" rel="noopener" href="https://isocpp.org/wiki/faq/exceptions">https://isocpp.org/wiki/faq/exceptions</a></li>
<li>cppreference.com, “Exceptions”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/exceptions">https://en.cppreference.com/w/cpp/language/exceptions</a></li>
<li>cppreference.com, “std::exception”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/error/exception">https://en.cppreference.com/w/cpp/error/exception</a></li>
</ol>
<h3 id="07-迭代器和好用的新for循环"><a href="#07-迭代器和好用的新for循环" class="headerlink" title="07 | 迭代器和好用的新for循环"></a>07 | 迭代器和好用的新for循环</h3><h4 id="7-1-什么是迭代器？"><a href="#7-1-什么是迭代器？" class="headerlink" title="7.1 什么是迭代器？"></a>7.1 什么是迭代器？</h4><p>迭代器是一个很通用的概念，并不是一个特定的类型。它实际上是一组对类型的要求（[1]）。它的最基本要求就是从一个端点出发，下一步、下一步地到达另一个端点。</p>
<p>我在用 output_container.h 输出容器内容的时候，实际上就对容器的 begin 和 end 成员函数返回的对象类型提出了要求。假设前者返回的类型是 I，后者返回的类型是 S，这些要求是：</p>
<ul>
<li>I 对象支持 <code>*</code> 操作，解引用取得容器内的某个对象。</li>
<li>I 对象支持 ++，指向下一个对象。</li>
<li>I 对象可以和 I 或 S 对象进行相等比较，判断是否遍历到了特定位置（在 S 的情况下是是否结束了遍历）。</li>
</ul>
<p>注意在 C++17 之前，begin 和 end 返回的类型 I 和 S 必须是相同的。从 C++17 开始，I 和 S 可以是不同的类型。</p>
<p>上面的类型 I，多多少少就是一个满足输入迭代器（input iterator）的类型了。不过， output_container.h 只使用了前置 ++，但输入迭代器要求前置和后置 ++ 都得到支持。</p>
<p>输入迭代器不要求对同一迭代器可以多次使用 <code>*</code> 运算符，也不要求可以保存迭代器来重新遍历对象，换句话说，只要求可以单次访问。如果取消这些限制、允许多次访问的话，那迭代器同时满足了前向迭代器（forward iterator）。</p>
<p>一个前向迭代器的类型，如果同时支持 —（前置及后置），回到前一个对象，那它就是个双向迭代器（bidirectional iterator）。也就是说，可以正向遍历，也可以反向遍历。</p>
<p>一个双向迭代器，如果额外支持在整数类型上的 +、-、+=、-=，跳跃式地移动迭代器；支持 []，数组式的下标访问；支持迭代器的大小比较（之前只要求相等比较）；那它就是个随机访问迭代器（random-access iterator）。</p>
<p>一个随机访问迭代器 i 和一个整数 n，在 <code>*i</code> 可解引用且 i + n 是合法迭代器的前提下，如果额外还满足 <code>*(addressdof(*i) + n)</code> 等价于 <code>*(i + n)</code>，即保证迭代器指向的对象在内存里是连续存放的，那它（在 C++20 里）就是个连续迭代器（contiguous iterator）。</p>
<p>以上这些迭代器只考虑了读取。如果一个类型像输入迭代器，但 <code>*i</code> 只能作为左值来写而不能读，那它就是个输出迭代器（output iterator）。</p>
<p>而比输入迭代器和输出迭代器更底层的概念，就是迭代器了。基本要求是：</p>
<ul>
<li>对象可以被拷贝构造、拷贝赋值和析构。</li>
<li>对象支持 * 运算符。</li>
<li>对象支持前置 ++ 运算符。</li>
</ul>
<p>迭代器类型的关系可从下图中全部看到：</p>
<p><img src="/images/《现代C++实战30讲》学习笔记/迭代器类型的关系.png" alt="迭代器类型的关系"></p>
<p>迭代器通常是对象。但需要注意的是，指针可以满足上面所有的迭代器要求，因而也是迭代器。这应该并不让人惊讶，因为本来迭代器就是根据指针的特性，对其进行抽象的结果。事实上，vector 的迭代器，在很多实现里就直接是使用指针的。</p>
<h4 id="7-2-常用迭代器"><a href="#7-2-常用迭代器" class="headerlink" title="7.2 常用迭代器"></a>7.2 常用迭代器</h4><p>最常用的迭代器就是容器的 iterator 类型了。一般而言，iterator 可写入，const_iterator 类型不可写入，但这些迭代器都被定义为输入迭代器或其派生类型：</p>
<ul>
<li>vector::iterator 和 array::iterator 可以满足到连续迭代器。</li>
<li>deque::iterator 可以满足到随机访问迭代器（记得它的内存只有部分连续）。</li>
<li>list::iterator 可以满足到双向迭代器（链表不能快速跳转）。</li>
<li>forward_list::iterator 可以满足到前向迭代器（单向链表不能反向遍历）。</li>
</ul>
<p>很常见的一个输出迭代器是 back_inserter 返回的类型 back_inserter_iterator 了；用它我们可以很方便地在容器的尾部进行插入操作。另外一个常见的输出迭代器是 ostream_iterator，方便我们把容器内容“拷贝”到一个输出流。</p>
<h4 id="7-3-使用输入行迭代器"><a href="#7-3-使用输入行迭代器" class="headerlink" title="7.3 使用输入行迭代器"></a>7.3 使用输入行迭代器</h4><p>下面我们来看一下一个我写的输入迭代器。它的功能本身很简单，就是把一个输入流（istream）的内容一行行读进来。配上 C++11 引入的基于范围的 for 循环的语法，我们可以把遍历输入流的代码以一种自然、非过程式的方式写出来，如下所示：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> line <span class="token operator">:</span> <span class="token function">istream_line_reader</span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 示例循环体中仅进行简单输出</span>
    cout <span class="token operator">&lt;&lt;</span> line <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们可以对比一下以传统的方式写的 C++ 代码，其中需要照顾不少细节：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string line<span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">getline</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>is<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> line <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们后面会分析一下这个输入迭代器。在此之前，我先解说一下基于范围的 for 循环这个语法。虽然这可以说是个语法糖，但它对提高代码的可读性真的非常重要。如果不用这个语法糖的话，简洁性上的优势就小多了。我们直接把这个循环改写成等价的普通 for 循环的样子。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">{</span>
    <span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> r <span class="token operator">=</span> <span class="token function">istream_line_reader</span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> it <span class="token operator">=</span> r<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> end <span class="token operator">=</span> r<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> end<span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> string<span class="token operator">&amp;</span> line <span class="token operator">=</span> <span class="token operator">*</span>it<span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> line <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到，它做的事情也不复杂，就是：</p>
<ul>
<li>获取冒号后边的范围表达式的结果，并隐式产生一个引用，在整个循环期间都有效。注意根据生命期延长规则，表达式结果如果是临时对象的话，这个对象要在循环结束后才被销毁。</li>
<li>自动生成遍历这个范围的迭代器。</li>
<li>循环内自动生成根据冒号左边的声明和 *it 来进行初始化的语句。</li>
<li>下面就是完全正常的循环体。</li>
</ul>
<p>生成迭代器这一步有可能是——但不一定是——调用 r 的 begin 和 end 成员函数。具体规则是：</p>
<ul>
<li>对于 C 数组（必须是没有退化为指针的情况），编译器会自动生成指向数组头尾的指针（相当于自动应用可用于数组的 std::begin 和 std::end 函数）。</li>
<li>对于有 begin 和 end 成员的对象，编译器会调用其 begin 和 end 成员函数（我们目前的情况）。</li>
<li>否则，编译器会尝试在 r 对象所在的名空间寻找可以用于 r 的 begin 和 end 函数，并</li>
<li>调用 begin(r) 和 end(r)；找不到的话则失败报错。</li>
</ul>
<h4 id="7-4-定义输入行迭代器"><a href="#7-4-定义输入行迭代器" class="headerlink" title="7.4 定义输入行迭代器"></a>7.4 定义输入行迭代器</h4><p>C++ 里有些固定的类型要求规范。对于一个迭代器，我们需要定义下面的类型：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">istream_line_reader</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">class</span> <span class="token class-name">iterator</span> <span class="token punctuation">{</span> <span class="token comment">// 实现 InputIterator</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token keyword">typedef</span> ptrdiff_t difference_type<span class="token punctuation">;</span>
        <span class="token keyword">typedef</span> string value_type<span class="token punctuation">;</span>
        <span class="token keyword">typedef</span> <span class="token keyword">const</span> value_type<span class="token operator">*</span> pointer<span class="token punctuation">;</span>
        <span class="token keyword">typedef</span> <span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> reference<span class="token punctuation">;</span>
        <span class="token keyword">typedef</span> input_iterator_tag iterator_category<span class="token punctuation">;</span>
        <span class="token comment">// …</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">// …</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>仿照一般的容器，我们把迭代器定义为 istream_line_reader 的嵌套类。它里面的这五个类型是必须定义的（其他泛型 C++ 代码可能会用到这五个类型；之前标准库定义了一个可以继承的类模板 std::iterator 来产生这些类型定义，但这个类目前已经被废弃[2]）。其中：</p>
<ul>
<li>difference_type 是代表迭代器之间距离的类型，定义为 ptrdiff_t 只是种标准做法（指针间差值的类型），对这个类型没什么特别作用。</li>
<li>value_type 是迭代器指向的对象的值类型，我们使用 string，表示迭代器指向的是字符串。</li>
<li>pointer 是迭代器指向的对象的指针类型，这儿就平淡无奇地定义为 value_type 的常指针了（我们可不希望别人来更改指针指向的内容）。类似的，reference 是 value_type 的常引用。</li>
<li>iterator_category 被定义为 input_iterator_tag，标识这个迭代器的类型是</li>
<li>input iterator（输入迭代器）。</li>
</ul>
<p>作为一个真的只能读一次的输入迭代器，有个特殊的麻烦（前向迭代器或其衍生类型没有）：到底应该让 <code>*</code> 负责读取还是 ++ 负责读取。我们这儿采用常见、也较为简单的做法，让 ++ 负责读取，<code>*</code> 负责返回读取的内容（这个做法会有些副作用，但按我们目前的用法则没有问题）。这样的话，这个 iterator 类需要有一个数据成员指向输入流，一个数据成员来存放读取的结果。根据这个思路，我们定义这个类的基本成员函数和数据成员：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">istream_line_reader</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">class</span> <span class="token class-name">iterator</span> <span class="token punctuation">{</span>
        <span class="token comment">//…</span>
        <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span>
            <span class="token operator">:</span> <span class="token function">stream_</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">explicit</span> <span class="token function">iterator</span><span class="token punctuation">(</span>istream<span class="token operator">&amp;</span> is<span class="token punctuation">)</span>
            <span class="token operator">:</span> <span class="token function">stream_</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>is<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token operator">++</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        reference <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">return</span> line_<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        pointer <span class="token keyword">operator</span><span class="token operator">-&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token operator">&amp;</span>line_<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        iterator<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token function">getline</span><span class="token punctuation">(</span><span class="token operator">*</span>stream_<span class="token punctuation">,</span> line_<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">*</span>stream_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                stream_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        iterator <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            iterator <span class="token function">temp</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">++</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> temp<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
        istream<span class="token operator">*</span> stream_<span class="token punctuation">;</span>
        string line_<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">//…</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们定义了默认构造函数，将 <code>stream_</code> 清空；相应的，在带参数的构造函数里，我们根据传入的输入流来设置 <code>stream_</code>。我们也定义了 <code>*</code> 和 -&gt; 运算符来取得迭代器指向的文本行的引用和指针，并用 ++ 来读取输入流的内容（后置 ++ 则以惯常方式使用前置 ++ 和拷贝构造来实现）。唯一“特别”点的地方，是我们在构造函数里调用了 ++，确保在构造后调用 <code>*</code> 运算符时可以读取内容，符合日常先使用 <code>*</code>、再使用 ++ 的习惯。一旦文件读取到尾部（或出错），则 <code>stream_</code> 被清空，回到默认构造的情况。</p>
<p>对于迭代器之间的比较，我们则主要考虑文件有没有读到尾部的情况，简单定义为：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> iterator<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> stream_ <span class="token operator">==</span> rhs<span class="token punctuation">.</span>stream_<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">!=</span><span class="token punctuation">(</span><span class="token keyword">const</span> iterator<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>有了这个 iterator 的定义后，istream_line_reader 的定义就简单得很了：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">istream_line_reader</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">class</span> <span class="token class-name">iterator</span> <span class="token punctuation">{</span>
        <span class="token comment">//…</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">istream_line_reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span>
        <span class="token operator">:</span> <span class="token function">stream_</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">explicit</span> <span class="token function">istream_line_reader</span><span class="token punctuation">(</span>istream<span class="token operator">&amp;</span> is<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>
        <span class="token operator">:</span> <span class="token function">stream_</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>is<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    iterator <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token operator">*</span>stream_<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    iterator <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    istream<span class="token operator">*</span> stream_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也就是说，构造函数只是简单地把输入流的指针赋给 stream_ 成员变量。begin 成员函数则负责构造一个真正有意义的迭代器；end 成员函数则只是返回一个默认构造的迭代器而已。</p>
<p>以上就是一个完整的基于输入流的行迭代器了。这个行输入模板的设计动机和性能测试结果可参见参考资料 [3] 和 [4]；完整的工程可用代码，请参见参考资料 [5]。该项目中还提供了利用 C 文件接口的 file_line_reader 和基于内存映射文件的 mmap_line_reader。</p>
<h4 id="7-5-参考资料"><a href="#7-5-参考资料" class="headerlink" title="7.5 参考资料"></a>7.5 参考资料</h4><ol>
<li>cppreference.com, “Iterator library”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/iterator">https://en.cppreference.com/w/cpp/iterator</a></li>
<li>Jonathan Boccara, “std::iterator is deprecated: why, what it was, and what to use instead”. <a target="_blank" rel="noopener" href="https://www.fluentcpp.com/2018/05/08/std-iterator-deprecated/">https://www.fluentcpp.com/2018/05/08/std-iterator-deprecated/</a></li>
<li>吴咏炜, “Python yield and C++ coroutines”. <a target="_blank" rel="noopener" href="https://yongweiwu.wordpress.com/2016/08/16/python-yield-and-cpluspluscoroutines/">https://yongweiwu.wordpress.com/2016/08/16/python-yield-and-cpluspluscoroutines/</a></li>
<li>吴咏炜, “Performance of my line readers”. <a target="_blank" rel="noopener" href="https://yongweiwu.wordpress.com/2016/11/12/performance-of-my-line-readers/">https://yongweiwu.wordpress.com/2016/11/12/performance-of-my-line-readers/</a></li>
<li>吴咏炜, nvwa. <a target="_blank" rel="noopener" href="https://github.com/adah1972/nvwa/">https://github.com/adah1972/nvwa/</a></li>
</ol>
<h3 id="08-易用性改进-I：自动类型推断和初始化"><a href="#08-易用性改进-I：自动类型推断和初始化" class="headerlink" title="08 | 易用性改进 I：自动类型推断和初始化"></a>08 | 易用性改进 I：自动类型推断和初始化</h3><h4 id="8-1-自动类型推断"><a href="#8-1-自动类型推断" class="headerlink" title="8.1 自动类型推断"></a>8.1 自动类型推断</h4><ol>
<li><p>auto</p>
<p> 自动类型推断，顾名思义，就是编译器能够根据表达式的类型，自动决定变量的类型（从 C++14 开始，还有函数的返回类型），不再需要程序员手工声明（[1]）。但需要说明的是，auto 并没有改变 C++ 是静态类型语言这一事实——使用 auto 的变量（或函数返回值）的类型仍然是编译时就确定了，只不过编译器能自动帮你填充而已。</p>
<p> auto 实际使用的规则类似于函数模板参数的推导规则（[3]）。当你写了一个含 auto 的表达式时，相当于把 auto 替换为模板参数的结果。举具体的例子：</p>
<ul>
<li>auto a = expr; 意味着用 expr 去匹配一个假想的 <code>template &lt;typename T&gt; f(T)</code> 函数模板，结果为值类型。</li>
<li>const auto&amp; a = expr; 意味着用 expr 去匹配一个假想的 <code>template &lt;typename T&gt; f(const T&amp;)</code> 函数模板，结果为常左值引用类型。</li>
<li>auto&amp;&amp; a = expr; 意味着用 expr 去匹配一个假想的 <code>template &lt;typename T&gt; f(T&amp;&amp;)</code> 函数模板，根据 <strong>[第 3 讲]</strong> 中我们讨论过的转发引用和引用坍缩规则，结果是一个跟 expr 值类别相同的引用类型。</li>
</ul>
</li>
<li><p>decltype</p>
<p> decltype 的用途是获得一个表达式的类型，结果可以跟类型一样使用。它有两个基本用法：</p>
<ul>
<li>decltype(变量名) 可以获得变量的精确类型。</li>
<li><p>decltype(表达式) （表达式不是变量名，但包括 decltype((变量名)) 的情况）可以获得表达式的引用类型；除非表达式的结果是个纯右值（prvalue），此时结果仍然是值类型。</p>
<p>如果我们有 int a;，那么：</p>
</li>
<li><p>decltype(a) 会获得 int（因为 a 是 int）。</p>
</li>
<li>decltype((a)) 会获得 int&amp;（因为 a 是 lvalue）。</li>
<li>decltype(a + a) 会获得 int（因为 a + a 是 prvalue）。</li>
</ul>
</li>
<li><p>decltype(auto)</p>
<p> 通常情况下，能写 auto 来声明变量肯定是件比较轻松的事。但这儿有个限制，你需要在写下 auto 时就决定你写下的是个引用类型还是值类型。根据类型推导规则，auto 是值类型，auto&amp; 是左值引用类型，auto&amp;&amp; 是转发引用（可以是左值引用，也可以是右值引用）。使用 auto 不能通用地根据表达式类型来决定返回值的类型。不过， decltype(expr) 既可以是值类型，也可以是引用类型。因此，我们可以这么写：</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">decltype</span><span class="token punctuation">(</span>expr<span class="token punctuation">)</span> a <span class="token operator">=</span> expr<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 这种写法明显不能让人满意，特别是表达式很长的情况（而且，任何代码重复都是潜在的问题）。为此，C++14 引入了 decltype(auto) 语法。对于上面的情况，我们只需要像下面这样写就行了。</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> a <span class="token operator">=</span> expr<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="8-2-函数返回值类型推断"><a href="#8-2-函数返回值类型推断" class="headerlink" title="8.2 函数返回值类型推断"></a>8.2 函数返回值类型推断</h4></li>
</ol>
<p>从 C++14 开始，函数的返回值也可以用 auto 或 decltype(auto) 来声明了。同样的，用 auto 可以得到值类型，用 auto&amp; 或 auto&amp;&amp; 可以得到引用类型；而用 decltype(auto) 可以根据返回表达式通用地决定返回的是值类型还是引用类型。</p>
<p>和这个形式相关的有另外一个语法，后置返回值类型声明。严格来说，这不算“类型推断”，不过我们也放在一起讲吧。它的形式是这个样子：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> <span class="token function">foo</span><span class="token punctuation">(</span>参数<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> 返回值类型声明
<span class="token punctuation">{</span>
    <span class="token comment">// 函数体</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>通常，在返回类型比较复杂、特别是返回类型跟参数类型有某种推导关系时会使用这种语法。以后我们会讲到一些实例。今天暂时不多讲了。</p>
<h4 id="8-3-类模板的模板参数推导"><a href="#8-3-类模板的模板参数推导" class="headerlink" title="8.3 类模板的模板参数推导"></a>8.3 类模板的模板参数推导</h4><p>如果你用过 pair 的话，一般都不会使用下面这种形式：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> pr<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>使用 make_pair 显然更容易一些：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> pr <span class="token operator">=</span> <span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这是因为函数模板有模板参数推导，使得调用者不必手工指定参数类型；但 C++17 之前的类模板却没有这个功能，也因而催生了像 make_pair 这样的工具函数。</p>
<p>在进入了 C++17 的世界后，这类函数变得不必要了。现在我们可以直接写：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">pair pr<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在初次见到 array 时，我觉得它的主要缺点就是不能像 C 数组一样自动从初始化列表来推断数组的大小了：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">&gt;</span> a2<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 啰嗦</span>
<span class="token comment">// array&lt;int&gt; a3{1, 2, 3}; 不行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这个问题在 C++17 里也是基本不存在的。虽然不能只提供一个模板参数，但你可以两个参数全都不写：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">array a<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 得到 array&lt;int, 3&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这种自动推导机制，可以是编译器根据构造函数来自动生成：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">MyObj</span> <span class="token punctuation">{</span>
    <span class="token function">MyObj</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//…</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

MyObj obj1 <span class="token punctuation">{</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 得到 MyObj&lt;string&gt;</span>
MyObj obj2 <span class="token punctuation">{</span> <span class="token string">"hello"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 得到 MyObj&lt;const char*&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以是手工提供一个推导向导，达到自己需要的效果：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">MyObj</span> <span class="token punctuation">{</span>
    <span class="token function">MyObj</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//…</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">MyObj</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> MyObj<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token punctuation">;</span>

MyObj obj1 <span class="token punctuation">{</span> <span class="token string">"hello"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 得到 MyObj&lt;string&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>更多的技术细节请参见参考资料 [4]。</p>
<h4 id="8-4-结构化绑定"><a href="#8-4-结构化绑定" class="headerlink" title="8.4 结构化绑定"></a>8.4 结构化绑定</h4><p>一个例子：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">multimap<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">::</span>iterator lower<span class="token punctuation">,</span> upper<span class="token punctuation">;</span>
std<span class="token operator">::</span><span class="token function">tie</span><span class="token punctuation">(</span>lower<span class="token punctuation">,</span> upper<span class="token punctuation">)</span> <span class="token operator">=</span> mmp<span class="token punctuation">.</span><span class="token function">equal_range</span><span class="token punctuation">(</span><span class="token string">"four"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这个例子里，返回值是个 pair，我们希望用两个变量来接收数值，就不得不声明了两个变量，然后使用 tie 来接收结果。在 C++11/14 里，这里是没法使用 auto 的。好在 C++17 引入了一个新语法，解决了这个问题。目前，我们可以把上面的代码简化为：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> <span class="token punctuation">[</span>lower<span class="token punctuation">,</span> upper<span class="token punctuation">]</span> <span class="token operator">=</span> mmp<span class="token punctuation">.</span><span class="token function">equal_range</span><span class="token punctuation">(</span><span class="token string">"four"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个语法使得我们可以用 auto 声明变量来分别获取 pair 或 tuple 返回值里各个子项，可以让代码的可读性更好。</p>
<p>关于这个语法的更多技术说明，请参见参考资料 [5]。</p>
<h4 id="8-5-列表初始化"><a href="#8-5-列表初始化" class="headerlink" title="8.5 列表初始化"></a>8.5 列表初始化</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这不是对标准库容器的特殊魔法，而是一个通用的、可以用于各种类的方法。从技术角度，编译器的魔法只是对 {1, 2, 3} 这样的表达式自动生成一个初始化列表，在这个例子里其类型是 initializer_list<int>。程序员只需要声明一个接受 initializer_list 的构造函数即可使用。从效率的角度，至少在动态对象的情况下，容器和数组也并无二致，都是通过拷贝（构造）进行初始化。</int></p>
<p>对于初始化列表在构造函数外的用法和更多的技术细节，请参见参考资料 [6]。</p>
<h4 id="8-6-统一初始化"><a href="#8-6-统一初始化" class="headerlink" title="8.6 统一初始化"></a>8.6 统一初始化</h4><p>你可能已经注意到了，我在代码里使用了大括号 {} 来进行对象的初始化。这当然也是 C++11 引入的新语法，能够代替很多小括号 () 在变量初始化时使用。这被称为统一初始化（uniform initialization）。</p>
<p>大括号对于构造一个对象而言，最大的好处是避免了 C++ 里“最令人恼火的语法分析”（the most vexing parse）。我也遇到过。假设你有一个类，原型如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">utf8_to_wstring</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">utf8_to_wstring</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">operator</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后你在 Windows 下想使用这个类来帮助转换文件名，打开文件：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ifstream <span class="token function">ifs</span><span class="token punctuation">(</span><span class="token function">utf8_to_wstring</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>上面这个写法会被编译器认为是和下面的写法等价的：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ifstream <span class="token function">ifs</span><span class="token punctuation">(</span>utf8_to_wstring filename<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>换句话说，编译器认为你是声明了一个叫 ifs 的函数，而不是对象！</p>
<p>如果你把任何一对小括号替换成大括号（或者都替换，如下），则可以避免此类问题：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ifstream ifs<span class="token punctuation">{</span>utf8_to_wstring<span class="token punctuation">{</span>filename<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>推而广之，你几乎可以在所有初始化对象的地方使用大括号而不是小括号。它还有一个附带的特点：当一个构造函数没有标成 explicit 时，你可以使用大括号不写类名来进行构造，如果调用上下文要求那类对象的话。如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Obj <span class="token function">getObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token number">1.0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果 Obj 类可以使用浮点数进行构造的话，上面的写法就是合法的。如果有无参数、多参数的构造函数，也可以使用这个形式。除了形式上的区别，它跟 Obj(1.0) 的主要区别是，后者可以用来调用 Obj(int)，而使用大括号时编译器会拒绝“窄”转换，不接受以 {1.0} 或 Obj{1.0} 的形式调用构造函数 Obj(int)。</p>
<p>这个语法主要的限制是，如果一个构造函数既有使用初始化列表的构造函数，又有不使用初始化列表的构造函数，那编译器会千方百计地试图调用使用初始化列表的构造函数，导致各种意外。所以，如果给一个推荐的话，那就是：</p>
<ul>
<li>如果一个类没有使用初始化列表的构造函数时，初始化该类对象可全部使用统一初始化语法。</li>
<li>如果一个类有使用初始化列表的构造函数时，则只应用在初始化列表构造的情况。</li>
</ul>
<p>关于这个语法的更多详细用法讨论，请参见参考资料 [7]。</p>
<h4 id="8-7-类数据成员的默认初始化"><a href="#8-7-类数据成员的默认初始化" class="headerlink" title="8.7 类数据成员的默认初始化"></a>8.7 类数据成员的默认初始化</h4><p>按照 C++98 的语法，数据成员可以在构造函数里进行初始化。这本身不是问题，但实践中，如果数据成员比较多、构造函数又有多个的话，逐个去初始化是个累赘，并且很容易在增加数据成员时漏掉在某个构造函数中进行初始化。为此，C++11 增加了一个语法，允许在声明数据成员时直接给予一个初始化表达式。这样，当且仅当构造函数的初始化列表中不包含该数据成员时，这个数据成员就会自动使用初始化表达式进行初始化。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Complex</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Complex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
    <span class="token function">Complex</span><span class="token punctuation">(</span><span class="token keyword">float</span> re<span class="token punctuation">)</span>
        <span class="token operator">:</span> <span class="token function">re_</span><span class="token punctuation">(</span>re<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    <span class="token function">Complex</span><span class="token punctuation">(</span><span class="token keyword">float</span> re<span class="token punctuation">,</span> <span class="token keyword">float</span> im<span class="token punctuation">)</span>
        <span class="token operator">:</span> <span class="token function">re_</span><span class="token punctuation">(</span>re<span class="token punctuation">)</span>
        <span class="token punctuation">,</span> <span class="token function">im_</span><span class="token punctuation">(</span>im<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">float</span> re_ <span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> im_ <span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="8-8-参考资料"><a href="#8-8-参考资料" class="headerlink" title="8.8 参考资料"></a>8.8 参考资料</h4><ol>
<li>cppreference.com, “Placeholder type specifiers”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/auto">https://en.cppreference.com/w/cpp/language/auto</a></li>
<li>Wikipedia, “Argument-dependent name lookup”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Argument-dependent_name_lookup">https://en.wikipedia.org/wiki/Argument-dependent_name_lookup</a></li>
<li>cppreference.com, “Template argument deduction”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/template_argument_deduction">https://en.cppreference.com/w/cpp/language/template_argument_deduction</a></li>
<li>cppreference.com, “Class template argument deduction”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction">https://en.cppreference.com/w/cpp/language/class_template_argument_deduction</a></li>
<li>cppreference.com, “Structured binding declaration”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/structured_binding">https://en.cppreference.com/w/cpp/language/structured_binding</a></li>
<li>cppreference.com, “std::initializer_list”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/utility/initializer_list">https://en.cppreference.com/w/cpp/utility/initializer_list</a></li>
<li>Scott Meyers,Effective Modern C++, item 7. O’Reilly Media, 2014. 有中文版（高博译，中国电力出版社，2018 年）</li>
</ol>
<h3 id="09-易用性改进-II：字面量、静态断言和成员函数说明符"><a href="#09-易用性改进-II：字面量、静态断言和成员函数说明符" class="headerlink" title="09 | 易用性改进 II：字面量、静态断言和成员函数说明符"></a>09 | 易用性改进 II：字面量、静态断言和成员函数说明符</h3><h4 id="9-1-自定义字面量"><a href="#9-1-自定义字面量" class="headerlink" title="9.1 自定义字面量"></a>9.1 自定义字面量</h4><p>字面量（literal）是指在源代码中写出的固定常量，它们在 C++98 里只能是原生类型，如：</p>
<ul>
<li>“hello”，字符串字面量，类型是 const char[6]</li>
<li>1，整数字面量，类型是 int</li>
<li>0.0，浮点数字面量，类型是 double</li>
<li>3.14f，浮点数字面量，类型是 float</li>
<li>123456789ul，无符号长整数字面量，类型是 unsigned long</li>
</ul>
<p>C++11 引入了自定义字面量，可以使用 operator”” 后缀 来将用户提供的字面量转换成实际的类型。C++14 则在标准库中加入了不少标准字面量。下面这个程序展示了它们的用法：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;chrono&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;complex&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"i * i = "</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span>i <span class="token operator">*</span> <span class="token number">1</span>i
         <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Waiting for 500ms"</span>
         <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span><span class="token number">500</span>ms<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello world"</span>s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
         <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面这个例子展示了 C++ 标准里提供的帮助生成虚数、时间和 basic_string 字面量的后缀。一个需要注意的地方是，我在上面使用了 using namespace std，这会同时引入 std 名空间和里面的内联名空间（inline namespace），包括了上面的字面量运算符所在的三个名空间：</p>
<ul>
<li>std::literals::complex_literals</li>
<li>std::literals::chrono_literals</li>
<li>std::literals::string_literals</li>
</ul>
<p>在产品项目中，一般不会（也不应该）全局使用 using namespace std（不过，为节约篇幅起见，专栏里的很多例子，特别是不完整的例子，还是默认使用了 using namespace std）。这种情况下，应当在使用到这些字面量的作用域里导入需要的名空间，以免发生冲突。在类似上面的例子里，就是在函数体的开头写：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token operator">::</span>literals<span class="token operator">::</span>chrono_literals<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>等等。</p>
<p>要在自己的类里支持字面量也相当容易，唯一的限制是非标准的字面量后缀必须以下划线 <code>_</code> 打头。比如，假如我们有下面的长度类：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">length</span> <span class="token punctuation">{</span>
    <span class="token keyword">double</span> value<span class="token punctuation">;</span>
    <span class="token keyword">enum</span> <span class="token class-name">unit</span> <span class="token punctuation">{</span>
        metre<span class="token punctuation">,</span>
        kilometre<span class="token punctuation">,</span>
        millimetre<span class="token punctuation">,</span>
        centimetre<span class="token punctuation">,</span>
        inch<span class="token punctuation">,</span>
        foot<span class="token punctuation">,</span>
        yard<span class="token punctuation">,</span>
        mile<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> <span class="token keyword">double</span> factors<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1000.0</span><span class="token punctuation">,</span> <span class="token number">1e-3</span><span class="token punctuation">,</span>
        <span class="token number">1e-2</span><span class="token punctuation">,</span> <span class="token number">0.0254</span><span class="token punctuation">,</span> <span class="token number">0.3048</span><span class="token punctuation">,</span>
        <span class="token number">0.9144</span><span class="token punctuation">,</span> <span class="token number">1609.344</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">explicit</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token keyword">double</span> v<span class="token punctuation">,</span> unit u <span class="token operator">=</span> metre<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        value <span class="token operator">=</span> v <span class="token operator">*</span> factors<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
length <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span>length lhs<span class="token punctuation">,</span> length rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">length</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>value <span class="token operator">+</span> rhs<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 可能有其他运算符</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们可以手写 length(1.0, length::metre) 这样的表达式，但估计大部分开发人员都不愿意这么做吧。反过来，如果我们让开发人员这么写，大家应该还是基本乐意的：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token number">1.0</span>_m <span class="token operator">+</span> <span class="token number">10.0</span>_cm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>要允许上面这个表达式，我们只需要提供下面的运算符即可：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">length <span class="token keyword">operator</span><span class="token string">""</span> <span class="token function">_m</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">double</span> v<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">length</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> length<span class="token operator">::</span>metre<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
length <span class="token keyword">operator</span><span class="token string">""</span> <span class="token function">_cm</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">double</span> v<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">length</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> length<span class="token operator">::</span>centimetre<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>关于自定义字面量的进一步技术细节，请参阅参考资料 [2]。</p>
<h4 id="9-2-二进制字面量"><a href="#9-2-二进制字面量" class="headerlink" title="9.2 二进制字面量"></a>9.2 二进制字面量</h4><p>C++ 里有 0x 前缀，可以让开发人员直接写出像 0xFF 这样的十六进制字面量。另外一个目前使用得稍少的前缀就是 0 后面直接跟 0–7 的数字，表示八进制的字面量，在跟文件系统打交道的时候还会经常用到：有经验的 Unix 程序员可能会觉得 chmod(path, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH) 并不比 chmod(path, 0644) 更为直观。从 C++14 开始，我们对于二进制也有了直接的字面量：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">unsigned</span> mask <span class="token operator">=</span> <span class="token number">0b111000000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>遗憾的是， I/O streams 里只有 dec、hex、oct 三个操纵器（manipulator），而没有 bin，因而输出一个二进制数不能像十进制、十六进制、八进制那么直接。一个间接方式是使用 bitset，但调用者需要手工指定二进制位数：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bitset&gt;</span></span>
cout <span class="token operator">&lt;&lt;</span> bitset<span class="token operator">&lt;</span><span class="token number">9</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>mask<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 111000000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h4 id="9-3-数字分隔符"><a href="#9-3-数字分隔符" class="headerlink" title="9.3 数字分隔符"></a>9.3 数字分隔符</h4><p>C++14 开始，允许在数字型字面量中任意添加 ‘ 来使其更可读。具体怎么添加，完全由程序员根据实际情况进行约定。某些常见的情况可能会是：</p>
<ul>
<li>十进制数字使用三位的分隔，对应英文习惯的 thousand、million 等单位。</li>
<li>十进制数字使用四位的分隔，对应中文习惯的万、亿等单位。</li>
<li>十六进制数字使用两位或四位的分隔，对应字节或双字节。</li>
<li>二进制数字使用三位的分隔，对应文件系统的权限分组。</li>
<li>等等。</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">unsigned</span> mask <span class="token operator">=</span> <span class="token number">0b111'000'000</span><span class="token punctuation">;</span>
<span class="token keyword">long</span> r_earth_equatorial <span class="token operator">=</span> <span class="token number">6'378'137</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> pi <span class="token operator">=</span> <span class="token number">3.14159'26535'89793</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">unsigned</span> magic <span class="token operator">=</span> <span class="token number">0x44'42'47'4E</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="9-4-静态断言"><a href="#9-4-静态断言" class="headerlink" title="9.4 静态断言"></a>9.4 静态断言</h4><p>C++11 直接从语言层面提供了静态断言机制，不仅能输出更好的信息，而且适用性也更好，可以直接放在类的定义中。</p>
<p>静态断言语法上非常简单，就是：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static_assert</span><span class="token punctuation">(</span>编译期条件表达式<span class="token punctuation">,</span> 可选输出信息<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="9-5-default-和-delete-成员函数"><a href="#9-5-default-和-delete-成员函数" class="headerlink" title="9.5 default 和 delete 成员函数"></a>9.5 default 和 delete 成员函数</h4><p>在类的定义时，C++ 有一些规则决定是否生成默认的特殊成员函数。这些特殊成员函数可能包括：</p>
<ul>
<li>默认构造函数</li>
<li>析构函数</li>
<li>拷贝构造函数</li>
<li>拷贝赋值函数</li>
<li>移动构造函数</li>
<li>移动赋值函数</li>
</ul>
<p>生成这些特殊成员函数（或不生成）的规则比较复杂，感兴趣的话你可以查看参考资料[3]。每个特殊成员函数有几种不同的状态：</p>
<ul>
<li>隐式声明还是用户声明</li>
<li>默认提供还是用户提供</li>
<li>正常状态还是删除状态</li>
</ul>
<p>这三个状态是可组合的，虽然不是所有的组合都有效。隐式声明的必然是默认提供的；默认提供的才可能被删除；用户提供的也必然是用户声明的。</p>
<p>如果成员和父类没有特殊原因导致对象不可拷贝或移动，在用户不声明这些成员函数的情况下，编译器会自动产生这些成员函数，即隐式声明、默认提供、正常状态。有特殊成员、用户声明的话，情况就非常复杂了：</p>
<ul>
<li>没有初始化的非静态 const 数据成员和引用类型数据成员会导致默认提供的默认构造函数被删除。</li>
<li>非静态的 const 数据成员和引用类型数据成员会导致默认提供的拷贝构造函数、拷贝赋值函数、移动构造函数和移动赋值函数被删除。</li>
<li>用户如果没有自己提供一个拷贝构造函数（必须形如 Obj(Obj&amp;) 或 Obj(const Obj&amp;)；不是模板），编译器会隐式声明一个。</li>
<li>用户如果没有自己提供一个拷贝赋值函数（必须形如 Obj&amp; operator=(Obj&amp;) 或 Obj&amp; operator=(const Obj&amp;)；不是模板），编译器会隐式声明一个。</li>
<li>用户如果自己声明了一个移动构造函数或移动赋值函数，则默认提供的拷贝构造函数和拷贝赋值函数被删除。</li>
<li>用户如果没有自己声明拷贝构造函数、拷贝赋值函数、移动赋值函数和析构函数，编译器会隐式声明一个移动构造函数。</li>
<li>用户如果没有自己声明拷贝构造函数、拷贝赋值函数、移动构造函数和析构函数，编译器会隐式声明一个移动赋值函数。</li>
<li>……</li>
</ul>
<p>我不鼓励你去死记硬背这些规则，而是希望你在项目和测试中体会其缘由。我认为这些规则还相当合理，虽然有略偏保守之嫌。尤其是关于移动构造和赋值：<strong>只要用户声明了另外的特殊成员函数中的任何一个，编译器就不默认提供了</strong>。不过嘛，缺省慢点总比缺省不安全要好……</p>
<p>我们这儿主要要说的是，我们可以改变缺省行为，在编译器能默认提供特殊成员函数时将其删除，或在编译器不默认提供特殊成员函数时明确声明其需要默认提供（不过，要注意，即使用户要求默认提供，编译器也可能根据其他规则将特殊成员函数标为删除）。</p>
<p>另外注意一下，用户将构造函数声明成删除也是一种声明，因此编译器不会提供默认版本的移动构造和移动赋值函数。</p>
<h4 id="9-6-override-和-final-说明符"><a href="#9-6-override-和-final-说明符" class="headerlink" title="9.6 override 和 final 说明符"></a>9.6 override 和 final 说明符</h4><p>override 和 final 是两个 C++11 引入的新说明符。它们不是关键词，仅在出现在函数声明尾部时起作用，不影响我们使用这两个词作变量名等其他用途。这两个说明符可以单个或组合使用，都是加在类成员函数声明的尾部。</p>
<p>override 显式声明了成员函数是一个虚函数且覆盖了基类中的该函数。如果有 override 声明的函数不是虚函数，或基类中不存在这个虚函数，编译器会报告错误。这个说明符的主要作用有两个：</p>
<ul>
<li>给开发人员更明确的提示，这个函数覆写了基类的成员函数；</li>
<li>让编译器进行额外的检查，防止程序员由于拼写错误或代码改动没有让基类和派生类中的成员函数名称完全一致。</li>
</ul>
<p>final 则声明了成员函数是一个虚函数，且该虚函数不可在派生类中被覆盖。如果有一点没有得到满足的话，编译器就会报错。</p>
<p>final 还有一个作用是标志某个类或结构不可被派生。同样，这时应将其放在被定义的类或结构名后面。</p>
<h4 id="9-7-参考资料"><a href="#9-7-参考资料" class="headerlink" title="9.7 参考资料"></a>9.7 参考资料</h4><ol>
<li>Wikipedia, “Mars Climate Orbiter”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Mars_Climate_Orbiter">https://en.wikipedia.org/wiki/Mars_Climate_Orbiter</a></li>
<li>cppreference.com, “User-defined literals”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/user_literal">https://en.cppreference.com/w/cpp/language/user_literal</a></li>
<li>cppreference.com, “Non-static member functions”, section “Special member functions”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/member_functions">https://en.cppreference.com/w/cpp/language/member_functions</a></li>
</ol>
<h2 id="02丨提高篇"><a href="#02丨提高篇" class="headerlink" title="02丨提高篇"></a>02丨提高篇</h2><h3 id="10-到底应不应该返回对象？"><a href="#10-到底应不应该返回对象？" class="headerlink" title="10 | 到底应不应该返回对象？"></a>10 | 到底应不应该返回对象？</h3><h4 id="10-1-F-20"><a href="#10-1-F-20" class="headerlink" title="10.1 F.20"></a>10.1 F.20</h4><p>《C++ 核心指南》的 F.20 这一条款是这么说的 [1]：</p>
<blockquote>
<p>F.20: For “out” output values, prefer return values to output parameters</p>
</blockquote>
<p>翻译一下：</p>
<blockquote>
<p>在函数输出数值时，尽量使用返回值而非输出参数</p>
</blockquote>
<h4 id="10-2-如何返回一个对象？"><a href="#10-2-如何返回一个对象？" class="headerlink" title="10.2 如何返回一个对象？"></a>10.2 如何返回一个对象？</h4><p>一个用来返回的对象，通常应当是<strong>可移动构造 / 赋值</strong>的，一般也同时是<strong>可拷贝构造 / 赋值</strong>的。如果这样一个对象同时又<strong>可以默认构造</strong>，我们就称其为一个<strong>半正则（semiregular）</strong>的对象。如果可能的话，我们应当尽量让我们的类满足半正则这个要求。</p>
<p>半正则意味着我们的 matrix 类提供下面的成员函数：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">matrix</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 普通构造</span>
    <span class="token function">matrix</span><span class="token punctuation">(</span>size_t rows<span class="token punctuation">,</span> size_t cols<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 半正则要求的构造</span>
    <span class="token function">matrix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">matrix</span><span class="token punctuation">(</span><span class="token keyword">const</span> matrix<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">matrix</span><span class="token punctuation">(</span>matrix<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 半正则要求的赋值</span>
    matrix<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> matrix<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    matrix<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>matrix<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们先看一下在没有返回值优化的情况下 C++ 是怎样返回对象的。以矩阵乘法为例，代码应该像下面这样：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">matrix <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> matrix<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> matrix<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>lhs<span class="token punctuation">.</span><span class="token function">cols</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> rhs<span class="token punctuation">.</span><span class="token function">rows</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"sizes mismatch"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    matrix <span class="token function">result</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span><span class="token function">rows</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> rhs<span class="token punctuation">.</span><span class="token function">cols</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 具体计算过程</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 <strong>[第 3 讲]</strong> 里说过的，返回非引用类型的表达式结果是个纯右值（prvalue）。在执行 auto r = … 的时候，编译器会认为我们实际是在构造 matrix r(…)，而“…”部分是一个纯右值。因此编译器会首先试图匹配 matrix(matrix&amp;&amp;)，在没有时则试图匹配 matrix(const matrix&amp;)；也就是说，有移动支持时使用移动，没有移动支持时则拷贝。</p>
<h4 id="10-3-返回值优化（拷贝消除）"><a href="#10-3-返回值优化（拷贝消除）" class="headerlink" title="10.3 返回值优化（拷贝消除）"></a>10.3 返回值优化（拷贝消除）</h4><p>我们再来看一个能显示生命期过程的对象的例子：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token comment">// Can copy and move</span>
<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Create A\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Destroy A\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Copy A\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token function">A</span><span class="token punctuation">(</span>A<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Move A\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

A <span class="token function">getA_unnamed</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> a <span class="token operator">=</span> <span class="token function">getA_unnamed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果你认为执行结果里应当有一行“Copy A”或“Move A”的话，你就忽视了返回值优化的威力了。即使完全关闭优化，三种主流编译器（GCC、Clang 和 MSVC）都只输出两行：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">Create A
Destroy A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>我们把代码稍稍改一下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">A <span class="token function">getA_named</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    A a<span class="token punctuation">;</span>
    <span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> a <span class="token operator">=</span> <span class="token function">getA_named</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这回结果有了一点点小变化。虽然 GCC 和 Clang 的结果完全不变，但 MSVC 在非优化编译的情况下产生了不同的输出（优化编译——使用命令行参数 /O1、/O2 或 /Ox——则不变）：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">Create A
Move A
Destroy A
Destroy A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>也就是说，返回内容被移动构造了。</p>
<p>我们继续变形一下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

A <span class="token function">getA_duang</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    A a1<span class="token punctuation">;</span>
    A a2<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">42</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> a1<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> a2<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> a <span class="token operator">=</span> <span class="token function">getA_duang</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这回所有的编译器都被难倒了，输出是：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">Create A
Create A
Move A
Destroy A
Destroy A
Destroy A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>关于返回值优化的实验我们就做到这里。下一步，我们试验一下把移动构造函数删除：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">A(A&amp;&amp;) = delete;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>我们可以立即看到“Copy A”出现在了结果输出中，说明目前结果变成拷贝构造了。</p>
<p>如果再进一步，把拷贝构造函数也删除呢？是不是上面的 getA_unnamed、getA_named 和 getA_duang 都不能工作了？</p>
<p>在 C++14 及之前确实是这样的。但从 C++17 开始，对于类似于 getA_unnamed 这样的情况，即使对象不可拷贝、不可移动，这个对象仍然是可以被返回的！C++17 要求对于这种情况，对象必须被直接构造在目标位置上，不经过任何拷贝或移动的步骤 [3]。</p>
<h4 id="10-4-回到-F-20"><a href="#10-4-回到-F-20" class="headerlink" title="10.4 回到 F.20"></a>10.4 回到 F.20</h4><p>理解了 C++ 里的对返回值的处理和返回值优化之后，我们再回过头看一下 F.20 里陈述的理由的话，应该就显得很自然了：</p>
<blockquote>
<p>A return value is self-documenting, whereas a &amp; could be either in-out or outonly and is liable to be misused.</p>
<p>返回值是可以自我描述的；而 &amp; 参数既可能是输入输出，也可能是仅输出，且很容易被误用。</p>
</blockquote>
<p>我想我对返回对象的可读性，已经给出了充足的例子。对于其是否有性能影响这一问题，也给出了充分的说明。</p>
<p>我们最后看一下 F.20 里描述的例外情况：</p>
<ul>
<li>“对于非值类型，比如返回值可能是子对象的情况，使用 unique_ptr 或 shared_ptr 来返回对象。”也就是面向对象、工厂方法这样的情况，像 <strong>[第 1 讲]</strong> 里给出的 create_shape 应该这样改造。</li>
<li>“对于移动代价很高的对象，考虑将其分配在堆上，然后返回一个句柄（如 unique_ptr），或传递一个非 const 的目标对象的引用来填充（用作输出参数）。”也就是说不方便移动的，那就只能使用一个 RAII 对象来管理生命周期，或者老办法输出参数了。</li>
<li>“要在一个内层循环里在多次函数调用中重用一个自带容量的对象：将其当作输入 / 输出参数并将其按引用传递。”这也是个需要继续使用老办法的情况。</li>
</ul>
<h4 id="10-5-参考资料"><a href="#10-5-参考资料" class="headerlink" title="10.5 参考资料"></a>10.5 参考资料</h4><ol>
<li>Bjarne Stroustrup and Herb Sutter (editors), “C++ core guidelines”, item F.20. <a target="_blank" rel="noopener" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-out">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-out</a> (非官方中文版可参见 <a target="_blank" rel="noopener" href="https://github.com/lynnboy/CppCoreGuidelines-zh-CN">https://github.com/lynnboy/CppCoreGuidelines-zh-CN</a>)</li>
<li>Conrad Sanderson and Ryan Curtin, Armadillo. <a target="_blank" rel="noopener" href="http://arma.sourceforge.net/">http://arma.sourceforge.net/</a></li>
<li>cppreference.com, “Copy elision”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/copy_elision">https://en.cppreference.com/w/cpp/language/copy_elision</a></li>
</ol>
<h3 id="11-Unicode：进入多文字支持的世界"><a href="#11-Unicode：进入多文字支持的世界" class="headerlink" title="11 | Unicode：进入多文字支持的世界"></a>11 | Unicode：进入多文字支持的世界</h3><h4 id="11-1-一些历史"><a href="#11-1-一些历史" class="headerlink" title="11.1 一些历史"></a>11.1 一些历史</h4><p>ASCII [1] 是一种创立于 1963 年的 7 位编码，用 0 到 127 之间的数值来代表最常用的字符，包含了控制字符（很多在今天已不再使用）、数字、大小写拉丁字母、空格和基本标点。它在编码上具有简单性，字母和数字的编码位置非常容易记忆。时至今日，ASCII 可以看作是字符编码的基础，主要的编码方式都保持着与 ASCII 的兼容性。</p>
<p><img src="/images/《现代C++实战30讲》学习笔记/ASCII表.png" alt="ASCII表"></p>
<p>ASCII 里只有基本的拉丁字母，它既没有带变音符的拉丁字母（如 é 和 ä ），也不支持像希腊字母（如 α、β、γ）、西里尔字母（如 Пушкин）这样的其他欧洲文字（也难怪，毕竟它是 American Standard Code for Information Interchange）。很多其他编码方式纷纷应运而生，包括 ISO 646 系列、ISO/IEC 8859 系列等等；大部分编码方式都是头 128 个字符与 ASCII 兼容，后 128 个字符是自己的扩展，总共最多是 256 个字符。每次只有一套方式可以生效，称之为一个代码页（code page）。这种做法，只能适用于文字相近、且字符数不多的国家。比如，下图表示了 ISO-8859-1（也称作 Latin-1）和后面的 Windows 扩展代码页 1252（下图中绿框部分为 Windows 的扩展），就只能适用于西欧国家。</p>
<p><img src="/images/《现代C++实战30讲》学习笔记/CP1252.png" alt="CP1252"></p>
<p>最早的中文字符集标准是 1980 年的国标 GB2312 [3]，其中收录了 6763 个常用汉字和 682 个其他符号。我们平时会用到编码 GB2312，其实更正确的名字是 EUC-CN [4]，它是一种与 ASCII 兼容的编码方式。它用单字节表示 ASCII 字符而用双字节表示 GB2312 中的字符；由于 GB2312 中本身也含有 ASCII 中包含的字符，在使用中逐渐就形成了“半角”和“全角”的区别。</p>
<p>国标字符集后面又有扩展，这个扩展后的字符集就是 GBK [5]，是中文版 Windows 使用的标准编码方式。GB2312 和 GBK 所占用的编码位置可以参看下面的图（由 John M. Długosz 为 Wikipedia 绘制）：</p>
<p><img src="/images/《现代C++实战30讲》学习笔记/GBK编码的第一字节和第二字节分布.png" alt="GBK编码的第一字节和第二字节分布"></p>
<p>图中 GBK/1 和 GBK/2 为 GB2312 中已经定义的区域，其他的则是后面添加的字符，总共定义了两万多个编码点，支持了绝大部分现代汉语中还在使用的字。</p>
<p>Unicode [6] 作为一种统一编码的努力，诞生于八十年代末九十年代初，标准的第一版出版于 1991—1992 年。由于最初发明者的目标放得太低，只期望对活跃使用中的现代文字进行编码，他们认为 16 比特的“宽 ASCII”就够用了。这就导致了早期采纳 Unicode 的组织，特别是微软，在其操作系统和工具链中广泛采用了 16 比特的编码方式。在今天，微软的系统中宽字符类型 wchar_t 仍然是 16 位的，操作系统底层接口大量使用 16 位字符编码的 API，说到 Unicode 编码时仍然指的是 16 位的编码 UTF-16（这一不太正确的名字，跟中文 GBK 编码居然可以被叫做 ANSI 相比，实在是小巫见大巫了）。在微软以外的世界， Unicode 本身不作编码名称用，并且最主流的编码方式并不是 UTF-16，而是和 ASCII 全兼容的 UTF-8。</p>
<p>早期 Unicode 组织的另一个决定是不同语言里的同一个字符使用同一个编码点，来减少总编码点的数量。中日韩三国使用的汉字就这么被统一了：像“将”、“径”、“网”等字，每个字在 Unicode 中只占一个编码点。这对网页的字体选择也造成了不少麻烦，时至今日我们仍然可以看到这个问题 [10]。不过这和我们的主题无关，就不再多费笔墨了。</p>
<h4 id="11-2-Unicode-简介"><a href="#11-2-Unicode-简介" class="headerlink" title="11.2 Unicode 简介"></a>11.2 Unicode 简介</h4><p>Unicode 在今天已经大大超出了最初的目标。到 Unicode 12.1 为止，Unicode 已经包含了 137,994 个字符，囊括所有主要语言（使用中的和已经不再使用的），并包含了表情符号、数学符号等各种特殊字符。仍然要指出一下，Unicode 字符是根据含义来区分的，而非根据字形。除了前面提到过中日韩汉字没有分开，像斜体（italics）、小大写字母（small caps）等排版效果在 Unicode 里也没有独立的对应。不过，因为 Unicode 里包含了很多数学、物理等自然科学中使用的特殊符号，某些情况下你也可以找到对应的符号，可以用在聊天中耍酷，如 𝒷𝒶𝒹（但不适合严肃的排版）。</p>
<p>Unicode 的编码点是从 0x0 到 0x10FFFF，一共 1,114,112 个位置。一般用“U+”后面跟 16 进制的数值来表示一个 Unicode 字符，如 U+0020 表示空格，U+6C49 表示“汉”，U+1F600 表示“😀”，等等（不足四位的一般写四位）。</p>
<p>Unicode 字符的常见编码方式有：</p>
<ul>
<li>UTF-32 [7]：32 比特，是编码点的直接映射。</li>
<li>UTF-16 [8]：对于从 U+0000 到 U+FFFF 的字符，使用 16 比特的直接映射；对于大于 U+FFFF 的字符，使用 32 比特的特殊映射关系——在 Unicode 的 16 比特编码点中 0xD800–0xDFFF 是一段空隙，使得这种变长编码成为可能。在一个 UTF-16 的序列中，如果看到内容是 0xD800–0xDBFF，那这就是 32 比特编码的前 16 比特；如果看到内容是 0xDC00–0xDFFF，那这是 32 比特编码的后 16 比特；如果内容在 0xD800–0xDFFF 之外，那就是一个 16 比特的映射。</li>
<li>UTF-8 [9]：1 到 4 字节的变长编码。在一个合法的 UTF-8 的序列中，如果看到一个字节的最高位是 0，那就是一个单字节的 Unicode 字符；如果一个字节的最高两比特是 10，那这是一个 Unicode 字符在编码后的后续字节；否则，这就是一个 Unicode 字符在编码后的首字节，且最高位开始连续 1 的个数表示了这个字符按 UTF-8 的方式编码有几个字节。</li>
</ul>
<p>在上面三种编码方式里，只有 UTF-8 完全保持了和 ASCII 的兼容性，目前得到了最广泛的使用。在我们下面讲具体编码方式之前，我们先看一下上面提到的三个字符在这三种方式下的编码结果：</p>
<ul>
<li>UTF-32：U+0020 映射为 0x00000020，U+6C49 映射为 0x00006C49，U+1F600 映射为 0x0001F600。</li>
<li>UTF-16：U+0020 映射为 0x0020，U+6C49 映射为 0x6C49，而 U+1F600 会映射为 0xD83D DE00。</li>
<li>UTF-8：U+0020 映射为 0x20，U+6C49 映射为 0xE6 B1 89，而 U+1F600 会映射为 0xF0 9F 98 80。</li>
</ul>
<p>Unicode 有好几种（上面还不是全部）不同的编码方式，上面的 16 比特和 32 比特编码方式还有小头党和大头党之争（“汉”按字节读取时是 6C 49 呢，还是 49 6C？）；同时，任何一种编码方式还需要跟传统的编码方式容易区分。因此，Unicode 文本文件通常有一个使用 BOM（byte order mark）字符的约定，即字符 U+FEFF [11]。由于 Unicode 不使用 U+FFFE，在文件开头加一个 BOM 即可区分各种不同编码：</p>
<ul>
<li>如果文件开头是 0x00 00 FE FF，那这是大头在前的 UTF-32 编码；</li>
<li>否则如果文件开头是 0xFF FE 00 00，那这是小头在前的 UTF-32 编码；</li>
<li>否则如果文件开头是 0xFE FF，那这是大头在前的 UTF-16 编码；</li>
<li>否则如果文件开头是 0xFF FE，那这是小头在前的 UTF-16 编码（注意，这条规则和第二条的顺序不能相反）；</li>
<li>否则如果文件开头是 0xEF BB BF，那这是 UTF-8 编码；</li>
<li>否则，编码方式使用其他算法来确定。</li>
</ul>
<p>在 UTF-8 编码下使用 BOM 字符并非必需，尤其在 Unix 上。但 Windows 上通常会使用 BOM 字符，以方便区分 UTF-8 和传统编码。</p>
<h4 id="11-3-C-中的-Unicode-字符类型"><a href="#11-3-C-中的-Unicode-字符类型" class="headerlink" title="11.3 C++ 中的 Unicode 字符类型"></a>11.3 C++ 中的 Unicode 字符类型</h4><p>C++98 中有 char 和 wchar_t 两种不同的字符类型，其中 char 的长度是单字节，而 wchar_t 的长度不确定。在 Windows 上它是双字节，只能代表 UTF-16，而在 Unix 上一般是四字节，可以代表 UTF-32。为了解决这种混乱，目前我们有了下面的改进：</p>
<ul>
<li>C++11 引入了 char16_t 和 char32_t 两个独立的字符类型（不是类型别名），分别代表 UTF-16 和 UTF-32。</li>
<li>C++20 将引入 char8_t 类型，进一步区分了可能使用传统编码的窄字符类型和 UTF-8 字符类型。</li>
<li>除了 string 和 wstring，我们也相应地有了 u16string、u32string（和将来的 u8string）。</li>
<li>除了传统的窄字符 / 字符串字面量（如 “hi”）和宽字符 / 字符串字面量（如 L”hi”），引入了新的 UTF-8、UTF-16 和 UTF-32 字面量，分别形如 u8”hi”、u”hi” 和 U”hi”。</li>
<li>为了确保非 ASCII 字符在源代码中可以简单地输入，引入了新的 Unicode 换码序列。比如，我们前面说到的三个字符可以这样表达成一个 UTF-32 字符串字面量：U”\u6C49\U0001F600”。要生成 UTF-16 或 UTF-8 字符串字面量只需要更改前缀即可。</li>
</ul>
<p>使用这些新的字符（串）类型，我们可以用下面的代码表达出 UTF-32 和其他两种 UTF 编码间是如何转换的：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iomanip&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdexcept&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token keyword">char32_t</span> unicode_max <span class="token operator">=</span> <span class="token number">0x10FFFF</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">to_utf_16</span><span class="token punctuation">(</span><span class="token keyword">char32_t</span> ch<span class="token punctuation">,</span> u16string<span class="token operator">&amp;</span> result<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">&gt;</span> unicode_max<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"invalid code point"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">&lt;</span> <span class="token number">0x10000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        result <span class="token operator">+=</span> <span class="token keyword">char16_t</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">char16_t</span> first <span class="token operator">=</span> <span class="token number">0xD800</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ch <span class="token operator">-</span> <span class="token number">0x10000</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">char16_t</span> second <span class="token operator">=</span> <span class="token number">0xDC00</span> <span class="token operator">|</span> <span class="token punctuation">(</span>ch <span class="token operator">&amp;</span> <span class="token number">0x3FF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        result <span class="token operator">+=</span> first<span class="token punctuation">;</span>
        result <span class="token operator">+=</span> second<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">to_utf_8</span><span class="token punctuation">(</span><span class="token keyword">char32_t</span> ch<span class="token punctuation">,</span> string<span class="token operator">&amp;</span> result<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">&gt;</span> unicode_max<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"invalid code point"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">&lt;</span> <span class="token number">0x80</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        result <span class="token operator">+=</span> ch<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">&lt;</span> <span class="token number">0x800</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        result <span class="token operator">+=</span> <span class="token number">0xC0</span> <span class="token operator">|</span> <span class="token punctuation">(</span>ch <span class="token operator">&gt;&gt;</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        result <span class="token operator">+=</span> <span class="token number">0x80</span> <span class="token operator">|</span> <span class="token punctuation">(</span>ch <span class="token operator">&amp;</span> <span class="token number">0x3F</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">&lt;</span> <span class="token number">0x10000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        result <span class="token operator">+=</span> <span class="token number">0xE0</span> <span class="token operator">|</span> <span class="token punctuation">(</span>ch <span class="token operator">&gt;&gt;</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        result <span class="token operator">+=</span> <span class="token number">0x80</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ch <span class="token operator">&gt;&gt;</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x3F</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        result <span class="token operator">+=</span> <span class="token number">0x80</span> <span class="token operator">|</span> <span class="token punctuation">(</span>ch <span class="token operator">&amp;</span> <span class="token number">0x3F</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        result <span class="token operator">+=</span> <span class="token number">0xF0</span> <span class="token operator">|</span> <span class="token punctuation">(</span>ch <span class="token operator">&gt;&gt;</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        result <span class="token operator">+=</span> <span class="token number">0x80</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ch <span class="token operator">&gt;&gt;</span> <span class="token number">12</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x3F</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        result <span class="token operator">+=</span> <span class="token number">0x80</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ch <span class="token operator">&gt;&gt;</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x3F</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        result <span class="token operator">+=</span> <span class="token number">0x80</span> <span class="token operator">|</span> <span class="token punctuation">(</span>ch <span class="token operator">&amp;</span> <span class="token number">0x3F</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char32_t</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> U<span class="token string">" \u6C49\U0001F600"</span><span class="token punctuation">;</span>
    u16string u16str<span class="token punctuation">;</span>
    string u8str<span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> ch <span class="token operator">:</span> str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">to_utf_16</span><span class="token punctuation">(</span>ch<span class="token punctuation">,</span> u16str<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">to_utf_8</span><span class="token punctuation">(</span>ch<span class="token punctuation">,</span> u8str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    cout <span class="token operator">&lt;&lt;</span> hex <span class="token operator">&lt;&lt;</span> <span class="token function">setfill</span><span class="token punctuation">(</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char16_t</span> ch <span class="token operator">:</span> u16str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">unsigned</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> ch <span class="token operator">:</span> u8str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">unsigned</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出结果是：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">0020 6c49 d83d de00
20 e6 b1 89 f0 9f 98 80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h4 id="11-4-平台区别"><a href="#11-4-平台区别" class="headerlink" title="11.4 平台区别"></a>11.4 平台区别</h4><p>下面我们看一下在两个主流的平台上一般是如何处理 Unicode 编码问题的。</p>
<ol>
<li><p>Unix</p>
<p> 现代 Unix 系统，包括 Linux 和 macOS 在内，已经全面转向了 UTF-8。这样的系统中一般直接使用 char[] 和 string 来代表 UTF-8 字符串，包括输入、输出和文件名，非常简单。不过，由于一个字符单位不能代表一个完整的 Unicode 字符，在需要真正进行文字处理的场合转换到 UTF-32 往往会更简单。在以前及需要和 C 兼容的场合，会使用 wchar_t、uint32_t 或某个等价的类型别名；在新的纯 C++ 代码里，就没有理由不使用 char32_t 和 u32string 了。</p>
<p> Unix 下输出宽字符串需要使用 wcout（这点和 Windows 相同），并且需要进行区域设置，通常使用 setlocale(LC_ALL, “en_US.UTF-8”); 即足够。由于没有什么额外好处，Unix 平台下一般只用 cout，不用 wcout。</p>
</li>
<li><p>Windows</p>
<p> Windows 由于历史原因和保留向后兼容性的需要（Windows 为了向后兼容性已经到了大规模放弃优雅的程度了），一直用 char 表示传统编码（如，英文 Windows 上是 Windows-1252，简体中文 Windows 上是 GBK），用 wchar_t 表示 UTF-16。由于传统编码一次只有一种、且需要重启才能生效，要得到好的多语言支持，在和操作系统交互时必须使用 UTF-16。</p>
<p> 对于纯 Windows 编程，全面使用宽字符（串）是最简单的处理方式。当然，源代码和文本很少用 UTF-16 存储，通常还是 UTF-8（除非是纯 ASCII，否则需要加入 BOM 字符来和传统编码相区分）。这时可能会有一个小小的令人惊讶的地方：微软的编译器会把源代码里窄字符串字面量中的非 ASCII 字符转换成传统编码。换句话说，同样的源代码在不同编码的 Windows 下编译可能会产生不同的结果！如果你希望保留 UTF-8 序列的话，就应该使用 UTF-8 字面量（并在将来使用 char8_t 字符类型）。</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">dump</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> str<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> ch <span class="token operator">:</span> str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.2x "</span><span class="token punctuation">,</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">putchar</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"你好"</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> u8str<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> u8<span class="token string">"你好"</span><span class="token punctuation">;</span>
    <span class="token function">dump</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">dump</span><span class="token punctuation">(</span>u8str<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 下面展示的是以上代码在 Windows 下系统传统编码设置为简体中文时的编译、运行结果：</p>
 <pre class="line-numbers language-text" data-language="text"><code class="language-text">c4 e3 ba c3 00
e4 bd a0 e5 a5 bd 00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> Windows 下的 wcout 主要用在配合宽字符的输出，此外没什么大用处。原因一样，只有进行了正确的区域设置，才能输出含非 ASCII 字符的宽字符串。如果要输出中文，得写 setlocale(LC_ALL, “Chinese_China.936”);，这显然就让“统一码”输出失去意义了。</p>
<p> 由于窄字符在大部分 Windows 系统上只支持传统编码，要打开一个当前编码不支持的文件名称，就必需使用宽字符的文件名。微软的 fstream 系列类及其 open 成员函数都支持 const wchar_t* 类型的文件名，这是 C++ 标准里所没有的。</p>
</li>
</ol>
<h4 id="11-5-统一化处理"><a href="#11-5-统一化处理" class="headerlink" title="11.5 统一化处理"></a>11.5 统一化处理</h4><p>要想写出跨平台的处理字符串的代码，我们一般考虑两种方式之一：</p>
<ul>
<li>源代码级兼容，但内码不同</li>
<li>源代码和内码都完全兼容</li>
</ul>
<p>微软推荐的方式一般是前者。做 Windows 开发的人很多都知道 tchar.h 和 _T 宏，它们就起着类似的作用（虽然目的不同）。根据预定义宏的不同，系统会在同一套代码下选择不同的编码方式及对应的函数。拿一个最小的例子来说：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;tchar.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">_tmain</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> TCHAR<span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">_putts</span><span class="token punctuation">(</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"Hello world!\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果用缺省的命令行参数进行编译，上面的代码相当于：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Hello world!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>而如果在命令行上加上了 /D_UNICODE，那代码则相当于：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">wmain</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">_putws</span><span class="token punctuation">(</span>L<span class="token string">"Hello world!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然，这个代码还是只能在 Windows 上用，并且仍然不漂亮（所有的字符和字符串字面量都得套上 _T）。后者无解，前者则可以找到替代方案（甚至自己写也不复杂）。C++ REST SDK 中就提供了类似的封装，可以跨平台地开发网络应用。但可以说，这种方式是一种主要照顾 Windows 的开发方式。</p>
<p>相应的，对 Unix 开发者而言更自然的方式是全面使用 UTF-8，仅在跟操作系统、文件系统打交道时把字符串转换成需要的编码。利用临时对象的生命周期，我们可以像下面这样写帮助函数和宏。</p>
<p>utf8_to_native.hpp：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">UTF8_TO_NATIVE_HPP</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">UTF8_TO_NATIVE_HPP</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>_WIN32<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">defined</span><span class="token punctuation">(</span>_UNICODE<span class="token punctuation">)</span></span></span>

std<span class="token operator">::</span>wstring <span class="token function">utf8_to_wstring</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>wstring <span class="token function">utf8_to_wstring</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">NATIVE_STR</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token function">utf8_to_wstring</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>

<span class="token keyword">inline</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">to_c_str</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> str<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">inline</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">to_c_str</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">NATIVE_STR</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token function">to_c_str</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">// UTF8_TO_NATIVE_HPP</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>utf8_to_native.cpp：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"utf8_to_native.hpp"</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>_WIN32<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">defined</span><span class="token punctuation">(</span>_UNICODE<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;windows.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;system_error&gt;</span></span>

<span class="token keyword">namespace</span> <span class="token punctuation">{</span>
<span class="token keyword">void</span> <span class="token function">throw_system_error</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> reason<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>string <span class="token function">msg</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>
    msg <span class="token operator">+=</span> <span class="token string">" failed"</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>error_code <span class="token function">ec</span><span class="token punctuation">(</span><span class="token function">GetLastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">system_category</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">system_error</span><span class="token punctuation">(</span>ec<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token comment">/* unnamed namespace */</span>

std<span class="token operator">::</span>wstring <span class="token function">utf8_to_wstring</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">MultiByteToWideChar</span><span class="token punctuation">(</span>CP_UTF8<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> str<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">throw_system_error</span><span class="token punctuation">(</span><span class="token string">"utf8_to_wstring"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    std<span class="token operator">::</span>wstring <span class="token function">result</span><span class="token punctuation">(</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> L<span class="token string">'\0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">MultiByteToWideChar</span><span class="token punctuation">(</span>CP_UTF8<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> str<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">throw_system_error</span><span class="token punctuation">(</span><span class="token string">"utf8_to_wstring"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
std<span class="token operator">::</span>wstring <span class="token function">utf8_to_wstring</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">utf8_to_wstring</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在头文件里，定义了在 Windows 下会做 UTF-8 到 UTF-16 的转换；在其他环境下则不真正做转换，而是不管提供的是字符指针还是 string 都会转换成字符指针。在 Windows 下每次调用 NATIVE_STR 会生成一个临时对象，当前语句执行结束后这个临时对象会自动销毁。</p>
<p>使用该功能的代码是这样的：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fstream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"utf8_to_native.hpp"</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> filename<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> u8<span class="token string">"测试.txt"</span><span class="token punctuation">;</span>
    ifstream <span class="token function">ifs</span><span class="token punctuation">(</span><span class="token function">NATIVE_STR</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 对 ifs 进行操作</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面这样的代码可以同时适用于现代 Unix 和现代 Windows（任何语言设置下），用来读取名为“测试.txt”的文件。</p>
<h4 id="11-6-编程支持"><a href="#11-6-编程支持" class="headerlink" title="11.6 编程支持"></a>11.6 编程支持</h4><p>快速介绍一下其他的一些支持 Unicode 及其转换的 API。</p>
<ol>
<li><p>Windows API</p>
<p> 上一节的代码在 Windows 下用到了 MultiByteToWideChar [12]，从某个编码转到 UTF-16。Windows 也提供了反向的 WideCharToMultiByte [13]，从 UTF-16 转到某个编码。从上面可以看到，C 接口用起来并不方便，可以考虑自己封装一下。</p>
</li>
<li><p>iconv</p>
<p> Unix 下最常用的底层编码转换接口是 iconv [14]，提供 iconv_open、iconv_close 和 iconv 三个函数。这同样是 C 接口，实践中应该封装一下。</p>
</li>
<li><p>ICU4C</p>
<p> ICU [15] 是一个完整的 Unicode 支持库，提供大量的方法，ICU4C 是其 C/C++ 的版本。ICU 有专门的字符串类型，内码是 UTF-16，但可以直接用于 IO streams 的输出。下面的程序应该在所有平台上都有同样的输出（但在 Windows 上要求当前系统传统编码能支持待输出的字符）：</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unicode/unistr.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unicode/ustream.h&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">using</span> icu<span class="token operator">::</span>UnicodeString<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> str <span class="token operator">=</span> <span class="token class-name">UnicodeString</span><span class="token operator">::</span><span class="token function">fromUTF8</span><span class="token punctuation">(</span>u8<span class="token string">"你好"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    string u8str<span class="token punctuation">;</span>
    str<span class="token punctuation">.</span><span class="token function">toUTF8String</span><span class="token punctuation">(</span>u8str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"In UTF-8 it is "</span> <span class="token operator">&lt;&lt;</span> u8str<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" bytes"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>codecvt</p>
<p> C++11 曾经引入了一个头文件 <codecvt> [16] 用作 UTF 编码间的转换，但很遗憾，那个头文件目前已因为存在安全性和易用性问题被宣告放弃（deprecated）[17]。<locale> 中有另外一个 codecvt 模板 [18]，本身接口不那么好用，而且到 C++20 还会发生变化，这儿也不详细介绍了。有兴趣的话可以直接看参考资料。</locale></codecvt></p>
</li>
</ol>
<h4 id="11-7-参考资料"><a href="#11-7-参考资料" class="headerlink" title="11.7 参考资料"></a>11.7 参考资料</h4><ol>
<li>Wikipedia, “ASCII”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/ASCII">https://en.wikipedia.org/wiki/ASCII</a></li>
<li>Wikipedia, “EBCDIC”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/EBCDIC">https://en.wikipedia.org/wiki/EBCDIC</a></li>
<li>Wikipedia, “GB 2312”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/GB_2312">https://en.wikipedia.org/wiki/GB_2312</a></li>
<li>Wikipedia, “EUC-CN”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Extended_Unix_Code#EUC-CN">https://en.wikipedia.org/wiki/Extended_Unix_Code#EUC-CN</a></li>
<li>Wikipedia, “GBK”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/GBK_(character_encoding)">https://en.wikipedia.org/wiki/GBK_(character_encoding)</a></li>
<li>Wikipedia, “Unicode”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Unicode">https://en.wikipedia.org/wiki/Unicode</a></li>
<li>Wikipedia, “UTF-32”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/UTF-32">https://en.wikipedia.org/wiki/UTF-32</a></li>
<li>Wikipedia, “UTF-16”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/UTF-16">https://en.wikipedia.org/wiki/UTF-16</a></li>
<li>Wikipedia, “UTF-8”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/UTF-8">https://en.wikipedia.org/wiki/UTF-8</a></li>
<li>吴咏炜, “Specify LANG in a UTF-8 web page”. <a target="_blank" rel="noopener" href="http://wyw.dcweb.cn/lang_utf8.htm">http://wyw.dcweb.cn/lang_utf8.htm</a></li>
<li>Wikipedia, “Byte order mark”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Byte_order_mark">https://en.wikipedia.org/wiki/Byte_order_mark</a></li>
<li>Microsoft, “MultiByteToWideChar function”.<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/stringapiset/nfstringapiset-multibytetowidechar">https://docs.microsoft.com/en-us/windows/win32/api/stringapiset/nfstringapiset-multibytetowidechar</a></li>
<li>Microsoft, “WideCharToMultiByte function”.<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/stringapiset/nfstringapiset-widechartomultibyte">https://docs.microsoft.com/en-us/windows/win32/api/stringapiset/nfstringapiset-widechartomultibyte</a></li>
<li>Wikipedia, “iconv”. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Iconv">https://en.wikipedia.org/wiki/Iconv</a></li>
<li>ICU Technical Committee, ICU—International Components for Unicode. <a target="_blank" rel="noopener" href="http://site.icu-project.org/">http://site.icu-project.org/</a></li>
<li>cppreference.com, “Standard library header <codecvt>”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/header/codecvt">https://en.cppreference.com/w/cpp/header/codecvt</a></codecvt></li>
<li>Alisdair Meredith, “Deprecating <codecvt>”. <a target="_blank" rel="noopener" href="http://www.openstd.org/jtc1/sc22/wg21/docs/papers/2017/p0618r0.html">http://www.openstd.org/jtc1/sc22/wg21/docs/papers/2017/p0618r0.html</a></codecvt></li>
<li>cppreference.com, “std::codecvt”. <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/locale/codecvt">https://en.cppreference.com/w/cpp/locale/codecvt</a></li>
</ol>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://kibazen.cn" rel="external nofollow noreferrer">Kiba Amor</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                    </span>
                <span class="reprint-info">
                    <a href="https://kibazen.cn/xian-dai-c-shi-zhan-30-jiang-xue-xi-bi-ji/">https://kibazen.cn/xian-dai-c-shi-zhan-30-jiang-xue-xi-bi-ji/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY-NC-ND 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://kibazen.cn" target="_blank">Kiba Amor</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/CPP/">
                                    <span class="chip bg-color">CPP</span>
                                </a>
                            
                                <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                                    <span class="chip bg-color">极客时间</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="qq,wechat,weibo,douban" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/xian-dai-c-shi-zhan-30-jiang-xue-xi-bi-ji/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/4.jpg" class="responsive-img" alt="《现代C++实战30讲》学习笔记">
                        
                        <span class="card-title">《现代C++实战30讲》学习笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-01-26
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                    学习笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/CPP/">
                        <span class="chip bg-color">CPP</span>
                    </a>
                    
                    <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                        <span class="chip bg-color">极客时间</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/vim-shi-yong-ji-qiao-bi-zhi-bi-hui-xue-xi-bi-ji/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/3.jpg" class="responsive-img" alt="《Vim实用技巧必知必会》学习笔记">
                        
                        <span class="card-title">《Vim实用技巧必知必会》学习笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-01-23
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                    学习笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                        <span class="chip bg-color">极客时间</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (true) {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 木叶禅<br />'
            + '文章作者: Kiba Amor<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者木叶禅所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('2'),
            headingSelector: 'h2, h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2022</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">Kiba Amor</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">800.4k</span>&nbsp;字
            
            
            
            
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/kibaamor" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>









    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=562236616" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 562236616" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>





    <a href="https://www.zhihu.com/people/kibaamor" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/kibaamor" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    

    

    

	
    

    

    

    
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
