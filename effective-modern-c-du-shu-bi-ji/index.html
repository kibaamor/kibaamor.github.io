<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <meta name="keywords" content="《Effective Modern C++》读书笔记, kiba, zen, amor, kibazen, kibaamor, 木叶, 木叶禅">
    <meta name="description" content="一个普通游戏程序员的博客">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>《Effective Modern C++》读书笔记 | 木叶禅</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/css/my.css">

    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="木叶禅" type="application/atom+xml">
</head>



   <style>
    body{
       background-image: url(/medias/background.jpg);
       background-repeat:no-repeat;
       background-size:cover;
       background-attachment:fixed;
    }
</style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">木叶禅</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/leetcode/" class="waves-effect waves-light">
      
      <i class="fas fa-code" style="zoom: 0.6;"></i>
      
      <span>LeetCode</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/learn/" class="waves-effect waves-light">
      
      <i class="fas fa-book" style="zoom: 0.6;"></i>
      
      <span>学习</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tool/" class="waves-effect waves-light">
      
      <i class="fas fa-toolbox" style="zoom: 0.6;"></i>
      
      <span>工具</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories/" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags/" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about/" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">木叶禅</div>
        <div class="logo-desc">
            
            一个普通游戏程序员的博客
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/leetcode/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-code"></i>
			
			LeetCode
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/learn/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-book"></i>
			
			学习
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tool/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-toolbox"></i>
			
			工具
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    
<script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/19.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">《Effective Modern C++》读书笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/CPP/">
                                <span class="chip bg-color">CPP</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="post-category">
                                读书笔记
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-05-22
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2021-12-25
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    7.3k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    26 分
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="一、型别推导"><a href="#一、型别推导" class="headerlink" title="一、型别推导"></a>一、型别推导</h2><h3 id="1-理解模板型别推导"><a href="#1-理解模板型别推导" class="headerlink" title="1. 理解模板型别推导"></a>1. 理解模板型别推导</h3><ol>
<li>在模板型别推导过程中，具有引用型别的实参会被当成非引用型别来处理。换言之，其引用性会被忽略。</li>
<li>对万能引用(Universal Reference)形参进行推导时，左值实参会进行特殊处理。</li>
<li>对按值传递的形参进行推导时，若实参型别中带有const或volatile饰词，则它们还是会被当作不带const或volatile饰词的型别来处理。</li>
<li>在模板型别推导过程中，数组或函数型别的实参会退化成对应的指针，除非它们被用来初始化引用。</li>
</ol>
<h3 id="2-理解auto型别推导"><a href="#2-理解auto型别推导" class="headerlink" title="2. 理解auto型别推导"></a>2. 理解auto型别推导</h3><ol>
<li>在一般情况下，auto型别推导和模板型别推导是一摸一样的，但是auto型别推导会假定用大括号括起的初始化表达式代表一个std::initializer_list，但模板型别推导却不会。</li>
<li>在函数返回值或lambda式的形参中使用auto，意思是使用模板型别推导而非auto型别推导。</li>
</ol>
<h3 id="3-理解decltype"><a href="#3-理解decltype" class="headerlink" title="3. 理解decltype"></a>3. 理解decltype</h3><ol>
<li>绝大多数情况下，decltype会得出变量或表达式的型别而不作任何修改。</li>
<li><p>对于型别为T的左值表达式，除非该表达式仅有一个名字，decltype总是得出型别T&amp;。</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>     <span class="token comment">// -&gt; int</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">// -&gt; int&amp;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span>    <span class="token comment">// -&gt; int&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>C++14支持decltype(auto)，和auto一样，它会从其初始化表达式出发来推导型别，但是它的型别推导使用的是decltype的规则。</li>
</ol>
<h3 id="4-掌握查看型别推导结果的方法"><a href="#4-掌握查看型别推导结果的方法" class="headerlink" title="4. 掌握查看型别推导结果的方法"></a>4. 掌握查看型别推导结果的方法</h3><ol>
<li>利用IDE编辑器、编译器错误消息和Boost.TypeIndex库常常能够查看到推导而得的型别。</li>
<li>有些工具产生的结果可能会无用，或者不准确。所以，理解C++型别推导规则是必要的。</li>
</ol>
<h2 id="二、auto"><a href="#二、auto" class="headerlink" title="二、auto"></a>二、auto</h2><h3 id="5-优先选用auto，而非显示型别声明"><a href="#5-优先选用auto，而非显示型别声明" class="headerlink" title="5. 优先选用auto，而非显示型别声明"></a>5. 优先选用auto，而非显示型别声明</h3><ol>
<li>auto变量必须初始化，基本上对会导致兼容性和效率问题的型别不匹配现象免疫，还可以简化重构流程，通常也比显示指定型别要少打一些字。</li>
<li>auto型别的变量都有着<a href="#2-理解auto型别推导">条款2</a>和<a href="#6-当auto推导的型别不符合要求时，使用带显示型别的初始化物习惯用法">条款6</a>中所描述的毛病。</li>
</ol>
<h3 id="6-当auto推导的型别不符合要求时，使用带显示型别的初始化物习惯用法"><a href="#6-当auto推导的型别不符合要求时，使用带显示型别的初始化物习惯用法" class="headerlink" title="6. 当auto推导的型别不符合要求时，使用带显示型别的初始化物习惯用法"></a>6. 当auto推导的型别不符合要求时，使用带显示型别的初始化物习惯用法</h3><ol>
<li>“隐形”的代理型别可以导致auto根据初始化表达式推导出“错误的”型别。</li>
<li>带显示型别的初始化物习惯用法强制auto推导出你想要的型别。</li>
</ol>
<h2 id="三、转向现代C"><a href="#三、转向现代C" class="headerlink" title="三、转向现代C++"></a>三、转向现代C++</h2><h3 id="7-在创建对象时注意区分-和"><a href="#7-在创建对象时注意区分-和" class="headerlink" title="7. 在创建对象时注意区分()和{}"></a>7. 在创建对象时注意区分()和{}</h3><ol>
<li>大括号初始化可以应用的语境最为宽泛，可以阻止隐式窄化型别转换，还对最令人苦恼之解析语法免疫。</li>
<li>在构造函数重载决议期间，只要有任何可能，大括号初始化物就会与带有std::initializer_list型别的形参相匹配，即使其他重载版本有着貌似更加匹配的形参表。</li>
<li>使用小括号还是大括号，会造成结果大相径庭的一个例子是：使用两个实参创建一个std::vector&lt;数值型别&gt;对象。</li>
<li>在模板内容进行对象创建时，到底应该使用小括号还是大括号会成为一个棘手问题。</li>
</ol>
<h4 id="几个容易混淆的例子"><a href="#几个容易混淆的例子" class="headerlink" title="几个容易混淆的例子"></a>几个容易混淆的例子</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Widget w1<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">// 调用默认构造函数</span>
Widget <span class="token function">w2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 声明了一个名为w2的函数</span>
Widget <span class="token function">w3</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 调用带有std::initializer_list型别形参的构造函数</span>
Widget w4<span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// 同上</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="8-优先选用nullptr，而非0或NULL"><a href="#8-优先选用nullptr，而非0或NULL" class="headerlink" title="8. 优先选用nullptr，而非0或NULL"></a>8. 优先选用nullptr，而非0或NULL</h3><ol>
<li>相对于0或NULL，优先选用nullptr。</li>
<li>避免在整型和指针型别之间重载。</li>
</ol>
<h3 id="9-优先选用别名声明，而非typedef"><a href="#9-优先选用别名声明，而非typedef" class="headerlink" title="9. 优先选用别名声明，而非typedef"></a>9. 优先选用别名声明，而非typedef</h3><ol>
<li>typedef不支持模板化，但别名声明支持。</li>
<li>别名模板可以让人免写“::type”后缀，并且在模板内，对于内嵌typedef的引用经常要求加上typename前缀。</li>
</ol>
<h3 id="10-优先选用限定作用域的枚举型别，而非不限作用域的枚举型别"><a href="#10-优先选用限定作用域的枚举型别，而非不限作用域的枚举型别" class="headerlink" title="10. 优先选用限定作用域的枚举型别，而非不限作用域的枚举型别"></a>10. 优先选用限定作用域的枚举型别，而非不限作用域的枚举型别</h3><ol>
<li>C++98风格的枚举型别，现在称为不限范围的枚举型别。</li>
<li>限定作用域的枚举型别仅在枚举型别内可见。它们只能通过强制型别转换以转换至其他型别。</li>
<li>限制作用域的枚举型别和不限范围的枚举型别都支持底层型别指定。限制作用域的枚举型别的默认底层型别是int，而不限范围的枚举型别没有默认底层型别。</li>
<li>限制作用域的枚举型别总是可以进行前置声明，而不限范围的枚举型别却只有在指定了默认底层型别的前提下才可以进行前置声明。</li>
</ol>
<h3 id="11-优先选用删除函数，而非private未定义函数"><a href="#11-优先选用删除函数，而非private未定义函数" class="headerlink" title="11. 优先选用删除函数，而非private未定义函数"></a>11. 优先选用删除函数，而非private未定义函数</h3><ol>
<li>优先选用删除函数，而非private未定义函数。</li>
<li>任何函数都可以删除，包括非成员函数和模板具现。</li>
</ol>
<h3 id="12-为意在改写的函数添加override声明"><a href="#12-为意在改写的函数添加override声明" class="headerlink" title="12. 为意在改写的函数添加override声明"></a>12. 为意在改写的函数添加override声明</h3><ol>
<li>为意在改写的函数添加override声明。</li>
<li>成员函数引用饰词使得对于左值和右值对象（*this）的处理能够区分开来。</li>
</ol>
<h3 id="13-优先选用const-iterator，而非iterator"><a href="#13-优先选用const-iterator，而非iterator" class="headerlink" title="13. 优先选用const_iterator，而非iterator"></a>13. 优先选用const_iterator，而非iterator</h3><ol>
<li>优先选用const_iterator，而非iterator。</li>
<li>在最通用的代码中，优先选用非成员函数版本的begin、end和rbegin等，而非其成员函数版本。</li>
</ol>
<h3 id="14-只要函数不会发射异常，就为其加上noexcept声明"><a href="#14-只要函数不会发射异常，就为其加上noexcept声明" class="headerlink" title="14. 只要函数不会发射异常，就为其加上noexcept声明"></a>14. 只要函数不会发射异常，就为其加上noexcept声明</h3><ol>
<li>noexcept声明是函数接口的组成部分，这意味着调用方可能会对它有依赖。</li>
<li>相对于不带noexcept声明的函数，带有noexcept声明的函数有更对机会得到优化。</li>
<li>noexcept性质对于移动操作、swap、函数释放函数和析构函数最有价值。</li>
<li>大多数函数都是异常中立的，不具备noexcept性质。</li>
</ol>
<h4 id="关于条款14的补充说明"><a href="#关于条款14的补充说明" class="headerlink" title="关于条款14的补充说明"></a>关于条款14的补充说明</h4><ul>
<li><p>在带有noexcept声明的函数中，优化器不需要在异常传出函数的前提下，将执行期栈保持在可开解状态；也不需要在异常溢出函数的前提下，保证所有其中的对象以其被构造顺序的逆序完成析构。而那些以“throw()”异常规格声明的函数就享受不到这样的优化灵活性，和没有加异常规格声明的函数一样。</p>
</li>
<li><p>在C++98中，允许内存释放函数（即operator delete或operator delete[]）和析构函数发射异常，被认为是一种差劲的编程风格。而在C++11中，这种风格规则被升级成了一条语言规则。<strong>默认地，内存释放函数和所有的析构函数（无论是用户定义的，还是编译器自动生成的）都隐式地具备noexcept性质。</strong></p>
</li>
</ul>
<h3 id="15-只要有可能使用constexpr，就使用它"><a href="#15-只要有可能使用constexpr，就使用它" class="headerlink" title="15. 只要有可能使用constexpr，就使用它"></a>15. 只要有可能使用constexpr，就使用它</h3><ol>
<li>constexpr对象都具备const属性，并由编译期已知的值完成初始化。</li>
<li>constexpr函数在调用时若传入的实参值是编译期已知的，则会产生出编译期结果。</li>
<li>比起非constexpr对象或constexpr函数而言，constexpr对象或是constexpr函数可以用在一个作用域更广的语境中。</li>
</ol>
<h4 id="关于constexpr函数的说明"><a href="#关于constexpr函数的说明" class="headerlink" title="关于constexpr函数的说明"></a>关于constexpr函数的说明</h4><ul>
<li>constexpr函数可以用在要求编译期常量的语境中。在这样的语境中，若你传给一个constexpr函数的实参值是在编译期已知的，则结果也会在编译期间计算出来。如果任何一个实参值在编译期未知，则你的代码将无法通过编译。</li>
<li>在调用constexpr函数时，若传入的值有一个或多个在编译期未知，则它的运作方式和普通函数无异，亦即它也是在运行期执行结果的计算。这意味着，如果函数执行的是同样的操作，仅仅应用的语境一个是要求编译期常量的，一个是用于所有其他值的话，那就不必写两个函数。constexpr函数就可以同时满足所有需求。</li>
</ul>
<h4 id="关于constexpr在C-11和C-14中的不同"><a href="#关于constexpr在C-11和C-14中的不同" class="headerlink" title="关于constexpr在C++11和C++14中的不同"></a>关于constexpr在C++11和C++14中的不同</h4><p>constexpr函数仅限于传入和返回字面型别（literal type），意思就是这样的型别能够持有编译期可以决议的值。在C++11中，所有的内建型别，除了void，都符合这个条件。但是用户自定义型别同样可能也是字面型别，因为它的构造函数和其他成员函数可能也是constexpr函数。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">constexpr</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">double</span> xVal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">double</span> yVal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span>
    <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>xVal<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>yVal<span class="token punctuation">)</span>
    <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">constexpr</span> <span class="token keyword">double</span> <span class="token function">xValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">double</span> <span class="token function">yValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">setX</span><span class="token punctuation">(</span><span class="token keyword">double</span> newX<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> x <span class="token operator">=</span> newX<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">setY</span><span class="token punctuation">(</span><span class="token keyword">double</span> newY<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> y <span class="token operator">=</span> newY<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">double</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在C++11中，有两个限制使得Point的成员函数setX和setY无法声明为constexpr。</p>
<ol>
<li>首先，它们修改了操作对象。在C++11中，constexpr函数都隐式地被声明为const的了。<em>这里说的并非函数返回值的const属性，而是指成员函数的const饰词，这意味着该成员函数不能修改其操作对象（严格地说是不能修改其非mutable数据成员）。</em></li>
<li>其次，它们的返回型别是void。而在C++11中，void并不是个字面型别。</li>
</ol>
<p>不过这两个限制在C++14中都被解除了，所以在C++14中，就连设置器也可以声明为constexpr。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    <span class="token keyword">constexpr</span> <span class="token keyword">void</span> <span class="token function">setX</span><span class="token punctuation">(</span><span class="token keyword">double</span> newX<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> x <span class="token operator">=</span> newX<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// C++14</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">void</span> <span class="token function">setY</span><span class="token punctuation">(</span><span class="token keyword">double</span> newY<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> y <span class="token operator">=</span> newY<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// C++14</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="关于条款15的补充说明"><a href="#关于条款15的补充说明" class="headerlink" title="关于条款15的补充说明"></a>关于条款15的补充说明</h4><ul>
<li><p>所有constexpr对象都是const对象，而并非所有的const对象都是constexpr对象。如果你想让编译器提供保证，让变量拥有一个值，用于要求编译期常量的语境，那么能达到这个目的的工具是constexpr，而非const。</p>
</li>
<li><p>在C++11中，constexpr函数不得包含多于一个可执行语句，即一个return语句。在C++14中，限制条件大大地放宽了。</p>
</li>
</ul>
<h3 id="16-保证const成员函数的线程安全性"><a href="#16-保证const成员函数的线程安全性" class="headerlink" title="16. 保证const成员函数的线程安全性"></a>16. 保证const成员函数的线程安全性</h3><ol>
<li>保证const成员函数的线程安全性，除非可以确信它们不会用在并发语境中。</li>
<li>运用std::atomic型别的变量会比运用互斥量提供更好的性能，但前者仅适用对单个变量或内存区域的操作。</li>
</ol>
<h3 id="17-理解特种成员函数的生成机制"><a href="#17-理解特种成员函数的生成机制" class="headerlink" title="17. 理解特种成员函数的生成机制"></a>17. 理解特种成员函数的生成机制</h3><ol>
<li>特种成员函数是指那些C++会自行生成的成员函数：默认构造函数、析构函数、复制操作，以及移动操作。</li>
<li>移动操作仅当类中未包含用户显式声明的复制操作、移动操作和析构函数时才生成。</li>
<li>复制构造函数仅当类中不包含用户显示声明的复制构造函数时才生成，如果该类声明了移动操作则复制构造函数将被删除。复制赋值运算符仅当类中不包含用户显示声明的复制赋值运算符才生成，如果该类声明了移动操作则复制赋值运算符将被删除。在已经存在显式声明的析构函数的条件下，生成复制操作已经成为了被废弃的行为。</li>
<li>成员函数模板在任何情况下都不会抑制特种成员函数的生成。</li>
</ol>
<h4 id="大三律"><a href="#大三律" class="headerlink" title="大三律"></a>大三律</h4><p>如果你声明了复制构造函数、复制赋值运算符，或析构函数中的任何一个，你就得同时声明所有这三个。</p>
<p>它植根于这样的思想：如果有改写复制操作的需求，往往意味着该类需要执行某种资源管理，而这就意味着：</p>
<ol>
<li>在一种复制操作中进行的任何资源管理，也极有可能在另一种复制操作中也需要进行；</li>
<li>该类的析构函数也会参与到该资源的管理中（通常是释放之）。</li>
</ol>
<h4 id="移动操作的生成条件（如果需要生成）仅当一下三者同时成立"><a href="#移动操作的生成条件（如果需要生成）仅当一下三者同时成立" class="headerlink" title="移动操作的生成条件（如果需要生成）仅当一下三者同时成立"></a>移动操作的生成条件（如果需要生成）仅当一下三者同时成立</h4><ol>
<li><p>该类未声明任何复制操作</p>
<p> 声明复制操作（无论是复制构造还是复制赋值）的行为表明了对象的常规复制途径（按成员复制）对于该类并不适用。编译器从而判定，既然按成员复制不适用于复制操作，则按成员移动极有可能也不适用于移动操作。</p>
</li>
<li><p>该类未声明任何移动操作</p>
<p> 假设你声明了一个移动构造函数，你实际上表明移动操作的实现方式将会与编译器生成的默认按成员移动的移动构造函数多少有些不同。而若是按成员进行的移动构造操作有不合用之处的话，那么按成员进行的移动赋值运算符极有可能也会有不合用之处。</p>
</li>
<li><p>该类未声明任何析构函数</p>
<ul>
<li><a href="#大三律">大三律</a>的一个推论是，如果存在用户声明的析构函数，则平凡的（trivial）按成员复制的也不适用于该类。根据这个推论，又能得出进一步的结论，如果声明了析构函数，则复制操作就不该被自动生成，因为它们的行为不可能正确。不过在C++98标准被接受的时代，这样的论证过程没有得到充分的重视，所以在C++98中，用户声明的析构函数即使存在，也不会影响编译器生成复制操作的意愿。这种情况在C++11仍然得到了保持，但原因仅仅在于，如果要对复制操作的生成条件施加更严格的限制，就会破坏太多的遗留代码了。</li>
<li>由于<a href="#大三律">大三律</a>背后的理由仍然成立，再结合声明了复制操作就会阻止隐式生成移动操作的事实，就推动了C++11中的这样一个规定：只要用户声明了析构函数，就不会生成移动操作。</li>
</ul>
</li>
</ol>
<h4 id="关于条款17的补充说明"><a href="#关于条款17的补充说明" class="headerlink" title="关于条款17的补充说明"></a>关于条款17的补充说明</h4><ul>
<li>当移动操作在某个数据成员或基类部分上执行移动构造或移动赋值的时候，并不能保证移动操作真的会发生。“按成员移动”实际上更像是按成员的移动请求，因为那些不可移动的型别（即那些并未为移动操作提供特殊支持的型别，这包括了大多数C++98的遗留型别）将通过其复制操作实现“移动”。每个按成员进行的“移动”操作，其核心在于把std::move应用于每一个移动源对象，其返回值被用于函数重载决议，最终决定是执行一个移动还是复制操作，这个流程将在<a href="#23-理解std::move和std::forward">条款23</a>中详述。在本条款中，只需记住，按成员移动是由两部分组成，一部分是在支持移动操作的成员上执行移动操作，另一部分实在不支持移动操作的成员上执行复制操作。</li>
</ul>
<h2 id="四、智能指针"><a href="#四、智能指针" class="headerlink" title="四、智能指针"></a>四、智能指针</h2><h3 id="18-使用std-unique-ptr管理具备专属所有权的资源"><a href="#18-使用std-unique-ptr管理具备专属所有权的资源" class="headerlink" title="18. 使用std::unique_ptr管理具备专属所有权的资源"></a>18. 使用std::unique_ptr管理具备专属所有权的资源</h3><ol>
<li>std::unique_ptr是小巧、高速的、具备只移型别的智能指针，对托管资源实施专属所有权语义。</li>
<li>默认地，资源析构采用delete运算符来实现，但可以指定自定义删除器。有状态的删除器和采用函数指针实现的删除器会增加std::unique_ptr型别的对象尺寸。</li>
<li>将std::unique_ptr转换成std::shared_ptr是容易实现的。</li>
</ol>
<h3 id="19-使用std-shared-ptr管理具备共享所有权的资源"><a href="#19-使用std-shared-ptr管理具备共享所有权的资源" class="headerlink" title="19. 使用std::shared_ptr管理具备共享所有权的资源"></a>19. 使用std::shared_ptr管理具备共享所有权的资源</h3><ol>
<li>std::shared_ptr提供方便的手段，实现了任意资源在共享所有权语义下进行生命周期管理的垃圾回收。</li>
<li>与std::unique_ptr相比，std::shared_ptr的尺寸通常是裸指针尺寸的两倍，它还会带来控制块的开销，并要求原子化的引用技术操作。</li>
<li>默认的资源析构通过delete运算符进行，但同时也支持定制删除器。删除器的型别对std::shared_ptr的型别没有影响。</li>
<li>避免使用裸指针型别的变量来创建std::shared_ptr指针。</li>
</ol>
<h3 id="20-对于类似std-shared-ptr但有可能空悬的指针使用std-weak-ptr"><a href="#20-对于类似std-shared-ptr但有可能空悬的指针使用std-weak-ptr" class="headerlink" title="20. 对于类似std::shared_ptr但有可能空悬的指针使用std::weak_ptr"></a>20. 对于类似std::shared_ptr但有可能空悬的指针使用std::weak_ptr</h3><ol>
<li>使用std::weak_ptr来代替可能空悬的std::shared_ptr。</li>
<li>std::weak_ptr可能的用武之地包括缓存，观察者列表，以及避免std::shared_ptr指针环路。</li>
</ol>
<h3 id="21-优先选用std-make-unique和std-make-shared，而非直接使用new"><a href="#21-优先选用std-make-unique和std-make-shared，而非直接使用new" class="headerlink" title="21. 优先选用std::make_unique和std::make_shared，而非直接使用new"></a>21. 优先选用std::make_unique和std::make_shared，而非直接使用new</h3><ol>
<li>相比于直接使用new表达式，make系列函数消除了重复代码、改进了异常安全性，并且对于std::make_shared和std::allocated_shared而言，生成的目标代码会尺寸更小、速度更快。</li>
<li>不适于使用make系列函数的场景包括需要定制删除器，以及期望直接传递大括号初始化物。</li>
<li>对于std::shared_ptr，不建议使用make系列函数的额外场景包括：（1）自定义内存管理的类；（2）内存紧张的系统、非常大的对象、以及存在比指涉到相同对象的std::shared_ptr生存期更久的std::weak_ptr。</li>
</ol>
<h3 id="22-使用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中"><a href="#22-使用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中" class="headerlink" title="22. 使用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中"></a>22. 使用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中</h3><ol>
<li>Pimpl惯用法通过降低类的客户和类实现者之间的依赖性，减少了构建遍数。</li>
<li>对于采用std::unique_ptr来实现的pImpl指针，须在类的头文件中声明特种成员函数，但在实现文件中实现它们。即使默认函数实现有着正确行为，也必须这样做。</li>
<li>上述建议仅适用于std::unique_ptr，但并不使用std::shared_ptr。</li>
</ol>
<h2 id="五、右值引用、移动语义和完美转发"><a href="#五、右值引用、移动语义和完美转发" class="headerlink" title="五、右值引用、移动语义和完美转发"></a>五、右值引用、移动语义和完美转发</h2><p>在阅读本章中的条款时，一定要把这一点铭记在心：<strong>形参总是左值，即使其型别是右值引用。</strong>即，给定函数形如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>形参w是个左值。即使它的型别是个指涉到Widget型别对象的右值引用（如果你对此感觉意外，请参阅本书第一章就写着的关于左值和右值的概述）。</p>
<h3 id="23-理解std-move和std-forward"><a href="#23-理解std-move和std-forward" class="headerlink" title="23. 理解std::move和std::forward"></a>23. 理解std::move和std::forward</h3><ol>
<li>std::move实施的是无条件的向右值型别的强制型别转换。就其本身而言，它不会执行移动操作。</li>
<li>仅当传入的实参被绑定到右值时，std::forward才针对该实参实施向右值型别的强制型别转换。</li>
<li>在运行期，std::move和std::forward都不会做任何操作。</li>
</ol>
<h3 id="24-区分万能引用和右值引用"><a href="#24-区分万能引用和右值引用" class="headerlink" title="24. 区分万能引用和右值引用"></a>24. 区分万能引用和右值引用</h3><ol>
<li>如果函数模板形参具备T&amp;&amp;型别，并且T的型别系推导而来，或如果对象使用auto&amp;&amp;声明其型别，则该形参或对象就是个万能引用。</li>
<li>如果型别声明并不精确地具备type&amp;&amp;的形式，或者型别推导并未发生，则type&amp;&amp;就代表右值引用。</li>
<li>若采用右值来初始化万能引用，就会得到一个右值引用。若采用左值来初始化万能引用，就会得到一个左值引用。</li>
</ol>
<h3 id="25-针对右值引用实施std-move，针对万能引用实施std-forward"><a href="#25-针对右值引用实施std-move，针对万能引用实施std-forward" class="headerlink" title="25. 针对右值引用实施std::move，针对万能引用实施std::forward"></a>25. 针对右值引用实施std::move，针对万能引用实施std::forward</h3><ol>
<li>针对右值引用的最后一次使用实施std::move，针对万能引用的最后一次使用实施std::forward。</li>
<li>作为按值返回的函数的右值引用和万能引用，依上一条所述采取相同行为。</li>
<li>若局部对象可能适用于返回值优化，则请勿针对其实施std::move或std::forward。</li>
</ol>
<h4 id="RVO的条件"><a href="#RVO的条件" class="headerlink" title="RVO的条件"></a>RVO的条件</h4><ul>
<li><p>局部对象型别和函数返回值型别相同。</p>
  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Widget <span class="token function">makeWidget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Widget w<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  <code>std::move(w)</code>返回的不是局部对象w，而是w的引用，std::move(w)的结果。返回一个局部对象的引用并不满足实施RVO的前提条件，因此编译器必须把w移入函数的返回值存储位置。</p>
</li>
<li><p>返回的就是局部对象本身。</p>
</li>
</ul>
<p>即使实施RVO的前提条件满足，但编译器选择不执行复制省略的时候，返回对象必须作为右值处理。这么一来，就等于标准要求：<strong>当RVO的前提条件允许时，要么发生复制省略，要么std::move隐式地被实施于返回的局部对象上。</strong></p>
<h3 id="26-避免依万能引用型型别进行重载"><a href="#26-避免依万能引用型型别进行重载" class="headerlink" title="26. 避免依万能引用型型别进行重载"></a>26. 避免依万能引用型型别进行重载</h3><ol>
<li>把万能引用作为重载候选型别，几乎总会让该重载版本在始料未及的情况下被调用到。</li>
<li>完美转发构造函数的问题尤其严重，因为对于非常量的左值型别而言，它们一般都会形成相对于复制构造函数的更佳匹配，并且它们还会劫持派生类中对基类的复制和移动构造函数的调用。</li>
</ol>
<h3 id="27-熟悉依万能引用型别进行重载的替代方案"><a href="#27-熟悉依万能引用型别进行重载的替代方案" class="headerlink" title="27. 熟悉依万能引用型别进行重载的替代方案"></a>27. 熟悉依万能引用型别进行重载的替代方案</h3><ol>
<li>如果不使用万能引用和重载的组合，则替代方案包括使用彼此不同的函数名字、传递const T&amp;型别的形参、传值和标签分派。</li>
<li>经由std::enable_if对模板施加限制，就可以将万能引用和重载一起使用，不过这种技术控制了编译器可以调用到接受万能引用的重载版本的条件。</li>
<li>万能引用形参通常在性能方面具备优势，但在易用性方面一般会有劣势。</li>
</ol>
<h3 id="28-理解引用折叠"><a href="#28-理解引用折叠" class="headerlink" title="28. 理解引用折叠"></a>28. 理解引用折叠</h3><ol>
<li>引用折叠会在四种语境中发生：模板实例化，auto型别生成、创建和运用typedef和别名声明，以及decltype。</li>
<li>当编译器在引用折叠的语境下生成引用的引用时，结果会变成单个引用。如果原始的引用中有任一引用为左值引用，则结果为左值引用。否则，结果为右值引用。</li>
<li>万能引用就是在型别推导的过程中会区别左值和右值，以及会发生引用折叠的语境中的右值引用。</li>
</ol>
<h3 id="29-假定移动操作不存在、成本高、未使用"><a href="#29-假定移动操作不存在、成本高、未使用" class="headerlink" title="29. 假定移动操作不存在、成本高、未使用"></a>29. 假定移动操作不存在、成本高、未使用</h3><ol>
<li>假定移动操作不存在、成本高、未使用。</li>
<li>对于那些型别或对于移动语义的支持情况已知的代码，则无需作以上假定。</li>
</ol>
<h3 id="30-熟悉完美转发的失败情形"><a href="#30-熟悉完美转发的失败情形" class="headerlink" title="30. 熟悉完美转发的失败情形"></a>30. 熟悉完美转发的失败情形</h3><ol>
<li>完美转发的失败情形，是源于模板型别推导失败，或推导结果是错误的型别。</li>
<li>会导致完美转发失败的实参种类有大括号初始化物、以值0或NULL表达的空指针、仅有声明的整型static const成员变量、模板或重载的函数名字，以及位域。</li>
</ol>
<h2 id="六、lambda表达式"><a href="#六、lambda表达式" class="headerlink" title="六、lambda表达式"></a>六、lambda表达式</h2><h3 id="31-避免默认捕获模式"><a href="#31-避免默认捕获模式" class="headerlink" title="31. 避免默认捕获模式"></a>31. 避免默认捕获模式</h3><ol>
<li>按引用的默认捕获会导致空悬指针问题。</li>
<li>按值的默认捕获极易受空悬指针影响（尤其是this），并会误导人们认为lambda式是自洽的。</li>
</ol>
<h3 id="32-使用初始化捕获将对象移入闭包"><a href="#32-使用初始化捕获将对象移入闭包" class="headerlink" title="32. 使用初始化捕获将对象移入闭包"></a>32. 使用初始化捕获将对象移入闭包</h3><ol>
<li>使用C++14的初始化捕获将对象移入闭包。</li>
<li>在C++11中，经由手工实现的类或std::bind去模拟初始化捕获。</li>
</ol>
<h3 id="33-对auto-amp-amp-型别的形参使用decltype，以std-forward之"><a href="#33-对auto-amp-amp-型别的形参使用decltype，以std-forward之" class="headerlink" title="33. 对auto&amp;&amp;型别的形参使用decltype，以std::forward之"></a>33. 对auto&amp;&amp;型别的形参使用decltype，以std::forward之</h3><ol>
<li><p>对auto&amp;&amp;型别的形参使用decltype，以std::forward之。</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token function">normalize</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<h3 id="34-优先选用lambda式，而非std-bind"><a href="#34-优先选用lambda式，而非std-bind" class="headerlink" title="34. 优先选用lambda式，而非std::bind"></a>34. 优先选用lambda式，而非std::bind</h3><ol>
<li>lambda式比起使用std::bind而言，可读性更好、表达力更强，可能运行效率也更高。</li>
<li>仅在C++11中，std::bind在实现移动捕获，或是绑定到具备模板化的函数调用运算符的对象的场合中，可能尚有余热可以发挥。</li>
</ol>
<h2 id="七、并发API"><a href="#七、并发API" class="headerlink" title="七、并发API"></a>七、并发API</h2><h3 id="35-优先选用基于任务而非基于线程的程序设计"><a href="#35-优先选用基于任务而非基于线程的程序设计" class="headerlink" title="35. 优先选用基于任务而非基于线程的程序设计"></a>35. 优先选用基于任务而非基于线程的程序设计</h3><ol>
<li>std::thread的API未提供直接获取异步运行函数返回值的途径，而且如果那些函数抛出异常，程序就会终止。</li>
<li>基于线程的程序设计要求手动管理线程耗尽、超订、负载均衡，以及新平台适配。</li>
<li>经由应用了默认启动策略的std::async进行基于任务的程序设计，大部分这类问题都能找到解决知道。</li>
</ol>
<h3 id="36-如果异步是必要的，则指定std-launch-async"><a href="#36-如果异步是必要的，则指定std-launch-async" class="headerlink" title="36. 如果异步是必要的，则指定std::launch::async"></a>36. 如果异步是必要的，则指定std::launch::async</h3><ol>
<li>std::async的默认启动策略既允许任务异步方式执行，也允许任务以同步方式执行。</li>
<li>如此的弹性会导致使用thread_local变量时的不确定性，隐含着任务可能永远不会执行，还会影响运用了基于超时的wait调用的程序逻辑。</li>
<li>如果异步是必要的，则指定std::launch::async。</li>
</ol>
<h3 id="37-使std-thread型别对象在所有路径皆不可联结（unjoinable）"><a href="#37-使std-thread型别对象在所有路径皆不可联结（unjoinable）" class="headerlink" title="37. 使std::thread型别对象在所有路径皆不可联结（unjoinable）"></a>37. 使std::thread型别对象在所有路径皆不可联结（unjoinable）</h3><ol>
<li>使std::thread型别对象在所有路径皆不可联结。</li>
<li>在析构时调用join可能导致难以调试的性能异常。</li>
<li>在析构时调用detach可能导致难以调试的未定义行为。</li>
<li>在成员列表的最后声明std::thread型别对象。</li>
</ol>
<h4 id="不可联结的std-thread型别对象"><a href="#不可联结的std-thread型别对象" class="headerlink" title="不可联结的std::thread型别对象"></a>不可联结的std::thread型别对象</h4><ol>
<li><strong>默认构造的std::thread。</strong> 此类std::thread没有可以执行的函数，因此也没有对应的底层执行线程。</li>
<li><strong>已移动的std::thread。</strong> 移动操作的结果是，一个std::thread所对应的底层执行线程（若有）被对应到另一个std::thread。</li>
<li><strong>已联结的std::thread。</strong> 联结后，std::thread型别对象不在对应至已结束运行的底层执行线程。</li>
<li><strong>已分离的std::thread。</strong> 分离操作会把std::thread型别对象和它对应的底层执行线程之间的连接断开。</li>
</ol>
<h4 id="关于条款37的补充说明"><a href="#关于条款37的补充说明" class="headerlink" title="关于条款37的补充说明"></a>关于条款37的补充说明</h4><ul>
<li>如果可联结线程对象的析构函数被调用，则程序的执行就终止了。</li>
</ul>
<h3 id="38-对变化多端的线程句柄析构函数行为保持关注"><a href="#38-对变化多端的线程句柄析构函数行为保持关注" class="headerlink" title="38. 对变化多端的线程句柄析构函数行为保持关注"></a>38. 对变化多端的线程句柄析构函数行为保持关注</h3><ol>
<li>期值（std::future/std::shared_future）的析构函数在常规情况下，仅会析构期值的成员变量。</li>
<li>指涉到经由std::async启动的未推迟任务的共享状态的最后一个期值会保持阻塞，直至该任务结束。</li>
</ol>
<h3 id="39-考虑针对一次性事件通信使用以void为模板型别实参的期值"><a href="#39-考虑针对一次性事件通信使用以void为模板型别实参的期值" class="headerlink" title="39. 考虑针对一次性事件通信使用以void为模板型别实参的期值"></a>39. 考虑针对一次性事件通信使用以void为模板型别实参的期值</h3><ol>
<li>如果仅为了实现平凡事件通信，基于条件变量的设计会要求多余的互斥量，这会给相互关联的检测和反应任务带来约束，并要求反应任务校验事件确已发生。</li>
<li>使用标志位的设计可以避免上述问题，但这一设计基于轮训而非阻塞。</li>
<li>条件变量和标志位可以一起使用，但这样的通信机制设计结果不甚自然。</li>
<li>使用std::promise型别对象和期值就可以回避这些问题，但是一来这个途径为了共享状态需要使用堆内存，而且仅限于一次性通信。</li>
</ol>
<h3 id="40-对并发使用std-atomic，对特种内存使用volatile"><a href="#40-对并发使用std-atomic，对特种内存使用volatile" class="headerlink" title="40. 对并发使用std::atomic，对特种内存使用volatile"></a>40. 对并发使用std::atomic，对特种内存使用volatile</h3><ol>
<li>std::atomic用于多线程访问的数据，且不用互斥量。它是撰写并发软件的工具。</li>
<li><p>volatile用于读写操作不可以被优化掉的内存。它是在面对特种内存时使用的工具。</p>
<p> 给y加上volatile可以避免编译器将代码：</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">y</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
y<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 优化成：</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">register</span> <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token keyword">register</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
y<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token keyword">register</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<h2 id="八、微调"><a href="#八、微调" class="headerlink" title="八、微调"></a>八、微调</h2><h3 id="41-针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递"><a href="#41-针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递" class="headerlink" title="41. 针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递"></a>41. 针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递</h3><ol>
<li>对于可复制的、在移动成本低廉的并且一定会被复制的形参而言，按值传递可能会和按引用传递的具备相近的效率，并且可能生成更少量的目标代码。</li>
<li>经由构造复制形参的成本可能比经由赋值复制形参高出很多。</li>
<li>按值传递肯定会导致切片问题，所以基类型别特别不适用于按值传递。</li>
</ol>
<h3 id="42-考虑置入而非插入"><a href="#42-考虑置入而非插入" class="headerlink" title="42. 考虑置入而非插入"></a>42. 考虑置入而非插入</h3><ol>
<li>从原理上说，置入函数（如：emplace_back）应该有时比对应的插入函数（如：push_back）高效，而且不应该有更低效的可能。</li>
<li>从实践上说，置入函数在以下几个前提成立时，极有可能会运行得更快：（1）待添加的值是以构造而非赋值方式加入容器；（2）传递的实参型别与容器持有之物的型别不同；（3）容器不会由于存在重复值而拒绝待添加的值。</li>
<li><p>置入函数可能会执行在插入函数中会被拒绝的型别转换。</p>
<p> 复制初始化是不允许调用带有explicit声明饰词的构造函数的，但直接初始化就允许。</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token operator">::</span>regex r1 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    <span class="token comment">// 错误！无法通过编译 （复制初始化）</span>
std<span class="token operator">::</span>regex <span class="token function">r2</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 能编译 （直接初始化）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
</ol>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://kibazen.cn" rel="external nofollow noreferrer">Kiba Amor</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                    </span>
                <span class="reprint-info">
                    <a href="https://kibazen.cn/effective-modern-c-du-shu-bi-ji/">https://kibazen.cn/effective-modern-c-du-shu-bi-ji/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY-NC-ND 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://kibazen.cn" target="_blank">Kiba Amor</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/CPP/">
                                    <span class="chip bg-color">CPP</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="qq,wechat,weibo,douban" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/jie-jue-ubuntu-bo-fang-sheng-yin-qia-dun-he-bao-yin/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/0.jpg" class="responsive-img" alt="解决Ubuntu播放声音卡顿和爆音">
                        
                        <span class="card-title">解决Ubuntu播放声音卡顿和爆音</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-08-13
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Linux/" class="post-category">
                                    Linux
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Ubuntu/">
                        <span class="chip bg-color">Ubuntu</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/tcp-mo-xing-xie-yi-zhuang-tai-ji-su-lan/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/22.jpg" class="responsive-img" alt="TCP模型协议状态机速览">
                        
                        <span class="card-title">TCP模型协议状态机速览</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-05-11
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E7%BD%91%E7%BB%9C/" class="post-category">
                                    网络
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/TCP%E7%8A%B6%E6%80%81%E6%9C%BA/">
                        <span class="chip bg-color">TCP状态机</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (true) {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 木叶禅<br />'
            + '文章作者: Kiba Amor<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者木叶禅所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('2'),
            headingSelector: 'h2, h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2021</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">Kiba Amor</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">487.7k</span>&nbsp;字
            
            
            
            
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/kibaamor" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>









    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=562236616" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 562236616" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>





    <a href="https://www.zhihu.com/people/kibaamor" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/kibaamor" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    

    

    

	
    

    

    

    
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
