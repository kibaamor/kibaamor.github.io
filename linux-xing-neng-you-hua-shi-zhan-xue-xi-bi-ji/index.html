<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <meta name="keywords" content="《Linux性能优化实战》学习笔记, kiba, zen, amor, kibazen, kibaamor, 木叶, 木叶禅">
    <meta name="description" content="一个普通游戏程序员的博客">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>《Linux性能优化实战》学习笔记 | 木叶禅</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/css/my.css">

    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="木叶禅" type="application/atom+xml">
</head>



   <style>
    body{
       background-image: url(/medias/background.jpg);
       background-repeat:no-repeat;
       background-size:cover;
       background-attachment:fixed;
    }
</style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">木叶禅</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/leetcode/" class="waves-effect waves-light">
      
      <i class="fas fa-code" style="zoom: 0.6;"></i>
      
      <span>LeetCode</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/learn/" class="waves-effect waves-light">
      
      <i class="fas fa-book" style="zoom: 0.6;"></i>
      
      <span>学习</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/softwares/" class="waves-effect waves-light">
      
      <i class="fas fa-toolbox" style="zoom: 0.6;"></i>
      
      <span>软件</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories/" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags/" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about/" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">木叶禅</div>
        <div class="logo-desc">
            
            一个普通游戏程序员的博客
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/leetcode/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-code"></i>
			
			LeetCode
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/learn/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-book"></i>
			
			学习
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/softwares/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-toolbox"></i>
			
			软件
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    
<script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = 'f65e070788a2647953051a7a1b70ada7fd2b3f70cd4d93c977207f5b762987d4';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/7.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">《Linux性能优化实战》学习笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/">
                                <span class="chip bg-color">性能分析</span>
                            </a>
                        
                            <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                                <span class="chip bg-color">极客时间</span>
                            </a>
                        
                            <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">
                                <span class="chip bg-color">性能优化</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                学习笔记
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-11-04
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2021-11-05
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    35.9k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    140 分
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="01-开篇词"><a href="#01-开篇词" class="headerlink" title="01 开篇词"></a><strong>01 开篇词</strong></h2><h3 id="01-如何学习Linux性能优化？"><a href="#01-如何学习Linux性能优化？" class="headerlink" title="01 | 如何学习Linux性能优化？"></a>01 | 如何学习Linux性能优化？</h3><h4 id="1-1-性能指标是什么？"><a href="#1-1-性能指标是什么？" class="headerlink" title="1.1 性能指标是什么？"></a>1.1 性能指标是什么？</h4><p>性能分析，其实就是找出应用或系统的瓶颈，并设法去避免或者缓解它们，从而更高效地利用系统资源处理更多的请求。这包含了一系列的步骤，比如下面这六个步骤：</p>
<ol>
<li>选择指标评估应用程序和系统的性能；</li>
<li>为应用程序和系统设置性能目标；</li>
<li>进行性能基准测试；</li>
<li>性能分析定位瓶颈；</li>
<li>优化系统和应用程序；</li>
<li>性能监控和告警。</li>
</ol>
<h4 id="1-2-学习的重点是什么？"><a href="#1-2-学习的重点是什么？" class="headerlink" title="1.2 学习的重点是什么？"></a>1.2 学习的重点是什么？</h4><p>想要学习好性能分析和优化，建立整体系统性能的全局观是最核心的话题。因而，</p>
<ul>
<li>理解最基本的几个系统知识原理；</li>
<li>掌握必要的性能工具；</li>
<li>通过实际的场景演练，贯穿不同的组件。</li>
</ul>
<p>千万不要把性能工具当成学习的全部。工具只是解决问题的手段，关键在于你的用法。只有真正理解了它们背后的原理，并且结合具体场景，融会贯通系统的不同组件，你才能真正掌握它们。</p>
<p><img src="/images/《Linux性能优化实战》学习笔记/Linux性能优化实战思维导图.png" alt="Linux性能优化实战思维导图"></p>
<h4 id="1-3-怎么学更高效？"><a href="#1-3-怎么学更高效？" class="headerlink" title="1.3 怎么学更高效？"></a>1.3 怎么学更高效？</h4><ul>
<li>虽然系统的原理很重要，但在刚开始一定不要试图抓住所有的实现细节。</li>
<li>边学边实践，通过大量的案例演习掌握 Linux 性能的分析和优化。</li>
<li>勤思考，多反思，善总结，多问为什么。</li>
</ul>
<h2 id="02-CPU-性能篇"><a href="#02-CPU-性能篇" class="headerlink" title="02 CPU 性能篇"></a><strong>02 CPU 性能篇</strong></h2><h3 id="02-基础篇：到底应该怎么理解“平均负载”？"><a href="#02-基础篇：到底应该怎么理解“平均负载”？" class="headerlink" title="02 | 基础篇：到底应该怎么理解“平均负载”？"></a>02 | 基础篇：到底应该怎么理解“平均负载”？</h3><h4 id="2-1-平均负载"><a href="#2-1-平均负载" class="headerlink" title="2.1 平均负载"></a>2.1 平均负载</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">uptime</span>
02:34:03 up <span class="token number">2</span> days, <span class="token number">20</span>:14,  <span class="token number">1</span> user,  load average: <span class="token number">0.63</span>, <span class="token number">0.83</span>, <span class="token number">0.88</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>输出结果分别是：系统当前时间、系统运行时间、登录用户数、系统过去 1 分钟、5 分钟、15 分钟的平均负载（Load Average）。</p>
<p>关于平均负载的解释可以查看 <code>man uptime</code>。</p>
<p>平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数。</p>
<ul>
<li>可运行状态的进程，是指正在使用 CPU 或者正在等待 CPU 的进程，也就是我们常用 ps 命令看到的，处于 R 状态（Running 或 Runnable）的进程。</li>
<li>不可中断状态的进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应，也就是我们在 ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程。<blockquote>
<p>比如，当一个进程向磁盘读写数据时，为了保证数据的一致性，在得到磁盘回复前，它是不能被其他进程或者中断打断的，这个时候的进程就处于不可中断状态。<br>不可中断状态实际上是系统对进程和硬件设备的一种保护机制。</p>
</blockquote>
</li>
</ul>
<p>可以简单理解为，平均负载其实就是平均活跃进程数。平均活跃进程数，直观上的理解就是单位时间内的活跃进程数，但它实际上是活跃进程数的指数衰减平均值。</p>
<h4 id="2-2-平均负载为多少时合理"><a href="#2-2-平均负载为多少时合理" class="headerlink" title="2.2 平均负载为多少时合理"></a>2.2 平均负载为多少时合理</h4><p>平均负载最理想的情况是等于 CPU 个数。</p>
<p>分析系统负载趋势：</p>
<ul>
<li>如果 1 分钟、5 分钟、15 分钟的三个值基本相同，或者相差不大，那就说明系统负载很平稳。</li>
<li>但如果 1 分钟的值远小于 15 分钟的值，就说明系统最近 1 分钟的负载在减少，而过去 15 分钟内却有很大的负载。</li>
<li>反过来，如果 1 分钟的值远大于 15 分钟的值，就说明最近 1 分钟的负载在增加，这种增加有可能只是临时性的，也有可能还会持续增加下去，所以就需要持续观察。一旦 1 分钟的平均负载接近或超过了 CPU 的个数，就意味着系统正在发生过载的问题，这时就得分析调查是哪里导致的问题，并要想办法优化了。</li>
</ul>
<p>在实际生产环境中，当平均负载高于 CPU 数量 70% 的时候，就应该分析排查负载高的问题了。</p>
<h4 id="2-3-平均负载与-CPU-使用率"><a href="#2-3-平均负载与-CPU-使用率" class="headerlink" title="2.3 平均负载与 CPU 使用率"></a>2.3 平均负载与 CPU 使用率</h4><p>平均负载是指单位时间内，处于可运行状态和不可中断状态的进程数。所以，它不仅包括了正在使用 CPU 的进程，还包括等待 CPU 和等待 I/O 的进程。</p>
<p>CPU 使用率，是单位时间内 CPU 繁忙情况的统计，跟平均负载并不一定完全对应。比如：</p>
<ul>
<li>CPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时这两者是一致的；</li>
<li>I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高；</li>
<li>大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高。</li>
</ul>
<h4 id="2-4-平均负载案例分析"><a href="#2-4-平均负载案例分析" class="headerlink" title="2.4 平均负载案例分析"></a>2.4 平均负载案例分析</h4><blockquote>
<p>机器配置：2 CPU，8GB 内存。</p>
<p>安装软件：<code>apt install stress sysstat</code>。</p>
</blockquote>
<p>观察测试前的平均负载</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">uptime</span>
<span class="token punctuation">..</span>.,  load average: <span class="token number">0.11</span>, <span class="token number">0.15</span>, <span class="token number">0.09</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ol>
<li><p>场景一：CPU 密集型进程</p>
<ol>
<li><p>模拟高 CPU 使用率</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ stress --cpu <span class="token number">1</span> --timeout <span class="token number">600</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>在第二个终端运行 uptime 查看平均负载的变化情况</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -d 参数表示高亮显示变化的区域</span>
$ <span class="token function">watch</span> -d <span class="token function">uptime</span>
<span class="token punctuation">..</span>.,  load average: <span class="token number">1.00</span>, <span class="token number">0.75</span>, <span class="token number">0.39</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li><p>在第三个终端运行 mpstat 查看 CPU 使用率的变化情况</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -P ALL 表示监控所有 CPU，后面数字 5 表示间隔 5 秒后输出一组数据</span>
$ mpstat -P ALL <span class="token number">5</span>
Linux <span class="token number">4.15</span>.0 <span class="token punctuation">(</span>ubuntu<span class="token punctuation">)</span> 09/22/18 _x86_64_ <span class="token punctuation">(</span><span class="token number">2</span> CPU<span class="token punctuation">)</span>
<span class="token number">13</span>:30:06     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
<span class="token number">13</span>:30:11     all   <span class="token number">50.05</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">49.95</span>
<span class="token number">13</span>:30:11       <span class="token number">0</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>  <span class="token number">100.00</span>
<span class="token number">13</span>:30:11       <span class="token number">1</span>  <span class="token number">100.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 可以看到，1 分钟的平均负载会慢慢增加到 1.00，而从终端三中还可以看到，正好有一个 CPU 的使用率为 100%，但它的 iowait 只有 0。这说明，平均负载的升高正是由于 CPU 使用率为 100% 。</p>
</li>
<li><p>到底是哪个进程导致了 CPU 使用率为 100% 呢？你可以使用 pidstat 来查询</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 间隔 5 秒后输出一组数据</span>
$ pidstat -u <span class="token number">5</span> <span class="token number">1</span>
<span class="token number">13</span>:37:07      <span class="token environment constant">UID</span>       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
<span class="token number">13</span>:37:12        <span class="token number">0</span>      <span class="token number">2962</span>  <span class="token number">100.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>  <span class="token number">100.00</span>     <span class="token number">1</span>  stress<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p> 可以明显看到，stress 进程的 CPU 使用率为 100%。</p>
</li>
</ol>
</li>
<li><p>场景二：I/O 密集型进程</p>
<ol>
<li><p>模拟 I/O 压力，即不停地执行 sync</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">stress -i <span class="token number">1</span> --timeout <span class="token number">600</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>在第二个终端运行 uptime 查看平均负载的变化情况</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">watch</span> -d <span class="token function">uptime</span>
<span class="token punctuation">..</span>.,  load average: <span class="token number">1.06</span>, <span class="token number">0.58</span>, <span class="token number">0.37</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li><p>在第三个终端运行 mpstat 查看 CPU 使用率的变化情况</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 显示所有 CPU 的指标，并在间隔 5 秒输出一组数据</span>
$ mpstat -P ALL <span class="token number">5</span> <span class="token number">1</span>
Linux <span class="token number">4.15</span>.0 <span class="token punctuation">(</span>ubuntu<span class="token punctuation">)</span>     09/22/18     _x86_64_    <span class="token punctuation">(</span><span class="token number">2</span> CPU<span class="token punctuation">)</span>
<span class="token number">13</span>:41:28     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
<span class="token number">13</span>:41:33     all    <span class="token number">0.21</span>    <span class="token number">0.00</span>   <span class="token number">12.07</span>   <span class="token number">32.67</span>    <span class="token number">0.00</span>    <span class="token number">0.21</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">54.84</span>
<span class="token number">13</span>:41:33       <span class="token number">0</span>    <span class="token number">0.43</span>    <span class="token number">0.00</span>   <span class="token number">23.87</span>   <span class="token number">67.53</span>    <span class="token number">0.00</span>    <span class="token number">0.43</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">7.74</span>
<span class="token number">13</span>:41:33       <span class="token number">1</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.81</span>    <span class="token number">0.20</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">98.99</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 可以看到，1 分钟的平均负载会慢慢增加到 1.06，其中一个 CPU 的系统 CPU 使用率升高到了 23.87，而 iowait 高达 67.53%。这说明，平均负载的升高是由于 iowait 的升高。</p>
</li>
<li><p>那么到底是哪个进程，导致 iowait 这么高呢？用 pidstat 来查询</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 间隔 5 秒后输出一组数据，-u 表示 CPU 指标</span>
$ pidstat -u <span class="token number">5</span> <span class="token number">1</span>
Linux <span class="token number">4.15</span>.0 <span class="token punctuation">(</span>ubuntu<span class="token punctuation">)</span>     09/22/18     _x86_64_    <span class="token punctuation">(</span><span class="token number">2</span> CPU<span class="token punctuation">)</span>
<span class="token number">13</span>:42:08      <span class="token environment constant">UID</span>       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
<span class="token number">13</span>:42:13        <span class="token number">0</span>       <span class="token number">104</span>    <span class="token number">0.00</span>    <span class="token number">3.39</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">3.39</span>     <span class="token number">1</span>  kworker/1:1H
<span class="token number">13</span>:42:13        <span class="token number">0</span>       <span class="token number">109</span>    <span class="token number">0.00</span>    <span class="token number">0.40</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.40</span>     <span class="token number">0</span>  kworker/0:1H
<span class="token number">13</span>:42:13        <span class="token number">0</span>      <span class="token number">2997</span>    <span class="token number">2.00</span>   <span class="token number">35.53</span>    <span class="token number">0.00</span>    <span class="token number">3.99</span>   <span class="token number">37.52</span>     <span class="token number">1</span>  stress
<span class="token number">13</span>:42:13        <span class="token number">0</span>      <span class="token number">3057</span>    <span class="token number">0.00</span>    <span class="token number">0.40</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.40</span>     <span class="token number">0</span>  pidstat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 可以发现，还是 stress 进程导致的。</p>
</li>
</ol>
</li>
<li><p>场景三：大量进程的场景</p>
<p> 当系统中运行进程超出 CPU 运行能力时，就会出现等待 CPU 的进程。</p>
<ol>
<li><p>使用 stress 模拟的是 8 个进程</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ stress -c <span class="token number">8</span> --timeout <span class="token number">600</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>由于系统只有 2 个 CPU，明显比 8 个进程要少得多，因而，系统的 CPU 处于严重过载状态，平均负载高达 7.97。</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">uptime</span>
<span class="token punctuation">..</span>.,  load average: <span class="token number">7.97</span>, <span class="token number">5.93</span>, <span class="token number">3.02</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li><p>接着再运行 pidstat 来看一下进程的情况</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 间隔 5 秒后输出一组数据</span>
$ pidstat -u <span class="token number">5</span> <span class="token number">1</span>
<span class="token number">14</span>:23:25      <span class="token environment constant">UID</span>       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
<span class="token number">14</span>:23:30        <span class="token number">0</span>      <span class="token number">3190</span>   <span class="token number">25.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">74.80</span>   <span class="token number">25.00</span>     <span class="token number">0</span>  stress
<span class="token number">14</span>:23:30        <span class="token number">0</span>      <span class="token number">3191</span>   <span class="token number">25.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">75.20</span>   <span class="token number">25.00</span>     <span class="token number">0</span>  stress
<span class="token number">14</span>:23:30        <span class="token number">0</span>      <span class="token number">3192</span>   <span class="token number">25.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">74.80</span>   <span class="token number">25.00</span>     <span class="token number">1</span>  stress
<span class="token number">14</span>:23:30        <span class="token number">0</span>      <span class="token number">3193</span>   <span class="token number">25.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">75.00</span>   <span class="token number">25.00</span>     <span class="token number">1</span>  stress
<span class="token number">14</span>:23:30        <span class="token number">0</span>      <span class="token number">3194</span>   <span class="token number">24.80</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">74.60</span>   <span class="token number">24.80</span>     <span class="token number">0</span>  stress
<span class="token number">14</span>:23:30        <span class="token number">0</span>      <span class="token number">3195</span>   <span class="token number">24.80</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">75.00</span>   <span class="token number">24.80</span>     <span class="token number">0</span>  stress
<span class="token number">14</span>:23:30        <span class="token number">0</span>      <span class="token number">3196</span>   <span class="token number">24.80</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">74.60</span>   <span class="token number">24.80</span>     <span class="token number">1</span>  stress
<span class="token number">14</span>:23:30        <span class="token number">0</span>      <span class="token number">3197</span>   <span class="token number">24.80</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">74.80</span>   <span class="token number">24.80</span>     <span class="token number">1</span>  stress
<span class="token number">14</span>:23:30        <span class="token number">0</span>      <span class="token number">3200</span>    <span class="token number">0.00</span>    <span class="token number">0.20</span>    <span class="token number">0.00</span>    <span class="token number">0.20</span>    <span class="token number">0.20</span>     <span class="token number">0</span>  pidstat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 可以看出，8 个进程在争抢 2 个 CPU，每个进程等待 CPU 的时间（也就是代码块中的 %wait 列）高达 75%。这些超出 CPU 计算能力的进程，最终导致 CPU 过载。</p>
</li>
</ol>
</li>
</ol>
<h4 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h4><p>平均负载提供了一个快速查看系统整体性能的手段，反映了整体的负载情况。但只看平均负载本身，我们并不能直接发现，到底是哪里出现了瓶颈。所以，在理解平均负载时，也要注意：</p>
<ul>
<li>平均负载高有可能是 CPU 密集型进程导致的；</li>
<li>平均负载高并不一定代表 CPU 使用率高，还有可能是 I/O 更繁忙了；</li>
<li>当发现负载高的时候，你可以使用 mpstat、pidstat 等工具，辅助分析负载的来源。</li>
</ul>
<h3 id="03-基础篇：经常说的-CPU-上下文切换是什么意思？（上）"><a href="#03-基础篇：经常说的-CPU-上下文切换是什么意思？（上）" class="headerlink" title="03 | 基础篇：经常说的 CPU 上下文切换是什么意思？（上）"></a>03 | 基础篇：经常说的 CPU 上下文切换是什么意思？（上）</h3><p>进程在竞争 CPU 的时候并没有真正运行，但是 CPU 上下文切换会导致系统的负载升高。</p>
<p>根据任务的不同，CPU 的上下文切换就可以分为几个不同的场景，也就是进程上下文切换、线程上下文切换以及中断上下文切换。</p>
<h4 id="3-1-进程上下文切换"><a href="#3-1-进程上下文切换" class="headerlink" title="3.1 进程上下文切换"></a>3.1 进程上下文切换</h4><ol>
<li><p>系统调用</p>
<p> 系统调用的过程会发生 CPU 上下文。</p>
<p> CPU 寄存器里原来用户态的指令位置，需要先保存起来。接着，为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务。</p>
<p> 而系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。所以，一次系统调用的过程，其实是发生了两次 CPU 上下文切换。</p>
<p> 需要注意的是，系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程。这跟我们通常所说的进程上下文切换是不一样的：</p>
<ul>
<li>进程上下文切换，是指从一个进程切换到另一个进程运行。</li>
<li><p>而系统调用过程中一直是同一个进程在运行。</p>
<p><strong>所以，系统调用过程通常称为特权模式切换，而不是上下文切换。</strong></p>
</li>
</ul>
</li>
<li><p>进程上下文切换跟系统调用又有什么区别呢？</p>
<p> 进程是由内核来管理和调度的，进程的切换只能发生在内核态。所以，进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。</p>
<p> 因此，进程的上下文切换就比系统调用时多了一步：在保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进程的虚拟内存、栈等保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。</p>
<p> <img src="/images/《Linux性能优化实战》学习笔记/进程上下文切换.png" alt="进程上下文切换"></p>
<p> 根据 <a target="_blank" rel="noopener" href="https://blog.tsunanet.net/2010/11/how-long-does-it-take-to-make-context.html">How long does it take to make a context switch?</a> 的测试报告，每次上下文切换都需要几十纳秒到数微秒的 CPU 时间。</p>
<p> 另外， Linux 通过 TLB（Translation Lookaside Buffer）来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，TLB 也需要刷新，内存的访问也会随之变慢。特别是在多处理器系统上，缓存是被多个处理器共享的，刷新缓存不仅会影响当前处理器的进程，还会影响共享缓存的其他处理器的进程。</p>
</li>
<li><p>进程在什么时候才会被调度到 CPU 上运行呢？</p>
<ol>
<li>进程执行完终止了，它之前使用的 CPU 会释放出来，这个时候再从就绪队列里，拿一个新的进程过来运行。</li>
<li>当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行。</li>
<li>进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。</li>
<li>当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度。</li>
<li>当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。</li>
<li>发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。</li>
</ol>
</li>
</ol>
<h4 id="3-2-线程上下文切换"><a href="#3-2-线程上下文切换" class="headerlink" title="3.2 线程上下文切换"></a>3.2 线程上下文切换</h4><p>线程与进程最大的区别在于，<strong>线程是调度的基本单位，而进程则是资源拥有的基本单位</strong> 。内核中的任务调度，实际上的调度对象是线程；而进程只是给线程提供了虚拟内存、全局变量等资源。所以，对于线程和进程，可以这么理解：</p>
<ul>
<li>当进程只有一个线程时，可以认为进程就等于线程。</li>
<li>当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。</li>
<li>另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。</li>
</ul>
<p>这么一来，线程的上下文切换其实就可以分为两种情况：</p>
<ol>
<li>前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。</li>
<li>前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。</li>
</ol>
<p>虽然同为上下文切换，但同进程内的线程切换，要比多进程间的切换消耗更少的资源，而这，也正是多线程代替多进程的一个优势。</p>
<h4 id="3-3-中断上下文切换"><a href="#3-3-中断上下文切换" class="headerlink" title="3.3 中断上下文切换"></a>3.3 中断上下文切换</h4><p>为了快速响应硬件的事件，<strong>中断处理会打断进程的正常调度和执行</strong>，转而调用中断处理程序，响应设备事件。</p>
<p>跟进程上下文不同，中断上下文切换并不涉及到进程的用户态。所以，即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等。</p>
<p>对同一个 CPU 来说，中断处理比进程拥有更高的优先级，所以中断上下文切换并不会与进程上下文切换同时发生。</p>
<h3 id="04-基础篇：经常说的-CPU-上下文切换是什么意思？（下）"><a href="#04-基础篇：经常说的-CPU-上下文切换是什么意思？（下）" class="headerlink" title="04 | 基础篇：经常说的 CPU 上下文切换是什么意思？（下）"></a>04 | 基础篇：经常说的 CPU 上下文切换是什么意思？（下）</h3><h4 id="4-1-怎么查看系统的上下文切换情况"><a href="#4-1-怎么查看系统的上下文切换情况" class="headerlink" title="4.1 怎么查看系统的上下文切换情况"></a>4.1 怎么查看系统的上下文切换情况</h4><ol>
<li><p>查看系统总体的上下文切换情况</p>
<p> vmstat 是一个常用的系统性能分析工具，主要用来分析系统的内存使用情况，也常用来分析 CPU 上下文切换和中断的次数。</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 每隔 5 秒输出 1 组数据</span>
$ <span class="token function">vmstat</span> <span class="token number">5</span>
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   <span class="token function">free</span>   buff  cache   si   so    bi    bo   <span class="token keyword">in</span>   cs us sy <span class="token function">id</span> wa st
 <span class="token number">0</span>  <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">7005360</span>  <span class="token number">91564</span> <span class="token number">818900</span>    <span class="token number">0</span>    <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">0</span>   <span class="token number">25</span>   <span class="token number">33</span>  <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">100</span>  <span class="token number">0</span>  <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 特别关注下面几列信息：</p>
<ul>
<li>cs（context switch）是每秒上下文切换的次数。</li>
<li>in（interrupt）则是每秒中断的次数。</li>
<li>r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待 CPU 的进程数。</li>
<li>b（Blocked）则是处于不可中断睡眠状态的进程数。</li>
</ul>
</li>
<li><p>查看每个进程的上下文切换情况</p>
<p> vmstat 只给出了系统总体的上下文切换情况，要想查看每个进程的详细情况，就需要使用我们前面提到过的 pidstat 了。给它加上 -w 选项，你就可以查看每个进程上下文切换的情况了。</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 每隔 5 秒输出 1 组数据</span>
$ pidstat -w <span class="token number">5</span>
Linux <span class="token number">4.15</span>.0 <span class="token punctuation">(</span>ubuntu<span class="token punctuation">)</span>  09/23/18  _x86_64_  <span class="token punctuation">(</span><span class="token number">2</span> CPU<span class="token punctuation">)</span>

08:18:26      <span class="token environment constant">UID</span>       PID   cswch/s nvcswch/s  Command
08:18:31        <span class="token number">0</span>         <span class="token number">1</span>      <span class="token number">0.20</span>      <span class="token number">0.00</span>  systemd
08:18:31        <span class="token number">0</span>         <span class="token number">8</span>      <span class="token number">5.40</span>      <span class="token number">0.00</span>  rcu_sched
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 特别关注下面几列信息：</p>
<ul>
<li>cswch ，表示每秒自愿上下文切换（voluntary context switches）的次数。</li>
<li><p>nvcswch ，表示每秒非自愿上下文切换（non voluntary context switches）的次数。</p>
<p>它们会反应出不同的性能问题：</p>
</li>
<li><p>自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换。</p>
</li>
<li>非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换。</li>
</ul>
</li>
</ol>
<h4 id="4-2-案例分析"><a href="#4-2-案例分析" class="headerlink" title="4.2 案例分析"></a>4.2 案例分析</h4><blockquote>
<p>机器配置： 2 CPU, 8 GB 内存。</p>
<p>安装软件：<code>apt install sysbench sysstat</code>。</p>
</blockquote>
<p>先用 vmstat 看一下空闲系统的上下文切换次数</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 间隔 1 秒后输出 1 组数据</span>
$ <span class="token function">vmstat</span> <span class="token number">1</span> <span class="token number">1</span>
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   <span class="token function">free</span>   buff  cache   si   so    bi    bo   <span class="token keyword">in</span>   cs us sy <span class="token function">id</span> wa st
 <span class="token number">0</span>  <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">6984064</span>  <span class="token number">92668</span> <span class="token number">830896</span>    <span class="token number">0</span>    <span class="token number">0</span>     <span class="token number">2</span>    <span class="token number">19</span>   <span class="token number">19</span>   <span class="token number">35</span>  <span class="token number">1</span>  <span class="token number">0</span> <span class="token number">99</span>  <span class="token number">0</span>  <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到，现在的上下文切换次数 cs 是 35，而中断次数 in 是 19，r 和 b 都是 0。因为这会儿没有运行其他任务，所以它们就是空闲系统的上下文切换次数。</p>
<ol>
<li><p>在第一个终端里运行 sysbench ，模拟系统多线程调度的瓶颈</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 以 10 个线程运行 5 分钟的基准测试，模拟多线程切换的问题</span>
$ sysbench --threads<span class="token operator">=</span><span class="token number">10</span> --max-time<span class="token operator">=</span><span class="token number">300</span> threads run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li><p>在第二个终端运行 vmstat ，观察上下文切换情况</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 每隔 1 秒输出 1 组数据（需要 Ctrl+C 才结束）</span>
$ <span class="token function">vmstat</span> <span class="token number">1</span>
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
r  b   swpd   <span class="token function">free</span>   buff  cache   si   so    bi    bo   <span class="token keyword">in</span>   cs us sy <span class="token function">id</span> wa st
<span class="token number">6</span>  <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">6487428</span> <span class="token number">118240</span> <span class="token number">1292772</span>    <span class="token number">0</span>    <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">0</span> <span class="token number">9019</span> <span class="token number">1398830</span> <span class="token number">16</span> <span class="token number">84</span>  <span class="token number">0</span>  <span class="token number">0</span>  <span class="token number">0</span>
<span class="token number">8</span>  <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">6487428</span> <span class="token number">118240</span> <span class="token number">1292772</span>    <span class="token number">0</span>    <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">0</span> <span class="token number">10191</span> <span class="token number">1392312</span> <span class="token number">16</span> <span class="token number">84</span>  <span class="token number">0</span>  <span class="token number">0</span>  <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 可以发现，cs 列的上下文切换次数从之前的 35 骤然上升到了 139 万。同时，注意观察其他几个指标：</p>
<ul>
<li>r 列：就绪队列的长度已经到了 8，远远超过了系统 CPU 的个数 2，所以肯定会有大量的 CPU 竞争。</li>
<li>us（user）和 sy（system）列：这两列的 CPU 使用率加起来上升到了 100%，其中系统 CPU 使用率，也就是 sy 列高达 84%，说明 CPU 主要是被内核占用了。</li>
<li><p>in 列：中断次数也上升到了 1 万左右，说明中断处理也是个潜在的问题。</p>
<p>综合这几个指标，我们可以知道，系统的就绪队列过长，也就是正在运行和等待 CPU 的进程数过多，导致了大量的上下文切换，而上下文切换又导致了系统 CPU 的占用率升高。</p>
<p>那么到底是什么进程导致了这些问题呢？</p>
</li>
</ul>
</li>
<li><p>在第三个终端再用 pidstat 来看一下， CPU 和进程上下文切换的情况</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 每隔 1 秒输出 1 组数据（需要 Ctrl+C 才结束）</span>
<span class="token comment"># -w 参数表示输出进程切换指标，而 -u 参数则表示输出 CPU 使用指标</span>
$ pidstat -w -u <span class="token number">1</span>
08:06:33      <span class="token environment constant">UID</span>       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
08:06:34        <span class="token number">0</span>     <span class="token number">10488</span>   <span class="token number">30.00</span>  <span class="token number">100.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>  <span class="token number">100.00</span>     <span class="token number">0</span>  sysbench
08:06:34        <span class="token number">0</span>     <span class="token number">26326</span>    <span class="token number">0.00</span>    <span class="token number">1.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">1.00</span>     <span class="token number">0</span>  kworker/u4:2

08:06:33      <span class="token environment constant">UID</span>       PID   cswch/s nvcswch/s  Command
08:06:34        <span class="token number">0</span>         <span class="token number">8</span>     <span class="token number">11.00</span>      <span class="token number">0.00</span>  rcu_sched
08:06:34        <span class="token number">0</span>        <span class="token number">16</span>      <span class="token number">1.00</span>      <span class="token number">0.00</span>  ksoftirqd/1
08:06:34        <span class="token number">0</span>       <span class="token number">471</span>      <span class="token number">1.00</span>      <span class="token number">0.00</span>  hv_balloon
08:06:34        <span class="token number">0</span>      <span class="token number">1230</span>      <span class="token number">1.00</span>      <span class="token number">0.00</span>  iscsid
08:06:34        <span class="token number">0</span>      <span class="token number">4089</span>      <span class="token number">1.00</span>      <span class="token number">0.00</span>  kworker/1:5
08:06:34        <span class="token number">0</span>      <span class="token number">4333</span>      <span class="token number">1.00</span>      <span class="token number">0.00</span>  kworker/0:3
08:06:34        <span class="token number">0</span>     <span class="token number">10499</span>      <span class="token number">1.00</span>    <span class="token number">224.00</span>  pidstat
08:06:34        <span class="token number">0</span>     <span class="token number">26326</span>    <span class="token number">236.00</span>      <span class="token number">0.00</span>  kworker/u4:2
08:06:34     <span class="token number">1000</span>     <span class="token number">26784</span>    <span class="token number">223.00</span>      <span class="token number">0.00</span>  sshd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 从 pidstat 的输出你可以发现，CPU 使用率的升高果然是 sysbench 导致的，它的 CPU 使用率已经达到了 100%。但上下文切换则是来自其他进程，包括非自愿上下文切换频率最高的 pidstat ，以及自愿上下文切换频率最高的内核线程 kworker 和 sshd。</p>
<p> 不过，细心的你肯定也发现了一个怪异的事儿：pidstat 输出的上下文切换次数，加起来也就几百，比 vmstat 的 139 万明显小了太多。</p>
<p> 通过运行 man pidstat ，你会发现，pidstat 默认显示进程的指标数据，加上 -t 参数后，才会输出线程的指标。</p>
<p> 所以，在第三个终端里， Ctrl+C 停止刚才的 pidstat 命令，再加上 -t 参数，重试一下看看：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 每隔 1 秒输出一组数据（需要 Ctrl+C 才结束）</span>
<span class="token comment"># -wt 参数表示输出线程的上下文切换指标</span>
$ pidstat -wt <span class="token number">1</span>
08:14:05      <span class="token environment constant">UID</span>      TGID       TID   cswch/s nvcswch/s  Command
<span class="token punctuation">..</span>.
08:14:05        <span class="token number">0</span>     <span class="token number">10551</span>         -      <span class="token number">6.00</span>      <span class="token number">0.00</span>  sysbench
08:14:05        <span class="token number">0</span>         -     <span class="token number">10551</span>      <span class="token number">6.00</span>      <span class="token number">0.00</span>  <span class="token operator">|</span>__sysbench
08:14:05        <span class="token number">0</span>         -     <span class="token number">10552</span>  <span class="token number">18911.00</span> <span class="token number">103740.00</span>  <span class="token operator">|</span>__sysbench
08:14:05        <span class="token number">0</span>         -     <span class="token number">10553</span>  <span class="token number">18915.00</span> <span class="token number">100955.00</span>  <span class="token operator">|</span>__sysbench
08:14:05        <span class="token number">0</span>         -     <span class="token number">10554</span>  <span class="token number">18827.00</span> <span class="token number">103954.00</span>  <span class="token operator">|</span>__sysbench
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 现在你就能看到了，虽然 sysbench 进程（也就是主线程）的上下文切换次数看起来并不多，但它的子线程的上下文切换次数却有很多。看来，上下文切换罪魁祸首，还是过多的 sysbench 线程。</p>
<p> 在观察系统指标时，除了上下文切换频率骤然升高，还有一个指标也有很大的变化。是的，正是中断次数。中断次数也上升到了 1 万，但到底是什么类型的中断上升了？</p>
<p> 既然是中断，我们都知道，它只发生在内核态，而 pidstat 只是一个进程的性能分析工具，并不提供任何关于中断的详细信息，怎样才能知道中断发生的类型呢？</p>
<p> 没错，那就是从 /proc/interrupts 这个只读文件中读取。/proc 实际上是 Linux 的一个虚拟文件系统，用于内核空间与用户空间之间的通信。/proc/interrupts 就是这种通信机制的一部分，提供了一个只读的中断使用情况。</p>
<p> 在第三个终端里， Ctrl+C 停止刚才的 pidstat 命令，然后运行下面的命令，观察中断的变化情况：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -d 参数表示高亮显示变化的区域</span>
$ <span class="token function">watch</span> -d <span class="token function">cat</span> /proc/interrupts
        CPU0       CPU1
<span class="token punctuation">..</span>.
RES:    <span class="token number">2450431</span>    <span class="token number">5279697</span>   Rescheduling interrupts
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 观察一段时间，你可以发现，变化速度最快的是重调度中断（RES），这个中断类型表示，唤醒空闲状态的 CPU 来调度新的任务运行。这是多处理器系统（SMP）中，调度器用来分散任务到不同 CPU 的机制，通常也被称为处理器间中断（Inter-Processor Interrupts，IPI）。</p>
<p> 所以，这里的中断升高还是因为过多任务的调度问题，跟前面上下文切换次数的分析结果是一致的。</p>
<p> 通过这个案例，你应该也发现了多工具、多方面指标对比观测的好处。如果最开始时，我们只用了 pidstat 观测，这些很严重的上下文切换线程，压根儿就发现不了了。</p>
<p> 现在再回到最初的问题，每秒上下文切换多少次才算正常呢？</p>
<p> 这个数值其实取决于系统本身的 CPU 性能。在我看来，如果系统的上下文切换次数比较稳定，那么从数百到一万以内，都应该算是正常的。但当上下文切换次数超过一万次，或者切换次数出现数量级的增长时，就很可能已经出现了性能问题。</p>
<p> 这时，你还需要根据上下文切换的类型，再做具体分析。比方说：</p>
<ul>
<li>自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 I/O 等其他问题；</li>
<li>非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈；</li>
<li>中断次数变多了，说明 CPU 被中断处理程序占用，还需要通过查看 /proc/interrupts 文件来分析具体的中断类型。</li>
</ul>
</li>
</ol>
<h3 id="05-基础篇：某个应用的CPU使用率居然达到100-，我该怎么办？"><a href="#05-基础篇：某个应用的CPU使用率居然达到100-，我该怎么办？" class="headerlink" title="05 | 基础篇：某个应用的CPU使用率居然达到100%，我该怎么办？"></a>05 | 基础篇：某个应用的CPU使用率居然达到100%，我该怎么办？</h3><p>CPU 使用率是单位时间内 CPU 使用情况的统计，以百分比的方式展示。</p>
<h4 id="5-1-CPU-使用率"><a href="#5-1-CPU-使用率" class="headerlink" title="5.1 CPU 使用率"></a>5.1 CPU 使用率</h4><p>Linux 作为一个多任务操作系统，将每个 CPU 的时间划分为很短的时间片，再通过调度器轮流分配给各个任务使用，因此造成多任务同时运行的错觉。</p>
<p>为了维护 CPU 时间，Linux 通过事先定义的节拍率（内核中表示为 HZ），触发时间中断，并使用全局变量 Jiffies 记录了开机以来的节拍数。每发生一次时间中断，Jiffies 的值就加 1。</p>
<p>节拍率 HZ 是内核的可配选项，可以设置为 100、250、1000 等。不同的系统可能设置不同数值，你可以通过查询 /boot/config 内核选项来查看它的配置值。比如在我的系统中，节拍率设置成了 250，也就是每秒钟触发 250 次时间中断。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">grep</span> <span class="token string">'CONFIG_HZ='</span> /boot/config-<span class="token variable"><span class="token variable">$(</span><span class="token function">uname</span> -r<span class="token variable">)</span></span>
<span class="token assign-left variable">CONFIG_HZ</span><span class="token operator">=</span><span class="token number">250</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>同时，正因为节拍率 HZ 是内核选项，所以用户空间程序并不能直接访问。为了方便用户空间程序，内核还提供了一个用户空间节拍率 USER_HZ，它总是固定为 100，也就是 1/100 秒。这样，用户空间程序并不需要关心内核中 HZ 被设置成了多少，因为它看到的总是固定值 USER_HZ。</p>
<p>Linux 通过 /proc 虚拟文件系统，向用户空间提供了系统内部状态的信息，而 /proc/stat 提供的就是系统的 CPU 和任务统计信息。比方说，如果你只关注 CPU 的话，可以执行下面的命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 只保留各个 CPU 的数据</span>
$ <span class="token function">cat</span> /proc/stat <span class="token operator">|</span> <span class="token function">grep</span> ^cpu
cpu  <span class="token number">280580</span> <span class="token number">7407</span> <span class="token number">286084</span> <span class="token number">172900810</span> <span class="token number">83602</span> <span class="token number">0</span> <span class="token number">583</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span>
cpu0 <span class="token number">144745</span> <span class="token number">4181</span> <span class="token number">176701</span> <span class="token number">86423902</span> <span class="token number">52076</span> <span class="token number">0</span> <span class="token number">301</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span>
cpu1 <span class="token number">135834</span> <span class="token number">3226</span> <span class="token number">109383</span> <span class="token number">86476907</span> <span class="token number">31525</span> <span class="token number">0</span> <span class="token number">282</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出结果是一个表格。其中，第一列表示的是 CPU 编号，如 cpu0、cpu1 ，而第一行没有编号的 cpu ，表示的是所有 CPU 的累加。其他列则表示不同场景下 CPU 的累加节拍数，它的单位是 USER_HZ，也就是 10 ms（1/100 秒），所以这其实就是不同场景下的 CPU 时间。</p>
<p>每个数字的意义可以通过 <code>man proc</code> 查询。要清楚 man proc 文档里每一列的涵义，它们都是 CPU 使用率相关的重要指标，你还会在很多其他的性能工具中看到它们。下面，我来依次解读一下。</p>
<ul>
<li>user（通常缩写为 us），代表用户态 CPU 时间。注意，它不包括下面的 nice 时间，但包括了 guest 时间。</li>
<li>nice（通常缩写为 ni），代表低优先级用户态 CPU 时间，也就是进程的 nice 值被调整为 1-19 之间时的 CPU 时间。这里注意，nice 可取值范围是 -20 到 19，数值越大，优先级反而越低。</li>
<li>system（通常缩写为 sys），代表内核态 CPU 时间。</li>
<li>idle（通常缩写为 id），代表空闲时间。注意，它不包括等待 I/O 的时间（iowait）。</li>
<li>iowait（通常缩写为 wa），代表等待 I/O 的 CPU 时间。</li>
<li>irq（通常缩写为 hi），代表处理硬中断的 CPU 时间。</li>
<li>softirq（通常缩写为 si），代表处理软中断的 CPU 时间。</li>
<li>steal（通常缩写为 st），代表当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间。</li>
<li>guest（通常缩写为 guest），代表通过虚拟化运行其他操作系统的时间，也就是运行虚拟机的 CPU 时间。</li>
<li>guest_nice（通常缩写为 gnice），代表以低优先级运行虚拟机的时间。</li>
</ul>
<p>CPU 使用率，就是除了空闲时间外的其他时间占总 CPU 时间的百分比，用公式来表示就是：</p>
<p><img src="/images/《Linux性能优化实战》学习笔记/CPU使用率公式.png" alt="CPU使用率公式"></p>
<p>根据这个公式，我们就可以从 /proc/stat 中的数据，很容易地计算出 CPU 使用率。当然，也可以用每一个场景的 CPU 时间，除以总的 CPU 时间，计算出每个场景的 CPU 使用率。</p>
<p>不过先不要着急计算，你能说出，直接用 /proc/stat 的数据，算的是什么时间段的 CPU 使用率吗？</p>
<p>看到这里，你应该想起来了，这是开机以来的节拍数累加值，所以直接算出来的，是开机以来的平均 CPU 使用率，一般没啥参考价值。</p>
<p>事实上，为了计算 CPU 使用率，性能工具一般都会取间隔一段时间（比如 3 秒）的两次值，作差后，再计算出这段时间内的平均 CPU 使用率，即</p>
<p><img src="/images/《Linux性能优化实战》学习笔记/平均CPU使用率公式.png" alt="平均CPU使用率公式"></p>
<p>这个公式，就是我们用各种性能工具所看到的 CPU 使用率的实际计算方法。</p>
<p>现在，我们知道了系统 CPU 使用率的计算方法，那进程的呢？跟系统的指标类似，Linux 也给每个进程提供了运行情况的统计信息，也就是 /proc/[pid]/stat。不过，这个文件包含的数据就比较丰富了，总共有 52 列的数据。</p>
<p><strong>性能分析工具给出的都是间隔一段时间的平均 CPU 使用率，所以要注意间隔时间的设置，特别是用多个工具对比分析时，你一定要保证它们用的是相同的间隔时间。</strong></p>
<p>比如，对比一下 top 和 ps 这两个工具报告的 CPU 使用率，默认的结果很可能不一样，因为 top 默认使用 3 秒时间间隔，而 ps 使用的却是进程的整个生命周期。</p>
<h4 id="5-2-怎么查看-CPU-使用率"><a href="#5-2-怎么查看-CPU-使用率" class="headerlink" title="5.2 怎么查看 CPU 使用率"></a>5.2 怎么查看 CPU 使用率</h4><p>top 和 ps 是最常用的性能分析工具：</p>
<ul>
<li>top 显示了系统总体的 CPU 和内存使用情况，以及各个进程的资源使用情况。</li>
<li>ps 则只显示了每个进程的资源使用情况。</li>
</ul>
<p>top 的输出格式为：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 默认每 3 秒刷新一次</span>
$ <span class="token function">top</span>
<span class="token function">top</span> - <span class="token number">11</span>:58:59 up <span class="token number">9</span> days, <span class="token number">22</span>:47,  <span class="token number">1</span> user,  load average: <span class="token number">0.03</span>, <span class="token number">0.02</span>, <span class="token number">0.00</span>
Tasks: <span class="token number">123</span> total,   <span class="token number">1</span> running,  <span class="token number">72</span> sleeping,   <span class="token number">0</span> stopped,   <span class="token number">0</span> zombie
%Cpu<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:  <span class="token number">0.3</span> us,  <span class="token number">0.3</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">99.3</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> st
KiB Mem <span class="token builtin class-name">:</span>  <span class="token number">8169348</span> total,  <span class="token number">5606884</span> free,   <span class="token number">334640</span> used,  <span class="token number">2227824</span> buff/cache
KiB Swap:        <span class="token number">0</span> total,        <span class="token number">0</span> free,        <span class="token number">0</span> used.  <span class="token number">7497908</span> avail Mem

  PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
    <span class="token number">1</span> root      <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">78088</span>   <span class="token number">9288</span>   <span class="token number">6696</span> S   <span class="token number">0.0</span>  <span class="token number">0.1</span>   <span class="token number">0</span>:16.83 systemd
    <span class="token number">2</span> root      <span class="token number">20</span>   <span class="token number">0</span>       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> S   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.05 kthreadd
    <span class="token number">4</span> root       <span class="token number">0</span> -20       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> I   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.00 kworker/0:0H
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出结果中，第三行 %Cpu 就是系统的 CPU 使用率，具体每一列的含义上一节都讲过，只是把 CPU 时间变换成了 CPU 使用率。不过需要注意，top 默认显示的是所有 CPU 的平均值，这个时候你只需要按下数字 1 ，就可以切换到每个 CPU 的使用率了。</p>
<p>继续往下看，空白行之后是进程的实时信息，每个进程都有一个 %CPU 列，表示进程的 CPU 使用率。它是用户态和内核态 CPU 使用率的总和，包括进程用户空间使用的 CPU、通过系统调用执行的内核空间 CPU 、以及在就绪队列等待运行的 CPU。在虚拟化环境中，它还包括了运行虚拟机占用的 CPU。</p>
<p>可以发现， top 并没有细分进程的用户态 CPU 和内核态 CPU。可以使用 pidstat 专门分析每个进程 CPU 使用情况的工具。</p>
<p>比如，下面的 pidstat 命令，就间隔 1 秒展示了进程的 5 组 CPU 使用率，包括：</p>
<ul>
<li>用户态 CPU 使用率 （%usr）；</li>
<li>内核态 CPU 使用率（%system）；</li>
<li>运行虚拟机 CPU 使用率（%guest）；</li>
<li>等待 CPU 使用率（%wait）；</li>
<li>以及总的 CPU 使用率（%CPU）。</li>
</ul>
<p>最后的 Average 部分，还计算了 5 组数据的平均值。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 每隔 1 秒输出一组数据，共输出 5 组</span>
$ pidstat <span class="token number">1</span> <span class="token number">5</span>
<span class="token number">15</span>:56:02      <span class="token environment constant">UID</span>       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
<span class="token number">15</span>:56:03        <span class="token number">0</span>     <span class="token number">15006</span>    <span class="token number">0.00</span>    <span class="token number">0.99</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.99</span>     <span class="token number">1</span>  dockerd

<span class="token punctuation">..</span>.

Average:      <span class="token environment constant">UID</span>       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
Average:        <span class="token number">0</span>     <span class="token number">15006</span>    <span class="token number">0.00</span>    <span class="token number">0.99</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.99</span>     -  dockerd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="5-3-CPU-使用率过高怎么办？"><a href="#5-3-CPU-使用率过高怎么办？" class="headerlink" title="5.3 CPU 使用率过高怎么办？"></a>5.3 CPU 使用率过高怎么办？</h4><p>通过 top、ps、pidstat 等工具，你能够轻松找到 CPU 使用率较高（比如 100% ）的进程。接下来，你可能又想知道，占用 CPU 的到底是代码里的哪个函数呢？找到它，你才能更高效、更针对性地进行优化。</p>
<p>我猜你第一个想到的，应该是 GDB（The GNU Project Debugger）， 这个功能强大的程序调试利器。的确，GDB 在调试程序错误方面很强大。但是，我又要来“挑刺”了。请你记住，GDB 并不适合在性能分析的早期应用。</p>
<p>为什么呢？因为 GDB 调试程序的过程会中断程序运行，这在线上环境往往是不允许的。所以，GDB 只适合用在性能分析的后期，当你找到了出问题的大致函数后，线下再借助它来进一步调试函数内部的问题。</p>
<p>那么哪种工具适合在第一时间分析进程的 CPU 问题呢？我的推荐是 perf。perf 是 Linux 2.6.31 以后内置的性能分析工具。它以性能事件采样为基础，不仅可以分析系统的各种事件和内核性能，还可以用来分析指定应用程序的性能问题。</p>
<p>使用 perf 分析 CPU 性能问题，我来说两种最常见、也是我最喜欢的用法。</p>
<p>第一种常见用法是 perf top，类似于 top，它能够实时显示占用 CPU 时钟最多的函数或者指令，因此可以用来查找热点函数，使用界面如下所示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ perf <span class="token function">top</span>
Samples: <span class="token number">833</span>  of event <span class="token string">'cpu-clock'</span>, Event count <span class="token punctuation">(</span>approx.<span class="token punctuation">)</span>: <span class="token number">97742399</span>
Overhead  Shared Object       Symbol
   <span class="token number">7.28</span>%  perf                <span class="token punctuation">[</span>.<span class="token punctuation">]</span> 0x00000000001f78a4
   <span class="token number">4.72</span>%  <span class="token punctuation">[</span>kernel<span class="token punctuation">]</span>            <span class="token punctuation">[</span>k<span class="token punctuation">]</span> vsnprintf
   <span class="token number">4.32</span>%  <span class="token punctuation">[</span>kernel<span class="token punctuation">]</span>            <span class="token punctuation">[</span>k<span class="token punctuation">]</span> module_get_kallsym
   <span class="token number">3.65</span>%  <span class="token punctuation">[</span>kernel<span class="token punctuation">]</span>            <span class="token punctuation">[</span>k<span class="token punctuation">]</span> _raw_spin_unlock_irqrestore
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出结果中，第一行包含三个数据，分别是采样数（Samples）、事件类型（event）和事件总数量（Event count）。比如这个例子中，perf 总共采集了 833 个 CPU 时钟事件，而总事件数则为 97742399。</p>
<p>再往下看是一个表格式样的数据，每一行包含四列，分别是：</p>
<ul>
<li>第一列 Overhead ，是该符号的性能事件在所有采样中的比例，用百分比来表示。</li>
<li>第二列 Shared ，是该函数或指令所在的动态共享对象（Dynamic Shared Object），如内核、进程名、动态链接库名、内核模块名等。</li>
<li>第三列 Object ，是动态共享对象的类型。比如 [.] 表示用户空间的可执行程序、或者动态链接库，而 [k] 则表示内核空间。</li>
<li>最后一列 Symbol 是符号名，也就是函数名。当函数名未知时，用十六进制的地址来表示。</li>
</ul>
<p>以上面的输出为例，我们可以看到，占用 CPU 时钟最多的是 perf 工具自身，不过它的比例也只有 7.28%，说明系统并没有 CPU 性能问题。 perf top 的使用你应该很清楚了吧。</p>
<p>接着再来看第二种常见用法，也就是 perf record 和 perf report。 perf top 虽然实时展示了系统的性能信息，但它的缺点是并不保存数据，也就无法用于离线或者后续的分析。而 perf record 则提供了保存数据的功能，保存后的数据，需要你用 perf report 解析展示。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ perf record <span class="token comment"># 按 Ctrl+C 终止采样</span>
<span class="token punctuation">[</span> perf record: Woken up <span class="token number">1</span> <span class="token builtin class-name">times</span> to <span class="token function">write</span> data <span class="token punctuation">]</span>
<span class="token punctuation">[</span> perf record: Captured and wrote <span class="token number">0.452</span> MB perf.data <span class="token punctuation">(</span><span class="token number">6093</span> samples<span class="token punctuation">)</span> <span class="token punctuation">]</span>

$ perf report <span class="token comment"># 展示类似于 perf top 的报告</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在实际使用中，我们还经常为 perf top 和 perf record 加上 -g 参数，开启调用关系的采样，方便我们根据调用链来分析性能问题。</p>
<h4 id="5-4-案例"><a href="#5-4-案例" class="headerlink" title="5.4 案例"></a>5.4 案例</h4><p>下面我们就以 Nginx + PHP 的 Web 服务为例，来看看当你发现 CPU 使用率过高的问题后，要怎么使用 top 等工具找出异常的进程，又要怎么利用 perf 找出引发性能问题的函数。</p>
<blockquote>
<p>机器配置：2 CPU，8GB 内存。</p>
<p>安装软件：<code>apt install docker.io sysstat linux-tools-common apache2-utils</code>。</p>
<blockquote>
<p>ab（apache bench）是一个常用的 HTTP 服务性能测试工具，这里用来模拟 Ngnix 的客户端。</p>
</blockquote>
</blockquote>
<ol>
<li><p>在第一个终端执行下面的命令来运行 Nginx 和 PHP 应用：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run --name nginx -p <span class="token number">10000</span>:80 -itd feisky/nginx
$ docker run --name phpfpm -itd --network container:nginx feisky/php-fpm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li><p>在第二个终端使用 curl 访问 <a href="http://[VM1">http://[VM1</a> 的 IP]:10000，确认 Nginx 已正常启动。你应该可以看到 It works! 的响应。</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 192.168.0.10 是第一台虚拟机的 IP 地址</span>
$ <span class="token function">curl</span> http://192.168.0.10:10000/
It works<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li><p>接着，我们来测试一下这个 Nginx 服务的性能。在第二个终端运行下面的 ab 命令：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 并发 10 个请求测试 Nginx 性能，总共测试 100 个请求</span>
$ ab -c <span class="token number">10</span> -n <span class="token number">100</span> http://192.168.0.10:10000/
This is ApacheBench, Version <span class="token number">2.3</span> <span class="token operator">&lt;</span><span class="token variable">$Revision</span><span class="token builtin class-name">:</span> <span class="token number">1706008</span> $<span class="token operator">&gt;</span>
Copyright <span class="token number">1996</span> Adam Twiss, Zeus Technology Ltd,
<span class="token punctuation">..</span>.
Requests per second:    <span class="token number">11.63</span> <span class="token punctuation">[</span><span class="token comment">#/sec] (mean)</span>
Time per request:       <span class="token number">859.942</span> <span class="token punctuation">[</span>ms<span class="token punctuation">]</span> <span class="token punctuation">(</span>mean<span class="token punctuation">)</span>
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 从 ab 的输出结果我们可以看到，Nginx 能承受的每秒平均请求数只有 11.63。太少了，那到底是哪里出了问题呢？我们用 top 和 pidstat 再来观察下。</p>
</li>
<li><p>我们在第二个终端，将测试的请求总数增加到 10000。这样当你在第一个终端使用性能分析工具时， Nginx 的压力还是继续。继续在第二个终端，运行 ab 命令：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ab -c <span class="token number">10</span> -n <span class="token number">10000</span> http://10.240.0.5:10000/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>回到第一个终端运行 top 命令，并按下数字 1 ，切换到每个 CPU 的使用率：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">top</span>
<span class="token punctuation">..</span>.
%Cpu0  <span class="token builtin class-name">:</span> <span class="token number">98.7</span> us,  <span class="token number">1.3</span> sy,  <span class="token number">0.0</span> ni,  <span class="token number">0.0</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> st
%Cpu1  <span class="token builtin class-name">:</span> <span class="token number">99.3</span> us,  <span class="token number">0.7</span> sy,  <span class="token number">0.0</span> ni,  <span class="token number">0.0</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> st
<span class="token punctuation">..</span>.
PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
<span class="token number">21514</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">16384</span>   <span class="token number">8712</span> R  <span class="token number">41.9</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:06.00 php-fpm
<span class="token number">21513</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">13244</span>   <span class="token number">5572</span> R  <span class="token number">40.2</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:06.08 php-fpm
<span class="token number">21515</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">16384</span>   <span class="token number">8712</span> R  <span class="token number">40.2</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:05.67 php-fpm
<span class="token number">21512</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">13244</span>   <span class="token number">5572</span> R  <span class="token number">39.9</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:05.87 php-fpm
<span class="token number">21516</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">16384</span>   <span class="token number">8712</span> R  <span class="token number">35.9</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:05.61 php-fpm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 这里可以看到，系统中有几个 php-fpm 进程的 CPU 使用率加起来接近 200%；而每个 CPU 的用户使用率（us）也已经超过了 98%，接近饱和。这样，我们就可以确认，正是用户空间的 php-fpm 进程，导致 CPU 使用率骤升。</p>
</li>
<li><p>那再往下走，怎么知道是 php-fpm 的哪个函数导致了 CPU 使用率升高呢？我们来用 perf 分析一下。在第一个终端运行下面的 perf 命令：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -g 开启调用关系分析，-p 指定 php-fpm 的进程号 21515</span>
$ perf <span class="token function">top</span> -g -p <span class="token number">21515</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 按方向键切换到 php-fpm，再按下回车键展开 php-fpm 的调用关系，你会发现，调用关系最终到了 sqrt 和 add_function。看来，我们需要从这两个函数入手了。</p>
<p> <img src="/images/《Linux性能优化实战》学习笔记/CPU使用率过高案例分析perf截图.png" alt="CPU使用率过高案例分析perf截图"></p>
<p> 我们拷贝出 <a target="_blank" rel="noopener" href="https://github.com/feiskyer/linux-perf-examples/blob/master/nginx-high-cpu/app/index.php">Nginx 应用的源码</a>，看看是不是调用了这两个函数：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 从容器 phpfpm 中将 PHP 源码拷贝出来</span>
$ docker <span class="token function">cp</span> phpfpm:/app <span class="token builtin class-name">.</span>

<span class="token comment"># 使用 grep 查找函数调用</span>
$ <span class="token function">grep</span> sqrt -r app/ <span class="token comment"># 找到了 sqrt 调用</span>
app/index.php:  <span class="token variable">$x</span> <span class="token operator">+=</span> sqrt<span class="token punctuation">(</span><span class="token variable">$x</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
$ <span class="token function">grep</span> add_function -r app/ <span class="token comment"># 没找到 add_function 调用，这其实是 PHP 内置函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> OK，原来只有 sqrt 函数在 app/index.php 文件中调用了。那最后一步，我们就该看看这个文件的源码了：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> app/index.php
<span class="token operator">&lt;</span>?php
// <span class="token builtin class-name">test</span> only.
<span class="token variable">$x</span> <span class="token operator">=</span> <span class="token number">0.0001</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">1000000</span><span class="token punctuation">;</span> <span class="token variable">$i</span>++<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token variable">$x</span> <span class="token operator">+=</span> sqrt<span class="token punctuation">(</span><span class="token variable">$x</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token builtin class-name">echo</span> <span class="token string">"It works!"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 呀，有没有发现问题在哪里呢？我想你要笑话我了，居然犯了一个这么傻的错误，测试代码没删就直接发布应用了。为了方便你验证优化后的效果，我把修复后的应用也打包成了一个 Docker 镜像，你可以在第一个终端中执行下面的命令来运行它：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 停止原来的应用</span>
$ docker <span class="token function">rm</span> -f nginx phpfpm
<span class="token comment"># 运行优化后的应用</span>
$ docker run --name nginx -p <span class="token number">10000</span>:80 -itd feisky/nginx:cpu-fix
$ docker run --name phpfpm -itd --network container:nginx feisky/php-fpm:cpu-fix<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>接着，到第二个终端来验证一下修复后的效果。首先 Ctrl+C 停止之前的 ab 命令后，再运行下面的命令：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ab -c <span class="token number">10</span> -n <span class="token number">10000</span> http://10.240.0.5:10000/
<span class="token punctuation">..</span>.
Complete requests:      <span class="token number">10000</span>
Failed requests:        <span class="token number">0</span>
Total transferred:      <span class="token number">1720000</span> bytes
HTML transferred:       <span class="token number">90000</span> bytes
Requests per second:    <span class="token number">2237.04</span> <span class="token punctuation">[</span><span class="token comment">#/sec] (mean)</span>
Time per request:       <span class="token number">4.470</span> <span class="token punctuation">[</span>ms<span class="token punctuation">]</span> <span class="token punctuation">(</span>mean<span class="token punctuation">)</span>
Time per request:       <span class="token number">0.447</span> <span class="token punctuation">[</span>ms<span class="token punctuation">]</span> <span class="token punctuation">(</span>mean, across all concurrent requests<span class="token punctuation">)</span>
Transfer rate:          <span class="token number">375.75</span> <span class="token punctuation">[</span>Kbytes/sec<span class="token punctuation">]</span> received
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 从这里你可以发现，现在每秒的平均请求数，已经从原来的 11 变成了 2237。</p>
</li>
</ol>
<h4 id="5-5-小结"><a href="#5-5-小结" class="headerlink" title="5.5 小结"></a>5.5 小结</h4><p>CPU 使用率是最直观和最常用的系统性能指标，更是我们在排查性能问题时，通常会关注的第一个指标。所以我们更要熟悉它的含义，尤其要弄清楚用户（%user）、Nice（%nice）、系统（%system） 、等待 I/O（%iowait） 、中断（%irq）以及软中断（%softirq）这几种不同 CPU 的使用率。比如说：</p>
<ul>
<li>用户 CPU 和 Nice CPU 高，说明用户态进程占用了较多的 CPU，所以应该着重排查进程的性能问题。</li>
<li>系统 CPU 高，说明内核态占用了较多的 CPU，所以应该着重排查内核线程或者系统调用的性能问题。</li>
<li>I/O 等待 CPU 高，说明等待 I/O 的时间比较长，所以应该着重排查系统存储是不是出现了 I/O 问题。</li>
<li>软中断和硬中断高，说明软中断或硬中断的处理程序占用了较多的 CPU，所以应该着重排查内核中的中断服务程序。</li>
</ul>
<p>碰到 CPU 使用率升高的问题，你可以借助 top、pidstat 等工具，确认引发 CPU 性能问题的来源；再使用 perf 等工具，排查出引起性能问题的具体函数。</p>
<h3 id="06-案例篇：系统的-CPU-使用率很高，但为啥却找不到高-CPU-的应用？"><a href="#06-案例篇：系统的-CPU-使用率很高，但为啥却找不到高-CPU-的应用？" class="headerlink" title="06 | 案例篇：系统的 CPU 使用率很高，但为啥却找不到高 CPU 的应用？"></a>06 | 案例篇：系统的 CPU 使用率很高，但为啥却找不到高 CPU 的应用？</h3><p>系统的 CPU 使用率，不仅包括进程用户态和内核态的运行，还包括中断处理、等待 I/O 以及内核线程等。所以，当你发现系统的 CPU 使用率很高的时候，不一定能找到相对应的高 CPU 使用率的进程。</p>
<p>今天，我就用一个 Nginx + PHP 的 Web 服务的案例，带你来分析这种情况。</p>
<h4 id="6-1-案例分析"><a href="#6-1-案例分析" class="headerlink" title="6.1 案例分析"></a>6.1 案例分析</h4><blockquote>
<p>机器配置：2 CPU，8GB 内存。</p>
<p>安装软件：<code>apt install docker.io sysstat linux-tools-common apache2-utils</code>。</p>
</blockquote>
<ol>
<li><p>在第一个终端，执行下面的命令运行 Nginx 和 PHP 应用：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run --name nginx -p <span class="token number">10000</span>:80 -itd feisky/nginx:sp
$ docker run --name phpfpm -itd --network container:nginx feisky/php-fpm:sp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li><p>第二个终端，使用 curl 访问 <a href="http://[VM1">http://[VM1</a> 的 IP]:10000，确认 Nginx 已正常启动。你应该可以看到 It works! 的响应。</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 192.168.0.10 是第一台虚拟机的 IP 地址</span>
$ <span class="token function">curl</span> http://192.168.0.10:10000/
It works<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li><p>来测试一下这个 Nginx 服务的性能。在第二个终端运行下面的 ab 命令。要注意，与上次操作不同的是，这次我们需要并发 100 个请求测试 Nginx 性能，总共测试 1000 个请求。</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 并发 100 个请求测试 Nginx 性能，总共测试 1000 个请求</span>
$ ab -c <span class="token number">100</span> -n <span class="token number">1000</span> http://192.168.0.10:10000/
This is ApacheBench, Version <span class="token number">2.3</span> <span class="token operator">&lt;</span><span class="token variable">$Revision</span><span class="token builtin class-name">:</span> <span class="token number">1706008</span> $<span class="token operator">&gt;</span>
Copyright <span class="token number">1996</span> Adam Twiss, Zeus Technology Ltd,
<span class="token punctuation">..</span>.
Requests per second:    <span class="token number">87.86</span> <span class="token punctuation">[</span><span class="token comment">#/sec] (mean)</span>
Time per request:       <span class="token number">1138.229</span> <span class="token punctuation">[</span>ms<span class="token punctuation">]</span> <span class="token punctuation">(</span>mean<span class="token punctuation">)</span>
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 从 ab 的输出结果我们可以看到，Nginx 能承受的每秒平均请求数，只有 87 多一点，是不是感觉它的性能有点差呀。那么，到底是哪里出了问题呢？我们再用 top 和 pidstat 来观察一下。</p>
<p> 这次，我们在第二个终端，将测试的并发请求数改成 5，同时把请求时长设置为 10 分钟（-t 600）。这样，当你在第一个终端使用性能分析工具时， Nginx 的压力还是继续的。</p>
</li>
<li><p>继续在第二个终端运行 ab 命令：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ab -c <span class="token number">5</span> -t <span class="token number">600</span> http://192.168.0.10:10000/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>然后，我们在第一个终端运行 top 命令，观察系统的 CPU 使用情况：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">top</span>
<span class="token punctuation">..</span>.
%Cpu<span class="token punctuation">(</span>s<span class="token punctuation">)</span>: <span class="token number">80.8</span> us, <span class="token number">15.1</span> sy,  <span class="token number">0.0</span> ni,  <span class="token number">2.8</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">1.3</span> si,  <span class="token number">0.0</span> st
<span class="token punctuation">..</span>.

PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
<span class="token number">6882</span> root      <span class="token number">20</span>   <span class="token number">0</span>    <span class="token number">8456</span>   <span class="token number">5052</span>   <span class="token number">3884</span> S   <span class="token number">2.7</span>  <span class="token number">0.1</span>   <span class="token number">0</span>:04.78 docker-containe
<span class="token number">6947</span> systemd+  <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">33104</span>   <span class="token number">3716</span>   <span class="token number">2340</span> S   <span class="token number">2.7</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:04.92 nginx
<span class="token number">7494</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">15012</span>   <span class="token number">7332</span> S   <span class="token number">2.0</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:03.55 php-fpm
<span class="token number">7495</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">15160</span>   <span class="token number">7480</span> S   <span class="token number">2.0</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:03.55 php-fpm
<span class="token number">10547</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">16200</span>   <span class="token number">8520</span> S   <span class="token number">2.0</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:03.13 php-fpm
<span class="token number">10155</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">16200</span>   <span class="token number">8520</span> S   <span class="token number">1.7</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:03.12 php-fpm
<span class="token number">10552</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">16200</span>   <span class="token number">8520</span> S   <span class="token number">1.7</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:03.12 php-fpm
<span class="token number">15006</span> root      <span class="token number">20</span>   <span class="token number">0</span> <span class="token number">1168608</span>  <span class="token number">66264</span>  <span class="token number">37536</span> S   <span class="token number">1.0</span>  <span class="token number">0.8</span>   <span class="token number">9</span>:39.51 dockerd
<span class="token number">4323</span> root      <span class="token number">20</span>   <span class="token number">0</span>       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> I   <span class="token number">0.3</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.87 kworker/u4:1
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 观察 top 输出的进程列表可以发现，CPU 使用率最高的进程也只不过才 2.7%，看起来并不高。</p>
<p> 然而，再看系统 CPU 使用率（ %Cpu ）这一行，你会发现，系统的整体 CPU 使用率是比较高的：用户 CPU 使用率（us）已经到了 80%，系统 CPU 为 15.1%，而空闲 CPU （id）则只有 2.8%。</p>
<p> 为什么用户 CPU 使用率这么高呢？我们再重新分析一下进程列表，看看有没有可疑进程：</p>
<ul>
<li>docker-containerd 进程是用来运行容器的，2.7% 的 CPU 使用率看起来正常；</li>
<li>Nginx 和 php-fpm 是运行 Web 服务的，它们会占用一些 CPU 也不意外，并且 2% 的 CPU 使用率也不算高；</li>
<li><p>再往下看，后面的进程呢，只有 0.3% 的 CPU 使用率，看起来不太像会导致用户 CPU 使用率达到 80%。</p>
<p>看来 top 是不管用了，那还有其他工具可以查看进程 CPU 使用情况吗？</p>
</li>
</ul>
</li>
<li><p>接下来，我们还是在第一个终端，运行 pidstat 命令：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 间隔 1 秒输出一组数据（按 Ctrl+C 结束）</span>
$ pidstat <span class="token number">1</span>
<span class="token punctuation">..</span>.
04:36:24      <span class="token environment constant">UID</span>       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
04:36:25        <span class="token number">0</span>      <span class="token number">6882</span>    <span class="token number">1.00</span>    <span class="token number">3.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">4.00</span>     <span class="token number">0</span>  docker-containe
04:36:25      <span class="token number">101</span>      <span class="token number">6947</span>    <span class="token number">1.00</span>    <span class="token number">2.00</span>    <span class="token number">0.00</span>    <span class="token number">1.00</span>    <span class="token number">3.00</span>     <span class="token number">1</span>  nginx
04:36:25        <span class="token number">1</span>     <span class="token number">14834</span>    <span class="token number">1.00</span>    <span class="token number">1.00</span>    <span class="token number">0.00</span>    <span class="token number">1.00</span>    <span class="token number">2.00</span>     <span class="token number">0</span>  php-fpm
04:36:25        <span class="token number">1</span>     <span class="token number">14835</span>    <span class="token number">1.00</span>    <span class="token number">1.00</span>    <span class="token number">0.00</span>    <span class="token number">1.00</span>    <span class="token number">2.00</span>     <span class="token number">0</span>  php-fpm
04:36:25        <span class="token number">1</span>     <span class="token number">14845</span>    <span class="token number">0.00</span>    <span class="token number">2.00</span>    <span class="token number">0.00</span>    <span class="token number">2.00</span>    <span class="token number">2.00</span>     <span class="token number">1</span>  php-fpm
04:36:25        <span class="token number">1</span>     <span class="token number">14855</span>    <span class="token number">0.00</span>    <span class="token number">1.00</span>    <span class="token number">0.00</span>    <span class="token number">1.00</span>    <span class="token number">1.00</span>     <span class="token number">1</span>  php-fpm
04:36:25        <span class="token number">1</span>     <span class="token number">14857</span>    <span class="token number">1.00</span>    <span class="token number">2.00</span>    <span class="token number">0.00</span>    <span class="token number">1.00</span>    <span class="token number">3.00</span>     <span class="token number">0</span>  php-fpm
04:36:25        <span class="token number">0</span>     <span class="token number">15006</span>    <span class="token number">0.00</span>    <span class="token number">1.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">1.00</span>     <span class="token number">0</span>  dockerd
04:36:25        <span class="token number">0</span>     <span class="token number">15801</span>    <span class="token number">0.00</span>    <span class="token number">1.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">1.00</span>     <span class="token number">1</span>  pidstat
04:36:25        <span class="token number">1</span>     <span class="token number">17084</span>    <span class="token number">1.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">2.00</span>    <span class="token number">1.00</span>     <span class="token number">0</span>  stress
04:36:25        <span class="token number">0</span>     <span class="token number">31116</span>    <span class="token number">0.00</span>    <span class="token number">1.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">1.00</span>     <span class="token number">0</span>  atopacctd
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 观察一会儿，你是不是发现，所有进程的 CPU 使用率也都不高啊，最高的 Docker 和 Nginx 也只有 4% 和 3%，即使所有进程的 CPU 使用率都加起来，也不过是 21%，离 80% 还差得远呢！</p>
<p> 后来我发现，会出现这种情况，很可能是因为前面的分析漏了一些关键信息。你可以先暂停一下，自己往上翻，重新操作检查一遍。或者，我们一起返回去分析 top 的输出，看看能不能有新发现。</p>
<p> 现在，我们回到第一个终端，重新运行 top 命令，并观察一会儿：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">top</span>
<span class="token function">top</span> - 04:58:24 up <span class="token number">14</span> days, <span class="token number">15</span>:47,  <span class="token number">1</span> user,  load average: <span class="token number">3.39</span>, <span class="token number">3.82</span>, <span class="token number">2.74</span>
Tasks: <span class="token number">149</span> total,   <span class="token number">6</span> running,  <span class="token number">93</span> sleeping,   <span class="token number">0</span> stopped,   <span class="token number">0</span> zombie
%Cpu<span class="token punctuation">(</span>s<span class="token punctuation">)</span>: <span class="token number">77.7</span> us, <span class="token number">19.3</span> sy,  <span class="token number">0.0</span> ni,  <span class="token number">2.0</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">1.0</span> si,  <span class="token number">0.0</span> st
KiB Mem <span class="token builtin class-name">:</span>  <span class="token number">8169348</span> total,  <span class="token number">2543916</span> free,   <span class="token number">457976</span> used,  <span class="token number">5167456</span> buff/cache
KiB Swap:        <span class="token number">0</span> total,        <span class="token number">0</span> free,        <span class="token number">0</span> used.  <span class="token number">7363908</span> avail Mem

PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
<span class="token number">6947</span> systemd+  <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">33104</span>   <span class="token number">3764</span>   <span class="token number">2340</span> S   <span class="token number">4.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:32.69 nginx
<span class="token number">6882</span> root      <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">12108</span>   <span class="token number">8360</span>   <span class="token number">3884</span> S   <span class="token number">2.0</span>  <span class="token number">0.1</span>   <span class="token number">0</span>:31.40 docker-containe
<span class="token number">15465</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">15256</span>   <span class="token number">7576</span> S   <span class="token number">2.0</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:00.62 php-fpm
<span class="token number">15466</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">15196</span>   <span class="token number">7516</span> S   <span class="token number">2.0</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:00.62 php-fpm
<span class="token number">15489</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">16200</span>   <span class="token number">8520</span> S   <span class="token number">2.0</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:00.62 php-fpm
<span class="token number">6948</span> systemd+  <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">33104</span>   <span class="token number">3764</span>   <span class="token number">2340</span> S   <span class="token number">1.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.95 nginx
<span class="token number">15006</span> root      <span class="token number">20</span>   <span class="token number">0</span> <span class="token number">1168608</span>  <span class="token number">65632</span>  <span class="token number">37536</span> S   <span class="token number">1.0</span>  <span class="token number">0.8</span>   <span class="token number">9</span>:51.09 dockerd
<span class="token number">15476</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">16200</span>   <span class="token number">8520</span> S   <span class="token number">1.0</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:00.61 php-fpm
<span class="token number">15477</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">16200</span>   <span class="token number">8520</span> S   <span class="token number">1.0</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:00.61 php-fpm
<span class="token number">24340</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>    <span class="token number">8184</span>   <span class="token number">1616</span>    <span class="token number">536</span> R   <span class="token number">1.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.01 stress
<span class="token number">24342</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>    <span class="token number">8196</span>   <span class="token number">1580</span>    <span class="token number">492</span> R   <span class="token number">1.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.01 stress
<span class="token number">24344</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>    <span class="token number">8188</span>   <span class="token number">1056</span>    <span class="token number">492</span> R   <span class="token number">1.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.01 stress
<span class="token number">24347</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>    <span class="token number">8184</span>   <span class="token number">1356</span>    <span class="token number">540</span> R   <span class="token number">1.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.01 stress
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 这次从头开始看 top 的每行输出，咦？Tasks 这一行看起来有点奇怪，就绪队列中居然有 6 个 Running 状态的进程（6 running），是不是有点多呢？</p>
<p> 回想一下 ab 测试的参数，并发请求数是 5。再看进程列表里， php-fpm 的数量也是 5，再加上 Nginx，好像同时有 6 个进程也并不奇怪。但真的是这样吗？</p>
<p> 再仔细看进程列表，这次主要看 Running（R） 状态的进程。你有没有发现， Nginx 和所有的 php-fpm 都处于 Sleep（S）状态，而真正处于 Running（R）状态的，却是几个 stress 进程。这几个 stress 进程就比较奇怪了，需要我们做进一步的分析。</p>
<p> 我们还是使用 pidstat 来分析这几个进程，并且使用 -p 选项指定进程的 PID。首先，从上面 top 的结果中，找到这几个进程的 PID。比如，先随便找一个 24344，然后用 pidstat 命令看一下它的 CPU 使用情况：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ pidstat -p <span class="token number">24344</span>

<span class="token number">16</span>:14:55      <span class="token environment constant">UID</span>       PID    %usr %system  %guest   %wait    %CPU   CPU  Command<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p> 奇怪，居然没有任何输出。难道是 pidstat 命令出问题了吗？之前我说过，<strong>在怀疑性能工具出问题前，最好还是先用其他工具交叉确认一下。</strong>那用什么工具呢？ ps 应该是最简单易用的。我们在终端里运行下面的命令，看看 24344 进程的状态：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 从所有进程中查找 PID 是 24344 的进程</span>
$ <span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">grep</span> <span class="token number">24344</span>
root      <span class="token number">9628</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>  <span class="token number">14856</span>  <span class="token number">1096</span> pts/0    S+   <span class="token number">16</span>:15   <span class="token number">0</span>:00 <span class="token function">grep</span> --color<span class="token operator">=</span>auto <span class="token number">24344</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p> 还是没有输出。现在终于发现问题，原来这个进程已经不存在了，所以 pidstat 就没有任何输出。既然进程都没了，那性能问题应该也跟着没了吧。我们再用 top 命令确认一下：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">top</span>
<span class="token punctuation">..</span>.
%Cpu<span class="token punctuation">(</span>s<span class="token punctuation">)</span>: <span class="token number">80.9</span> us, <span class="token number">14.9</span> sy,  <span class="token number">0.0</span> ni,  <span class="token number">2.8</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">1.3</span> si,  <span class="token number">0.0</span> st
<span class="token punctuation">..</span>.

PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
<span class="token number">6882</span> root      <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">12108</span>   <span class="token number">8360</span>   <span class="token number">3884</span> S   <span class="token number">2.7</span>  <span class="token number">0.1</span>   <span class="token number">0</span>:45.63 docker-containe
<span class="token number">6947</span> systemd+  <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">33104</span>   <span class="token number">3764</span>   <span class="token number">2340</span> R   <span class="token number">2.7</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:47.79 nginx
<span class="token number">3865</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">336696</span>  <span class="token number">15056</span>   <span class="token number">7376</span> S   <span class="token number">2.0</span>  <span class="token number">0.2</span>   <span class="token number">0</span>:00.15 php-fpm
<span class="token number">6779</span> daemon    <span class="token number">20</span>   <span class="token number">0</span>    <span class="token number">8184</span>   <span class="token number">1112</span>    <span class="token number">556</span> R   <span class="token number">0.3</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.01 stress
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 好像又错了。结果还跟原来一样，用户 CPU 使用率还是高达 80.9%，系统 CPU 接近 15%，而空闲 CPU 只有 2.8%，Running 状态的进程有 Nginx、stress 等。</p>
<p> 可是，刚刚我们看到 stress 进程不存在了，怎么现在还在运行呢？再细看一下 top 的输出，原来，这次 stress 进程的 PID 跟前面不一样了，原来的 PID 24344 不见了，现在的是 6779。</p>
<p> 进程的 PID 在变，这说明什么呢？在我看来，要么是这些进程在不停地重启，要么就是全新的进程，这无非也就两个原因：</p>
<ul>
<li>第一个原因，进程在不停地崩溃重启，比如因为段错误、配置错误等等，这时，进程在退出后可能又被监控系统自动重启了。</li>
<li><p>第二个原因，这些进程都是短时进程，也就是在其他应用内部通过 exec 调用的外面命令。这些命令一般都只运行很短的时间就会结束，你很难用 top 这种间隔时间比较长的工具发现（上面的案例，我们碰巧发现了）。</p>
<p>至于 stress，我们前面提到过，它是一个常用的压力测试工具。它的 PID 在不断变化中，看起来像是被其他进程调用的短时进程。要想继续分析下去，还得找到它们的父进程。</p>
<p>要怎么查找一个进程的父进程呢？没错，用 pstree 就可以用树状形式显示所有进程之间的关系：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ pstree <span class="token operator">|</span> <span class="token function">grep</span> stress
        <span class="token operator">|</span>-docker-containe-+-php-fpm-+-php-fpm---sh---stress
        <span class="token operator">|</span>         <span class="token operator">|</span>-3*<span class="token punctuation">[</span>php-fpm---sh---stress---stress<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>从这里可以看到，stress 是被 php-fpm 调用的子进程，并且进程数量不止一个（这里是 3 个）。找到父进程后，我们能进入 app 的内部分析了。</p>
<p>首先，当然应该去看看它的源码。运行下面的命令，把案例应用的源码拷贝到 app 目录，然后再执行 grep 查找是不是有代码再调用 stress 命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 拷贝源码到本地</span>
$ docker <span class="token function">cp</span> phpfpm:/app <span class="token builtin class-name">.</span>

<span class="token comment"># grep 查找看看是不是有代码在调用 stress 命令</span>
$ <span class="token function">grep</span> stress -r app
app/index.php:// fake I/O with stress <span class="token punctuation">(</span>via write<span class="token punctuation">(</span><span class="token punctuation">)</span>/unlink<span class="token punctuation">(</span><span class="token punctuation">))</span>.
app/index.php:<span class="token variable">$result</span> <span class="token operator">=</span> exec<span class="token punctuation">(</span><span class="token string">"/usr/local/bin/stress -t 1 -d 1 2&gt;&amp;1"</span>, <span class="token variable">$output</span>, <span class="token variable">$status</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>找到了，果然是 <a target="_blank" rel="noopener" href="https://github.com/feiskyer/linux-perf-examples/blob/master/nginx-short-process/app/index.php">app/index.php</a> 文件中直接调用了 stress 命令。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> app/index.php
<span class="token operator">&lt;</span>?php
// fake I/O with stress <span class="token punctuation">(</span>via write<span class="token punctuation">(</span><span class="token punctuation">)</span>/unlink<span class="token punctuation">(</span><span class="token punctuation">))</span>.
<span class="token variable">$result</span> <span class="token operator">=</span> exec<span class="token punctuation">(</span><span class="token string">"/usr/local/bin/stress -t 1 -d 1 2&gt;&amp;1"</span>, <span class="token variable">$output</span>, <span class="token variable">$status</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>isset<span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">"verbose"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">"verbose"</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$status</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token builtin class-name">echo</span> <span class="token string">"Server internal error: "</span><span class="token punctuation">;</span>
print_r<span class="token punctuation">(</span><span class="token variable">$output</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
<span class="token builtin class-name">echo</span> <span class="token string">"It works!"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
?<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到，源码里对每个请求都会调用一个 stress 命令，模拟 I/O 压力。从注释上看，stress 会通过 write() 和 unlink() 对 I/O 进程进行压测，看来，这应该就是系统 CPU 使用率升高的根源了。</p>
<p>不过，stress 模拟的是 I/O 压力，而之前在 top 的输出中看到的，却一直是用户 CPU 和系统 CPU 升高，并没见到 iowait 升高。这又是怎么回事呢？stress 到底是不是 CPU 使用率升高的原因呢？</p>
<p>我们还得继续往下走。从代码中可以看到，给请求加入 verbose=1 参数后，就可以查看 stress 的输出。你先试试看，在第二个终端运行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">curl</span> http://192.168.0.10:10000?verbose<span class="token operator">=</span><span class="token number">1</span>
Server internal error: Array
<span class="token punctuation">(</span>
    <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">&gt;</span> stress: info: <span class="token punctuation">[</span><span class="token number">19607</span><span class="token punctuation">]</span> dispatching hogs: <span class="token number">0</span> cpu, <span class="token number">0</span> io, <span class="token number">0</span> vm, <span class="token number">1</span> hdd
    <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">&gt;</span> stress: FAIL: <span class="token punctuation">[</span><span class="token number">19608</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">563</span><span class="token punctuation">)</span> mkstemp failed: Permission denied
    <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">&gt;</span> stress: FAIL: <span class="token punctuation">[</span><span class="token number">19607</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">394</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span>-- worker <span class="token number">19608</span> returned error <span class="token number">1</span>
    <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">&gt;</span> stress: WARN: <span class="token punctuation">[</span><span class="token number">19607</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">396</span><span class="token punctuation">)</span> now reaping child worker processes
    <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">&gt;</span> stress: FAIL: <span class="token punctuation">[</span><span class="token number">19607</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">)</span> <span class="token function">kill</span> error: No such process
    <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">&gt;</span> stress: FAIL: <span class="token punctuation">[</span><span class="token number">19607</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">451</span><span class="token punctuation">)</span> failed run completed <span class="token keyword">in</span> 0s
<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>看错误消息 <strong>mkstemp failed: Permission denied</strong> ，以及 <strong>failed run completed in 0s</strong>。原来 stress 命令并没有成功，它因为权限问题失败退出了。看来，我们发现了一个 PHP 调用外部 stress 命令的 bug：没有权限创建临时文件。</p>
<p>从这里我们可以猜测，正是由于权限错误，大量的 stress 进程在启动时初始化失败，进而导致用户 CPU 使用率的升高。</p>
<p>分析出问题来源，下一步是不是就要开始优化了呢？当然不是！既然只是猜测，那就需要再确认一下，这个猜测到底对不对，是不是真的有大量的 stress 进程。该用什么工具或指标呢？</p>
<p>我们前面已经用了 top、pidstat、pstree 等工具，没有发现大量的 stress 进程。那么，还有什么其他的工具可以用吗？</p>
<p>还记得上一期提到的 perf 吗？它可以用来分析 CPU 性能事件，用在这里就很合适。依旧在第一个终端中运行 perf record -g 命令 ，并等待一会儿（比如 15 秒）后按 Ctrl+C 退出。然后再运行 perf report 查看报告：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 记录性能事件，等待大约 15 秒后按 Ctrl+C 退出</span>
$ perf record -g

<span class="token comment"># 查看报告</span>
$ perf report<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样，你就可以看到下图这个性能报告：</p>
<p><img src="/images/《Linux性能优化实战》学习笔记/系统CPU很高但找不到应该案例分析perf截图.png" alt="系统CPU很高但找不到应该案例分析perf截图"></p>
<p>你看，stress 占了所有 CPU 时钟事件的 77%，而 stress 调用调用栈中比例最高的，是随机数生成函数 random()，看来它的确就是 CPU 使用率升高的元凶了。随后的优化就很简单了，只要修复权限问题，并减少或删除 stress 的调用，就可以减轻系统的 CPU 压力。</p>
</li>
</ul>
</li>
</ol>
<h4 id="6-2-execsnoop"><a href="#6-2-execsnoop" class="headerlink" title="6.2 execsnoop"></a>6.2 execsnoop</h4><pre><code>在这个案例中，我们使用了 top、pidstat、pstree 等工具分析了系统 CPU 使用率高的问题，并发现 CPU 升高是短时进程 stress 导致的，但是整个分析过程还是比较复杂的。对于这类问题，有没有更好的方法监控呢？

[execsnoop](https://github.com/brendangregg/perf-tools/blob/master/execsnoop) 就是一个专为短时进程设计的工具。它通过 ftrace 实时监控进程的 exec() 行为，并输出短时进程的基本信息，包括进程 PID、父进程 PID、命令行参数以及执行的结果。

比如，用 execsnoop 监控上述案例，就可以直接得到 stress 进程的父进程 PID 以及它的命令行参数，并可以发现大量的 stress 进程在不停启动：

<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 按 Ctrl+C 结束</span>
$ execsnoop
PCOMM            PID    <span class="token environment constant">PPID</span>   RET ARGS
<span class="token function">sh</span>               <span class="token number">30394</span>  <span class="token number">30393</span>    <span class="token number">0</span>
stress           <span class="token number">30396</span>  <span class="token number">30394</span>    <span class="token number">0</span> /usr/local/bin/stress -t <span class="token number">1</span> -d <span class="token number">1</span>
<span class="token function">sh</span>               <span class="token number">30398</span>  <span class="token number">30393</span>    <span class="token number">0</span>
stress           <span class="token number">30399</span>  <span class="token number">30398</span>    <span class="token number">0</span> /usr/local/bin/stress -t <span class="token number">1</span> -d <span class="token number">1</span>
<span class="token function">sh</span>               <span class="token number">30402</span>  <span class="token number">30400</span>    <span class="token number">0</span>
stress           <span class="token number">30403</span>  <span class="token number">30402</span>    <span class="token number">0</span> /usr/local/bin/stress -t <span class="token number">1</span> -d <span class="token number">1</span>
<span class="token function">sh</span>               <span class="token number">30405</span>  <span class="token number">30393</span>    <span class="token number">0</span>
stress           <span class="token number">30407</span>  <span class="token number">30405</span>    <span class="token number">0</span> /usr/local/bin/stress -t <span class="token number">1</span> -d <span class="token number">1</span>
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
execsnoop 所用的 ftrace 是一种常用的动态追踪技术，一般用于分析 Linux 内核的运行时行为，后面课程我也会详细介绍并带你使用。
</code></pre><h4 id="6-3-小结"><a href="#6-3-小结" class="headerlink" title="6.3 小结"></a>6.3 小结</h4><p>碰到常规问题无法解释的 CPU 使用率情况时，首先要想到有可能是短时应用导致的问题，比如有可能是下面这两种情况。</p>
<ul>
<li>第一，应用里直接调用了其他二进制程序，这些程序通常运行时间比较短，通过 top 等工具也不容易发现。</li>
<li>第二，应用本身在不停地崩溃重启，而启动过程的资源初始化，很可能会占用相当多的 CPU。</li>
</ul>
<p>对于这类进程，我们可以用 pstree 或者 execsnoop 找到它们的父进程，再从父进程所在的应用入手，排查问题的根源。</p>
<h3 id="07-案例篇：系统中出现大量不可中断进程和僵尸进程怎么办？（上）"><a href="#07-案例篇：系统中出现大量不可中断进程和僵尸进程怎么办？（上）" class="headerlink" title="07 | 案例篇：系统中出现大量不可中断进程和僵尸进程怎么办？（上）"></a>07 | 案例篇：系统中出现大量不可中断进程和僵尸进程怎么办？（上）</h3><h4 id="7-1-进程状态"><a href="#7-1-进程状态" class="headerlink" title="7.1 进程状态"></a>7.1 进程状态</h4><p>当 iowait 升高时，进程很可能因为得不到硬件的响应，而长时间处于不可中断状态。从 ps 或者 top 命令的输出中，你可以发现它们都处于 D 状态，也就是不可中断状态（Uninterruptible Sleep）。</p>
<p>top 和 ps 是最常用的查看进程状态的工具，我们就从 top 的输出开始。下面是一个 top 命令输出的示例，S 列（也就是 Status 列）表示进程的状态。从这个示例里，你可以看到 R、D、Z、S、I 等几个状态，它们分别是什么意思呢？</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">top</span>
  PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
<span class="token number">28961</span> root      <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">43816</span>   <span class="token number">3148</span>   <span class="token number">4040</span> R   <span class="token number">3.2</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.01 <span class="token function">top</span>
  <span class="token number">620</span> root      <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">37280</span>  <span class="token number">33676</span>    <span class="token number">908</span> D   <span class="token number">0.3</span>  <span class="token number">0.4</span>   <span class="token number">0</span>:00.01 app
    <span class="token number">1</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">160072</span>   <span class="token number">9416</span>   <span class="token number">6752</span> S   <span class="token number">0.0</span>  <span class="token number">0.1</span>   <span class="token number">0</span>:37.64 systemd
 <span class="token number">1896</span> root      <span class="token number">20</span>   <span class="token number">0</span>       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> Z   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.00 devapp
    <span class="token number">2</span> root      <span class="token number">20</span>   <span class="token number">0</span>       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> S   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.10 kthreadd
    <span class="token number">4</span> root       <span class="token number">0</span> -20       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> I   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.00 kworker/0:0H
    <span class="token number">6</span> root       <span class="token number">0</span> -20       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> I   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.00 mm_percpu_wq
    <span class="token number">7</span> root      <span class="token number">20</span>   <span class="token number">0</span>       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> S   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:06.37 ksoftirqd/0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们挨个来看一下：</p>
<ul>
<li>R 是 Running 或 Runnable 的缩写，表示进程在 CPU 的就绪队列中，正在运行或者正在等待运行。</li>
<li>D 是 Disk Sleep 的缩写，也就是不可中断状态睡眠（Uninterruptible Sleep），一般表示进程正在跟硬件交互，并且交互过程不允许被其他进程或中断打断。</li>
<li>Z 是 Zombie 的缩写，如果你玩过“植物大战僵尸”这款游戏，应该知道它的意思。它表示僵尸进程，也就是进程实际上已经结束了，但是父进程还没有回收它的资源（比如进程的描述符、PID 等）。</li>
<li>S 是 Interruptible Sleep 的缩写，也就是可中断状态睡眠，表示进程因为等待某个事件而被系统挂起。当进程等待的事件发生时，它会被唤醒并进入 R 状态。</li>
<li>I 是 Idle 的缩写，也就是空闲状态，用在不可中断睡眠的内核线程上。前面说了，硬件交互导致的不可中断进程用 D 表示，但对某些内核线程来说，它们有可能实际上并没有任何负载，用 Idle 正是为了区分这种情况。要注意，D 状态的进程会导致平均负载升高， I 状态的进程却不会。</li>
</ul>
<p>当然了，上面的示例并没有包括进程的所有状态。除了以上 5 个状态，进程还包括下面这 2 个状态。</p>
<ul>
<li>第一个是 T 或者 t，也就是 Stopped 或 Traced 的缩写，表示进程处于暂停或者跟踪状态。<blockquote>
<p>向一个进程发送 SIGSTOP 信号，它就会因响应这个信号变成暂停状态（Stopped）；再向它发送 SIGCONT 信号，进程又会恢复运行（如果进程是终端里直接启动的，则需要你用 fg 命令，恢复到前台运行）。</p>
<p>而当你用调试器（如 gdb）调试一个进程时，在使用断点中断进程后，进程就会变成跟踪状态，这其实也是一种特殊的暂停状态，只不过你可以用调试器来跟踪并按需要控制进程的运行。</p>
</blockquote>
</li>
<li>另一个是 X，也就是 Dead 的缩写，表示进程已经消亡，所以你不会在 top 或者 ps 命令中看到它。</li>
</ul>
<ol>
<li><p>不可中断状态</p>
<p> 先看不可中断状态，这其实是为了保证进程数据与硬件状态一致，并且正常情况下，不可中断状态在很短时间内就会结束。所以，短时的不可中断状态进程，我们一般可以忽略。</p>
<p> 但如果系统或硬件发生了故障，进程可能会在不可中断状态保持很久，甚至导致系统中出现大量不可中断进程。这时，你就得注意下，系统是不是出现了 I/O 等性能问题。</p>
</li>
<li><p>僵尸进程</p>
<p> 再看僵尸进程，这是多进程应用很容易碰到的问题。正常情况下，当一个进程创建了子进程后，它应该通过系统调用 wait() 或者 waitpid() 等待子进程结束，回收子进程的资源；而子进程在结束时，会向它的父进程发送 SIGCHLD 信号，所以，父进程还可以注册 SIGCHLD 信号的处理函数，异步回收资源。</p>
<p> 如果父进程没这么做，或是子进程执行太快，父进程还没来得及处理子进程状态，子进程就已经提前退出，那这时的子进程就会变成僵尸进程。换句话说，父亲应该一直对儿子负责，善始善终，如果不作为或者跟不上，都会导致“问题少年”的出现。</p>
<p> 通常，僵尸进程持续的时间都比较短，在父进程回收它的资源后就会消亡；或者在父进程退出后，由 init 进程回收后也会消亡。</p>
<p> 一旦父进程没有处理子进程的终止，还一直保持运行状态，那么子进程就会一直处于僵尸状态。大量的僵尸进程会用尽 PID 进程号，导致新进程不能创建，所以这种情况一定要避免。</p>
</li>
</ol>
<h4 id="7-1-案例分析"><a href="#7-1-案例分析" class="headerlink" title="7.1 案例分析"></a>7.1 案例分析</h4><blockquote>
<p>机器配置： 2 CPU, 8 GB 内存。</p>
<p>安装软件：<code>apt install docker.io dstat sysstat</code>。</p>
<blockquote>
<p>dstat 是一个新的性能工具，它吸收了 vmstat、iostat、ifstat 等几种工具的优点，可以同时观察系统的 CPU、磁盘 I/O、网络以及内存使用情况。</p>
</blockquote>
</blockquote>
<ol>
<li><p>首先执行下面的命令运行案例应用：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run --privileged --name<span class="token operator">=</span>app -itd feisky/app:iowait<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>然后，输入 ps 命令，确认案例应用已正常启动。如果一切正常，你应该可以看到如下所示的输出：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">grep</span> /app
root      <span class="token number">4009</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">4376</span>  <span class="token number">1008</span> pts/0    Ss+  05:51   <span class="token number">0</span>:00 /app
root      <span class="token number">4287</span>  <span class="token number">0.6</span>  <span class="token number">0.4</span>  <span class="token number">37280</span> <span class="token number">33660</span> pts/0    D+   05:54   <span class="token number">0</span>:00 /app
root      <span class="token number">4288</span>  <span class="token number">0.6</span>  <span class="token number">0.4</span>  <span class="token number">37280</span> <span class="token number">33668</span> pts/0    D+   05:54   <span class="token number">0</span>:00 /app<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p> 从这个界面，我们可以发现多个 app 进程已经启动，并且它们的状态分别是 Ss+ 和 D+。其中，S 表示可中断睡眠状态，D 表示不可中断睡眠状态，我们在前面刚学过，那后面的 s 和 + 是什么意思呢？不知道也没关系，查一下 <code>man ps</code> 就可以。现在记住，s 表示这个进程是一个会话的领导进程，而 + 表示前台进程组。</p>
<p> 这里又出现了两个新概念，进程组和会话。它们用来管理一组相互关联的进程，意思其实很好理解。</p>
<ul>
<li>进程组表示一组相互关联的进程，比如每个子进程都是父进程所在组的成员；</li>
<li><p>而会话是指共享同一个控制终端的一个或多个进程组。</p>
<p>比如，我们通过 SSH 登录服务器，就会打开一个控制终端（TTY），这个控制终端就对应一个会话。而我们在终端中运行的命令以及它们的子进程，就构成了一个个的进程组，其中，在后台运行的命令，构成后台进程组；在前台运行的命令，构成前台进程组。</p>
<p>明白了这些，我们再用 top 看一下系统的资源使用情况：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 按下数字 1 切换到所有 CPU 的使用情况，观察一会儿按 Ctrl+C 结束</span>
$ <span class="token function">top</span>
<span class="token function">top</span> - 05:56:23 up <span class="token number">17</span> days, <span class="token number">16</span>:45,  <span class="token number">2</span> users,  load average: <span class="token number">2.00</span>, <span class="token number">1.68</span>, <span class="token number">1.39</span>
Tasks: <span class="token number">247</span> total,   <span class="token number">1</span> running,  <span class="token number">79</span> sleeping,   <span class="token number">0</span> stopped, <span class="token number">115</span> zombie
%Cpu0  <span class="token builtin class-name">:</span>  <span class="token number">0.0</span> us,  <span class="token number">0.7</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">38.9</span> id, <span class="token number">60.5</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> st
%Cpu1  <span class="token builtin class-name">:</span>  <span class="token number">0.0</span> us,  <span class="token number">0.7</span> sy,  <span class="token number">0.0</span> ni,  <span class="token number">4.7</span> id, <span class="token number">94.6</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> st
<span class="token punctuation">..</span>.

PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
<span class="token number">4340</span> root      <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">44676</span>   <span class="token number">4048</span>   <span class="token number">3432</span> R   <span class="token number">0.3</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.05 <span class="token function">top</span>
<span class="token number">4345</span> root      <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">37280</span>  <span class="token number">33624</span>    <span class="token number">860</span> D   <span class="token number">0.3</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.01 app
<span class="token number">4344</span> root      <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">37280</span>  <span class="token number">33624</span>    <span class="token number">860</span> D   <span class="token number">0.3</span>  <span class="token number">0.4</span>   <span class="token number">0</span>:00.01 app
   <span class="token number">1</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">160072</span>   <span class="token number">9416</span>   <span class="token number">6752</span> S   <span class="token number">0.0</span>  <span class="token number">0.1</span>   <span class="token number">0</span>:38.59 systemd
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从这里你能看出什么问题吗？</p>
</li>
<li><p>先看第一行的平均负载（ Load Average），过去 1 分钟、5 分钟和 15 分钟内的平均负载在依次减小，说明平均负载正在升高；而 1 分钟内的平均负载已经达到系统的 CPU 个数，说明系统很可能已经有了性能瓶颈。</p>
</li>
<li>再看第二行的 Tasks，有 1 个正在运行的进程，但僵尸进程比较多，而且还在不停增加，说明有子进程在退出时没被清理。</li>
<li>接下来看两个 CPU 的使用率情况，用户 CPU 和系统 CPU 都不高，但 iowait 分别是 60.5% 和 94.6%，好像有点儿不正常。</li>
<li><p>最后再看每个进程的情况， CPU 使用率最高的进程只有 0.3%，看起来并不高；但有两个进程处于 D 状态，它们可能在等待 I/O，但光凭这里并不能确定是它们导致了 iowait 升高。</p>
<p>汇总一下：</p>
</li>
<li><p>第一点，iowait 太高了，导致系统的平均负载升高，甚至达到了系统 CPU 的个数。</p>
</li>
<li>第二点，僵尸进程在不断增多，说明有程序没能正确清理子进程的资源。</li>
</ul>
</li>
</ol>
<h4 id="7-2-小结"><a href="#7-2-小结" class="headerlink" title="7.2 小结"></a>7.2 小结</h4><p>进程的状态包括运行（R）、空闲（I）、不可中断睡眠（D）、可中断睡眠（S）、僵尸（Z）以及暂停（T）等。</p>
<p>其中，不可中断状态和僵尸状态，是我们今天学习的重点。</p>
<ul>
<li>不可中断状态，表示进程正在跟硬件交互，为了保护进程数据和硬件的一致性，系统不允许其他进程或中断打断这个进程。进程长时间处于不可中断状态，通常表示系统有 I/O 性能问题。</li>
<li>僵尸进程表示进程已经退出，但它的父进程还没有回收子进程占用的资源。短暂的僵尸状态我们通常不必理会，但进程长时间处于僵尸状态，就应该注意了，可能有应用程序没有正常处理子进程的退出。</li>
</ul>
<h3 id="08-案例篇：系统中出现大量不可中断进程和僵尸进程怎么办？（下）"><a href="#08-案例篇：系统中出现大量不可中断进程和僵尸进程怎么办？（下）" class="headerlink" title="08 | 案例篇：系统中出现大量不可中断进程和僵尸进程怎么办？（下）"></a>08 | 案例篇：系统中出现大量不可中断进程和僵尸进程怎么办？（下）</h3><p>打开一个终端，登录到上次的机器中。然后执行下面的命令，重新运行这个案例：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 先删除上次启动的案例</span>
$ docker <span class="token function">rm</span> -f app
<span class="token comment"># 重新运行案例</span>
$ docker run --privileged --name<span class="token operator">=</span>app -itd feisky/app:iowait<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="8-1-iowait-分析"><a href="#8-1-iowait-分析" class="headerlink" title="8.1 iowait 分析"></a>8.1 iowait 分析</h4><p>一提到 iowait 升高，你首先会想要查询系统的 I/O 情况。我一般也是这种思路，那么什么工具可以查询系统的 I/O 情况呢？</p>
<p>这里，我推荐的正是上节课要求安装的 dstat ，它的好处是，可以同时查看 CPU 和 I/O 这两种资源的使用情况，便于对比分析。</p>
<ol>
<li><p>在终端中运行 dstat 命令，观察 CPU 和 I/O 的使用情况：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 间隔 1 秒输出 10 组数据</span>
$ dstat <span class="token number">1</span> <span class="token number">10</span>
You did not <span class="token keyword">select</span> any stats, using -cdngy by default.
--total-cpu-usage-- -dsk/total- -net/total- ---paging-- ---system--
usr sys idl wai stl<span class="token operator">|</span> <span class="token builtin class-name">read</span>  writ<span class="token operator">|</span> recv  send<span class="token operator">|</span>  <span class="token keyword">in</span>   out <span class="token operator">|</span> int   csw
  <span class="token number">0</span>   <span class="token number">0</span>  <span class="token number">96</span>   <span class="token number">4</span>   <span class="token number">0</span><span class="token operator">|</span>1219k  408k<span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span>  <span class="token number">42</span>   <span class="token number">885</span>
  <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">2</span>  <span class="token number">98</span>   <span class="token number">0</span><span class="token operator">|</span>  34M    <span class="token number">0</span> <span class="token operator">|</span> 198B  790B<span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span>  <span class="token number">42</span>   <span class="token number">138</span>
  <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span> <span class="token number">100</span>   <span class="token number">0</span><span class="token operator">|</span>  34M    <span class="token number">0</span> <span class="token operator">|</span>  66B  342B<span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span>  <span class="token number">42</span>   <span class="token number">135</span>
  <span class="token number">0</span>   <span class="token number">0</span>  <span class="token number">84</span>  <span class="token number">16</span>   <span class="token number">0</span><span class="token operator">|</span>5633k    <span class="token number">0</span> <span class="token operator">|</span>  66B  342B<span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span>  <span class="token number">52</span>   <span class="token number">177</span>
  <span class="token number">0</span>   <span class="token number">3</span>  <span class="token number">39</span>  <span class="token number">58</span>   <span class="token number">0</span><span class="token operator">|</span>  22M    <span class="token number">0</span> <span class="token operator">|</span>  66B  342B<span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span>  <span class="token number">43</span>   <span class="token number">144</span>
  <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span> <span class="token number">100</span>   <span class="token number">0</span><span class="token operator">|</span>  34M    <span class="token number">0</span> <span class="token operator">|</span> 200B  450B<span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span>  <span class="token number">46</span>   <span class="token number">147</span>
  <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">2</span>  <span class="token number">98</span>   <span class="token number">0</span><span class="token operator">|</span>  34M    <span class="token number">0</span> <span class="token operator">|</span>  66B  342B<span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span>  <span class="token number">45</span>   <span class="token number">134</span>
  <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span> <span class="token number">100</span>   <span class="token number">0</span><span class="token operator">|</span>  34M    <span class="token number">0</span> <span class="token operator">|</span>  66B  342B<span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span>  <span class="token number">39</span>   <span class="token number">131</span>
  <span class="token number">0</span>   <span class="token number">0</span>  <span class="token number">83</span>  <span class="token number">17</span>   <span class="token number">0</span><span class="token operator">|</span>5633k    <span class="token number">0</span> <span class="token operator">|</span>  66B  342B<span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span>  <span class="token number">46</span>   <span class="token number">168</span>
  <span class="token number">0</span>   <span class="token number">3</span>  <span class="token number">39</span>  <span class="token number">59</span>   <span class="token number">0</span><span class="token operator">|</span>  22M    <span class="token number">0</span> <span class="token operator">|</span>  66B  342B<span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span>  <span class="token number">37</span>   <span class="token number">134</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 从 dstat 的输出，我们可以看到，每当 iowait 升高（wai）时，磁盘的读请求（read）都会很大。这说明 iowait 的升高跟磁盘的读请求有关，很可能就是磁盘读导致的。</p>
<p> 那到底是哪个进程在读磁盘呢？不知道你还记不记得，上节在 top 里看到的不可中断状态进程，我觉得它就很可疑，我们试着来分析下。</p>
</li>
<li><p>继续在刚才的终端中，运行 top 命令，观察 D 状态的进程：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 观察一会儿按 Ctrl+C 结束</span>
$ <span class="token function">top</span>
<span class="token punctuation">..</span>.
 PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
<span class="token number">4340</span> root      <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">44676</span>   <span class="token number">4048</span>   <span class="token number">3432</span> R   <span class="token number">0.3</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.05 <span class="token function">top</span>
<span class="token number">4345</span> root      <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">37280</span>  <span class="token number">33624</span>    <span class="token number">860</span> D   <span class="token number">0.3</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.01 app
<span class="token number">4344</span> root      <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">37280</span>  <span class="token number">33624</span>    <span class="token number">860</span> D   <span class="token number">0.3</span>  <span class="token number">0.4</span>   <span class="token number">0</span>:00.01 app
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 我们从 top 的输出找到 D 状态进程的 PID，你可以发现，这个界面里有两个 D 状态的进程，PID 分别是 4344 和 4345。</p>
<p> 一般要查看某一个进程的资源使用情况，都可以用我们的老朋友 pidstat，不过这次记得加上 -d 参数，以便输出 I/O 使用情况。</p>
</li>
<li><p>以 4344 为例，我们在终端里运行下面的 pidstat 命令，并用 -p 4344 参数指定进程号：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -d 展示 I/O 统计数据，-p 指定进程号，间隔 1 秒输出 3 组数据</span>
$ pidstat -d -p <span class="token number">4344</span> <span class="token number">1</span> <span class="token number">3</span>
06:38:50      <span class="token environment constant">UID</span>       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command
06:38:51        <span class="token number">0</span>      <span class="token number">4344</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>       <span class="token number">0</span>  app
06:38:52        <span class="token number">0</span>      <span class="token number">4344</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>       <span class="token number">0</span>  app
06:38:53        <span class="token number">0</span>      <span class="token number">4344</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>       <span class="token number">0</span>  app<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 在这个输出中， kB_rd 表示每秒读的 KB 数， kB_wr 表示每秒写的 KB 数，iodelay 表示 I/O 的延迟（单位是时钟周期）。它们都是 0，那就表示此时没有任何的读写，说明问题不是 4344 进程导致的。</p>
<p> 可是，用同样的方法分析进程 4345，你会发现，它也没有任何磁盘读写。</p>
<p> 那要怎么知道，到底是哪个进程在进行磁盘读写呢？我们继续使用 pidstat，但这次去掉进程号，干脆就来观察所有进程的 I/O 使用情况。</p>
</li>
<li><p>在终端中运行下面的 pidstat 命令：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 间隔 1 秒输出多组数据 (这里是 20 组)</span>
$ pidstat -d <span class="token number">1</span> <span class="token number">20</span>
<span class="token punctuation">..</span>.
06:48:46      <span class="token environment constant">UID</span>       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command
06:48:47        <span class="token number">0</span>      <span class="token number">4615</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>       <span class="token number">1</span>  kworker/u4:1
06:48:47        <span class="token number">0</span>      <span class="token number">6080</span>  <span class="token number">32768.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>     <span class="token number">170</span>  app
06:48:47        <span class="token number">0</span>      <span class="token number">6081</span>  <span class="token number">32768.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>     <span class="token number">184</span>  app

06:48:47      <span class="token environment constant">UID</span>       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command
06:48:48        <span class="token number">0</span>      <span class="token number">6080</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>     <span class="token number">110</span>  app

06:48:48      <span class="token environment constant">UID</span>       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command
06:48:49        <span class="token number">0</span>      <span class="token number">6081</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>     <span class="token number">191</span>  app

06:48:49      <span class="token environment constant">UID</span>       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command

06:48:50      <span class="token environment constant">UID</span>       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command
06:48:51        <span class="token number">0</span>      <span class="token number">6082</span>  <span class="token number">32768.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>       <span class="token number">0</span>  app
06:48:51        <span class="token number">0</span>      <span class="token number">6083</span>  <span class="token number">32768.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>       <span class="token number">0</span>  app

06:48:51      <span class="token environment constant">UID</span>       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command
06:48:52        <span class="token number">0</span>      <span class="token number">6082</span>  <span class="token number">32768.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>     <span class="token number">184</span>  app
06:48:52        <span class="token number">0</span>      <span class="token number">6083</span>  <span class="token number">32768.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>     <span class="token number">175</span>  app

06:48:52      <span class="token environment constant">UID</span>       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command
06:48:53        <span class="token number">0</span>      <span class="token number">6083</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>     <span class="token number">105</span>  app
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 观察一会儿可以发现，的确是 app 进程在进行磁盘读，并且每秒读的数据有 32 MB，看来就是 app 的问题。不过，app 进程到底在执行啥 I/O 操作呢？</p>
<p> 这里，我们需要回顾一下进程用户态和内核态的区别。进程想要访问磁盘，就必须使用系统调用，所以接下来，重点就是找出 app 进程的系统调用了。</p>
</li>
<li><p>strace 正是最常用的跟踪进程系统调用的工具。所以，我们从 pidstat 的输出中拿到进程的 PID 号，比如 6082，然后在终端中运行 strace 命令，并用 -p 参数指定 PID 号：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">strace</span> -p <span class="token number">6082</span>
strace: attach: ptrace<span class="token punctuation">(</span>PTRACE_SEIZE, <span class="token number">6082</span><span class="token punctuation">)</span>: Operation not permitted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> <strong>一般遇到这种问题时，我会先检查一下进程的状态是否正常。</strong> 比如，继续在终端中运行 ps 命令，并使用 grep 找出刚才的 6082 号进程：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">grep</span> <span class="token number">6082</span>
root      <span class="token number">6082</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> pts/0    Z+   <span class="token number">13</span>:43   <span class="token number">0</span>:00 <span class="token punctuation">[</span>app<span class="token punctuation">]</span> <span class="token operator">&lt;</span>defunct<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 果然，进程 6082 已经变成了 Z 状态，也就是僵尸进程。僵尸进程都是已经退出的进程，所以就没法儿继续分析它的系统调用。关于僵尸进程的处理方法，我们一会儿再说，现在还是继续分析 iowait 的问题。</p>
<p> 到这一步，你应该注意到了，系统 iowait 的问题还在继续，但是 top、pidstat 这类工具已经不能给出更多的信息了。这时，我们就应该求助那些基于事件记录的动态追踪工具了。</p>
</li>
<li><p>你可以用 perf top 看看有没有新发现。再或者，可以像我一样，在终端中运行 perf record，持续一会儿（例如 15 秒），然后按 Ctrl+C 退出，再运行 perf report 查看报告：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ perf record -g
$ perf report<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 接着，找到我们关注的 app 进程，按回车键展开调用栈，你就会得到下面这张调用关系图：</p>
<p> <img src="/images/《Linux性能优化实战》学习笔记/大量不可中断进程和僵尸进程案例iowait分析perf截图.png" alt="大量不可中断进程和僵尸进程案例iowait分析perf截图"></p>
<p> 这个图里的 swapper 是内核中的调度进程，你可以先忽略掉。</p>
<p> 我们来看其他信息，你可以发现， app 的确在通过系统调用 sys_read() 读取数据。并且从 new_sync_read 和 blkdev_direct_IO 能看出，进程正在对磁盘进行<strong>直接读</strong>，也就是绕过了系统缓存，每个读请求都会从磁盘直接读，这就可以解释我们观察到的 iowait 升高了。</p>
<p> 看来，罪魁祸首是 app 内部进行了磁盘的直接 I/O 啊！</p>
<p> 查看源码文件 <a target="_blank" rel="noopener" href="https://github.com/feiskyer/linux-perf-examples/blob/master/high-iowait-process/app.c">app.c</a>，你会发现它果然使用了 O_DIRECT 选项打开磁盘，于是绕过了系统缓存，直接对磁盘进行读写。</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">open</span><span class="token punctuation">(</span>disk<span class="token punctuation">,</span> O_RDONLY<span class="token operator">|</span>O_DIRECT<span class="token operator">|</span>O_LARGEFILE<span class="token punctuation">,</span> <span class="token number">0755</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 直接读写磁盘，对 I/O 敏感型应用（比如数据库系统）是很友好的，因为你可以在应用中，直接控制磁盘的读写。但在大部分情况下，我们最好还是通过系统缓存来优化磁盘 I/O，换句话说，删除 O_DIRECT 这个选项就是了。</p>
<p> <a target="_blank" rel="noopener" href="https://github.com/feiskyer/linux-perf-examples/blob/master/high-iowait-process/app-fix1.c">app-fix1.c</a> 就是修改后的文件，我也打包成了一个镜像文件，运行下面的命令，你就可以启动它了：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 首先删除原来的应用</span>
$ docker <span class="token function">rm</span> -f app
<span class="token comment"># 运行新的应用</span>
$ docker run --privileged --name<span class="token operator">=</span>app -itd feisky/app:iowait-fix1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>最后，再用 top 检查一下：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">top</span>
<span class="token function">top</span> - <span class="token number">14</span>:59:32 up <span class="token number">19</span> min,  <span class="token number">1</span> user,  load average: <span class="token number">0.15</span>, <span class="token number">0.07</span>, <span class="token number">0.05</span>
Tasks: <span class="token number">137</span> total,   <span class="token number">1</span> running,  <span class="token number">72</span> sleeping,   <span class="token number">0</span> stopped,  <span class="token number">12</span> zombie
%Cpu0  <span class="token builtin class-name">:</span>  <span class="token number">0.0</span> us,  <span class="token number">1.7</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">98.0</span> id,  <span class="token number">0.3</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> st
%Cpu1  <span class="token builtin class-name">:</span>  <span class="token number">0.0</span> us,  <span class="token number">1.3</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">98.7</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> st
<span class="token punctuation">..</span>.

 PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
<span class="token number">3084</span> root      <span class="token number">20</span>   <span class="token number">0</span>       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> Z   <span class="token number">1.3</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.04 app
<span class="token number">3085</span> root      <span class="token number">20</span>   <span class="token number">0</span>       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> Z   <span class="token number">1.3</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.04 app
    <span class="token number">1</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">159848</span>   <span class="token number">9120</span>   <span class="token number">6724</span> S   <span class="token number">0.0</span>  <span class="token number">0.1</span>   <span class="token number">0</span>:09.03 systemd
    <span class="token number">2</span> root      <span class="token number">20</span>   <span class="token number">0</span>       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> S   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.00 kthreadd
    <span class="token number">3</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 你会发现， iowait 已经非常低了，只有 0.3%，说明刚才的改动已经成功修复了 iowait 高的问题。</p>
</li>
</ol>
<h4 id="8-2-僵尸进程"><a href="#8-2-僵尸进程" class="headerlink" title="8.2 僵尸进程"></a>8.2 僵尸进程</h4><p>既然僵尸进程是因为父进程没有回收子进程的资源而出现的，那么，要解决掉它们，就要找到它们的根儿，也就是找出父进程，然后在父进程里解决。</p>
<ol>
<li><p>父进程的找法我们前面讲过，最简单的就是运行 pstree 命令：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -a 表示输出命令行选项</span>
<span class="token comment"># p 表 PID</span>
<span class="token comment"># s 表示指定进程的父进程</span>
$ pstree -aps <span class="token number">3084</span>
systemd,1
└─dockerd,15006 -H fd://
    └─docker-containe,15024 --config /var/run/docker/containerd/containerd.toml
        └─docker-containe,3991 -namespace moby -workdir<span class="token punctuation">..</span>.
            └─app,4009
                └─<span class="token punctuation">(</span>app,3084<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 运行完，你会发现 3084 号进程的父进程是 4009，也就是 app 应用。</p>
<p> 所以，我们接着查看 app 应用程序的代码，看看子进程结束的处理是否正确，比如有没有调用 wait() 或 waitpid() ，抑或是，有没有注册 SIGCHLD 信号的处理函数。</p>
</li>
<li><p>现在我们查看修复 iowait 后的源码文件 <a target="_blank" rel="noopener" href="https://github.com/feiskyer/linux-perf-examples/blob/master/high-iowait-process/app-fix1.c">app-fix1.c</a> ，找到子进程的创建和清理的地方：</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">sub_process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>status<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 循环语句本来就容易出错，你能找到这里的问题吗？这段代码虽然看起来调用了 wait() 函数等待子进程结束，但却错误地把 wait() 放到了 for 死循环的外面，也就是说，wait() 函数实际上并没被调用到，我们把它挪到 for 循环的里面就可以了。</p>
</li>
<li><p>修改后的文件我放到了 <a target="_blank" rel="noopener" href="https://github.com/feiskyer/linux-perf-examples/blob/master/high-iowait-process/app-fix2.c">app-fix2.c</a> 中，也打包成了一个 Docker 镜像，运行下面的命令，你就可以启动它：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 先停止产生僵尸进程的 app</span>
$ docker <span class="token function">rm</span> -f app
<span class="token comment"># 然后启动新的 app</span>
$ docker run --privileged --name<span class="token operator">=</span>app -itd feisky/app:iowait-fix2
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>启动后，再用 top 最后来检查一遍：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">top</span>
<span class="token function">top</span> - <span class="token number">15</span>:00:44 up <span class="token number">20</span> min,  <span class="token number">1</span> user,  load average: <span class="token number">0.05</span>, <span class="token number">0.05</span>, <span class="token number">0.04</span>
Tasks: <span class="token number">125</span> total,   <span class="token number">1</span> running,  <span class="token number">72</span> sleeping,   <span class="token number">0</span> stopped,   <span class="token number">0</span> zombie
%Cpu0  <span class="token builtin class-name">:</span>  <span class="token number">0.0</span> us,  <span class="token number">1.7</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">98.3</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> st
%Cpu1  <span class="token builtin class-name">:</span>  <span class="token number">0.0</span> us,  <span class="token number">1.3</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">98.7</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> st
<span class="token punctuation">..</span>.

PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
<span class="token number">3198</span> root      <span class="token number">20</span>   <span class="token number">0</span>    <span class="token number">4376</span>    <span class="token number">840</span>    <span class="token number">780</span> S   <span class="token number">0.3</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.01 app
    <span class="token number">2</span> root      <span class="token number">20</span>   <span class="token number">0</span>       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> S   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.00 kthreadd
    <span class="token number">3</span> root      <span class="token number">20</span>   <span class="token number">0</span>       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> I   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.41 kworker/0:0
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 好了，僵尸进程（Z 状态）没有了， iowait 也是 0，问题终于全部解决了。</p>
</li>
</ol>
<h4 id="8-3-小结"><a href="#8-3-小结" class="headerlink" title="8.3 小结"></a>8.3 小结</h4><p>虽然这个案例是磁盘 I/O 导致了 iowait 升高，不过， <strong>iowait 高不一定代表 I/O 有性能瓶颈。当系统中只有 I/O 类型的进程在运行时，iowait 也会很高，但实际上，磁盘的读写远没有达到性能瓶颈的程度。</strong></p>
<p>因此，碰到 iowait 升高时，需要先用 dstat、pidstat 等工具，确认是不是磁盘 I/O 的问题，然后再找是哪些进程导致了 I/O。</p>
<p>等待 I/O 的进程一般是不可中断状态，所以用 ps 命令找到的 D 状态（即不可中断状态）的进程，多为可疑进程。但这个案例中，在 I/O 操作后，进程又变成了僵尸进程，所以不能用 strace 直接分析这个进程的系统调用。</p>
<p>这种情况下，我们用了 perf 工具，来分析系统的 CPU 时钟事件，最终发现是直接 I/O 导致的问题。这时，再检查源码中对应位置的问题，就很轻松了。</p>
<p>而僵尸进程的问题相对容易排查，使用 pstree 找出父进程后，去查看父进程的代码，检查 wait() / waitpid() 的调用，或是 SIGCHLD 信号处理函数的注册就行了。</p>
<h3 id="09-基础篇：怎么理解Linux软中断？"><a href="#09-基础篇：怎么理解Linux软中断？" class="headerlink" title="09 | 基础篇：怎么理解Linux软中断？"></a>09 | 基础篇：怎么理解Linux软中断？</h3><h4 id="9-1-从“取外卖”看中断"><a href="#9-1-从“取外卖”看中断" class="headerlink" title="9.1 从“取外卖”看中断"></a>9.1 从“取外卖”看中断</h4><p>中断是系统用来响应硬件设备请求的一种机制，它会打断进程的正常调度和执行，然后调用内核中的中断处理程序来响应设备的请求。</p>
<p>为什么要有中断呢？</p>
<p>比如说你订了一份外卖，但是不确定外卖什么时候送到，也没有别的方法了解外卖的进度，但是，配送员送外卖是不等人的，到了你这儿没人取的话，就直接走人了。所以你只能苦苦等着，时不时去门口看看外卖送到没，而不能干其他事情。</p>
<p>不过呢，如果在订外卖的时候，你就跟配送员约定好，让他送到后给你打个电话，那你就不用苦苦等待了，就可以去忙别的事情，直到电话一响，接电话、取外卖就可以了。</p>
<p>这里的“打电话”，其实就是一个中断。没接到电话的时候，你可以做其他的事情；只有接到了电话（也就是发生中断），你才要进行另一个动作：取外卖。</p>
<p>可以发现，<strong>中断其实是一种异步的事件处理机制，可以提高系统的并发处理能力。</strong></p>
<p>由于中断处理程序会打断其他进程的运行，所以，<strong>为了减少对正常进程运行调度的影响，中断处理程序就需要尽可能快地运行</strong>。如果中断本身要做的事情不多，那么处理起来也不会有太大问题；但如果中断要处理的事情很多，中断服务程序就有可能要运行很长时间。</p>
<p>特别是，中断处理程序在响应中断时，还会临时关闭中断。这就会导致上一次中断处理完成之前，其他中断都不能响应，也就是说中断有可能会丢失。</p>
<h4 id="9-2-软中断"><a href="#9-2-软中断" class="headerlink" title="9.2 软中断"></a>9.2 软中断</h4><p>为了解决中断处理程序执行过长和中断丢失的问题，Linux 将中断处理过程分成了两个阶段，也就是<strong>上半部和下半部</strong>：</p>
<ul>
<li>上半部用来快速处理中断，它在中断禁止模式下运行，主要处理跟硬件紧密相关的或时间敏感的工作。</li>
<li>下半部用来延迟处理上半部未完成的工作，通常以内核线程的方式运行。</li>
</ul>
<p>举个最常见的网卡接收数据包的例子。</p>
<p>网卡接收到数据包后，会通过<strong>硬件中断</strong>的方式，通知内核有新的数据到了。这时，内核就应该调用中断处理程序来响应它。</p>
<p>对上半部来说，既然是快速处理，其实就是要把网卡的数据读到内存中，然后更新一下硬件寄存器的状态（表示数据已经读好了），最后再发送一个<strong>软中断</strong>信号，通知下半部做进一步的处理。</p>
<p>而下半部被软中断信号唤醒后，需要从内存中找到网络数据，再按照网络协议栈，对数据进行逐层解析和处理，直到把它送给应用程序。</p>
<p>所以，这两个阶段你也可以这样理解：</p>
<ul>
<li>上半部直接处理硬件请求，也就是我们常说的硬中断，特点是快速执行；</li>
<li>而下半部则是由内核触发，也就是我们常说的软中断，特点是延迟执行。</li>
</ul>
<p>实际上，上半部会打断 CPU 正在执行的任务，然后立即执行中断处理程序。而下半部以内核线程的方式执行，并且每个 CPU 都对应一个软中断内核线程，名字为 “ksoftirqd/CPU 编号”，比如说， 0 号 CPU 对应的软中断内核线程的名字就是 ksoftirqd/0。</p>
<p>不过要注意的是，软中断不只包括了刚刚所讲的硬件设备中断处理程序的下半部，一些内核自定义的事件也属于软中断，比如内核调度和 RCU 锁（Read-Copy Update 的缩写，RCU 是 Linux 内核中最常用的锁之一）等。</p>
<h4 id="9-3-查看软中断和内核线程"><a href="#9-3-查看软中断和内核线程" class="headerlink" title="9.3 查看软中断和内核线程"></a>9.3 查看软中断和内核线程</h4><p>proc 文件系统可以用来查看内核的数据结构，或者用来动态修改内核的配置。其中：</p>
<ul>
<li>/proc/softirqs 提供了软中断的运行情况；</li>
<li>/proc/interrupts 提供了硬中断的运行情况。</li>
</ul>
<p>运行下面的命令，查看 /proc/softirqs 文件的内容，你就可以看到各种类型软中断在不同 CPU 上的累积运行次数：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> /proc/softirqs
                    CPU0       CPU1
          HI:          <span class="token number">0</span>          <span class="token number">0</span>
       TIMER:     <span class="token number">811613</span>    <span class="token number">1972736</span>
      NET_TX:         <span class="token number">49</span>          <span class="token number">7</span>
      NET_RX:    <span class="token number">1136736</span>    <span class="token number">1506885</span>
       BLOCK:          <span class="token number">0</span>          <span class="token number">0</span>
    IRQ_POLL:          <span class="token number">0</span>          <span class="token number">0</span>
     TASKLET:     <span class="token number">304787</span>       <span class="token number">3691</span>
       SCHED:     <span class="token number">689718</span>    <span class="token number">1897539</span>
     HRTIMER:          <span class="token number">0</span>          <span class="token number">0</span>
         RCU:    <span class="token number">1330771</span>    <span class="token number">1354737</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在查看 /proc/softirqs 文件内容时，你要特别注意以下这两点。</p>
<ul>
<li>第一，要注意软中断的类型，也就是这个界面中第一列的内容。从第一列你可以看到，软中断包括了 10 个类别，分别对应不同的工作类型。比如 NET_RX 表示网络接收中断，而 NET_TX 表示网络发送中断。</li>
<li>第二，要注意同一种软中断在不同 CPU 上的分布情况，也就是同一行的内容。正常情况下，同一种中断在不同 CPU 上的累积次数应该差不多。比如这个界面中，NET_RX 在 CPU0 和 CPU1 上的中断次数基本是同一个数量级，相差不大。</li>
</ul>
<p>不过你可能发现，TASKLET 在不同 CPU 上的分布并不均匀。TASKLET 是最常用的软中断实现机制，每个 TASKLET 只运行一次就会结束 ，并且只在调用它的函数所在的 CPU 上运行。</p>
<p>因此，使用 TASKLET 特别简便，当然也会存在一些问题，比如说由于只在一个 CPU 上运行导致的调度不均衡，再比如因为不能在多个 CPU 上并行运行带来了性能限制。</p>
<p>另外，刚刚提到过，软中断实际上是以内核线程的方式运行的，每个 CPU 都对应一个软中断内核线程，这个软中断内核线程就叫做 ksoftirqd/CPU 编号。那要怎么查看这些线程的运行状况呢？</p>
<p>其实用 ps 命令就可以做到，比如执行下面的指令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">grep</span> softirq
root         <span class="token number">7</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        S    Oct10   <span class="token number">0</span>:01 <span class="token punctuation">[</span>ksoftirqd/0<span class="token punctuation">]</span>
root        <span class="token number">16</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span>      <span class="token number">0</span>     <span class="token number">0</span> ?        S    Oct10   <span class="token number">0</span>:01 <span class="token punctuation">[</span>ksoftirqd/1<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>注意，这些线程的名字外面都有中括号，这说明 ps 无法获取它们的命令行参数（cmline）。一般来说，ps 的输出中，名字括在中括号里的，一般都是内核线程。</p>
<h3 id="10-案例篇：系统的软中断CPU使用率升高，我该怎么办？"><a href="#10-案例篇：系统的软中断CPU使用率升高，我该怎么办？" class="headerlink" title="10 | 案例篇：系统的软中断CPU使用率升高，我该怎么办？"></a>10 | 案例篇：系统的软中断CPU使用率升高，我该怎么办？</h3><h4 id="10-1-案例"><a href="#10-1-案例" class="headerlink" title="10.1 案例"></a>10.1 案例</h4><blockquote>
<p>机器配置： 2 CPU, 8 GB 内存。</p>
<p>安装软件：<code>apt-get install docker.io sysstat hping3 tcpdump</code>。</p>
<ul>
<li>sar 是一个系统活动报告工具，既可以实时查看系统的当前活动，又可以配置保存和报告历史统计数据。</li>
<li>hping3 是一个可以构造 TCP/IP 协议数据包的工具，可以对系统进行安全审计、防火墙测试等。</li>
<li>tcpdump 是一个常用的网络抓包工具，常用来分析各种网络问题。</li>
</ul>
</blockquote>
<ol>
<li><p>在第一个终端，执行下面的命令运行案例，也就是一个最基本的 Nginx 应用：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 运行 Nginx 服务并对外开放 80 端口</span>
$ docker run -itd --name<span class="token operator">=</span>nginx -p <span class="token number">80</span>:80 nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li><p>在第二个终端，使用 curl 访问 Nginx 监听的端口，确认 Nginx 正常启动。假设 192.168.0.30 是 Nginx 所在虚拟机的 IP 地址，运行 curl 命令后你应该会看到下面这个输出界面：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">curl</span> http://192.168.0.30/
<span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>html<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>head<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>title<span class="token operator">&gt;</span>Welcome to nginx<span class="token operator">!</span><span class="token operator">&lt;</span>/title<span class="token operator">&gt;</span>
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>还是在第二个终端，我们运行 hping3 命令，来模拟 Nginx 的客户端请求：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -S 参数表示设置 TCP 协议的 SYN（同步序列号），-p 表示目的端口为 80</span>
<span class="token comment"># -i u100 表示每隔 100 微秒发送一个网络帧</span>
<span class="token comment"># 注：如果你在实践过程中现象不明显，可以尝试把 100 调小，比如调成 10 甚至 1</span>
$ hping3 -S -p <span class="token number">80</span> -i u100 <span class="token number">192.168</span>.0.30<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p> 现在我们再回到第一个终端，你应该发现了异常。是不是感觉系统响应明显变慢了，即便只是在终端中敲几个回车，都得很久才能得到响应？这个时候应该怎么办呢？</p>
</li>
<li><p>先看看系统的整体资源使用情况应该是个不错的注意，比如执行下 top 看看是不是出现了 CPU 的瓶颈。我们在第一个终端运行 top 命令，看一下系统整体的资源使用情况。</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># top 运行后按数字 1 切换到显示所有 CPU</span>
$ <span class="token function">top</span>
<span class="token function">top</span> - <span class="token number">10</span>:50:58 up <span class="token number">1</span> days, <span class="token number">22</span>:10,  <span class="token number">1</span> user,  load average: <span class="token number">0.00</span>, <span class="token number">0.00</span>, <span class="token number">0.00</span>
Tasks: <span class="token number">122</span> total,   <span class="token number">1</span> running,  <span class="token number">71</span> sleeping,   <span class="token number">0</span> stopped,   <span class="token number">0</span> zombie
%Cpu0  <span class="token builtin class-name">:</span>  <span class="token number">0.0</span> us,  <span class="token number">0.0</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">96.7</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">3.3</span> si,  <span class="token number">0.0</span> st
%Cpu1  <span class="token builtin class-name">:</span>  <span class="token number">0.0</span> us,  <span class="token number">0.0</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">95.6</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">4.4</span> si,  <span class="token number">0.0</span> st
<span class="token punctuation">..</span>.

  PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
    <span class="token number">7</span> root      <span class="token number">20</span>   <span class="token number">0</span>       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> S   <span class="token number">0.3</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:01.64 ksoftirqd/0
   <span class="token number">16</span> root      <span class="token number">20</span>   <span class="token number">0</span>       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> S   <span class="token number">0.3</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:01.97 ksoftirqd/1
 <span class="token number">2663</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">923480</span>  <span class="token number">28292</span>  <span class="token number">13996</span> S   <span class="token number">0.3</span>  <span class="token number">0.3</span>   <span class="token number">4</span>:58.66 docker-containe
 <span class="token number">3699</span> root      <span class="token number">20</span>   <span class="token number">0</span>       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> I   <span class="token number">0.3</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.13 kworker/u4:0
 <span class="token number">3708</span> root      <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">44572</span>   <span class="token number">4176</span>   <span class="token number">3512</span> R   <span class="token number">0.3</span>  <span class="token number">0.1</span>   <span class="token number">0</span>:00.07 <span class="token function">top</span>
    <span class="token number">1</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">225384</span>   <span class="token number">9136</span>   <span class="token number">6724</span> S   <span class="token number">0.0</span>  <span class="token number">0.1</span>   <span class="token number">0</span>:23.25 systemd
    <span class="token number">2</span> root      <span class="token number">20</span>   <span class="token number">0</span>       <span class="token number">0</span>      <span class="token number">0</span>      <span class="token number">0</span> S   <span class="token number">0.0</span>  <span class="token number">0.0</span>   <span class="token number">0</span>:00.03 kthreadd
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 我们从第一行开始，逐个看一下：</p>
<ul>
<li>平均负载全是 0，就绪队列里面只有一个进程（1 running）。</li>
<li>每个 CPU 的使用率都挺低，最高的 CPU1 的使用率也只有 4.4%，并不算高。</li>
<li><p>再看进程列表，CPU 使用率最高的进程也只有 0.3%，还是不高呀。</p>
<p>仔细看 top 的输出，两个 CPU 的使用率虽然分别只有 3.3% 和 4.4%，但都用在了软中断上；而从进程列表上也可以看到，CPU 使用率最高的也是软中断进程 ksoftirqd。看起来，软中断有点可疑了。</p>
<p>根据上一期的内容，既然软中断可能有问题，那你先要知道，究竟是哪类软中断的问题。停下来想想，上一节我们用了什么方法，来判断软中断类型呢？没错，还是 proc 文件系统。观察 /proc/softirqs 文件的内容，你就能知道各种软中断类型的次数。</p>
<p>不过，这里的各类软中断次数，又是什么时间段里的次数呢？它是系统运行以来的累积中断次数。所以我们直接查看文件内容，得到的只是累积中断次数，对这里的问题并没有直接参考意义。因为，这些中断次数的变化速率才是我们需要关注的。</p>
<p>那什么工具可以观察命令输出的变化情况呢？我想你应该想起来了，在前面案例中用过的 watch 命令，就可以定期运行一个命令来查看输出；如果再加上 -d 参数，还可以高亮出变化的部分，从高亮部分我们就可以直观看出，哪些内容变化得更快。</p>
</li>
</ul>
</li>
<li><p>在第一个终端，我们运行下面的命令：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">watch</span> -d <span class="token function">cat</span> /proc/softirqs
                    CPU0       CPU1
          HI:          <span class="token number">0</span>          <span class="token number">0</span>
       TIMER:    <span class="token number">1083906</span>    <span class="token number">2368646</span>
      NET_TX:         <span class="token number">53</span>          <span class="token number">9</span>
      NET_RX:    <span class="token number">1550643</span>    <span class="token number">1916776</span>
       BLOCK:          <span class="token number">0</span>          <span class="token number">0</span>
    IRQ_POLL:          <span class="token number">0</span>          <span class="token number">0</span>
     TASKLET:     <span class="token number">333637</span>       <span class="token number">3930</span>
       SCHED:     <span class="token number">963675</span>    <span class="token number">2293171</span>
     HRTIMER:          <span class="token number">0</span>          <span class="token number">0</span>
         RCU:    <span class="token number">1542111</span>    <span class="token number">1590625</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 通过 /proc/softirqs 文件内容的变化情况，你可以发现， TIMER（定时中断）、NET_RX（网络接收）、SCHED（内核调度）、RCU（RCU 锁）等这几个软中断都在不停变化。</p>
<p> 其中，NET_RX，也就是网络数据包接收软中断的变化速率最快。而其他几种类型的软中断，是保证 Linux 调度、时钟和临界区保护这些正常工作所必需的，所以它们有一定的变化倒是正常的。</p>
<p> 那么接下来，我们就从网络接收的软中断着手，继续分析。既然是网络接收的软中断，第一步应该就是观察系统的网络接收情况。这里你可能想起了很多网络工具，不过，我推荐今天的主人公工具 sar 。</p>
<p> sar 可以用来查看系统的网络收发情况，还有一个好处是，不仅可以观察网络收发的吞吐量（BPS，每秒收发的字节数），还可以观察网络收发的 PPS，即每秒收发的网络帧数。</p>
</li>
<li><p>在第一个终端中运行 sar 命令，并添加 -n DEV 参数显示网络收发的报告：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -n DEV 表示显示网络收发的报告，间隔 1 秒输出一组数据</span>
$ sar -n DEV <span class="token number">1</span>
<span class="token number">15</span>:03:46        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil
<span class="token number">15</span>:03:47         eth0  <span class="token number">12607.00</span>   <span class="token number">6304.00</span>    <span class="token number">664.86</span>    <span class="token number">358.11</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.01</span>
<span class="token number">15</span>:03:47      docker0   <span class="token number">6302.00</span>  <span class="token number">12604.00</span>    <span class="token number">270.79</span>    <span class="token number">664.66</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>
<span class="token number">15</span>:03:47           lo      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>
<span class="token number">15</span>:03:47  veth9f6bbcd   <span class="token number">6302.00</span>  <span class="token number">12604.00</span>    <span class="token number">356.95</span>    <span class="token number">664.66</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.05</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 对于 sar 的输出界面，我先来简单介绍一下，从左往右依次是：</p>
<ul>
<li>第一列：表示报告的时间。</li>
<li>第二列：IFACE 表示网卡。</li>
<li>第三、四列：rxpck/s 和 txpck/s 分别表示每秒接收、发送的网络帧数，也就是 PPS。</li>
<li><p>第五、六列：rxkB/s 和 txkB/s 分别表示每秒接收、发送的千字节数，也就是 BPS。</p>
<p>后面的其他参数基本接近 0，显然跟今天的问题没有直接关系，你可以先忽略掉。</p>
<p>我们具体来看输出的内容，你可以发现：</p>
</li>
<li><p>对网卡 eth0 来说，每秒接收的网络帧数比较大，达到了 12607，而发送的网络帧数则比较小，只有 6304；每秒接收的千字节数只有 664 KB，而发送的千字节数更小，只有 358 KB。</p>
</li>
<li><p>docker0 和 veth9f6bbcd 的数据跟 eth0 基本一致，只是发送和接收相反，发送的数据较大而接收的数据较小。这是 Linux 内部网桥转发导致的，你暂且不用深究，只要知道这是系统把 eth0 收到的包转发给 Nginx 服务即可。具体工作原理，我会在后面的网络部分详细介绍。</p>
<p>既然怀疑是网络接收中断的问题，我们还是重点来看 eth0 ：接收的 PPS 比较大，达到 12607，而接收的 BPS 却很小，只有 664 KB。直观来看网络帧应该都是比较小的，我们稍微计算一下，664*1024/12607 = 54 字节，说明平均每个网络帧只有 54 字节，这显然是很小的网络帧，也就是我们通常所说的小包问题。</p>
<p>那么，有没有办法知道这是一个什么样的网络帧，以及从哪里发过来的呢？</p>
<p>使用 tcpdump 抓取 eth0 上的包就可以了。我们事先已经知道， Nginx 监听在 80 端口，它所提供的 HTTP 服务是基于 TCP 协议的，所以我们可以指定 TCP 协议和 80 端口精确抓包。</p>
</li>
</ul>
</li>
<li><p>接下来，我们在第一个终端中运行 tcpdump 命令，通过 -i eth0 选项指定网卡 eth0，并通过 tcp port 80 选项指定 TCP 协议的 80 端口：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -i eth0 只抓取 eth0 网卡，-n 不解析协议名和主机名</span>
<span class="token comment"># tcp port 80 表示只抓取 tcp 协议并且端口号为 80 的网络帧</span>
$ tcpdump -i eth0 -n tcp port <span class="token number">80</span>
<span class="token number">15</span>:11:32.678966 IP <span class="token number">192.168</span>.0.2.18238 <span class="token operator">&gt;</span> <span class="token number">192.168</span>.0.30.80: Flags <span class="token punctuation">[</span>S<span class="token punctuation">]</span>, <span class="token function">seq</span> <span class="token number">458303614</span>, win <span class="token number">512</span>, length <span class="token number">0</span>
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 从 tcpdump 的输出中，你可以发现：</p>
<ul>
<li>192.168.0.2.18238 &gt; 192.168.0.30.80 ，表示网络帧从 192.168.0.2 的 18238 端口发送到 192.168.0.30 的 80 端口，也就是从运行 hping3 机器的 18238 端口发送网络帧，目的为 Nginx 所在机器的 80 端口。</li>
<li><p>Flags [S] 则表示这是一个 SYN 包。</p>
<p>再加上前面用 sar 发现的， PPS 超过 12000 的现象，现在我们可以确认，这就是从 192.168.0.2 这个地址发送过来的 SYN FLOOD 攻击。</p>
<p>SYN FLOOD 问题最简单的解决方法，就是从交换机或者硬件防火墙中封掉来源 IP，这样 SYN FLOOD 网络帧就不会发送到服务器中。</p>
</li>
</ul>
</li>
</ol>
<h4 id="10-2-终端卡顿的问题"><a href="#10-2-终端卡顿的问题" class="headerlink" title="10.2 终端卡顿的问题"></a>10.2 终端卡顿的问题</h4><p>这个是由于网络延迟增大（甚至是丢包）导致的。比如你可以再拿另外一台机器（也就是第三台）在 hping3 运行的前后 ping 一下案例机器，ping -c3 <ip></ip></p>
<p>hping3 运行前，你可能看到最长的也不超过 1 ms：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">3 packets transmitted, 3 received, 0% packet loss, time 2028ms
rtt min/avg/max/mdev = 0.815/0.914/0.989/0.081 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>而 hping3 运行时，不仅平均延迟增长到了 245 ms，而且还会有丢包的发生：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">3 packets transmitted, 2 received, 33% packet loss, time 2026ms
rtt min/avg/max/mdev = 240.637/245.758/250.880/5.145 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="11-套路篇：如何迅速分析出系统CPU的瓶颈在哪里？"><a href="#11-套路篇：如何迅速分析出系统CPU的瓶颈在哪里？" class="headerlink" title="11 | 套路篇：如何迅速分析出系统CPU的瓶颈在哪里？"></a>11 | 套路篇：如何迅速分析出系统CPU的瓶颈在哪里？</h3><h4 id="11-1-CPU-性能指标"><a href="#11-1-CPU-性能指标" class="headerlink" title="11.1 CPU 性能指标"></a>11.1 CPU 性能指标</h4><ol>
<li><p>最容易想到的应该是 CPU 使用率。</p>
<p> CPU 使用率描述了非空闲时间占总 CPU 时间的百分比，根据 CPU 上运行任务的不同，又被分为用户 CPU、系统 CPU、等待 I/O CPU、软中断和硬中断等。</p>
<ul>
<li>用户 CPU 使用率，包括用户态 CPU 使用率（user）和低优先级用户态 CPU 使用率（nice），表示 CPU 在用户态运行的时间百分比。用户 CPU 使用率高，通常说明有应用程序比较繁忙。</li>
<li>系统 CPU 使用率，表示 CPU 在内核态运行的时间百分比（不包括中断）。系统 CPU 使用率高，说明内核比较繁忙。</li>
<li>等待 I/O 的 CPU 使用率，通常也称为 iowait，表示等待 I/O 的时间百分比。iowait 高，通常说明系统与硬件设备的 I/O 交互时间比较长。</li>
<li>软中断和硬中断的 CPU 使用率，分别表示内核调用软中断处理程序、硬中断处理程序的时间百分比。它们的使用率高，通常说明系统发生了大量的中断。</li>
<li>除了上面这些，还有在虚拟化环境中会用到的窃取 CPU 使用率（steal）和客户 CPU 使用率（guest），分别表示被其他虚拟机占用的 CPU 时间百分比，和运行客户虚拟机的 CPU 时间百分比。</li>
</ul>
</li>
<li><p>第二个比较容易想到的，应该是平均负载（Load Average）。</p>
<p> 平均负载（Load Average），也就是系统的平均活跃进程数。它反应了系统的整体负载情况，主要包括三个数值，分别指过去 1 分钟、过去 5 分钟和过去 15 分钟的平均负载。</p>
<p> 理想情况下，平均负载等于逻辑 CPU 个数，这表示每个 CPU 都恰好被充分利用。如果平均负载大于逻辑 CPU 个数，就表示负载比较重了。</p>
</li>
<li><p>第三个，也是在专栏学习前你估计不太会注意到的，进程上下文切换。</p>
<p> 包括：</p>
<ul>
<li>无法获取资源而导致的自愿上下文切换；</li>
<li><p>被系统强制调度导致的非自愿上下文切换。</p>
<p>上下文切换，本身是保证 Linux 正常运行的一项核心功能。但过多的上下文切换，会将原本运行进程的 CPU 时间，消耗在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，缩短进程真正运行的时间，成为性能瓶颈。</p>
</li>
</ul>
</li>
<li><p>还有一个指标，CPU 缓存的命中率。</p>
<p> 由于 CPU 发展的速度远快于内存的发展，CPU 的处理速度就比内存的访问速度快得多。这样，CPU 在访问内存的时候，免不了要等待内存的响应。为了协调这两者巨大的性能差距，CPU 缓存（通常是多级缓存）就出现了。</p>
<p> <img src="/images/《Linux性能优化实战》学习笔记/CPU缓存架构.png" alt="CPU缓存架构"></p>
<p> 就像上面这张图显示的，CPU 缓存的速度介于 CPU 和内存之间，缓存的是热点的内存数据。根据不断增长的热点数据，这些缓存按照大小不同分为 L1、L2、L3 等三级缓存，其中 L1 和 L2 常用在单核中， L3 则用在多核中。</p>
<p> 从 L1 到 L3，三级缓存的大小依次增大，相应的，性能依次降低（当然比内存还是好得多）。而它们的命中率，衡量的是 CPU 缓存的复用情况，命中率越高，则表示性能越好。</p>
</li>
</ol>
<p><img src="/images/《Linux性能优化实战》学习笔记/CPU性能指标筛选清单.png" alt="CPU性能指标筛选清单"></p>
<h4 id="11-2-性能工具"><a href="#11-2-性能工具" class="headerlink" title="11.2 性能工具"></a>11.2 性能工具</h4><ol>
<li><p>平均负载的案例。</p>
<p> 我们先用 uptime， 查看了系统的平均负载；而在平均负载升高后，又用 mpstat 和 pidstat ，分别观察了每个 CPU 和每个进程 CPU 的使用情况，进而找出了导致平均负载升高的进程，也就是我们的压测工具 stress。</p>
</li>
<li><p>上下文切换的案例。</p>
<p> 我们先用 vmstat ，查看了系统的上下文切换次数和中断次数；然后通过 pidstat ，观察了进程的自愿上下文切换和非自愿上下文切换情况；最后通过 pidstat ，观察了线程的上下文切换情况，找出了上下文切换次数增多的根源，也就是我们的基准测试工具 sysbench。</p>
</li>
<li><p>进程 CPU 使用率升高的案例。</p>
<p> 我们先用 top ，查看了系统和进程的 CPU 使用情况，发现 CPU 使用率升高的进程是 php-fpm；再用 perf top ，观察 php-fpm 的调用链，最终找出 CPU 升高的根源，也就是库函数 sqrt() 。</p>
</li>
<li><p>系统的 CPU 使用率升高的案例。</p>
<p> 我们先用 top 观察到了系统 CPU 升高，但通过 top 和 pidstat ，却找不出高 CPU 使用率的进程。于是，我们重新审视 top 的输出，又从 CPU 使用率不高但处于 Running 状态的进程入手，找出了可疑之处，最终通过 perf record 和 perf report ，发现原来是短时进程在捣鬼。</p>
<p> 另外，对于短时进程，我还介绍了一个专门的工具 execsnoop，它可以实时监控进程调用的外部命令。</p>
</li>
<li><p>不可中断进程和僵尸进程的案例。</p>
<p> 我们先用 top 观察到了 iowait 升高的问题，并发现了大量的不可中断进程和僵尸进程；接着我们用 dstat 发现是这是由磁盘读导致的，于是又通过 pidstat 找出了相关的进程。但我们用 strace 查看进程系统调用却失败了，最终还是用 perf 分析进程调用链，才发现根源在于磁盘直接 I/O 。</p>
</li>
<li><p>软中断的案例。</p>
<p> 我们通过 top 观察到，系统的软中断 CPU 使用率升高；接着查看 /proc/softirqs， 找到了几种变化速率较快的软中断；然后通过 sar 命令，发现是网络小包的问题，最后再用 tcpdump ，找出网络帧的类型和来源，确定是一个 SYN FLOOD 攻击导致的。</p>
</li>
</ol>
<h4 id="11-3-活学活用，把性能指标和性能工具联系起来"><a href="#11-3-活学活用，把性能指标和性能工具联系起来" class="headerlink" title="11.3 活学活用，把性能指标和性能工具联系起来"></a>11.3 活学活用，把性能指标和性能工具联系起来</h4><ol>
<li><p>第一个维度，从 CPU 的性能指标出发。也就是说，当你要查看某个性能指标时，要清楚知道哪些工具可以做到。</p>
<p> 根据不同的性能指标，对提供指标的性能工具进行分类和理解。这样，在实际排查性能问题时，你就可以清楚知道，什么工具可以提供你想要的指标，而不是毫无根据地挨个尝试，撞运气。</p>
<p> 比如用 top 发现了软中断 CPU 使用率高后，下一步自然就想知道具体的软中断类型。那在哪里可以观察各类软中断的运行情况呢？当然是 proc 文件系统中的 /proc/softirqs 这个文件。</p>
<p> 紧接着，比如说，我们找到的软中断类型是网络接收，那就要继续往网络接收方向思考。系统的网络接收情况是什么样的？什么工具可以查到网络接收情况呢？在我们案例中，用的正是 dstat。</p>
<p> <img src="/images/《Linux性能优化实战》学习笔记/根据指标找工具（CPU性能）.png" alt="根据指标找工具（CPU性能）"></p>
</li>
<li><p>第二个维度，从工具出发。也就是当你已经安装了某个工具后，要知道这个工具能提供哪些指标。</p>
<p> <img src="/images/《Linux性能优化实战》学习笔记/根据工具查指标（CPU性能）.png" alt="根据工具查指标（CPU性能）"></p>
</li>
</ol>
<h4 id="11-4-如何迅速分析-CPU-的性能瓶颈"><a href="#11-4-如何迅速分析-CPU-的性能瓶颈" class="headerlink" title="11.4 如何迅速分析 CPU 的性能瓶颈"></a>11.4 如何迅速分析 CPU 的性能瓶颈</h4><p>虽然 CPU 的性能指标比较多，但要知道，既然都是描述系统的 CPU 性能，它们就不会是完全孤立的，很多指标间都有一定的关联。<strong>想弄清楚性能指标的关联性，就要通晓每种性能指标的工作原理</strong>。这也是为什么我在介绍每个性能指标时，都要穿插讲解相关的系统原理，希望你能记住这一点。</p>
<p>举个例子，用户 CPU 使用率高，我们应该去排查进程的用户态而不是内核态。因为用户 CPU 使用率反映的就是用户态的 CPU 使用情况，而内核态的 CPU 使用情况只会反映到系统 CPU 使用率上。</p>
<p>所以，<strong>为了缩小排查范围，我通常会先运行几个支持指标较多的工具，如 top、vmstat 和 pidstat</strong>。为什么是这三个工具呢？仔细看看下面这张图，你就清楚了。</p>
<p><img src="/images/《Linux性能优化实战》学习笔记/使用top、vmstat和pidstat缩小排查范围.png" alt="使用top、vmstat和pidstat缩小排查范围"></p>
<p>这张图里，我列出了 top、vmstat 和 pidstat 分别提供的重要的 CPU 指标，并用虚线表示关联关系，对应出了性能分析下一步的方向。</p>
<p>通过这张图你可以发现，这三个命令，几乎包含了所有重要的 CPU 性能指标，比如：</p>
<ul>
<li>从 top 的输出可以得到各种 CPU 使用率以及僵尸进程和平均负载等信息。</li>
<li>从 vmstat 的输出可以得到上下文切换次数、中断次数、运行状态和不可中断状态的进程数。</li>
<li>从 pidstat 的输出可以得到进程的用户 CPU 使用率、系统 CPU 使用率、以及自愿上下文切换和非自愿上下文切换情况。</li>
</ul>
<p>另外，这三个工具输出的很多指标是相互关联的，所以，我也用虚线表示了它们的关联关系，举几个例子你可能会更容易理解。</p>
<ol>
<li><p>第一个例子，pidstat 输出的进程用户 CPU 使用率升高，会导致 top 输出的用户 CPU 使用率升高。所以，当发现 top 输出的用户 CPU 使用率有问题时，可以跟 pidstat 的输出做对比，观察是否是某个进程导致的问题。</p>
<p> 而找出导致性能问题的进程后，就要用进程分析工具来分析进程的行为，比如使用 strace 分析系统调用情况，以及使用 perf 分析调用链中各级函数的执行情况。</p>
</li>
<li><p>第二个例子，top 输出的平均负载升高，可以跟 vmstat 输出的运行状态和不可中断状态的进程数做对比，观察是哪种进程导致的负载升高。</p>
<ul>
<li>如果是不可中断进程数增多了，那么就需要做 I/O 的分析，也就是用 dstat 或 sar 等工具，进一步分析 I/O 的情况。</li>
<li>如果是运行状态进程数增多了，那就需要回到 top 和 pidstat，找出这些处于运行状态的到底是什么进程，然后再用进程分析工具，做进一步分析。</li>
</ul>
</li>
<li><p>最后一个例子，当发现 top 输出的软中断 CPU 使用率升高时，可以查看 /proc/softirqs 文件中各种类型软中断的变化情况，确定到底是哪种软中断出的问题。比如，发现是网络接收中断导致的问题，那就可以继续用网络分析工具 sar 和 tcpdump 来分析。</p>
</li>
</ol>
<h3 id="12-套路篇：CPU-性能优化的几个思路"><a href="#12-套路篇：CPU-性能优化的几个思路" class="headerlink" title="12 | 套路篇：CPU 性能优化的几个思路"></a>12 | 套路篇：CPU 性能优化的几个思路</h3><h4 id="12-1-性能优化方法论"><a href="#12-1-性能优化方法论" class="headerlink" title="12.1 性能优化方法论"></a>12.1 性能优化方法论</h4><p>通过各种性能分析方法，终于找到引发性能问题的瓶颈后，是不是立刻就要开始优化了呢？别急，动手之前，你可以先看看下面这三个问题。</p>
<ul>
<li>首先，既然要做性能优化，那要怎么判断它是不是有效呢？特别是优化后，到底能提升多少性能呢？</li>
<li>第二，性能问题通常不是独立的，如果有多个性能问题同时发生，你应该先优化哪一个呢？</li>
<li>第三，提升性能的方法并不是唯一的，当有多种方法可以选择时，你会选用哪一种呢？是不是总选那个最大程度提升性能的方法就行了呢？</li>
</ul>
<p>如果你可以轻松回答这三个问题，那么二话不说就可以开始优化。</p>
<p>比如，在前面的不可中断进程案例中，通过性能分析，我们发现是因为一个进程的直接 I/O ，导致了 iowait 高达 90%。那是不是用“直接 I/O 换成缓存 I/O”的方法，就可以立即优化了呢？</p>
<p>按照上面讲的，你可以先自己思考下那三点。如果不能确定，我们一起来看看。</p>
<ul>
<li>第一个问题，直接 I/O 换成缓存 I/O，可以把 iowait 从 90% 降到接近 0，性能提升很明显。</li>
<li>第二个问题，我们没有发现其他性能问题，直接 I/O 是唯一的性能瓶颈，所以不用挑选优化对象。</li>
<li>第三个问题，缓存 I/O 是我们目前用到的最简单的优化方法，而且这样优化并不会影响应用的功能。</li>
</ul>
<p>好的，这三个问题很容易就能回答，所以立即优化没有任何问题。</p>
<h4 id="12-2-怎么评估性能优化的效果？"><a href="#12-2-怎么评估性能优化的效果？" class="headerlink" title="12.2 怎么评估性能优化的效果？"></a>12.2 怎么评估性能优化的效果？</h4><p>我们解决性能问题的目的，自然是想得到一个性能提升的效果。为了评估这个效果，我们需要对系统的性能指标进行量化，并且要分别测试出优化前、后的性能指标，用前后指标的变化来对比呈现效果。我把这个方法叫做性能评估“三步走”。</p>
<ol>
<li><p>确定性能的量化指标。</p>
<p> 我的建议是不要局限在单一维度的指标上，你至少要从应用程序和系统资源这两个维度，分别选择不同的指标。比如，以 Web 应用为例：</p>
<ul>
<li>应用程序的维度，我们可以用吞吐量和请求延迟来评估应用程序的性能。</li>
<li><p>系统资源的维度，我们可以用 CPU 使用率来评估系统的 CPU 使用情况。</p>
<p>之所以从这两个不同维度选择指标，主要是因为应用程序和系统资源这两者间相辅相成的关系。</p>
</li>
<li><p>好的应用程序是性能优化的最终目的和结果，系统优化总是为应用程序服务的。所以，必须要使用应用程序的指标，来评估性能优化的整体效果。</p>
</li>
<li>系统资源的使用情况是影响应用程序性能的根源。所以，需要用系统资源的指标，来观察和分析瓶颈的来源。</li>
</ul>
</li>
<li><p>测试优化前的性能指标。</p>
</li>
<li><p>测试优化后的性能指标。</p>
</li>
</ol>
<p>以刚刚的 Web 应用为例，对应上面提到的几个指标，我们可以选择 ab 等工具，测试 Web 应用的并发请求数和响应延迟。而测试的同时，还可以用 vmstat、pidstat 等性能工具，观察系统和进程的 CPU 使用率。这样，我们就同时获得了应用程序和系统资源这两个维度的指标数值。</p>
<p>不过，在进行性能测试时，有两个特别重要的地方你需要注意下。</p>
<ol>
<li><p>第一，要避免性能测试工具干扰应用程序的性能。通常，对 Web 应用来说，性能测试工具跟目标应用程序要在不同的机器上运行。</p>
<p> 比如，在之前的 Nginx 案例中，我每次都会强调要用两台虚拟机，其中一台运行 Nginx 服务，而另一台运行模拟客户端的工具，就是为了避免这个影响。</p>
</li>
<li><p>第二，避免外部环境的变化影响性能指标的评估。这要求优化前、后的应用程序，都运行在相同配置的机器上，并且它们的外部依赖也要完全一致。</p>
<p> 比如还是拿 Nginx 来说，就可以运行在同一台机器上，并用相同参数的客户端工具来进行性能测试。</p>
</li>
</ol>
<h4 id="12-3-多个性能问题同时存在，要怎么选择？"><a href="#12-3-多个性能问题同时存在，要怎么选择？" class="headerlink" title="12.3 多个性能问题同时存在，要怎么选择？"></a>12.3 多个性能问题同时存在，要怎么选择？</h4><p>系统性能总是牵一发而动全身，所以性能问题通常也不是独立存在的。那当多个性能问题同时发生的时候，应该先去优化哪一个呢？</p>
<p>在性能测试的领域，流传很广的一个说法是“二八原则”，也就是说 80% 的问题都是由 20% 的代码导致的。只要找出这 20% 的位置，你就可以优化 80% 的性能。所以，我想表达的是，<strong>并不是所有的性能问题都值得优化</strong>。</p>
<p>我的建议是，动手优化之前先动脑，先把所有这些性能问题给分析一遍，找出最重要的、可以最大程度提升性能的问题，从它开始优化。这样的好处是，不仅性能提升的收益最大，而且很可能其他问题都不用优化，就已经满足了性能要求。</p>
<p>那关键就在于，怎么判断出哪个性能问题最重要。这其实还是我们性能分析要解决的核心问题，只不过这里要分析的对象，从原来的一个问题，变成了多个问题，思路其实还是一样的。</p>
<p>所以，你依然可以用我前面讲过的方法挨个分析，分别找出它们的瓶颈。分析完所有问题后，再按照因果等关系，排除掉有因果关联的性能问题。最后，再对剩下的性能问题进行优化。</p>
<p>如果剩下的问题还是好几个，你就得分别进行性能测试了。比较不同的优化效果后，选择能明显提升性能的那个问题进行修复。这个过程通常会花费较多的时间，这里，我推荐两个可以简化这个过程的方法。</p>
<ol>
<li>第一，如果发现是系统资源达到了瓶颈，比如 CPU 使用率达到了 100%，那么首先优化的一定是系统资源使用问题。完成系统资源瓶颈的优化后，我们才要考虑其他问题。</li>
<li>第二，针对不同类型的指标，首先去优化那些由瓶颈导致的，性能指标变化幅度最大的问题。比如产生瓶颈后，用户 CPU 使用率升高了 10%，而系统 CPU 使用率却升高了 50%，这个时候就应该首先优化系统 CPU 的使用。</li>
</ol>
<h4 id="12-4-有多种优化方法时，要如何选择"><a href="#12-4-有多种优化方法时，要如何选择" class="headerlink" title="12.4 有多种优化方法时，要如何选择?"></a>12.4 有多种优化方法时，要如何选择?</h4><p>一般情况下，我们当然想选能最大提升性能的方法，这其实也是性能优化的目标。</p>
<p>但要注意，现实情况要考虑的因素却没那么简单。最直观来说，性能优化并非没有成本。性能优化通常会带来复杂度的提升，降低程序的可维护性，还可能在优化一个指标时，引发其他指标的异常。也就是说，很可能你优化了一个指标，另一个指标的性能却变差了。</p>
<p>一个很典型的例子是我将在网络部分讲到的 DPDK（Data Plane Development Kit）。DPDK 是一种优化网络处理速度的方法，它通过绕开内核网络协议栈的方法，提升网络的处理能力。</p>
<p>不过它有一个很典型的要求，就是要独占一个 CPU 以及一定数量的内存大页，并且总是以 100% 的 CPU 使用率运行。所以，如果你的 CPU 核数很少，就有点得不偿失了。</p>
<p>所以，在考虑选哪个性能优化方法时，你要综合多方面的因素。切记，不要想着“一步登天”，试图一次性解决所有问题；也不要只会“拿来主义”，把其他应用的优化方法原封不动拿来用，却不经过任何思考和分析。</p>
<h4 id="12-5-CPU-优化"><a href="#12-5-CPU-优化" class="headerlink" title="12.5 CPU 优化"></a>12.5 CPU 优化</h4><p>清楚了性能优化最基本的三个问题后，我们接下来从应用程序和系统的角度，分别来看看如何才能降低 CPU 使用率，提高 CPU 的并行处理能力。</p>
<ol>
<li><p>应用程序优化</p>
<p> 首先，从应用程序的角度来说，降低 CPU 使用率的最好方法当然是，排除所有不必要的工作，只保留最核心的逻辑。比如减少循环的层次、减少递归、减少动态内存分配等等。</p>
<p> 除此之外，应用程序的性能优化也包括很多种方法，我在这里列出了最常见的几种，你可以记下来。</p>
<ul>
<li><strong>编译器优化</strong>：很多编译器都会提供优化选项，适当开启它们，在编译阶段你就可以获得编译器的帮助，来提升性能。比如， gcc 就提供了优化选项 -O2，开启后会自动对应用程序的代码进行优化。</li>
<li><strong>算法优化</strong>：使用复杂度更低的算法，可以显著加快处理速度。比如，在数据比较大的情况下，可以用 O(nlogn) 的排序算法（如快排、归并排序等），代替 O(n^2) 的排序算法（如冒泡、插入排序等）。</li>
<li><strong>异步处理</strong>：使用异步处理，可以避免程序因为等待某个资源而一直阻塞，从而提升程序的并发处理能力。比如，把轮询替换为事件通知，就可以避免轮询耗费 CPU 的问题。</li>
<li><strong>多线程代替多进程</strong>：前面讲过，相对于进程的上下文切换，线程的上下文切换并不切换进程地址空间，因此可以降低上下文切换的成本。</li>
<li><strong>善用缓存</strong>：经常访问的数据或者计算过程中的步骤，可以放到内存中缓存起来，这样在下次用时就能直接从内存中获取，加快程序的处理速度。</li>
</ul>
</li>
<li><p>系统优化</p>
<p> 从系统的角度来说，优化 CPU 的运行，一方面要充分利用 CPU 缓存的本地性，加速缓存访问；另一方面，就是要控制进程的 CPU 使用情况，减少进程间的相互影响。</p>
<p> 具体来说，系统层面的 CPU 优化方法也有不少，这里我同样列举了最常见的一些方法，方便你记忆和使用。</p>
<ul>
<li><p><strong>CPU 绑定</strong>：把进程绑定到一个或者多个 CPU 上，可以提高 CPU 缓存的命中率，减少跨 CPU 调度带来的上下文切换问题。</p>
</li>
<li><p><strong>CPU 独占</strong>：跟 CPU 绑定类似，进一步将 CPU 分组，并通过 CPU 亲和性机制为其分配进程。这样，这些 CPU 就由指定的进程独占，换句话说，不允许其他进程再来使用这些 CPU。</p>
</li>
<li><p><strong>优先级调整</strong>：使用 nice 调整进程的优先级，正值调低优先级，负值调高优先级。优先级的数值含义前面我们提到过，忘了的话及时复习一下。在这里，适当降低非核心应用的优先级，增高核心应用的优先级，可以确保核心应用得到优先处理。</p>
</li>
<li><p><strong>为进程设置资源限制</strong>：使用 Linux cgroups 来设置进程的 CPU 使用上限，可以防止由于某个应用自身的问题，而耗尽系统资源。</p>
</li>
<li><p><strong>NUMA（Non-Uniform Memory Access）优化</strong>：支持 NUMA 的处理器会被划分为多个 node，每个 node 都有自己的本地内存空间。NUMA 优化，其实就是让 CPU 尽可能只访问本地内存。</p>
</li>
<li><p><strong>中断负载均衡</strong>：无论是软中断还是硬中断，它们的中断处理程序都可能会耗费大量的 CPU。开启 irqbalance 服务或者配置 smp_affinity，就可以把中断处理过程自动负载均衡到多个 CPU 上。</p>
</li>
</ul>
</li>
</ol>
<h4 id="12-6-千万避免过早优化"><a href="#12-6-千万避免过早优化" class="headerlink" title="12.6 千万避免过早优化"></a>12.6 千万避免过早优化</h4><p>“过早优化是万恶之源”。</p>
<p>因为，一方面，优化会带来复杂性的提升，降低可维护性；另一方面，需求不是一成不变的。针对当前情况进行的优化，很可能并不适应快速变化的新需求。这样，在新需求出现时，这些复杂的优化，反而可能阻碍新功能的开发。</p>
<p>所以，性能优化最好是逐步完善，动态进行，不追求一步到位，而要首先保证能满足当前的性能要求。当发现性能不满足要求或者出现性能瓶颈时，再根据性能评估的结果，选择最重要的性能问题进行优化。</p>
<h3 id="13-答疑（一）：无法模拟出-RES-中断的问题，怎么办？"><a href="#13-答疑（一）：无法模拟出-RES-中断的问题，怎么办？" class="headerlink" title="13 | 答疑（一）：无法模拟出 RES 中断的问题，怎么办？"></a>13 | 答疑（一）：无法模拟出 RES 中断的问题，怎么办？</h3><h4 id="13-1-问题-1：性能工具版本太低，导致指标不全"><a href="#13-1-问题-1：性能工具版本太低，导致指标不全" class="headerlink" title="13.1 问题 1：性能工具版本太低，导致指标不全"></a>13.1 问题 1：性能工具版本太低，导致指标不全</h4><p>工具只是查找分析的手段，指标才是我们重点分析的对象。</p>
<p>proc 文件系统提供各项指标。</p>
<h4 id="13-2-问题-2：使用-stress-命令，无法模拟-iowait-高的场景"><a href="#13-2-问题-2：使用-stress-命令，无法模拟-iowait-高的场景" class="headerlink" title="13.2 问题 2：使用 stress 命令，无法模拟 iowait 高的场景"></a>13.2 问题 2：使用 stress 命令，无法模拟 iowait 高的场景</h4><p>使用 stress 无法模拟 iowait 升高，但是却看到了 sys 升高。这是因为案例中 的 stress -i 参数，它表示通过系统调用 sync() 来模拟 I/O 的问题，但这种方法实际上并不可靠。</p>
<p>因为 sync() 的本意是刷新内存缓冲区的数据到磁盘中，以确保同步。如果缓冲区内本来就没多少数据，那读写到磁盘中的数据也就不多，也就没法产生 I/O 压力。</p>
<p>这一点，在使用 SSD 磁盘的环境中尤为明显，很可能你的 iowait 总是 0，却单纯因为大量的系统调用，导致了系统 CPU 使用率 sys 升高。</p>
<p>推荐使用 stress-ng 来代替 stress。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -i 的含义还是调用 sync，而—hdd 则表示读写临时文件</span>
$ stress-ng -i <span class="token number">1</span> --hdd <span class="token number">1</span> --timeout <span class="token number">600</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h4 id="13-3-问题-3：无法模拟出-RES-中断的问题"><a href="#13-3-问题-3：无法模拟出-RES-中断的问题" class="headerlink" title="13.3 问题 3：无法模拟出 RES 中断的问题"></a>13.3 问题 3：无法模拟出 RES 中断的问题</h4><p>这个问题是说，即使运行了大量的线程，也无法模拟出重调度中断 RES 升高的问题。</p>
<p>其实我在 CPU 上下文切换的案例中已经提到，重调度中断是调度器用来分散任务到不同 CPU 的机制，也就是可以唤醒空闲状态的 CPU ，来调度新任务运行，而这通常借助处理器间中断（Inter-Processor Interrupts，IPI）来实现。</p>
<p>所以，这个中断在单核（只有一个逻辑 CPU）的机器上当然就没有意义了，因为压根儿就不会发生重调度的情况。</p>
<p>在这里顺便提一下，留言中很常见的一个错误。有些同学会拿 pidstat 中的 %wait 跟 top 中的 iowait% （缩写为 wa）对比，其实这是没有意义的，因为它们是完全不相关的两个指标。</p>
<ul>
<li>pidstat 中， %wait 表示进程等待 CPU 的时间百分比。</li>
<li>top 中 ，iowait% 则表示等待 I/O 的 CPU 时间百分比。</li>
</ul>
<h4 id="13-4-问题-4：无法模拟出-I-O-性能瓶颈，以及-I-O-压力过大的问题"><a href="#13-4-问题-4：无法模拟出-I-O-性能瓶颈，以及-I-O-压力过大的问题" class="headerlink" title="13.4 问题 4：无法模拟出 I/O 性能瓶颈，以及 I/O 压力过大的问题"></a>13.4 问题 4：无法模拟出 I/O 性能瓶颈，以及 I/O 压力过大的问题</h4><p>这个问题可以看成是上一个问题的延伸，只是把 stress 命令换成了一个在容器中运行的 app 应用。</p>
<p>事实上，在 I/O 瓶颈案例中，除了上面这个模拟不成功的留言，还有更多留言的内容刚好相反，说的是案例 I/O 压力过大，导致自己的机器出各种问题，甚至连系统都没响应了。</p>
<p>之所以这样，其实还是因为每个人的机器配置不同，既包括了 CPU 和内存配置的不同，更是因为磁盘的巨大差异。比如，机械磁盘（HDD）、低端固态磁盘（SSD）与高端固态磁盘相比，性能差异可能达到数倍到数十倍。</p>
<p>其实，我自己所用的案例机器也只是低端的 SSD，比机械磁盘稍微好一些，但跟高端固态磁盘还是比不了的。所以，相同操作下，我的机器上刚好出现 I/O 瓶颈，但换成一台使用机械磁盘的机器，可能磁盘 I/O 就被压死了（表现为使用率长时间 100%），而换上好一些的 SSD 磁盘，可能又无法产生足够的 I/O 压力。</p>
<p>另外，由于我在案例中只查找了 /dev/xvd 和 /dev/sd 前缀的磁盘，而没有考虑到使用其他前缀磁盘（比如 /dev/nvme）的同学。如果你正好用的是其他前缀，你可能会碰到跟 Vicky 类似的问题，也就是 app 启动后又很快退出，变成 exited 状态。</p>
<p>所以，在最新的案例中，我为 app 应用增加了三个选项。</p>
<ul>
<li>-d 设置要读取的磁盘，默认前缀为 /dev/sd 或者 /dev/xvd 的磁盘。</li>
<li>-s 设置每次读取的数据量大小，单位为字节，默认为 67108864（也就是 64MB）。</li>
<li>-c 设置每个子进程读取的次数，默认为 20 次，也就是说，读取 20*64MB 数据后，子进程退出。</li>
</ul>
<p>你可以点击 <a target="_blank" rel="noopener" href="https://github.com/feiskyer/linux-perf-examples/tree/master/high-iowait-process">Github</a> 查看它的源码，使用方法我写在了这里：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run --privileged --name<span class="token operator">=</span>app -itd feisky/app:iowait /app -d /dev/sdb -s <span class="token number">67108864</span> -c <span class="token number">20</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>案例运行后，你可以执行 docker logs 查看它的日志。正常情况下，你可以看到下面的输出：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker logs app
Reading data from disk /dev/sdb with buffer size <span class="token number">67108864</span> and count <span class="token number">20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h4 id="13-5-问题-5：性能工具（如-vmstat）输出中，第一行数据跟其他行差别巨大"><a href="#13-5-问题-5：性能工具（如-vmstat）输出中，第一行数据跟其他行差别巨大" class="headerlink" title="13.5 问题 5：性能工具（如 vmstat）输出中，第一行数据跟其他行差别巨大"></a>13.5 问题 5：性能工具（如 vmstat）输出中，第一行数据跟其他行差别巨大</h4><p>这个问题主要是说，在执行 vmstat 时，第一行数据跟其他行相比较，数值相差特别大。我相信不少同学都注意到了这个现象，这里我简单解释一下。</p>
<p>首先还是要记住，我总强调的那句话，<strong>在碰到直观上解释不了的现象时，要第一时间去查命令手册</strong>。</p>
<p>比如，运行 man vmstat 命令，你可以在手册中发现下面这句话：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">The first report produced gives averages since the last reboot.  Additional reports give information on a sampling period of length delay.  The process and memory reports are instantaneous in either case.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>也就是说，第一行数据是系统启动以来的平均值，其他行才是你在运行 vmstat 命令时，设置的间隔时间的平均值。另外，进程和内存的报告内容都是即时数值。</p>
<h3 id="14-答疑（二）：如何用perf工具分析Java程序？"><a href="#14-答疑（二）：如何用perf工具分析Java程序？" class="headerlink" title="14 | 答疑（二）：如何用perf工具分析Java程序？"></a>14 | 答疑（二）：如何用perf工具分析Java程序？</h3><h4 id="14-1-问题-1：-使用-perf-工具时，看到的是-16-进制地址而不是函数名"><a href="#14-1-问题-1：-使用-perf-工具时，看到的是-16-进制地址而不是函数名" class="headerlink" title="14.1 问题 1： 使用 perf 工具时，看到的是 16 进制地址而不是函数名"></a>14.1 问题 1： 使用 perf 工具时，看到的是 16 进制地址而不是函数名</h4><p>这也是留言比较多的一个问题，在 CentOS 系统中，使用 perf 工具看不到函数名，只能看到一些 16 进制格式的函数地址。</p>
<p>其实，只要你观察一下 perf 界面最下面的那一行，就会发现一个警告信息：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">Failed to open /opt/bitnami/php/lib/php/extensions/opcache.so, continuing without symbols<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这说明，perf 找不到待分析进程依赖的库。当然，实际上这个案例中有很多依赖库都找不到，只不过，perf 工具本身只在最后一行显示警告信息，所以你只能看到这一条警告。</p>
<p>这个问题，其实也是在分析 Docker 容器应用时，我们经常碰到的一个问题，因为容器应用依赖的库都在镜像里面。</p>
<p>针对这种情况，我总结了下面四个解决方法。</p>
<ol>
<li><p>第一个方法，在容器外面构建相同路径的依赖库。这种方法从原理上可行，但是我并不推荐，一方面是因为找出这些依赖库比较麻烦，更重要的是，构建这些路径，会污染容器主机的环境。</p>
</li>
<li><p>第二个方法，在容器内部运行 perf。不过，这需要容器运行在特权模式下，但实际的应用程序往往只以普通容器的方式运行。所以，容器内部一般没有权限执行 perf 分析。</p>
<p> 比方说，如果你在普通容器内部运行 perf record ，你将会看到下面这个错误提示：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ perf_4.9 record -a -g
perf_event_open<span class="token punctuation">(</span><span class="token punctuation">..</span>., PERF_FLAG_FD_CLOEXEC<span class="token punctuation">)</span> failed with unexpected error <span class="token number">1</span> <span class="token punctuation">(</span>Operation not permitted<span class="token punctuation">)</span>
perf_event_open<span class="token punctuation">(</span><span class="token punctuation">..</span>., <span class="token number">0</span><span class="token punctuation">)</span> failed unexpectedly with error <span class="token number">1</span> <span class="token punctuation">(</span>Operation not permitted<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p> 当然，其实你还可以通过配置 /proc/sys/kernel/perf_event_paranoid （比如改成 -1），来允许非特权用户执行 perf 事件分析。</p>
<p> 不过还是那句话，为了安全起见，这种方法我也不推荐。</p>
</li>
<li><p>第三个方法，指定符号路径为容器文件系统的路径。比如对于第 05 讲的应用，你可以执行下面这个命令：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">mkdir</span> /tmp/foo
$ <span class="token assign-left variable">PID</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>docker inspect --format <span class="token punctuation">{</span><span class="token punctuation">{</span>.State.Pid<span class="token punctuation">}</span><span class="token punctuation">}</span> phpfpm<span class="token variable">)</span></span>
$ bindfs /proc/<span class="token variable">$PID</span>/root /tmp/foo
$ perf report --symfs /tmp/foo

<span class="token comment"># 使用完成后不要忘记解除绑定</span>
$ <span class="token function">umount</span> /tmp/foo/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 不过这里要注意，bindfs 这个工具需要你额外安装。bindfs 的基本功能是实现目录绑定（类似于 mount —bind），这里需要你安装的是 1.13.10 版本（这也是它的最新发布版）。</p>
<p> 如果你安装的是旧版本，你可以到 <a target="_blank" rel="noopener" href="https://github.com/mpartel/bindfs">GitHub</a> 上面下载源码，然后编译安装。</p>
</li>
<li><p>第四个方法，在容器外面把分析纪录保存下来，再去容器里查看结果。这样，库和符号的路径也就都对了。</p>
<p> 比如，你可以这么做。先运行 perf record -g -p &lt; pid&gt;，执行一会儿（比如 15 秒）后，按 Ctrl+C 停止。</p>
<p> 然后，把生成的 perf.data 文件，拷贝到容器里面来分析：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker <span class="token function">cp</span> perf.data phpfpm:/tmp
$ docker <span class="token builtin class-name">exec</span> -i -t phpfpm <span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 接下来，在容器的 bash 中继续运行下面的命令，安装 perf 并使用 perf report 查看报告：</p>
 <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> /tmp/
$ <span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token function">install</span> -y linux-tools linux-perf procps
$ perf_4.9 report<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p> 不过，这里也有两点需要你注意。</p>
<ol>
<li>首先是 perf 工具的版本问题。在最后一步中，我们运行的工具是容器内部安装的版本 perf_4.9，而不是普通的 perf 命令。这是因为， perf 命令实际上是一个软连接，会跟内核的版本进行匹配，但镜像里安装的 perf 版本跟虚拟机的内核版本有可能并不一致。</li>
<li>另外，php-fpm 镜像是基于 Debian 系统的，所以安装 perf 工具的命令，跟 Ubuntu 也并不完全一样。</li>
</ol>
</li>
</ol>
<p>事实上，抛开我们的案例来说，即使是在非容器化的应用中，你也可能会碰到这个问题。假如你的应用程序在编译时，使用 strip 删除了 ELF 二进制文件的符号表，那么你同样也只能看到函数的地址。</p>
<h4 id="14-2-问题-2：如何用-perf-工具分析-Java-程序"><a href="#14-2-问题-2：如何用-perf-工具分析-Java-程序" class="headerlink" title="14.2 问题 2：如何用 perf 工具分析 Java 程序"></a>14.2 问题 2：如何用 perf 工具分析 Java 程序</h4><p>这两个问题，其实是上一个 perf 问题的延伸。 像是 Java 这种通过 JVM 来运行的应用程序，运行堆栈用的都是 JVM 内置的函数和堆栈管理。所以，从系统层面你只能看到 JVM 的函数堆栈，而不能直接得到 Java 应用程序的堆栈。</p>
<p>perf_events 实际上已经支持了 JIT，但还需要一个 /tmp/perf-PID.map 文件，来进行符号翻译。当然，开源项目 <a target="_blank" rel="noopener" href="https://github.com/jvm-profiling-tools/perf-map-agent">perf-map-agent</a> 可以帮你生成这个符号表。</p>
<p>此外，为了生成全部调用栈，你还需要开启 JDK 的选项 -XX:+PreserveFramePointer。因为这里涉及到大量的 Java 知识，我就不再详细展开了。如果你的应用刚好基于 Java ，那么你可以参考 NETFLIX 的技术博客 <a target="_blank" rel="noopener" href="https://medium.com/netflix-techblog/java-in-flames-e763b3d32166">Java in Flames</a>，来查看详细的使用步骤。</p>
<p>说到这里，我也想强调一个问题，那就是学习性能优化时，不要一开始就把自己限定在具体的某个编程语言或者性能工具中，纠结于语言或工具的细节出不来。</p>
<p>掌握整体的分析思路，才是我们首先要做的。因为，性能优化的原理和思路，在任何编程语言中都是相通的。</p>
<h4 id="14-3-问题-3：为什么-perf-的报告中，很多符号都不显示调用栈"><a href="#14-3-问题-3：为什么-perf-的报告中，很多符号都不显示调用栈" class="headerlink" title="14.3 问题 3：为什么 perf 的报告中，很多符号都不显示调用栈"></a>14.3 问题 3：为什么 perf 的报告中，很多符号都不显示调用栈</h4><p>perf report 是一个可视化展示 perf.data 的工具。在第 08 讲的案例中，我直接给出了最终结果，并没有详细介绍它的参数。估计很多同学的机器在运行时，都碰到了跟路过同学一样的问题，看到的是下面这个界面。</p>
<p><img src="/images/《Linux性能优化实战》学习笔记/perf报告中很多符号都不显示调用栈.png" alt="perf报告中很多符号都不显示调用栈"></p>
<p>这个界面可以清楚看到，perf report 的输出中，只有 swapper 显示了调用栈，其他所有符号都不能查看堆栈情况，包括我们案例中的 app 应用。</p>
<p>这种情况我们以前也遇到过，当你发现性能工具的输出无法理解时，应该怎么办呢？当然还是查工具的手册。比如，你可以执行 man perf-report 命令，找到 -g 参数的说明：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">-g, --call-graph=&lt;print_type,threshold[,print_limit],order,sort_key[,branch],value&gt;
           Display call chains using type, min percent threshold, print limit, call order, sort key, optional branch and value. Note that
           ordering is not fixed so any parameter can be given in an arbitrary order. One exception is the print_limit which should be
           preceded by threshold.

               print_type can be either:
               - flat: single column, linear exposure of call chains.
               - graph: use a graph tree, displaying absolute overhead rates. (default)
               - fractal: like graph, but displays relative rates. Each branch of
                        the tree is considered as a new profiled object.
               - folded: call chains are displayed in a line, separated by semicolons
               - none: disable call chain display.

               threshold is a percentage value which specifies a minimum percent to be
               included in the output call graph.  Default is 0.5 (%).

               print_limit is only applied when stdio interface is used.  It's to limit
               number of call graph entries in a single hist entry.  Note that it needs
               to be given after threshold (but not necessarily consecutive).
               Default is 0 (unlimited).

               order can be either:
               - callee: callee based call graph.
               - caller: inverted caller based call graph.
               Default is 'caller' when --children is used, otherwise 'callee'.

               sort_key can be:
               - function: compare on functions (default)
               - address: compare on individual code addresses
               - srcline: compare on source filename and line number

               branch can be:
               - branch: include last branch information in callgraph when available.
                         Usually more convenient to use --branch-history for this.

               value can be:
               - percent: diplay overhead percent (default)
               - period: display event period
               - count: display event count<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过这个说明可以看到，-g 选项等同于 —call-graph，它的参数是后面那些被逗号隔开的选项，意思分别是输出类型、最小阈值、输出限制、排序方法、排序关键词、分支以及值的类型。</p>
<p>我们可以看到，这里默认的参数是 graph,0.5,caller,function,percent，具体含义文档中都有详细讲解，这里我就不再重复了。</p>
<p>现在再回过头来看我们的问题，堆栈显示不全，相关的参数当然就是最小阈值 threshold。通过手册中对 threshold 的说明，我们知道，当一个事件发生比例高于这个阈值时，它的调用栈才会显示出来。</p>
<p>threshold 的默认值为 0.5%，也就是说，事件比例超过 0.5% 时，调用栈才能被显示。再观察我们案例应用 app 的事件比例，只有 0.34%，低于 0.5%，所以看不到 app 的调用栈就很正常了。</p>
<p>这种情况下，你只需要给 perf report 设置一个小于 0.34% 的阈值，就可以显示我们想看到的调用图了。比如执行下面的命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ perf report -g graph,0.3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="14-4-问题-4：怎么理解-perf-report-报告"><a href="#14-4-问题-4：怎么理解-perf-report-报告" class="headerlink" title="14.4 问题 4：怎么理解 perf report 报告"></a>14.4 问题 4：怎么理解 perf report 报告</h4><p>看到这里，我估计你也曾嘀咕过，为啥不一上来就用 perf 工具解决，还要执行那么多其他工具呢？ 这个问题其实就给出了很好的解释。</p>
<p>在问题 4 的 perf report 界面中，你也一定注意到了， swapper 高达 99% 的比例。直觉来说，我们应该直接观察它才对，为什么没那么做呢？</p>
<p>其实，当你清楚了 swapper 的原理后，就很容易理解我们为什么可以忽略它了。</p>
<p>看到 swapper，你可能首先想到的是 SWAP 分区。实际上， swapper 跟 SWAP 没有任何关系，它只在系统初始化时创建 init 进程，之后，它就成了一个最低优先级的空闲任务。也就是说，当 CPU 上没有其他任务运行时，就会执行 swapper 。所以，你可以称它为“空闲任务”。</p>
<p>回到我们的问题，在 perf report 的界面中，展开它的调用栈，你会看到， swapper 时钟事件都耗费在了 do_idle 上，也就是在执行空闲任务。</p>
<p><img src="/images/《Linux性能优化实战》学习笔记/怎么理解perfreport报告.png" alt="怎么理解perfreport报告"></p>
<p>所以，分析案例时，我们直接忽略了前面这个 99% 的符号，转而分析后面只有 0.3% 的 app。其实从这里你也能理解，为什么我们一开始不先用 perf 分析。</p>
<p>因为在多任务系统中，次数多的事件，不一定就是性能瓶颈。所以，只观察到一个大数值，并不能说明什么问题。具体有没有瓶颈，还需要你观测多个方面的多个指标，来交叉验证。这也是我在套路篇中不断强调的一点。</p>
<p>另外，关于 Children 和 Self 的含义，手册里其实有详细说明，还很友好地举了一个例子，来说明它们的百分比的计算方法。简单来说，</p>
<ul>
<li>Self 是最后一列的符号（可以理解为函数）本身所占比例；</li>
<li>Children 是这个符号调用的其他符号（可以理解为子函数，包括直接和间接调用）占用的比例之和。</li>
</ul>
<p>所以，使用性能工具时，确实应该考虑工具本身对系统性能的影响。而这种情况，就需要你了解这些工具的原理。比如，</p>
<ul>
<li>perf 这种动态追踪工具，会给系统带来一定的性能损失。</li>
<li>vmstat、pidstat 这些直接读取 proc 文件系统来获取指标的工具，不会带来性能损失。</li>
</ul>
<h4 id="14-5-问题-5：性能优化书籍和参考资料推荐"><a href="#14-5-问题-5：性能优化书籍和参考资料推荐" class="headerlink" title="14.5 问题 5：性能优化书籍和参考资料推荐"></a>14.5 问题 5：性能优化书籍和参考资料推荐</h4><p>Brendan Gregg</p>
<p>《Systems Performance: Enterprise and the Cloud》</p>
<blockquote>
<p>中文版 《性能之巅：洞悉系统、企业与云计算》</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="http://www.brendangregg.com/linuxperf.html">Linux Performance</a></p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://kibazen.cn" rel="external nofollow noreferrer">Kiba Amor</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                    </span>
                <span class="reprint-info">
                    <a href="https://kibazen.cn/linux-xing-neng-you-hua-shi-zhan-xue-xi-bi-ji/">https://kibazen.cn/linux-xing-neng-you-hua-shi-zhan-xue-xi-bi-ji/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY-NC-ND 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://kibazen.cn" target="_blank">Kiba Amor</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/">
                                    <span class="chip bg-color">性能分析</span>
                                </a>
                            
                                <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                                    <span class="chip bg-color">极客时间</span>
                                </a>
                            
                                <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">
                                    <span class="chip bg-color">性能优化</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="qq,wechat,weibo,douban" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/linux-xing-neng-you-hua-shi-zhan-xue-xi-bi-ji/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/7.jpg" class="responsive-img" alt="《Linux性能优化实战》学习笔记">
                        
                        <span class="card-title">《Linux性能优化实战》学习笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-11-04
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                    学习笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/">
                        <span class="chip bg-color">性能分析</span>
                    </a>
                    
                    <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                        <span class="chip bg-color">极客时间</span>
                    </a>
                    
                    <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">
                        <span class="chip bg-color">性能优化</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/linux-xing-neng-fen-xi/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/12.jpg" class="responsive-img" alt="Linux性能分析">
                        
                        <span class="card-title">Linux性能分析</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-11-02
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Linux/" class="post-category">
                                    Linux
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/">
                        <span class="chip bg-color">性能分析</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (true) {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 木叶禅<br />'
            + '文章作者: Kiba Amor<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者木叶禅所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('3'),
            headingSelector: 'h2, h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2021</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">Kiba Amor</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">266.2k</span>&nbsp;字
            
            
            
            
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/kibaamor" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>









    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=562236616" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 562236616" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>





    <a href="https://www.zhihu.com/people/kibaamor" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/kibaamor" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    

    

    

	
    

    

    

    
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
