<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <meta name="keywords" content="《Vim实用技巧必知必会》学习笔记, kiba, zen, amor, kibazen, kibaamor, 木叶, 木叶禅">
    <meta name="description" content="一个普通游戏程序员的博客">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>《Vim实用技巧必知必会》学习笔记 | 木叶禅</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/css/my.css">

    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="木叶禅" type="application/atom+xml">
</head>



   <style>
    body{
       background-image: url(/medias/background.jpg);
       background-repeat:no-repeat;
       background-size:cover;
       background-attachment:fixed;
    }
</style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">木叶禅</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/leetcode/" class="waves-effect waves-light">
      
      <i class="fas fa-code" style="zoom: 0.6;"></i>
      
      <span>LeetCode</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/learn/" class="waves-effect waves-light">
      
      <i class="fas fa-book" style="zoom: 0.6;"></i>
      
      <span>学习</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tool/" class="waves-effect waves-light">
      
      <i class="fas fa-toolbox" style="zoom: 0.6;"></i>
      
      <span>工具</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories/" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags/" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about/" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">木叶禅</div>
        <div class="logo-desc">
            
            一个普通游戏程序员的博客
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/leetcode/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-code"></i>
			
			LeetCode
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/learn/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-book"></i>
			
			学习
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tool/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-toolbox"></i>
			
			工具
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    
<script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = 'f65e070788a2647953051a7a1b70ada7fd2b3f70cd4d93c977207f5b762987d4';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/3.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">《Vim实用技巧必知必会》学习笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                                <span class="chip bg-color">极客时间</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                学习笔记
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-01-23
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2022-01-25
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    43.9k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    161 分
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p><a target="_blank" rel="noopener" href="http://service.qbjavawa.top/time/VIMPracticalSkills.html">http://service.qbjavawa.top/time/VIMPracticalSkills.html</a></p>
<h2 id="01｜各平台下的-Vim-安装方法：上路前准备好你的宝马"><a href="#01｜各平台下的-Vim-安装方法：上路前准备好你的宝马" class="headerlink" title="01｜各平台下的 Vim 安装方法：上路前准备好你的宝马"></a>01｜各平台下的 Vim 安装方法：上路前准备好你的宝马</h2><h2 id="02｜基本概念和基础命令：应对简单的编辑任务"><a href="#02｜基本概念和基础命令：应对简单的编辑任务" class="headerlink" title="02｜基本概念和基础命令：应对简单的编辑任务"></a>02｜基本概念和基础命令：应对简单的编辑任务</h2><h3 id="2-1-Vim-教程的内容概要"><a href="#2-1-Vim-教程的内容概要" class="headerlink" title="2.1 Vim 教程的内容概要"></a>2.1 Vim 教程的内容概要</h3><p><img src="/images/《Vim实用技巧必知必会》学习笔记/Vim命令速查（教程版）.png" alt="Vim命令速查（教程版）"></p>
<p>图中的“•”表示，单个字母不是完整的命令，必须再有进一步的输入。比如，单个“g”没有意义，而“gg”表示跳转到文件开头。（对于命令后面明确跟一个动作的，如“c”，我们不使用“•”。）一个键最多有三排内容：最底下是直接按键的结果，中间是按下 Shift 的结果（变大写），上面偏右的小字是按下 Ctrl 的结果。</p>
<p>一些命令行命令：</p>
<ul>
<li>“:q!”：退出 Vim</li>
<li>“:wq”：存盘退出</li>
<li>“:s”：执行替换</li>
<li>“:!”：执行外部命令</li>
<li>“:edit”（一般缩写为 “:e”）：编辑文件</li>
<li>“:w”：写文件</li>
<li>“:r”：读文件</li>
<li>“:help”：查看帮助</li>
<li>使用键 Ctrl-D 和 Tab 来进行命令行补全</li>
</ul>
<h3 id="2-2-Vim-的模式"><a href="#2-2-Vim-的模式" class="headerlink" title="2.2 Vim 的模式"></a>2.2 Vim 的模式</h3><p>Vim 有以下四种主要模式：</p>
<ul>
<li>正常（normal）模式（也称为普通模式），缺省的编辑模式；如果不加特殊说明，一般提到的命令都直接在正常模式下输入；在任何其他模式中，都可以通过键盘上的 Esc 键回到正常模式。</li>
<li>插入（insert）模式，输入文本时使用；比如在正常模式下键入 i（insert）或 a（append）即可进入插入模式。</li>
<li>可视（visual）模式，用于选定文本块；教程中已经提到可以用键 v（小写）来按字符选定，Vim 里也提供其他不同的选定方法，包括按行和按列块。</li>
<li>命令行（command-line）模式，用于执行较长、较复杂的命令；在正常模式下键入冒号（:）即可进入该模式；使用斜杠（/）和问号（?）开始搜索也算作命令行模式。命令行模式下的命令要输入回车键（Enter）才算完成。</li>
</ul>
<p>此外，Vim 也有个选择（select）模式，与普通的 Windows 编辑器行为较为接近，选择内容后再输入任何内容，将会替换选择的内容。在以可视模式和选择模式之一选定文本块之后，可以使用 Ctrl-G 切换到另一模式。</p>
<h3 id="2-3-Vim-的键描述体例"><a href="#2-3-Vim-的键描述体例" class="headerlink" title="2.3 Vim 的键描述体例"></a>2.3 Vim 的键描述体例</h3><p>Vim 里的标准键描述方式：</p>
<ul>
<li><code>&lt;Esc&gt;</code> 表示 Esc 键；显示为“⎋”</li>
<li><code>&lt;CR&gt;</code> 表示回车键；显示为“↩”</li>
<li><code>&lt;Space&gt;</code> 表示空格键；显示为“␣”</li>
<li><code>&lt;Tab&gt;</code> 表示 Tab 键；显示为“⇥”</li>
<li><code>&lt;BS&gt;</code> 表示退格键；显示为“⌫”</li>
<li><code>&lt;Del&gt;</code> 表示删除键；显示为“⌦”</li>
<li><code>&lt;lt&gt;</code> 表示 &lt; 键；显示为“&lt;”</li>
<li><code>&lt;Up&gt;</code> 表示光标上移键；显示为“⇡”</li>
<li><code>&lt;Down&gt;</code> 表示光标下移键；显示为“⇣”</li>
<li><code>&lt;Left&gt;</code> 表示光标左移键；显示为“⇠”</li>
<li><code>&lt;Right&gt;</code> 表示光标右移键；显示为“⇢”</li>
<li><code>&lt;PageUp&gt;</code> 表示 Page Up 键；显示为“⇞”</li>
<li><code>&lt;PageDown&gt;</code> 表示 Page Down 键；显示为“⇟”</li>
<li><code>&lt;Home&gt;</code> 表示 Home 键；显示为“↖”</li>
<li><code>&lt;End&gt;</code> 表示 End 键；显示为“↘”</li>
<li><code>&lt;F1&gt; - &lt;F12&gt;</code> 表示功能键 1 到 12；显示为“F1”到“F12”</li>
<li><code>&lt;S-…&gt;</code> Shift 组合键；显示为“⇧”（较少使用，因为我们需要写 <code>!</code> 而不是 <code>&lt;S-1&gt;</code>； 和特殊键组合时仍然有用）</li>
<li><code>&lt;C-…&gt;</code> Control 组合键；显示为“⌃”</li>
<li><code>&lt;M-…&gt;</code> Alt 组合键；显示为“⌥”（对于大部分用户，它的原始键名 Meta 应该只具有历史意义）</li>
<li><code>&lt;D-…&gt;</code> Command 组合键；显示为“⌘”（Mac 键盘）</li>
</ul>
<p>Esc、Enter、v、V 和 Ctrl-V 以后就会写成 <code>&lt;Esc&gt;</code>、<code>&lt;CR&gt;</code>、<code>v</code>、<code>V</code>、<code>&lt;C-V&gt;</code>。这也是以后在 Vim 里对键进行重映射的写法。</p>
<p>这里我要强调一下，对“&lt;”的特殊解释仅在描述输入时生效。在描述命令行和代码时，我们写“<code>&lt;CR&gt;</code>”仍表示四个字符，而非回车键。特别是，如果我们描述的命令行首是“:”，表示这是一个输入 : 开始的 Vim 命令行模式命令（以回车键结束）；如果行首是“/”或“?”，表示这是一个输入 / 或 ? 开始的搜索命令（以回车键结束）；如果行首是“$”，表示这是一个在 shell 命令行上输入的命令（以回车键结束），“$”（和后面的空格）不是命令的一部分，通常后续行也不是命令的一部分，除非行尾有“\”或“^”字符，或行首有“$”字符。</p>
<p>也就是说，下面的命令是在 Vim 里输入“<code>:set ft?&lt;CR&gt;</code>”（用来显示当前编辑文件的文件类型）：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token punctuation">:</span><span class="token keyword">set</span> <span class="token builtin">ft</span><span class="token operator">?</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/Vim命令示例.gif" alt="Vim命令示例"></p>
<p>下面的命令则是在 shell 里输入“<code>which vim&lt;CR&gt;</code>”（用来检查 vim 命令的位置）：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">which</span> <span class="token function">vim</span>
/usr/bin/vim<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/Shell命令示例.gif" alt="Shell命令示例"></p>
<p>此外，当我用“<a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/help.html">:help</a>”描述帮助命令时，你不仅可以在 Vim 里输入这个命令来得到帮助，也可以点击这个帮助的链接，直接在线查看相应的中文帮助页面。</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/Vim的内置帮助功能.jpeg" alt="Vim的内置帮助功能"></p>
<p>这节内容不需要死记。建议使用“收藏”功能，这样，你可以在以后碰到不认识的符号标记的时候，返回来查看这一节的内容。</p>
<h3 id="2-4-Vim-的选项和配置"><a href="#2-4-Vim-的选项和配置" class="headerlink" title="2.4 Vim 的选项和配置"></a>2.4 Vim 的选项和配置</h3><p>Vim 的配置文件放在用户的主目录下，文件名通常是 .vimrc；而它在 Windows 下名字是 _vimrc。最基本的配置文件：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">set</span> <span class="token builtin">enc</span><span class="token operator">=</span>utf<span class="token operator">-</span><span class="token number">8</span>
<span class="token keyword">set</span> <span class="token builtin">nocompatible</span>
<span class="token keyword">source</span> $VIMRUNTIME<span class="token operator">/</span>vimrc_example<span class="token operator">.</span><span class="token keyword">vim</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这三行完成了下列功能：</p>
<ul>
<li>设置编辑文件的内码是 UTF-8（非所有平台缺省，但为编辑多语言文件所必需）</li>
<li>设置 Vim 不需要和 vi 兼容（仅为万一起见，目前大部分情况下这是缺省情况）</li>
<li>导入 Vim 的示例配置（这会打开一些有用的选项，如语法加亮、搜索加亮、命令历史、记住上次的文件位置，等等）</li>
</ul>
<p>对于现代 Unix 系统上的 Vim 8，实际上只需要最后一句就足够了。对于现代 Windows 系统上的 Vim 8，中间的这句 <code>set nocompatible</code> 也可以删除。如果你在较老的 Vim 版本上进行配置，那么把这三行全放进去会比较安全。</p>
<h4 id="2-4-1-备份和撤销文件"><a href="#2-4-1-备份和撤销文件" class="headerlink" title="2.4.1 备份和撤销文件"></a>2.4.1 备份和撤销文件</h4><p>上面的基本设置会产生一个有人喜欢、但也有很多人感到困惑的结果：你修改文件时会出现结尾为“~”的文件，有文件名后面直接加“~”的，还有前面加“.”后面加“.un~”的。这是因为在示例配置里，Vim 自动设置了下面两个选项：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">set</span> <span class="token builtin">backup</span>
<span class="token keyword">set</span> undofile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>前一个选项使得我们每次编辑会保留上一次的备份文件，后一个选项使得 Vim 在重新打开一个文件时，仍然能够撤销之前的编辑（undo），这就会产生一个保留编辑历史的“撤销文件”（undofile）了。</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/有撤销文件时，再次打开文件仍然可以撤销上次的编辑.gif" alt="有撤销文件时，再次打开文件仍然可以撤销上次的编辑"></p>
<p>我的通常做法是，不产生备份文件，但保留跨会话撤销编辑的能力；因为有了撤销文件，备份其实也就没有必要了。同时，把撤销文件放在用户个人的特定目录下，既保证了安全，又免去了其他目录下出现不必要文件的麻烦。</p>
<p>要达到这个目的，我在 Linux/macOS 下会这么写：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">set</span> <span class="token builtin">nobackup</span>
<span class="token keyword">set</span> undodir<span class="token operator">=~</span><span class="token operator">/</span><span class="token operator">.</span><span class="token keyword">vim</span><span class="token operator">/</span>undodir<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在 Windows 下这么写：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">set</span> <span class="token builtin">nobackup</span>
<span class="token keyword">set</span> undodir<span class="token operator">=~</span>\vimfiles\undodir<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>无论哪种环境，你都需要创建这个目录。我们可以用下面的命令来让 Vim 在启动时自动创建这个目录：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">isdirectory</span><span class="token punctuation">(</span>&amp;undodir<span class="token punctuation">)</span>
  <span class="token keyword">call</span> <span class="token function">mkdir</span><span class="token punctuation">(</span>&amp;undodir<span class="token punctuation">,</span> <span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token number">0700</span><span class="token punctuation">)</span>
<span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>其中 <code>&amp;undodir</code> 代表 <code>undodir</code> 这个选项的值。相关的帮助文档：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/eval.html#isdirectory%28%29">:help isdirectory()</a></li>
<li><a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/eval.html#mkdir%28%29">:help mkdir()</a></li>
<li><a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/eval.html#:call">:help :call</a></li>
</ul>
<p>这个跨会话撤销的能力，我还真不知道其他哪个编辑器也有。更妙的是，Vim 还有撤销树的概念，可以帮助你回到任一历史状态。</p>
<h4 id="2-4-2-鼠标支持"><a href="#2-4-2-鼠标支持" class="headerlink" title="2.4.2 鼠标支持"></a>2.4.2 鼠标支持</h4><p>在 Vim 的终端使用场景下，鼠标的选择有一定的歧义：你希望是使用 Vim 的可视模式选择内容，并且只能在 Vim 里使用呢，还是产生 Vim 外的操作系统的文本选择，用于跟其他应用程序的交互呢？这是一个基本的使用问题，两种情况都可能发生，都需要照顾。</p>
<p>如果你使用 xterm 兼容终端的话，通常的建议是：</p>
<ul>
<li>在不按下修饰键时，鼠标选择产生 Vim 内部的可视选择。</li>
<li>在按下 Shift 时，鼠标选择产生操作系统的文本选择。</li>
</ul>
<p>对于不兼容 xterm、不支持对 Shift 键做这样特殊处理的终端，我们一般会采用一种“绕过”方式，让 Vim 在某种情况下暂时不接管鼠标事件。通常的选择是在命令行模式下不使用鼠标。下面，我们就分这两种情况来配置。</p>
<p>虽然最新的 Vim 缺省配置文件（示例配置文件会包含缺省配置），在大部分情况下已经可以自动设置合适的鼠标选项了，不过为照顾我们课程的三种不同平台，我们还是手工设置一下：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">if</span> <span class="token function">has</span><span class="token punctuation">(</span><span class="token string">'mouse'</span><span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token function">has</span><span class="token punctuation">(</span><span class="token string">'gui_running'</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>&amp;<span class="token builtin">term</span> <span class="token operator">=~</span> <span class="token string">'xterm'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token string">'mac'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">set</span> <span class="token builtin">mouse</span><span class="token operator">=</span>a
  <span class="token keyword">else</span>
    <span class="token keyword">set</span> <span class="token builtin">mouse</span><span class="token operator">=</span>nvi
  <span class="token keyword">endif</span>
<span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面代码说的是，如果 Vim 有鼠标支持的话，那在以下任一条件满足时：</p>
<ul>
<li>图形界面正在运行</li>
<li>终端是 xterm 兼容，并且不是 Mac（Mac 上的终端声称自己是 xterm，但行为并不完全相同）</li>
</ul>
<p>我们将启用完全的鼠标支持（<code>mouse=a</code>）。特别是，此时鼠标拖拽就会在 Vim 里使用可视模式选择内容（只能在 Vim 里使用）。而当用户按下 Shift 键时，窗口系统接管鼠标事件，用户可以使用鼠标复制 Vim 窗口里的内容供其他应用程序使用。</p>
<p>否则（非图形界面的的终端，且终端类型不是 xterm），就只在正常模式（n）、可视模式（v）、插入模式（i）中使用鼠标。这意味着，当用户按下 <code>:</code> 键进入命令行模式时，Vim 将不对鼠标进行响应，这时，用户就可以使用鼠标复制 Vim 窗口里的内容到其他应用程序里去了。</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/可视模式的选取和按：后的选取.gif" alt="可视模式的选取和按：后的选取"></p>
<p>非 xterm 的鼠标支持在 macOS 和 Windows 下都有效。但在 Windows 下需要注意的一点是，如果使用非图形界面的 Vim 的话，应当在命令提示符（Command Prompt）的属性里关闭“快速编辑模式”（QuickEdit Mode），否则 Vim 在运行时将无法对鼠标事件进行响应。</p>
<p>鉴于命令提示符的行为有很多怪异和不一致之处，强烈建议你在 Windows 下，要么使用图形界面的 Vim，要么使用 Cygwin/MSYS2 里、运行在 mintty 下的 Vim。</p>
<h4 id="2-4-3-中文支持"><a href="#2-4-3-中文支持" class="headerlink" title="2.4.3 中文支持"></a>2.4.3 中文支持</h4><p>完整的 Unicode 历史和原理从实用的角度可以简化成下面几条：</p>
<ul>
<li>整个世界基本上在向 UTF-8 编码靠拢。</li>
<li>微软由于历史原因，内部使用 UTF-16；UTF-16 可以跟 UTF-8 无损转换。</li>
<li>GB2312、GBK、GB18030 是一系列向后兼容的中文标准编码方式，GB2312 编码的文件是合法的 GBK 文件，GBK 编码的文件是合法的 GB18030 文件。但除了 GB18030，都不能做到跟 UTF-8 无损转换；目前非 UTF-8 的简体中文文本基本上都用 GBK/GB18030 编码（繁体中文文本则以 Big5 居多）。鉴于 GB18030 是国家标准，其他两种编码也和 GB18030 兼容，我们就重点讲如何在 Vim 中支持 GB18030 了。</li>
</ul>
<p>举一个具体的例子，“你好😄”这个字符串，在 UTF-8 编码下是下面 10 个字节（我按字符进行了分组）：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">e4bda0 e5a5bd f09f9884<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果使用 GB18030 编码（GB2312/GBK 不能支持表情字符）的话，会编码成 8 个字节：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">c4e3 bac3 9439fd30<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这么看起来，GB18030 处理中文在存储效率上是优势的。但它也有缺点：</p>
<ul>
<li>GBK 外的 Unicode 字符一般需要四字节编码（非中文情况会劣化）</li>
<li>GBK 外的 Unicode 字符跟 Unicode 码点需要查表才能转换（UTF-8 则可以用非常简单的条件判断、移位、与、或操作来转换）</li>
<li>一旦出现文件中有单字节发生损毁，后续的所有中文字符都可能发生紊乱（而 UTF-8 可以在一个字符之后恢复）</li>
</ul>
<p>因此，GB18030 在国际化的软件中不会作为内码来使用，只会是读取/写入文件时使用的转换编码。我们要让 Vim 支持 GB18030 也同样是如此。由于 UTF-8 编码是有明显规律的，并非任意文件都能成功地当成 UTF-8 来解码，我们一般使用的解码顺序是：</p>
<ul>
<li>首先，检查文件是不是有 Unicode 的 BOM（字节顺序标记）字符，有的话按照 BOM 字符来转换文件内容。</li>
<li>其次，检查文件能不能当作 UTF-8 来解码；如果可以，就当作 UTF-8 来解释。</li>
<li>否则，尝试用 GB18030 来解码；如果能成功，就当作 GB18030 来转换文件内容。</li>
<li>最后，如果上面的解码都不成功，就按 Latin1 字符集来解码；由于这是单字节的编码，转换必定成功。</li>
</ul>
<p>事实上，Vim 缺省差不多就是按这样的顺序，但第三步使用何种编码跟系统配置有关。如果你明确需要处理中文，那在配置文件里最好明确写下下面的选项设定：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">set</span> <span class="token builtin">fileencodings</span><span class="token operator">=</span>ucs<span class="token operator">-</span>bom<span class="token punctuation">,</span>utf<span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">,</span>gb18030<span class="token punctuation">,</span>latin1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="2-4-4-图形界面的字体配置"><a href="#2-4-4-图形界面的字体配置" class="headerlink" title="2.4.4 图形界面的字体配置"></a>2.4.4 图形界面的字体配置</h4><p>图形界面的 Vim 可以自行配置使用的字体，但在大部分环境里，这只是起到美化作用，而非必需项。不过，对于高分辨率屏幕的 Windows，这是一个必需项：Vim 在 Windows 下缺省使用的不是 TrueType 字体，不进行配置的话，字体会小得没法看。</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/高分辨率屏下的Windows图形界面Vim.png" alt="高分辨率屏下的Windows图形界面Vim"></p>
<p>在 Windows 的缺省字体里，一般而言，Consolas 和 Courier New 还比较合适。以 Courier New 为例，在 <code>_vimrc</code> 里可以这样配置（Windows 上的基本写法是字体名称加冒号、“h”加字号；用“_”取代空格，否则空格需要用“\”转义）：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">if</span> <span class="token function">has</span><span class="token punctuation">(</span><span class="token string">'gui_running'</span><span class="token punctuation">)</span>
  <span class="token keyword">set</span> <span class="token builtin">guifont</span><span class="token operator">=</span>Courier_New<span class="token punctuation">:</span>h10
<span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/设置了10磅Consolas字体的Vim.png" alt="设置了10磅Consolas字体的Vim"></p>
<p>字体名称如何写是件平台相关的事（可参见帮助文档“<a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/gui.html#gui-font">:help gui-font</a>”）。如果你不确定怎么写出你需要的字体配置，或者你怎么写都写不对的话，可以先使用图形界面的菜单来选择（通常是“编辑 &gt; 选择字体”；在 MacVim 里是“Edit &gt; Font &gt; Show Fonts”），然后使用命令“:set guifont?”来查看。</p>
<p>注意，Vim 在设置选项时，空格需要用“\”进行转义。比如，如果我们要在 Ubuntu 下把字体设成 10 磅的 DejaVu Sans Mono，就需要写：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token comment">" Linux 和 Windows 不同，不能用 </span><span class="token string">'_'</span> 取代空格
<span class="token keyword">set</span> <span class="token builtin">guifont</span><span class="token operator">=</span>DejaVu\ Sans\ Mono\ <span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>此外，宽字符字体（对我们来讲，就是中文字体了）是可以单独配置的。这可能就更是一件仁者见仁、智者见智的事了。对于纯中文的操作系统，这一般反而是不需要配置的；但如果你的语言设定里，中文不是第一选择的话，就有可能在显示中文时出现操作系统误用日文字体的情况。这时你会想要手工选择一个中文字体，比如在 Ubuntu 下，可以用：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">set</span> <span class="token builtin">guifontwide</span><span class="token operator">=</span>Noto\ Sans\ Mono\ CJK\ SC\ <span class="token number">11</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>注意，在不同的中英文字体搭配时，并不需要字号相同。事实上，在 Windows 和 Linux 上我通常都是使用不同字号的中英文字体的。</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/Ubuntu下gvim设置中文字体.gif" alt="Ubuntu下gvim设置中文字体"></p>
<p>在上面的动图中，你可以观察到设了中文字体之后，不仅中文字变大，更美观了，“将”、“适”、“关”、“复”、“启”等字的字形也同时发生了变化。</p>
<p>由于字体在各平台上差异较大，字体配置我就不写到 Vim 的参考配置中去了，只把如何选择和配置的方法写出来供你参考。</p>
<h4 id="2-4-5-内容小结"><a href="#2-4-5-内容小结" class="headerlink" title="2.4.5 内容小结"></a>2.4.5 内容小结</h4><p>最终的 Vim 配置文件可以在 GitHub 上找到：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/adah1972/geek_time_vim">https://github.com/adah1972/geek_time_vim</a></p>
<p>关于这个配置文件，我这里做个备注说明：主（master）分支可以用在类 Unix 平台上，windows 分支则用在 Windows 上。适用于今天这一讲的内容标签是 <code>l2-unix</code> 和 <code>l2-windows</code> 。</p>
<h2 id="03｜更多常用命令：应对稍复杂的编辑任务"><a href="#03｜更多常用命令：应对稍复杂的编辑任务" class="headerlink" title="03｜更多常用命令：应对稍复杂的编辑任务"></a>03｜更多常用命令：应对稍复杂的编辑任务</h2><h3 id="3-1-光标移动"><a href="#3-1-光标移动" class="headerlink" title="3.1 光标移动"></a>3.1 光标移动</h3><p>Vim 里的基本光标移动是通过 h、j、k、l 四个键实现的。之所以使用这四个键，是有历史原因的。你看一下 Bill Joy 开发 vi 时使用的键盘就明白了：这个键盘上没有独立的光标键，而四个光标符号直接标注在 H、J、K、L 四个字母按键上。</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/LearSieglerADM-3A终端键盘的排布（图片源自维基百科）.png" alt="LearSieglerADM-3A终端键盘的排布（图片源自维基百科）"></p>
<p>当然，除了历史原因外，这四个键一直使用至今，还是有其合理性的。它们都处于打字机的本位排（home row）上，这样打字的时候，手指基本不用移动就可以敲击到。</p>
<p>顺便提一句，你有没有注意到 ADM-3A 键盘上的 Esc 键在今天 Tab 的位置？在 Bill Joy 决定使用 Esc 来退出插入模式的时候，Esc 在键盘上的位置还没像今天那样跑到遥远的左上角去……</p>
<p>Vim 跳转到行首的命令是 0，跳转到行尾的命令是 $，它们与 <code>&lt;Home&gt;</code> 和 <code>&lt;End&gt;</code> 的区别可以参考帮助：<a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/motion.html#%3CHome%3E"><code>:help &lt;Home&gt;</code></a> 。此外，我们也有 ^，用来跳转到行首的第一个非空白字符。</p>
<p>对于一次移动超过一个字符的情况，Vim 支持使用 b/w 和 B/W，来进行以单词为单位的跳转。它们的意思分别是 words Backward 和 Words forward，用来向后或向前跳转一个单词。小写和大写命令的区别在于，小写的跟编程语言里的标识符的规则相似，认为一个单词是由字母、数字、下划线组成的（不严格的说法），而大写的命令则认为非空格字符都是单词。</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/小写w和大写W的区别.gif" alt="小写w和大写W的区别"></p>
<p>根据单个字符来进行选择也很常见。比如，现在光标在 <code>if (frame-&gt;fr_child != NULL)</code> 第五个字符上，如果我们想要修改括号里的所有内容，需要仔细考虑 w 的选词规则，然后输入 <code>c5w</code> 吗？这样显然不够方便。</p>
<p>这种情况下，我们就需要使用 f（find）和 t（till）了。它们的作用都是找到下一个（如果在输入它们之前先输入数字 n 的话，那就是下面第 n 个）紧接着输入的字符。两者的区别是，f 会包含这个字符，而 t 不会包含这个字符。在上面的情况下，我们用 t 就可以了：<code>ct)</code> 就可以达到目的。如果需要反方向搜索的话，使用大写的 F 和 T 就可以。</p>
<p>对于写文字的情况，比如给开源项目写英文的 README，下面的光标移动键也会比较有用：</p>
<ul>
<li>( 和 ) 移到上一句和下一句</li>
<li>{ 和 } 移到上一段和下一段</li>
</ul>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/整句和整段的移动.gif" alt="整句和整段的移动"></p>
<p>在很多环境（特别是图形界面）里，Vim 支持使用 <code>&lt;C-Home&gt;</code> 和 <code>&lt;C-End&gt;</code> 跳转到文件的开头和结尾。如果遇到困难，则可以使用 vi 兼容的 gg 和 G 跳转到开头和结尾行（小区别：G 是跳转到最后一行的第一个字符，而不是最后一个字符）。</p>
<h3 id="3-2-文本修改"><a href="#3-2-文本修改" class="headerlink" title="3.2 文本修改"></a>3.2 文本修改</h3><p>Vim 中 c 和 d 配合方向键，可以对文本进行更改。本质上，我们可以认为 c（修改）的功能就是执行 d（删除）然后 i（插入）。在 Vim 里，一般的原则就是，常用的功能，按键应尽可能少。因此很多相近的功能在 Vim 里会有不同的按键。不仅如此，大写键也一般会重载一个相近但稍稍不同的含义：</p>
<ul>
<li>d 加动作来进行删除（dd 删除整行）；D 则相当于 d$，删除到行尾。</li>
<li>c 加动作来进行修改（cc 修改整行）；C 则相当于 c$，删除到行尾然后进入插入模式。</li>
<li>s 相当于 cl，删除一个字符然后进入插入模式；S 相当于 cc，替换整行的内容。</li>
<li>i 在当前字符前面进入插入模式；I 则相当于 ^i，把光标移到行首非空白字符上然后进入插入模式。</li>
<li>a 在当前字符后面进入插入模式；A 相当于 $a，把光标移到行尾然后进入插入模式。</li>
<li>o 在当前行下方插入一个新行，然后在这行进入插入模式；O 在当前行上方插入一个新行，然后在这行进入插入模式。</li>
<li>r 替换光标下的字符；R 则进入替换模式，每次按键（直到 <code>&lt;Esc&gt;</code>）替换一个字符。</li>
<li>u 撤销最近的一个修改动作；U 撤销当前行上的所有修改。</li>
</ul>
<h3 id="3-3-文本对象选择"><a href="#3-3-文本对象选择" class="headerlink" title="3.3 文本对象选择"></a>3.3 文本对象选择</h3><p>可以使用 c、d 加动作键对这个动作选定的文本块进行操作，也可以使用 v 加动作键来选定文本块（以便后续进行操作）。不过，还有几个动作只能在 c、d、v 这样命令之后用。</p>
<p>这些选择动作的基本附加键是 a 和 i。其中，a 可以简单理解为英文单词 a，表示选定后续动作要求的完整内容，而 i 可理解为英文单词 inner，代表后续动作要求的内容的“内部”。</p>
<p>具体的例子，假设有下面的文本内容：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">if (message == "sesame open")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>我们进一步假设光标停在“sesame”的“a”上，那么：</p>
<ul>
<li>dw（理解为 delete word）会删除 ame␣，结果是 if (message == “sesopen”)</li>
<li>diw（理解为 delete inside word）会删除 sesame，结果是 if (message == “ open”)</li>
<li>daw（理解为 delete a word）会删除 sesame␣，结果是 if (message == “open”)</li>
<li>diW 会删除 “sesame，结果是 if (message == open”)</li>
<li>daW 会删除 “sesame␣，结果是 if (message == open”)</li>
<li>di” 会删除 sesame open，结果是 if (message == “”)</li>
<li>da” 会删除 “sesame open”，结果是 if (message ==)</li>
<li>di( 或 di) 会删除 message == “sesame open”，结果是 if ()</li>
<li>da( 或 da) 会删除 (message == “sesame open”)，结果是 if␣</li>
</ul>
<p>上面演示了 a、i 和 w、双引号、圆括号搭配使用，这些对于任何语言的代码编辑都是非常有用的。实际上，可以搭配的还有更多：</p>
<ul>
<li>搭配 s（sentence）对句子进行操作——适合西文文本编辑</li>
<li>搭配 p（paragraph) 对段落进行操作——适合西文文本编辑，及带空行的代码编辑</li>
<li>搭配 t（tag）对 HTML/XML 标签进行操作——适合 HTML、XML 等语言的代码编辑</li>
<li>搭配 ` 和 ‘ 对这两种引号里的内容进行操作——适合使用这些引号的代码，如 shell 和 Python</li>
<li>搭配方括号（“[”和“]”）对方括号里的内容进行操作——适合各种语言（大部分都会用到方括号吧）</li>
<li>搭配花括号（“{”和“}”）对花括号里的内容进行操作——适合类 C 的语言</li>
<li>搭配角括号（“&lt;”和“&gt;”）对角括号里的内容进行操作——适合 C++ 的模板代码</li>
</ul>
<p>再进一步，在 a 和 i 前可以加上数字，对多个（层）文本对象进行操作。下面图中是一个示例：</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/修改往上第2层花括号内的所有内容.gif" alt="修改往上第2层花括号内的所有内容"></p>
<h3 id="3-4-更快地移动"><a href="#3-4-更快地移动" class="headerlink" title="3.4 更快地移动"></a>3.4 更快地移动</h3><p>可以使用 <code>&lt;PageUp&gt;</code> 和 <code>&lt;PageDown&gt;</code> 来翻页，但 Vim 更传统的用法是 <code>&lt;C-B&gt;</code> 和 <code>&lt;C-F&gt;</code>，分别代表 Backward 和 Forward。</p>
<p>除了翻页，Vim 里还能翻半页，有时也许这种方式更方便，需要的键是 <code>&lt;C-U&gt;</code> 和 <code>&lt;C-D&gt;</code>，Up 和 Down。</p>
<p>如果你知道出错位置的行号，那你可以用数字加 G 来跳转到指定行。类似地，你可以用数字加 | 来跳转到指定列。这在调试代码的时候非常有用，尤其适合进行自动化。</p>
<p>下图中展示了 iTerm2 中<a target="_blank" rel="noopener" href="https://www.iterm2.com/documentation-captured-output.html">捕获输出</a>并执行 Vim 命令的过程（用 vim -c ‘normal 5G36|’ 来执行跳转到出错位置第 5 行第 36 列）：</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/捕获错误信息并自动通过Vim命令行来跳转到指定位置.gif" alt="捕获错误信息并自动通过Vim命令行来跳转到指定位置"></p>
<p>（如果你用 iTerm2 并对这个功能感兴趣，我设置的正则表达式是 <code>^([_a-zA-Z0-9+/.-]+):([0-9]+):([0-9]+): (?:fatal error|error|warning|note):</code>，捕获输出后执行的命令是 <code>echo "vim -c 'normal \2G\3|' \1"</code>。）</p>
<p>你只关心当前屏幕的话，可以快速移动光标到屏幕的顶部、中间和底部：用 H（High）、M（Middle）和 L（Low）就可以做到。</p>
<p>顺便提一句，vimrc_example 有一个设定，我不太喜欢：它会设 set scrolloff=5，导致只要屏幕能滚动，光标就移不到最上面的 4 行和最下面的 4 行里，因为一移进去屏幕就会自动滚动。这同样也会导致 H 和 L 的功能发生变化：本来是移动光标到屏幕的最上面和最下面，现在则变成了移动到上数第 6 行和下数第 6 行，和没有这个设定时的 6H 与 6L 一样了。所以我一般会在 Vim 配置文件里设置 set scrolloff=1（你也可以考虑设成 0），减少这个设置的干扰。</p>
<p>只要光标还在屏幕上，你也可以滚动屏幕而不移动光标（不像某些其他编辑器，Vim 不允许光标在当前屏幕以外）。需要的按键是 <code>&lt;C-E&gt;</code> 和 <code>&lt;C-Y&gt;</code>。</p>
<p>另外一种可能更实用的滚动屏幕方式是，把当前行“滚动”到屏幕的顶部、中部或底部。Vim 里的对应按键是 zt、zz 和 zb。和上面的几个滚动相关的按键一样，它们同样受选项 scrolloff 的影响。</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/光标移动和屏幕滚动.gif" alt="光标移动和屏幕滚动"></p>
<h3 id="3-5-重复，重复，再重复"><a href="#3-5-重复，重复，再重复" class="headerlink" title="3.5 重复，重复，再重复"></a>3.5 重复，重复，再重复</h3><p>Vim 对很多简单操作已经定义了重复键：</p>
<ul>
<li>; 重复最近的字符查找（f、t 等）操作</li>
<li>, 重复最近的字符查找操作，反方向</li>
<li>n 重复最近的字符串查找操作（/ 和 ?）</li>
<li>N 重复最近的字符串查找操作（/ 和 ?），反方向</li>
<li>. 重复执行最近的修改操作</li>
</ul>
<h2 id="04｜初步定制：让你的-Vim-更顺手"><a href="#04｜初步定制：让你的-Vim-更顺手" class="headerlink" title="04｜初步定制：让你的 Vim 更顺手"></a>04｜初步定制：让你的 Vim 更顺手</h2><h3 id="4-1-Vim-的目录结构"><a href="#4-1-Vim-的目录结构" class="headerlink" title="4.1 Vim 的目录结构"></a>4.1 Vim 的目录结构</h3><p>Vim 的工作环境是由运行支持文件来设定的。Vim 比较有意思的一点的是，虽然运行支持文件是在 Vim 的安装目录下，但用户自己是可以“克隆”这个目录结构的。也就是说，你自己目录下的用户配置，到你深度定制的时候，也有相似的目录结构。</p>
<h3 id="4-2-安装目录下的运行支持文件"><a href="#4-2-安装目录下的运行支持文件" class="headerlink" title="4.2 安装目录下的运行支持文件"></a>4.2 安装目录下的运行支持文件</h3><p>Vim 的运行支持文件在不同的平台上有着相似的目录结构。以 Vim 8.2 为例，它们的标准安装位置分别在：</p>
<ul>
<li>大部分 Unix 下面：/usr/share/vim/vim82</li>
<li>macOS Homebrew 下：/usr/local/opt/macvim/MacVim.app/Contents/Resources/vim/runtime</li>
<li>Windows 下：C:\Program Files (x86)\Vim\vim82</li>
</ul>
<p>最常用的子目录：</p>
<ul>
<li>syntax：Vim 的语法加亮文件</li>
<li>doc：Vim 的帮助文件</li>
<li>colors：Vim 的配色方案</li>
<li>plugin：Vim 的“插件”，即用来增强 Vim 功能的工具</li>
</ul>
<p>这里面的文件去掉“.vim”后缀后，就是文件类型的名字，你可以用类似 <code>:setfiletype java</code> 这样的命令来设置文件的类型，从而进行语法加亮。</p>
<p>在图形界面的 Vim 里，你可以通过“语法 &gt; 在菜单中显示文件类型”（“Syntax &gt; Show File Types in Menu”）来展示 Vim 的所有文件类型，然后可以选择某一类型来对当前文件进行设置。这儿的菜单项，跟 syntax 目录下的文件就基本是一一对应的了。</p>
<p>在菜单中显示文件类型这个额外的步骤，可能是因为很久很久以前，加载所有文件类型的菜单是一个耗时的操作吧。在 menu.vim 里，目前有这样的代码：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token comment">" Skip setting up the individual syntax selection menus unless</span>
<span class="token comment">" do_syntax_sel_menu is defined (it takes quite a bit of time).</span>
<span class="token keyword">if</span> <span class="token function">exists</span><span class="token punctuation">(</span><span class="token string">"do_syntax_sel_menu"</span><span class="token punctuation">)</span>
  <span class="token keyword">runtime</span><span class="token operator">!</span> synmenu<span class="token operator">.</span><span class="token keyword">vim</span>
<span class="token keyword">else</span>
  …
<span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不知道这段注释是什么年代加上的……但显然，我们的电脑已经不会再在乎加载几百个菜单项所占的时间了。即使我不怎么用菜单，我也找不出不直接展示这个菜单的理由；我可不想在需要使用的时候再多点一次鼠标。</p>
<p>所以，我会在我的 vimrc 文件里写上：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">let</span> do_syntax_sel_menu <span class="token operator">=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>同理，我会加载其他一些可能会被 Vim 延迟加载的菜单，减少需要在菜单上点击的次数：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">let</span> do_no_lazyload_menus <span class="token operator">=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>我们用“:help”命令查看的帮助文件就放在 doc 目录下。我们可以用菜单“编辑 &gt; 配色方案”（“Edit &gt; Color Scheme”）浏览配色方案，相应的文件就在 colors 目录下。</p>
<p>在 plugin 目录下的系统内置插件不多，我们下面就快速讲解一下：</p>
<ul>
<li>getscriptPlugin：获得最新的 Vim 脚本的插件（在目前广泛使用 Git 的年代，这个插件过时了，我们不讲）</li>
<li>gzip：编辑 .gz 压缩文件（能在编辑后缀为 .gz 的文件时自动解压和压缩，你会感觉不到这个文件是压缩的）</li>
<li>logiPat：模式匹配的逻辑运算符（允许以逻辑运算、而非标准正则表达式的方式来写模式匹配表达式）</li>
<li>manpager：使用 Vim 来查看 man 帮助（强烈建议试一下，记得使用 Vim 的跳转键C-] 和 C-T）</li>
<li>matchparen：对括号进行高亮匹配（现代编辑器基本都有类似的功能）</li>
<li>netrwPlugin：从网络上编辑文件和浏览（远程）目录（支持多种常见协议如 ftp 和scp，可直接打开目录来选择文件）</li>
<li>rrhelper：用于支持 —remote-wait 编辑（Vim 的多服务器会用到这一功能）</li>
<li>spellfile：在拼写文件缺失时自动下载（Vim 一般只安装了英文的拼写文件）</li>
<li>tarPlugin：编辑（压缩的）tar 文件（注意，和 gzip 情况不同，这儿不支持写入）</li>
<li>tohtml：把语法加亮的结果转成 HTML（自己打开个文件，输入命令“:TOhtml”就知道效果了）</li>
<li>vimballPlugin：创建和解开 .vba 文件（这个目前也略过时了，我们不讲）</li>
<li>zipPlugin：编辑 zip 文件（和 tar 文件不同，zip 文件可支持写入）</li>
</ul>
<p>除了 rrhelper 和 spellfile 属于功能支持插件，没有自己的帮助页面，其他功能都可以使用“:help”命令来查看帮助。查看帮助时，插件名称中的“Plugin”后缀需要去掉：查看 zip 文件编辑的帮助时，应当使用“<a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/pi_zip.html#zip">:help zip</a>”而不是“:help zipPlugin”。</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/浏览远程目录，打开一个tar.gz文件.gif" alt="浏览远程目录，打开一个tar.gz文件"></p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/使用Vim查看man帮助.gif" alt="使用Vim查看man帮助"></p>
<h3 id="4-3-用户的-Vim-配置目录"><a href="#4-3-用户的-Vim-配置目录" class="headerlink" title="4.3 用户的 Vim 配置目录"></a>4.3 用户的 Vim 配置目录</h3><p>Vim 的安装目录你是不应该去修改的。首先，你可能没有权限去修改这个目录；其次，即使你有修改权限，这个目录会在 Vim 升级时被覆盖，你做的修改也会丢失。用户自己的配置应当放在自己的目录下，这也就是用户自己的主目录下的 Vim 配置目录（Unix 下的 .vim，Windows 下的 vimfiles）。这个目录应和 Vim 安装目录下的运行支持文件目录有相同的结构，但下面的子目录你在需要修改 Vim 的相关行为时才有必要创建。如果一个同名文件出现用户自己的 Vim 配置目录里和 Vim 的安装目录里，用户的文件优先。</p>
<h3 id="4-4-Vim-8-新功能"><a href="#4-4-Vim-8-新功能" class="headerlink" title="4.4 Vim 8 新功能"></a>4.4 Vim 8 新功能</h3><p>站在我个人的角度看，从 Vim 7.4 到 Vim 8.2，最大的新功能是：</p>
<ul>
<li>Vim 软件包的支持（“<a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/repeat.html#packages">:help packages</a>”）</li>
<li>异步任务支持（“<a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/channel.html">:help channel</a>”、“<a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/channel.html#job">:help job</a>”和“<a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/eval.html#timers">:helptimers</a>”）</li>
<li>终端支持（“<a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/terminal.html">:help terminal</a>”）</li>
</ul>
<h3 id="4-5-Vim-软件包"><a href="#4-5-Vim-软件包" class="headerlink" title="4.5 Vim 软件包"></a>4.5 Vim 软件包</h3><p>Vim 的目录结构有点传统 Unix 式：一个功能用到的文件可能会分散在多个目录下。，一个 Vim 的插件（严格来讲，应该叫包）通常也会分散在多个目录下：</p>
<ul>
<li>插件的主体通常在 plugin 目录下</li>
<li>插件的帮助文件在 doc 目录下</li>
<li>有些插件只对某些文件类型有效，会有文件放在 ftplugin 目录下</li>
<li>有些插件有自己的文件类型检测规则，会有文件放在 ftdetect 目录下</li>
<li>有些插件有特殊的语法加亮，会有文件放在 syntax 目录下</li>
<li>……</li>
</ul>
<p>以前我们安装插件，一般是一次性安装后就不管了。安装过程基本上就是到 .vim 目录（Windows 上是 vimfiles 目录）下，解出压缩包的内容，然后执行 vim -c ‘helptags doc|q’ 生成帮助文件的索引。到了“互联网式更新”的年代，这种方式就显得落伍了。尤其糟糕的地方在于，它是按文件类型来组织目录的，而不是按相关性，这就没法用 Git 来管理了。</p>
<p>Vim 上后来就出现了一些包管理器，它们的基本模式都是相通的：每个包有自己的目录，然后这些目录会被加到 Vim 的运行时路径（runtimepath）选项里。最早的 runtimepath 较为简单，在 Unix 上缺省为：</p>
<ul>
<li>$HOME/.vim,</li>
<li>$VIM/vimfiles,</li>
<li>$VIMRUNTIME,</li>
<li>$VIM/vimfiles/after,</li>
<li>$HOME/.vim/after</li>
</ul>
<p>而在有了包管理器之后，runtimepath 就会非常复杂，每个包都会增加一个自己的目录进去。但是，好处也是非常明显的，包的管理变得非常方便。从 Vim 8 开始，Vim 官方也采用了类似的体系。Vim 会在用户的配置目录（Unix 下是 $HOME/.vim ，Windows 下是 $HOME/vimfiles ）下识别名字叫 pack 的目录，并在这个目录的子目录的 start 和 opt 目录下寻找包的目录。</p>
<p>听着有点绕吧？我们看一个实际的 Vim 配置目录的结构就清楚了：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">.
├── colors
├── doc
├── pack
│   ├── minpac
│   │   ├── opt
│   │   │   ├── minpac
│   │   │   ├── vim-airline
│   │   │   └── vimcdoc
│   │   └── start
│   │       ├── VimExplorer
│   │       ├── asyncrun.vim
│   │       ├── fzf.vim
│   │       ├── gruvbox
│   │       ├── killersheep
│   │       ├── nerdcommenter
│   │       ├── nerdtree
│   │       ├── tagbar
│   │       ├── undotree
│   │       ├── vim-fugitive
│   │       ├── vim-matrix-screensaver
│   │       ├── vim-rainbow
│   │       ├── vim-repeat
│   │       ├── vim-rhubarb
│   │       └── vim-surround
│   └── my
│       ├── opt
│       │   ├── YouCompleteMe
│       │   ├── ale
│       │   ├── clang_complete
│       │   ├── cvsmenu
│       │   └── syntastic
│       └── start
│           ├── vim-gitgutter
│           └── ycmconf
├── plugin
├── syntax
└── undodir<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到，pack 目录下有 minpac 和 my 两个子目录（这些名字 Vim 不关心），每个目录下面又有 opt 和 start 两个子目录，再下面就是每个包自己的目录了，里面又可以有自己的一套 colors、doc、plugin 这样的子目录，这样就方便管理了。Vim 8 在启动时会加载所有 pack/*/start 下面的包，而用户可以用 <code>:packadd</code> 命令来加载某个 opt 目录下的包，如 <code>:packadd vimcdoc</code> 命令可加载 vimcdoc 包，来显示中文帮助信息。</p>
<p>有了这样的目录结构，用户要自己安装、管理包就方便多了。不过，我们还是推荐使用一个包管理器。包管理器可以带来下面的好处：</p>
<ul>
<li>根据文本的配置（一般写在 vimrc 配置文件里）决定要安装哪些包</li>
<li>自动化安装、升级和卸载，包括帮助文件的索引生成</li>
</ul>
<p>在我们这门课程里，我会使用 minpac，一个利用 Vim 8 功能的小巧的包管理器。如果你已经在使用其他包管理器，我接下来讲的两个小节你可以考虑跳过。</p>
<h3 id="4-6-安装-minpac"><a href="#4-6-安装-minpac" class="headerlink" title="4.6 安装 minpac"></a>4.6 安装 minpac</h3><p>根据 minpac 网页上的说明，我们在 Windows 下可以使用下面的命令：</p>
<pre class="line-numbers language-bat" data-language="bat"><code class="language-bat">cd /d %USERPROFILE%
git clone https://github.com/k-takata/minpac.git ^
    vimfiles\pack\minpac\opt\minpac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在 Linux 和 macOS 下则可以使用下面的命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/k-takata/minpac.git <span class="token punctuation">\</span>
    ~/.vim/pack/minpac/opt/minpac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>然后，我们在 vimrc 配置文件中加入以下内容（先不用理解其含义）：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">if</span> <span class="token function">exists</span><span class="token punctuation">(</span><span class="token string">'*minpac#init'</span><span class="token punctuation">)</span>
  <span class="token comment">" Minpac is loaded.</span>
  <span class="token keyword">call</span> minpac#<span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">call</span> minpac#<span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'k-takata/minpac'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'opt'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token comment">" Other plugins</span>
<span class="token keyword">endif</span>

<span class="token keyword">if</span> <span class="token function">has</span><span class="token punctuation">(</span><span class="token string">'eval'</span><span class="token punctuation">)</span>
  <span class="token comment">" Minpac commands</span>
  command<span class="token operator">!</span> PackUpdate packadd minpac | <span class="token keyword">source</span> $MYVIMRC | <span class="token keyword">call</span> minpac#<span class="token function">update</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">'do'</span><span class="token punctuation">:</span> <span class="token string">'call minpac#status()'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
  command<span class="token operator">!</span> PackClean  packadd minpac | <span class="token keyword">source</span> $MYVIMRC | <span class="token keyword">call</span> minpac#<span class="token function">clean</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  command<span class="token operator">!</span> PackStatus packadd minpac | <span class="token keyword">source</span> $MYVIMRC | <span class="token keyword">call</span> minpac#<span class="token function">status</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>存盘、重启 Vim 之后，我们就有了三个新的命令，可以用来更新（安装）包、清理包和检查当前包的状态。</p>
<h3 id="4-7-通过-minpac-安装扩展包"><a href="#4-7-通过-minpac-安装扩展包" class="headerlink" title="4.7 通过 minpac 安装扩展包"></a>4.7 通过 minpac 安装扩展包</h3><p>下面我们就来试验一下通过 minpac 来安装扩展包。我们在“Other plugins”那行下面加入以下内容：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">call</span> minpac#<span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'tpope/vim-eunuch'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>保存文件，然后我们使用 <code>:PackUpdate</code> 命令。略微等待之后，我们就能看到类似下面的界面：</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/插件安装之后的状态界面.png" alt="插件安装之后的状态界面"></p>
<p>这就说明安装成功了。我们可以按 <code>q</code> 来退出这个状态窗口。我们也可以使用 <code>:PackStatus</code> 来重新打开这个状态窗口。要删除一个插件，在 vimrc 中删除对应的那行，保存，然后使用 <code>:PackClean</code> 命令就可以了。</p>
<h3 id="4-8-最近使用的文件"><a href="#4-8-最近使用的文件" class="headerlink" title="4.8 最近使用的文件"></a>4.8 最近使用的文件</h3><p>安装好 Vim 软件包之后，我们进一步来实现一个小功能。</p>
<p>Vim 的缺省安装缺了一个很多编辑器都有的功能：最近使用的文件。</p>
<p>我们就把这个功能补上吧。你只需要按照上一节的步骤安装 yegappan/mru 包就可以了（MRU 代表 most recently used）。安装完之后，重新打开 vimrc 文件，你就可以在图形界面里看到下面的菜单了：</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/最近文件的菜单.png" alt="最近文件的菜单.png"></p>
<p>估计你很可能会问：如果是远程连接，没有图形界面怎么办？</p>
<p>我们仍可以在文本界面上唤起菜单，虽然美观程度会差点。你需要在 vimrc 配置文件中加入以下内容（同样，我们暂时先不用去理解其意义）：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token string">'gui_running'</span><span class="token punctuation">)</span>
  <span class="token comment">" 设置文本菜单</span>
  <span class="token keyword">if</span> <span class="token function">has</span><span class="token punctuation">(</span><span class="token string">'wildmenu'</span><span class="token punctuation">)</span>
    <span class="token keyword">set</span> <span class="token builtin">wildmenu</span>
    <span class="token keyword">set</span> <span class="token builtin">cpoptions</span><span class="token operator">-=</span><span class="token operator">&lt;</span>
    <span class="token keyword">set</span> <span class="token builtin">wildcharm</span><span class="token operator">=</span><span class="token operator">&lt;</span>C<span class="token operator">-</span>Z<span class="token operator">&gt;</span>
    nnoremap <span class="token operator">&lt;</span>F10<span class="token operator">&gt;</span>      <span class="token punctuation">:</span><span class="token keyword">emenu</span> <span class="token operator">&lt;</span>C<span class="token operator">-</span>Z<span class="token operator">&gt;</span>
    inoremap <span class="token operator">&lt;</span>F10<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>C<span class="token operator">-</span>O<span class="token operator">&gt;</span><span class="token punctuation">:</span><span class="token keyword">emenu</span> <span class="token operator">&lt;</span>C<span class="token operator">-</span>Z<span class="token operator">&gt;</span>
  <span class="token keyword">endif</span>
<span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在增加上面的配置之后，你就可以使用键 <code>&lt;F10&gt;</code> （当然你也可以换用其他键）加 <code>&lt;Tab&gt;</code> 来唤起 Vim 的文本菜单了。如下图所示：</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/文本菜单的使用.gif" alt="文本菜单的使用"></p>
<h2 id="05｜多文件打开与缓冲区：复制粘贴的正确姿势"><a href="#05｜多文件打开与缓冲区：复制粘贴的正确姿势" class="headerlink" title="05｜多文件打开与缓冲区：复制粘贴的正确姿势"></a>05｜多文件打开与缓冲区：复制粘贴的正确姿势</h2><p>今天，我们就来细细讨论一下这个话题，什么是编辑多个文件的正确姿势。</p>
<p>先来假设一个简单的使用场景，我们现在需要在某个目录下的所有 .cpp 和 .h 文件开头贴入一段版权声明，该如何操作？</p>
<h3 id="5-1-单文件的打开方式"><a href="#5-1-单文件的打开方式" class="headerlink" title="5.1 单文件的打开方式"></a>5.1 单文件的打开方式</h3><h4 id="5-1-1-图形界面"><a href="#5-1-1-图形界面" class="headerlink" title="5.1.1 图形界面"></a>5.1.1 图形界面</h4><p>使用图形界面的话，我们可以在操作系统的资源管理器里进入到合适的目录，然后逐个使用 Vim 来打开文件。我们可以使用右键菜单（“Edit with Vim”、“Open with…”等），也可以直接把文件拖拽到 Vim 里。使用“文件 &gt; 打开”（File &gt; Open）菜单当然也是一种选择，但这需要你记住上次打开到第几个文件，并不如使用资源管理器方便。</p>
<p>使用这几种编辑方式的话，你可以把需要粘贴的内容放到操作系统的剪贴板里，然后在图形界面的 Vim 里用以下方法之一粘贴进去（当然，如果光标不在开头的话，先用鼠标或用 gg 命令跳转到开头）：</p>
<ul>
<li>正常模式 Vim 命令 “+P（意义我们后面再解释）</li>
<li>快捷键 <code>&lt;D-V&gt;</code>（提醒：这是我们对 ⌘V 的标记方式；仅适用于 macOS）或 <code>&lt;SInsert&gt;</code>（PC 键盘）</li>
<li>鼠标右键加“粘贴”（Paste）</li>
<li>菜单“编辑 &gt; 粘贴”（Edit &gt; Paste）</li>
</ul>
<p>注意，如果你通常使用 Ctrl-V 键粘贴的话，这个快捷键在 Vim 里并不适用。即使你使用的是图形界面的 Vim 也是如此，因为这个键在 Vim 里有其他用途。顺便说一句，这个键在 Unix 终端上也一样是不能用作粘贴的。</p>
<h4 id="5-1-2-终端-Vim"><a href="#5-1-2-终端-Vim" class="headerlink" title="5.1.2 终端 Vim"></a>5.1.2 终端 Vim</h4><p>如果直接把图形界面下的基本步骤，翻译成终端 Vim（非图形界面）的用法的话，应该是这样子的：</p>
<ol>
<li>在终端里进入到目标目录下</li>
<li>使用 vim 文件名 来逐一打开需要编辑的文件</li>
<li>如果光标不在开头的话，用鼠标或 gg 命令跳转到开头</li>
<li>使用命令 i 进入插入模式</li>
<li>使用终端窗口的粘贴命令或快捷键（如 <code>&lt;S-Insert&gt;</code>）来粘贴内容</li>
<li>按 <code>&lt;Esc&gt;</code> 回到正常模式并用 ZZ 存盘退出</li>
</ol>
<p>或者，我们还可以采用下面的不退出 Vim 的处理方法：</p>
<ul>
<li>打开文件使用 :e 文件名；可以使用 <code>&lt;C-D&gt;</code> 来查看有哪些文件，及用 <code>&lt;Tab&gt;</code> 进行自动完成</li>
<li>存盘使用 :w</li>
</ul>
<p>但是如果粘贴的内容含缩进、而 Vim 又不够新的话，我们还会有特殊的麻烦。请继续往下看。</p>
<h4 id="5-1-3-Vim-老版本的特殊处理"><a href="#5-1-3-Vim-老版本的特殊处理" class="headerlink" title="5.1.3 Vim 老版本的特殊处理"></a>5.1.3 Vim 老版本的特殊处理</h4><p><img src="/images/《Vim实用技巧必知必会》学习笔记/老版本Vim下直接粘贴可能出现的错误结果.png" alt="老版本Vim下直接粘贴可能出现的错误结果"></p>
<p>上面的图片展示了 Vim 用户可能遇到的一种错误情况。这是因为对于终端 Vim 来说，一般而言，它是没法分辨用户输入和粘贴的。因此，在粘贴内容时，Vim 的很多功能，特别是和自动缩进相关的，就会和输入打架，导致最后的结果不对。</p>
<p>要解决这个问题，你就得让 Vim 知道，你到底是在输入还是在粘贴。Vim 有一个 paste 选项，就是用来切换输入 / 粘贴状态的。如果这个选项打开的话（:set paste），Vim 就认为你在粘贴，智能缩进、制表符转换等功能就不会修改粘贴的内容。</p>
<p>不过，手工设置该选项（及事后用 set nopaste 取消）是件烦人的事。所幸 xterm 里有一个“括号粘贴模式”（bracketed paste mode）可以帮 Vim 判断目前是输入还是粘贴。这个模式启用后，终端在发送剪贴板的内容之前和之后都会发送特殊的控制字符序列，来通知应用程序进行特殊的处理。</p>
<p>启用括号粘贴模式需要向 xterm 发送启用序列 <code>&lt;Esc&gt;[?2004h</code>，关闭括号粘贴模式需要向 xterm 发送关闭序列 <code>&lt;Esc&gt;[?2004l</code>；在启用了括号粘贴模式后，xterm 在发送剪贴板内容时会在前后分别加上开始粘贴序列 <code>&lt;Esc&gt;[200~</code> 和结束粘贴序列 <code>&lt;Esc&gt;[201~</code>。</p>
<p>Vim 8.0.0210 开始引入了对括号粘贴模式的支持。在兼容 xterm 的终端里进行粘贴时，你不再需要使用 paste 这个选项了。更棒的是，目前你甚至都不需要进入插入模式就可以粘贴了。</p>
<p>如果你使用的是 Vim 8.0.0210 之前的版本的话，那我们至少也可以通过代码来使得手工设置 paste 选项变得不必要。你可以在 vimrc 里加入下面的代码：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token string">'patch-8.0.210'</span><span class="token punctuation">)</span>
  <span class="token comment">" 进入插入模式时启用括号粘贴模式</span>
  <span class="token keyword">let</span> &amp;<span class="token builtin">t_SI</span> <span class="token operator">.=</span> <span class="token string">"\&lt;Esc&gt;[?2004h"</span>
  <span class="token comment">" 退出插入模式时停用括号粘贴模式</span>
  <span class="token keyword">let</span> &amp;<span class="token builtin">t_EI</span> <span class="token operator">.=</span> <span class="token string">"\&lt;Esc&gt;[?2004l"</span>
  <span class="token comment">" 见到 &lt;Esc&gt;[200~ 就调用 XTermPasteBegin</span>
  inoremap <span class="token operator">&lt;</span>special<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>expr<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>Esc<span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token number">200</span>~ <span class="token function">XTermPasteBegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token keyword">function</span><span class="token operator">!</span> <span class="token function">XTermPasteBegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">" 设置使用 &lt;Esc&gt;[201~ 关闭粘贴模式</span>
    <span class="token keyword">set</span> <span class="token builtin">pastetoggle</span><span class="token operator">=</span><span class="token operator">&lt;</span>Esc<span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token number">201</span>~
    <span class="token comment">" 开启粘贴模式</span>
    <span class="token keyword">set</span> <span class="token builtin">paste</span>
    <span class="token keyword">return</span> <span class="token string">""</span>
  <span class="token keyword">endfunction</span>
<span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="5-1-4-“已经存在交换文件！”"><a href="#5-1-4-“已经存在交换文件！”" class="headerlink" title="5.1.4 “已经存在交换文件！”"></a>5.1.4 “已经存在交换文件！”</h4><p>对每个文件单独使用一个 Vim 会话来编辑，很容易出现冲突的情况，所以你迟早会遇到“已经存在交换文件！”（Swap file “…” already exists!）的错误提示。出现这个提示，有两种可能的原因：</p>
<ol>
<li>你上次编辑这个文件时，发生了意外崩溃。</li>
<li>你已经在使用另外一个 Vim 会话编辑这个文件了。</li>
</ol>
<p>原因不同，我们处理的策略自然也不相同。当进程 ID（process ID）后面没有“STILL RUNNING”这样的字样时，那就是情况 1；否则，就是情况 2 了。</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/上次编辑这个文件时发生了意外崩溃的错误提示.png" alt="上次编辑这个文件时发生了意外崩溃的错误提示"></p>
<p>上图中没有“STILL RUNNING”的字样，说明是情况 1。这时你需要按 r 来恢复上次的编辑状态——Vim 支持即使在你没有存盘的情况下仍然保存你的编辑状态，因而这种方法可以恢复你上次没有存盘的内容。</p>
<p>需要注意的是，在恢复之后，Vim 仍然不会删除崩溃时保留下来的那个交换文件。因此，在确定内容无误、保存文件之后，你需要重新再打开文件，并按 d 键把交换文件删除。当然，如果你确定目前保存的文件版本就是你想要的，也可以直接按 d 把交换文件删除、重新编辑文件。</p>
<p>反过来，如果你已经在另一个 Vim 会话里编辑文件的话，我们就会在进程 ID 后面看到“STILL RUNNING”的字样；同时，Vim 界面上也没有了删除（Delete）交换文件这一选项。</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/文件正在其他地方被编辑的错误提示.png" alt="文件正在其他地方被编辑的错误提示"></p>
<p>这时，大部分情况侠我们应当使用 q 或 a（绝大部分情况下没有区别）放弃编辑，并找到目前已经打开的 Vim 窗口，从那里继续。少数情况下，我们只是要查看文件，那也可以选择 o 只读打开文件。需要使用 e 强行编辑的情况很少，需要非常谨慎——比如，你确认另外有 Vim 会话，但里面不会去做任何修改，这是我目前想得出来的唯一的合理需求。</p>
<p>如果我们使用图形界面 Vim 8 的话，Vim 支持在文件已经打开时自动切换到已经打开的 Vim 窗口上。这个功能在文件处于一个不活跃的标签页（下一讲会讨论标签页支持）时特别有用，因为 Vim 能把这个标签页自动切到最前面。不过，这个功能不是默认激活的，我们需要在 vimrc 中加入以下内容：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">if</span> v<span class="token punctuation">:</span><span class="token keyword">version</span> <span class="token operator">&gt;=</span> <span class="token number">800</span>
  packadd<span class="token operator">!</span> editexisting
<span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="5-2-多文件的打开方式"><a href="#5-2-多文件的打开方式" class="headerlink" title="5.2 多文件的打开方式"></a>5.2 多文件的打开方式</h3><p>首先，我们需要知道，Vim 支持一次性打开多个文件，你只需要在命令行上写出多个文件即可，或者使用通配符。比如，就我们刚才所说的编辑场景，我们可以使用 <code>vim *.cpp *.h</code> 。</p>
<p>有可能让你吃惊的是，输入这个命令之后，Vim 只打开了一个文件，那就是所有文件中的第一个。</p>
<p>原来，为了确保在配置较差的环境里仍然能够正常工作，Vim 绝对不会不必要地消耗内存，包括打开不必要立即打开的文件。所以在上面的命令后，Vim 建立了一个文件列表，并且暂时只打开其中的第一个文件。接下来，用户可以决定，要编辑哪个文件，或者查看列表，或者提前退出，等等。</p>
<p>为此，Vim 提供了以下命令：</p>
<ul>
<li>:args：可以显示“参数”，即需要编辑的多个文件的列表</li>
<li>:args 文件名：使用新的文件名替换参数列表</li>
<li>:next（可缩写为 :n）：打开下一个文件；如当前文件修改（未存盘）则会报错中止，但如果命令后面加 ! 则会放弃修改内容，其他命令也类似</li>
<li>:Next（缩写 :N）或 :previous（缩写 :prev）：打开上一个文件</li>
<li>:first 或 :rewind：回到列表中的第一个文件</li>
<li>:last：打开列表中的最后一个文件</li>
</ul>
<p>使用这些命令，我们的工作流当然就会发生变化了：</p>
<ol>
<li>在终端里进入到目标目录下</li>
<li>使用 <code>vim *.cpp *.h</code> 或 <code>gvim *.cpp *.h</code> 来打开需要编辑的文件</li>
<li>对于第一个文件，使用之前的方法贴入所需的文本</li>
<li>使用 V 进入行选择的可视模式，移动光标选中所需的文本，然后使用 y 复制选中的各行</li>
<li>执行命令 :set autowrite，告诉 Vim 在切换文件时自动存盘</li>
<li>执行命令 :n|normal ggP，切换到下一个文件并执行正常模式命令 ggP，跳转到文件开头并贴入文本</li>
<li>确认修改无误后，键入 :、上箭头和回车，重复执行上面的命令</li>
<li>待 Vim 报错说已经在最后一个文件里，使用 :w 存盘，或 :wq（抑或更快的 ZZ）存盘退出</li>
</ol>
<p>注意，第 6 步可以拆成 :n 和 ggP 两步，但文件数量较多时，反复手工敲 ggP 也挺累的。因此，我这儿使用了 normal 命令，在命令行模式下执行正常模式命令，下面就可以直接 重复切换命令加粘贴命令，我们的编辑效率也得以大大提升。</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/第4步到第7步的演示（注意倒数第二行的变化）.gif" alt="第4步到第7步的演示（注意倒数第二行的变化）"></p>
<p>另外，Vim 还能解决一个 shell 相关的不一致性问题。如果我们要编辑的文件除了当前目录下的，还有所有子目录下的，在大部分 shell 下，包括 Linux 上缺省的 Bash，我们需要使用“<code>*.cpp *.h **/*.cpp **/*.h</code>”来挑选这些文件，重复、麻烦。Vim 在此处采用了类似于 Zsh 的简化语法，“**”也包含了当前目录。这样，我们只需把上面第 2 步改成下面这样即可：</p>
<ul>
<li>键入 vim 进入 Vim，然后使用 <code>:args **/*.cpp **/*.h</code> 来打开需要编辑的文件</li>
</ul>
<h3 id="5-3-缓冲区的管理和切换"><a href="#5-3-缓冲区的管理和切换" class="headerlink" title="5.3 缓冲区的管理和切换"></a>5.3 缓冲区的管理和切换</h3><p>跟多文件相关又略微不同的一个概念是缓冲区（buffer）。它是 Vim 里的一个基本概念，和今天讲的很多其他内容有相关性和相似性。</p>
<p>Vim 里会对每一个已打开或要打开的文件创建一个缓冲区，这个缓冲区就是文件在 Vim 中的映射。在多文件编辑的时候你也会有同样数量的缓冲区。不过，缓冲区的数量常常会更高，因为你用 :e 等命令打开的文件不会改变“命令行参数”（只被命令行或 :args 命令修改），但同样会增加缓冲区的数量。</p>
<p>此外，:args 代表参数列表 / 文件列表，真的只是文件的列表而已。缓冲区中有更多信息的，最最基本的就是记忆了光标的位置。在 Vim 里，除了切换到下一个文件这样的批处理操作外，操作缓冲区的命令比简单操作文件的命令更为方便。</p>
<p>作为对比，我们来看一下文件列表和缓冲区列表的命令的结果。</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/文件列表命令args的结果.png" alt="文件列表命令args的结果"></p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/缓冲区列表命令ls的结果.png" alt="缓冲区列表命令ls的结果"></p>
<p>可以看到，两者都展示了文件，都标示出了当前编辑的文件（分别使用方括号和“%a”）。不过，缓冲区列表中明显有更多的信息：</p>
<ul>
<li>文件名前面有编号；我们也马上就会说到利用编号的命令。</li>
<li>除了当前活跃文件的标记“%a”，还有个文件被标成了“#”，这表示最近的缓冲区；缓冲区列表里还可能有其他标记，如“+”表示缓冲区已经被修改。</li>
<li>文件名后面有行号，表示光标在文件中的位置。</li>
</ul>
<p>常用的缓冲区命令跟前面文件列表相关的命令有很大的相似性，因此我在这儿一起讲，可以帮助你记忆：</p>
<ul>
<li>:buffers 或 :ls：可以显示缓冲区的列表</li>
<li>:buffer 缓冲区列表里的编号（:buffer 可缩写为 :b）：跳转到编号对应的缓冲区；如当前缓冲区已被修改（未存盘）则会报错中止，但如果命令后面加 ! 则会放弃修改内容；其他命令也类似</li>
<li>:bdelete 缓冲区列表里的编号（:bdelete 可缩写为 :bd）：删除编号对应的缓冲区；编号省略的话删除当前缓冲区</li>
<li>:bnext（缩写 :bn）：跳转到下一个缓冲区</li>
<li>:bNext（缩写 :bN）或 :bprevious（缩写 :bp）：跳转到上一个缓冲区</li>
<li>:bfirst 或 :brewind：跳转到缓冲区列表中的第一个文件</li>
<li>:blast：跳转到缓冲区列表中的最后一个文件</li>
</ul>
<p>还有很常见的一种情况是，我们需要在两个文件之间切换。Vim 对最近编辑的文件（上面提到的列表里标有“#”的文件）有特殊的支持，使用快捷键 <code>&lt;C-^&gt;</code> 可以在最近的两个缓冲区之间来回切换。这个快捷键还有一个用法是在前面输入缓冲区的编号：比如，用 <code>1&lt;C-^&gt;</code> 可以跳转到第一个缓冲区（跟命令行模式的命令 :bfirst 或 :b1 效果相同）。</p>
<p>从实际使用的角度，使用缓冲区列表有点像打开最近使用的文件菜单（但缓冲区列表不会存盘），可以当作一种快速切换到最近使用的文件的方式。</p>
<p>缓冲区是文件在某个 Vim 会话里的映射。这意味着，如果某个 Vim 会话里不同的窗口或标签页（下一讲里会讨论）编辑的是同一个文件，它们对应到的也会是同一个缓冲区。更重要的是，文件 / 缓冲区的修改在同一个 Vim 会话里是完全同步的——这就不会像在多会话编辑时那样发生冲突和产生错误了。</p>
<h2 id="06｜窗口和标签页：修改、对比多个文件的正确姿势"><a href="#06｜窗口和标签页：修改、对比多个文件的正确姿势" class="headerlink" title="06｜窗口和标签页：修改、对比多个文件的正确姿势"></a>06｜窗口和标签页：修改、对比多个文件的正确姿势</h2><h3 id="6-1-多窗口编辑"><a href="#6-1-多窗口编辑" class="headerlink" title="6.1 多窗口编辑"></a>6.1 多窗口编辑</h3><p>Vim 有窗口的概念。事实上，如果你使用过 Vim 的帮助功能的话，那你就已经见过 Vim 的多窗口界面了。在那种情况下，Vim 自动打开了一个水平分割的帮助窗口。</p>
<p>那如果我们想要自己同时查看、编辑多个文件呢？最基本的命令就是 :split（缩写 :sp）了。这个命令后面如果有文件名，表示分割窗口并打开指定的文件；如果没有文件名，那就表示仅仅把当前窗口分割开，当前编辑的文件在两个窗口里都显示。跟显示帮助文件一样，:split 默认使用水平分割的方式。</p>
<p>可以在会产生分割的命令（如 help 和 split）之前加上 vertical（缩写 vert），来进行竖直分割。对于最常见的竖直分割操作，我们则可以直接写成 :vsplit（缩写 :vs）。</p>
<p>下面的动画展示了我们进行一次竖直分割后，再进行水平分割的过程：</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/窗口分割演示.gif" alt="窗口分割演示"></p>
<p>多窗口编辑是一个比较适宜使用鼠标的情况。你可以使用鼠标来激活想要使用的窗口，也可以使用鼠标来拖拉窗口的大小——只要启用了鼠标支持，终端窗口（包括远程连接的 mintty、PuTTY 等）里的 Vim 的窗口分割线也是可以拖动的（上面动画里的分割线拖动就是在一个终端窗口里）。</p>
<p>当然，作为 Vim 用户，基本的键盘使用肯定是少不了的：</p>
<ul>
<li><code>&lt;C-W&gt;</code> 加方向键（h、j、k、l、<code>&lt;Left&gt;</code> 等等）可以在窗口之间跳转</li>
<li><code>&lt;C-W&gt;w</code> 跳转到下一个（往右和往下）窗口，如果已经是右下角的窗口，则跳转到左上角的窗口</li>
<li><code>&lt;C-W&gt;W</code> 跳转到上一个（往左和往上）窗口，如果已经是左上角的窗口，则跳转到右下角的窗口</li>
<li><code>&lt;C-W&gt;n</code> 或 :new 打开一个新窗口</li>
<li><code>&lt;C-W&gt;c</code> 或 :close 关闭当前窗口；当前窗口如果已经是最后一个则无效</li>
<li><code>&lt;C-W&gt;q</code> 或 :quit 退出当前窗口，当最后一个窗口退出时则退出 Vim</li>
<li><code>&lt;C-W&gt;o</code> 或 :only 只保留当前窗口，关闭其他所有窗口</li>
<li><code>&lt;C-W&gt;s</code> 和 :split 作用相同，把当前窗口横向一分为二</li>
<li><code>&lt;C-W&gt;v</code> 和 :vsplit 作用相同，把当前窗口纵向一分为二</li>
<li><code>&lt;C-W&gt;=</code> 使得所有窗口大小相同（当调整过终端或图形界面 Vim 的窗口大小后特别有用）</li>
<li><code>&lt;C-W&gt;_</code> 设置窗口高度，命令前的数字表示高度行数，默认为纵向占满（想专心编辑某个文件时很有用）</li>
<li><code>&lt;C-W&gt;|</code> 设置窗口宽度，命令前的数字表示宽度列数，默认为横向占满</li>
<li><code>&lt;C-W&gt;+</code> 增加窗口的高度，命令前的数字表示需要增加的行数，默认为 1</li>
<li><code>&lt;C-W&gt;-</code> 减少窗口的高度，命令前的数字表示需要减少的行数，默认为 1</li>
<li><code>&lt;C-W&gt;&gt;</code> 增加窗口的宽度，命令前的数字表示需要增加的列数，默认为 1</li>
<li><code>&lt;C-W&gt;&lt;lt&gt;</code>（提醒，我们用 <code>&lt;lt&gt;</code> 表示“&lt;”键）减少窗口的宽度，命令前的数字表示需要增加的列数，默认为 1</li>
</ul>
<p>由于切换窗口是一个非常常见的操作，我通常会映射一下快捷键。为了跟一般的图形界面程序一致，我使用了 Ctrl-Tab 和 Ctrl-Shift-Tab：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim">nnoremap <span class="token operator">&lt;</span>C<span class="token operator">-</span>Tab<span class="token operator">&gt;</span>   <span class="token operator">&lt;</span>C<span class="token operator">-</span>W<span class="token operator">&gt;</span><span class="token keyword">w</span>
inoremap <span class="token operator">&lt;</span>C<span class="token operator">-</span>Tab<span class="token operator">&gt;</span>   <span class="token operator">&lt;</span>C<span class="token operator">-</span>O<span class="token operator">&gt;</span><span class="token operator">&lt;</span>C<span class="token operator">-</span>W<span class="token operator">&gt;</span><span class="token keyword">w</span>
nnoremap <span class="token operator">&lt;</span>C<span class="token operator">-</span>S<span class="token operator">-</span>Tab<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>C<span class="token operator">-</span>W<span class="token operator">&gt;</span>W
inoremap <span class="token operator">&lt;</span>C<span class="token operator">-</span>S<span class="token operator">-</span>Tab<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>C<span class="token operator">-</span>O<span class="token operator">&gt;</span><span class="token operator">&lt;</span>C<span class="token operator">-</span>W<span class="token operator">&gt;</span>W<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>简单解释一下：nnoremap 命令映射正常模式下的键盘，inoremap 命令映射插入模式下的键盘；正常模式的映射简单直白，应该不需要解释，插入模式的映射使用了临时模式切换键 <code>&lt;C-O&gt;</code>（<a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/insert.html#i_CTRL-O">:help i_CTRL-O</a>），在正常模式下执行相应的窗口命令，然后返回插入模式。使用这样的键盘映射之后，这两个快捷键在正常模式和插入模式下就都可以使用了。</p>
<h3 id="6-2-双窗口比较"><a href="#6-2-双窗口比较" class="headerlink" title="6.2 双窗口比较"></a>6.2 双窗口比较</h3><p>多窗口编辑中有一个非常有用的使用方式，那就是比较两个文件，Vim 对此也有特殊的支持。使用 vimdiff 或 gvimdiff 命令，后面跟两个文件名，我们就可以对这两个文件进行比较。在比较时，Vim 会自动折叠相同的代码行，并加亮两边文本的不同部分。窗口的滚动也是联动的。一个实际的截图如下所示：</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/比较两个CPP文件.png" alt="比较两个CPP文件"></p>
<p>顺便说一句，因为使用双窗口比较功能要求 Vim 的宽度是平时的两倍左右，所以我通常都会对 Vim 窗口使用最大化、拖拉之类的操作。这些操作一般只影响右边的窗口的大小，因此，在放大窗口的操作后，我通常紧跟着就会执行 <code>&lt;C-W&gt;=</code> 来使两个窗口的宽度相同——事实上，我使用 <code>&lt;C-W&gt;=</code> 主要就在这种场合。你也可以试试。</p>
<p>当然了，在 Vim 内部也可以发起这样的比较。你需要做的是打开第一个文件，然后使用命令 :vert diffsplit 第二个文件。这一点只要了解一下就好，毕竟大部分情况下你不需要这样去做。</p>
<h3 id="6-3-多标签页编辑"><a href="#6-3-多标签页编辑" class="headerlink" title="6.3 多标签页编辑"></a>6.3 多标签页编辑</h3><p>接下来我们继续讨论和多窗口编辑构成互补的另外一种方式，也就是多标签页。</p>
<p>这里我先给你一个结论：<strong>单窗口多文件编辑最适合的场景是批量修改具有相似性质的文件，多窗口编辑最适合的场景是需要对多个文件进行对比编辑，而其他的一些同时编辑多个文件的场景，就可以考虑多标签页的编辑方式</strong>。</p>
<p>多标签页的基本特性：</p>
<ul>
<li>多标签页编辑允许在编辑器里同时修改多个（未存盘的）文件</li>
<li>多标签页编辑一次只展示一个文件</li>
<li>通过选择标签页（或使用键盘）可以方便地在多个标签页中进行切换</li>
</ul>
<p>Vim 中的标签页在图形界面或终端模式下都能支持上面描述的这些特性。</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/终端里运行的有两个标签页的Vim.png" alt="终端里运行的有两个标签页的Vim"></p>
<p>和某些图形界面应用程序不同，Vim 里标签页可包含多个窗口（一个标签页里默认有一个窗口），而不是窗口可包含多个标签页——这也意味着，在标签页里关闭最后一个窗口就关闭了整个标签页。</p>
<p>此外，Vim 的标签页在纯文本的终端模式里也是可用的。在存在多个标签页的情况下，即使在终端里，你也可以用鼠标点击标签页来进行切换，双击标签栏的空白处添加新标签页，以及点击“X”标记来关闭标签页。</p>
<p>当然，Vim 用户更经常会使用键盘：</p>
<ul>
<li>在已有命令行模式命令前加 tab␣ 可以在新标签页中展示命令的结果，如 :tab help 可以在新标签页中打开帮助，:tab split 可以在新标签页中打开当前缓冲区</li>
<li>:tabs 展示所有标签页的列表</li>
<li>:tabnew 或 :tabedit 可以打开一个空白的新标签页，后面有文件名的话则打开该文件</li>
<li>:tabclose 可以关闭当前标签页（如果标签页里只有一个窗口，使用窗口关闭命令 <code>&lt;C-W&gt;c</code> 应该更快）</li>
<li>:tabnext、gt 或 <code>&lt;C-PageDown&gt;</code> 可以切换到下一个标签页</li>
<li>:tabNext、:tabprevious 、gT 或 <code>&lt;C-PageUp&gt;</code> 可以切换到上一个标签页</li>
<li>:tabfirst 或 :tabrewind 切换到第一个标签页</li>
<li>:tablast 切换到最后一个标签页</li>
</ul>
<p>如果一开始用多窗口编辑，后来发现不需要一直参照这个文件了，或者屏幕空间不足了，该怎么办呢？Vim 提供了一个命令，可以把当前窗口转变成一个新标签页：按下 <code>&lt;C-W&gt;T</code> 即可（仅当当前屏幕上有多个窗口时有效）。</p>
<p>上一讲我们说过，如果某个 Vim 会话里不同的窗口（或标签页；以下略）编辑的是同一个文件，它们对应到的也会是同一个缓冲区。这意味着多个窗口编辑同一个文件不会有冲突，同时，如果缓冲区被修改了，但只要当前关闭的窗口不是包含这个缓冲区的唯一窗口，那关闭窗口不会有任何问题，也不会影响文件的状态。在任何一个瞬间，任何一个窗口都指向一个缓冲区，而任何一个缓冲区都属于一个或多个窗口。（例外情况是你使用了一个不那么常用的功能，隐藏缓冲区；这个功能在本课程中不会讨论。）</p>
<h3 id="6-4-NERDTree-插件"><a href="#6-4-NERDTree-插件" class="headerlink" title="6.4 NERDTree 插件"></a>6.4 NERDTree 插件</h3><p>来看几个利用这些特性的插件。我们讨论的第一个插件就是 NERDTree。</p>
<p>对于找文件这件事，NERDTree 就是你知道文件大概在哪里、但不知道文件具体名字时的一个好选择。跟很多 Vim 插件一样，NERDTree 会利用多窗口（少数情况下利用标签页）的特性。</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/NERDTree的使用界面.png" alt="NERDTree的使用界面"></p>
<h4 id="6-4-1-安装"><a href="#6-4-1-安装" class="headerlink" title="6.4.1 安装"></a>6.4.1 安装</h4><p>如果使用 minpac 的话，我们需要在 vimrc 中“Other plugins”那行下面加入下面的语句，并运行 :PackUpdate 来安装一下：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">call</span> minpac#<span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'preservim/nerdtree'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>NERDTree 缺省就会抢占 netrw 使用的路径形式，所以我们可以用 :e . 来打开 NERDTree。不过，更常用的方式仍然是使用 :NERDTreeToggle，NERDTree 窗口的切换命令。我们使用这个命令可以打开上面左侧的那个 NERDTree 窗口，也可以关闭。</p>
<h4 id="6-4-2-使用"><a href="#6-4-2-使用" class="headerlink" title="6.4.2 使用"></a>6.4.2 使用</h4><p>在打开 NERDTree 窗口之后，使用还是相当直观的，并且按下 ? 就可以查看帮助信息。提一下最重要的几个功能点：</p>
<ul>
<li>顾名思义，这个插件以树形方式展示文件系统，在目录上敲回车或双击即可打开或关闭光标下的目录树。</li>
<li>在文件上敲回车或双击立即打开该文件，并且光标跳转到文件窗口中，这样你就可以立即开始编辑了。</li>
<li>在文件上使用 go 会预览该文件，也就是光标不会跳转到文件所在的窗口中，方便快速查看多个文件的内容。</li>
<li>按 i 会打开文件到一个新的水平分割的窗口中，按 s 会打开文件到一个新的竖直分割的窗口中，按 t 会打开文件到一个新的标签页中。</li>
<li>NERDTree 会自动过滤隐藏文件和目录，但如果你需要看到它们的话，也可以用 I 来开启和关闭隐藏文件的显示。</li>
<li>按 m 会出现一个菜单，允许添加、删除、更名等操作。</li>
</ul>
<h3 id="6-5-类似插件"><a href="#6-5-类似插件" class="headerlink" title="6.5 类似插件"></a>6.5 类似插件</h3><p><a target="_blank" rel="noopener" href="https://github.com/mbbill/VimExplorer">VimExplorer</a></p>
<h2 id="07｜正则表达式：实现文件内容的搜索和替换"><a href="#07｜正则表达式：实现文件内容的搜索和替换" class="headerlink" title="07｜正则表达式：实现文件内容的搜索和替换"></a>07｜正则表达式：实现文件内容的搜索和替换</h2><h3 id="7-1-正则表达式搜索"><a href="#7-1-正则表达式搜索" class="headerlink" title="7.1 正则表达式搜索"></a>7.1 正则表达式搜索</h3><p>通过 Vim 教程，你已经学到了搜索命令 / 和替换命令 :s 的基本用法。教程里没有提到的是，你输入的待查找的内容是被 Vim 当成正则表达式来看待的。下面我们会简单讨论的，是 Vim 里的正则表达式，重点是它和其他常用正则表达式（正则表达式还是有很多种不同的风格的）的区别之处。</p>
<p>在一个搜索表达式里，或者称为模式（pattern；注意不要和 Vim 的 mode 混淆）里，.、*、^、$、~、[]、\ 是有特殊含义的字符：</p>
<ul>
<li><code>.</code> 可以匹配除换行符外的任何字符：如 <code>a.</code> 可以匹配“aa”、“ab”、“ac”等，但不能匹配“a”、“b”或“ba”。如果需要匹配换行符（跨行匹配）的话，则需要使用 <code>\_.</code> 。</li>
<li><code>*</code> 表示之前的匹配原（最普通的情况为单个字符）重复零次或多次：如 <code>aa*</code> 可以匹配“a”、“aa”或“aaa”，<code>a.*</code> 可以匹配“a”、“aa”、“abc”等等，但两者均不能匹配“b”。</li>
<li><code>^</code> 匹配一行的开头，如果出现在模式的开头的话；在其他位置代表字符本身。</li>
<li><code>$</code> 匹配一行的结尾，如果出现在模式的结尾的话；在其他位置代表字符本身。</li>
<li><code>~</code> 匹配上一次替换的字符串，即如果上一次你把“foo”替换成了“bar”，那 <code>~</code> 就匹配“bar”。</li>
<li><code>[…]</code> 匹配方括号内的任一字符；方括号内如果第一个字符是 ^，表示对结果取反；除开头之外的 - 表示范围：如 <code>[A-Za-z]</code> 表示任意一个拉丁字母，<code>[^-+*/]</code> 表示除了“+”、“-”、“*”、“/”外的任意字符。</li>
<li><code>\</code> 的含义取决于下一个字符，在大部分的情况下，包括上面的这几个（.、*、\、^、$、~、[ 和 ]），代表后面这个字符本身；在跟某些字符时则有特殊含义（后面我们会讨论最重要的那些）。</li>
</ul>
<p>除此之外的字符都是普通字符，没有特殊含义。不过，需要注意的是，如果使用 / 开始一个搜索命令，或者在替换命令（:s）中使用 / 作为模式的分隔符，那模式中的 / 必须写作 \/ 才行，否则 Vim 看到 / 就会以为模式结束了，导致错误发生。</p>
<p>为了避免写模式的困扰，如果模式中使用“/”作为路径的分隔符，在替换命令中可以使用其他模式中没有的符号作为分隔符。比如，想把“/image/”全部替换成“/images/”的话，不要用 <code>:%s/\/image\//\/images\//g</code>，而应该用类似于 <code>:%s!/image/!/images/!g</code> 的写法。这只能适用于替换命令，而在使用 / 命令搜索时我们就没什么好办法了，只能把模式里的 / 写作 \/。不过我们也可以取巧一下，用 ? 向上、也就是反向搜索，只要记得 n、N 反过来用找下一个就行。</p>
<p>通过 \ 开始的特殊表达式有不少，如果你需要完整了解的话，可以去看看参考文档（<a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/pattern.html#pattern-overview">:help pattern-overview</a>）。我们下面先学习一下最基本的 6 个特殊模式项：</p>
<ul>
<li><code>\?</code> 表示之前的匹配原重复零次或一次：如 <code>aa\?</code> 可以匹配“a”、“aa”，但不能完整匹配“aaa”（可以匹配其前两个字符、后两个或最后一个字符）。</li>
<li><code>\+</code> 表示之前的匹配原重复一次或多次：如 <code>aa\+</code> 可以匹配“aa”、“aaa”，但不能匹配“a”或“b”。</li>
<li><code>\{n,m}</code> 表示之前的匹配原重复 n 到 m 遍之间，两个数字可以省略部分或全部：如 <code>a\{3}</code>（可读作：3 个“a”）可以匹配“aaa” ，<code>a\{,3}</code>（可读作：最多 3 个“a”）可以匹配“”、“a”、“aa”和“aaa”；两个数字都省略时等价于 <code>*</code>，也就是之前的匹配原可以重复零次或多次。</li>
<li><code>\(</code> 和 <code>\)</code> 括起一个模式，将其组成为单个匹配原：如 <code>\(foo\)\?</code> 可以表示单词“foo”出现零次或一次。<code>\(</code> 和 <code>\)</code> 还有一个附加作用，是捕获匹配的内容，按 <code>\(</code> 出现的先后顺序，可以用 <code>\1</code>、<code>\2</code> 到 <code>\9</code> 来引用。如果你不需要捕获匹配内容的话，用 <code>\%(</code> 和 <code>\)</code> 的性能更高。</li>
<li><code>\&amp;</code> 是分支内多个邻接（concat）的分隔符，概念上可以和与操作相比，表示每一项都需要匹配成功，然后取最后一项的结果返回：如 <code>.*foo.*\&amp;.*bar.*</code> 匹配同时出现了“foo”和“bar”的完整行。相对来讲，<code>\&amp;</code> 没那么常用。</li>
<li><code>\|</code> 是多个分支的分隔符，概念上可以和或操作相比，表示任意一项匹配成功即可：如 <code>foo\|bar</code> 可匹配“foo”或“bar”两单词之一。</li>
</ul>
<p>接下来，我再和你分享 13 个特殊模式项。虽然它们相对来说不那么必需，但掌握它们可以大大地提高程序员的编辑效率。</p>
<ul>
<li><code>\&lt;</code> 匹配单词的开头</li>
<li><code>\&gt;</code> 匹配单词的结尾</li>
<li><code>\s</code> 匹配空白字符 <code>&lt;Space&gt;</code> 和 <code>&lt;Tab&gt;</code></li>
<li><code>\S</code> 匹配非空白字符</li>
<li><code>\d</code> 匹配数字，相当于 [0-9]</li>
<li><code>\D</code> 匹配非数字，相当于 <sup><a href="#fn_0-9" id="reffn_0-9">0-9</a></sup></li>
<li><code>\x</code> 匹配十六进制数字，相当于 [0-9A-Fa-f]</li>
<li><code>\X</code> 匹配非十六进制数字，相当于 <sup><a href="#fn_0-9A-Fa-f" id="reffn_0-9A-Fa-f">0-9A-Fa-f</a></sup></li>
<li><code>\w</code> 匹配单词字符，相当于 [0-9A-Za-z_]</li>
<li><code>\W</code> 匹配非单词字符，相当于 <sup><a href="#fn_0-9A-Za-z_" id="reffn_0-9A-Za-z_">0-9A-Za-z_</a></sup></li>
<li><code>\h</code> 匹配单词首字符，相当于 [A-Za-z_]</li>
<li><code>\H</code> 匹配非单词首字符，相当于 ^[A-Za-z_]</li>
<li><code>\c</code> 忽略大小写进行匹配</li>
</ul>
<p>以上我们讨论的实际上是 Vim 缺省设置下的正则表达式。通过选项（<a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/pattern.html#%2Fmagic">:help /magic</a>），我们可以对哪些字符有特殊意义进行一定程度的调整。不过一般情况下，我认为修改这个选项只会造成混乱、增加心智负担，因此我也就不在这儿展开了。</p>
<h3 id="7-2-搜索实例"><a href="#7-2-搜索实例" class="headerlink" title="7.2 搜索实例"></a>7.2 搜索实例</h3><p>抽象地讨论正则表达式恐怕你也不容易记住，我们还是拿一些具体的例子来看一下吧。</p>
<p>首先，如果<strong>我们要查找某个函数，该怎么做呢？</strong>简单，按下 /，然后输入函数名，回车，不就行了？</p>
<p>错。这种方式对函数名是部分匹配，你搜 begin 还会得到 begin1、_begin 之类的结果。正确的方法是，要在前后加上匹配单词头尾的标记，如，<code>\&lt;begin\&gt;</code>。</p>
<p>顺便说一句，被誉为最有用的 Vim 提示，是把光标移到希望搜索的关键字上，然后按下 *键。Vim 会提取光标下的关键字，并自动添加 <code>\&lt;</code> 和 <code>\&gt;</code> 进行搜索。</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/使用星号搜索的示例；注意“unexpected”并没有被高亮.gif" alt="使用星号搜索的示例；注意“unexpected”并没有被高亮"></p>
<p>如果我要搜索 begin 或 end 呢？我想，你应该已经知道了，是：<code>/\&lt;\(begin\|end\)\&gt;</code>。注意，写成 <code>/\&lt;begin\|end\&gt;</code> 可是不对的。（为什么？你想明白了吗？）</p>
<p>对于 HTML，你应该多多少少有些了解。<strong>如果我们想匹配一下 HTML 标签的话，该怎么做呢？</strong></p>
<p>一个标签以 &lt; 开始，以 &gt; 结束。所以，最简单的模式应该是 <code>&lt;.\+&gt;</code>，对吗？</p>
<p>不对，这个写法忽略了一行里可能有多个标签的事实：对于<code>“&lt;h1&gt;title&lt;/h1&gt;</code>”这样一个字符串，上面这个简单的模式会匹配整个字符串，而不是“<code>&lt;h1&gt;</code>”和“<code>&lt;/h1&gt;</code>”……</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/HTML标签的错误匹配.png" alt="HTML标签的错误匹配"></p>
<p>有一种解决方案是，排除不应该匹配的字符，把模式写成 <code>&lt;[^&gt;]\+&gt;</code>：一对尖括号里有一个或多个不是“&gt;”的字符。不过，这样的写法会让像 &gt; 这样的结尾字符在模式中重复出现，因此这并不是最理想的写法。更好的方式是，使用最短匹配。</p>
<h3 id="7-3-最长匹配和最短匹配"><a href="#7-3-最长匹配和最短匹配" class="headerlink" title="7.3 最长匹配和最短匹配"></a>7.3 最长匹配和最短匹配</h3><p>我们上面学到的 <code>*</code>、<code>\?</code>、<code>\+</code> 和 <code>\{}</code> 都属于最长匹配（也叫贪婪匹配），也就是说，当模式既可以匹配一个较长的字符串，也可以匹配一个较短的字符串时，结果会是那个较长的字符串。</p>
<p>相应地，还有一种匹配叫做最短匹配，也就是在同时可以匹配较长的字符串和较短的字符串时，产生较短的匹配。在 Vim 里，最短匹配只有一种形式，{-n,m}，其意义和之前说的 {n,m} 基本相同，但结果是较短而非较长的字符串。</p>
<p>以上面的 HTML 标签匹配为例，使用最短匹配的话，我们可以把模式写成 <code>&lt;.\{-1,}&gt;</code>，要求在一对尖括号里至少有一个字符，但越短越好。</p>
<h3 id="7-4-搜索加亮和取消"><a href="#7-4-搜索加亮和取消" class="headerlink" title="7.4 搜索加亮和取消"></a>7.4 搜索加亮和取消</h3><p>Vim 缺省在你输入搜索模式时就会高亮跟你输入的模式匹配的文本。</p>
<p>Vim 有一个专门命令来取消搜索加亮，这个命令就是 :nohlsearch，不要高亮搜索。</p>
<p>鉴于这个命令使用的频度实在是太高了，我们需要给它专门分配一个快捷键。请在 vimrc 中加入：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token comment">" 停止搜索高亮的键映射</span>
nnoremap <span class="token operator">&lt;</span><span class="token keyword">silent</span><span class="token operator">&gt;</span> <span class="token operator">&lt;</span>F2<span class="token operator">&gt;</span>      <span class="token punctuation">:</span><span class="token keyword">nohlsearch</span><span class="token operator">&lt;</span>CR<span class="token operator">&gt;</span>
inoremap <span class="token operator">&lt;</span><span class="token keyword">silent</span><span class="token operator">&gt;</span> <span class="token operator">&lt;</span>F2<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>C<span class="token operator">-</span>O<span class="token operator">&gt;</span><span class="token punctuation">:</span><span class="token keyword">nohlsearch</span><span class="token operator">&lt;</span>CR<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这样一来，在搜索或替换工作完成之后，只要按下 <code>&lt;F2&gt;</code> 就可以取消搜索加亮了。</p>
<h3 id="7-5-正则表达式替换"><a href="#7-5-正则表达式替换" class="headerlink" title="7.5 正则表达式替换"></a>7.5 正则表达式替换</h3><p>有些复杂的情况：</p>
<ul>
<li>要保留匹配中的某些字符，而替换另外一些字符</li>
<li>要对匹配出的内容做大小写转换</li>
<li>需要“计算”出替换结果</li>
<li>需要决定一行里要替换单次还是多次，是自动替换还是要一一确认，等等</li>
</ul>
<p>接下来，我们就分别看看这些复杂情况。</p>
<p>在这些情况里，最常用的显然就是<strong>在替换结果中保留匹配出的字符串</strong>了。前面说到 <code>\(\)</code> 除了将一个模式转变成匹配原外，还有一个作用是捕捉匹配的内容，按 <code>\(</code> 的出现顺序依次编号为 1 到 9，并可以在模式和替换字符串中用 <code>\1</code> 到 <code>\9</code> 来访问。如果要在替换字符串中完整使用匹配内容的话，则可以使用 <code>\0</code> 或 <code>&amp;</code>（字符“&amp;”也因此要在替换字符串中写成 <code>\&amp;</code>）。</p>
<p>从搜索的角度，我们一般只关心匹配与否，而不关心匹配的大小。举个例子，如果我想找出作为函数调用的 begin，那我可以写成 <code>\&lt;begin(</code>，虽然 ( 不是我想匹配的内容（函数名称）的一部分。但从替换的角度，我需要在替换时再处理一下多匹配的内容，也是件麻烦事；在非匹配的内容比较复杂或者会变化的时候，尤其会是这样。所以 Vim 里还有专门标识匹配开始和结束的匹配原，分别是 <code>\zs</code> 和 <code>\ze</code>。对于这个例子，搜索模式就应该是 <code>\&lt;begin\ze(</code>。为了巩固前面学到的知识，你应该知道，这个模式也可以啰嗦地写成 <code>\&lt;begin(\&amp;begin</code> 或 <code>\&lt;begin(\&amp;.....</code> 。</p>
<p>\Vim 里还有一些<strong>大小写转换的特殊替换字符串</strong>。它们是：</p>
<ul>
<li><code>\U</code> 把下面的字符变成大写，直到 <code>\E</code> 出现</li>
<li><code>\u</code> 把下一个字符变成大写</li>
<li><code>\L</code> 把下面的字符变成小写，直到 <code>\E</code> 出现</li>
<li><code>\l</code> 把下一个字符变成小写</li>
<li><code>\E</code> 结束大小写转换</li>
</ul>
<p>Vim 还能用 \= 开始一个返回字符串的表达式，用来计算出一个替换结果。鉴于我们目前还没有讨论 Vim 脚本，这个我们就留到后面第 14 讲再说了。</p>
<p>跟常用的编程语言一样，Vim 的正则表达式中支持 \t、\r、\n 等特殊转义字符，但在替换表达式中，由于一些技术原因（<a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/pattern.html#NL-used-for-Nul">:help NL-used-for-Nul</a>），\n 插入的是空字符（NUL 或“\0”），而非在模式中出现时代表的 LF。如果要插入正常的行尾符 LF 的话，我们得使用 \r。这意味着如果想把一个回车变成两个的话，我们得别扭地写 :s/\n/\r\r/，略遗憾。如果有特殊需要得插入 CR 的话，就要更别扭地输入 <code>\&lt;C-V&gt;&lt;CR&gt;</code> 才行。还好，我们基本不会在替换时遇到要插入 CR 的情况……</p>
<p>Vim 有很多用来控制替换的标志，你可以通过 <a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/change.html#:s_flags">:help s_flags</a> 查看详细的介绍，我就不一一列举了。今天这一讲中，我们只会用到最常用的一个标志，g，代表可以在一行内进行多次替换；没有这个标志的话，Vim 在一行里只会对第一个成功的匹配进行替换。</p>
<h3 id="7-6-替换实例"><a href="#7-6-替换实例" class="headerlink" title="7.6 替换实例"></a>7.6 替换实例</h3><p>先来看一个简单的，删除行尾的“//”注释。我们可以用这个命令 <code>:%s!\s*//.*$!!</code> 把零到多个空白字符后面出现的“//”直到行尾全部删除。</p>
<p>如果要删除“<code>/* */</code>”注释，那就复杂多了。首先，匹配内容可以跨行；其次，有跟 HTML 标签类似的问题，需要使用最短匹配。我们需要使用的命令是 <code>:%s!/\*\_.\{-}\*/!!g</code> 。</p>
<p>由于一行里可以有多个“<code>/* */</code>”注释，我们在替换命令的尾部还加上了 g 标志，允许一行里进行多次替换。</p>
<p>假设我们目前的编码规范规定，所有的函数名应该首字母大写（简单起见，我们假设所有的类名已经是首字母大写了，因而构造函数自动符合该要求，不会发生冲突；但其他很多函数名称仍然是小写字母开头），那么 Vim 的替换命令是：<code>:%s/\&lt;\(_*\)\([a-z]\w*\)\ze(/\1\u\2/g</code> 。</p>
<h2 id="08｜基本编程支持：规避、解决编程时的常见问题"><a href="#08｜基本编程支持：规避、解决编程时的常见问题" class="headerlink" title="08｜基本编程支持：规避、解决编程时的常见问题"></a>08｜基本编程支持：规避、解决编程时的常见问题</h2><h3 id="8-1-文件类型和关联设定"><a href="#8-1-文件类型和关联设定" class="headerlink" title="8.1 文件类型和关联设定"></a>8.1 文件类型和关联设定</h3><p>程序源代码通常由文件组成，每个文件都有一个关联的文件类型。这个文件类型决定了Vim 对其进行处理的一些基本设定，可能包括：</p>
<ul>
<li>如何对文件进行高亮</li>
<li>制表符（tab）的宽度（空格数）</li>
<li>是否在键入 <code>&lt;Tab&gt;</code> 时扩展为空格字符</li>
<li>每次缩进的空格数（是的，可以和制表符宽度不同）</li>
<li>采用何种自动缩进方法</li>
<li>其他可适用的选项</li>
</ul>
<p><strong>文件高亮</strong>通常需要一套相当复杂的规则，我们今天就只把它当成一个既成事实了，不讨论这些规则的细节。其他各项在 Vim 里一般以选项的形式出现。这些选项都是文件本地（local）选项，即可以在一个文件里修改其数值而不影响其他文件。对于这样的选项，可以用 :setlocal 和 :setglobal 命令分别访问本地值和全局值。一般的 :set 命令在读取数值时（如 :set tabstop?）返回本地值，在写入数值时（如 :set tabstop=4）同时设置本地值和全局值。</p>
<p><strong>制表符宽度</strong>对应的选项是 tabstop。这在不同的语言里可能有不同的惯例，自然不必多说。它的缺省值是 8，但在不同的文件里可以不一样。不同的文件类型也可能会自动设定不同的数值。</p>
<p>是否 <code>扩展 &lt;Tab&gt; 为空格</code> 由 expandtab 选项控制。我们前面看到过，但没有讲过，Vim 选项有些是用等号赋值的，也有些不用等号，而只用选项名称或选项名称前面加 no，表示否定。这些就是布尔类型选项，expandtab 也是其中之一。如果打开了 expandtab 选项，那输入中的 tab 会被转变成空格；如果关闭的话，则 tab 字符会被保留。</p>
<p>让事情变得更复杂的是，Vim 还有个 softtabstop 选项，软制表符宽度。一旦设置了这个选项为非零值，再键入 <code>&lt;Tab&gt;</code> 和 <code>&lt;BS&gt;</code>（退格键），你就感觉像设置了这个宽度的 tabstop 一样，有相应数量的缩进或取消缩进，但实际插入的字符仍然受 expandtab 和 tabstop 两个选项控制。在设置软制表符宽度时，一种最常用的用法是同时设置 expandtab，这样，编辑时你感觉像使用了这个宽度的制表符一样，但你输入的内容里实际被保存的仍然是空格字符。</p>
<p>这些还不是 Vim 真正使用的“缩进”值。以 C 语言为例，当 Vim 看到你输入“{”和回车键时，会自动产生一个缩进，而这个缩进值跟 tabstop 和 softtabstop 都无关，是一个独立的选项 shiftwidth。</p>
<p>最后，Vim 还有很多精细的选项来控制如何进行缩进。默认情况下，Vim 没有特殊缩进，回车键回到行首。一般而言，使用选项 autoindent 可以使 Vim 至少记住上一行的缩进位置；而对于特定语言，Vim 可以设置更合适的选项，达到更佳的缩进效果——如对类 C 语言 Vim 会设置 cindent 选项，达到最优的缩进效果。我们下面还会提到，Vim 支持对类 C 语言的缩进有一些精调选项，你也可以自己进一步进行调整。</p>
<h3 id="8-2-文件类型判断"><a href="#8-2-文件类型判断" class="headerlink" title="8.2 文件类型判断"></a>8.2 文件类型判断</h3><p>Vim 的文件类型判断是在 filetype.vim 中执行的。我们可以用下面的命令来打开这个文件：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token punctuation">:</span><span class="token keyword">e</span> $VIMRUNTIME<span class="token operator">/</span><span class="token keyword">filetype</span><span class="token operator">.</span><span class="token keyword">vim</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>其中最主要的逻辑仍然是通过后缀来进行判断，如：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token comment">" C++</span>
au BufNewFile<span class="token punctuation">,</span>BufRead <span class="token operator">*</span><span class="token operator">.</span>cxx<span class="token punctuation">,</span><span class="token operator">*</span><span class="token operator">.</span><span class="token keyword">c</span><span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">,</span><span class="token operator">*</span><span class="token operator">.</span><span class="token builtin">hh</span><span class="token punctuation">,</span><span class="token operator">*</span><span class="token operator">.</span>hxx<span class="token punctuation">,</span><span class="token operator">*</span><span class="token operator">.</span>hpp<span class="token punctuation">,</span><span class="token operator">*</span><span class="token operator">.</span>ipp<span class="token punctuation">,</span><span class="token operator">*</span><span class="token operator">.</span>moc<span class="token punctuation">,</span><span class="token operator">*</span><span class="token operator">.</span>tcc<span class="token punctuation">,</span><span class="token operator">*</span><span class="token operator">.</span>inl <span class="token keyword">setf</span> cpp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>其中 au 是 autocmd 的缩写，代表 Vim 在发生某事件时触发某一动作。上面说的就是在创建（BufNewFile）或读入（BufRead）跟指定文件名模式匹配的文件时，把文件类型设为 C++（setf cpp， setf 是 setfiletype 的缩写）。</p>
<p>但在后缀不足以唯一判断时，Vim 可以进一步执行代码，如：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim">au BufNewFile<span class="token punctuation">,</span>BufRead <span class="token operator">*</span><span class="token operator">.</span><span class="token keyword">h</span>     <span class="token keyword">call</span> dist#<span class="token builtin">ft</span>#<span class="token function">FTheader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>上面函数的定义在文件 $VIMRUNTIME/autoload/dist/ft.vim 里：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim">func dist#<span class="token builtin">ft</span>#<span class="token function">FTheader</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token function">match</span><span class="token punctuation">(</span><span class="token function">getline</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">line</span><span class="token punctuation">(</span><span class="token string">"$"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'^@\(interface\|end\|class\)'</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span>
    <span class="token keyword">if</span> <span class="token function">exists</span><span class="token punctuation">(</span><span class="token string">"g:c_syntax_for_h"</span><span class="token punctuation">)</span>
      <span class="token keyword">setf</span> objc
    <span class="token keyword">else</span>
      <span class="token keyword">setf</span> objcpp
    <span class="token keyword">endif</span>
  <span class="token keyword">elseif</span> <span class="token function">exists</span><span class="token punctuation">(</span><span class="token string">"g:c_syntax_for_h"</span><span class="token punctuation">)</span>
    <span class="token keyword">setf</span> <span class="token keyword">c</span>
  <span class="token keyword">elseif</span> <span class="token function">exists</span><span class="token punctuation">(</span><span class="token string">"g:ch_syntax_for_h"</span><span class="token punctuation">)</span>
    <span class="token keyword">setf</span> <span class="token builtin">ch</span>
  <span class="token keyword">else</span>
    <span class="token keyword">setf</span> cpp
  <span class="token keyword">endif</span>
endfunc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>它的大概意思是，如果在头 200 行里找到某行以 @interface 等内容开始，那就认为这是 Objective-C/C++，否则认为是 C/C++。具体是 C 还是 C++，则由全局变量 g:c_syntax_for_h 控制（我们忽略 Ch 这种小众情况）。</p>
<p>上面讲的是 Vim 的缺省行为。我们当然也可以定制 Vim 的行为。按照惯例，一般把定制放在用户 Vim 配置目录里的 filetype.vim 里。我的定制如下所示：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">if</span> <span class="token function">exists</span><span class="token punctuation">(</span><span class="token string">"did_load_filetypes"</span><span class="token punctuation">)</span>
  <span class="token keyword">finish</span>
<span class="token keyword">endif</span>

<span class="token keyword">function</span><span class="token operator">!</span> s<span class="token punctuation">:</span><span class="token function">CheckCPP</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token function">expand</span><span class="token punctuation">(</span><span class="token string">'%:t'</span><span class="token punctuation">)</span> <span class="token operator">!~</span> <span class="token string">'\.'</span>
    <span class="token keyword">setfiletype</span> cpp
  <span class="token keyword">endif</span>
<span class="token keyword">endfunction</span>

augroup filetypedetect
  au<span class="token operator">!</span> BufRead<span class="token punctuation">,</span>BufNewFile <span class="token operator">*</span><span class="token operator">.</span>asm      <span class="token keyword">setfiletype</span> masm
  au<span class="token operator">!</span> BufRead proxy<span class="token operator">.</span>pac             <span class="token keyword">setfiletype</span> javascript
  au<span class="token operator">!</span> BufRead <span class="token operator">*</span><span class="token operator">/</span><span class="token keyword">c</span><span class="token operator">+</span><span class="token operator">+</span><span class="token operator">/</span><span class="token operator">*</span>               <span class="token keyword">call</span> s<span class="token punctuation">:</span><span class="token function">CheckCPP</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  au<span class="token operator">!</span> BufRead <span class="token operator">*</span><span class="token operator">/</span><span class="token builtin">include</span><span class="token operator">/</span><span class="token operator">*</span>           <span class="token keyword">call</span> s<span class="token punctuation">:</span><span class="token function">CheckCPP</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
augroup END<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面这段代码主要做了以下事情：</p>
<ul>
<li>当读入或创建后缀为“.asm”的文件时，设置文件类型为微软宏汇编（默认为 GNU 的汇编格式）。</li>
<li>当读入名字为“proxy.pac”的文件时，把内容当成 JavaScript 解释。</li>
<li>当读入路径含“c++”或“include”的文件时，调用脚本内部函数 CheckCPP，检查文件名（% 代表文件名，:t 代表尾部，即去掉路径部分）是否不含“.”，是的话当成 C++ 文件类型。这是为了处理像“memory”这样的无后缀 C++ 头文件。</li>
<li>随后 Vim 会继续载入自带的 filetype.vim；如果文件类型还未确定的话，则继续使用 Vim 自带的规则进行判断。</li>
</ul>
<h3 id="8-3-文件类型选项"><a href="#8-3-文件类型选项" class="headerlink" title="8.3 文件类型选项"></a>8.3 文件类型选项</h3><p>一旦确定了文件类型，Vim 会从运行支持文件目录下载入同名的文件。以 Python 为例：</p>
<ul>
<li>syntax/python.vim 包含了如何对 Python 进行语法加亮的设置</li>
<li>indent/python.vim 包含了如何对 Python 代码进行缩进的设置（如在用户输入 if 时进行缩进等）</li>
<li>ftplugin/python.vim 是文件类型插件，包含了其他跟文件类型相关的设置</li>
</ul>
<p>文件类型插件中包含我们上面提到的制表符宽度方面的设定，具体来说，是下面这几行：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token string">"g:python_recommended_style"</span><span class="token punctuation">)</span> <span class="token operator">||</span> g<span class="token punctuation">:</span>python_recommended_style <span class="token operator">!=</span> <span class="token number">0</span>
  <span class="token comment">" As suggested by PEP8.</span>
  <span class="token keyword">setlocal</span> <span class="token builtin">expandtab</span> <span class="token builtin">shiftwidth</span><span class="token operator">=</span><span class="token number">4</span> <span class="token builtin">softtabstop</span><span class="token operator">=</span><span class="token number">4</span> <span class="token builtin">tabstop</span><span class="token operator">=</span><span class="token number">8</span>
<span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>默认情况下，该文件使用 <a target="_blank" rel="noopener" href="https://www.python.org/dev/peps/pep-0008/">PEP 8</a> 推荐的设置：</p>
<ul>
<li>把用户输入的制表符扩展成空格</li>
<li>缩进和软制表符宽度设为 4</li>
<li>如果文件中包含制表符的话，仍按宽度为 8 来解释</li>
</ul>
<p>缩进和软制表符宽度设成 4 估计不需要解释，这应该是最常用的缩进值了。使用空格而不是制表符的最大好处是，在无论何种环境下，展示效果都可以完全一致，不会在 diff 时或制表符宽度不符合预期时代码就乱了。至于“硬”制表符宽度仍然是 8，则是为了确保显示文件的兼容性，尤其是在终端里 cat 文件时和在浏览器中浏览源代码时；这两种情况下，制表符宽度一般都是 8。</p>
<p>跟 Python 不同，很多其他文件类型没有推荐的风格设定，这时就应该用户自己进行设定了。我推荐在 vimrc 配置文件里进行设置，因为比较集中、容易管理。如：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim">au FileType <span class="token keyword">c</span><span class="token punctuation">,</span>cpp<span class="token punctuation">,</span>objc  <span class="token keyword">setlocal</span> <span class="token builtin">expandtab</span> <span class="token builtin">shiftwidth</span><span class="token operator">=</span><span class="token number">4</span> <span class="token builtin">softtabstop</span><span class="token operator">=</span><span class="token number">4</span> <span class="token builtin">tabstop</span><span class="token operator">=</span><span class="token number">4</span> <span class="token builtin">cinoptions</span><span class="token operator">=</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">,</span>g0<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>w1
au FileType json        <span class="token keyword">setlocal</span> <span class="token builtin">expandtab</span> <span class="token builtin">shiftwidth</span><span class="token operator">=</span><span class="token number">2</span> <span class="token builtin">softtabstop</span><span class="token operator">=</span><span class="token number">2</span>
au FileType <span class="token keyword">vim</span>         <span class="token keyword">setlocal</span> <span class="token builtin">expandtab</span> <span class="token builtin">shiftwidth</span><span class="token operator">=</span><span class="token number">2</span> <span class="token builtin">softtabstop</span><span class="token operator">=</span><span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>上面设置了几种不同文件类型的编辑选项。大部分我们都已经知道了，下面这个则是新的：</p>
<ul>
<li>cinoptions 可以精调 C 风格缩进的方式；上面 :0 表示 switch 下面的 case 语句不进行额外缩进，g0 代表作用域声明（public:、private: 等）不额外缩进，(0 和 w1 配合代表没结束的圆括号里的内容折行时不额外缩进。</li>
</ul>
<p>我们也可以根据文件类型以外的条件来进行设定，如下面设定是要把 /usr/include 目录下的文件按 <a target="_blank" rel="noopener" href="https://www.gnu.org/prep/standards/">GNU 编码风格</a>来解释：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">function</span><span class="token operator">!</span> <span class="token function">GnuIndent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">setlocal</span> <span class="token builtin">cinoptions</span><span class="token operator">=</span><span class="token operator">&gt;</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token keyword">n</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span>^<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>g0<span class="token punctuation">,</span>h2<span class="token punctuation">,</span>p5<span class="token punctuation">,</span>t0<span class="token punctuation">,</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>u0<span class="token punctuation">,</span>w1<span class="token punctuation">,</span>m1
  <span class="token keyword">setlocal</span> <span class="token builtin">shiftwidth</span><span class="token operator">=</span><span class="token number">2</span>
  <span class="token keyword">setlocal</span> <span class="token builtin">tabstop</span><span class="token operator">=</span><span class="token number">8</span>
<span class="token keyword">endfunction</span>

au BufRead <span class="token operator">/</span>usr<span class="token operator">/</span><span class="token builtin">include</span><span class="token operator">/</span><span class="token operator">*</span>  <span class="token keyword">call</span> <span class="token function">GnuIndent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/GNU风格的CPP代码（注意大括号的缩进风格和高亮的tab宽度）.png" alt="GNU风格的CPP代码（注意大括号的缩进风格和高亮的tab宽度）"></p>
<p>当然，除了设定选项，我们也可以做其他事情，比如下面的代码是在 Vim 帮助文件中，将 q 设定为关闭窗口的按键，映射中的 <buffer> 表示该映射只对这个缓冲区有效。</buffer></p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim">au FileType <span class="token keyword">help</span> nnoremap <span class="token operator">&lt;</span><span class="token keyword">buffer</span><span class="token operator">&gt;</span> <span class="token keyword">q</span> <span class="token operator">&lt;</span>C<span class="token operator">-</span>W<span class="token operator">&gt;</span><span class="token keyword">c</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="8-4-Tags-支持"><a href="#8-4-Tags-支持" class="headerlink" title="8.4 Tags 支持"></a>8.4 Tags 支持</h3><p>Vim 对一种叫 tags 的文本索引格式有特殊支持。事实上，Vim 自己的帮助文件都是用 tags 来索引的。我们用过了 Vim 帮助，也就用过了 tags 文件。下面展示了 $VIMRUNTIME/doc/tags 文件中的一部分：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">?       pattern.txt     /*?*
?&lt;CR&gt;   pattern.txt     /*?&lt;CR&gt;*
@       repeat.txt      /*@*
@/      change.txt      /*@\/*
@:      repeat.txt      /*@:*
@=      change.txt      /*@=*
@@      repeat.txt      /*@@*
@r      eval.txt        /*@r*
A       insert.txt      /*A*
ACL     editing.txt     /*ACL*
ANSI-C  develop.txt     /*ANSI-C*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们可以清楚地看到，其中内容分为三列：第一列是关键字，第二列是文件名，第三列是在目标文件中的匹配文本。当你在 Vim 的帮助文件中使用双击或 <code>&lt;C-]&gt;</code> 等命令跳转时， Vim 就会在 tags 文件中搜索，寻找到匹配项的时候就跳转到指定的文件，并利用匹配文本跳转到指定的位置。</p>
<p>注意我们有不止一个 tags 文件。单单从 Vim 帮助的角度，个人 Vim 配置目录下的 doc目录里有一个 tags 文件；每当你装了一个新的带帮助文件的 Vim 插件时，你都需要到这个 doc 目录下运行 helptags . 来重新生成索引。每个 Vim 软件包的 doc 目录下也同样需要有 tags 文件，不过包管理器能够在安装、更新时自动帮我们在 doc 目录下生成 tags文件。Vim 在你使用 :help 命令查帮助时，会自动在你的所有运行时目录（可以使用 :set runtimepath? 查看）下的 doc/tags 里查找第一个匹配项。</p>
<h3 id="8-5-生成-tags-文件的工具"><a href="#8-5-生成-tags-文件的工具" class="headerlink" title="8.5 生成 tags 文件的工具"></a>8.5 生成 tags 文件的工具</h3><p>我们需要使用下列两个工具之一：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://ctags.sourceforge.net/">Exubertant Ctags</a></li>
<li><a target="_blank" rel="noopener" href="https://ctags.io/">Universal Ctags</a></li>
</ul>
<p>Exuberant Ctags 是已经存在了好多年的老牌工具。Universal Ctags 还比较新。推荐 Universal Ctags，是因为虽然 Exuberant Ctags 和 Universal Ctags 都支持超过 40 种的常见编程语言，但 Exuberant Ctags 的最后一个版本 5.8，发布于 2009 年，之后就一直没有更新了。Universal Ctags 是基于 Exuberant Ctags 代码的改进版本，并把开发移到了 GitHub 上，项目一直处于活跃状态。想偷懒的话，可以直接使用 Exuberant Ctags；如果愿意折腾一下，或者明确遇到 Exuberant Ctags 的问题，则可以试试 Universal Ctags。</p>
<h3 id="8-6-生成-tags-文件的命令"><a href="#8-6-生成-tags-文件的命令" class="headerlink" title="8.6 生成 tags 文件的命令"></a>8.6 生成 tags 文件的命令</h3><p>要生成 tags 文件时，你可以简单地进入到一个目录下，然后执行下面的语句对该目录及子目录下的程序源文件生成一个 tags 文件：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ctags -R <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>但根据场景和语言不同，你可能需要使用更多的选项。比如，对于 C++，我一般使用：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ctags --fields<span class="token operator">=</span>+iaS --extra<span class="token operator">=</span>+q -R <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果是对系统的头文件生成 tags 文件——可以用来查找函数的原型信息——那我们一般还需要加上 <code>--c-kinds=+p</code> 选项。为了一次性地对系统头文件简单地生成 tags 文件，我<br>还专门写了个脚本 <a target="_blank" rel="noopener" href="https://github.com/adah1972/gen_systags">gen_systags</a> 来自动化这项工作。</p>
<h3 id="8-7-使用-tags-文件"><a href="#8-7-使用-tags-文件" class="headerlink" title="8.7 使用 tags 文件"></a>8.7 使用 tags 文件</h3><p>如果当前目录下或当前文件所在目录下存在 tags 文件，Vim 会自动使用这个文件，不需要你做额外的设定。你所需要做的就是在待搜索的关键字上（也可以在可视模式下选中需要的关键字）使用正常模式命令 <c-]>，或者按 g（g 可理解成 go）键加鼠标单击。你愿意的话，也可以手工输入命令 :tag 后面跟空格和待搜索的符号加回车键。这样 Vim 即会跳转到该符号的定义或声明位置。</c-]></p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/标签跳转示例.gif" alt="标签跳转示例"></p>
<p>如果待搜索的符号找不到，Vim 会报错“E426: tag not found”。如果存在一个或多个匹配项，Vim 会跳转到第一个匹配的位置。下面我列举一下其他相关的常用命令：</p>
<ul>
<li>:tnext（缩写 :tn）跳转到下一个标签匹配位置</li>
<li>:tNext（缩写 :tN）或 :tprevious（缩写 :tp）跳转到上一个标签匹配位置</li>
<li>:tfirst 或 :trewind 跳转到第一个标签匹配位置</li>
<li>:tlast 跳转到最后一个标签匹配位置</li>
<li>:tselect 名称（:tselect 可缩写为 :ts）跟 :tag 类似，但会列举可能的匹配项，让你自己选择（而非跳转到第一个匹配位置）</li>
<li>g] 跟 <code>&lt;C-]&gt;</code> 类似，但跟 :tselect 一样会给出一个列表而非直接跳转</li>
<li>:tjump 名称（:tjump 可缩写为 :tj）跟 :tselect 类似，但在只有一个匹配项的时候会直接跳转到匹配位置</li>
<li><code>g&lt;C-]&gt;</code> 跟 g] 类似，但跟 :tjump 一样在只有一个匹配项时会直接跳转到匹配位置</li>
<li>:stselect 名称（:stselect 可缩写为 :sts）跟 :tselect 类似，但结果会打开到一个新分割的窗口中</li>
<li>:stjump 名称（:stjump 可缩写为 :stj）跟 :tjump 类似，但结果会打开到一个新分割的窗口中</li>
</ul>
<p>我们的标签跳转分为 :tag、:tselect 和 :tjump 三种不同方法，正常模式和可视模式的命令 <code>&lt;C-]</code> 也同样有后两种方法的变体，对应的命令分别是 g] 和 <code>g&lt;C-]&gt;</code>。这三个命令前面也都可以额外加上 <code>&lt;C-W&gt;</code>，表示结果打开到新窗口中而非当前窗口。</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/展示在新窗口中选择并打开printf的声明.gif" alt="展示在新窗口中选择并打开printf的声明"></p>
<p>Vim 默认只在当前目录下和文件所在目录下寻找 tags 文件。对于含多层目录的项目，这个设定就不合适了。解决方法是使用 Vim 的选项 tags。一个小技巧是根据项目的可能深度，检查上层存在的 tags 文件：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token comment">" 加入记录系统头文件的标签文件和上层的 tags 文件</span>
<span class="token keyword">set</span> <span class="token keyword">tags</span><span class="token operator">=</span><span class="token operator">.</span><span class="token operator">/</span><span class="token keyword">tags</span><span class="token punctuation">,</span><span class="token operator">.</span><span class="token operator">.</span><span class="token operator">/</span><span class="token keyword">tags</span><span class="token punctuation">,</span><span class="token operator">.</span><span class="token operator">.</span><span class="token operator">/</span><span class="token operator">.</span><span class="token operator">.</span><span class="token operator">/</span><span class="token keyword">tags</span><span class="token punctuation">,</span><span class="token keyword">tags</span><span class="token punctuation">,</span><span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>etc<span class="token operator">/</span>systags<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="8-8-Tagbar-插件"><a href="#8-8-Tagbar-插件" class="headerlink" title="8.8 Tagbar 插件"></a>8.8 Tagbar 插件</h3><p>Vim 的插件 tagbar 就可以利用 Ctags 来提取符号，生成源代码的结构图。只要 Ctags 能支持这种语言，插件就能“识别” 这种语言，来生成结构图；识别的好坏程度也视 Ctags 对其的支持程度而定。下面是一个示例：</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/Tagbar示例.png" alt="Tagbar示例"></p>
<p>跟之前类似，假设使用 minpac 的话，我们需要在 vimrc 中“Other plugins”那行下面加入下面的语句，并运行 :PackUpdate 来安装一下：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">call</span> minpac#<span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'majutsushi/tagbar'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>我给它映射了快捷键 <code>&lt;F9&gt;</code>，可以快速打开和关闭 Tagbar 的窗口：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token comment">" 开关 Tagbar 插件的键映射</span>
nnoremap <span class="token operator">&lt;</span>F9<span class="token operator">&gt;</span> <span class="token punctuation">:</span>TagbarToggle<span class="token operator">&lt;</span>CR<span class="token operator">&gt;</span>
inoremap <span class="token operator">&lt;</span>F9<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>C<span class="token operator">-</span>O<span class="token operator">&gt;</span><span class="token punctuation">:</span>TagbarToggle<span class="token operator">&lt;</span>CR<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="8-9-Quickfix-窗口"><a href="#8-9-Quickfix-窗口" class="headerlink" title="8.9 Quickfix 窗口"></a>8.9 Quickfix 窗口</h3><p>Vim 里有一种特殊类型的窗口，被称作 quickfix（快速修复）。这个窗口中会展示外部命令的结果，并可以通过这个窗口中的内容直接跳转到特定文件的特定位置。这个设计最初是用来加速“编辑 - 编译 - 编辑”这个循环的，但它的实际用处并不只是用来编译程序。</p>
<p>我们先来看一下 Vim 的 :make 命令。如果你的代码可以简单执行 make 来编译的话（也就是说，你已经写了或者生成了合适的 Makefile），你可以尝试直接在 Vim 里执行 :make。你会看到正常的执行过程。唯一不一样的地方是，如果编译失败了，Vim 会自动跳转到第一个出错的位置！</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/演示make失败时的行为.gif" alt="演示make失败时的行为"></p>
<p>如果使用 :copen 命令，我们就可以打开 quickfix 窗口。在里面我们可以看到完整的出错信息，并能通过颜色看出 Vim 解析了文件名和行号。我们在带文件名的行上双击即可跳转到对应位置。另外，我们在 quickfix 窗口中也有跟之前类似的“next”类命令：</p>
<ul>
<li>:cnext（缩写 :cn）跳转到下一个出错位置</li>
<li>:cNext（缩写 :cN）或 :cprevious（缩写 :cp）跳转到上一个出错位置</li>
<li>:cfirst 或 :crewind 跳转到第一个出错位置</li>
<li>:clast 跳转到最后一个出错位置</li>
</ul>
<p>为了方便记忆，我对它们都映射了相似的快捷键。</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token comment">" 用于 quickfix、标签和文件跳转的键映射</span>
nmap <span class="token operator">&lt;</span>F11<span class="token operator">&gt;</span> <span class="token punctuation">:</span><span class="token keyword">cn</span><span class="token operator">&lt;</span>CR<span class="token operator">&gt;</span>
nmap <span class="token operator">&lt;</span>F12<span class="token operator">&gt;</span> <span class="token punctuation">:</span><span class="token keyword">cp</span><span class="token operator">&lt;</span>CR<span class="token operator">&gt;</span>
nmap <span class="token operator">&lt;</span>M<span class="token operator">-</span>F11<span class="token operator">&gt;</span> <span class="token punctuation">:</span><span class="token keyword">copen</span><span class="token operator">&lt;</span>CR<span class="token operator">&gt;</span>
nmap <span class="token operator">&lt;</span>M<span class="token operator">-</span>F12<span class="token operator">&gt;</span> <span class="token punctuation">:</span><span class="token keyword">cclose</span><span class="token operator">&lt;</span>CR<span class="token operator">&gt;</span>
nmap <span class="token operator">&lt;</span>C<span class="token operator">-</span>F11<span class="token operator">&gt;</span> <span class="token punctuation">:</span><span class="token keyword">tn</span><span class="token operator">&lt;</span>CR<span class="token operator">&gt;</span>
nmap <span class="token operator">&lt;</span>C<span class="token operator">-</span>F12<span class="token operator">&gt;</span> <span class="token punctuation">:</span><span class="token keyword">tp</span><span class="token operator">&lt;</span>CR<span class="token operator">&gt;</span>
nmap <span class="token operator">&lt;</span>S<span class="token operator">-</span>F11<span class="token operator">&gt;</span> <span class="token punctuation">:</span><span class="token keyword">n</span><span class="token operator">&lt;</span>CR<span class="token operator">&gt;</span>
nmap <span class="token operator">&lt;</span>S<span class="token operator">-</span>F12<span class="token operator">&gt;</span> <span class="token punctuation">:</span><span class="token keyword">prev</span><span class="token operator">&lt;</span>CR<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="8-10-make-命令的其他细节"><a href="#8-10-make-命令的其他细节" class="headerlink" title="8.10 :make 命令的其他细节"></a>8.10 :make 命令的其他细节</h3><p>Vim 里的 :make 命令缺省会执行 make 命令，并且这是可以通过选项 makeprg 来进行配置的。比如，如果你希望启用四路并发编译，你就可以设置 <code>:set makeprg=make\ -j4</code>。你也可以使用 GNU Make 之外的构建工具，但需要注意的是，如果发现 Vim 不能识别你使用的构建工具产生的错误信息，你可能需要利用 errorformat（<a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/quickfix.html#errorformat">:helperrorformat</a>）选项来告诉 Vim 如何处理错误信息。</p>
<h3 id="8-11-grep-命令"><a href="#8-11-grep-命令" class="headerlink" title="8.11 :grep 命令"></a>8.11 :grep 命令</h3><p>跟 :make 命令相似，Vim 会调用一个合适的外部程序（可通过 grepprg 选项来进行配置）来进行搜索，并从结果中找到文件名、行号等信息。注意：在 Windows 上如果 Vim 没找到 grep 的话，它会调用 Windows 自带的 findstr 命令行工具；为了获得跟其他平台相同的体验和跟 Vim 本身相似的正则表达式，我强烈推荐你在 Windows 上也安装 grep 工具。我们上一讲讲到的搜索模式，大部分在 grep 里可以原封不动地使用，尤其是对 <code>\?</code>、<code>+</code>、<code>\&lt;</code> 和 <code>\&gt;</code> 的解释。考虑到 vi 源自 Bill Joy，grep 源自 Ken Thompson，两者的老祖宗都是 ed，这自然也不是件令人意外的事。</p>
<p>如果使用 grep 命令的话，我们的命令大致如下所示：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token punctuation">:</span><span class="token keyword">grep</span> <span class="token string">'要查找的符号'</span> 文件名列表<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当然，grep 支持的复杂参数我们都可以用上。比如，下面的命令可以在所有的子目录里查找用到了 printf 的 .c 和 .h 文件：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token punctuation">:</span><span class="token keyword">grep</span> <span class="token operator">-</span>R <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">include</span><span class="token operator">=</span><span class="token string">'*.c'</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">include</span><span class="token operator">=</span><span class="token string">'*.h'</span> <span class="token string">'\&lt;printf\&gt;'</span> <span class="token operator">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>小提示</strong>：在查看搜索结果时，适时使用 zz（或 zt、zb）重定位当前行在屏幕上的位置，可能可以更清晰地查看前后的相关代码。</p>
<h3 id="8-12-异步支持"><a href="#8-12-异步支持" class="headerlink" title="8.12 异步支持"></a>8.12 异步支持</h3><p>上面这些命令，都有一个缺点：在执行过程中你干不了其他事情。幸好，在 Vim 8 支持异步任务之后，这个问题也得到了解决。我们利用一个插件，就可以获得类似在一些集成开发环境中的体验，在构建过程中仍然可以继续做其他事情。</p>
<p>我们首先需要安装一个插件 asyncrun.vim。跟前面类似，假设我们使用 minpac 的话，我们需要在 vimrc 中的合适位置加入下面这行：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">call</span> minpac#<span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'skywind3000/asyncrun.vim'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>我们还需要一个跟 :make 相似的命令。我使用下面的命令定义（今天我们重点看使用，定义的细节就不讨论了）：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token comment">" 和 asyncrun 一起用的异步 make 命令</span>
command<span class="token operator">!</span> <span class="token operator">-</span>bang <span class="token operator">-</span>nargs<span class="token operator">=</span><span class="token operator">*</span> <span class="token operator">-</span><span class="token builtin">complete</span><span class="token operator">=</span><span class="token keyword">file</span> Make AsyncRun <span class="token operator">-</span>program<span class="token operator">=</span><span class="token keyword">make</span> @ <span class="token operator">&lt;</span><span class="token keyword">args</span><span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这个命令同样会使用 makeprg 选项。不过，还有个问题是默认情况下屏幕上看不到执行过程的信息。我们可以让 asyncrun 在执行命令时立即打开 quickfix 窗口：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token comment">" 异步运行命令时打开 quickfix 窗口，高度为 10 行</span>
<span class="token keyword">let</span> g<span class="token punctuation">:</span>asyncrun_open <span class="token operator">=</span> <span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>对于 C/C++ 程序员来讲，启动和停止构建应该是一个很频繁的操作吧。所以，我也给它分配了一个快捷键：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token comment">" 映射按键来快速启停构建</span>
nnoremap <span class="token operator">&lt;</span>F5<span class="token operator">&gt;</span>  <span class="token punctuation">:</span><span class="token keyword">if</span> g<span class="token punctuation">:</span>asyncrun_status <span class="token operator">!=</span> <span class="token string">'running'</span><span class="token operator">&lt;</span>bar<span class="token operator">&gt;</span>
                 \<span class="token keyword">if</span> &amp;<span class="token builtin">modifiable</span><span class="token operator">&lt;</span>bar<span class="token operator">&gt;</span>
                   \<span class="token keyword">update</span><span class="token operator">&lt;</span>bar<span class="token operator">&gt;</span>
                 \<span class="token keyword">endif</span><span class="token operator">&lt;</span>bar<span class="token operator">&gt;</span>
                 \exec <span class="token string">'Make'</span><span class="token operator">&lt;</span>bar<span class="token operator">&gt;</span>
               \<span class="token keyword">else</span><span class="token operator">&lt;</span>bar<span class="token operator">&gt;</span>
                 \AsyncStop<span class="token operator">&lt;</span>bar<span class="token operator">&gt;</span>
               \<span class="token keyword">endif</span><span class="token operator">&lt;</span>CR<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的代码通过判断异步任务状态和窗口是否可修改，还会自动执行保存文件和终止构建等操作。</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/演示异步启动构建和使用快捷键跳转.gif" alt="演示异步启动构建和使用快捷键跳转"></p>
<h3 id="8-13-查看文档"><a href="#8-13-查看文档" class="headerlink" title="8.13 查看文档"></a>8.13 查看文档</h3><p>Vim 里快捷键 K 可以用来查看光标下关键字的相关文档。它的行为是由选项 keywordprg（<a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/options.html#'keywordprg'">:help ‘keywordprg’</a>）控制的。这个选项的缺省值是 man，表示查看 Unix 的 man 手册，很多文件类型插件会对当前缓冲区设置一个更合适的值，如 Vim 脚本就会直接把行为改成调用 :help 命令。</p>
<p>查看 man 手册的默认行为通常只在终端工作良好，而在图形界面 Vim 里会出现显示问题。我推荐使用 Vim 内置的 man 插件，并把全局的 keywordprg 设成 :Man：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token comment">" 启用 man 插件</span>
<span class="token keyword">source</span> $VIMRUNTIME<span class="token operator">/</span>ftplugin<span class="token operator">/</span>man<span class="token operator">.</span><span class="token keyword">vim</span>

<span class="token keyword">set</span> <span class="token builtin">keywordprg</span><span class="token operator">=</span><span class="token punctuation">:</span>Man<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样，我们在使用 K 命令时，将在 Vim 里直接打开 man 手册，效果如下所示：</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/使用K在Vim里查看man手册.png" alt="使用K在Vim里查看man手册"></p>
<h2 id="09｜七大常用技巧：让编辑效率再上一个台阶"><a href="#09｜七大常用技巧：让编辑效率再上一个台阶" class="headerlink" title="09｜七大常用技巧：让编辑效率再上一个台阶"></a>09｜七大常用技巧：让编辑效率再上一个台阶</h2><h3 id="9-1-自动完成"><a href="#9-1-自动完成" class="headerlink" title="9.1 自动完成"></a>9.1 自动完成</h3><p>Vim 内置有自动完成功能。最基本的自动完成功能有两种：</p>
<ul>
<li>基于当前文件文本的自动完成</li>
<li>基于文件系统的自动完成</li>
</ul>
<p>我们先说<strong>基于当前文件文本</strong>的自动完成。在当前文件里，或当前文件用 #include（C 类语言的情况）包含的文件里包含某个关键字时，你可以输入头若干个字母并按下 <code>&lt;CP&gt;</code>（表示 previous）或 <code>&lt;C-N&gt;</code>（表示 next）来进行自动完成。这两者的区别是，<code>&lt;C-P&gt;</code>是从当前位置往前找，而 <code>&lt;C-N&gt;</code> 是从当前位置往后找。当只有一个匹配项时，Vim 直接给出完成结果，再次按下 <code>&lt;C-P&gt;</code> 或 <code>&lt;C-N&gt;</code> 则取消自动完成。当存在多个匹配项时，Vim 会根据搜索顺序给出匹配项列表并使用第一个匹配项；再次按下 <code>&lt;C-P&gt;</code> 或 <code>&lt;C-N&gt;</code> 则可以在列表里进行选择。</p>
<p>Vim 的缺省选项能帮你在 Unix 系统上找到系统的头文件，利用里面出现的关键字来完成。想要在其他语言或平台里找到当前文件“包含”的文件里的关键字，请参考下列选项帮助：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/options.html#'include'">:help include</a></li>
<li><a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/options.html#'includeexpr'">:help includeexpr</a></li>
<li><a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/options.html#'isfname'">:help isfname</a></li>
<li><a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/options.html#'path'">:help path</a></li>
</ul>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/自动完成的示例.gif" alt="自动完成的示例"></p>
<p>我们再看一下基于文件系统的自动完成。当你在插入模式下输入一个绝对路径或者当前目录下的文件 / 目录名称的一部分时，你可以使用 <code>&lt;C-X&gt;&lt;C-F&gt;</code> 来启动文件自动完成。在此之后，操作就和前面一样了，你可以使用 <code>&lt;C-P&gt;</code> 和 <code>&lt;C-N&gt;</code> 在匹配项中跳转和取消。</p>
<p>Vim 里还有其他一些以 <code>&lt;C-X&gt;</code> 开始的自动完成功能。比如，你可以用 <code>&lt;C-X&gt;&lt;C-K&gt;</code> 从配置的词典中选择合适的单词，可以用 <code>&lt;C-X&gt;&lt;C-O&gt;</code> 进行“代码自动完成”。但这些功能要么不常用，要么在缺省配置下工作得并不好。</p>
<p>最后，要注意任何自动完成功能都可能会重复你的错误。如果你一开始拼错了，后面又拼对了，很可能会发现前面的错误。而一旦使用自动完成，你要是一开始就拼错了，后面可能就会不断重复之前的错误。</p>
<h3 id="9-2-文本目标跳转"><a href="#9-2-文本目标跳转" class="headerlink" title="9.2 文本目标跳转"></a>9.2 文本目标跳转</h3><p>当光标下的文件名可以在 path 选项标识的目录下找到时，我们可以很方便地跳转过去。你需要的是正常模式命令 <code>gf</code> 和 <code>&lt;C-W&gt;f</code>。前者是直接跳转到文件（理解为“goto file”），后者则会打开一个新窗口（window），在新窗口里打开该文件。</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/文件跳转的演示.gif" alt="文件跳转的演示"></p>
<p>如果光标下面是一个链接，或者非文本文件，。这时候，最简单的解决方式是使用 netrw 插件提供的 gx 命令。它的缺省行为是使用操作系统提供的机制来打开光标下的文件或链接。</p>
<p>比较让人伤心的是，最新版本的 netrw 插件在打开链接时的行为不正常。<a target="_blank" rel="noopener" href="https://github.com/vim/vim/issues/4738">这个问题已经报告有一年了，还没有解决</a>。作为临时方案，我在 Vim 配置的目录放了一个可以工作的老版本，你可以把这个文件复制到你的 Vim 配置目录下的 plugin 子目录下来绕过这个问题。此外，gx 只适合本机，不适合在远程连接上使用。</p>
<h3 id="9-3-Vim-寄存器-剪贴板"><a href="#9-3-Vim-寄存器-剪贴板" class="headerlink" title="9.3 Vim 寄存器 / 剪贴板"></a>9.3 Vim 寄存器 / 剪贴板</h3><p>Vim 的删除和复制命令（如 d 和 y）会把内容存起来，以供粘贴命令（如p 和 P）使用。</p>
<p>估计你已经知道的是，Vim 把要粘贴的内容存在 Vim 内部的“寄存器”（register）里，而非系统的剪贴板。你不一定知道的是，Vim 里的寄存器有好多个。事实上，Vim 有超过 40 个不同的寄存器！我们挨个来看一下：</p>
<ul>
<li>首先是无名寄存器。当操作没有用 “ 加寄存器名称指定寄存器时，我们默认使用无名寄存器。不过，我们仍可以使用 “” 来指定使用无名寄存器，也就是说，””p 和 p 效果相同。</li>
<li>其次是数字寄存器 0 到 9。0 号寄存器中放的永远是最近一次复制（yank）的内容。这和无名寄存器很不一样，它里面放的是最近操作的结果，也包括了 d、x、c 等命令，特别是包括了粘贴命令所替换的内容。1 到 9 号寄存器中放的则是上一次、倒数第二次、直到倒数第九次被删除或修改命令删除的文本。在做少量的用一个名字替换另一个名字、而又懒得使用替换命令时，”0p 是一个接近图形界面里的粘贴命令的常用选择。</li>
<li>然后有小删除寄存器 -。上面我说得不全，删除内容进入 1 到 9 号寄存器的前提条件是被删除的内容至少有一行，或者使用了移动命令 %、(、)、`、/、?、n、N、{ 和 } 进行删除。否则，删除的内容只会进入 - 而不是 1 到 9 号寄存器。</li>
<li>常用的有名寄存器 a 到 z。这些寄存器仅在用户手工指定时才会使用，内容在下一次打开 Vim 时仍然存在。比如，我们可以用 “ayy 代替 yy 把当前行复制到 a 寄存器中，以后就一直可以用 “ap 来进行粘贴了，直到 a 寄存器的内容被替换为止。</li>
<li>不常用的特殊寄存器 . 、:、# 和 %。这些相对来说不那么常用，请自行查看帮助文件 <a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/change.html#quote.">:help “.</a> 等。</li>
<li>黑洞寄存器 _。专门用来删除，目的就是不要影响无名寄存器的内容。</li>
<li>搜索寄存器 /。存放是上一次搜索使用的模式。</li>
<li>表达式寄存器 =。可以把 Vim 表达式估值的结果作为寄存器的内容。</li>
<li>最后是图形界面剪贴板寄存器 <code>+</code>、<code>*</code> 和 <code>~</code>。一般而言，+ 寄存器代表操作系统的剪贴板，和图形界面应用程序交互用这个就好；你用图形界面 Vim 菜单里的拷贝和粘贴访问的也是系统剪贴板。<code>*</code> 和 <code>~</code> 在 X11 和 GTK 环境下有一些特殊用途，我们目前就不展开了。想深入钻研的话，可以查看帮助文档 <a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/gui_x11.html#quoteplus">:help “+</a>、<a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/gui.html#quotestar">:help “*</a> 和 <a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/change.html#quote%7E">:help “~</a>。</li>
</ul>
<p>寄存器在正常模式下可以用 d、y、p 等命令来访问，你现在应当已经很清楚了。它们在插入模式和命令行模式下也可以用 C-R 加寄存器名来访问，这经常也会省去你很多打字的麻烦。</p>
<h3 id="9-4-常用的寄存器使用场景"><a href="#9-4-常用的寄存器使用场景" class="headerlink" title="9.4 常用的寄存器使用场景"></a>9.4 常用的寄存器使用场景</h3><p>如果要<strong>交换两行内容</strong>，可以直接利用删除命令会把删除的内容放到无名寄存器这个特性。我们在第一行上面按下 dd，然后直接按 p 粘贴即可。</p>
<p>如果要<strong>交换两处文本内容</strong>，可以类似地使用删除和粘贴替换都会把内容放到无名寄存器这个特性。我们选中第一处文本，按下 d 进行删除；然后选中第二处文本，按下 p 进行粘贴；最后回到第一处文本的原来位置，使用 P 把文本粘贴回去即可。</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/两处文本交换的演示.gif" alt="两处文本交换的演示.gif"></p>
<p>如果要<strong>少量修改某一变量名称</strong>（多的话使用 :s 替换命令更合适），可以把光标移到变量名称上，用 * 进行开启自动搜索，然后编辑变量名称到合适；随后复制新的变量名称，反复使用 n 命令搜索，并用 <code>ve"0p</code> 进行替换即可。</p>
<p>当然，反复打 <code>ve"0p</code> 真的会感觉这个命令有点长。鉴于这个组合键使用的频度还挺高，我觉得映射一个更短的按键比较好，我的选择是 \v，同时，我做了点更通用的处理：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token comment">" 替换光标下单词的键映射</span>
nnoremap <span class="token operator">&lt;</span>Leader<span class="token operator">&gt;</span>v viw<span class="token comment">"0p</span>
vnoremap <span class="token operator">&lt;</span>Leader<span class="token operator">&gt;</span>v <span class="token comment">"0p</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>关于 <leader> 的含义，可查看帮助文档 <a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/map.html#mapleader"><code>:help &lt;Leader&gt;</code></a>。</leader></p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/使用复制、自动选择、粘贴修改变量名.gif" alt="使用复制、自动选择、粘贴修改变量名"></p>
<h3 id="9-5-宏的录制和播放"><a href="#9-5-宏的录制和播放" class="headerlink" title="9.5 宏的录制和播放"></a>9.5 宏的录制和播放</h3><p>Vim 里可以用 q 把动作记录到寄存器里，然后使用 @ 来播放这些动作。上面这个变量更名，如果用宏来做也可以：</p>
<ul>
<li>用 * 开启搜索</li>
<li>键入 qa 开始录制宏到 a 寄存器；当然我们可以使用其他寄存器，只要被录制的命令不会修改这个寄存器即可，所以一般使用 a 到 z 这 26 个有名寄存器</li>
<li>键入 n 进行搜索；先行搜索的目的是，如果搜索不到内容，命令出错，宏的剩余部分就不会被执行</li>
<li>键入 <code>eabar&lt;Esc&gt;</code> 把 foo 修改为 foobar</li>
<li>键入 q 结束宏录制</li>
<li>键入 @a 播放录制的宏</li>
<li>重复上一步直到 Vim 报告找不到 foo 为止</li>
</ul>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/使用宏修改变量名.gif" alt="使用宏修改变量名"></p>
<p>关于宏的进一步细节可以查看帮助文件（<a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/repeat.html#q">:help q</a>）。</p>
<h3 id="9-6-文本对象增强"><a href="#9-6-文本对象增强" class="headerlink" title="9.6 文本对象增强"></a>9.6 文本对象增强</h3><p>如果你安装了 tpope/vim-surround 插件，你可以实现下面这些功能：</p>
<ul>
<li>在一个单词的外面加上引号，如把 word 变成 “word”，可以使用命令 ysiw”</li>
<li>把一个单词的外面的双引号变成单引号（有强迫症的 Python 程序员很可能有这样的需求），如把 “word” 变成 ‘word’，可以使用命令 cs”‘</li>
<li>把外面的引号或括号变成 HTML 标签也没有问题，如把 [my choice] 变成 <code>&lt;em&gt;my choice&lt;/em&gt;</code>，可以使用命令 <code>cs[&lt;em&gt;</code></li>
<li>可视模式也有类似的命令，如可以在选中 my choice 后，输入 <code>S&lt;em&gt;</code> 把文本变成 <code>&lt;em&gt;my choice&lt;/em&gt;</code></li>
<li>当然，你也可以把加上的包围符号移除，命令是 ds 后面跟包围符号，如 <code>ds"</code> 可以移除外围的双引号；要移除 HTML 标签则使用 t 来表达，即使用 <code>dst</code> 来移除文本外面的第一个 HTML 标签</li>
</ul>
<p>注意 Vim 命令 <code>.</code> 只能用来重复 Vim 的内置命令，而不能用来重复上面这样的用户自定义命令。为了解决这个问题，我也会安装 tpope/vim-repeat 插件，使得重复命令对上面样的情况依然能够生效。</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/Vim-surround和vim-repeat的演示.gif" alt="Vim-surround和vim-repeat的演示"></p>
<h3 id="9-7-撤销树"><a href="#9-7-撤销树" class="headerlink" title="9.7 撤销树"></a>9.7 撤销树</h3><p>Vim 不仅支持多级撤销，而且有撤销树的概念。利用撤销树，你可以转回到编辑中的任何一个历史状态。不过，问题是，Vim 用来管理撤销树的命令不那么直观。在使用撤销树的图形化插件之前，我自己也没有把相关的命令真正用好。</p>
<p>著名的撤销树插件我知道两个，一个是 mbbill/undotree，一个是 sjl/gundo.vim。两者功能相似，界面风格和快捷键有所不同。鉴于 undotree 功能更加丰富，我就以它为例来介绍一下。</p>
<p>从下图中可以看到，undotree 可以展示完整修改历史。你可以用 J 和 K 在历史中跳转，左下角的预览窗口中就会显示修改的内容，右侧文件直接会回到相应的历史状态，并加亮最近的那次修改。一旦用上这个插件，就真的回不到没有这个插件的环境了。</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/Undotree插件的效果.png" alt="Undotree插件的效果"></p>
<p>另外需要稍加注意的一点是，一旦这个文件在其他编辑器里修改了，Vim 发现内容对不上，就无法保留编辑的历史。有一个绕过方法是，当你需要使用其他编辑器修改前，确保你在 Vim 里打开了该文件并且所有修改已保存；这样，在修改完成之后，只要在 Vim 里用 :e 命令重新载入该文件，Vim 就可以把外部的修改也保存在撤销历史记录里，保留完整的编辑历史。此外要注意的是，<strong>最后得在 Vim 里使用 :w 存盘一次</strong>，才能把编辑历史真正保存下来——即使你在 Vim 里没有进行任何修改，也需要这样做一下才能保存修改的历史。</p>
<h3 id="9-8-对当前缓冲区的更名和移动"><a href="#9-8-对当前缓冲区的更名和移动" class="headerlink" title="9.8 对当前缓冲区的更名和移动"></a>9.8 对当前缓冲区的更名和移动</h3><p>你肯定遇见过文件需要更名或者移动吧。这当然很简单，你可以通过图形界面或命令行进行操作。但这样操作之后，有一个问题是 Vim 的撤销历史跟文件就再也对不上了，你也没法再继续撤销更名或移动前的编辑操作了。有一个 Vim 插件，也是 Tim Pope 写的 tpope/vim-eunuch，可以解决这个问题。</p>
<p>事实上，这个插件的功能远不止更名和移动。它实际上是把 Unix 的很多命令行工具搬到了 Vim 里（比较一下 Unix 和 eunuch 的发音你就知道这个插件的名字是什么意思了）。对我来说，最重要的就是它提供的 :Rename 和 :Move 命令，后面跟的参数就是新的名字或路径。这样操作之后，以后再打开这个更名或移动后的文件，仍然能够访问它的一切编辑历史。</p>
<h3 id="9-9-模糊文件查找"><a href="#9-9-模糊文件查找" class="headerlink" title="9.9 模糊文件查找"></a>9.9 模糊文件查找</h3><p>使用 NERDTree 的话，你可以通过浏览目录来打开文件。这种方式，对于你知道文件在哪个目录下、但不知道文件名的时候特别有用。另外一种可能的情况是，你知道文件名或其中的关键部分，但你不知道或不关心文件在哪里。这种情况下，Fzf 的模糊匹配就非常有用了。我们先来看一下动画演示，有一个初步的印象：</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/Fzf的动态文件筛选演示.gif" alt="Fzf的动态文件筛选演示"></p>
<p>从动画可以看到，插件使用的是模糊匹配的方式，可以动态展示搜索的结果，并能直接预览当前选中的文件内容（在窗口足够宽的情况下）。因而这种方式不仅快，而且非常直观。</p>
<p>跟其他插件不同的是，fzf.vim 插件依赖于 fzf 命令行工具。在 <a target="_blank" rel="noopener" href="https://github.com/junegunn/fzf">fzf</a> 的页面上列出了具体安装方式，支持各个平台。</p>
<p>在安装了 fzf 后（可以执行 fzf 来验证一下，它会枚举当前目录下的所有文件，并在你输入字符时缩小匹配；按 <code>&lt;CR&gt;</code> 选择文件，按 <code>&lt;Esc&gt;</code> 取消选择），就可以安装插件了。使用minpac 的话，我们需要在 vimrc 中加入下面两行：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">call</span> minpac#<span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'junegunn/fzf'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">'do'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token operator">-</span><span class="token operator">&gt;</span> fzf#<span class="token function">install</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">call</span> minpac#<span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'junegunn/fzf.vim'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在安装完成之后，你就可以像我前面展示的那样使用 :Files 命令了。更多高级用法可以查看 <a target="_blank" rel="noopener" href="https://github.com/junegunn/fzf.vim">fzf.vim</a> 的页面。</p>
<p>这个插件可以跟其他工具进一步配合。如果你安装了 <a target="_blank" rel="noopener" href="https://github.com/BurntSushi/ripgrep">ripgrep</a> 和 <a target="_blank" rel="noopener" href="https://github.com/sharkdp/bat">bat</a> 的话，可以获得更好的效果。动图中右下角文件预览的语法加亮的效果就依赖于系统里有 bat。如果你装了 ripgrep 的话，可以考虑设置下面的环境变量：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">FZF_DEFAULT_COMMAND</span><span class="token operator">=</span><span class="token string">'rg --files --sortr modified'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这样的话，fzf 可以利用 ripgrep 来自动过滤掉被 Git 忽略的文件、隐藏文件、二进制文件等程序员通常不关心的内容，并将结果以修改时间倒排，确保最新修改的文件在最下面，大大提高了迅速找到你需要的文件的概率。</p>
<h2 id="10｜代码重构实验：在实战中提高编辑熟练度"><a href="#10｜代码重构实验：在实战中提高编辑熟练度" class="headerlink" title="10｜代码重构实验：在实战中提高编辑熟练度"></a>10｜代码重构实验：在实战中提高编辑熟练度</h2><h2 id="11｜文本的细节：关于字符、编码、行你所需要知道的一切"><a href="#11｜文本的细节：关于字符、编码、行你所需要知道的一切" class="headerlink" title="11｜文本的细节：关于字符、编码、行你所需要知道的一切"></a>11｜文本的细节：关于字符、编码、行你所需要知道的一切</h2><h3 id="11-1-什么是文本"><a href="#11-1-什么是文本" class="headerlink" title="11.1 什么是文本"></a>11.1 什么是文本</h3><p>从二元论的角度看，计算机文件可以分为文本文件（text file）和二进制文件（binary file），但这个分法并没有对文本做出清晰的界定。从实用的角度，我们大致可以这么区分：</p>
<ul>
<li>文本文件里存放的是用行结束符（EOL，即 End of Line）隔开的文本行，二进制文件里则没有这样的明确分隔符</li>
<li>文本文件可以通过简单、直接的算法转换为人眼能够识别的文字，而二进制文件里含有不能简单转化为文字的信息</li>
</ul>
<p>事实上，计算机判定一个文件是不是文本文件，并不是件容易的事情，特别是在这个文件含有非 ASCII 字符的时候。</p>
<p>从实用的角度，我对文本文件的判定通常是：</p>
<blockquote>
<p>一个文本文件可以直接输出到终端上，或在简单的编码转换后输出到终端上，显示为一行或多行可识别的字符，并且不包含乱码。</p>
</blockquote>
<p>想要理解这句话，你得先知道什么是字符？什么是编码？什么是行和行结束符？</p>
<h3 id="11-2-字符和编码"><a href="#11-2-字符和编码" class="headerlink" title="11.2 字符和编码"></a>11.2 字符和编码</h3><p>从文件系统的角度看，文件的内容就是一堆比特（bit）而已。把比特对应到字符的方法，就是编码（encoding）。在目前的主流操作系统里，通常八比特是一个基本单位，也就是字节（byte）。最基本的编码方式，就是把一个字节对应到一个字符。</p>
<p>目前的大部分编码方式，在 0－127 的范围里，字节值和字符的对应关系是基本相同的。除了个别字符外，编码的基本方式都和 ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）兼容，如下图所示：</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/ASCII字符映射表.gif" alt="ASCII字符映射表"></p>
<p>注意，头 32 个字符和最后一个字符是控制字符，其中大部分现在已经很少有人使用了，但还有一些我们今天仍然会在不同的场合遇到，如马上就会讨论的 LF 和 CR。</p>
<p>ASCII 是美国标准，里面只有基本的拉丁字母，对其他国家来讲可能就不合适。比如对欧洲国家来说，ASCII 既没有带变音符的拉丁字母（如 é 和 ä ），也不支持像希腊字母（如α、β、γ）、西里尔字母（如 Пушкин）这样的其他欧洲文字，使用起来很不方便。很多其他编码方式使用了 128－255 的字节值范围作为扩展，总共最多是 256 个字符，一次允许一套方式生效，称之为一个代码页（code page）。这种做法，只能适用于文字相近、且字符数不多的国家。比如，下图表示的 ISO-8859-1（也称作 Latin-1）和后面的 Windows 扩展代码页 1252（下图中绿框部分为 Windows 的扩展），就只能适用于西欧国家。</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/ISO-8859-1和Windows-1252里的字符.png" alt="ISO-8859-1和Windows-1252里的字符"></p>
<p>最早的中文字符集标准是 1980 年的国标 GB2312，其中收录了 6763 个常用汉字和 682 个其他符号。至于我们平时用到的编码 GB2312，它更准确的名字其实是 EUC-CN，是一种与 ASCII 兼容的编码方式。它用单字节表示 ASCII 字符而用双字节表示 GB2312 中的字符；由于 GB2312 中本身也含有 ASCII 中包含的字符，在使用中逐渐就形成了“半角”和“全角”的区别。</p>
<p>国标字符集后面又有扩展，这个扩展后的字符集就是 GBK，是中文版 Windows 使用的标准编码方式。GB2312 和 GBK 所占用的编码位置可以参看下面的图（由 John M. Długosz 为 Wikipedia 绘制）：</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/GBK编码的第一字节和第二字节分布.png" alt="GBK编码的第一字节和第二字节分布"></p>
<p>图中 GBK/1 和 GBK/2 为 GB2312 中已经定义的区域，其他的则是 GBK 后面添加的字符，总共定义了两万多个编码点，支持了绝大部分现代汉语中还在使用的字。</p>
<p>显然，多个不同的编码方式是不利于信息交换的。我们在打开文本文件时看到的“乱码”，最常见的情况就是文件的编码和打开文件的工具以为的编码不同。毕竟，只要出现了非 ASCII 字符，解释方式就多了。对我们来说，常见的情况是 Latin-1/Windows-1252（西欧文字）、GBK（简体中文）、Big5（繁体中文），今天还增加了 UTF-8。</p>
<p>UTF-8 的全称是 8-bit Unicode Transformation Format，8 比特的 Unicode 转换格式。Unicode 自发明伊始，就是为了统一编码问题，但它的最早编码方式，UCS-2，存在两个重大问题：</p>
<ul>
<li>和 ASCII 不兼容，不能在现有软件和文件系统中直接使用</li>
<li>在储存 ASCII 为主的字符时，存在一字节变两字节的空间浪费</li>
</ul>
<p>Ken Thompson 在 1992 年和 Rob Pike（罗勃 · 派克）一起发明了 UTF-8，解决了这两个问题（牛人就是牛人啊）。到了今天，UTF-8 已经成了互联网和 Unix 世界里文本文件（含 HTML 和 XHTML）的主流编码方式。但是，Windows 下的文本文件，由于历史原因，可能还大量使用着传统的编码方式（很错误地被叫做 ANSI）；对于中文 Windows，这个传统编码就是 GBK 了。</p>
<p>抛开编码方式的细节（从网上你可以找到足够多的关于 Unicode 和 UTF-8 的资料），我们需要牢牢记住的是，UTF-8 是 Unicode 里最重要的编码方式，可以把一到四字节长度的字节序列映射成为一个 Unicode 字符。目前我们使用的任何字符都可以用 UTF-8 表示，因而 UTF-8 是我们在 Vim 中使用的内部编码（选项 encoding）。我们在第 2 讲中给出 fileencodings 选项设置，就是为了在读写文件时把文件内容进行适当的转换。这个选项表示的是自动检测使用的编码；而在文件被 Vim 载入后，文件的编码会出现在选项 fileencoding 里。如果 fileencoding 选项为空，则表示文件保存时不做任何转换。</p>
<h3 id="11-3-字符和字形"><a href="#11-3-字符和字形" class="headerlink" title="11.3 字符和字形"></a>11.3 字符和字形</h3><p>Unicode 设计时的一个决定，目前看起来有点短视，那就是对中日韩文字中使用到的汉字进行了“统一”。如果字源相同，它们在 Unicode 中就只占据一个编码点。于是，一个字符可能就有多个字形。这个问题，我在第 2 讲中已经展示过了，它也是我们可能需要在图形界面 Vim 中单独设置宽字符字体（guifontwide）的原因。</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/部分汉字的中文和日文字形对比.png" alt="部分汉字的中文和日文字形对比"></p>
<p>跟中文字符集中“半角”和“全角”的概念有点像，Unicode 中也有字宽的概念。和简单的半角与全角的区别不同，Unicode 里除了窄字符和宽字符，还有模糊宽度（ambiguous width）字符。这些字符的宽度根据上下文而定：在东亚文字里一般是宽字符，而在西方文字里一般是窄字符。最常用的模糊宽度字符有（“U+”后面跟十六进制数值是用来表示 Unicode 字符所占编码点数值的通常方法）：</p>
<ul>
<li>U+00B0：「°」</li>
<li>U+00B7：「·」</li>
<li>U+00D7：「×」</li>
<li>U+00F7：「÷」</li>
<li>U+2014：「—」</li>
<li>U+2018：「‘」</li>
<li>U+2019：「’」</li>
<li>U+201C：「“」</li>
<li>U+201D：「”」</li>
<li>U+2103：「℃」</li>
</ul>
<p>对于某一特定字体，它们的宽度当然就是确定的；尤其使用变宽字体（大部分英文字体，不同字符宽度不同）时，如在极客时间的正文里，这个模糊宽度没有什么意义。对于使用等宽字体（程序员一般使用的字体，Vim 只能用等宽字体）的文本编辑器，到底是把这些字符显示成跟 ASCII 字符一样的“单”宽度，还是显示成跟汉字一样的“双”宽度，就是一个需要考虑的问题了。</p>
<p>稍微展开一点点，这个模糊宽度，在我们日常生活中还是造成了一点麻烦的。非常常见的一个排版错误，就是由于使用的软件（在中文 Windows 下的）的字体选择规则，西文中的 「’」误用了中文字体展示，导致这个符号展示出来的字间距过宽。一个相反的麻烦，是中文中写「·」希望两侧留空很足，但在另外一些环境下，永远优先选择西文的字体（如大部分的手机操作系统），导致需要手工两侧加空格才能有比较理想的排版效果……</p>
<p>扯远了，这些毕竟不是 Vim 的问题。Vim 里的解决方式是提供选项 ambiwidth，可以设为 single（默认值）或 double，表示 Vim 到底把这些字符的宽度当成是占一个字符还是两个字符，你想怎么样都可以。对于终端 Vim，由于 Vim 不能决定显示的字体，这个选项只能决定光标在这些字符上应当移动的列数，用户必须自己保证在终端里的设定和 Vim的设定是一致的；否则，可能导致眼睛看到的编辑位置和实际编辑位置不一致。虽然 macOS 的终端应用、Linux 的 GNOME Terminal 和 Windows 下的 PuTTY 都提供了如何处理模糊宽度字体的设定（关键字是“模糊”或“ambiguous”），但鉴于这些软件的字体选择策略，选择“宽”容易导致显示问题，所以我的建议是保留缺省的“窄”设定。</p>
<p>对于图形界面的 Vim，ambiwidth 选项同时也决定了显示这些模糊宽度字符是使用 guifont 选项还是 guifontwide 的设定。在这种情况下，把 ambiwidth 设成 double 才比较有意义：</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/设置了guifontwide之后，两种ambiwidth设置的对比.png" alt="设置了guifontwide之后，两种ambiwidth设置的对比"></p>
<p>修改 ambiwidth 主要影响的是一行的长度，而 Vim 具有根据行长来进行断行的功能。下面，我们先来看一下什么是行。</p>
<h3 id="11-4-行"><a href="#11-4-行" class="headerlink" title="11.4 行"></a>11.4 行</h3><p>从 Vim 和 Unix 的角度看，一个文本文件由多行构成，每一行都以一个行结束符（EOL）结束。根据传统习惯，这个 EOL 在存盘时使用的字符是 LF，编码值是 10（U+000A）。</p>
<p>这只是 Unix 格式。常用的还有 DOS 格式（也包括了 Windows），以及老的 Mac 格式。</p>
<p>在 DOS 格式里，行尾就不只使用 LF 这一个字符了，在 LF 前面会多一个 CR，编码值为 13（U+000D）。这个用法的来源是以前的打字机，CR 表示机架归位（carriage return），LF 表示换行（line feed）。在使用 CR LF 作为行结束符的系统里，CR 只负责光标回到第一列，而 LF 负责光标向下一行。</p>
<p>老的 Mac 则使用单个 CR 字符作为行结束符，但苹果从 Mac OS X（2001 年）开始就使用了 Unix 风格的行结束符。所以，目前我们遇到的文本文件，应当都使用 LF 或 CR LF 作为行结束符了。这也是 Vim 的 fileformats 选项的意义：它的默认值通常是 unix,dos（Unix 环境下）或 dos,unix（Windows 环境下），即会自动检测 Unix 和 DOS 行尾；如果检测不到，则以第一个风格设置作为默认值。</p>
<p>fileencodings 有一个对应的文件相关的 fileencoding 选项，跟它一样，fileformats 也对应有一个文件相关的 fileformat 选项，表示当前文件的行尾风格。需要注意的是，如果一个文件里既有 LF 行尾、又有 CR LF 行尾的话，Vim 会把文件当成 Unix 格式，于是文件里会出现最后一个字符显示成“^M”（通常为蓝色，表示是控制字符，跟正常文本不同）的情况。如果你想保留这种行尾，那不需要做任何事情。但绝大多数情况下，你会希望把行尾统一成 Unix 风格或 DOS 风格。此时，你可以使用下面两种方法之一：</p>
<ul>
<li>使用 :e ++ff=dos 命令强制以 DOS 行尾加载文件；此时文件的行尾格式是 dos。</li>
<li>使用 :%s/\r$// 命令删除行尾多余的 CR 字符；此时文件的行尾格式保持 unix 不变。</li>
</ul>
<p>此外，再说明一下，Unix/Vim 的传统是任何一行都以行结束符终结，包括最后一行。使用 Vim 编辑的文本文件，最后一个字符通常是 LF（除非使用 Mac 行尾风格，则结尾是 CR）。Windows 上大部分文本编辑器则允许最后一行不以行结束符结束；这样的文件在Vim 打开时，Vim 默认会给出一个“<code>[noeol]</code>”的提示。在存盘时，Vim 则会自动在最后添加一个行结束符。</p>
<p>除了 Vim，很多 Unix 工具都会有类似的要求。比如，用于文件比对的命令行工具 diff，它在文件比对时如果输出下面的信息，就是表示文件之一没有用行尾结束符来结束：</p>
<blockquote>
<p>\ No newline at end of file</p>
</blockquote>
<h3 id="11-5-断行"><a href="#11-5-断行" class="headerlink" title="11.5 断行"></a>11.5 断行</h3><p>中文文本文件的行文习惯，通常是在一段之中不空行，一段结束了再换行。文本编辑器需要做的，是在行长超过屏幕宽度时自动折行。Vim 虽然也能在这种情况下自动折行，但 Vim 的更惯常用法是欧洲字母文字和源代码的做法，行长有一定的限制（根据惯例，常用值是 72、80、120），到了指定的行长则应当进行断行，用一个空行来明确表示分段。这也是 Markdown 格式里的标准做法：单个换行符仅相当于空格而已。（这个额外插入的空格就是中文一段之中不换行的原因。）</p>
<p>Vim 有一个文本宽度的选项 textwidth，表示插入文字时的最大行宽度。这个选项的全局默认值为 0，表示不进行限制，但 Vim 脚本可能会设置它，你也可以自己在 vimrc 等地方对其进行设置。我自己的设置是文件相关的，如：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim">au FileType changelog <span class="token keyword">setlocal</span> <span class="token builtin">textwidth</span><span class="token operator">=</span><span class="token number">76</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个设置，加上对行进行格式化的命令 gq，可以让你方便地对（英文）文本进行整理。gq 命令跟 c、d 等命令一样，可以先在可视模式下选定文本，也可以在命令之后跟动作键。对于源代码，它的妙处在于它知道什么是注释，什么是列表：</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/设置行宽为64、使用数字列表，然后格式化注释.gif" alt="设置行宽为64、使用数字列表，然后格式化注释"></p>
<p>如果对这些功能有兴趣的话，请查看相关的帮助： <a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/change.html#gq">:help gq</a> 和 <a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/change.html#fo-table">:help fo-table</a>。我这儿特别要指出的是：</p>
<ul>
<li>要能够在无空格的中文之中断行，我们需要有 :set formatoptions+=m</li>
<li>选项 ambiwidth 会影响行宽的判断，如左右弯引号的宽度算 1 还算 2</li>
<li>在 Vim 8.2.0901 之前，Vim 断行时不考虑中文标点符号的规则；要使用 gq 对中文文本断行，最好升级到这个版本或更高版本</li>
</ul>
<h3 id="11-6-编辑二进制文件"><a href="#11-6-编辑二进制文件" class="headerlink" title="11.6 编辑二进制文件"></a>11.6 编辑二进制文件</h3><p>Vim 有个 binary 选项和一个 -b 命令行参数。当你通过 -b 命令行参数，或 :e ++binary … 命令来打开文件时，binary 选项会自动被设置（用户不应该手动设置该选项）。这个选项保证了，Vim 在读取和存储文件时，不会做会影响文件内容的转换和修改。</p>
<p>不过，即使有这个选项，二进制文件打开后仍然是一堆乱码，这当然是正常的。你除了可以在里面搜索文本之外，还可以利用 Vim 的 Tools（工具）菜单下的“Convert to HEX”（转换成十六进制）和“Convert Back”（转换回）两项，来对二进制文件进行编辑。下面的两张图显示了打开二进制文件后的样子和使用了“Convert to HEX”后的样子：</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/用二进制模式打开一个PNG文件.png" alt="用二进制模式打开一个PNG文件"></p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/转换成HEX格式后的结果.png" alt="转换成HEX格式后的结果"></p>
<p>不管你是要检查文件中的具体字节内容，还是要修改某个字节，HEX 格式都更方便一些。当然，如果你要把修改写回硬盘的话，一定要先使用“Tools &gt; Convert Back”。</p>
<p>要是你使用的不是图形界面，菜单里的这两个命令可以用 :%!xxd 和 :%!xxd -r 来手工替代。</p>
<h2 id="12｜语法加亮和配色方案：颜即正义"><a href="#12｜语法加亮和配色方案：颜即正义" class="headerlink" title="12｜语法加亮和配色方案：颜即正义"></a>12｜语法加亮和配色方案：颜即正义</h2><h3 id="12-1-语法加亮"><a href="#12-1-语法加亮" class="headerlink" title="12.1 语法加亮"></a>12.1 语法加亮</h3><p>Vim 的语法加亮依靠的是在 syntax 目录下的运行支持文件。今天，我就通过例子给你解说一下，Vim 里如何实现语法加亮，然后语法加亮又如何映射到屏幕上的颜色和字体。</p>
<p>我们先来看一个比较简单的例子，xxd。</p>
<p>xxd 它是一个把二进制文件转换成地址加十六进制数值再加可读 ASCII 文本的工具，它的输出格式在 Vim 里也被称作 xxd。不过，在用菜单项或 :%!xxd 命令转换之后，Vim 并不会自动使用 xxd 格式。要应用 xxd 格式的语法加亮，我们需要使用自动命令（可以参考 <a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/tips.html#using-xxd">:help using-xxd</a>），或者手工使用命令 :setf xxd。下图是对上次的二进制文件使用了 xxd 语法加亮的效果：</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/使用了xxd语法加亮的效果.png" alt="使用了xxd语法加亮的效果"></p>
<p>这个格式的语法加亮足够简单，我们就拿它来分析一下。不过，我有个小建议，你在看具体的语法加亮代码前，先花几秒钟的时间看一下图，自己分析一下里面有几种不同的语法加亮效果。</p>
<p>下面我们就来逐步看一下 syntax/xxd.vim 的内容。首先是开头和结尾部分：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token comment">" quit when a syntax file was already loaded</span>
<span class="token keyword">if</span> <span class="token function">exists</span><span class="token punctuation">(</span><span class="token string">"b:current_syntax"</span><span class="token punctuation">)</span>
  <span class="token keyword">finish</span>
<span class="token keyword">endif</span>

…

<span class="token keyword">let</span> <span class="token keyword">b</span><span class="token punctuation">:</span>current_syntax <span class="token operator">=</span> <span class="token string">"xxd"</span>

<span class="token comment">" vim: ts=4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后一行的模式行，设定了这个文件使用的 tab 宽度。剩余部分基本上算是语法文件的固定格式了，有一个检查缓冲区变量（使用前缀 b:）、防止语法文件重复载入的条件判断，并在结尾设定这个缓冲区变量为语法的名称。</p>
<p>剩余部分可以分为两段。第一段是语法匹配：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token builtin">syn</span> <span class="token keyword">match</span> xxdAddress            <span class="token string">"^[0-9a-f]\+:"</span>      contains<span class="token operator">=</span>xxdSep
<span class="token builtin">syn</span> <span class="token keyword">match</span> xxdSep    contained   <span class="token string">":"</span>
<span class="token builtin">syn</span> <span class="token keyword">match</span> xxdAscii              <span class="token string">"  .\{,16\}\r\=$"</span>hs<span class="token operator">=</span>s<span class="token operator">+</span><span class="token number">2</span> contains<span class="token operator">=</span>xxdDot
<span class="token builtin">syn</span> <span class="token keyword">match</span> xxdDot    contained   <span class="token string">"[.\r]"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这儿定义了 4 种不同的“语法项目”，其中 1、2 和 3、4 还互相有包含（“contains”）和被包含（“contained”）的关系。</p>
<ol>
<li><strong>xxdAddress</strong>。它是地址匹配，所以匹配条件是从行首开始的一个或更多的十六进制字符后面跟一个冒号。</li>
<li><strong>xxdSep</strong>。它是分隔符，仅匹配 xxdAddress 中的冒号部分，也算是地址的一部分。</li>
<li><strong>xxdAscii</strong>。它是右边的 ASCII 字符部分，条件是两个空格后面跟最多 16 个字符，然后是可选的 CR 字符（\= 和 \? 效果相同），然后必须是一行结束。</li>
<li><strong>xxdDot</strong>。它是对“.”和 CR 字符的特殊匹配，可以留意一下上面图里“.”和其他字符的加亮效果的不同之处。同样，这个句点也属于 ASCII 字符部分。</li>
</ol>
<p>上面的正则表达式都比较简单，唯一之前没出现过的是第 3 个正则表达式后面的 hs=s+2：它的含义是语法加亮的起始位置是模式匹配部分的开始位置再加 2（可查看 <a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/syntax.html#:syn-pattern-offset">:help :syn-pattern-offset</a>），这是在语法加亮文件里的常用特殊语法。</p>
<p>上面的代码可以从 xxd 格式的内容中找出 4 种不同的语法格式。如何展示这些语法，就要看下面的第二段代码了：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token comment">" Define the default highlighting.</span>
<span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token string">"skip_xxd_syntax_inits"</span><span class="token punctuation">)</span>

 <span class="token builtin">hi</span> <span class="token builtin">def</span> link xxdAddress Constant
 <span class="token builtin">hi</span> <span class="token builtin">def</span> link xxdSep     Identifier
 <span class="token builtin">hi</span> <span class="token builtin">def</span> link xxdAscii   Statement

<span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>外面的条件语句不是惯用法，我们可以忽略。里面重要的是三个 hi def link 语句，拼写完整的话是 highlight default link（可参见帮助 <a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/syntax.html#:highlight-link">:help :highlightlink</a>）。这三个语句建立了默认的语法加亮链接组，也就是，在用户没有自己在 vimrc 配置文件中使用 highlight link 来修改语法加亮时，默认的语法项目和加亮组之间的关系。目前，地址 xxdAddress 使用常数 Constant 的加亮方式，冒号分隔符 xxdSep 使用标识符 Identifier 的加亮方式，ASCII 文本 xxdAscii 使用语句 Statement 的加亮方式。</p>
<p>那 xxdDot 到哪儿去了呢？答案是，它没有加亮组，因为我们不需要对其进行特殊加亮。虽然 Vim 会认出它使用了特殊的语法格式，在显示上它和中间的十六进制数值一样，没有任何语法加亮效果。</p>
<p>Constant、Identifier、Statement 这些加亮组，又应该以何种方式展示呢？这就是配色方案要做的事情了。如果说语法加亮是逻辑问题的话，那配色方案就是个审美问题。你要个性化的话，就靠配色方案了。</p>
<h3 id="12-2-配色方案"><a href="#12-2-配色方案" class="headerlink" title="12.2 配色方案"></a>12.2 配色方案</h3><p>类似地，配色方案里包含的也是一些模板语句加上色彩的定义。比如，在配色方案 koehler 里，跟 xxd 相关的核心色彩定义是：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">set</span> <span class="token builtin">background</span><span class="token operator">=</span>dark
<span class="token builtin">hi</span> Normal         guifg<span class="token operator">=</span>white  guibg<span class="token operator">=</span>black
<span class="token builtin">hi</span> Constant       <span class="token builtin">term</span><span class="token operator">=</span>underline  cterm<span class="token operator">=</span>bold ctermfg<span class="token operator">=</span>magenta  guifg<span class="token operator">=</span>#ffa0a0
<span class="token builtin">hi</span> Identifier     <span class="token builtin">term</span><span class="token operator">=</span>underline   ctermfg<span class="token operator">=</span>brown  guifg<span class="token operator">=</span>#40ffff
<span class="token builtin">hi</span> Statement      <span class="token builtin">term</span><span class="token operator">=</span>bold  cterm<span class="token operator">=</span>bold ctermfg<span class="token operator">=</span>yellow  gui<span class="token operator">=</span>bold  guifg<span class="token operator">=</span>#ffff60<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先，这个配色方案设定背景为 dark，深色（允许的另外一个值是 light，浅色背景）。这会调整缺省的颜色组，使得文字色彩在深色背景上显示比较友好。但这不会在终端里真正改变背景（仍要靠下面的背景色设定），因此，如果你在浅色背景的终端里使用这个配色方案，会显得不太友好。有些比较好的配色方案会采用相反的做法，根据目前是深色还是浅色背景，采用不同的配色。</p>
<p>对于“正常”（Normal）的加亮组，这个配色方案采用了最直截了当的前景白、背景黑。可以预见，这个配色会比较醒（cì）目（yǎn）。</p>
<p>对于 Constant 加亮组，这个配色方案就稍微复杂点了，分了单色终端、色彩终端和图形界面的不同配色。古老的单色终端里使用下划线（应该已经没人用吧，所以以后我就忽略这种设定了）；色彩终端下使用粗体和紫色前景；图形界面指定了前景色为 RGB 色彩 #ffa0a0，亮棕色。</p>
<p>Identifier 加亮组也类似，色彩终端下使用棕色前景，图形界面下前景色则是 RGB 色彩 #40ffff，亮青色。</p>
<p>Statement 加亮组在色彩终端和图形界面下都使用粗体，色彩终端使用黄色前景色，图形界面使用前景色是 RGB 色彩 #ffff60，亮黄色。</p>
<p>使用这个配色方案在图形界面和色彩终端下的效果，如下面的截图所示：</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/图形界面下koehler配色方案的效果.png" alt="图形界面下koehler配色方案的效果"></p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/色彩终端下koehler配色方案的效果.png" alt="色彩终端下koehler配色方案的效果"></p>
<h3 id="12-3-配色方案在终端下的优化"><a href="#12-3-配色方案在终端下的优化" class="headerlink" title="12.3 配色方案在终端下的优化"></a>12.3 配色方案在终端下的优化</h3><p>说到这里，我们有必要来讨论一下 Vim 里允许使用的色彩数量。在图形界面 Vim 里，色彩是 Vim 本身调用系统的编程接口来控制的，可以使用 RGB 的所有 16,777,216 种不同颜色。但在终端里，Vim 会受到终端能力的限制，只能根据终端的能力来显示色彩。根据终端的类型，我们可以分为 4 种情况：</p>
<p>第 1 种是最古老的是单色终端，没有颜色，只能使用下划线、粗体等效果。效果定义使用 term=… 的形式。今天，我们应该基本碰不到这样的环境了。</p>
<p>第 2 种是 8/16 色终端，允许使用最基本的八种颜色（黑、红、绿、黄、蓝、紫、青、白），以及这些颜色的较亮变体（即使 8 色终端一般也能在前景色上使用加亮的变体）。我们可以使用 cterm=… 定义粗体等效果（由于兼容性问题，不常用），用 ctermfg=… 和 ctermbg=… 定义前景和背景色，其中可以使用英文色彩名称或序号（见 <a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/syntax.html#cterm-colors">:help cterm-colors</a>）。鉴于序号在不同的环境里可能是不同的，我们一般使用色彩名称。如果你使用非图形界面终端，可能会遇到这种情况，但这应当也很不常见了吧。</p>
<p>这些颜色虽然是标准的，但很多终端允许用户调整这些颜色，以达到最好的色彩组合效果。比如，下图是 macOS 里终端应用的一个设置界面，其中的“ANSI 颜色”就是用户可以调整的 16 种“标准色”：</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/macOS终端应用的文本设置界面.png" alt="macOS终端应用的文本设置界面"></p>
<p>第 3 种是 256 色终端，用户可以选择预先定义的 256 种颜色之一，这在目前的终端里是非常主流的方式了。你可以在网上很方便地找到<a target="_blank" rel="noopener" href="https://github.com/eikenb/terminal-colors">脚本</a>来输出这些颜色，效果如下图所示：</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/在iTerm2下使用脚本输出的256种颜色.png" alt="在iTerm2下使用脚本输出的256种颜色"></p>
<p>要选择这 256 种颜色中的一种，方式不太直观：你需要使用 ctermfg=… 和 ctermbg=…，并直接写出这 256 种颜色之一的编号。</p>
<p>这 256 种颜色都可以算是标准的，它们的标准 RGB 值有明确的定义。头 16 种颜色就是上面的“ANSI 颜色”，在终端里常常可以直接调整，图中也可以看到和前面图里的颜色已经有明显的不同。虽然界面只提供了头 16 种颜色的调整，但为了达到最佳的显示效果，你也可以编程修改这 256 种颜色的调色板。</p>
<p>第 4 种是支持真彩（truecolor）的终端，跟编程修改 256 色的调色板相比，这是更简单的做法。下面是部分比较常见的支持 RGB 真彩的终端（ <a target="_blank" rel="noopener" href="https://gist.github.com/XVilka/8346728">此处是一个更完整的列表</a>）：</p>
<ul>
<li>GNOME-Terminal（Linux）</li>
<li>iTerm2（macOS）</li>
<li>mintty（Windows）</li>
<li>命令提示符（Windows 10 版本 1703 及以后；在命令提示符里使用 Vim，如果不启用真彩支持，颜色可能完全错误！）</li>
</ul>
<p>在这些终端里，终端 Vim 就能显示跟图形界面 Vim 同样多的颜色数，因而能达到最佳色彩效果。你仍需手工打开（默认关闭的）Vim 选项 termguicolors。此后，Vim 就会使用你在 guifg 和 guibg 中写的 RGB 色彩，也就是说，把终端当图形界面一样看待（在色彩方面）。</p>
<p>鉴于真彩终端的一个惯例是设置环境变量 COLORTERM 为 truecolor 或 24bit，我们可以在 vimrc 配置文件中进行检查：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">if</span> <span class="token function">has</span><span class="token punctuation">(</span><span class="token string">'termguicolors'</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
      \<span class="token punctuation">(</span>$COLORTERM <span class="token operator">==</span> <span class="token string">'truecolor'</span> <span class="token operator">||</span> $COLORTERM <span class="token operator">==</span> <span class="token string">'24bit'</span><span class="token punctuation">)</span>
  <span class="token keyword">set</span> termguicolors
<span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>不过，这个检查方式仅限于类 Unix 平台。对于 Windows，Vim 提供了另外一个专门的特性检查项：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">if</span> <span class="token function">has</span><span class="token punctuation">(</span><span class="token string">'vcon'</span><span class="token punctuation">)</span>
  <span class="token keyword">set</span> termguicolors
<span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="12-4-推荐配色方案"><a href="#12-4-推荐配色方案" class="headerlink" title="12.4 推荐配色方案"></a>12.4 推荐配色方案</h3><ul>
<li>morhetz/gruvbox</li>
<li>nanotech/jellybeans.vim</li>
<li>mbbill/desertEx（作者用的就是这个）</li>
</ul>
<h3 id="12-5-检查-调试配色方案"><a href="#12-5-检查-调试配色方案" class="headerlink" title="12.5 检查 / 调试配色方案"></a>12.5 检查 / 调试配色方案</h3><p>如果你想自己对配色方案进行调整的话，有一个小工具肯定会非常有用，那就是 vimscripts/SyntaxAttr.vim。不过，这个插件不会自己添加键映射，需要你在用包管理器安装之后，自己在 vimrc 配置文件中加入类似下面的语句：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim">nnoremap <span class="token operator">&lt;</span>Leader<span class="token operator">&gt;</span>a <span class="token punctuation">:</span><span class="token keyword">call</span> <span class="token function">SyntaxAttr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>CR<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这样，我们就能用 \a 来检查光标下面的语法高亮详情了。下面是一个示例：</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/检查光标下文本的加亮组.png" alt="检查光标下文本的加亮组"></p>
<p>从上面可以看到，constexpr 属于 cppStorageClass 语法加亮组（这是在 syntax/cpp.vim 中定义的），并且被链接到了 Type 加亮组。后面的 guifg 和 gui 设定就是 Type 加亮组的内容：使用色彩 tan1（RGB 值为 #ffa54f），特殊效果为粗体（bold）。</p>
<h3 id="12-6-输出加亮效果"><a href="#12-6-输出加亮效果" class="headerlink" title="12.6 输出加亮效果"></a>12.6 输出加亮效果</h3><p>作为一个文本编辑器，Vim 只接受文本的复制和粘贴。如果你想要在一个（非 Markdown）文档中展示有语法加亮的代码，Vim 也是可以用来产生这样的代码的——通过 HTML 输出。</p>
<p>Vim 默认就提供了 :TOhtml 命令，可以把当前展示的语法加亮效果输出为一个 HTML 文件。</p>
<p>我最近对一个 Vim 插件 <a target="_blank" rel="noopener" href="https://github.com/adah1972/vim-copy-as-rtf">vim-copy-as-rtf</a> 作了点改造，使其可以在我们现在讲的三大主流平台（macOS、Linux 和 Windows）上都可以直接复制出带语法加亮的代码。在 macOS 和 Windows 上，没有特别的配置要求；在 Linux 桌面环境下，我们要求系统必须装有 xclip 工具。这样，我们只需要在使用 TOhtml 的地方，把命令改成 CopyRTF 就能把加亮的代码复制到系统的剪贴板中。</p>
<h2 id="13｜YouCompleteMe：Vim-里的自动完成"><a href="#13｜YouCompleteMe：Vim-里的自动完成" class="headerlink" title="13｜YouCompleteMe：Vim 里的自动完成"></a>13｜YouCompleteMe：Vim 里的自动完成</h2><h2 id="14｜Vim-脚本简介：开始你的深度定制"><a href="#14｜Vim-脚本简介：开始你的深度定制" class="headerlink" title="14｜Vim 脚本简介：开始你的深度定制"></a>14｜Vim 脚本简介：开始你的深度定制</h2><h3 id="14-1-语法概要"><a href="#14-1-语法概要" class="headerlink" title="14.1 语法概要"></a>14.1 语法概要</h3><p>首先，我们需要知道，通过命令行模式执行的命令就是 Vim 脚本。它是一种图灵完全的脚本语言：图灵完全，说明它的功能够强大，理论上可以完成任何计算任务；脚本语言，说明它不需要编译，可以直接通过解释方式来执行。</p>
<p>当然，这并没有说出 Vim 脚本的真正特点。下面，我们就通过各个不同的角度，进行了解，把 Vim 脚本这头“大象”的基本形状完整地摸出来。</p>
<p>在这一讲里，我们改变一下惯例，除非明确说“正常模式命令”，否则用代码方式显示的都是脚本文件里的代码或者命令行模式命令，也就是说，它们前面都不会加 :。毕竟我们这一讲介绍的全是 Vim 脚本，而不是正常模式的快捷操作。</p>
<h3 id="14-2-打印输出和字符串"><a href="#14-2-打印输出和字符串" class="headerlink" title="14.2 打印输出和字符串"></a>14.2 打印输出和字符串</h3><p>Vim 脚本的“Hello world!”是下面这样的：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim">echo <span class="token string">'Hello world!'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>echo 是 Vim 用来显示信息的内置命令，而 ‘Hello world!’ 是一个字符串字面量。 Vim 里也可以使用 “ 来引起一个字符串。’ 和 “ 的区别和在 shell 里比较相似，前者里面不允许有任何转义字符，而后者则可以使用常见的转义字符序列，如 \n 和 \u…. 等。和 shell 不同的是，我们可以在 ‘ 括起的字符里把 ‘ 重复一次来得到这个字符本身，即 ‘It’’s’ 相当于 “It’s”。</p>
<p>因为 “ 还有开始注释的作用，一般情况下我推荐在 Vim 脚本里使用 ‘，除非你需要转义字符序列或者需要把 ‘ 本身放到字符串里。</p>
<p>字符串可以用 . 运算符来拼接。由于字典访问也可以用 . ，为了避免歧义，Bram 推荐开发者在新的 Vim 脚本中使用 .. 来拼接。但要注意，这个写法在 Vim 7 及之前的版本里不支持。我目前仍暂时使用 . 进行字符串拼接，并和其他大部分运算符一样，前后空一格。这样跟不空格的字典用法比起来，差异就相当明显了。</p>
<p>除了 echo，Vim 还可以用 echomsg（缩写 echom）命令，来显示一条消息。跟 echo 不同的是，这条消息不仅会显示在屏幕上，还会保留在消息历史里，可以在之后用 message 命令查看。</p>
<h3 id="14-3-变量"><a href="#14-3-变量" class="headerlink" title="14.3 变量"></a>14.3 变量</h3><p>变量可以用 let 命令来赋值，如下所示：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">let</span> answer <span class="token operator">=</span> <span class="token number">42</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后你当然就可以使用 answer 这个变量了，如：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim">echo <span class="token string">'The meaning of life, the universe and everything is '</span> <span class="token operator">.</span> answer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>Vim 的变量可以手工取消，需要的命令是 unlet。在你写了 unlet answer 之后，你就不能再读取 answer 这个变量了。</p>
<h3 id="14-4-数字"><a href="#14-4-数字" class="headerlink" title="14.4 数字"></a>14.4 数字</h3><p>Vim 脚本里的数字支持整数和浮点数，在大部分平台上，两者都是 64 位的有符号数字类型，基本对应于大部分 C 语言环境里的 int64_t 和 double。表示方式也和 C 里面差不多：整数可以使用 0（八进制）、0b（二进制）和 0x（十六进制）前缀；浮点数含小数点（不可省略），可选使用科学计数法。</p>
<h3 id="14-5-复杂数据结构"><a href="#14-5-复杂数据结构" class="headerlink" title="14.5 复杂数据结构"></a>14.5 复杂数据结构</h3><p>Vim 脚本内置支持的复杂数据结构是列表（list）和字典（dictionary）。这两者都和 Python 里的对应数据结构一样。对于 C++ 的程序员来说，列表基本上就是数组 /array/vector，但大小可变，而且可以直接使用方括号表达式来初始化，如：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">let</span> primes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后你可以用下标访问，比如用 primes[0] 就可以得到 2。</p>
<p>字典基本上就是 map，可以使用花括号来初始化，如：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">let</span> int_squares <span class="token operator">=</span> <span class="token punctuation">{</span>
      \<span class="token number">0</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
      \<span class="token number">1</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
      \<span class="token number">2</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span>
      \<span class="token number">3</span><span class="token punctuation">:</span> <span class="token number">9</span><span class="token punctuation">,</span>
      \<span class="token number">4</span><span class="token punctuation">:</span> <span class="token number">16</span><span class="token punctuation">,</span>
      \<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>键会自动转换成字符串，而值会保留其类型。上面也用到了 Vim 脚本的续行——下一行的第一个非空白字符如果是 \，则表示这一行跟上一行在逻辑上是同一行，这一点和大部分其他语言是不同的。</p>
<p>访问字典里的某一个元素可以用方括号（跟大部分语言一样），如 int_squares[‘2’]；或使用 .，如 int_squares.2。</p>
<h3 id="14-6-表达式"><a href="#14-6-表达式" class="headerlink" title="14.6 表达式"></a>14.6 表达式</h3><p>跟大部分编程语言类似，Vim 脚本的表达式里可以使用括号，可以调用函数（形如 func(…)），支持加（+）、减（-）、乘（*）、除（/）和取模（%），支持逻辑操作（&amp;&amp;、|| 和 !），还支持三元条件表达式（a ? b : c）。前面我们已经学过，可以使用 [] 访问列表成员，可以使用 [] 或 . 访问字典的成员，也可以使用 . 或 .. 进行字符串拼接。== 和 != 运算符对所有类型都有效，而 &lt;、&gt;= 等运算符对整数、浮点数和字符串都有效。</p>
<p>对于文本处理，常见的情况是我们使用 =~ 和 !~ 进行正则表达式匹配，前者表示匹配的判断，后者表示不匹配的判断。比较操作符可以后面添加 # 或 ? 来强制进行大小写敏感或不敏感的匹配（缺省受 Vim 选项 ignorecase 影响）。表达式的左侧是待匹配的字符串，右侧则是用来匹配的正则表达式。</p>
<p>注意表达式不是一个合法的 Vim 命令或脚本语句。在表达式的左侧，需要有 echo 这样的命令。如果你只想调用一个函数，而不需要使用其返回的结果，则应使用 call func(…) 这样的写法。</p>
<p>此外，我们在插入模式和命令行模式下都可以使用按键 <c-r>=（两个键）后面跟一个表达式来使用表达式的结果。在替换命令中，我们在 \= 后面也同样可以跟一个表达式，来表示使用该表达式的结果。比如，下面的命令可以在当前编辑文件的每一行前面插入行号和空格：</c-r></p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token punctuation">:</span><span class="token operator">%</span>s<span class="token operator">/</span>^<span class="token operator">/</span>\<span class="token operator">=</span><span class="token function">line</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span> <span class="token operator">.</span> <span class="token string">' '</span><span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>line 是 Vim 的一个内置函数，line(‘.’) 表示“当前”行的行号。</p>
<h3 id="14-7-控制结构"><a href="#14-7-控制结构" class="headerlink" title="14.7 控制结构"></a>14.7 控制结构</h3><p>Vim 支持标准的 if、while 和 for 语句。语法上，Vim 的写法有点老派，跟当前的主流语言不太一样，每种结构都要用一个对应的 endif、endwhile 和 endfor 来结束，如下面所示：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token comment">" 简单条件语句</span>
<span class="token keyword">if</span> 表达式
  语句
<span class="token keyword">endif</span>

<span class="token comment">" 有 else 分支的条件语句</span>
<span class="token keyword">if</span> 表达式
  语句
<span class="token keyword">else</span>
  语句
<span class="token keyword">endif</span>

<span class="token comment">" 更复杂的条件语句</span>
<span class="token keyword">if</span> 表达式
  语句
<span class="token keyword">elseif</span> 表达式
  语句
<span class="token keyword">else</span>
  语句
<span class="token keyword">endif</span>

<span class="token comment">" 循环语句</span>
<span class="token keyword">while</span> 表达式
  语句
<span class="token keyword">endwhile</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 while 和 for 循环语句里，你可以使用 break 来退出循环，也可以使用 continue 来跳过循环体内的其他语句。</p>
<p>Vim 脚本的 for 语句跟 Python 非常相似，形式是：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">for</span> var <span class="token keyword">in</span> object
  这儿可以使用 var
<span class="token keyword">endfor</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>表示遍历 object（通常是个列表）对象里面的所有元素。</p>
<p>跟 Python 一样，Vim 脚本也没有 switch/case 语句。</p>
<h3 id="14-8-函数和匿名函数"><a href="#14-8-函数和匿名函数" class="headerlink" title="14.8 函数和匿名函数"></a>14.8 函数和匿名函数</h3><p>Vim 脚本里定义函数使用下面的语法：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">function</span> 函数名<span class="token punctuation">(</span>参数<span class="token number">1</span><span class="token punctuation">,</span> 参数<span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">.</span><span class="token operator">.</span><span class="token operator">.</span><span class="token punctuation">)</span>
  函数内容
<span class="token keyword">endfunction</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>Vim 里用户自定义函数必须首字母大写（和内置函数相区别），或者使用 s: 表示该函数只在当前脚本文件有效。… 可以出现在参数列表的结尾，表示可以传递额外的无名参数。使用有名字的参数时，你需要加上 a: 前缀。要访问额外参数，则需要使用 a:1、a:2 这样的形式。特殊名字 a:0 表示额外参数的数量，a:000 表示把额外参数当成列表来使用，因而 a:000[0] 就相当于 a:1。</p>
<p>在函数里面，跟大部分语言一样，你可以使用 return 命令返回一个结果，或提前结束函数的执行。</p>
<p>Vim 脚本里允许匿名函数，形式是 {逗号分隔开的参数 -&gt; 表达式}。在 Vim 脚本里可以使用类似下面的语句：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim">echo <span class="token function">map</span><span class="token punctuation">(</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>idx<span class="token punctuation">,</span> val <span class="token operator">-</span><span class="token operator">&gt;</span> val <span class="token operator">*</span> val<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>结果是 [1, 4, 9, 16, 25]。跟常见的 map 函数不同，Vim 会传过去两个参数，分别是列表索引和值；同时，它会修改列表的内容。不想修改的话，要把列表复制一份，如 copy(mylist)。</p>
<h3 id="14-9-Vim-特性"><a href="#14-9-Vim-特性" class="headerlink" title="14.9 Vim 特性"></a>14.9 Vim 特性</h3><h4 id="14-9-1-变量的前缀"><a href="#14-9-1-变量的前缀" class="headerlink" title="14.9.1 变量的前缀"></a>14.9.1 变量的前缀</h4><p>通用编程概念上很容易理解的是下面四个：</p>
<ul>
<li>a: 表示这个变量是函数参数，只能在函数内使用。</li>
<li>g: 表示这个变量是全局变量，可以在任何地方访问。</li>
<li>l: 表示这个变量是本地变量，但一般这个前缀不需要使用，除非你跟系统的某个名字发生了冲突。</li>
<li>s: 表示这个变量（或函数，它也能用在函数上）只能用于当前脚本，有点像 C 里面的 static 变量和函数，只在当前脚本文件有效，因而不会影响其他脚本文件里定义的有冲突的名字。</li>
</ul>
<p>一般编程语言里没有的，是下面这些前缀：</p>
<ul>
<li>b: 表示这个变量是当前缓冲区的，不同的缓冲区可以有同名的 b: 变量。比如，在 Vim 里，b:current_syntax 这个变量表示当前缓冲区使用的语法名字。</li>
<li>w: 表示这个变量是当前窗口的，不同的窗口可以有同名的 w: 变量。</li>
<li>t: 表示这个变量是当前标签页的，不同的标签页可以有同名的 t: 变量。</li>
<li>v: 表示这个变量是特殊的 Vim 内置变量，如 v:version 是 Vim 的版本号，等等（详见 <a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/eval.html#v:var">:help v:var</a>）。</li>
</ul>
<p>还有下面这些前缀，可以让我们像使用变量一样使用环境变量和 Vim 选项：</p>
<ul>
<li>$ 表示紧接着的名字是一个环境变量。注意，一些环境变量是由 Vim 自己设置的，如 $VIMRUNTIME。</li>
<li>&amp; 表示紧接着的名字是一个选项，比如， echo &amp;filetype 和 set filetype? 效果相似，都能用来显示当前缓冲区的文件类型。</li>
<li>&amp;g: 表示访问一个选项的全局（global）值。对于有本地值的选项，如 tabstop，我们用 &amp;tabstop 直接读到的是本地值了，要访问全局值就必须使用 &amp;g:tabstop。</li>
<li>&amp;l: 表示访问一个选项的本地（local）值。对于有本地值的选项，如 tabstop，我们用 &amp;tabstop 直接读到的已经是本地值了，但修改则和 set 一样，同时修改本地值和全局值。使用 &amp;l: 前缀可以允许我们仅修改本地值，像 setlocal 命令一样。</li>
</ul>
<p>你可能要问，什么时候我们会需要用变量形式来访问选项，而不是使用 set、setlocal 这样的命令呢？答案是，当我们需要计算出选项值的时候。set filetype=cpp 基本上和 let &amp;filetype = ‘cpp’ 等效，我们需要注意到后者里面 cpp 是个字符串，可以是通过某种方式算出来的。光使用 set，就不方便做到这样的灵活性了。</p>
<h4 id="14-9-2-重要命令"><a href="#14-9-2-重要命令" class="headerlink" title="14.9.2 重要命令"></a>14.9.2 重要命令</h4><p>首先是 execute（缩写 exe），它能用来把后面跟的字符串当成命令来解释。跟上一节使用选项还是 &amp; 变量一样，这样做可以增加脚本的灵活性。除此之外，它还有两种常见特殊用法：</p>
<ul>
<li>在使用键盘映射等场合、需要在一行里放多个命令时，一般可以使用 | 来分隔，但某些命令会把 | 当成命令的一部分（如 !、command、nmap 和用户自定义命令），这种时候就可以使用 execute 把这样的命令包起来，如：exe ‘!ls’ | echo ‘See file list above’。</li>
<li>normal 命令把后面跟的字符直接当成正常模式命令解释，但如果其中包含有特殊字符时就不方便了。这时可以用 execute 命令，然后在 “ 里可以使用转义字符。我们上面讲字符串时没说的是，按键也可以这样转义，比如，”\<c-w>“ 就代表 Ctrl-W 这个按键。所以，如果你想在脚本中控制切换到下一个窗口，可以写成：exe “normal \<cw>w”。</cw></c-w></li>
</ul>
<p>然后，我要介绍一下 source（缩写 so）命令。它用来载入一个 Vim 脚本文件，并执行其中的内容。</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">source</span> $VIMRUNTIME<span class="token operator">/</span>vimrc_example<span class="token operator">.</span><span class="token keyword">vim</span>
…
command<span class="token operator">!</span> PackUpdate packadd minpac | <span class="token keyword">source</span> $MYVIMRC | <span class="token keyword">call</span> minpac#<span class="token function">update</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">'do'</span><span class="token punctuation">:</span> <span class="token string">'call minpac#status()'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
…<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里要注意的地方是，要允许一个文件被 source 多次，是需要一些特殊处理的。我目前给出的 vimrc 配置文件由于需要被载入多次，进行了下面的特殊处理：</p>
<ul>
<li>清除缺省自动命令组里当前的所有命令，以免定义的自动命令被执行超过一次</li>
<li>使用 command! 来定义命令，避免重复命令定义的错误</li>
<li>使用 function! 来定义函数，避免重复函数定义的错误</li>
<li>没有手工设置 set nocompatible，因为该设置可能会有较多的副作用（在 defaults.vim 里会确保只设置该选项一次）</li>
</ul>
<p>上面我已经展示了一个 command 命令的例子。这个命令允许我们自定义 Vim 的命令，并允许用户来定制自动完成之类的效果（详见 <a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/map.html#user-commands">:help user-commands</a>）。注意这个命令的定义要写在一行里，所以如果命令很长，或者中间出现会吞掉 | 的命令的话，我们就会需要用上 execute 命令了。</p>
<p>最后，我再说明一下我们用过的 map 系列键映射命令（详见 <a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/map.html#key-mapping">:help keymapping</a>）。这些命令的主干是 map，然后前面可以插入 nore 表示键映射的结果不再重新映射，最前面用 n、v、i 等字母表示适用的 Vim 模式。在绝大部分情况下，我们都会使用带 nore 这种方式，表示结果不再进行映射（排除偶尔偷懒的情况）。但是，如果我们的 map 命令的右侧用到了已有的（如某个插件带来的）键映射，我们就必须使用没有 nore 的版本了。</p>
<h4 id="14-9-3-事件"><a href="#14-9-3-事件" class="headerlink" title="14.9.3 事件"></a>14.9.3 事件</h4><p>和用户主动发起的命令相对应，Vim 里的自动处理依赖于 Vim 里的事件。迄今为止，我们已经遇到了下面这些事件：</p>
<ul>
<li>BufNewFile 事件在创建一个新文件时触发</li>
<li>BufRead（跟 BufReadPost 相同）事件在读入一个文件后触发</li>
<li>BufWritePost 事件在把整个缓冲区写回到文件之后触发</li>
<li>FileType 事件在设置文件类型（filetype 选项）时被触发</li>
</ul>
<p>Vim 里的事件还有很多（详见 <a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/autocmd.html#autocmd-events-abc">:help autocmd-events-abc</a>）。</p>
<h4 id="14-9-4-内置函数"><a href="#14-9-4-内置函数" class="headerlink" title="14.9.4 内置函数"></a>14.9.4 内置函数</h4><p>Vim 里内置了很多函数（列表见 <a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/usr_41.html#function-list">:help function-list</a>），可以实现编程语言所需要的基本功能。我们目前用得比较多的是下面这两个：</p>
<ul>
<li>exists 用来检测某一符号（变量、函数等）是否已经存在。在 Vim 脚本里最常见的用途是检测某一变量是否已经被定义。</li>
<li>has 用来检测某一 Vim 特性（列表见 <a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/eval.html#feature-list">:help feature-list</a>）是否存在。</li>
</ul>
<p>在看 Vim 脚本时，在关键字上按下 K 就可以查看这个关键字的帮助，如下图所示：</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/在Vim脚本里使用K键查看帮助.gif" alt="在Vim脚本里使用K键查看帮助"></p>
<h4 id="14-9-5-风格指南"><a href="#14-9-5-风格指南" class="headerlink" title="14.9.5 风格指南"></a>14.9.5 风格指南</h4><p>Google 出品的 Vim 脚本风格指南：<a target="_blank" rel="noopener" href="https://google.github.io/styleguide/vimscriptguide.xml">Google Vimscript Style Guide</a>。</p>
<h4 id="14-9-5-Python-集成（选学）"><a href="#14-9-5-Python-集成（选学）" class="headerlink" title="14.9.5 Python 集成（选学）"></a>14.9.5 Python 集成（选学）</h4><p>Vim 脚本功能再强大，也还是一种小众的编程语言。所以，Vim 里内置了跟多种脚本语言的集成，包括：</p>
<ul>
<li>Python</li>
<li>Perl</li>
<li>Tcl</li>
<li>Ruby</li>
<li>Lua</li>
<li>MzScheme</li>
</ul>
<p>由于 Python 的高流行度，目前 Vim 插件里常常见到对 Python 的要求——至少我还没有用过哪个插件要求有其他语言的支持。所以，在这儿我就以 Python 为例，简单介绍一下 Vim 对其他脚本语言的支持。各个语言当然有不同的特性，但支持的方式非常相似，可以说是大同小异。</p>
<p>Vim 很早就支持了 Python 2，Vim 的命令 python（缩写 py）就是用来执行 Python 2 的代码的。后来，Vim 也支持了 Python 3，使用 python3（缩写 py3）来执行 Python 3 的代码。鉴于 Python 的代码还是有不少是 2、3 兼容的，Vim 还有命令 pythonx（缩写 pyx）可以自动选择一个可用的 Python 版本来执行。</p>
<p>我在 <a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/278870">拓展 3</a> 里给出了一段代码，用 Python 来检测当前目录是不是在一个 Git 库里。我们先用 pythonx 命令定义了一个 Python 函数，然后用 pyxeval 函数来调用该函数。这就是一种典型的使用方式：在 Python 里定义某个功能，然后在 Vim 脚本里调用该功能。这种情况下，Python 部分的代码一般不需要对 Vim 有任何特殊处理，只是简单实现某个特定功能。</p>
<p>下面是另一个小例子，通过 Python 来获得当前时区和协调世界时的时间差值（对于中国，应当返回 ␣+0800）：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">function</span><span class="token operator">!</span> <span class="token function">Timezone</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token function">has</span><span class="token punctuation">(</span><span class="token string">'pythonx'</span><span class="token punctuation">)</span>
pythonx <span class="token operator">&lt;</span><span class="token operator">&lt;</span> EOF
import time

<span class="token builtin">def</span> <span class="token function">my_timezone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    is_dst <span class="token operator">=</span> time<span class="token operator">.</span>daylight and time<span class="token operator">.</span><span class="token function">localtime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">.</span>tm_isdst
    offset <span class="token operator">=</span> time<span class="token operator">.</span>altzone <span class="token keyword">if</span> is_dst <span class="token keyword">else</span> time<span class="token operator">.</span>timezone
    <span class="token punctuation">(</span>hours<span class="token punctuation">,</span> seconds<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">divmod</span><span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>offset<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3600</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> offset <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span> hours <span class="token operator">=</span> <span class="token operator">-</span>hours
    minutes <span class="token operator">=</span> seconds <span class="token operator">/</span><span class="token operator">/</span> <span class="token number">60</span>
    <span class="token keyword">return</span> <span class="token string">'{:+03d}{:02d}'</span><span class="token operator">.</span><span class="token function">format</span><span class="token punctuation">(</span>hours<span class="token punctuation">,</span> minutes<span class="token punctuation">)</span>
EOF
    <span class="token keyword">return</span> <span class="token string">' '</span> <span class="token operator">.</span> <span class="token function">pyxeval</span><span class="token punctuation">(</span><span class="token string">'my_timezone()'</span><span class="token punctuation">)</span>
  <span class="token keyword">else</span>
    <span class="token keyword">return</span> <span class="token string">''</span>
  <span class="token keyword">endif</span>
<span class="token keyword">endfunction</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从 pythonx &lt;&lt; EOF 到 EOF，中间是 Python 代码，定义了一个叫 my_timezone 的函数，我们然后调用该函数来获得结果。对于不支持 Python 的情况，我们就直接返回一个空字符串了。</p>
<p>另一种更复杂的情况是，我们的主干处理逻辑就放在 Python 里。这种情况下，我们就需要在 Python 里调用 Vim 的功能了。在 Vim 调用 Python 代码时，Python 可以访问 vim 模块，其中提供多个 Vim 的专门方法和对象，如：</p>
<ul>
<li>vim.command 可以执行 Vim 的命令</li>
<li>vim.eval 可以对表达式进行估值</li>
<li>vim.buffers 代表 Vim 里的缓冲区</li>
<li>vim.windows 代表当前标签页里的 Vim 窗口</li>
<li>vim.tabpages 代表 Vim 里的标签页</li>
<li>vim.current 代表各种 Vim 的“当前”对象（详见 <a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/if_pyth.html#python-current">:help pythoncurrent</a>），包括行、缓冲区、窗口等</li>
</ul>
<p>此外，在 <strong>拓展 2</strong> 里我们给出的使用 pyxf 来执行一个 Python 脚本文件，也是一种在 Vim 里调用 Python 的方式（详见 <a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/if_pyth.html#:pyxfile">:help pyxfile</a>）。那段 clang-format 的代码，总体上也就是访问 vim.current.buffer 对象，调用外部命令格式化指定行，然后把修改的内容写回到 Vim 缓冲区里。</p>
<h2 id="15｜插件荟萃：不可或缺的插件"><a href="#15｜插件荟萃：不可或缺的插件" class="headerlink" title="15｜插件荟萃：不可或缺的插件"></a>15｜插件荟萃：不可或缺的插件</h2><h2 id="16｜终端和-GDB-支持：不离开-Vim-完成开发任务"><a href="#16｜终端和-GDB-支持：不离开-Vim-完成开发任务" class="headerlink" title="16｜终端和 GDB 支持：不离开 Vim 完成开发任务"></a>16｜终端和 GDB 支持：不离开 Vim 完成开发任务</h2><p>Emacs 有个功能可是 Vim 用户一直暗暗垂涎的，那就是可以集成 GDB 来调试程序。Emacs 之所以能够实现这个功能，是因为它可以模拟一个终端环境，像终端一样跟一个程序进行输入输出的交互。这样一来，我们不离开编辑器，也能调试程序，既可以方便地看到目前执行在源代码的第几行，也可以直接在编辑器里跟执行中的程序进行交互。</p>
<p>很多主流的开发环境都支持类似的功能。但 Vim 一直不支持这样的功能，直到 Vim 8。</p>
<h3 id="16-1-终端窗口支持"><a href="#16-1-终端窗口支持" class="headerlink" title="16.1 终端窗口支持"></a>16.1 终端窗口支持</h3><h4 id="16-1-1-基本用法"><a href="#16-1-1-基本用法" class="headerlink" title="16.1.1 基本用法"></a>16.1.1 基本用法</h4><p>使用 :terminal（缩写 :term）命令，我们可以在 Vim 的窗口中运行终端模拟器。基本的用法就是下面两种：</p>
<ul>
<li>使用 :terminal，后面不跟其他命令，分割一个新窗口，并使用默认的 shell 程序进行终端模拟；shell 退出后窗口自动关闭（可用使用命令参数 ++noclose 改变这一行为）。</li>
<li>使用 :terminal 命令 的方式，分割一个新窗口，在其中运行指定的命令并进行终端模拟；命令执行完成退出后窗口不自动关闭，保留执行中显示的信息（可用使用命令参数 ++close 改变这一行为）。</li>
</ul>
<p>跟其他的多窗口命令一样，:terminal 默认会进行横向分割，但你也可以在 terminal 前面加上 vert 来进行纵向分割，或加上 tab 来把终端窗口打开到一个新的标签页里。</p>
<p>跟 quickfix 窗口里只能看到程序的输出不同，在终端模拟器里我们既可以看到程序的输出，也可以向程序提供输入。同时，这个终端模拟器像一个真正的终端一样，能够支持色彩和其他的文本控制。你甚至可以在里面运行 Vim，就像 Matrix 电影里层层嵌套的世界一样。</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/开了两个终端窗口的Vim，其中上面那个又再次运行Vim.png" alt="开了两个终端窗口的Vim，其中上面那个又再次运行Vim"></p>
<p>当然，从实用的角度，我并不建议你这么做——那样可能会让人头昏，并且容易在使用 <code>&lt;C-W&gt;</code> 和 :q 这样的命令时，出现结果跟自己预想不一致的情况。</p>
<p>终端模拟器的行为应当跟普通的终端一致；因此在 Vim 的终端模拟器里，你可以直接使用的命令跟一般的 Vim 窗口很不一样。毕竟，你在终端模拟器里输入 : 时，肯定不是想进入 Vim 的命令行模式吧？这时候，你需要知道下面这些在“终端作业模式”下的特殊命令（完整列表见 <a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/terminal.html#t_CTRL-W_N">:help t_CTRL-W</a>）：</p>
<ul>
<li><code>&lt;C-W&gt;N</code>（注意大写）或 <code>&lt;C-\&gt;&lt;C-N&gt;</code> 退出终端作业模式，进入终端普通模式。这时终端窗口变成一个普通的文本窗口（终端缓冲区），不再显示色彩，但可以像普通的只读窗口一样自由使用，只是不能修改其中的内容而已。按下 a 或 i 可重新激活终端模拟器，进入终端作业模式。</li>
<li><code>&lt;C-W&gt;"</code> 后面跟寄存器号，表示粘贴该寄存器中的内容到终端里。</li>
<li><code>&lt;C-W&gt;:</code> 相当于普通窗口中的 :，执行命令行模式的命令。</li>
<li><code>&lt;C-W&gt;.</code> 可以给终端窗口发送一个普通的 Ctrl-W。</li>
<li><code>&lt;C-W&gt;&lt;C-\&gt;</code> 可以给终端窗口发送一个普通的 Ctrl-\。</li>
<li>大部分的 <code>&lt;C-W&gt;</code> 开始的命令仍然可以使用，如窗口跳转命令（后面跟 j、k 等）、窗口大小调整命令（后面跟 +、_ 等），等等。</li>
</ul>
<p>需要注意，终端模拟器里的光标只能用正常终端里的光标移动键来移动，比如在 Bash 默认配置下，可以用 <code>&lt;C-A&gt;</code> 或 <code>&lt;Home&gt;</code> 移到行首，用 <code>&lt;C-E&gt;</code> 或 <code>&lt;End&gt;</code> 移到行尾等。在退出终端作业模式后，光标就只是普通文本窗口的光标，不会影响终端模式里的光标位置——在你按下 a 或 i 时，光标还是在原来的位置，而不是退出终端作业模式后你移动到的新位置。你也不能修改终端缓冲区中的内容。只要稍微仔细想一想，你就知道这些是完全符合逻辑的。</p>
<p>当你从终端窗口切到另外一个窗口时，终端窗口里面的程序仍然在继续运行；如果你不退出终端作业模式的话，终端窗口里面的内容也会持续更新，跟正常的终端行为一致。要结束终端运行的话（而不只是临时退出终端模式），也跟普通的终端情况一下，可使用 exit 命令或 <code>&lt;C-D&gt;</code>。如果由于某种原因无法正常退出终端的话，则可以使用 <code>&lt;C-W&gt;&lt;C-C&gt;</code> 来强行退出。</p>
<h3 id="16-2-使用提示"><a href="#16-2-使用提示" class="headerlink" title="16.2 使用提示"></a>16.2 使用提示</h3><p>如果你觉得自己不会在终端里另外启动 Vim，似乎也就很少有机会用到 <esc> 了，那我们干吗不把这个键用作退出终端作业模式呢？说干就干：</esc></p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim">tnoremap <span class="token operator">&lt;</span>Esc<span class="token operator">&gt;</span>      <span class="token operator">&lt;</span>C<span class="token operator">-</span>\<span class="token operator">&gt;</span><span class="token operator">&lt;</span>C<span class="token operator">-</span><span class="token keyword">N</span><span class="token operator">&gt;</span>
tnoremap <span class="token operator">&lt;</span>C<span class="token operator">-</span>V<span class="token operator">&gt;</span><span class="token operator">&lt;</span>Esc<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>Esc<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>前缀 t 表示在终端作业模式下的键映射。我们把 <code>&lt;Esc&gt;</code> 映射到我们上面说的退出终端作业模式的快捷键；同时，我们又把 <code>&lt;C-V&gt;&lt;Esc&gt;</code> 这一在终端里等价于 <code>&lt;Esc&gt;</code> 的按键组合映射为 <code>&lt;Esc&gt;</code>，这样万一我们需要 <code>&lt;Esc&gt;</code>，仍然可以用一种较为自然的方式获得这个按键。</p>
<p>遗憾的是，在 Unix 终端的情况下，很多功能键本身包含 <esc>，因而会误触发这个键映射。对于这种情况，我们使用下面的键映射，用连按两下 <esc> 退出终端作业模式效果更好：</esc></esc></p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim">tnoremap <span class="token operator">&lt;</span>Esc<span class="token operator">&gt;</span><span class="token operator">&lt;</span>Esc<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>C<span class="token operator">-</span>\<span class="token operator">&gt;</span><span class="token operator">&lt;</span>C<span class="token operator">-</span><span class="token keyword">N</span><span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>此外，对于大部分人而言（像 Bram 这样，用 Vim 调试 Vim，不属于大众需求吧），在 Vim 的终端模式里启动 Vim，恐怕是失误的可能性最大。为了防止这样的失误发生，我们可以在 Vim 启动时检查一下，检测这种嵌套的 Vim 使用。你只需要把下面的代码加到 vimrc 配置文件的开头即可：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">if</span> <span class="token function">exists</span><span class="token punctuation">(</span><span class="token string">'$VIM_TERMINAL'</span><span class="token punctuation">)</span>
  <span class="token keyword">echoerr</span> <span class="token string">'Do not run Vim inside a Vim terminal'</span>
  <span class="token keyword">quit</span>
<span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="16-3-终端的用途"><a href="#16-3-终端的用途" class="headerlink" title="16.3 终端的用途"></a>16.3 终端的用途</h3><p>我是这么理解的：</p>
<ol>
<li><p><strong>方便</strong>。特别在远程连接的时候，有可能新开一个连接在某些环境里需要特别的认证，比较麻烦。即使连接没有任何障碍，你总还需要重新 cd 到工作目录里吧？而如果在一个现有的 Vim 会话里开一个新的终端，可以一个命令搞定，然后用你已经很熟悉的 Vim 命令在不同的窗口或标签页里切换。</p>
</li>
<li><p><strong>文本</strong>。我们可以从终端作业模式切换到终端普通模式，然后用我们熟悉的 Vim 命令来对缓冲区中的文本进行搜索、复制等处理工作。</p>
</li>
<li><p><strong>控制</strong>。你可以发送命令给终端，也可以读取终端屏幕上的信息。这样，事实上就打开了一片新天地，可以在 Vim 里做很多之前做不到的事情，比如，用 Vim 来比较两个屏幕输出的区别（<a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/terminal.html#terminal-diff">:help terminal-diff</a>）。</p>
</li>
</ol>
<p>终端窗口相关的函数名称都以 <code>term_</code> 打头（可以查看帮助文件<a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/terminal.html#terminal-function-details">:help terminalfunction-details</a>）。比如，如果我们想要用程序向缓冲区编号为 2（可以用 :ls 和 :echo term_list() 等命令来检查）的终端发送 ls 命令来显示当前目录下的文件列表的话，我们可以使用（注意转义字符序列要求使用双引号）：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">call</span> <span class="token function">term_sendkeys</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"ls\n"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>下面这个比较无聊的例子，可以用来获取 ~/.vim 目录下的文件清单：</p>
<pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">let</span> term_nbr <span class="token operator">=</span> <span class="token function">term_start</span><span class="token punctuation">(</span><span class="token string">'bash'</span><span class="token punctuation">)</span>
<span class="token keyword">call</span> <span class="token function">term_wait</span><span class="token punctuation">(</span>term_nbr<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> line_pos1 <span class="token operator">=</span> <span class="token function">term_getcursor</span><span class="token punctuation">(</span>term_nbr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token keyword">call</span> <span class="token function">term_sendkeys</span><span class="token punctuation">(</span>term_nbr<span class="token punctuation">,</span> <span class="token string">"ls ~/.vim|cat\n"</span><span class="token punctuation">)</span>
<span class="token keyword">call</span> <span class="token function">term_wait</span><span class="token punctuation">(</span>term_nbr<span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> line_pos2 <span class="token operator">=</span> <span class="token function">term_getcursor</span><span class="token punctuation">(</span>term_nbr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> line_pos1 <span class="token operator">+=</span> <span class="token number">1</span>
<span class="token keyword">while</span> line_pos1 <span class="token operator">&lt;</span> line_pos2
  <span class="token keyword">call</span> <span class="token function">add</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> <span class="token function">term_getline</span><span class="token punctuation">(</span>term_nbr<span class="token punctuation">,</span> line_pos1<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword">let</span> line_pos1 <span class="token operator">+=</span> <span class="token number">1</span>
<span class="token keyword">endwhile</span>
<span class="token keyword">call</span> <span class="token function">term_sendkeys</span><span class="token punctuation">(</span>term_nbr<span class="token punctuation">,</span> <span class="token string">"\&lt;C-D&gt;"</span><span class="token punctuation">)</span>
<span class="token keyword">while</span> <span class="token function">term_getstatus</span><span class="token punctuation">(</span>term_nbr<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">'finished'</span>
  <span class="token keyword">call</span> <span class="token function">term_wait</span><span class="token punctuation">(</span>term_nbr<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>
<span class="token keyword">endwhile</span>
exe term_nbr <span class="token operator">.</span> <span class="token string">'bd'</span>
echo <span class="token function">join</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这当然不是完成这件任务的最好方法，但上面的代码展示了终端相关函数的一些基本用法：</p>
<ol>
<li>我们用 term_start 命令创建一个新的终端，得到终端缓冲区的编号</li>
<li>我们用 term_wait 等待 100 毫秒，待其就绪</li>
<li>我们用 term_getcursor 获取光标的当前行号</li>
<li>我们用 term_sendkeys 发送一个命令到终端上；ls 之后用 cat 是为了防止 ls 看到输出是终端而产生多列的输出</li>
<li>然后我们等待命令执行完成并更新终端</li>
<li>我们获取光标的当前位置，然后用 term_getline 获得上一次的行号和这一次的行号之间的行的内容，放到变量 result 里</li>
<li>我们然后发送一个 <code>&lt;C-D&gt;</code> 到终端，结束作业</li>
<li>然后我们等待到 term_getstaus 返回的状态成为 ‘finished’，即终端作业已经执行结束</li>
<li>最后我们用缓冲区编号加 bd 命令删除缓冲区（所以屏幕上我们看不到这个终端窗口），并用换行符作为分隔符打印 ls 返回的内容</li>
</ol>
<p>你可以实际测试一下这个脚本，体会一下这些基本功能。比如，可以把脚本存盘为 test.vim，然后用 :so % 来运行。</p>
<h3 id="16-4-GDB-支持"><a href="#16-4-GDB-支持" class="headerlink" title="16.4 GDB 支持"></a>16.4 GDB 支持</h3><p>Vim 通过一个内置的插件，就可以提供 GDB 的调试支持了。我们可以通过 :packadd termdebug 命令来加载这个插件，然后通过 :Termdebug 可执行程序名称 来调试一个可执行程序。</p>
<p>下面这个动图可以说明最主要的流程：</p>
<p><img src="/images/《Vim实用技巧必知必会》学习笔记/在Vim里进行调试的过程示例.gif" alt="在Vim里进行调试的过程示例"></p>
<p>我简要说明一下需要注意的几点：</p>
<ul>
<li>:Termdebug 命令会把屏幕分成三个区域，从上到下分别是 gdb 命令行，程序输出，以及含调试控制按钮的源代码窗口。</li>
<li>在最上面的 gdb 窗口中，我们可以输入 gdb 的命令，但程序的输出和纯终端使用 gdb 的情况不同，是在中间的窗口输出的。</li>
<li>最下面的的源代码窗口里，我们有五个按钮可以用，允许习惯图形界面的用户使用鼠标进行操作。我们也可以使用鼠标右键直接在源代码行上设置断点。（当然，我们仍然可以在最上面的 gdb 窗口用命令来完成这些任务。）</li>
<li>鼠标在变量上悬停时，可以显示变量的值。只要 gdb 能打印的信息，它就能用浮动提示显示出来。这比手工使用 gdb 的 p 命令还是要方便多了。</li>
</ul>
<p>还有一个需要稍微注意的地方是，如果你在不同的作用域有两个同名变量，那浮动提示只能显示当前作用域的变量的信息，即使你把光标放到不在当前作用域的变量上也是如此。这点上，Vim 还是比较笨的——毕竟它不理解代码。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://kibazen.cn" rel="external nofollow noreferrer">Kiba Amor</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                    </span>
                <span class="reprint-info">
                    <a href="https://kibazen.cn/vim-shi-yong-ji-qiao-bi-zhi-bi-hui-xue-xi-bi-ji/">https://kibazen.cn/vim-shi-yong-ji-qiao-bi-zhi-bi-hui-xue-xi-bi-ji/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY-NC-ND 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://kibazen.cn" target="_blank">Kiba Amor</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                                    <span class="chip bg-color">极客时间</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="qq,wechat,weibo,douban" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/vim-shi-yong-ji-qiao-bi-zhi-bi-hui-xue-xi-bi-ji/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/3.jpg" class="responsive-img" alt="《Vim实用技巧必知必会》学习笔记">
                        
                        <span class="card-title">《Vim实用技巧必知必会》学习笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-01-23
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                    学习笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                        <span class="chip bg-color">极客时间</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/cheng-xu-yuan-jin-jie-gong-lue-xue-xi-bi-ji/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/18.jpg" class="responsive-img" alt="《程序员进阶攻略》学习笔记">
                        
                        <span class="card-title">《程序员进阶攻略》学习笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-01-11
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                    学习笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                        <span class="chip bg-color">极客时间</span>
                    </a>
                    
                    <a href="/tags/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/">
                        <span class="chip bg-color">职业规划</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (true) {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 木叶禅<br />'
            + '文章作者: Kiba Amor<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者木叶禅所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('2'),
            headingSelector: 'h2, h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2022</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">Kiba Amor</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">778.2k</span>&nbsp;字
            
            
            
            
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/kibaamor" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>









    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=562236616" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 562236616" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>





    <a href="https://www.zhihu.com/people/kibaamor" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/kibaamor" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    

    

    

	
    

    

    

    
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
