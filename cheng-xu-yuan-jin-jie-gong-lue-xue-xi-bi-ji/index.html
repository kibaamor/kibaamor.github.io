<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <meta name="keywords" content="《程序员进阶攻略》学习笔记, kiba, zen, amor, kibazen, kibaamor, 木叶, 木叶禅">
    <meta name="description" content="一个普通游戏程序员的博客">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>《程序员进阶攻略》学习笔记 | 木叶禅</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/css/my.css">

    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="木叶禅" type="application/atom+xml">
</head>



   <style>
    body{
       background-image: url(/medias/background.jpg);
       background-repeat:no-repeat;
       background-size:cover;
       background-attachment:fixed;
    }
</style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">木叶禅</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/leetcode/" class="waves-effect waves-light">
      
      <i class="fas fa-code" style="zoom: 0.6;"></i>
      
      <span>LeetCode</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/learn/" class="waves-effect waves-light">
      
      <i class="fas fa-book" style="zoom: 0.6;"></i>
      
      <span>学习</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tool/" class="waves-effect waves-light">
      
      <i class="fas fa-toolbox" style="zoom: 0.6;"></i>
      
      <span>工具</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories/" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags/" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about/" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">木叶禅</div>
        <div class="logo-desc">
            
            一个普通游戏程序员的博客
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/leetcode/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-code"></i>
			
			LeetCode
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/learn/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-book"></i>
			
			学习
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tool/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-toolbox"></i>
			
			工具
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    
<script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = 'f65e070788a2647953051a7a1b70ada7fd2b3f70cd4d93c977207f5b762987d4';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/18.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">《程序员进阶攻略》学习笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                                <span class="chip bg-color">极客时间</span>
                            </a>
                        
                            <a href="/tags/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/">
                                <span class="chip bg-color">职业规划</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                学习笔记
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-01-11
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2022-01-13
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    35.5k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    119 分
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="一、开篇词"><a href="#一、开篇词" class="headerlink" title="一、开篇词"></a>一、开篇词</h2><h3 id="开篇词-程序行知：走在同样的路上，遇见自己的风景"><a href="#开篇词-程序行知：走在同样的路上，遇见自己的风景" class="headerlink" title="开篇词 | 程序行知：走在同样的路上，遇见自己的风景"></a>开篇词 | 程序行知：走在同样的路上，遇见自己的风景</h3><p>这是一个关于路径与行路的专栏。</p>
<p><strong>有时选择对了合适的路，比光顾着赶路要重要得多。</strong></p>
<p><img src="/images/《程序员进阶攻略》学习笔记/成长路径.webp" alt="成长路径"></p>
<p>这是一条成长线的表意图，有两个部分：图上左侧的路径，是匹配不同成长阶段，对应不同职业角色；右侧是一条由不同成长阶段组成的成长线，包括如下：</p>
<ol>
<li>征途：启程之初</li>
<li>修炼：程序之术</li>
<li>修行：由术入道</li>
<li>徘徊：道中彷徨</li>
<li>寻路：路在何方</li>
<li>蜕变：破茧成蝶</li>
</ol>
<p>“启程之初”，是你刚踏上程序之路面临的一些问题和感悟。“程序之术”，是你工作早期的主要内容，以修炼编程技能为主。除了编程写代码，还有很多其他的内容，这是另外一个维度的修行之路，也即 “由术入道”。</p>
<p>工作数年，成长到一定阶段，你可能会面临一个成长平台期的困扰，在此就进入了 “道中彷徨” 的徘徊期。这些困扰和彷徨很多都关乎选择，这期间是你发出 “路在何方” 之问的寻路期。最后，你坚定了道路，继续前行，前面的路上还有一道 “断层”，突破之后你将会蜕变，最终 “破茧成蝶”。</p>
<p><img src="/images/《程序员进阶攻略》学习笔记/大纲.webp" alt="大纲"></p>
<h2 id="二、征途：启程之初"><a href="#二、征途：启程之初" class="headerlink" title="二、征途：启程之初"></a>二、征途：启程之初</h2><h3 id="01-初心：为什么成为一名程序员？"><a href="#01-初心：为什么成为一名程序员？" class="headerlink" title="01 | 初心：为什么成为一名程序员？"></a>01 | 初心：为什么成为一名程序员？</h3><ol>
<li><p>⾸次接触</p>
<p> 初⼼未有。</p>
</li>
<li><p>选择专业</p>
<p> 初⼼已有，但却是混乱的。</p>
</li>
<li><p>转换专业</p>
<p> 初⼼虽已不乱，但依然未明。</p>
</li>
<li><p>转换⾏业</p>
<p> 初⼼才算渐渐明了。</p>
</li>
<li><p>⼼明⾏远</p>
<p> 作者过去18年的成⻓线</p>
<p> <img src="/images/《程序员进阶攻略》学习笔记/作者过去18年的成长线.png" alt="作者过去18年的成长线"></p>
</li>
</ol>
<h3 id="02-初惑：技术方向的选择"><a href="#02-初惑：技术方向的选择" class="headerlink" title="02 | 初惑：技术方向的选择"></a>02 | 初惑：技术方向的选择</h3><ol>
<li><p>选择语⾔</p>
<p> 选择技术⽅向，从某种意义上讲就是选择语⾔。</p>
<p> 要是我来选，我会如何选择语⾔呢？我会选择那些展现出蓬勃⽣命⼒的语⾔。</p>
<p> 只熟悉语⾔本身是远远不够的，其实是要熟悉整个⽣态圈。</p>
</li>
<li><p>选择回报</p>
<p> 选择技术⽅向，选择语⾔，本质都是⼀种投资。</p>
<p> 选择确定性的回报，要⽐抱着赌⼀把的⼼态更可取。看看当前的市场需求是什么，最需要什么，以及⻓期需要什么。</p>
<p> ⽐如，今天技术的热潮在⼈⼯智能、机器学习、区块链等上⾯，这是市场最需要的，⽽市场给的价格也是最⾼的。所以，你应该投⼊这⾥么？先别头脑发热，看看⾃⼰的基础，能否翻越⻔槛，及时上得了⻋吗？</p>
<p> 技术的选择，都是赚取⻓期回报，短期的波动放在⻓期来看终将被抵消掉，成为时代的⼀朵⼩浪花。</p>
</li>
<li><p>选择⾏业</p>
<p> 搞清楚了语⾔、技术⽅向和回报的关系后，最后做出选择的⽴⾜点通常会落在⾏业上。</p>
<p> 选语⾔，就是选职业，⽽选职业⾸先选⾏业。</p>
<p> 先想想⾃⼰想从事哪个⾏业的软件开发；然后，再看看：这个⾏业的现状如何？⾏业的平均增速如何？和其他⾏业相⽐如何？这个⾏业⾥最好的公司相⽐⾏业平均增速⼜如何？最后，再看看这些最好的公司都⽤些什么样的技术栈和语⾔。如果你想进⼊这样的公司，那就很简单了，就选择学这样的技术和语⾔。</p>
</li>
</ol>
<h3 id="03-初程：带上一份技能地图"><a href="#03-初程：带上一份技能地图" class="headerlink" title="03 | 初程：带上一份技能地图"></a>03 | 初程：带上一份技能地图</h3><p>在程序的技能地图中，可以从两个不同程度的维度来说明：</p>
<ul>
<li>掌握：意味着是一开始就要求熟练掌握的硬技能，这是生存之本。而至于掌握的深度，是动态的，倒是可以在行进过程中不断去迭代加深。</li>
<li>了解：相对掌握不是必需，但也需要达到知其然的程度，甚至知其所以然更好。</li>
</ul>
<ol>
<li><p>掌握</p>
<ol>
<li><p>开发平台</p>
<p> 开发平台，它包括一种编程语言、附带的平台生态及相关的技术。开发平台决定了你会成为什么类型和方向的程序员。比如：服务端、客户端或前端开发等。其中进一步细分客户端还可以有 Windows、Mac、iOS 和 Android 等不同的平台。</p>
<ol>
<li>编程语言</li>
<li>平台生态</li>
</ol>
</li>
<li><p>常用算法</p>
<p> 算法，表达的是一个计算的动态过程，它引入了一个度量标准：时空复杂度。</p>
<p> 结合工作实际的业务场景，我们需要去设计更贴合需求的算法，而只要是算法它都受到时空复杂度的约束，而我们只是在其中进行平衡与折衷。</p>
</li>
<li><p>数据结构</p>
<p> 数据结构通常都和算法一起出现，但算法表达的是动态特性，而数据结构表达的是一种静态的结构特性。</p>
<p> 最基础和常用的数据结构：</p>
<ul>
<li>数组 Array</li>
<li>链表 Linked List</li>
<li>队列 Queues</li>
<li>堆栈 Stacks</li>
<li>散列 Hashes</li>
<li>集合 Sets</li>
<li>树 Trees</li>
<li>图 Graphs</li>
</ul>
</li>
</ol>
</li>
<li><p>了解</p>
<ol>
<li><p>数据存储</p>
<p> 如今广泛流行的数据存储系统有下面三类：</p>
<ul>
<li>SQL 关系型数据库（如：MySQL、Oracle）</li>
<li>NoSQL 非关系型数据库（如：HBase、MongoDB）</li>
<li><p>Cache 缓存（如：Redis、Memcached）</p>
<p>按了解的深度需要依次知道如下几点：</p>
</li>
<li><p>如何用？在什么场景下，用什么数据存储的什么特性？</p>
</li>
<li>它们是如何工作的？</li>
<li>如何优化你的使用方式？</li>
<li>它们的量化指标，并能够进行量化分析？</li>
</ul>
</li>
<li><p>测试方法</p>
<p> 在写代码的时候，用测试的思维与方式（提供单元测试）去审视和检测代码。</p>
<p> 开发与测试这两种相反视角的切入维度，能真正长期地提高你写代码的效率和水平。</p>
</li>
<li><p>工程规范</p>
<p> 最基础的工程规范是代码规范，包括两个方面：</p>
<ul>
<li>代码结构</li>
<li>代码风格</li>
</ul>
</li>
<li><p>开发流程</p>
<p> 在开发流程方法论上，敏捷基本已经横扫天下，所以我们至少要了解下敏捷开发方法论。</p>
<p> 先了解，再优化。</p>
</li>
<li><p>源码管理</p>
<p> 至少要了解 Git，并用好它。</p>
<p> 对源码进行管理的最基本诉求有以下三点：</p>
<ul>
<li>并行：以支持多特性，多人的并行开发</li>
<li>协作：以协调多人对同一份代码的编写</li>
<li>版本：以支持不同历史的代码版本切换</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>总结</p>
<p><img src="/images/《程序员进阶攻略》学习笔记/程序员的基础技能图.webp" alt="程序员的基础技能图"></p>
<p>红色区域相对更小而聚焦，是需要掌握的部分，要求深度；蓝色区域的部分更广而泛，需要广度。</p>
<h3 id="04-初感：别了校园，入了江湖"><a href="#04-初感：别了校园，入了江湖" class="headerlink" title="04 | 初感：别了校园，入了江湖"></a>04 | 初感：别了校园，入了江湖</h3><ol>
<li><p>重剑⽆锋</p>
<p> 作为⼀名新⼊职的程序员，⾸要之事就是配备⼀台电脑。</p>
<p> 因为这是我们程序员每天使⽤最多的⼯具，如果你不在乎你的⼯具，可能你也就不会在乎你的时间和效率。</p>
</li>
<li><p>野蛮⽣⻓</p>
<p> 现在的公司基本都会给新⼊职的同学配备⼀个⽼员⼯，俗称 “导师”。</p>
<p> 我觉着新⼊⾏的同学，尽量不要去依赖此类导师制。职场的第⼀个台阶就是形成独⽴性：独⽴承担职责的能⼒。</p>
</li>
<li><p>⻘春有价</p>
<p> 思考⼀个问题：你能在⼗年后做到相⽐刚毕业时稳定收⼊增⻓⼗倍吗？也就是说现在⽉薪⼀万的⼈，⼗年后能⽉⼊⼗万吗？难，⾮常难。</p>
<p> 关于知识、⻅识和能⼒的积累与相应价值的变现，理论与现实的对⽐可能如下图，纵坐标：年薪（单位万），横坐标：⼯作年限。</p>
<p> <img src="/images/《程序员进阶攻略》学习笔记/年薪与⼯作年限概念图.png" alt="年薪与⼯作年限概念图"></p>
<p> 现实不太可能因为你的能⼒每增⻓ 20% 就会⽴刻体现在你的收⼊上。现实有两种可能：⼀种存在⼀个拐点让你的积累获得相应的价格体现，另⼀种也可能不存在这个拐点，停留在某个⽔平位。其中拐点就是我们现实中常说的机遇吧。</p>
<p> ⽆论怎样，要想获得拐点出现的机遇，可能你也只能持续努⼒地积累下去。</p>
</li>
</ol>
<h2 id="三、修炼：程序之术"><a href="#三、修炼：程序之术" class="headerlink" title="三、修炼：程序之术"></a>三、修炼：程序之术</h2><h3 id="05-架构与实现：它们的连接与分界？"><a href="#05-架构与实现：它们的连接与分界？" class="headerlink" title="05 | 架构与实现：它们的连接与分界？"></a>05 | 架构与实现：它们的连接与分界？</h3><p>把⼀种想法、⼀个需求变成代码，这叫 “实现”，⽽在此之前，技术上有⼀个过程称为设计，设计中有个特别的阶段叫 “架构”。</p>
<ol>
<li><p>是什么</p>
<p> ⾏业⾥关于软件架构的共同认知：软件系统的结构与⾏为设计。</p>
</li>
<li><p>做什么</p>
<p> 从定义上，你已知道架构是⼀种结构设计，但它同时可能存在于不同的维度和层次上：</p>
<ul>
<li>⾼维度：指系统、⼦系统或服务之间的切分与交互结构。</li>
<li>中维度：指系统、服务内部模块的切分与交互结构。</li>
<li><p>低维度：指模块组成的代码结构、数据结构、库表结构等。</p>
<p>在不同规模的团队中，存在不同维度的架构师，但不论⼯作在哪个维度的架构师，他们⼯作的共同点包括下⾯4个⽅⾯：</p>
</li>
</ul>
<ol>
<li>确定边界：划定问题域、系统域的边界。</li>
<li>切分协作：切分系统和服务，⽬的是建⽴分⼯与协作，并⾏以获得效率。</li>
<li>连接交互：在切分的各部分之间建⽴连接交互的原则和机制。</li>
<li><p>组装整合：把切分的各部分按预期定义的规则和⽅法组装整合为⼀体，完成系统⽬标。</p>
<p><strong>架构师的交付成果是⼀整套决策流，⽂档仅仅是交付载体</strong>，⽽且仅仅是过程交付产物，最终的技术决策流实际体现在线上系统的运⾏结构中。</p>
<p>实现的最终交付物是程序代码，但这个过程中会发⽣什么？⼀般会有下⾯6个⽅⾯的考虑：</p>
</li>
<li><p>选型评估；</p>
</li>
<li>程序设计；</li>
<li>执⾏效率；</li>
<li>稳定健壮；</li>
<li>维护运维；</li>
<li><p>集成部署。</p>
<p>下表为其对应的详细内容：</p>
<p><img src="/images/《程序员进阶攻略》学习笔记/做架构过程中6个方面的考虑.png" alt="做架构过程中6个方面的考虑"></p>
<p>我以交付⼀个功能需求为例，讲述下这个过程。</p>
<p>我以交付⼀个功能需求为例，讲述下这个过程。实现⼀个功能，可能全部⾃⼰徒⼿做，也可能选择⼀些合适的库或框架，再从中找到需要的API。</p>
<p>确定了合适的选型后，需要从逻辑、控制与数据这三个⽅⾯进⼀步考虑程序设计：</p>
</li>
</ol>
<ul>
<li>逻辑，即功能的业务逻辑，反映了真实业务场景流程与分⽀，包含⼤量业务领域知识。</li>
<li>控制，即考虑业务逻辑的执⾏策略，哪些可以并⾏执⾏，哪些可以异步执⾏，哪些地⽅⼜必须同步等待结果并串⾏执⾏？</li>
<li><p>数据，包括数据结构、数据状态变化和存取⽅式。</p>
<p>开始编码实现时，你进⼀步要考虑代码的执⾏效率，需要运⾏多⻓时间？要求的最⼤等待响应时间能否满⾜？并发吞吐能⼒如何？运⾏的稳定性和各种边界条件、异常处理是否考虑到了？上线后，出现 Bug，相关的监控、⽇志能否帮助快速定位？是否有动态线上配置和变更能⼒，可以快速修复⼀些问题？新上线版本时，你的程序是否考虑了兼容⽼版本的问题等？</p>
<p>最后你开发的代码是以什么形态交付？如果是提供⼀个程序库，则需要考虑相关的依赖复杂度和使⽤便利性，以及未来的升级管理。如果是提供服务，就需要考虑服务调⽤的管理、服务使⽤的统计监控，以及相关的 SLA 服务保障承诺。</p>
<p>以上，就是我针对整个实现过程⾃⼰总结的⼀个思维框架。如果你每次写代码时，都能有⼀个完善的思维框架，应该就能写出更好的代码。这个思维框架是在过去多年的编程经验中逐步形成的，在过去每次写代码时如果漏掉了其中某个部分，后来都以某种线上 Bug 或问题的形式，让我付出了代价，做出了偿还。</p>
<p>“实现”作为⼀个过程，就是不断地在交付代码流。⽽完成的每⼀⾏代码，都包含了上⾯这些⽅⾯的考虑，⽽这些⽅⾯的所有判断也是⼀整套决策流，然后固化在了⼀块块的代码中。</p>
<p>因为实现是围绕架构来进⾏的，所以架构的决策流在先，⼀定程度上决定了实现决策流的⽅向与复杂度，⽽架构决策的失误，后续会成倍地放⼤实现的成本。</p>
</li>
</ul>
</li>
<li><p>关注点</p>
<p> 架构的⼀个核⼼关注点：熵。</p>
<p> 软件系统或架构，会因为变化⽽腐坏。⼀开始清晰整洁的架构与实现随着需求的变化⽽不断变得浑浊、混乱。这也就意味着系统的“熵”在不断增⾼。</p>
<p> <img src="/images/《程序员进阶攻略》学习笔记/软件系统的熵值.png" alt="软件系统的熵值"></p>
<p> 如果你不关注、也不管理系统的“熵”值，它最终的发展趋势就如图中的蓝线，⼀直升⾼，达到临界点，届时你就不得不付出巨⼤的代价来进⾏系统架构升级。⽽实现中重构与优化的动作则是在不断进⾏减“熵”，作出平衡，让系统的“熵”值在安全的范围内波动。</p>
<p> 实现的核⼼关注点：简。</p>
<p> 简，是简单、简洁、简明、简化，都是在做减法，但不是简陋。关于实现的全部智慧都浓缩在了这⼀个字⾥，它不仅减少代码量，也减少了开发时间，减少了测试时间，减少了潜在 Bug 的数量，甚⾄减少了未来的维护、理解与沟通成本。</p>
<p> 架构关注复杂度的变化，⾃然就会带来简化，⽽实现则应当顺着把“简”做到极致。</p>
</li>
<li><p>断裂带</p>
<p> 架构与实现之间，存在⼀条鸿沟，这是它们之间的断裂带。</p>
<p> 断裂带出现在架构执⾏过程之中，落在⽂档上的架构决策实际上是静态的，但真正的架构执⾏过程却是动态的。架构师如何准确地传递架构决策？⽽开发实施的效果⼜如何能与架构决策保持⼀致？在这个过程中出现实施与决策的冲突，就⼜需要重新协调沟通讨论以取得新的⼀致。</p>
<p> 但在我发现和掌握的所有细节中，我需要做⼀个判断，哪些细节上的问题会是战略性的，⽽我有限的时间和注意⼒，必须放在这样的战略性细节上。⽽其他⼤量的实现细节也许和我想的不同，但只要没有越出顶层宏观结构定义的边界即可。系统是活的，控制演化的⽅向是可⾏的，⽽妄图掌控演化过程的每⼀步是不现实的。</p>
<p> 关注与把控边界，这就⽐掌控整个领地的范围⼩了很多，再确认领地中的战略要地，那么掌控的能⼒也就有了⽀撑。架构与实现的鸿沟会始终存在，在这条鸿沟上选择合适的地⽅建设桥梁，建设桥梁的地⽅必是战略要地。</p>
</li>
<li><p>等效性</p>
<p> 任何架构的可实现性，是完全等效的，但实现本身却不是等效的，对不同的⼈或不同的团队可实现性的可能、成本、效率是绝对不等效的。</p>
<p> 架构升级，仅仅是⼀次系统的重新布局与规划，成本和效率的重新计算与设计，“熵”的重新分布与管理。</p>
</li>
<li><p>总结</p>
<ul>
<li>架构是关注系统结构与⾏为的决策流，⽽实现是围绕架构的程序开发过程；</li>
<li>架构核⼼关注系统的“熵”，⽽实现则顺应“简”；</li>
<li>架构注重把控系统的边界与 “要塞”，⽽实现则去建⽴ “领地”；</li>
<li><p>所有架构的可实现性都是等效的，但实现的成本、效率绝不会相同。</p>
<p>架构和实现之间有⼀条断裂带，⽽让架构与实现分道扬镳的原因有：</p>
</li>
<li><p>沟通问题：如信息传递障碍。</p>
</li>
<li>⽔平问题：如技术能⼒不⾜。</li>
<li>态度问题：如偷懒⾛捷径。</li>
<li>现实问题：如⽆法变更的截⽌⽇期（Deadline）。</li>
</ul>
</li>
</ol>
<h3 id="06-模式与框架：它们的关系与误区？"><a href="#06-模式与框架：它们的关系与误区？" class="headerlink" title="06 | 模式与框架：它们的关系与误区？"></a>06 | 模式与框架：它们的关系与误区？</h3><ol>
<li><p>设计模式</p>
<p> 在我看来，模式是前⼈解决某类问题⽅式的总结，是⼀种解决问题域的优化路径。但引⼊模式也是有代价的。设计模式描述了抽象的概念，也就在代码层⾯引⼊了抽象，它会导致代码量和复杂度的增加。⽽衡量应⽤设计模式付出的代价和带来的益处是否值得，这也是程序员 “⽕候” 能⼒另⼀层⾯的体现。</p>
</li>
<li><p>开发框架</p>
<p> ⼀个框架是⼀个可复⽤的设计组件，它统⼀定义了⾼层设计和接⼝，使得从框架构建应⽤程序变得⾮常容易。因此，框架可以算是打开“快速开发”与“代码复⽤”这两扇⻔的钥匙。</p>
<p> 但若不巧，哪天某个框架在某些情况下出现了问题，在搞不懂框架原理的情况下，就总会有⼈惊慌失措。</p>
<p> 如今，框架带来的束缚在于，同⼀个问题，会有很多不同框架可供选择。如何了解、评估、选择与取舍框架，成了新的束缚。</p>
<p> 框架，既是钥匙，也是枷锁，既解放了我们，也束缚着我们。</p>
</li>
<li><p>两者关系</p>
<p> 框架和模式的共同点在于，它们都提供了⼀种问题的重⽤解决⽅案。其中，框架是代码复⽤，模式是设计复⽤。</p>
<p> 框架采⽤了⼀种结构化的⽅式来对特定的编程领域进⾏了规范化，在框架中直接就会包含很多模式的应⽤、模式的设计概念、领域的优化实践等，都被固化在了框架之中。框架是程序代码，⽽模式是关于这些程序代码的知识。</p>
</li>
</ol>
<h3 id="07-多维与视图：系统设计的思考维度与展现视图"><a href="#07-多维与视图：系统设计的思考维度与展现视图" class="headerlink" title="07 | 多维与视图：系统设计的思考维度与展现视图"></a>07 | 多维与视图：系统设计的思考维度与展现视图</h3><p>UML 是⼀种类似于传统⼯程设计领域 “三视图” 的尝试，但却⼜远没有达到 “三视图” 的精准。</p>
<p>在多年的⼯程实践中，我逐渐得到了⼀些维度的视图，下⾯就以我近些年⼀直在持续维护、设计、演进的系统（京东咚咚）为例来简单说明下。</p>
<ol>
<li><p>组成视图</p>
<p> 组成视图，表达了系统由哪些⼦系统、服务、组件部分构成。</p>
<p> <img src="/images/《程序员进阶攻略》学习笔记/组成视图示例.png" alt="组成视图示例"></p>
<p> 每⼀类服务提供逻辑概念上⽐较相关的功能，⽽每⼀个微服务⼜按照如下两⼤原则进⾏了更细的划分：</p>
<ul>
<li>单⼀化：每个服务提供单⼀内聚的功能集。</li>
<li><p>正交化：任何⼀个功能仅由⼀个服务提供，⽆提供多个类似功能的服务。</p>
<p>如上，就是我们系统的服务组成视图，⽤于帮助团队理解整体系统的宏观组成，以及个⼈的具体⼯作内容在整个系统中的位置。</p>
<p>了解了服务的组成，进⼀步⾃然就需要了解服务之间的关系与交互。</p>
</li>
</ul>
</li>
<li><p>交互视图</p>
<p> 交互视图，表达了系统或服务与外部系统或服务的协作关系，也即：依赖与被依赖。</p>
<p> 由于咚咚系统的业务场景繁多，拆分出来的服务种类也⽐较多，交互关系复杂。所以可以像地图⼀样通过不同倍率的缩放视⻆来表达和观察服务之间的交互关系。</p>
<p> 如下图，是⼀张宏观⼤倍率的整体交互视图示例。它隐藏了内部众多服务的交互细节，强调了终端和服务端，以及服务端内部交互的主要过程。这⾥依然以地图作类⽐，它体现了整体系统主⼲道场景的运动过程。⽽每⼀个服务本身，在整体的交互图中，都会有其位置，有些在主⼲道上，⽽有些则在⽀线上。</p>
<p> <img src="/images/《程序员进阶攻略》学习笔记/交互视图示例.png" alt="交互视图示例"></p>
<p> 如果我们把⽬光聚焦在⼀个服务上，以其为中⼼的表达⽅式，就体现了该服务的依赖协作关系。所以，可以从不同服务为中⼼点出发，得到关注点和细节更明确的局部交互细节图，⽽这样的细节图⼀般掌握在每个服务开发者的脑中。当我们需要写关于某个服务的设计⽂档时，这样的局部细节交互图也应该是必不可少的。</p>
<p> 在逻辑的层⾯了解了服务间的协作与交互后，则需要更进⼀步了解这些服务的部署环境与物理结构。</p>
</li>
<li><p>部署视图</p>
<p> 部署视图，表达系统的部署结构与环境。</p>
<p> 部署视图，从不同的⼈员⻆⾊出发，关注点其实不⼀样，不过从应⽤开发和架构的⻆度来看，会更关注应⽤服务实际部署的主机环境、⽹络结构和其他⼀些环境元素依赖。下⾯是⼀张强调服务部署的机房结构、⽹络和依赖元素的部署图示例。</p>
<p> <img src="/images/《程序员进阶攻略》学习笔记/部署视图示例.png" alt="部署视图示例"></p>
<p> 部署视图本身也可以从不同的视⻆来画，这取决于你想强调什么元素。上⾯这张示例图，强调的是应⽤部署的 IDC 及其之间的⽹络关系，和⼀些关键的⽹络通讯延时指标。因为这些内容可能影响系统的架构设计和开发实现⽅式。</p>
<p> ⾄此，组成、交互和部署图更多是表达系统的宏观视图：关注系统组合、协作和依存的关系。但还缺乏关于系统设计或实现本身的表达，这就引出了流程和状态两类视图。</p>
</li>
<li><p>流程视图</p>
<p> 流程视图，表达系统内部实现的功能和控制逻辑流程。</p>
<p> 可能有⼈喜欢⽤常⻅的流程图来表达系统设计与实现的流程，但我更偏好使⽤ UML 的序列图，个⼈感觉更清晰些。</p>
<p> 下图是咚咚消息投递的⼀个功能逻辑流程表达，看起来就像是 UML 的序列图，但并没有完全遵循 UML 的图例语法（主要是我习惯的画图⼯具不⽀持）。⽽且，我想更多⼈即使是程序员也并不⼀定会清楚地了解和记得住 UML 的各种图例语法，所以都⽤⽂字做了补充说明，也就没必要⼀定要遵循其语法了，重点还是在于要把逻辑表达清楚。</p>
<p> <img src="/images/《程序员进阶攻略》学习笔记/流程视图示例.png" alt="流程视图示例"></p>
<p> 逻辑流程⼀般分两种：业务与控制。有些系统业务逻辑很复杂，⽽有些系统业务逻辑不复杂但请求并发很⾼，导致对性能、安全与稳定的要求⾼，所以控制逻辑就复杂了。这两类复杂的逻辑处理流程都需要表达清楚，⽽上图就是对业务功能逻辑的表达示例。</p>
<p> 除了逻辑流程的复杂性，系统维持的状态变迁很可能也是另⼀个复杂性之源。</p>
</li>
<li><p>状态视图</p>
<p> 状态视图，表达系统内部管理了哪些状态以及状态的变迁转移路径。</p>
<p> 像咚咚这样的 IM 消息系统，就⾃带⼀个复杂的状态管理场景：消息的已读/未读状态。它的复杂性体现在，它本身就处在⼀个不可控的分布式场景下，在⽤户的多个终端和服务端之间，需要保持尽可能的最终⼀致性。</p>
<p> 为什么没法满⾜绝对严格的最终⼀致性？如下图所示，IM 的 “已读/未读” 状态需要在⽤户的多个终端和服务端之间进⾏分布式的同步。按照分布式 CAP 原理，IM 的业务场景限定了 AP 是必须满⾜的，所以 C ⾃然就是受限的了。</p>
<p> <img src="/images/《程序员进阶攻略》学习笔记/状态视图示例.png" alt="状态视图示例"></p>
<p> 所有的业务系统都⼀定会有状态，因为那就是业务的核⼼价值，并且这个系统只要有⽤户使⽤，⽤户就会产⽣⾏为，⾏为导致系统状态的变迁。⽐如，IM 中⽤户发出的消息，⽤户的上下线等等都是⾏为引发的状态变化。</p>
<p> 但⽆状态服务相⽐有状态的服务和系统要简单很多，⼀个系统中不是所有的服务都有状态，只会有部分服务需要状态，我们的设计仅仅是围绕在，如何尽可能地把状态限制在系统的有限范围内，控制其复杂性的区域边界。</p>
</li>
</ol>
<h3 id="08-代码与分类：工业级编程的代码分类与特征"><a href="#08-代码与分类：工业级编程的代码分类与特征" class="headerlink" title="08 | 代码与分类：工业级编程的代码分类与特征"></a>08 | 代码与分类：工业级编程的代码分类与特征</h3><p>回顾我曾经写过的各种系统代码，按代码的作⽤，⼤概都可以分为如下三类：</p>
<ol>
<li><p>功能</p>
<p> 功能代码，是实现需求的业务逻辑代码，反映真实业务场景，包含⼤量领域知识。</p>
<p> ⼀个程序软件系统，拥有完备的功能性代码仅是基本要求。因为业务逻辑的复杂度决定了功能性代码的复杂度，所以要把功能代码写好，最难的不是编码本身，⽽是搞清楚功能背后的需求并得到正确的理解。之后的编码活动，就仅是⼀个“翻译”⼯作了：把需求“翻译”为代码。</p>
</li>
<li><p>控制</p>
<p> 控制代码，是控制业务功能逻辑代码执⾏的代码，即业务逻辑的执⾏策略。</p>
<p> 控制代码，都是与业务功能逻辑不直接相关的，但它们和程序运⾏的性能、稳定性、可⽤性直接相关。提供⼀项服务，功能代码满⾜了服务的功能需求，⽽控制代码则保障了服务的稳定可靠。</p>
<p> 有了控制和功能代码，程序系统终于能正常且稳定可靠地运⾏了，但难保不出现异常，这时最后⼀类 “运维” 型代码便要登场了。</p>
</li>
<li><p>运维</p>
<p> 运维代码，就是⽅便程序检测、诊断和运⾏时处理的代码。它们的存在，才让系统具备了真正⼯业级的可运维性。</p>
</li>
</ol>
<p>功能、控制、运维，三类代码，在现实的开发场景中优先级这样依次排序。有时你可能仅仅完成了第⼀类功能代码就迫于各种压⼒上线发布了，但你要在内⼼谨记，少了后两类代码，将来都会是负债，甚⾄是灾难。⽽⼀个满⾜⼯业级强度的程序系统，这三类代码，⼀个也不能少。</p>
<p>⽽对三类代码的设计和实现，越是优雅的程序，这三类代码在程序实现中就越是能看出明显的边界。为什么需要边界？因为，“码以类聚，⼈以群分”。功能代码易变化，控制代码固复杂，运维代码偏繁琐，这三类不同的代码，不仅特征不同，⽽且编写它们的⼈（程序员）也可能分属不同群组，有⾜够的边界与距离才能避免耦合与混乱。</p>
<h3 id="09-粗放与精益：编程的两种思路与方式"><a href="#09-粗放与精益：编程的两种思路与方式" class="headerlink" title="09 | 粗放与精益：编程的两种思路与方式"></a>09 | 粗放与精益：编程的两种思路与方式</h3><p>认识到我的编程⽅式和习惯在那⼏年已经慢慢发⽣了变化，形成了明显的两个阶段的转变。这两个阶段是：</p>
<ul>
<li>写得粗放，写得多</li>
<li>写得精益，写得好</li>
</ul>
<ol>
<li><p>多与粗放</p>
<p> ⼀个典型的粗放式编程场景⼤概是这样的：需求到开发⼿上后，开始编码，编码完成，⼈⾁测试，没问题后快速发布到线上，然后进⼊下⼀个迭代。</p>
<p> 这个阶段是必要的，它因⼈、因环境⽽异，或⻓或短。</p>
<p> 因为每做出⼀个垃圾作品，都会吸取上⼀次制作的错误教训，然后在做下⼀个作品时得到改进。</p>
<p> <strong>在通往 “更好” 的路上，总会经过 “更多” 这条路。</strong></p>
</li>
<li><p>好与精益</p>
<p> 编程的难点是，⽆论你在开始动⼿编程时看过多少有关编程理论、⽅法、哲学与艺术的书，⼀开始你还是⽆法领悟到什么是编程的正确⽅法，以及什么是“完美” 的程序。毕竟纸上得来终觉浅，绝知此事要躬⾏。</p>
<p> 别被所谓 “完美“ 的程序所困扰，只管先去盯住你要⽤编程解决的问题，把问题解决，把任务完成。</p>
<p> <strong>编程，其实⼀开始哪有什么完美，只有不断变得更好。</strong></p>
<p> ⼀个道理：<strong>好不是完美，好是⼀个过程，⼀个不断精益化的过程。</strong></p>
</li>
</ol>
<h3 id="10-炫技与克制：代码的两种味道与态度"><a href="#10-炫技与克制：代码的两种味道与态度" class="headerlink" title="10 | 炫技与克制：代码的两种味道与态度"></a>10 | 炫技与克制：代码的两种味道与态度</h3><p>代码读得多了，慢慢就会感受到好代码中有⼀种味道和品质：克制。但也会发现另⼀种代码，它也会散发出⼀种味道：炫技。</p>
<ol>
<li><p>炫技</p>
<p> 在程序员的成⻓路径上，攀登公司的晋升阶梯时，通常会采⽤同⾏评审制度，⽽作为技术⼈就容易倾向性地关注项⽬或⼯程中的技术含量与难点。</p>
<p> 这样的制度倾向性，有可能导致⼈为制造技术含量，也就是炫技了。</p>
<p> <strong>除了增加不必要的复杂性外，炫技的代码，也可能更容易出 Bug。</strong></p>
<p> 炫技是因为你想表达得不⼀样，就像平常说话，你要故意说得引经据典去彰显⾃⼰有⽂化，但其实效果不⼀定佳，因为我们更需要的是平实、易懂的表达。</p>
</li>
<li><p>克制</p>
<p> 在说克制之前，先说说什么叫不克制，写代码的不克制。</p>
<p> <strong>其实对于新技术，即使从我知道、我了解到我熟悉、我深谙，这时也还需要克制，要等待合适的时机。</strong></p>
<p> 不克制的⼀种形态是容易做出臆想的、通⽤化的假设，⽽且我们还会给这种假设安⼀个⾮常正当的理由：扩展性。不可否认，扩展性很重要，但扩展性也应当来⾃真实的需求，⽽⾮假设将来的某天可能需要扩展，因为扩展性的反⾯就是带来设计抽象的复杂性以及代码量的增加。</p>
<p> 那么，如何才是克制的编程⽅式？我想可能有这样⼀些⽅⾯：</p>
<ul>
<li>克制的编码，是每次写完代码，需要去反思和提炼它，代码应当是直观的，可读的，⾼效的。</li>
<li>克制的代码，是即使站在远远的地⽅去看屏幕上的代码，甚⾄看不清代码的具体内容时，也能感受到它的结构是⼲净整⻬的，⽽⾮ “意⼤利⾯条” 似的混乱⽆序。</li>
<li>克制的重构，是每次看到 “坏” 代码不是⽴刻就动⼿去改，⽽是先标记圈定它，然后通读代码，掌握全局，重新设计，最后再等待⼀个合适的时机，来⼀⽓呵成地完成重构。</li>
</ul>
</li>
</ol>
<h3 id="11-三阶段进化：调试，编写与运行代码"><a href="#11-三阶段进化：调试，编写与运行代码" class="headerlink" title="11 | 三阶段进化：调试，编写与运行代码"></a>11 | 三阶段进化：调试，编写与运行代码</h3><p>⼀路⾛来⼗多年后，再回溯编程之路的经历，总结编程的进化过程，⼤概会经历下⾯三个阶段。</p>
<ol>
<li><p>调试代码 Debugging</p>
<p> 编程第⼀阶段的 “调试代码 Debugging” 时期。这个时期或⻓或短，也许你曾经为各种编程⼯具或 IDE 提供的⾼级 Debug 功能激动不已，但如果你不逐渐降低使⽤ Debug 功能的频率，那么你可能很难⾛⼊第⼆阶段。</p>
</li>
<li><p>编写代码 Coding</p>
<p> 翻译讲究 “信、达、雅”，编码亦如此。</p>
<p> 那么何谓 “信、达、雅” ？它是由我国清末新兴启蒙思想家严复提出的，他在《天演论》中的 “译例⾔” 讲到：</p>
<blockquote>
<p>译事三难：信、达、雅。求其信已⼤难矣，顾信矣，不达，虽译犹不译也，则达尚焉。</p>
</blockquote>
<ol>
<li><p><strong>信，指不违背原⽂，不偏离原⽂，不篡改，不增不减，要求准确可信地表达原⽂描述的事实。</strong></p>
<p> 这条应⽤在编程上就是：程序员需要深刻地理解⽤户的原始需求。虽然需求很多时候来⾃于需求（产品）⽂档，但需求（产品）⽂档上写的并不⼀定真正体现了⽤户的原始需求。关于⽤户需求的“提炼”，早已有流传甚⼴的“福特之问”。</p>
<blockquote>
<p>福特：您需要⼀个什么样的更好的交通⼯具？</p>
<p>⽤户：我要⼀匹更快的⻢。</p>
</blockquote>
<p> ⽤户说需要⼀匹更快的⻢，你就跑去 “养” 只更壮、更快的⻢；后来⽤户需求⼜变了，说要让⻢能在天上⻜，你可能就傻眼了，只能拒绝⽤户说：“这需求不合理，技术上实现不了。”可⻅，⽤户所说的也不可 “信” 矣。只有真正挖掘并理解了⽤户的原始需求，最后通过编程实现的程序系统才是符合 “信” 的标准的。</p>
</li>
<li><p><strong>达，指不拘泥于原⽂的形式，表达通顺明⽩，让读者对所述内容明达。</strong></p>
<p> 这条应⽤在编程上就是在说程序的可读性、可理解性和可维护性。</p>
<p> 按严复的标准，只满⾜ “信” ⼀条的翻译，还不如不译，⾄少还需要满⾜ “达” 这条才算尚可。</p>
<p> 同样，只满⾜ “信” 这⼀条的程序虽然能准确地满⾜⽤户的需要，但没有 “达” 则很难维护下去。因为程序固然是写给机器去执⾏的，但其实也是给⼈看的。</p>
</li>
<li><p><strong>雅，指选⽤的词语要得体，追求⽂章本身的古雅，简明优雅。</strong></p>
<p> 雅的标准，应⽤在编程上已经从技艺上升到了艺术的追求，这当然是很⾼的要求与⾃我追求了，难以强求。⽽只有先满⾜于“信” 和 “达” 的要求，你才有余⼒来追求 “雅” 。</p>
</li>
</ol>
</li>
<li><p>运⾏代码 Running</p>
<p> 编程相对翻译，其超越 “信、达、雅” 的部分在于：翻译出来的⽂字能让⼈读懂，读爽就够了；但代码写出来还需要运⾏，才能产⽣最终的价值。</p>
<p> 写程序我们追求 “⼜快⼜好”，并且写出来的代码要符合 “信、达、雅” 的标准，但清晰定义 “多快多好” 则是指运⾏时的效率和效果。为准确评估代码的运⾏效率和效果，每个程序员可能都需要深刻记住并理解下⾯这张关于程序延迟数字的图：</p>
<p> <img src="/images/《程序员进阶攻略》学习笔记/每个程序员都应该知道的延迟数字.png" alt="每个程序员都应该知道的延迟数字"></p>
</li>
</ol>
<h3 id="12-Bug的空间属性：环境依赖与过敏反应"><a href="#12-Bug的空间属性：环境依赖与过敏反应" class="headerlink" title="12 | Bug的空间属性：环境依赖与过敏反应"></a>12 | Bug的空间属性：环境依赖与过敏反应</h3><p>从今天开始，咱们专栏进⼊ “程序之术” 中关于写代码的⼀个你可能⾮常熟悉，却也常苦恼的⼩主题：<strong>Bug</strong>。</p>
<p>技术性 Bug 可以从很多维度分类，⽽我则习惯于从 Bug 出现的 “时空” 特征⻆度来分类。可划为如下两类：</p>
<ul>
<li>空间：环境过敏</li>
<li>时间：周期规律</li>
</ul>
<ol>
<li><p>环境过敏</p>
<p> 环境，即程序运⾏时的空间与依赖。</p>
<p> 过敏在医学上的解释是：“有机体将正常⽆害的物质误认为是有害的东⻄。”⽽我对 “程序过敏反应” 的定义是：“程序将存在问题的环境当作正常处理，从⽽产⽣的异常。”⽽潜在的环境问题通常就成了程序的 “过敏原”。</p>
</li>
<li><p>应对之道</p>
<p> 应对环境过敏，⾃然要先从<strong>了解环境</strong>开始。</p>
<p> 环境那么复杂，你需要了解到何种程度呢？我觉得你⾄少必须关⼼与程序运⾏直接相关联的那⼀层环境。</p>
<p> 怎么理解呢？以后端Java 程序的运⾏为例，Java 是运⾏在 JVM 中，那么 JVM 提供的运⾏时配置和特性就是你必须要关⼼的⼀层环境了。⽽ JVM 可能是运⾏在 Linux 操作系统或者是像 Docker 这样的虚拟化容器中，那么 Linux 或 Docker 这⼀层，理论上你的关⼼程度就没太多要求，当然，学有余⼒去了解到这⼀层次，⾃是更好的。</p>
<p> <strong>收集信息</strong>，不仅仅局限于相关直接依赖环境的配置和参数，也包括⽤户输⼊的⼀些数据。</p>
</li>
</ol>
<p>整体简单总结⼀下就是：空间即环境，包括了程序的运⾏和依赖环境；环境是多维度、多层次的，你对环境的理解越全⾯、越深⼊，那么出现空间类 Bug 的⼏率也就越低；对环境的掌控有⼴度和深度两个⽅向，更有效的⽅法是先⼴度全⾯了解，再同步与程序直接相连的⼀层去深度理解，最后逐层深⼊，“各个击破”。</p>
<h3 id="13-Bug的时间属性：周期特点与非规律性"><a href="#13-Bug的时间属性：周期特点与非规律性" class="headerlink" title="13 | Bug的时间属性：周期特点与非规律性"></a>13 | Bug的时间属性：周期特点与非规律性</h3><p>Bug 有了时间属性，Bug 的出现就是⼀个概率性问题了，它体现出如下特征。</p>
<ol>
<li><p>周期特点</p>
<p> 周期特点，是⼀定频率出现的 Bug 的特征。</p>
<p> 这类 Bug 因为会周期性地复现，相对还是容易捕捉和解决。⽐较典型的呈现此类特征的 Bug ⼀般是资源泄漏问题。</p>
</li>
<li><p>⾮规律性</p>
<p> 没有规律性的 Bug，才是让⼈抓狂的。</p>
<p> 好的办法就应该是采⽤⼯具，直接引⼊代码 Profiler 等性能剖析⼯具，就可以准确地找到有性能问题的代码段，从⽽避免了看似有理却⽆效的猜测。</p>
</li>
<li><p>神出⻤没</p>
<p> 能称得上神出⻤没的 Bug 只有⼀种：<strong>海森堡 Bug（Heisenbug）</strong>。</p>
<p> 这个 Bug 的名字来⾃量⼦物理学的 “海森堡不确定性原理”，其认为观测者观测粒⼦的⾏为会最终影响观测结果。所以，我们借⽤这个效应来指代那些⽆法进⾏观测的 Bug，也就是在⽣产环境下不经意出现，费尽⼼⼒却⽆法重现的 Bug。</p>
<p> 海森堡 Bug 的出现场景通常都是和分布式的并发编程有关。</p>
</li>
</ol>
<h3 id="14-Bug的反复出现：重蹈覆辙与吸取教训"><a href="#14-Bug的反复出现：重蹈覆辙与吸取教训" class="headerlink" title="14 | Bug的反复出现：重蹈覆辙与吸取教训"></a>14 | Bug的反复出现：重蹈覆辙与吸取教训</h3><p>Bug 除了时间和空间两种属性，还有⼀个特点是和程序员直接相关的。本质重复的错误，导致⼀些 Bug 总是以不同的形态反复出现。</p>
<ol>
<li><p>重蹈覆辙</p>
<p> 重蹈覆辙的错误。</p>
<ol>
<li>粗⼼⼤意</li>
<li>认知偏差</li>
<li>熵增问题：程序规模变⼤，复杂度变⾼之后，再去修改程序或添加功能就更容易引发未知的 Bug。</li>
</ol>
</li>
<li><p>吸取教训</p>
<ol>
<li><p>优化⽅法</p>
<ul>
<li>粗⼼⼤意，可以通过开发规范、代码⻛格、流程约束，代码评审和⼯具检查等⼯程⼿段来加以避免。甚⾄相对写错别字，代码更进⼀步，通过补充单元测试在运⾏时做⼀个正确性后验，反过来去发现这类我们视⽽不⻅的低级错误。</li>
<li>认知偏差，⼀般没什么太好的⾃我发现机制，但可以依赖团队和技术⼿段来纠偏。每次掉坑⾥爬出来后的经验教训总结和团队内部分享，另外就是像⼀些静态代码扫描⼯具也提供了内置的优化实践，通过它们的提示来发现与你的认知产⽣碰撞纠偏。</li>
<li>熵增问题，业界不断迭代更新流⾏的架构模式就是在解决这个问题。微服务本质上就是将⼀个⼤系统的熵增问题，局部化在⼀个⼜⼀个的⼩服务中。⽽每个微服务都有⼀个熵增的极限值，⽽这个极限值⼀般是要低于该服务负责⼈的驾驭能⼒上限的。对于⼀个熵增接近极限附近的微服务，服务负责⼈就需要及时重构优化，降低熵的⽔平。⽽⾼⽔平和低⽔平程序员负责的服务本质差别在于熵的⼤⼩。</li>
</ul>
</li>
<li><p>塑造环境</p>
<p> 总结经验教训，加深印象避免再犯的形式。认识问题的本质，修正真正的错误。</p>
<p> <strong>建⽴和维护有利于程序员及时暴露并修正错误，挑战权威和主动改善系统的低权⼒距离⽂化氛围，这其实就是推崇扁平化管理和 “⼯程师⽂化” 的关键所在。</strong></p>
<p> ⼀旦系统出了故障⾮技术背景的管理者通常喜欢⽤流程、制度甚⾄价值观来应对问题，⽽技术背景的管理者则喜欢从技术本身的⻆度去解决当下的问题。我觉着两者需要结合，站在更⾼的维度去考虑问题：规则、流程或评价体系的制定所造成的⽂化氛围，对于错误是否以及何时被暴露，如何被修正有着决定性的影响。</p>
</li>
</ol>
</li>
</ol>
<h2 id="四、修行：由术入道"><a href="#四、修行：由术入道" class="headerlink" title="四、修行：由术入道"></a>四、修行：由术入道</h2><h3 id="15-根源：计划的愿景——仰望星空"><a href="#15-根源：计划的愿景——仰望星空" class="headerlink" title="15 | 根源：计划的愿景——仰望星空"></a>15 | 根源：计划的愿景——仰望星空</h3><p>在前⾯第 2 章节 “<strong>程序之术</strong>” 中，我已把对“<strong>设计</strong>”“<strong>编程</strong>”和“<strong>Bug</strong>”的思考与理解都分享给你了。今天开始进⼊第 3 章节，是关于成⻓修⾏中 “<strong>由术⼊道</strong>” 的部分，⽽“道”的维度众多，我就先从和个⼈成⻓最直接相关的 “<strong>计划体系</strong>” 讲起。它会有助于你⼀步⼀步⾛向你“理想的⾃⼰”，所以可别⼩看它的重要性。</p>
<ol>
<li><p>需求模型</p>
<p> 需求层次理论认为个体成⻓发展的内在⼒量是动机，⽽动机是由多种不同性质的需要所组成，各种需要之间，有先后顺序与⾼低层次之分，每⼀层次的需要与满⾜，将决定个体⼈格发展的境界或程度。 其层次模型的经典⾦字塔图示如下：</p>
<p> <img src="/images/《程序员进阶攻略》学习笔记/需求层次模型.png" alt="需求层次模型"></p>
<p> 在⼈⽣的不同阶段，会产⽣不同层次的⽬标需求。</p>
<p> 需求⾦字塔底部两层属于物质层次的 “经济基础”，⽽再往上则进⼊了更⾼精神层次的 “上层建筑”。就个体⽽⾔，⾼层次需求要⽐低层次需求具有更⼤的价值。在 “⽣存” 和 “安全” 基本满⾜的保障基础之上，我们才会更从容地向内求，更多地探求内⼼，进⽽向外索，对外去探索、发现和建⽴不同的圈层关系，以满⾜上层的社交 “归属”、获得 “尊重” 与 “⾃我实现” 的需求。</p>
<p> ⻢斯洛把底层的四类需求：⽣存、安全、归属、尊重归类为 “缺失性” 需求，它们的满⾜需要从外部环境去获得。⽽最顶层的“⾃我实现” 则属于 “成⻓性” 需求。成⻓就是⾃我实现的过程，成⻓的动机也来⾃于 “⾃我实现” 的吸引。就像很多植物具有天⽣的向阳性，⽽对于⼈，我感觉也有天⽣的 “⾃我实现” 趋向性。</p>
<p> ⼈⽣最激荡⼈⼼的时刻，就在于⾃我实现的创造性过程中，产⽣出的⼀种 “⾼峰体验” 感。正因为⼈所固有的需求层次模型，我们才有了愿望，愿望产⽣⽬标，⽬标则引发计划。</p>
</li>
<li><p>⽣涯发展</p>
<p> 在攀登需求⾦字塔的过程中，我们创造了关于⼈⽣的 “⽣涯”。⽽ “⽣涯” ⼀词最早来⾃庄⼦语：</p>
<blockquote>
<p>吾⽣也有涯，⽽知也⽆涯。以有涯随⽆涯，殆已。</p>
</blockquote>
<p> “涯” 字的原意是⽔边，隐喻⼈⽣道路的尽头，尽头已经没了路，是终点，是边界。正因如此，⼈⽣有限，才需要计划。著名⽣涯规划师古典有⼀篇⽂章《你的⽣命有什么可能？》对⽣涯提出了四个维度：⾼度、宽度、深度和温度。这⾥就借他⼭之⽟，来谈谈我的理解。</p>
<ul>
<li>⾼度：背后的价值观是影响与权⼒。代表性关键词有：追逐竞争、改变世界。</li>
<li>深度：背后的价值观是卓越与智慧。代表性关键词有：专业主义、⼯匠精神。</li>
<li>宽度：背后的价值观是博爱与和谐。代表性关键词有：多种⻆⾊、丰富平衡。</li>
<li><p>温度：背后的价值观是⾃由与快乐。代表性关键词有：⾃我认同、精彩程度。</p>
<p>每个⼈的⼈⽣发展路线都会有这四个维度，只是不同⼈的偏好、愿望和阶段不同导致了在四个维度分布重⼼的差异。在不同维度的选择，都代表了不⼀样的 “⽣涯”，每⼀种 “⽣涯” 都需要⼀定程度的计划与努⼒。</p>
<p>虽有四种维度，四个⽅向，但不代表只能选其⼀。虽然我们不太可能同时去追求这四个维度，但可以在特定的⼈⽣不同阶段，在其中⼀个维度上，给⾃⼰⼀个去尝试和探索的周期。所以，这就有了选择，有了计划。⽽计划会有开始，也会有结束，我们需要计划在⼈⽣的不同阶段，重点开始哪个维度的追求，以及⼤概需要持续的周期。</p>
<p>⼈⽣本是多维的，你会有多努⼒、多投⼊来设计并实现⾃⼰的⽣涯规划呢？不计划和努⼒⼀下，也许你永远⽆法知道⾃⼰的边界和所能达到的程度。</p>
<p>所以，总要开始计划做点啥，你才能知道⾃⼰的 “涯” 到底有多远；⽽计划就是在系统地探索⽣涯，甚⾄⼈⽣的⽆限可能性。</p>
</li>
</ul>
</li>
<li><p>回⾸⽆悔</p>
<p> 关于后悔，有研究说：“我们最后悔的是没做什么，⽽不是做过什么。”回味⼀下，这个结论也确实符合我们的感觉。</p>
<p> 若放到前⾯⻢斯洛需求⾦字塔中，“理想的⾃⼰” 就是站在顶端 “⾃我实现” 位置的那个⾃⼰；⽽ “义务的⾃⼰” 正在⾦字塔下⾯四层，挣扎于现实的处境。如果你从来没有去向 “理想的⾃⼰” 望上⼀眼，⾛上⼀步，将来终究会后悔的。事实上，研究结论也证明了这点：70% 以上的⼈都会后悔没有成为 “理想的⾃⼰”。</p>
</li>
</ol>
<p>计划，就是做选择，你在为未来的你做出选择，你在选择未来变成 “谁”。如果你还在为今天的⾃⼰⽽后悔，那就该为明天的⾃⼰做出计划了。</p>
<h3 id="16-方式：计划的方法——脚踏实地"><a href="#16-方式：计划的方法——脚踏实地" class="headerlink" title="16 | 方式：计划的方法——脚踏实地"></a>16 | 方式：计划的方法——脚踏实地</h3><p>就拿我来说，每年结束我都会做⼀次全年总结，然后再做好新⼀年的计划，⼀开始这个过程确实挺艰难且漫⻓的，因为毕竟要想清楚⼀年的计划还是挺难的。但慢</p>
<ol>
<li><p>⽬标</p>
<p> 富有成效的计划的第⼀步，便是确定⽬标。</p>
<p> 在设定⽬标这个领域，国外⼀位研究者⻢克·墨菲（Mark Murphy）曾提出过⼀种 HARD ⽅法。HARD 是 4 个英⽂词的⾸字⺟缩写：</p>
<ul>
<li>Heartfelt 衷⼼的，源⾃内⼼的</li>
<li>Animated 活⽣⽣，有画⾯感的</li>
<li>Required 必须的，需求明确的</li>
<li><p>Difficult 困难的，有难度的</p>
<p>我们为什么要⽴ HARD ⽬标？有⼀句话是这么说的：</p>
<blockquote>
<p>Easy choices, hard life. Hard choices, easy life.</p>
<p>容易的选择，艰难的⽣活；艰难的选择，轻松的⽣活。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>⽅法</p>
<p> ⽬标是愿望层⾯的，计划是执⾏层⾯的，⽽计划的⽅式也有不同的认识维度。</p>
<p> 从时间维度，可以拟定 “短、中、⻓” 三阶段的计划：</p>
<ul>
<li>短期：拟定⼀年内的⼏个主要事项、⾏动周期和检查标准。</li>
<li>中期：近 2～3 年内的规划，对⼀年内不⾜以取得最终成果的事项，可以分成每年的阶段性结果。</li>
<li><p>⻓期：我的⻓期⼀般也就在 5～7 年周期，属于我的 “⼀辈⼦” 的概念范围了，⽽ “⼀辈⼦” 当有⼀个愿景。</p>
<p>短期⼀年可以完成⼏件事或任务，中期两三年可以掌握精熟⼀⻔技能，⻓期的 “⼀辈⼦” 达成⼀个愿景，实现⼀个成⻓的⾥程碑。</p>
<p>从路径维度，订计划可以⽤⼀种 SMART ⽅法，该⽅法是百年⽼店通⽤电⽓创造的。SMART 也是 5 个英⽂词的⾸字⺟缩写：</p>
</li>
<li><p>Specific 具体的</p>
</li>
<li>Measurable 可衡量的</li>
<li>Achievable 可实现的</li>
<li>Relevant 相关的</li>
<li><p>Time-bound 有时限的</p>
<p>讲讲我如何通过 SMART 来跟踪个⼈年度计划执⾏的。按SMART ⽅式定义的计划执⾏起来都是可以量化跟踪的，我通常⽤如下格式的⼀张表来跟踪：</p>
<p><img src="/images/《程序员进阶攻略》学习笔记/计划跟踪表示意图.png" alt="计划跟踪表示意图"></p>
<p>其实，⼀年值得放进这张表的就那么⼏件事，每件事⼜可以分解为具体的⼏个可量化的任务，再分解到⼀年 50 周，就可以很明显地看出理想计划和现实路径的曲线对⽐。</p>
<p>有时你可能会觉得计划没有变化快，或者计划好的⼈⽣，过起来好机械，没劲。其实计划是准备，变化才是永恒，⽽计划就是为了应对变化。为此，我经常会把计划表按优先级排得满满的，但我永远只做那些计划表顶部最让⾃⼰感到 HARD 的事情。</p>
<p>变化来了，就把它装进计划表中，看这样的变化会排在哪个位置，和之前计划表前列的事情相⽐⼜如何。如果变化的事总能排在顶上，那么说明你的⼈⽣实际就在不断变得更精彩，做的事情也会让你更激动。⽽如果变化⽼是那些并不重要却还总是紧急的事情，⽼打断当下的计划，那么也许你就要重新审视下你当前的环境和⾃身的问题了。</p>
</li>
</ul>
</li>
</ol>
<h3 id="17-检视：计划的可行——时间与承诺"><a href="#17-检视：计划的可行——时间与承诺" class="headerlink" title="17 | 检视：计划的可行——时间与承诺"></a>17 | 检视：计划的可行——时间与承诺</h3><p>程序员啊，有⼀个特点就是偏乐观，所以对于计划的估计总是过于乐观，乐观地期待 “惊喜”，然后⼜“惊吓”地接受现实。那如何才能让计划更具可⾏性呢？⼜可以从哪些⽅⾯来检视呢？</p>
<ol>
<li><p>时间与周期</p>
<p> 计划的第⼀个影响因素是和时间有关。</p>
<p> 我的经验是：做计划不能靠模糊的感觉，⽽是需要精确理性的计算。</p>
<p> 先来计算下，⼀年，我们到底有多少时间？⼀个正常参与社会⼯作的⼈，时间⼤约会被平均分成三份。</p>
<ul>
<li>其中的 1/3（约 8 ⼩时）会被睡过去了。</li>
<li>另⼀个 1/3 你会贡献到和你的⼯作有关的各种事项中。</li>
<li><p>最后的 1/3 就是我们常说的决定⼈⽣的业余 8 ⼩时。</p>
<p>⼀年 52 周，会有⼀些法定的⻓假和个⼈的休假安排，我们先扣除两周⽤于休假。那么⼀天业余 8 ⼩时，⼀年算 350 天，那么⼀年总共有 2800 ⼩时的业余时间。但实际这 2800 ⼩时⾥还包括了你全部的周末和⼀些零星的假期，再预扣除每周 8 ⼩时⽤于休闲娱乐、处理各种社会关系事务等等，那么你还剩下 2400 ⼩时。</p>
<p>这 2400 ⼩时就是你可以⽐较⾃由地⽤来安排的全部业余时间了，这就是理性计算的结果。这样看来，⼀年实际能⽤来计划的时间并不多，需要仔细挑选合理的事项，放进计划表，并真正地执⾏。⽽实际，⼀年中你还需要把时间合理地分配在 “短、中、⻓” 三种不同周期的计划上。</p>
</li>
<li><p>短期：完成事项，获取结果，得到即时反馈与成就感（⽐如：写这个专栏）。</p>
</li>
<li>中期：学习技能，实践经验，积累能⼒（⽐如：学⼀⻔语⾔）。</li>
<li><p>⻓期：建⽴信念，达成愿景（⽐如：成⻓为⼀名架构师）。</p>
<p>你可以从时间的维度，看看你计划的时间安排是否合理分配在了不同周期的计划事项上。如果计划的事项和周期匹配错了，计划的执⾏就容易产⽣挫败感从⽽导致半途⽽废。</p>
<p>要让计划可⾏，就是<strong>选择合适的事项，匹配正确的周期，建⽴合理的预期，得到不断进步的反馈。</strong></p>
</li>
</ul>
</li>
<li><p>兴趣与承诺</p>
<p> 吴军有⼀个观点：</p>
<blockquote>
<p>凡事从 0 分做到 50 分，靠的是直觉和经验；从 50 分到 90 分，就要靠技艺了。</p>
</blockquote>
<p> 凭借兴趣驱动的尝试，结合直觉和经验就能达成 50 分的效果，⽽要到 90 分就需要靠技艺了。⽽技艺的习得是靠刻意练习的，⽽刻意练习通常来说都不太有趣。要坚持⻓期的刻意练习，唯⼀可靠的办法就是对其做出郑重的承诺。</p>
<p> 通过兴趣来启动，但要靠承诺才能有效地执⾏下去。感兴趣和做承诺的差别在于，只是感兴趣的事，到了执⾏的时候，总可以给⾃⼰找出各种各样的原因、借⼝或外部因素的影响去延期执⾏；⽽承诺就是这件事是每天的最⾼优先级，除⾮不可抗⼒的因素，都应该优先执⾏。</p>
<p> <strong>兴趣让计划更容易启动，⽽承诺让计划得以完成。</strong></p>
</li>
</ol>
<p>可⾏的计划应该是：<strong>有限的时间，适合的周期，兴趣的选择，郑重的承诺。</strong></p>
<h3 id="18-评估：计划的收获——成本与收益"><a href="#18-评估：计划的收获——成本与收益" class="headerlink" title="18 | 评估：计划的收获——成本与收益"></a>18 | 评估：计划的收获——成本与收益</h3><p>做计划⾃是为了有收获，实现愿景也好，获得成⻓也罢，每⼀份计划背后都有付出与收获的关系。如果计划的收益不能⾼于执⾏它付出的成本，那么其实这种的计划就⼏乎没有执⾏价值。</p>
<p>执⾏计划的成本通常是你付出的时间或⾦钱，但收益则没那么明确，这就需要你去仔细评估和取舍。</p>
<ol>
<li><p>成本与机会</p>
<p> 计划即选择，⽽但凡选择就有成本。</p>
<p> 从经济学思维的⻆度，做计划就是做选择，选择了某些事情；⽽选择了这些事情，就意味着放弃了另外可能做的事情，这⾥⾯的成本就是机会成本。机会成本是放弃的代价，选择这些事情从⽽放弃的其他可能选项中拥有最⾼价值的事情。</p>
<p> <strong>计划才能给你真正的⾃由，你对计划的控制⼒越强，离⾃由也就更近了。</strong></p>
</li>
<li><p>结果与收益</p>
<p> 计划得到了执⾏，产⽣了预期的结果，才会有期望的收益。</p>
<p> 在获得结果的路上，这个世界上似乎有两类⼈：</p>
<ul>
<li>第⼀类⼈，⾃⼰给⾃⼰施加约束，保持⾃律并建⽴期望；</li>
<li><p>第⼆类⼈，需要外部环境给予其约束和期望。</p>
<p><strong>要获得好的结果，你就要做第⼀类⼈，需要对⾃⼰有更⾼的期望，需要有⾃驱⼒。</strong></p>
<p>那么如何理解收益结构？以我现阶段的状态来说，已有三个直接收益结构：</p>
</li>
<li><p>专业</p>
</li>
<li>写作</li>
<li><p>理财</p>
<p>专业，⾃然是指程序专业技能，通过出售⾃⼰的时间和⼈⼒资源来获取⼀份相对稳定的⼯资收⼊来源。写作，到今天这个专栏出品后，终于可以通过作品的形式产⽣直接收益，它只需⼀次性投⼊时间来完成作品。⽽理财属于资产性收益，就是任何等价于钱的家庭动产或不动产，能产⽣利息、分红或租⾦的收⼊，它需要⻓期的收⼊结余积累。</p>
</li>
</ul>
</li>
</ol>
<h3 id="19-障碍：从计划到坚持，再到坚持不下去的时候"><a href="#19-障碍：从计划到坚持，再到坚持不下去的时候" class="headerlink" title="19 | 障碍：从计划到坚持，再到坚持不下去的时候"></a>19 | 障碍：从计划到坚持，再到坚持不下去的时候</h3><p>为什么那么多计划都半途⽽废了？在执⾏计划时，你会碰到怎样的障碍？我想从计划⽣命周期的各个阶段来分析下。</p>
<ol>
<li><p>酝酿</p>
<p> 酝酿期，是计划的早期雏形阶段；这阶段最⼤的障碍来⾃内⼼：理性与感性的冲突。</p>
</li>
<li><p>启动</p>
<p> 启动期，是计划从静⽌到运动的早期阶段；这阶段的最⼤障碍是所谓的“最⼤静摩擦⼒”。</p>
</li>
<li><p>执⾏</p>
<p> 执⾏期，是计划实现过程中最漫⻓的阶段；这阶段的最⼤障碍就是容易困倦与乏味。</p>
<p> 坚持，特别是⻓期的坚持，是需要动⼒的，⽽动⼒来⾃⽬标和意义。⽽获得⽬标与意义的最好⽅式是讲好⼀个故事。你看，成功的企业家会把未来的愿景包进⼀个美好的故事⾥，让⾃⼰深信不疑；然后再把这个故事传播出去，把所有相信这个故事的⼈聚在⼀起去追寻这个故事；最后，这个关于未来的故事就这样在现实中发⽣了。</p>
</li>
<li><p>挫败</p>
<p> 挫败，不是⼀个阶段，⽽是坚持路上的⼀些点；正是在这些点上你遭遇了巨⼤的挫败感。</p>
<p> 遭遇挫败，你会进⼊⼀种⼼情与情绪的低⾕，这个时候有很⾼的概率做出放弃的决策。⽽我的经验是，不要在挫败的情绪低⾕期进⾏任何的选择与决策。可以暂时放下这件事，等待情绪回归到正常，再重新理性地评估计划还是否该坚持。</p>
</li>
</ol>
<p>你为了做成⼀件事，定⼀个计划，在执⾏计划的过程中，在 “酝酿”“启动” 和 “执⾏” 的不同阶段都会碰到各种障碍，可能都会让你产⽣⼀种快坚持不下去了的感觉。每到此时，你都要想想清楚，哪些是真正客观的障碍？哪些是主观的退却？</p>
<h3 id="20-执行：从坚持到持续，再到形成自己的节奏"><a href="#20-执行：从坚持到持续，再到形成自己的节奏" class="headerlink" title="20 | 执行：从坚持到持续，再到形成自己的节奏"></a>20 | 执行：从坚持到持续，再到形成自己的节奏</h3><p>在执⾏过程中，容易半途⽽废的⼀个很可能的原因在于节奏出了问题。</p>
<ol>
<li><p>计划的节奏</p>
<p> ⼀个计划被制定出来后，我们通常会根据它的周期设定⼀个执⾏的节奏。</p>
<p> <strong>⻓期</strong>，就像⻓跑，跑五千⽶是⻓跑，跑⻢拉松（四万多⽶）也是⻓跑，但我们知道跑五千⽶和跑拉松肯定是⽤不同的节奏在跑。</p>
<p> ⼀个<strong>中期</strong>的⽬标，也许是⼀年。</p>
<p> ⼀个<strong>短期</strong>的⽬标，可能是⼏个⽉。</p>
<p> 你可能也遇到过，计划的节奏总是会被现实的“意外”打断，每次计划的节奏被打断后，都会陷⼊⼀种内疚的挫败感中；然后就强迫⾃⼰去完成每⽇计划列表中的每⼀项，否则不休息，最终也许是获得了数量，但失去了质量。在这样的挫败中纠结了⼏次后，你慢慢就会发现，现实总是⽐计划中的理想情况复杂多变。</p>
<p> 计划更多是给予预期和⽅向，去锚定现实的⾛向，但在⾏进的过程中，“意外” 难免会出现。所以，你要从⼼理上接受它，并从⾏为上合理地应对它。</p>
<p> 下⾯我就来说说我是怎么应对这些“意外”的。</p>
<p> 按程序员的思考⽅式，我会为所有计划中的事情创建了⼀个优先级队列，每次都只取⼀件最⾼优先级的事情来做。⽽现实总会有临时更⾼优先级的 “意外” 紧急事件插⼊，处理完临时的紧急事件，队列中经常还满满地排着很多本来计划当天要做的事情。</p>
<p> 以前，我总是尝试去清空队列，不清空不休息，但实际上这很容易让⼈产⽣精疲⼒竭的感觉。如今，我对每个计划内的事情对应了⼀个⼤致的时间段，如果被现实⼲扰，错过了这个时间段，没能做成这件计划内的事情，就跳过了，⼀天下来到点就休息，也不再内疚了。</p>
</li>
<li><p>他⼈的节奏</p>
<p> 跑⻢拉松的时候，⼀⼤群⼈⼀起出发，最后到达终点时却是稀稀拉拉。这说明每个⼈的节奏是不同的，即便同⼀⼈在不同阶段的节奏也是不⼀样。</p>
<p> 每个⼈都会有⾃⼰不同的节奏，这需要⾃⼰去摸索、练习，并慢慢提升。如果开始的节奏太快，可能很快就会疲惫、倦怠，很容易放弃；但如果⼀直节奏都很慢，则会达不到练习与提升的效果，变成了浪费时间。</p>
</li>
<li><p>⾃⼰的节奏</p>
<p> 找到并控制好⾃⼰的节奏，才能⻓期匀速地奔跑，才能更⾼效地利⽤好⾃⼰的时间和注意⼒。</p>
<p> 对于每⽇计划的执⾏节奏，我⾃⼰的经验是：<strong>把⾃⼰的时间安排成⼀段⼀段的，⾼度集中和⾼度分⼼交叉分布。</strong></p>
</li>
</ol>
<h3 id="21-信息：过载与有效"><a href="#21-信息：过载与有效" class="headerlink" title="21 | 信息：过载与有效"></a>21 | 信息：过载与有效</h3><p>⾄此，专栏已⽤6篇⽂章讲完了我关于“<strong>计划体系</strong>”这个主题的理解与思考 ，你是不是已经有点按捺不住想要赶快上路实践了？不急，接下来分享的主题是关于 “<strong>精进思维</strong>” 的，它会让你在按计划上路时，会有更好的跑步姿态，从⽽跑得更轻松、更有效率。</p>
<ol>
<li><p>现状：信息过载</p>
<p> 信息时代，作为离信息距离最近的职业之⼀，程序员应该最能感受这个时代的信息洪流与知识迭代的速度有多快。</p>
</li>
<li><p>状态：疲于奔命</p>
<p> 在⾯对这股信息与知识的洪流时，有时我们会不⾃觉地就进⼊到了 “疲于奔命”模式中。</p>
<p> 因为每天感觉有太多的信息要处理，太多的知识想学习。计划表排得满满的，似乎每天没能完成当天的计划，就会产⽣焦虑感，造成了⽇复⼀⽇的 “疲于奔命” 状态。</p>
</li>
<li><p>筛选：⼼智模型</p>
<p> ⾯对⼤量的信息和知识，我们该如何应对？这可以从两个⻆度来考虑：</p>
<ul>
<li>信息和知识本身的价值</li>
<li><p>我需要怎样的信息和知识</p>
<p>第⼀点，信息和知识的价值是⼀个主观的判断，有⼀个客观点的因⼦是获取⻔槛。如果⼀个信息或知识随处可得，⼤家都能接触到，甚⾄变得很热⻔，那么其价值可能就不⼤。</p>
<p>第⼆点，就提出了⼀个关于如何筛选信息和知识的问题。⼼理学上有⼀个 “⼼智模型” ：</p>
<blockquote>
<p>“⼼智模型” 是⽤于解释个体对现实世界中某事所运作的内在认知历程，它在有限的领域知识和有限的信息处理能⼒上，产⽣合理的解释。</p>
</blockquote>
<p>每个⼈都有这样的 “⼼智模型”，⽤来处理信息，解释⾏为，做出决策。不过只有少部分⼈会更理性地认知到这个模型的存在，⽽且不断通过吸收相关信息和知识来完善这个模型；更多的众⼈依赖的是所谓的 “感觉” 和 “直觉”。但实际上 “感觉” 和 “直觉”也是 “⼼智模型” 产⽣的⼀种快捷⽅式，只是他们没有理性地认知到这⼀点。</p>
<p>理解了以上两点，再把⼤量的信息和知识限定在我们所处的程序领域，就会得到⼀个合理的答案。</p>
<p>“⼼智” 这两个字合在⼀起是⼀个意思，分开为 “⼼” 和 “智” 两个字⼜可以分别解释为：<strong>“⼼” 是你对需要的选择，从⼼出发；“智” 是对价值的判断，智⼒的匹配。</strong></p>
</li>
</ul>
</li>
<li><p>应⽤：⼀击中的</p>
<p> 储备了信息，建⽴了知识，最终都是为了应⽤。</p>
<p> 没有⽬的的学习是徒劳的，它仅仅是在我们的头脑中流过⼀遍，流过的痕迹很快⼜会被新的信息冲刷⼲净。不管我们拥有怎样的 “最强⼤脑”，在⾯对这股信息与知识洪流时，都⼏乎可忽略不计。</p>
<p> 你得挑选那些真正值得做和学的东⻄去让⼤脑满负荷运转，但凡投⼊决⼼去做的事情，就需要百分百投⼊。这就是专注于少⽽精的东⻄，深⼊了解这些东⻄，进⼊到更深的层次上。深可以⽆⽌境，那到底多深才合适？我的答案是：<strong>让你的内⼼对取得的效果感受到满意的深度层次上</strong>。它的反⾯是：但凡⼼存疑虑，不是那么确定要全⼒投⼊的事情，⼲脆就不做了。</p>
</li>
</ol>
<p>最后，总结下在信息爆炸的时代，我们该如何有效处理、吸收和消化信息：</p>
<ul>
<li>信息过载是现实；</li>
<li>疲于奔命是陷阱；</li>
<li>⼼智模型是⽅法；</li>
<li>⼀击中的是策略。</li>
</ul>
<h3 id="22-领域：知识与体系"><a href="#22-领域：知识与体系" class="headerlink" title="22 | 领域：知识与体系"></a>22 | 领域：知识与体系</h3><p>其实个⼈的成⻓有很多⽅⾯，但对于程序员的成⻓最重要的就是知识体系的构建，这其实就是⼀个 “点线⾯体” 的演进过程。</p>
<p>下⾯我会结合⾃⼰的成⻓路线来梳理下这个体系的建⽴过程。</p>
<ol>
<li><p>点</p>
<p> 进⼊任何⼀个知识领域，都是从⼀个点开始的。</p>
<p> <img src="/images/《程序员进阶攻略》学习笔记/我的成长时间线上相关技术领域知识点.png" alt="我的成长时间线上相关技术领域知识点"></p>
<p> 在你⼊⾏后，我想你可能也会因为时代、公司或项⽬的原因，有很⼤的随机性去接触很多不同的技术点。但如果你总是这样被客观的原因驱动去随机点亮不同的 “点”，那么你终究会感到有点疲于奔命，永远追不上技术的浪潮。</p>
</li>
<li><p>线</p>
<p> 当形成的点⾜够多了后，⼀部分点开始形成线，⽽另⼀些点则在技术趋势的演进中被⾃然淘汰或⾃⼰主动战略放弃。</p>
<p> 那你到底该如何把这些零散的点串成线，形成⾃⼰的体系与⽅向呢？如下图，是我的⼀个成⻓ “T 线图”，它串联了如今我沉淀下来的和⼀些新发展的 “点”。</p>
<p> <img src="/images/《程序员进阶攻略》学习笔记/我个人的成长发展T线图.png" alt="我个人的成长发展T线图"></p>
<p> 我从成为了⼀名 Java 程序员开始，在这条 “T线” 上，先向下⾛，专注于解决业务需求碰到的技术问题。先⾃然地要向下⾄少⾛⼀层，接触 Java 的运⾏平台 JVM。⽽⼜因为早期做了⼏年电信项⽬，要和很多⽹络设备（包括各类⽹元和交换机等）通信，接触⽹络协议编程；后来⼜做了即时消息（IM）领域的⼯作，⽹络这⼀块就⼜继续增强了。⽽⽹络编程依赖于操作系统提供的 I/O 模型和 API，⾃然绕不过 OS 这⼀块。</p>
<p> 在 Java 领域⾛了多年以后，以前涉猎的技术点就逐步暗淡了。⽽再从程序员到架构师，就开始往上⾛，进⼊更纯粹的 “架构与设计” 领域，在更宽的范围和更⾼的维度评估技术⽅案，做出技术决策与权衡，设定技术演进路线。</p>
<p> 但是，再好的技术⽅案，再完美的架构，如果没有承载更有意义的业务与产品形态，它们的价值和作⽤就体现不了。所以不可避免，再往上⾛时就会去了解并评估 “业务与产品”，关注⽬标的价值、路径的有效性与合理性。</p>
<p> 在整个纵向的技术线上，最终汇总到顶点，会形成⼀种新的能⼒，也就是我对这条纵向线的 “掌控⼒”。到了这个 “点” 后，在这⾥可以横向发展，如图中，也就有了新的能⼒域：领导⼒和组织⼒。</p>
<p> ⼀个个点，构成了基本的价值点，这些点串起来，就形成了更⼤的价值输出链条。在这条路上，你也会有⼀条属于⾃⼰的 “T线”，当这条线成型后，你的价值也将变得更⼤。</p>
</li>
<li><p>⾯</p>
<p> 线的交织，将形成⾯。</p>
<p> 当我试着把我最近六年多在电商客服和即时通讯领域的⼯作画出来后，它就织就了下⾯（如图所示）的这个“⾯”。</p>
<p> <img src="/images/《程序员进阶攻略》学习笔记/我近些年工作面的分层图.png" alt="我近些年工作面的分层图"></p>
<p> 我从最早的聚焦于某个业务点和技术栈，逐步延伸扩展到整个⾯。因为 IM 这个产品本身具备很深的技术栈，⽽且也有⾜够多元化的应⽤场景，这样整个⾯就可以铺得特别宽⼴。这也是为什么我已经在这个⾯上耕耘了六年多之久。</p>
<p> 但事实上，我并不掌握这个⾯上的每个点，整个团队才会分布⼯作在整个⾯上，每个个体贡献者也只会具体⼯作在这个⾯上的某个或某些点。但我们需要去认清整个⾯的价值体系，这样才能更好地选择和切⼊⼯作的点，创造更⼤的价值。</p>
<p> ⽽有时候，我也了解到有些程序员的⼀些说法是这样的：在相对传统的⾏业，做偏业务的开发，技术栈相对固定且⽼化，难度和深度都不⾼，看不到发展⽅向，期望找到突破⼝。若你也出现这样的情况，那就说明你从事的业务开发，其单个技术点的价值上限较低，⽽选择更新、更流⾏的技术，你就是期望提升单个技术点的价值，但单个技术点的价值是相对有限的。</p>
<p> 反过来，如果很难跳脱出⾃身环境的局限，那么也可以不局限于技术，去考虑这些传统的业务价值，从技术到业务，再上升到⽤户的接⼊触达，考虑产品的场景、形态和⼈群是如何去为这些⽤户提供的服务、产⽣的价值。</p>
<p> 当你对整个业务⾯上的价值点掌握的更多，能抓住和把握核⼼的价值链条，去为更⼴、更⼤的价值负责，那么你就能克服⾃⼰的成⻓发展困境，找到了另外⼀条出路了。</p>
<p> 同时，你也为⾃⼰织就了⼀张更⼤的领域之⽹。在整个⾯形成了⼀个领域，在这个⾯上你所能掌控的每条线就是你的体系。在这条线的 “点” 上，你解决具体问题，是做解答题；但在整个⾯上你选择 “线”，是做选择题。</p>
</li>
<li><p>体</p>
<p> 体是经济体或其中的单元。</p>
<p> 你的 “⾯” 附着在什么 “体” 上决定了它的价值上限。如果 “体” 在⾼速增⻓并形成趋势，你就可能获得更快的发展。</p>
<p> 从电⼒时代到信息时代再到智能时代，互联⽹、电商、移动互联⽹，这些都是 “体” 的变化。今天互联⽹⾏业的软件⼯程师，他们⾯临的挑战和难度不⻅得⽐传统的机械或电⼒⼯程师更⼤，只不过他们所从事的 “点” 所属的 “⾯”，附着于⼀个快速崛起的 “体” 上，获得了更⼤的加速度。</p>
<p> “体” 的崛起，是时代的机遇。</p>
</li>
</ol>
<p>总结来说，就是：<strong>在领域知识体系中，“点” 是利器，“线” 是路径，“⾯” 是地图；⽽就我们个体⽽⾔，“点” 是孤⽴知识点的学习掌握，⽽ “线” 是对这些点的连接，“⾯” 则构成了完整的知识体系⽹。</strong></p>
<h3 id="23-转化：能力与输出"><a href="#23-转化：能力与输出" class="headerlink" title="23 | 转化：能力与输出"></a>23 | 转化：能力与输出</h3><p>个⼈，建⽴好了知识体系，各⽅⾯都明了了，但有时做起事来却还会感觉发挥不出来；团队，⽜⼈众多，但感觉做出的事情效果却很⼀般。</p>
<p>这类问题的症结，多就出在从体系积累到输出转化的环节，它涉及两个实体的转化问题：</p>
<ol>
<li><p>个体</p>
<p> 我们从学会⼀个知识，到能够熟练应⽤其去输出能⼒，⼤概会经历如下过程：</p>
<p> <img src="/images/《程序员进阶攻略》学习笔记/新能力从学习到输出的过程.png" alt="新能力从学习到输出的过程"></p>
<p> 所以，对于个体⽽⾔，刚建⽴起⼀个初步的知识体系，到能真正充分发挥出这个体系的⼒量，才仅仅是刚开始。</p>
</li>
<li><p>团队</p>
<p> 如果说个体的能⼒输出像出拳，那么团队的输出就像战争了。</p>
<p> 《原则》的作者是雷·达⾥奥描述了⼀个思想和实践，就是把公司当作 “机器” （原⽂是 Machine）来管理运转。在作者看来管理者就像是⼯程师，⽽⼯程师维护机器运转的⼯作状态我们都能想象到，或通过机器的运⾏仪表盘监控机器的运转状态，或通过指标优化机器的运⾏效率。⽽达⾥奥的 “机器” 就是他建⽴的管理公司的体系。</p>
<p> 曾经，我们团队有个⾼级测试⼯程师，在他晋升测试架构师级别的述职时，提到他的⼀项⼯作就是搭建测试体系来帮助团队改善测试⼯作的效率和效果。在进⾏阐述时，他完整地描述了这个体系 “机器” 的各个零部件组成，他制造的很多⼯具和系统，却缺失了关于体系的⼀些最重要的⽅⾯：</p>
<ul>
<li>这个体系是如何运转的？</li>
<li>它提供了哪些系统和仪表盘监控指标来⽀撑和反映其运转状态？</li>
<li><p>为什么这个体系能在团队⾥运转？</p>
<p>以上三个问题，就反映了 “机器” 体系的三个核⼼点：</p>
</li>
<li><p>流程规则</p>
</li>
<li>⼯具系统</li>
<li><p>规范共识</p>
<p>没有流程规则，“机器” 体系就不知该如何运转；缺乏⼯具系统⽀撑，就没法监视和控制这个体系的运转效率与效果；⽽如果未能在团队形成共识并达成规范，“机器” 体系就不可能“和谐”运转起来。所以，流程规则，建⽴其运⾏轨道；⼯具系统，⽀撑其⾼效运⾏；规范共识，形成了协调合奏。</p>
<p>团队能⼒输出就是这样⼀个 “机器” 体系运⾏的过程。那么团队的强弱就由两⽅⾯决定，⼀是团队中所有个体形成的体系⼒量之和，⼆是由流程规则、⼯具系统和规范共识共同决定的转化效率。</p>
</li>
</ul>
</li>
<li><p>转化</p>
<p> 从个体到团队，都是通过搭建体系来积蓄⼒量，再通过体系的运转来输出能⼒。</p>
<p> 这⾥的共同思维⽅式是：体系化、⼯具化。这是⼀种标准的⼯程师思维模式，巧妙的是它依然可以⽤在⾮⼯程的领域。体系，从⼯程维度看就像⽣产流⽔线，⽽体系的运转就是开动了⽣产流⽔线。搭建并调校出⼀条⾼转化输出能⼒的体系⽣产线，是真正具有核⼼竞争⼒和护城河的事情。</p>
</li>
</ol>
<p>个体和团队的强弱，⼀⽅⾯取决于我们在体系中积蓄的⼒量的总量，另⼀⽅⾯在于体系运作的转化输出率。体系决定了⼒量的总量，⽽转化决定了拳拳到⾁的痛感。</p>
<h3 id="24-并行：工作与学习"><a href="#24-并行：工作与学习" class="headerlink" title="24 | 并行：工作与学习"></a>24 | 并行：工作与学习</h3><p>该如何在⼯作的同时，保持学习，并持续成⻓与进阶呢？我想，可以先从分析“程序员的⼯作本质是什么”开始着⼿。</p>
<ol>
<li><p>⼯作</p>
<p> 程序员的主要⼯作是：编程，产出代码，完成需求，交付程序系统。</p>
<p> 程序员按其⼯作技能和经验，⼤体⼜分为三个阶段：初级、中级和⾼级。这三个级别的程序员的主要⼯作都是编程与产出代码，产出代码的数量也许相差不⼤，但产出的代码属性就可能有明显差别。</p>
<p> 什么是代码属性？它包括资产与负债两类。由⼤量初级程序员产出的代码并以此构建的软件系统，如果最终能完成交付，那么很可能资产和负债性基本持平。</p>
<p> 从初、中级⾛向⾼级程序员，就不仅仅是交付代码，完成⼯作，还要有后续的更⾼要求。如：达成品质、优化效率。⽽在不断晋级的路上，跨越的⻔槛就在于此，很多⼈⽐较容易被卡在不断地在完成⼯作，但却没有去反思、沉淀、迭代并改进，导致⼀直停留在了不断重复的怪圈之中。</p>
<p> 程序员，⼯作以产出代码为主，从初级到⾼级，代码的负债属性逐步降低，资产属性不断提升，最终成为⾼品质的个⼈贡献者。⽽从完成到追求品质和完美的路上，不仅仅是靠⼯作实践的经验积累，还需要有意识地持续学习。</p>
</li>
<li><p>学习</p>
<p> 持续学习，是让你突破不断循环怪圈的不⼆法⻔。</p>
<p> 在⼯作中，我⼀直有观察到⼀个现象，很多⼈因为离开学校后，⼯作任务多，压⼒⼤，从此就停⽌了系统地学习。在《浪潮之巅》⼀书中，吴军写道：</p>
<blockquote>
<p>国内: ⼩时候努⼒，到⼤学后就不努⼒了。</p>
<p>国外: 到⼤学后才开始努⼒，很快就超过国内学⽣。</p>
</blockquote>
<p> 学习还需要聚焦和主动选择，毕竟你的精⼒和时间都是有限的。⽽有选择性的学习就需要找出真正与你近期规划有关的学习路径。</p>
<p> 对于学习语⾔本身我觉得最⾼效的⽅法就是看⼀本该领域的经典⼊⻔书。⽐如，对于 Java 就是《Java 核⼼技术》或《Java 编程思想》，这是我称之为<strong>第⼀维度的书，聚焦于⼀个技术领域并讲得透彻清晰。</strong></p>
<p> 在有了该语⾔的⼀些实际编程和⼯程经验后，就可以看⼀些该领域<strong>第⼆维度的书</strong>，⽐如：《Effective Java》《UNIX 编程艺术》等，这些是聚焦于特定领域经验总结型的书，这类书最有价值的地⽅是其<strong>聚焦于领域的思想和思路</strong>。</p>
<blockquote>
<p>如果过早地看这类书反⽽没什么帮助，甚⾄还会可能造成误解与困扰。</p>
</blockquote>
<p> ⽽另外⼀些技能，像 Java 开发⼯作需要⼤量使⽤的开源框架⼜该如何学习？张铁蕾曾写过⼀篇《技术的正宗与野路⼦》，其中介绍了如何⽤真正 “正宗” 的⽅式去学习并快速掌握这些层出不穷的开源新框架和技术。</p>
<p> 这⾥就借⽤原⽂⾥的⼀张图（重新按统⼀⻛格绘制了下），每⼀项开源框架或技术相关的学习资料可以组织成下⾯这张⾦字塔形的结构图。</p>
<p> <img src="/images/《程序员进阶攻略》学习笔记/技术学习资料的层次结构示例图.png" alt="技术学习资料的层次结构示例图"></p>
<p> Tutorial（指南） 和 API Reference（应⽤编程接⼝参考） 层次的信息资料能帮助你快速上⼿开发，⽽ Spec（技术规范）和 Code（源代码）会帮助你深刻地理解这⻔技术。⽽其他相关的技术书籍和⽂章其实是作为⼀种补充阅读，好的技术书籍和⽂章应该有官⽅资料中未涵盖的特定经验或实践才算值得⼀读。</p>
<p> 张铁蕾在⽂中如是说：</p>
<blockquote>
<p>每当我们接触⼀项新技术的时候，都要把⼿头的资料按照类似这样的⼀个⾦字塔结构进⾏分类。如果我们阅读了⼀些技术博客和技术书籍，那么也要清楚地知道它们涉及到的是⾦字塔中的哪些部分。</p>
</blockquote>
<p> 我深以为然，关于技术学习我们不能简单地蜻蜓点⽔、复制粘贴、拿来主义，应是去建⽴你的知识 “⾦字塔”，形成体系结构，⽽每次的学习实践都是在不断完善你的 “⾦字塔”。⾄于更多技术性学习的细节，若你感兴趣的话，也可以去看看那篇⽂章。</p>
</li>
<li><p>路径</p>
<p> 保持学习，不断成⻓，⼯作也许还在重复，但成⻓却在迭代上升，然后才会有机会⾯临更多可选择的路径。</p>
<p> 程序员在攀登职场阶梯的道路上，⾛过了⾼级，后⾯还会有好些分叉路线。⽐如，转到脱离技术的纯管理岗或者技术管理岗。技术主管或架构师某种意义上都属于技术管理岗，不懂技术是做不了这两个⻆⾊的；或者继续沿着深度领域⾛，成为细分领域专家。</p>
<p> ⾯对怎么选路的问题，我近些年学习的收获是这样的：选择⾛最适合实现个⼈价值的路。这就是我的基础选择价值观。</p>
<p> 拉姆·查兰有本书叫《领导梯队》，书⾥把⼈才潜能分成三种：<strong>熟练潜能、成⻓潜能和转型潜能</strong>。原书对这三点做了详细的特征描述，我简单提炼下主要特点：</p>
<ul>
<li>熟练潜能：关注当前专业领域且⼗分熟练，但没有显示出在开发新能⼒上的努⼒，竭⼒维持现有技能。</li>
<li>成⻓潜能：按需开发新能⼒，显示出⾼于当前层级要求的其他技能，如：专业、管理、领导。</li>
<li><p>转型潜能：持续有规律地开发新能⼒，追求跨层级的挑战和机会，展现雄⼼壮志。</p>
<p>⼈⼒资源管理中的⾼潜⼈才盘点，基本就来⾃这套模型，主要就是识别出这三类潜能⼈才。“熟练潜能” 已是我们这⾏对学习的最低要求，在程序员这个技术⽇新⽉异的⾏业⾥，维持现有技能确实已经让不少⼈感觉很竭⼒了。</p>
</li>
</ul>
</li>
</ol>
<p>程序员的⼯作形式是编程产出代码，本质是完成需求，交付系统；但在⼯作中容易陷⼊不断完成的循环怪圈，要打破它，就需要你持续学习并有意识地关注交付代码的品质和属性，⼀⽅⾯提升了交付质量，另⼀⽅⾯也获得了个⼈成⻓。</p>
<p>⽽学习的路在时间上是永远持续的，在空间上也是有路径的；有效的学习需要你关注学习曲线的变化，遵循有体系的技术学习框架，匹配适合当前阶段的学习资源。</p>
<h3 id="25-时间：塑造基石习惯（上）——感知与测量"><a href="#25-时间：塑造基石习惯（上）——感知与测量" class="headerlink" title="25 | 时间：塑造基石习惯（上）——感知与测量"></a>25 | 时间：塑造基石习惯（上）——感知与测量</h3><p>⾄此，咱们专栏已⽤4篇⽂章分享了我关于“<strong>精进思维</strong>”这个主题的理解与思考，期待以后你能得⼼应⼿并游刃有余地持续进阶。</p>
<p>接下来，咱们专栏⼜会进⼊⼀个新的主题：<strong>习惯</strong>。</p>
<p>养成好的习惯能帮助我们更快地成⻓，⽽在所有的好习惯中，关于时间的习惯是其中的基础，我称之为 “基⽯”习惯。如果你的时间习惯不好，那你做其他事情的效率往往也就不⾼。</p>
<p>那么，该如何塑造好时间这块 “基⽯”呢？我觉得在有效地应⽤之前，先需要精确地感知与测量。</p>
<ol>
<li><p>感知时间</p>
<p> 曾经在知乎上看到个问题：“为何⼈随着年龄的增⼤觉得时间过得越来越快？”这个问题的⼏句答案，解答了我多年以来的困惑：</p>
<blockquote>
<p><strong>有共性的回忆趋向粘合在⼀起，标志性的回忆倾向于鹤⽴鸡群</strong>。⼼理学家认为：我们对时间的感知同时和我们的经历有关。如果⼀件事对于我们来说是 “激动⼈⼼” 的，这样的记忆在我们脑海中感觉到的时间会更⻓。</p>
</blockquote>
</li>
<li><p>测量时间</p>
<p> 有⼀本书叫《奇特的⼀⽣》，主要是关于⼀位苏联科学家柳⽐歇夫的故事，他通过⾃创的 “时间统计法” 在⼀⽣内取得了惊⼈的成就。⽽我在遇到这本书之前，已经在使⽤⼀种类似的⽅法：<strong>我会记下⼀年来经历的所有有意义的事件（除去每⽇的例⾏⼯作），我称之为 “时间⽇志”</strong>。</p>
<p> 我按每周来记录，每周⾥⾯有每天的事件记录和所花费的时间。</p>
<p> 这就是关于时间的第⼀个 “基⽯” 习惯，<strong>在精确地感知与测量时间之后，你才可能更准确地“预知” 未来</strong>。</p>
</li>
</ol>
<h3 id="26-时间：塑造基石习惯（下）——切割与构建"><a href="#26-时间：塑造基石习惯（下）——切割与构建" class="headerlink" title="26 | 时间：塑造基石习惯（下）——切割与构建"></a>26 | 时间：塑造基石习惯（下）——切割与构建</h3><p><strong>为了更有效地利⽤好你每天有限的时间，就需要你重新审视并调整你的时间切割与构建⽅式。</strong></p>
<ol>
<li><p>切割时间</p>
<p> 转换⼀下看待时间的⽅式。</p>
<blockquote>
<p>两个⼯⼈正在⼯地搬⽯头，⼀个路⼈正好⾛过，就问他们在做什么？</p>
<p>第⼀个⼯⼈说：“我在把⽯头从这边搬过来，并垒在⼀起。”</p>
<p>第⼆个⼯⼈说：“我在盖⼀座华丽的教堂，盖好后，你再来欣赏我的作品。”</p>
</blockquote>
<p> 关于时间的第⼆个 “基⽯” 习惯：<strong>将时间切割成建造你⼼中“⼤教堂”的合适“⽯材”。</strong></p>
</li>
<li><p>构建⽅式</p>
<p> 适当的构建⽅式，是指在时间的 “基⽯” 习惯之上，建⽴其他的习惯。</p>
<p> ⽐如，好些年前开始，我会从每周的时间⾥切出来⼀块，专⽤于写作，慢慢就形成了写作的习惯。这意味着，我从现有的 “时间⽯材” 中拿出了⼀部分，⽤于构建写作的习惯，然⽽ “时间⽯材” 的总量是有限的，我必须在其上建⽴有限数量的习惯，我得做出选择。</p>
<p> 任何⾏动的发⽣，都需要两种努⼒才有可能：第⼀种，是⾏动本身固有需要的努⼒，如跑步，跑⼀公⾥和跑⼗公⾥固有需要的努⼒是不等量的；第⼆种，指决策是否执⾏这种⾏动的努⼒，决定跑⼀公⾥还是跑⼗公⾥的决策意志⼒消耗，我想也不会⼀样。</p>
<p> <strong>构建习惯的⽬的，以及它们能起作⽤的原因在于：它能消除⾏动中第⼆种努⼒的决策消耗。</strong></p>
<p> 我之所以选择构建写作习惯⽽不是跑步习惯的原因是，对⼀个像我这样的程序员⽽⾔，写⽂章和写代码的感觉很接近，它就好像是⼀种刚好在程序员的能⼒边界线外不远处的事情。这样，写作⾏动所需要付出的两种努⼒，感觉都还在可以应对的范围，属于能⼒边界附近不远的事情，也是正适合⽤来扩张能⼒边界的事，有⼀种挑战的刺激感，⼜不⾄于望⽽⽣畏。</p>
<p> 所以，在时间 “基⽯” 习惯之上构建的习惯应该是你能⼒范围之外的⾏动。如果⼀项⾏动通过习惯慢慢变成了能⼒范围之内的事，那么你以后再去做类似的事，其实就不需要再付出什么决策努⼒了，也就不再需要习惯来帮忙了。</p>
<p> <strong>习惯，它的表象和形式给⼈的感觉是在重复⼀件事，但它的内在与核⼼其实是不断产⽣交付，持续的交付。</strong></p>
<p> <strong>如果你要构建⼀个习惯，就要运⽤好基因中本已存在的关于 “采集和狩猎” 的本能：⾼度专注，跨出边界，持续交付。</strong></p>
</li>
</ol>
<p>末了，我把上、下两篇的内容⼀起提炼总结为如下：</p>
<ul>
<li>要形成时间习惯，要通过有意识的感知和测量来发现时间是怎么流失的。</li>
<li>要完成建设你⼼中 “⼤教堂”，要通过切割 “时间原⽯” 来完成 “时间⽯材” 的准备。</li>
<li>在养成了时间的基⽯习惯之上，挑选和构建其他习惯来完成 “⼤教堂” 的持续建设与交付。</li>
</ul>
<h3 id="27-试试：一种“坏”习惯"><a href="#27-试试：一种“坏”习惯" class="headerlink" title="27 | 试试：一种“坏”习惯"></a>27 | 试试：一种“坏”习惯</h3><p>曾经，我碰到⼀些程序员问我：“我以前是做安卓的，现在想试着学下后端服务开发，你觉得怎样？”我⼀下⼦就卡住了，不知该如何回答才好。原因是：学习本是个好事，但前⾯加个 “试着” 似乎感觉就不太好了。</p>
<ol>
<li><p>好的出发点</p>
<p> “试⼀试” 的初衷本来就该是好的，它表达了⼀种好奇⼼，以及尝试⾛出舒适区的勇⽓。</p>
<p> 程序员这个职业，会带来⼀些职业习惯。⽐如，可能会经常性地去尝试⼀些新东⻄，然后看看它是否如预期般那样被应⽤或实现。</p>
</li>
<li><p>模糊的终点</p>
<p> 这⾥，“试⼀试”的“坏”习惯的“坏”字之所以加上双引号，就在于它的出发点本是好的，但如果终点是模糊的，那就“坏”了。</p>
<p> 近些年来，就出现过⼏轮的技术热，⽐如，刚进⼊移动互联⽹时代就⼤热、但如今已经回归常温的移动开发，曾经⼤热现已降温的云计算与⼤数据，以及还在热度中的⼈⼯智能、机器学习和区块链等。⾯对这些技术热，很多⼈都跃跃欲学之、试之。可能你也不例外。那么，到底为什么你会想去尝试⼀种新技术？是你仔细思考后的主动选择，还是说或多或少⼜被技术潮流所裹挟？</p>
<p> 好些年前，移动开发还在升温阶段时，我也不可避免地被这样⼀种潮流所裹挟过。我开始看⼀些关于 iOS 开发的书，从语⾔到⼯具。其实，尝试学习⼀种新技术并不是坏事，即使是被技术潮流所裹挟，但问题出在，这次尝试的终点在哪⾥？</p>
<p> 我是想转型成为⼀名移动开发⼯程师吗？还是说我有⼀个想法，需要开发⼀个 App 来达成？抑或我仅仅是想学习并了解下移动开发是怎么回事，从⽽进⼀步提升下技术的⼴度理解与视野？</p>
<p> 然⽽以上皆不是，我当时的尝试完全没想清楚终点在哪⼉。后来热度下来了，其他⼯作任务也多了，也就慢慢遗忘了。回过头来看，这只是浪费了⼀些时间和精⼒罢了。</p>
<p> ⼏年后，⼈⼯智能与机器学习⼜热了起来，我⼜开始尝试学习起来，但较上次不同的是，这次我把尝试的终点定义得很清楚。我不是想转型成为⼀名机器学习领域的算法⼯程师，也不是因为它很热就“随波逐流”地被潮流裹挟，我这次尝试的终点就是想搞清楚关于⼈⼯智能与机器学习的三件事：</p>
<ul>
<li>它的原理与应⽤场景；</li>
<li>它的前世今⽣；</li>
<li><p>它如今已抵达的边界。</p>
<p>搞清楚这三件事，虽不会让我成为机器学习的专家，但会提升我对于这个热⻔技术的判断⼒。因为，现实中我需要判断⼀些真实的业务场景该如何结合这样的技术，这就需要了解它们的应⽤场景和⼀些原理。</p>
<p>另外，⼀⻔新技术很少是凭空冒出来的，了解它们的前世今⽣，会更有效地知道，哪些⽅⾯已经有了成熟的⽅案，哪些地⽅还在⻘涩的探索期。再结合它当前的边界，就知道如何定义清楚需要，形成合理的技术⽅案，⽽不会产⽣过度的妄想。</p>
<p><strong>试⼀试，需要有更清晰的终点</strong>。关于终点，你也可以从下⾯⼀些⽅⾯来考虑：</p>
<p><strong>1. 验证猜想</strong>。这个部分程序员就很熟悉了，因为编程中的调试其实最重要的⽬的就是验证猜想。引⼊⼀种新技术或框架，验证 API 的调⽤结果或运⾏输出是否如你所想，即使最终否决了，那你也获得了判断的依据与知识。<br><strong>2. 收获结果</strong>。定义清楚你尝试的这件事，到底能收获怎样具体的结果。⽐如：考试，尝试的收获就是要通过。<br><strong>3. 体验过程</strong>。有时候结果并不确定，⽐如，创业的结果未必就⼀定是成功，那么这样的尝试难道就没有意义了吗？有的，因为创业的超低成功率，所以，体验过程恐怕多于收获最终结果。<br><strong>4. 理解现实</strong>。你尝试⼀个新东⻄或学习⼀个新知识，有时未必真是为了将来有朝⼀⽇能⽤上它，⽽主要是为了完善你的知识与认知体系，然后再去理解现实为什么是这样的。</p>
</li>
</ul>
</li>
<li><p>现实的路径</p>
<p> “试⼀试” 的路径是有限的，毕竟终究离不开现实的约束。</p>
<p> 有时候，你因为现实⼯作需要，可能需要不停地在各种技术栈上切换。⽽很多技术可能过了那段时间，就再也⽤不上了，这样的技术尝试难免会让⼈感觉可惜。但通过我前⾯列出的关于 “终点” 的⽅⾯，再来分析下这个现实场景。</p>
<p> ⾸先，你得⾯对现实，这样的技术尝试在现实中太多太多了，有时就是没得选择。</p>
<p> 其次，如果觉得仅仅⼀次性收获的结果，不值得你投⼊的时间和精⼒，那就可以从 “理解现实” 的⻆度去挖掘。这些知识，从学以致⽤的⻆度很快就过时了，但它们并不是完全孤⽴的，事实上计算机程序体系内的很多知识都不是完全孤⽴的，它们都有相互的联系与连接点。</p>
<p> 从理解的⻆度，这类技术切换的尝试事实上扩⼤了你的知识边界，尝试的也许是孤点，但你可以进⼀步找到它们的连接处，形成体系。因为很多现实的原因，每个⼈的起点和路径都不会⼀样，但我们都是从某⼀点开始去慢慢摸索、尝试，最终⾛出⼀个属于⾃⼰的体系来的。</p>
<p> 最后，当你有了⾃⼰的体系，也可能有了更多的尝试选择权，就可以体系为中⼼，去有选择地尝试对你更有意义或价值的事了。</p>
</li>
</ol>
<h3 id="28-提问：从技术到人生的习惯"><a href="#28-提问：从技术到人生的习惯" class="headerlink" title="28 | 提问：从技术到人生的习惯"></a>28 | 提问：从技术到人生的习惯</h3><p>提问这个习惯，我有三个层⾯的理解：</p>
<ol>
<li><p>如何问？提问之术</p>
<p> ⼀个能够回答的具体问题，⼀般都是解答题形式，表达清楚你的解答⽬的，也许你的困扰在⾼⼿那⾥根本就不存在。你只是⾛了⼀个弯路⽽已，这样不仅绕过了障碍，还获得了⼀条近（先进的）路，这就是有意义的提问。</p>
<p> ⾄此，就得到了提问的第⼀个原则：<strong>提供⾜够的信息，让⼈能够回答</strong>。</p>
<p> 草率的问题是懒惰的问题，通过搜索引擎就能简单获得；草率的问题是模糊的问题，让⼈没法回答。⽽更有意义的提问是把解答题变成选择题，提供你的选项，展现你探索了哪些路径，省去了可能产⽣的反问。也许你的某条路径已经⾮常接近答案了，只是卡在了某个点上，知道答案的⼈⼀看就明⽩了，也很容易回答。</p>
<p> 这就是提问的第⼆个原则：<strong>提供更多的选项，让⼈⽅便回答</strong>。</p>
<p> 即使你的问题能够回答，也⽅便回答，但也可能得不到回答。因为，回答问题需要有驱动⼒。提问本是⼀种索取，要让⼈有更多的回答动⼒，还需要付出。付出⼀种态度，表达感谢；付出⼀份可供交换的视⻆，建⽴讨论的基础。</p>
<p> 这就是提问的第三个原则：<strong>提供交换价值，建⽴讨论基础，表达感谢态度，让⼈乐于回答</strong>。</p>
<p> 归纳下关于提问之术的三个⽅⾯：</p>
<ol>
<li>提让⼈能够回答的问题：草率的问题，只能得到⼀个草率的答案。</li>
<li>提让⼈⽅便回答的问题：你得到的答案的好坏取决于提问的⽅式和开发答案的难度。</li>
<li>提让⼈乐于回答的问题：只索取⽽不愿思考和付出的提问者，要么什么也得不到，要么只会得到 RTFM（Read TheFucking Manual） 或 STFW（Search The Fucking Web）。</li>
</ol>
</li>
<li><p>问什么？求解之惑</p>
<p> 先从⼀个记录问题，积攒 “问什么” 的习惯开始，不断去积累并留下⼀些东⻄，将来再定时去回顾这些问题，也许就会得到意外的收获。对于程序员，总会碰到各种技术问题，就从这些最具体的问题开始，把暂时这阶段还没法回答的问题按⼀种模式记录下来，⽐如下⾯这样：</p>
<ul>
<li>问题的上、下⽂；</li>
<li>问题的具体描述；</li>
<li>问题的解决思考和思路；</li>
<li>问题的解决⽅案和具体技术或办法；</li>
<li><p>问题解决后留下的思考或其他延伸的疑问。</p>
<p><strong>当遇到暂时没有答案的问题时，先记录下来。</strong></p>
</li>
</ul>
</li>
<li><p>为何问？价值之道</p>
<p> 提问的⽬标是获得答案，⽽答案于我们⾃⼰⽽⾔是⼀种价值；为何⽽问，就是发问于我们的价值之道，最终指向的⽬的是：认清⾃我。</p>
<p> 值得问 “为何” 的问题不多，但总会遇到，它是⼀道选择题，有关我们的价值选择。我们最关⼼的是⾃⼰的命运，⽽关于命运有⼀句话是这么说的：</p>
<blockquote>
<p>选择决定命运，什么来决定选择？价值观。</p>
</blockquote>
<p> 价值观，是我们对事情做出判断，进⾏选择取舍的标准。每个⼈都有价值观，⽆论你能否清晰地定义与表述它，这些观念都决定了你的⾏为标准。</p>
<p> <strong>为何⽽问？获得答案，认清⾃我，选择⾃⼰的价值之道。</strong></p>
</li>
</ol>
<p>关于提问，今天就分享到这⾥，我总结提炼下：</p>
<ul>
<li>如何问，是关于提问的 “<strong>术</strong>”，考虑让⼈能够回答，⽅便回答和乐于回答；</li>
<li>问什么，是关于成⻓的 “<strong>惑</strong>”，去积累问题，寻找答案，并分享出来，从⽽完成了价值的积累、传递与交换；</li>
<li>为何问，是关于选择的 “<strong>道</strong>”，价值观的选择决定了不同的道。</li>
</ul>
<p>成⻓的过程，⼀般都是从提出⼀个问题开始，找到答案，再融⼊⾃身的价值观，完成下⼀次更好的选择，周⽽复始，形成习惯，化作天性。</p>
<h3 id="29-偏好：个人习惯的局限与反思"><a href="#29-偏好：个人习惯的局限与反思" class="headerlink" title="29 | 偏好：个人习惯的局限与反思"></a>29 | 偏好：个人习惯的局限与反思</h3><p>⾃⼰的习惯或癖好对别⼈本该是⽆所谓的，但在团队合作中，有些时候，我们可能会不⾃觉地去维护，甚⾄推⼴这种习惯。这种 “不⾃觉” 的⾏为是值得我们警惕和反思的。</p>
<ol>
<li><p>习惯形成</p>
<p> 即使某种的习惯最后也许真的变成了⼤家认同的好⽅法，⼀开始也不该以个⼈的⽅式直接去强加于⼈。因为强加于⼈，总是容易带来分歧和争论，最终可能好习惯还没机会带来收益，却因为分歧争论直接带来了损失。</p>
<p> 但编程中总结出来的⼀些⽅法和原则，很多可能就是始于个⼈习惯，最后逐渐传播并演化形成了普遍共识。</p>
</li>
<li><p>共识达成</p>
<p> ⼀些 “编程智慧” 类的好⽅法，不太好形成具体的规范描述。下⾯，我就结合我⾃⼰的⼯作经历和经验，列举⼀些规范建议：</p>
<ol>
<li>设计模式。遵守设计模式总是能让你少踩坑的，但如何灵活地采⽤合适的模式⼜是另⼀种智慧了。</li>
<li>术语约定。约定了术语，总是能让⼝头的概念和落在代码上的东⻄保持⼀致，减少沟通歧义，从⽽更⾼效。</li>
<li>单元测试。这⽐任何的代码评审都来得可靠，哪⾥该写多少测试⽤例，哪⾥可以不写，这⼜是智慧了。但不要刻意为了追求覆盖率⽽去写，覆盖率的技术统计⽅法其实是很唬⼈的，有些覆盖率很⾼的项⽬，该有的 Bug 还是有的。</li>
<li>随时重构。对于技术债务，每个⽉付点“利息”，⽐好⼏年后“连本带息”去还要感觉轻松得多。这条的特殊点在于，这可能是⼤部分程序员都认可的好⽅法，但却不是⼤部分⼈的习惯。因为技术上的债，实在⾃⼰还不起，总是可以推脱出去给下个“倒霉的家伙”，但从⻓远⻆度看，这样的推脱不会让你获得成⻓，甚⾄还会阻碍你的发展。</li>
</ol>
</li>
<li><p>分辨反思</p>
<p> 编程中除了好⽅法，还有些确实只是个⼈习惯的东⻄，如果我们不去留⼼区分，很容易模糊了两者的界限。</p>
<p> 那⼤家都认同并形成共识的⽅法就⼀定能形成习惯吗？也未必，这需要我们去分辨和反思。</p>
</li>
</ol>
<p>总结来说：</p>
<p>在你从程序新⼈成⻓起来的过程中，要学会区分，哪些确实是值得学习与推⼴的好⽅法，哪些仅仅是⾃⼰的个⼈习惯，特别是在你成⻓到开始成为技术管理者之后。</p>
<p>反过来看，程序⾏业，编程实践中，存在⼤量流⾏的概念、模式、原则，甚⾄哲学，它们的产⽣都有其历史背景和过程，并在⼀定范围内形成了共识。但你依然需要去对这些流⾏的共识进⾏分辨和反思，看看哪些才是适合你的好⽅法。若真是好⽅法，也可以进⼀步将其培养成⾃⼰的习惯。</p>
<h3 id="30-写作：写字如编码"><a href="#30-写作：写字如编码" class="headerlink" title="30 | 写作：写字如编码"></a>30 | 写作：写字如编码</h3><p>程序员群体有个共同的弱点，那就是写得了代码，解决得了问题，但却不能很好地展现⾃⼰的能⼒。从今天开始，咱们专栏即进⼊⼀个关于 “展现” 的主题，聊聊（写作、画图和演讲）三类最常⻅的展现⼿段。</p>
<p>其中，展现的最常⻅形式之⼀就是：<strong>写作</strong>，它是⼀种能随着时间去沉淀的⻓尾展现形式。</p>
<p>把每⼀篇⽂字当作⼀个需求，把写作当成在编码的过程去完成这个需求，它会⾮常类似于程序开发的整个过程，包括<strong>需求、设计、实现、测试和交付</strong>五个阶段。</p>
<ol>
<li><p>需求</p>
<p> 程序的需求，对应于写作的主题。</p>
<p> 对于我来说，写作主题的来源可以有很多⽅⾯：有时，是来⾃身边的⼯作和⽣活中的事件引发的感触；有时，是阅读过程中突然产⽣的启发与领悟；有时，则是曾经⼀直困惑的问题突然碰到或找到了答案……这些都属于灵感乍现的时刻，也是我写作主题的来源。</p>
<p> 但只是等到写的时候去灵光⼀现是很难保障持续写作的主题供应的，所以为了持续写作，我很多时候在⼤脑的潜意识⾥都会考虑主题的问题，等有了灵光⼀闪的时刻，就随时记录下来，形成⼀个<strong>主题列表</strong>。这个主题列表，就有些像产品的需求特性列表了，呆在需求池⾥等待被 “实现”，也即，“写出来”。</p>
<p> 随⼿记录的主题可能很多，但真正能写的时间和精⼒却有限，因此你得挑选值得写的主题。如果把每⼀篇⽂字想象成⼀件产品，那么定义写作的主题，就像定义产品的灵魂，你得确定⼀个产品的⽬标、定位，以及⾯向的读者⼈群。</p>
<p> ⼀个好的主题很可能是⼀篇好⽂字的开端，毕竟如果⼀开始产品⽅向错了，实现得再好⼜能有多⼤意义呢？</p>
</li>
<li><p>设计</p>
<p> 程序开发的设计⼀般分为两个层⾯：</p>
<ol>
<li><p>概要设计</p>
<p> 在软件程序系统的设计中，这部分内容主要是架构设计，系统或⼦系统的拆分、交互逻辑、边界等等。⽽对于写作⽽⾔，这部分对应的就是设计本篇⽂字的逻辑结构，换⾔之，即在主题确定的基础上，采⽤怎样的逻辑去展开主题，形成合适的衔接。</p>
<p> ⽐如，我写的⽂章多为随笔散⽂类，⽽散⽂的结构，上过中学语⽂课的我们都知道：形散⽽神不散。其中的 “神”，就包括了⽂章的核⼼主题观点，以及围绕主题展开的逻辑结构、⽂字附着的延展线条等。</p>
</li>
<li><p>详细设计</p>
<p> 有了逻辑⻣架后，就需要补充真正有⾎有⾁的⽂字了。</p>
<p> 围绕主题想表达的观点，考虑需要添加哪些⽀撑观点的素材，以及设计整理、引出和排布这些素材的⽅式。⽽为了让⽂字更有阅读的趣味，还需要有适当的故事，因为⼈们都喜欢读故事，⽽⾮说教，那故事⼜该如何切⼊与布局？这也是需要考虑的点。</p>
<p> 另外，这些素材或故事⼜从哪⾥来？只能来⾃平时的阅读积累。⼤部分我们读过的东⻄很快就会被遗忘，所以为了在需要的时候找到合适的内容，就需要在平时的阅读时记录笔记，留下索引，必要时再根据笔记索引的关键词去搜索。</p>
</li>
</ol>
</li>
<li><p>实现</p>
<p> 写⽂字和编码在实现层⾯最⼤的差异是：实现过程的技能和要求不同。</p>
<p> 在实现技能层⾯，程序是⽤计算机语⾔来表达的，⽂字是⽤⾃然语⾔来表达的。计算机语⾔的逻辑性和精确表达能⼒要⽐⾃然语⾔强得多，⾃然语⾔是模糊的、混沌的、不精确的。因此写得⼀⼿好程序的⼈，不⼀定能写得⼀⼿好⽂字，因为他们需要驾驭的语⾔的特性完全不同。</p>
</li>
<li><p>测试</p>
<p> 每次写完⼀篇⽂章后，就感觉⾃⼰好像是被清空了，甚⾄不再想去读⼀遍，这时我就会把它“扔”在⼀边。</p>
<p> 写作的过程中，⼤脑从冷的状态逐步升温，直到进⼊⼀种很热的状态，⽂字就是在这样的状态下⾃然流淌出来的。直到写完之前，⼤脑⼀直在⾼速运作，就像⼀颗 100% 利⽤率的 CPU，它的温度很⾼。写完后，CPU 终于降低了负载，但温度的降低还需要⼀个过程。</p>
<p> ⽽对写完的⽂字再读⼀遍，进⾏再编辑和优化，这就像软件开发中的测试过程。但我需要在⼀个冷却的状态下进⾏，站在⼀个读者或编者的视⻆去重新审视这篇⽂章。所以，这个过程通常发⽣在写作完成后的⼀天或⼏天之后。这中间的间隔，我称之为写作后的冷却时间。只有在冷却的状态下，我才能更客观地检视⾃⼰写的⽂字，同时进⾏合适地编辑和修改，这个过程就是对⽂字的测试。</p>
</li>
<li><p>交付</p>
<p> 交付，就是发布这篇新写的⽂字，让它⾯对读者，获得反馈与验证价值。</p>
<p> <strong>写作与⽂字的价值实现分两部分，写完后就完成了对⾃我的价值实现，⽽交付后才算完成了对他⼈的价值实现。</strong></p>
</li>
</ol>
<h3 id="31-画图：一图胜千言"><a href="#31-画图：一图胜千言" class="headerlink" title="31 | 画图：一图胜千言"></a>31 | 画图：一图胜千言</h3><p>能不能画好图和⼯具的关系并不⼤。</p>
<ol>
<li><p>为何？</p>
<p> 程序员不是主要写代码的么，为什么需要画图？</p>
<p> 有些程序员会认为写好代码就好，画好图有什么⽤？程序员成为架构师后是不是就天天画架构图，成为了所谓的 PPT 架构师？曾经读过⼀篇⽂章《在⾸席架构师眼⾥，架构的本质是…》，⾥⾯提出了⼀个架构师能⼒模型图，（我重新绘制）如下：</p>
<p> <img src="/images/《程序员进阶攻略》学习笔记/架构师能力模型图.png" alt="架构师能力模型图"></p>
<p> 结合我⾃⼰的经历和经验，这个能⼒模型针对架构师这个岗位来说还是⽐较符合的。程序员出⾊到了⼀定程度后想成⻓为⼀名架构师，就需要看看能⼒模型中的其他⽅⾯。⽽掌握好画图技法，对这个能⼒模型有什么帮助吗？</p>
<p> 前⾯讲系统设计的⽂章《多维与视图》中我已经给出过结论：“⽤更系统化的视图去观察和思考，想必也会让你得到更成体系化的系统设计。”</p>
<p> ⽽画图对于能⼒模型中的 “抽象思维” 就起到了⼀种锻炼，其作⽤就是帮助你在不同的层次上去思考系统设计，并具象化这个设计。既然具象化了设计，那么再基于此去沟通交流⾃是事半功倍。成为架构师之后，你⾃⼰明⽩还不是主要的，要让别⼈明⽩才更重要。</p>
<p> 此外，站在⼀个多层次、全⽅位的系统架构图⾯前，在不同抽象维度上描绘了系统的各个重要⽅⾯，想必更容易看到问题的本质，也能更好地发现和找到系统的症结。如果解决系统的问题就像⾛迷宫，那么你是直接钻进去反复尝试寻找出路，还是站在更⾼的维度去俯视迷宫然后再找最佳的问题解决路径呢？</p>
<p> 想必在更宏观和全局的视野下，与系统所有相关⼈员进⾏清晰准确地交流，直击问题本质，那么再进⾏正确⽽适当的技术决策与平衡取舍也没那么难了，对吧？⾄于 “多领域知识” 和 “技术前瞻性” 这两⽅⾯好像确实和画图的关联性不强，但如果“多领域知识”不限于程序技术领域，那画图也算⼀个领域的知识吧。</p>
</li>
<li><p>如何？</p>
<p> ⼀些基本认知和感觉还不错的实践⽅式。</p>
<ol>
<li><p>图形</p>
<p> 我画技术图例时只会使⽤⼀些最基础的图形，⽐如：矩形、圆、三⻆、菱形、⽓泡、箭头，这些最基本的图形⼏乎所有的画图软件都会⾃带的，所以⼯具的依赖性很低，但真正画时的操作效率却⼜很⾼。</p>
<p> 当然，⼀些著名外部系统可能都有各⾃知名的 Logo 图标，如果有时为了表达和这些著名外部系统间的交互，也会直接使⽤它们的 Logo 图标。如下⾯图示，就是我常⽤的⼀些画图图形元素。</p>
<p> <img src="/images/《程序员进阶攻略》学习笔记/我的⼀些常用画图元素.png" alt="我的⼀些常用画图元素"></p>
</li>
<li><p>颜⾊</p>
<p> 使⽤⼤部分⼈觉得美的颜⾊。那⼤部分⼈觉得美的颜⾊是什么呢？彩虹⾊，当然这⼀点也我没有做过专⻔调查，只是凭经验得来。所以我⼀般⽤的颜⾊就是彩虹七⾊，外加两种经典⾊：⿊、⽩。这样就有九种颜⾊加上好⼏种基本图形，可以组合出⼏⼗种表达不同组件的图形元素，基本也就够⽤了。</p>
<p> 彩虹七⾊包括：红、橙、⻩、绿、⻘、蓝、紫。但七种颜⾊的选择也是有优先级，在⼀本讲设计的书中 Designing with theMind in Mind（中⽂译本《认知与设计》）提出了下⾯⼀些⾊彩使⽤准则：</p>
<ul>
<li>使⽤饱和度、亮度以及⾊相区分颜⾊，确保颜⾊的⾼反差，因为⼈的视觉是为边缘反差⽽优化的。</li>
<li>使⽤独特的颜⾊，因为⼈最容易区分的颜⾊包括：红、绿、⻩、蓝、⽩和⿊。</li>
<li>避免使⽤⾊盲⽆法区分的颜⾊对，⽐如：深红－⿊，深红－深绿，蓝⾊－紫⾊，浅绿－⽩⾊。</li>
<li>使⽤颜⾊之外的其他提示，对有颜⾊视觉障碍的⼈友好，⽽且也增强了可理解性。</li>
<li><p>避免强烈的对抗⾊，⽐如：红⿊，⻩⿊。</p>
<p>当然红有好多种红，绿有好多种绿，该⽤哪种呢？看下图所示，给出了 RGB 三原⾊的配⾊数值，这属于个⼈偏好，在 Mac的显示器下看起来很舒服。但若⽤在其他场合，⽐如投影什么的，就可能需要根据投影实际效果进⾏微调了。</p>
<p><img src="/images/《程序员进阶攻略》学习笔记/个人偏好的颜色配色参数.png" alt="个人偏好的颜色配色参数"></p>
</li>
</ul>
</li>
<li><p>审美</p>
<p> 审美对最终的效果呈现有很⼤影响，这得感谢苹果总设计师乔纳森·伊夫（Jonathan Ive）把⼤众的审美倾向全部带⼊到扁平化时代，所以实际中我只需要把图形弄得扁平，去掉⽴体、阴影什么的，看起来就还不错了。</p>
<p> <img src="/images/《程序员进阶攻略》学习笔记/审美效果示例图.png" alt="审美效果示例图"></p>
</li>
</ol>
</li>
<li><p>⼏何？</p>
<p> “⼏何” 不是数学⾥的⼏何，⽽是掌握画图技法到底代价⼏何？⼜价值⼏何呢？</p>
<p> 学会使⽤⼀种简单的软件，使⽤简单的图形和配⾊，在最有效率的情况下画出⼀幅效果还不错的图例，也是很有价值的。</p>
<p> 当然你可能会认为只有写出的代码才有价值，其实这⾥你可能忽视了⼀个⼤部分程序员都认同的观点：代码也是写给⼈看的。程序员不会认为⼀份机器能运⾏⽽⼈很难看懂的代码是好代码，⽽画好图就能更好地帮助你去思考代码的组织和呈现⽅式。</p>
</li>
</ol>
<h3 id="32-演讲：表达的技术"><a href="#32-演讲：表达的技术" class="headerlink" title="32 | 演讲：表达的技术"></a>32 | 演讲：表达的技术</h3><p>我确实有⽐较系统地思考和琢磨过演讲的价值、效果以及提升的⽅法，现在我将其分享给你，希望能对你的成⻓或者职业道路有所帮助。</p>
<ol>
<li><p>价值与效果</p>
<p> 写作的展现，是⼀种⼴度路线，产⽣间接、⻓尾效应；演讲的展现，是⼀种深度路线，产⽣直接、深度连接。</p>
<p> 为什么说写作是⼴度⽽演讲是深度的？过去⼏年，我读过很多的⽂章、书，但还能记得住只⾔⽚语的都⾮常少。即使当时⼀些给我⾮常多启发与触动的⽂字，如今也只能记得当时触动的感觉，却忘了触动的内容。但好些年前，我参加过⼏次⾏业⼤会，有那么⼏场演讲，现在回想起来，不仅记得当时深受启发的触动感，甚⾄还能记得当时的内容。</p>
<p> 这就是演讲带来的深度效应，它的现场感更⽴体，有助于留下更深刻的记忆，持续发挥影响的时间也超过了⽂字。</p>
<p> 演讲的现场⽴体感带来的深度效应，也只能留在现场。即使我们把整个演讲过程录制成为视频，观看视频的过程也会损失很⼤⼀部分深度影响⼒，也许这就是为什么有⼈会去看现场演唱会的原因。</p>
<p> 所以，演讲的最⼤价值就在于这样的深度效应。但现场感并不⼀定带来深度影响，也可能是把⼈ “催眠” 了。那如何发挥好演讲的效果呢？这⾥我就先谈谈我⾃⼰的⼀些经历和感悟。</p>
</li>
<li><p>经历与感悟</p>
<p> 成⻓路上，终究会遇上演讲；从没遇上演讲的程序员，可能天花板就会⽐较低。</p>
</li>
<li><p>准备与发挥</p>
<p> ⼀场演讲，包括前期准备和现场发挥两个阶段，⽽前期充分的准备是现场良好发挥的基础。</p>
<p> 那前期可以准备的内容有哪些？我梳理了有如下维度：</p>
<ol>
<li><p>框架</p>
<p> 演讲的框架和程序的架构有点类似，⼀般我都从下⾯⼏个⽅⾯来设计：</p>
<ul>
<li>⽬标：本次演讲需要达成的⽬标是什么？</li>
<li>听众：本次演讲的受众是哪些⼈？</li>
<li><p>重点：本次演讲要传递的关键点有哪些？</p>
<p>那么⼀场技术分享的框架线，可能有如下：</p>
</li>
<li><p>引出主题：结合⽬标与听众来确定。</p>
</li>
<li>⾃我介绍：让听众了解你，证明你有资格讲这个主题。</li>
<li>重点结构：每⼀个关键点的分析、讲解，可以从以下⽅⾯来拆解。<ul>
<li>问题：这个点上存在什么问题？</li>
<li>历史：这个问题的历史由来是什么？</li>
<li>⽅法：你是⽤什么⽅法解决这个问题的？</li>
<li>原因：为什么要⽤这个⽅法，要在这个阶段，以及这样解决问题？</li>
</ul>
</li>
<li>细节深⼊：有⼀定细节深⼊，更有说服⼒。</li>
<li>总结回顾：结束前的再次总结和提炼，以加深印象。</li>
</ul>
</li>
<li><p>材料</p>
<p> 在框架线清晰后，就进⼊了演讲材料的准备阶段。其中的材料包括三类：</p>
<p> <strong>第⼀类是幻灯⽚</strong>。到底要准备多少⻚的幻灯⽚？这个取决于框架线和演讲时⻓。但这⾥幻灯⽚的最⼤作⽤在于：</p>
<ul>
<li>辅助演讲者的结构记忆与信息表达；</li>
<li><p>辅助听众的信息吸收、理解与消化。</p>
<p>也就是说，演讲的主⻆还是讲，⽽幻灯⽚仅仅是配⻆。</p>
<p><strong>第⼆类是演讲稿</strong>。讲之前你可以先写下来你所要讲的内容，这样会有助于组织信息、梳理逻辑和提炼语⾔。</p>
<p>我们的正常语速⼤约是每分钟150～200个汉字，但在演讲的压⼒环境下，可能会出现不⾃觉地加速，⽆意识地跑偏，甚⾄语⽆伦次。如果想要提供更精确的信息传递和表达，那么演讲稿就是必需的。</p>
<p><strong>第三类是⼩故事</strong>。⼈是情感动物，故事的影响效应远⾼于数据和逻辑，即使是在做技术分享时。</p>
<p>以前听过⼀些技术分享感觉⽐较枯燥、催眠，就在于技术基本都在讲逻辑、讲数据，听久了⾃然疲劳。⽽穿插⼀些 “⼩” 故事，则可以加深前⾯数据和逻辑的影响效应。这⼀点很多慈善募捐组织早就学会了，再⼤⽐例的穷困数据，也⽐不上⼀张⾐不蔽体的⼩⼥孩照⽚来得有效。</p>
</li>
</ul>
</li>
<li><p>节奏</p>
<p> ⼀段持续时间的演讲中，有没有⼀些关键的时间点呢？当然是有的。</p>
<p> <strong>⼀个是开场</strong>。据研究统计，⼀场演讲给⼈留下的印象和评价，开场的数秒⾄关重要。这可能和⼀开始是否能抓住听众的注意⼒有关。</p>
<p> <strong>另⼀个是峰终</strong>。管理界有⼀个 “峰终定律（Peak-End Rule）”：在 “峰” 和 “终” 时的体验，主宰了对⼀段体验好或者不好的感受，⽽在过程中好或不好体验的⽐重、时间⻓短，对记忆的感觉差不多没有影响。也就是说，如果在⼀段体验的⾼峰和结尾，你的体验是愉悦的，那么你对整个体验的感受就是愉悦的，即使这次体验总体来看，更多是⽆聊和乏味的时刻。</p>
<p> 峰终定律，在管理上决定了⽤户体验的资源投⼊分布，只需要重点投⼊设计好 “峰终” 体验。⽽演讲，也是⼀⻔体验艺术，它的 “峰” 前⾯说了⼀处——开场（抓注意⼒）；另⼀处，可能是中间某⼀处关键点（提供独特的⾼价值内容或观点）。</p>
</li>
<li><p>表演</p>
<p> 演，即表演和发挥；表演的准备，有三个层级，如下图（原图来⾃ Tim Urban’s Memorization Spectrum，翻译后重绘制）：即兴发挥、框架内发挥和严格遵从剧本。</p>
<p> <img src="/images/《程序员进阶攻略》学习笔记/表演准备的三个层级.png" alt="表演准备的三个层级"></p>
<p> 做了前述准备的演讲，算是在框架内发挥。如果还准备了演讲稿，那么练习熟练后，基本算是接近了 3A 这个层级，但演讲稿，还算不上是剧本，所以只是接近。按 3 这个层级的准备，是把演讲当作了⼀出舞台剧，有严格的剧本，需要经过反复地排演练习。</p>
</li>
</ol>
</li>
</ol>
<p>演讲，本是表达的艺术，但对程序员的要求远没到艺术的层次；先能表达，再求精确，技术达标，⾜矣。</p>
<h3 id="33-定义：阶梯与级别"><a href="#33-定义：阶梯与级别" class="headerlink" title="33 | 定义：阶梯与级别"></a>33 | 定义：阶梯与级别</h3><p>从今天开始，咱们专栏会开启⼀个⼤家可能都⽐较感兴趣的主题：<strong>程序员的职场阶梯，以及攀登阶梯的晋升博弈</strong>。</p>
<p>腾讯的 5 个⼤级别与我⾃⼰⼀路⾛来经历的⼏个阶段感觉会⽐较匹配⼀些，⽽⼤级别之间的分界线也会更明显⼀些。我对升级阶梯的定义也是 5 个：初级、中级、⾼级、资深和专家。</p>
<p>⾄于对不同级别的定义，我选择了三个相对容易判断的维度：</p>
<ul>
<li>具备什么能⼒？</li>
<li>解决什么问题？</li>
<li>产⽣多⼤影响？</li>
</ul>
<ol>
<li><p>初级</p>
<p> 初级，多属于刚⼊职场的新⼈。</p>
<p> 这个级别基本完成的都是螺丝钉级别的⼯作，影响很有限。但如果从这个阶段你就开始定期归纳总结这些局部的⼯作经验，不断优化⼯作内容，并能在团队⼩组内部做出分享，甚⾄帮助其他同学解决问题，那就说明你已经⾛上了⼀条快速成⻓的通道。</p>
</li>
<li><p>中级</p>
<p> 中级，相对初级最⼤的质变在于：独⽴性。</p>
<p> 初级同学经过两三年⼯作历练，对实现各种业务功能、开发规范流程都很熟练了，摆脱了对基本指导的依赖性，这时就进⼊了中级阶段。中级⼯程师已经能够独⽴承担开发任务，设计实现他们负责的系统模块，以及通过搜集有效信息、资料和汲取过往经验来解决⾃⼰⼯作范围内遇到的问题。</p>
<p> 中级这个层⾯的基本要求就是：<strong>完成动作、达成品质和优化效率</strong>，属于公司 “动作执⾏” 层⾯的中坚⼒量。观察下来，这个级别的⼯程师多数都能做到完成，但品质可能有瑕疵，效率上甚⾄也有很多⽆效耗散。不过，效率和品质总是在不断的迭代中去完善，⾃身也会在这个过程中不断成⻓并向着下⼀个阶梯迈进。</p>
<p> 不少同学卡在这⼀阶段，就是因为虽然不断在完成⼯作，但却没有去反思、沉淀、迭代并改进，从⽽导致⾃⼰⼀直停留在了不断的重复中。所以，在⼯作中要保持迭代与改进，并把你的经验分享给新来的初级同学，这样在未来之路你不仅会⾛得更快，⽽且也可能⾛得更轻松。</p>
</li>
<li><p>⾼级</p>
<p> ⾼级，不仅要能独⽴完成⼯作，还要能独⽴负责。他们能独⽴负责⼀个⼤系统中的⼦系统或服务，并成为团队⻣⼲或最重要的个⼈贡献者。</p>
<p> 相⽐于中级，⾼级⼯程师在 “动作执⾏” 层⾯，不仅能独⽴完成⾼级难度的开发任务，⽽且在⽤户体验（品质提升）和性能优化（优化效率）⽅⾯还都能做出更全⾯的考量。也就是说，他们不仅仅可以把开发任务完成得⼜快⼜好，⽽且还能清晰地定义出多快、多好。⽐如，⼀个服务的响应时间 99.9% 是在 20 毫秒内，内存消耗最⼤不超过 1G，并发吞吐量 10000+/s，类似能⽤清晰的数据来定义服务品质和效率。</p>
<p> 另外，⾼级别需要⾯对的问题就不再是单⼀维度的技术问题了，他们需要结合业务特性去考虑设计合理的解决⽅案。熟悉业务领域内的应⽤系统架构以及各个部分使⽤的技术，能根据业务特性，合理进⾏分层设计，实现⾼效率、低成本的运维或运营。</p>
<p> 初、中级别的能⼒提升与影响输出是通过经验的归纳总结与分享，那么⾼级则需要在经验这种偏个体特性的基础上，再进⾏抽象提炼，沉淀⽅法论。换⾔之，通过个⼈的经验，研究⾏业的优秀实践，再结合⾃身实践和逻辑推导，沉淀出切合现实的⽅法论，并在团队内部推⼴应⽤。</p>
</li>
<li><p>资深</p>
<p> 资深，有深度和资历（即⼴度）两个层⾯，对应到职业⽣涯路线上，也有两个⽅向。</p>
<ul>
<li>资深⼯程师</li>
<li><p>架构师</p>
<p>在偏基础研发、算法和特定技术复杂领域，会向 “资深⼯程师” ⽅向发展，属于深度优先。⽽在⾯向业务开发的领域，业务复杂度⾼于技术复杂度，则会向 “架构师” ⽅向发展，属于⼴度优先。</p>
<p>但⽆论深度还是⼴度，进⼊这个级别即说明你在特定领域都已经具备了相当的积累。这时你是作为相关领域的专家，深度参与和⽀持团队项⽬，在领域内进⾏关键的技术判断和决策，进⽽帮助团队项⽬或产品加速成功。在这个层次上，你⾯临的都是⼀些更复杂的、具备⼀些灰度（不是⾮此即彼，⽽是需要折中权衡）特性的问题，这时就需要你能够全⽅位、多层次、多⻆度地深⼊理解问题，评估每种⽅案的收益、成本和潜在未来的⻓短期影响等。</p>
<p>这个层次的影响⽅⾯，除了经验分享和⽅法论沉淀，还有<strong>产品</strong>和<strong>团队</strong>两个考虑维度：即使是做纯技术的东⻄，最终的影响也是通过技术产品来完成的；⽽另⼀⽅⾯则是团队的梯队建设、结构调整与协作优化，决定了团队外在表现。这两个维度，前者可能资深⽅向侧重多⼀些，后者则是架构师⽅向需要侧重思考实践的。</p>
</li>
</ul>
</li>
<li><p>专家</p>
<p> 专家，表明了某种领域的明确建⽴。</p>
<p> 也许架构师和资深⼯程师也具备在特定细分技术领域的深厚积累，说明他们和专家⼀样也有属于⾃⼰的领域，但这个领域还不算明确建⽴，它还需要有公认的影响⼒。公认影响⼒实际指⼀个范围，如果是公司的技术专家，那么范围就是公司或⾏业。</p>
</li>
</ol>
<h3 id="34-晋升：评定与博弈"><a href="#34-晋升：评定与博弈" class="headerlink" title="34 | 晋升：评定与博弈"></a>34 | 晋升：评定与博弈</h3><p>晋升的结果和个⼈利益有直接的绑定关系，⽽且这个过程从来都不是⼀个简单的是和否的选择，那你该如何看待这个“不简单”的晋升过程呢？</p>
<ol>
<li><p>标准维度</p>
<p> 先站在评定者的⻆度，假设你作为⼀名评委，你会如何去评定？⼜有怎样的标准呢？</p>
<p> 技术晋升评定是依赖⼈的判断，本是⾮常主观的⼀个过程，但为了规避这种过于“拍脑袋”的主观性，就需要去制定标准。制定标准的初衷也是为了给评定过程增加客观性，将⼈的主观判断约束在⼀定的客观范围内。</p>
<p> 我在参考了⼀些⾏业⾥⼤公司的晋升和技术素质模型，并结合当时团队的具体现状，制定了出了⼀些标准维度：</p>
<ul>
<li>通⽤能⼒，包括学习能⼒、沟通能⼒和领导能⼒等；</li>
<li>业务能⼒，包括业务理解和领域建模等；</li>
<li>技术能⼒，包括深度、⼴度和技能应⽤等；</li>
<li><p>影响⼒，如知识总结、知识传承和⼈才培养。</p>
<p>除以上 4 个⼤维度外，还有⼀项 “⼯作业绩” ，不属于现场技术评定的维度，直接来源于过去⼀年的⼯作业绩评价。每个⼤维度会占据⼀定的⽐重，然后可以针对每个⼤维度去打分。</p>
<p>虽然有了客观的标准维度去细分判断，但⼈打分在细微之处依然会有主观的偏好。</p>
</li>
</ul>
</li>
<li><p>过程识别</p>
<p> 晋升识别过程是⼀条链路，⽽技术标准评定只是其中的⼀个环节。</p>
<p> 晋升过程启动⼀般由 HR 部⻔驱动发起，经过各个部⻔直属领导提报候选⼈，再经由技术委员会进⾏专业线评定，再去到管理层复议，最后⼜回到 HR 部⻔最终确定。</p>
<p> 第⼀个环节，HR 部⻔的责任是对提报候选⼈进⾏晋升资格确认。第⼆个环节，部⻔从满⾜资格的员⼯中进⾏提报，部⻔的作⽤是对提报员⼯过去⼀年在本部⻔⼯作绩效的认可；第三个环节，就进⼊了技术委员会组织的专业线技术评定，⽽通过技术标准评定后，是对其专业综合能⼒的认可。</p>
<p> 最后，就进⼊到管理层复议环节，这个环节会有⼀个冲突点存在。公司每年的晋升名额也是有限的。⼀般公司每年的晋升名额都会有⼀个⽐例限制，这是出于控制成本与优化⼈才结构的考虑，因⽽经过前⾯的环节，最后到达这⾥的⼈数可能多于这个名额。所以，管理层复议其实就是对最后多出来的⼈数，综合考虑整体和局部的利益，进⾏调节筛选。</p>
<p> 了解了评定的标准和过程，就可以反过来站在晋升者的⻆度想想，如何才能更有效地被识别出来？</p>
<p> 晋升述职过程仅仅只有 10 到 20 分钟，即使采⽤了前⾯所述的标准维度，晋升述职者也只能在有限的时间内把过去⼀、两年的⼯作成果、能⼒成⻓展示在⼏个点的范围内。这对于评定者来说，就像在管中窥豹了，看不到全貌，看完⼏个展示的特征点后就需要判断这到底是 “豹⼦”（符合下⼀级别的晋升标准）还是 “猫”（不符合）。</p>
<p> 我在做晋升评委时，就⼀直被这样的判断所困扰，多数述职同事都在这⼏个点上表现得很好。这就像是说，如果是豹⼦，它确实该有这些特征点，反过来，拥有这些特征点的就⼀定就是豹⼦么？这些特征点，是豹⼦的唯⼀或⾜够有区分度的标志性特征吗？</p>
<p> 我发现靠 “点” 上的判断，准确度⾃⼰其实也完全没把握，后来就想到了⼀种更好的⽅式，靠 “域” 的判断。域，即领域，包含了：责任域和能⼒域。能⼒和责任总是相辅相成的。</p>
<p> 责任域，就是你负责什么，这个相对容易识别。⽽能⼒域则过于抽象，很难清晰识别，在述职这样的形式中，最容易判断的仅仅是表达和沟通能⼒；⾄于业务和技术能⼒，虽不那么容易判断，但好在其有最好的展现形式：作品。</p>
<p> 对于程序员，作品可以是⼀个完整的系统，但其展现不应该是⼀系列的技术点，⽽是先有整体（⾯），再深⼊局部（点），应该是⼀个画⻰点睛的过程。从这样的展现过程中就能很好地体现出晋升者的业务与技术能⼒。</p>
<p> 识别的过程，本质是在解⼀个概率问题，当参与这个过程的两⽅（评定者和晋升者）都这样努⼒去考虑时，我想这样的过程就会有更⾼的准确率。</p>
</li>
<li><p>博弈权衡</p>
<p> 晋升过程因为涉及太多个⼈的利益，所以评定过程的公平性是所有参与⽅都关⼼的问题。</p>
<p> 晋升的本质是承担更⼤的责任，⽽责任和能⼒是需要匹配的，晋升就是完成这样⼀种匹配关系的过程。⼀个公司中的责任域是有限的、发展的、变化的，那你当下具备的能⼒域是否匹配相应的责任域？你正在学习和开发的新能⼒域，是否能在组织中匹配上合适的责任域？这才是看待职场阶梯与晋升的正确⽅式。</p>
<p> 保持不断学习和提升能⼒，找到并承担起合适的责任域，那么后续的晋升并贴上⼀个相应的职级标签，就是⼀件⾃然⽽然的事情了。</p>
</li>
</ol>
<h3 id="35-关系：学徒与导师"><a href="#35-关系：学徒与导师" class="headerlink" title="35 | 关系：学徒与导师"></a>35 | 关系：学徒与导师</h3><p>现在很多公司都有⼀种带新⼈的导师（Mentor）制度，导师制的初衷是为了帮助新员⼯快速熟悉公司环境，并提供⼯作技能和个⼈成⻓的帮助，正所谓 “传帮带”。</p>
<p>这是⽤制度建⽴并约束了⼀种在新、⽼员⼯之间的关系，这本是⼀个很好的出发点。但想要类似这样的制度关系发挥期望的作⽤，恐怕就需要 “导师” 和 “学徒” 都有⼀个更⾼层次的清晰认知，毕竟制度只能在其中起到催化的作⽤。</p>
<ol>
<li><p>起源</p>
<p> 导师制诞⽣于⼗四世纪，那时的年轻男⼥们可以⽤⾃⼰最富余的资产——时间，去交换当时最稀缺的资源——培训。在那个时代，经验丰富的⼿艺⼈，⽐如，铁匠、鞋匠、⽊匠等，他们指导这些年轻⼈，并承诺将来某天年轻⼈能学会他们的技能然后去开创属于⾃⼰的事业。作为交换，年轻⼈会提供低成本且廉价的劳动⼒。</p>
</li>
<li><p>导师</p>
<p> 有经验的程序员、⽼员⼯，站在 “导师” 的视⻆，会如何看待这样的关系呢？</p>
<p> 从某种意义上来讲，经验丰富的程序员，就和中世纪的⽼师傅⼀样，他们经历了⼤量的时间犯过⼤量的错误，积累了很多难以⾔说的经验价值。他们已经经历过你所犯的错误，已然能够轻松应对如今让你痛苦和头疼的问题，所以他们具有能够引导你迈向正确⽅向的潜能。</p>
<p> 但反过来想，他们为什么要指导你？只是因为公司有个导师制，并安排了他成为你的导师？那么这样的指导通常也就变成了上⾯那种场景。为什么他们要牺牲⾃⼰的⼯作时间，甚⾄私⼈时间来⽆私地指导你？也许作为新同学的你，甚⾄包括制度的制定者本身，可能也没从这个⻆度来看待该问题。</p>
<p> 职场导师制，如果公司没有相应⾜够的考核、评价和激励制度⽀撑，那么这种师徒关系实际上没有任何约束，完全靠运⽓、投缘之类的。站在导师的⻆度，对于凑巧碰到的⼀个职场新⼈，他有什么样的利益或情感驱动要去更积极地做这件事呢？其实最直接的，还是由对⽅的态度和⾏动来驱动的。</p>
</li>
<li><p>学徒</p>
<p> 反过来，站在 “学徒” 的视⻆，该如何看待这样的关系？万维钢有篇⽂章叫《给前辈铺路的⼈》说得很有现实意义：</p>
<blockquote>
<p>给⼈当学徒，就给你提供了这个机会。你现在把⾃⼰和⼀个⾼⼿连接在了⼀起，你可以从内部了解第⼀⼿的经验。这就是学徒⼯作的协议：⽤礼敬和服务，换取机会——⽽这个机会还不是⽴功露脸的机会，⽽是学习实践的机会。</p>
</blockquote>
<p> 机会，就是得到更快的成⻓与发展。从导师多年积累的经验中获益，能够缩短获得这些知识经验的时间，并且避免重复错误。但这⾥⾯可能还有个障碍，就是⾃尊⼼的问题，态度不够谦虚，那么也许是性格还需磨练。如果态度谦虚，双⽅都投⼊了适当的时间和精⼒，那么导师当年花了⼗数年才学会或领悟到的东⻄，学徒也许只⽤短短⼏年就能学到，绕过了没必要的重复路线。</p>
<p> 从学徒⽅⾯来说，必要的、简单的、低技术含量或重复性的⼯作也是必须的，不应该被认为是⼀种浪费或牺牲。当你在免费获得⼤量的知识和帮助的同时，却抱怨时间投⼊太多，或者时间不够，其实是短视的。因为：</p>
<blockquote>
<p>当你给⼈铺路的时候，你实际上也在左右他的前进⽅向。</p>
</blockquote>
</li>
<li><p>关系</p>
<p> 现实中，对于师徒关系，会有⼈有这样的疑问：“教会徒弟，会饿死师傅吗？”也许中世纪时期的师徒关系会有这样的担忧，但如今这个信息时代，知识根本不稀缺，也没有所谓的 “⼀招鲜，吃遍天” 的绝招。反过来说，<strong>带好了徒弟，接⼿并取代了你当前正在做的事情，你才有可能解放出来去做更⾼层次和更⼤维度的事情</strong>。</p>
<p> ⽽作为学徒，你需要吸取德⾥克的经验：<strong>学习和成⻓是⾃⼰的事，严肃待之，⾏动起来，⾃助者，⼈亦助之</strong>。</p>
</li>
</ol>
<h3 id="36-核心：安全与效率——工程技术的两个核心维度"><a href="#36-核心：安全与效率——工程技术的两个核心维度" class="headerlink" title="36 | 核心：安全与效率——工程技术的两个核心维度"></a>36 | 核心：安全与效率——工程技术的两个核心维度</h3><p>在“<strong>修⾏：由术⼊道</strong>”模块的最后⼀个主题，我们聊聊<strong>⼯程</strong>，不是具体的⼯程的技术，⽽是抽象的⼯程之道。</p>
<p>做了很多年的⼯程，开发了各种各样的系统，写了⽆数的代码，说起这⼀切，我们都在谈些什么？</p>
<p>我们谈过程，从需求⼯程到开发流程，从编码规范到同⾏评审，从持续集成到⾃动部署，从敏捷开发到极限编程；我们谈架构，从企业级到互联⽹，从⾯向服务架构（SOA）到微服务架构（Microservice）；我们谈复杂性，从⾼并发到⾼性能，从⾼可⽤到⾼可靠，从⼤数据到⼤容量。</p>
<p>那么对于这⼀切，你感觉这⾥⾯的核⼼是什么？</p>
<ol>
<li><p>核⼼</p>
<p> 核⼼，意味着最重要的，⼀切复杂的⼯程技术⽅案都是围绕着它来运转。</p>
<p> ⼀个电⼒⾏业的故事。</p>
<blockquote>
<p>记得有个给我们上课的主讲⽼师是个须发皆⽩的⽼先⽣，进⻔后掏出⼀堆零件放在讲台上。⼀盏酒精灯、⼀个⼩⽔壶、⼀个叶⽚、⼀个铜光闪闪的⼩电机、⼀个⼩灯泡。⽼先⽣往壶⾥倒了些⽔，点燃酒精灯，不⼀会⼉⽔开了，从壶嘴⾥喷出了蒸汽，带动叶⽚旋转，然后⼩灯泡就亮了。</p>
<p>⽼先⽣说：“这就是电⼚。如果烧的是煤炭，这就是燃煤电⼚；如果烧的天然⽓，这就是燃⽓电⼚；如果获得热能的⽅式是核裂变，这就是核电⼚；如果带动叶⽚的能量来⾃从⾼处流向低处的⽔流，这就是⽔电⼚。”</p>
</blockquote>
<p> “你们或许会问：那我们看到的电站怎么这么复杂？答案其实很简单，电站需要复杂系统的⽬的：⼀是为了确保安全（Safety），⼆是为了提⾼效率（Efficiency）。<strong>安全与效率的平衡，是所有⼯程技术的核⼼</strong>。”</p>
<p> 听完这个故事，我觉着所谓 “⼤道⾄简” ⼤概就是这样的感觉了。</p>
</li>
<li><p>安全</p>
<p> 安全，之于信息⼯程技术领域，包括了 “狭义” 和 “⼴义” 两个⽅⾯的安全范畴。如下图所示：</p>
<p> <img src="/images/《程序员进阶攻略》学习笔记/工程安全的狭义和广义分类.png" alt="工程安全的狭义和广义分类"></p>
<p> 狭义的安全，就是传统信息安全领域的 “安全攻防” 范畴。⽐如，客户端的跨站脚本攻击（XSS）、服务端数据库的 SQL 注⼊、代码漏洞以及针对服务可⽤性的拒绝服务攻击（DDoS）等。这个⽅⾯的 “安全” 含义是信息技术⾏业独有的，但前⾯电站例⼦中指的 “安全” 更多是 “⼴义” 层⾯的。</p>
<p> 在程序技术上的 “⼴义” 安全范畴，我划分了三个⽅⾯：</p>
<ol>
<li><strong>安全开发</strong>，就是为了保障交付的程序代码是⾼质量、低 Bug 率、⽆漏洞的。从开发流程、编码规范到代码评审、单元测试等，都是为了保障开发过程中的 “安全”。</li>
<li><strong>安全运维</strong>，就是为了保障程序系统在线上的变化过程中不出意外，⽆故障。但⽆故障是个理想状态，现实中总会有故障产⽣，当其发⽣时最好是对⽤户⽆感知或影响范围有限的。</li>
<li><strong>安全运⾏</strong>，就是为了应对 “峰值” 等极端或异常运⾏状态，提供⾼可靠和⾼可⽤的服务能⼒。</li>
</ol>
</li>
<li><p>效率</p>
<p> 效率，从程序系统的⻆度看，同样也是从 “开发”“运维” 和 “运⾏” 三个⽅⾯来考虑。如下图所示：</p>
<p> <img src="/images/《程序员进阶攻略》学习笔记/效率的划分.png" alt="效率的划分"></p>
<ol>
<li><p><strong>开发效率</strong>，可以从 “个体” 和 “群体” 两个⽅⾯来看。</p>
<p> 个体，就是程序员个⼈了，其开发效率除了受⾃身代码设计与编写能⼒的影响，同时还要看其利⽤⼯具的⽔平。更好的源码管理⼯具与技巧可以避免⽆谓的冲突与混乱；代码模板与开发框架能⼤幅度提升代码产出效率；⽽持续集成⼯具体系则能有助于快速推进代码进⼊可测试状态。</p>
<p> 群体，就是⼀个团队，其开发效率最⼤的限制经常是架构导致的。如果你在⼀个⼯程项⽬上写过⼏年代码后，多半会碰到这样⼀种场景，代码库越来越⼤，⽽功能越改越困难。明明感觉是⼀个⼩功能变化，也要改上好⼏天，再测上好⼏天，这通常都是架构的问题，导致了团队群体开发效率的下降。</p>
<p> 以后端服务架构技术演进的变化为例，从单体应⽤到⾯向服务架构思想，再到如今已成主流的微服务架构实践，它最⼤的作⽤在于有利于⼤规模开发团队的并⾏化开发，从⽽提升了团队整体的效率。理想情况下，每个微服务的代码库都不⼤，变化锁闭在每个服务内部，不会影响其他服务。</p>
</li>
<li><p><strong>运维效率</strong>，可以从 “检查”“诊断” 和 “处理” 三个⽅⾯来看。</p>
<p> ⼀个运⾏的系统，是⼀个有⽣命⼒的系统，并有其⽣命周期。在其⽣命周期内，我们需要定期去做检查，以得到系统的 “⽣命体征” 的多维度信息数据汇总，以供后续的诊断分析。</p>
<p> 准确地诊断之后，才能进⾏合适地处理。和治病不同，⼤部分的故障都可以通过常⻅的处理⼿段解决，极少存在所谓的 “不治之症”。⽽常⻅的线上处理⼿段有如下三类。</p>
<ul>
<li>恢复：重启或隔离来清除故障、恢复服务；</li>
<li>变更：修改配置或回滚程序版本；</li>
<li>限制：故障断路或过载限流。</li>
</ul>
</li>
<li><p><strong>运⾏效率</strong>，关键就是提⾼程序的 “响应性”，若是服务还包括其 “吞吐量”。</p>
<p> 程序运⾏的⾼效率，也即⾼响应、⾼吞吐能⼒，所有的优化⼿段都可以从下⾯两个维度来分类：</p>
<ul>
<li>更多</li>
<li><p>更快</p>
<p>负载均衡器让更多的机器或进程参与服务，并⾏算法策略让更多的线程同步执⾏。异步化、⽆锁化和⾮阻塞的算法策略让程序执⾏得更快，缓存与缓冲让数据的读写更快。</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="37-过程：规模与协作——规模化的过程方法"><a href="#37-过程：规模与协作——规模化的过程方法" class="headerlink" title="37 | 过程：规模与协作——规模化的过程方法"></a>37 | 过程：规模与协作——规模化的过程方法</h3><p>⼯业级规模化的程序系统开发包括了⼀系列的过程，⽽这⼀系列过程的起点是：需求。</p>
<ol>
<li><p>需求与调度</p>
<p> 需求，有时会有很多不同的表达形式，包括：客户的诉求、⽤户的请求、⽼板的要求，但这些不同的表达形式，不⼀定是真正的需求。</p>
<p> 如何对过多的需求进⾏排序？可以学习、借鉴下操作系统的资源调度策略。</p>
<ol>
<li>先来先执⾏</li>
<li>执⾏起来最快的先执⾏</li>
<li>占⽤资源最少的先执⾏</li>
<li>释放资源最多的先执⾏</li>
<li><p>⾼优先级的先执⾏</p>
<p>为什么需要排序？</p>
</li>
</ol>
<ul>
<li>最⼤化⽤户、客户和⽼板的整体满意度；</li>
<li>最⼤化价值与产出，让最多的资源投⼊到最有价值的需求上。</li>
</ul>
</li>
<li><p>设计与开发</p>
<p> <strong>规模化的设计思路，⼀⽅⾯是⾃顶向下去完成顶层设计</strong>。顶层设计主要做两件事：</p>
<ul>
<li>⼀是去建⽴系统的边界。系统提供什么？不提供什么？以怎样的形式提供？</li>
<li><p>⼆是去划定系统的区域。也就是系统的层次与划分，以及它们之间的通信路径。</p>
<p>⽽系统的区域划分，也是为了让系统内部各部分之间的耦合降低，从⽽让开发⼈员在属于⾃⼰的区域内更⾃由地发挥。</p>
<p><strong>规模化设计思路的另⼀⾯，就是要让系统具备⾃底向上的演化机能</strong>。因为，⾃顶向下的设计是前瞻性的设计，但没有⼈能做到完美的前瞻性设计；⽽⾃底向上的演化机能，是后验性的反应，它能调整修复前瞻性设计中可能的盲点缺陷。</p>
<p>⼀个规模化的系统既要靠前瞻的设计视野，也依赖后验的演化机能，这样才可能将前瞻蓝图变成美好现实。</p>
</li>
</ul>
</li>
<li><p>测试与运维</p>
<p> 以测试为例进⾏规模化的最佳⽅式，就是打造⼀条 “测试机器” 流⽔线，⽽我在《转化：能⼒与输出》⼀⽂中写到了关于打造 “机器” 的三个核⼼点，这⾥再强调⼀次：</p>
<ul>
<li>流程规则</li>
<li>⼯具系统</li>
<li><p>规范共识</p>
<p>围绕这三个核⼼点，我们再来看看 “测试机器” 如何打造？</p>
<p>从开发提测，机器⾃动下载提测版本分⽀代码，进⾏构建编译打包，实施代码规范性检查测试，通过后发布测试环境，进⾏分层次的各类⾃动化专项测试。如：⽤户终端层、通信协议层、服务接⼝层、数据存储层的各项测试，全部通过后，⽣成相应的测试报告，进⼊下⼀步发布流程。这就是测试体系的“流程”，⽽“规则”就是其中定义的各种测试项检查约束。</p>
<p>上述流程中涉及的“⼯具系统”包括：代码规范检查⼯具、终端 UI 的⾃动化测试⼯具、通信协议与服务端接⼝调⽤的模拟⼯具、数据⼀致性校验⼯具、测试报告⽣成⼯具、测试 Bug 统计分析与收敛趋势等可视化展现⼯具，等等。</p>
<p>最后，“规范共识” 是整个团队对这个流程环节、⾥⾯具体规则的定义以及 Bug 分类等⽅⾯达成的共识，这决定了这台 “测试机器” 运转的协调性与效率。</p>
<p>测试通过后，发布到线上就进⼊了运维阶段，⾏业⾥已经有⼤量的关于 DevOps 的分享内容，⽽它的本质也就是打造了⼀台“运维机器” 流⽔线，这和我上⾯描述的 “测试机器” 运转类同，只是有不同的规范共识、流程规则和⼯具系统，便不再赘述了。</p>
<p>到了规模化的测试与运维阶段，看⼀个团队的⽔平，就是看这台 “机器” 的制作⽔准与运转效率。</p>
</li>
</ul>
</li>
</ol>
<h3 id="38-思维：科学与系统——两类问题的两种思维解法"><a href="#38-思维：科学与系统——两类问题的两种思维解法" class="headerlink" title="38 | 思维：科学与系统——两类问题的两种思维解法"></a>38 | 思维：科学与系统——两类问题的两种思维解法</h3><p>写了多年代码，做了好多的⼯程，不停地完成项⽬，但如果你⼀直仅仅停留在重复这个过程，那么就不会得到真正的成⻓与提<br>⾼。你得从这些重复做⼯程的过程中，抽象提炼出真正解决问题的⼯程思维，⽤来指导未来的⼯程实践。</p>
<p><strong>⼯程思维：⼀种具备科学理论⽀撑，并成体系的系统化思维</strong>。</p>
<p>做了多年的软件开发⼯程，碰到和解决了数不清的问题，最终这些问题，我发现稍微抽象⼀下，可以归为以下两类：</p>
<ul>
<li>可以简单归因的问题：属于直接简单的因果关系；</li>
<li>难以简单归因的问题：属于间接复杂的因果关系。</li>
</ul>
<p>上⾯的描述可能有点抽象，那具体该怎么理解呢？这⾥我分别举两个例⼦：线上有个 Bug，找到了有问题代码⽚段，需要⼀个优化实现⽅案来解决，这就是第⼀类问题，原因和结果⾮常明确清晰；线上⽼是出故障，⽽且反复总出意外故障，对于这个结果，它的原因是什么，这就很难简单归因了，就属于第⼆类问题。</p>
<p>对于这两类问题，我想讲讲两种不同的思维框架提供的解法。</p>
<ol>
<li><p>科学与理论</p>
<p> 第⼀类问题，现象清晰，归因明确，那么它唯⼀的难处就是为这个问题找到最优的解决⽅案。求解最优化问题，就需要科学与理论的⽀持，也即：<strong>科学思维</strong>。</p>
<p> 吴军⽼师也曾在⼀篇⽂章《计算机科学与⼯程的区别》⾥指出：</p>
<blockquote>
<p>科学常常指出正确的⽅向，⽽⼯程则是沿着科学指出的⽅向建设道路；在⼯程中必须⾸先使⽤在科学上最好的⽅法，然后再作细节的改进。</p>
</blockquote>
<p> 我做在线客服系统时碰到⼀个问题和滴滴打⻋的匹配问题⾮常类似，打⻋是⼈和⻋的匹配，⽽咨询客服是⼈和客服的匹配。抽象来看，这个匹配的算法并不复杂，但因为涉及到⾮常具体且繁琐的业务规则，实现起来就有特别多业务逻辑，导致性能有问题。这就是软件⼯程现实中的第⼀类问题，需要找到优化⽅案。</p>
<p> 理论的意义不在于充当蓝图，⽽在于为⼯程设计实践提供有约束⼒的原理；⽽⼯程设计则依循⼀切有约束⼒的理论，为实践作切实可⾏的筹划。</p>
<p> <strong>简⾔之，科学理论确定了上限，⼯程实践画出了路线。</strong></p>
</li>
<li><p>系统与反馈</p>
<p> 第⼆类问题，结果明确，但归因很难，那么找到真正的原因就是第⼀个需要解决的难点。这时，我们就需要⽤另⼀种思维⽅式：<strong>系统思维</strong>。</p>
<p> 回到前⾯举的例⼦，线上⽼是出故障，⽽且反复出意外故障。如果简单归因，查出故障直接原因，发现是代码写得不严谨，实现有不少漏洞和问题，仔细看就能分析出来，但触发条件罕⻅不容易测出来，于是提出解决⽅案是增加代码评审（CodeReview）流程来保障上线代码的质量。</p>
<p> 关于代码评审就是我从业多年来遇到的⼀个⾮常有意思的问题，⼤家都觉得它有⽤，也都说好，但很多时候就是执⾏不下去。因为它不是⼀个简单问题，⽽是⼀个系统问题。万维钢在《线性思维与系统思维》这篇⽂章⾥，给出了⼀些系统问题的典型特征，其中有两条是这样说的：</p>
<blockquote>
<p>多次试图解决⼀个问题，却总是⽆效；</p>
<p>新⼈来了就发现问题，⽼⼈⼀笑了之。</p>
</blockquote>
</li>
</ol>
<p>⼀个优秀的⼯程师应该同时具备科学思维和系统思维，它们是⼯程思维的两种不同表现形态：<strong>系统思维洞察问题本质，科学思维发现最优解法</strong>。</p>
<h2 id="五、徘徊：道中彷徨"><a href="#五、徘徊：道中彷徨" class="headerlink" title="五、徘徊：道中彷徨"></a>五、徘徊：道中彷徨</h2><h2 id="六、寻路：路在何方"><a href="#六、寻路：路在何方" class="headerlink" title="六、寻路：路在何方"></a>六、寻路：路在何方</h2><h2 id="七、蜕变：破茧成蝶"><a href="#七、蜕变：破茧成蝶" class="headerlink" title="七、蜕变：破茧成蝶"></a>七、蜕变：破茧成蝶</h2><h2 id="八、结束语"><a href="#八、结束语" class="headerlink" title="八、结束语"></a>八、结束语</h2>
                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://kibazen.cn" rel="external nofollow noreferrer">Kiba Amor</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                    </span>
                <span class="reprint-info">
                    <a href="https://kibazen.cn/cheng-xu-yuan-jin-jie-gong-lue-xue-xi-bi-ji/">https://kibazen.cn/cheng-xu-yuan-jin-jie-gong-lue-xue-xi-bi-ji/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY-NC-ND 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://kibazen.cn" target="_blank">Kiba Amor</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                                    <span class="chip bg-color">极客时间</span>
                                </a>
                            
                                <a href="/tags/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/">
                                    <span class="chip bg-color">职业规划</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="qq,wechat,weibo,douban" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/cheng-xu-yuan-jin-jie-gong-lue-xue-xi-bi-ji/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/18.jpg" class="responsive-img" alt="《程序员进阶攻略》学习笔记">
                        
                        <span class="card-title">《程序员进阶攻略》学习笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-01-11
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                    学习笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                        <span class="chip bg-color">极客时间</span>
                    </a>
                    
                    <a href="/tags/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/">
                        <span class="chip bg-color">职业规划</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/xi-tong-xing-neng-diao-you-bi-zhi-bi-hui-xue-xi-bi-ji/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/5.jpg" class="responsive-img" alt="《系统性能调优必知必会》学习笔记">
                        
                        <span class="card-title">《系统性能调优必知必会》学习笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-01-10
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                    学习笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                        <span class="chip bg-color">极客时间</span>
                    </a>
                    
                    <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">
                        <span class="chip bg-color">性能优化</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (true) {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 木叶禅<br />'
            + '文章作者: Kiba Amor<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者木叶禅所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('2'),
            headingSelector: 'h2, h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2022</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">Kiba Amor</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">703.5k</span>&nbsp;字
            
            
            
            
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/kibaamor" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>









    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=562236616" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 562236616" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>





    <a href="https://www.zhihu.com/people/kibaamor" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/kibaamor" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    

    

    

	
    

    

    

    
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
