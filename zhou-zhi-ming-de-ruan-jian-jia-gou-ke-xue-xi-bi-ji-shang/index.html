<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <meta name="keywords" content="《周志明的软件架构课》学习笔记（上）, kiba, zen, amor, kibazen, kibaamor, 木叶, 木叶禅">
    <meta name="description" content="You are too concerned with what was and what will be">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>《周志明的软件架构课》学习笔记（上） | 木叶禅</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/css/my.css">

    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="木叶禅" type="application/atom+xml">
</head>



   <style>
    body{
       background-image: url(/medias/background.jpg);
       background-repeat:no-repeat;
       background-size:cover;
       background-attachment:fixed;
    }
</style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">木叶禅</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/learn/" class="waves-effect waves-light">
      
      <i class="fas fa-book" style="zoom: 0.6;"></i>
      
      <span>Learn</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/memo/" class="waves-effect waves-light">
      
      <i class="fas fa-sticky-note" style="zoom: 0.6;"></i>
      
      <span>Memo</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories/" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags/" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about/" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">木叶禅</div>
        <div class="logo-desc">
            
            You are too concerned with what was and what will be
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/learn/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-book"></i>
			
			Learn
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/memo/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-sticky-note"></i>
			
			Memo
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    
<script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = 'f65e070788a2647953051a7a1b70ada7fd2b3f70cd4d93c977207f5b762987d4';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/16.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">《周志明的软件架构课》学习笔记（上）</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                                <span class="chip bg-color">极客时间</span>
                            </a>
                        
                            <a href="/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/">
                                <span class="chip bg-color">软件架构</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                学习笔记
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-03-06
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2023-04-11
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    35.8k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    124 分
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="开篇词"><a href="#开篇词" class="headerlink" title="开篇词"></a>开篇词</h2><h3 id="如何构建一个可靠的分布式系统？"><a href="#如何构建一个可靠的分布式系统？" class="headerlink" title="如何构建一个可靠的分布式系统？"></a>如何构建一个可靠的分布式系统？</h3><p>作为一名架构师，在软件研发的过程中，最难的事儿，其实并不是如何解决具体某个缺陷、如何提升某段代码的性能，而是 <strong>如何才能让一系列来自不同开发者、不同厂商、不同版本、不同语言、质量也良莠不齐的软件模块，在不同的物理硬件和拓扑结构随时变动的网络环境中，依然能保证可靠的运行质量。</strong></p>
<p>显然，这并不是一个研发过程的管理问题。一套”靠谱”的软件系统，尤其是大型的、分布式的软件系统，很难指望只依靠团队成员的个人能力水平，或者依靠质量管理流程来达成。</p>
<p>在我看来，这是一个系统性的、架构层面的问题，最终还是要在技术和架构中去解决。而这也正是我要在这门课中跟你一起探讨的主题： <strong>如何构建一个可靠的分布式系统。</strong></p>
<h4 id="我是怎么规划课程的？"><a href="#我是怎么规划课程的？" class="headerlink" title="我是怎么规划课程的？"></a>我是怎么规划课程的？</h4><p>那么，为了能够讨论清楚这个话题，我把课程划分成了以下 5 个模块。</p>
<ol>
<li><p><strong>演进中的架构</strong>: 我会借着讨论历史之名，从全局性的视角，帮你梳理微服务发展历程中出现的大量技术名词、概念，让你了解这些技术的时代背景和探索过程，帮你在后续的课程讲解中，更容易去深入理解软件架构设计的本质。</p>
</li>
<li><p><strong>分布式的基石</strong>：我会聚焦在分布式架构，和你探讨分布式带来的问题与应对策略。我会带你剖析分布式架构中出现的一系列问题，比如服务的注册发现、跟踪治理、负载均衡、故障隔离、认证授权、伸缩扩展、传输通讯、事务处理等，有哪些解决思路、方法和常见工具。</p>
</li>
<li><p><strong>不可变基础设施</strong>：我会按照云原生时代”基础设施即代码”的新思路，带你深入理解基础设施不变性的目的、原理与实现途径，和你一起去体会用代码和用基础设施，来解决分布式问题的差异，让你能够理解不可变基础设施的内涵，便于在实际工作中做运维、程序升级和部署等工作。</p>
</li>
<li><p><strong>探索与实践</strong>：我会带你一起开发不同架构的 Fenix”s Bookstore（”<a target="_blank" rel="noopener" href="http://time.geekbang.org/column/article/309747">导读</a>“这一讲会具体介绍这个项目），并看看在不同环境下都应该怎么部署。这个模块的定位是”实战”，为了保证学习效果，我特意没有安排音频，所以建议你一定要自己动手去实操。</p>
</li>
</ol>
<p>因为我相信，如果你是一名驾驶初学者，最合理的学习路径应该是先把汽车发动，然后慢慢行驶起来，而不是马上从”引擎动力原理””变速箱构造”入手，去设法深刻地了解一台汽车。学习计算机技术也是同样的道理。所以在”探索与实践”模块，我会先带你从运行程序开始，看看效果，然后再搭建好开发、调试环境。</p>
<p>说到这里，我一定要和你说说怎么学习这门课，才能保证最好的效果。</p>
<h4 id="你要怎么学习这门课？"><a href="#你要怎么学习这门课？" class="headerlink" title="你要怎么学习这门课？"></a>你要怎么学习这门课？</h4><p>如果你已经是一名系统架构师或者高级开发工程师了，那这门课程就非常适合你。通过跟随学习，你会知道，在软件设计、架构工作中，都需要考虑哪些因素、需要解决哪些问题、有哪些行业标准的解决方案。而如果你是个刚入行不久的程序员，那你可以把这门课程作为一个概念名词的速查手册。</p>
<p>很多内容对你来说可能是全新的，甚至会颠覆你过去的一些认知。而这门课程的好处就是，在不同的技术水平阶段，你都会找到不同的使用方法。具体怎么做呢？</p>
<ul>
<li>第一步，先完整地跟着课程的节奏学习一遍。你可以先去串一下各种技术名词和架构理论概念，拓展一下视野，去看看大型的架构项目是怎么搭建的，涨涨见识，不一定要求自己深入地理解和记住每一讲的内容。</li>
<li>第二步，根据自己当前的情况，按图索骥寻找对应的章节深入学习并实践。</li>
<li>第三步，当你有了一定的实践经验之后，再来重新学习对应的章节，看看自己曾经的理解是否有遗漏或者有偏差，或者看看我的内容是否还有不完善的地方，真正将知识变成自己的认知。</li>
</ul>
<h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>最后，我想说的是，我在极客时间上开设这门课程，既是为了分享与技术布道，也是为了借这个机会，系统性地整理自己的知识，查缺补漏，将它们都融入既有的知识框架之中。</p>
<p><strong>我一直认为，技术人员的成长是有”捷径”的，做技术不仅要去看、去读、去想、去用，更要去写、去说。</strong></p>
<p>把自己”认为掌握了的”知识给叙述出来，能够写得条理清晰，讲得理直气壮；能够让别人听得明白，释去心中疑惑；能够把自己的观点交给别人审视，乃至质疑。在这个过程之中，就会挖掘出很多潜藏在”已知”背后的”未知”。</p>
<h3 id="什么是”The-Fenix-Project”？"><a href="#什么是”The-Fenix-Project”？" class="headerlink" title="什么是”The Fenix Project”？"></a>什么是”The Fenix Project”？</h3><h4 id="软件架构探索"><a href="#软件架构探索" class="headerlink" title="软件架构探索"></a>软件架构探索</h4><p>“Phoenix”的字面意思，就是”凤凰”，或者是”不死鸟”，这个词我们东方人不太常用，但它在西方的软件工程读物，尤其是关于 Agile、DevOps 话题的作品中经常会出现。</p>
<p>比如说，软件工程小说《<a target="_blank" rel="noopener" href="https://book.douban.com/subject/20644908/">The Phoenix Project</a>》，就讲述了徘徊在死亡边缘的 Phoenix 项目，在精益方法下浴火重生的故事；马丁 · 福勒（Martin Fowler）对《<a target="_blank" rel="noopener" href="https://book.douban.com/subject/4327796/">Continuous Delivery</a>》（持续交付）的诠释里，也多次提到过”<a target="_blank" rel="noopener" href="https://martinfowler.com/bliki/PhoenixServer.html">Phoenix Server</a>“（取其能够”涅槃重生”之意）与”<a target="_blank" rel="noopener" href="https://martinfowler.com/bliki/SnowflakeServer.html">Snowflake Server</a>“（取其”世界上没有相同的两片雪花”之意）的优劣比对。</p>
<p><img src="https://fastly.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《周志明的软件架构课》学习笔记/ThePhoenixProject.webp" alt="ThePhoenixProject"></p>
<p>也许是东西方文化差异的原因，尽管我们东方人会说”失败是成功之母”，但骨子里还是更注重一次就能把事做对、做好，尽量别出乱子；而西方人则要”更看得开”一些，把出错看作是正常、甚至是必须的发展过程，只要出了问题能够兜底，能重回正轨就好。</p>
<p>其实在软件工程的世界里，任何产品的研发，只要时间尺度足够长，人就总会疏忽犯错，代码就总会带有缺陷，电脑就总会宕机崩溃，网络就总会堵塞中断……</p>
<p>所以如果一项工程需要大量的人员共同去研发，并保证它们分布在网络中的大量服务器节点能够同时运行，那么随着项目规模的增大、运作时间变长，它必然会受到墨菲定律的无情打击。</p>
<blockquote>
<p>Murphy”s Law: Anything that can go wrong will go wrong.</p>
<p>墨菲定律：凡事只要有可能出错，那就一定会出错。</p>
</blockquote>
<p><strong>这样问题就来了：为了得到高质量的软件产品，我们是应该把精力更多地集中在提升每一个人员、过程、产出物的能力和质量上，还是放在整体流程和架构上？</strong></p>
<p>这里我先给一个”和稀泥”式的回答：这两者都重要。前者重术，后者重道；前者更多与编码能力相关，后者更多与软件架构相关；前者主要由开发者个体水平决定，后者主要由技术决策者水平决定。</p>
<p>但是，我也必须要强调这个问题的另外一面：这两者的理解路径和抽象程度是不一样的。</p>
<p>如何学习一项具体的语言、框架、工具，比如 Java、Spring、Vue.js，等等，都是相对具象的，不论其蕴含的内容多少、复杂程度的高低，它们至少是能看得见、摸得着的。</p>
<p>而如何学习某一种风格的架构方法，比如单体、微服务、服务网格、无服务、云原生，等等，则是相对抽象的，谈论它们可能要面临着”一百个人眼中有一百个哈姆雷特”的困境。</p>
<p>所以，探讨这方面的话题，要想言之有物，就不能只是单纯的经验陈述了。</p>
<p>那么我就想，回到这些架构根本的出发点和问题上，带你一起真正去使用这些不同风格的架构方法，来实现某些需求、解决某些问题，然后在实践中观察它们的异同优劣，这会是一种很好的，也许是最好的学习方式。</p>
<h4 id="可靠的系统"><a href="#可靠的系统" class="headerlink" title="可靠的系统"></a>可靠的系统</h4><p>我们接着前面提出的”人与系统”的探讨，再来思考一个问题： <strong>构建一个大规模但依然可靠的软件系统，是否可行？</strong></p>
<p>看到这个问题，你的第一感觉可能会认为有点荒谬：废话。如果这个事情从理论上来说就根本不可能的话，那我们这些做软件开发的还在瞎忙活些什么呢？</p>
<p>但你再仔细想想，根据”墨菲定律”和在”大规模”这个前提下，在做软件开发时，你一定会遇到各种不靠谱的人员、代码、硬件、网络等因素。那你从中就能得出一个听起来很符合逻辑直觉的推论： <strong>如果一项工作，要经过多个”不靠谱”的过程相互协作来完成，其中的误差应该会不断地累积叠加，导致最终结果必然不能收敛稳定才对。</strong></p>
<p>这个问题，也并不是杞人忧天、庸人自扰式的瞎操心，计算机之父冯 · 诺依曼（John von Neumann）在 1940 年代末期，就曾经花了大约两年的时间，来研究这个问题，并且得出了一门理论《自复制自动机》（Theory of Self-Reproducing Automata），这个理论以机器应该如何从基本的部件中，构造出与自身相同的另一台机器引出。</p>
<p>他的目的并不是想单纯地模拟或者理解生物体的自我复制，也并不是简单地想制造自我复制的计算机，而就是想回答一个理论问题： <strong>如何用一些不可靠的部件来构造出一个可靠的系统。</strong></p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Self-replicating_machine"><img src="https://fastly.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《周志明的软件架构课》学习笔记/当时自复制机的艺术表示.webp" alt="当时自复制机的艺术表示"></a></p>
<p>所以说，自复制机恰好就是一个最好的、用不可靠部件构造的可靠系统的例子。这里的”不可靠部件”，你可以理解为构成生命的大量细胞、甚至是分子。由于热力学扰动、生物复制差错等因素的干扰，这些分子本身并不可靠。</p>
<p>但是，生命系统之所以可靠的本质，恰恰是因为它可以使用不可靠的部件来完成遗传迭代。这其中的关键点，便是承认细胞、分子等这些零部件可能会出错，某个具体的零部件可能会崩溃消亡，但在存续生命的微生态系统中，一定会有其后代的出现，重新代替该零部件的作用，以维持系统的整体稳定。</p>
<p>因而，在这个微生态里，每一个部件都可以看作是一只不死鸟（Phoenix），它会老迈，而之后又能涅槃重生。</p>
<p>虽然几乎是在计算机诞生的同时，计算机科学家就开始研究如何构造可靠的软件系统，并且得到了”像 Phoenix 一样迭代的生态才是可靠的”明确的结论，但是软件架构却不是一蹴而就地直接照这个结论去设计。原因也很简单，因为软件架构有一个逐渐演进的过程。</p>
<h4 id="架构的演进"><a href="#架构的演进" class="headerlink" title="架构的演进"></a>架构的演进</h4><p>软件架构风格从大型机（Mainframe），发展到了多层单体架构（Monolithic），到分布式（Distributed），到微服务（Microservices），到服务网格（Service Mesh），到无服务（Serverless）……你能发现，在技术架构上确实呈现出”从大到小”的发展趋势。</p>
<p>这几年微服务兴起后，出现了各类文章去总结、去赞美它的各种好处，比如简化了部署、逻辑拆分更清晰、便于技术异构、易于伸缩拓展应对更高的性能，等等。没错，这些都是微服务架构非常重要的优点，也是企业去搭建微服务的动力。</p>
<p>可是，如果不拘泥于特定系统或特定的某个问题，我们从更宏观的角度来看，前面所列举的这些好处，都只能算是”锦上添花”、是让系统”活得更好”的动因，肯定比不上系统如何”确保生存”的需求来得更关键、本质。</p>
<p>在我看来，架构演变最重要的驱动力，或者说产生这种”从大到小”趋势的最根本的驱动力，始终都是 <strong>为了方便某个服务能够顺利地”死去”与”重生”而设计</strong> 的。个体服务的生死更迭，是关系到整个系统能否可靠续存的关键因素。</p>
<p>我举个例子。假设某个企业中应用的是单体架构的 Java 系统，它的更新、升级都必须要有固定的停机计划，必须在特定的时间窗口内才能按时开始，而且必须按时结束。如果出现了非计划之中的宕机，那就是生产事故。</p>
<p>但是，软件的缺陷不会遵循领导定下的停机计划来”安排时间出错”，所以为了应对缺陷与变化，做到不停机地检修，Java 曾经搞出了 OSGi 和 JVMTI Instrumentation 等这样复杂的 HotSwap 方案，以实现给奔跑中的汽车更换轮胎这种匪夷所思却又无可奈何的需求。</p>
<p>而在微服务架构的视角下，所谓的系统检修，只不过是一次在线服务更新而已，先停掉 1/3 的机器，升级新的软件版本，再有条不紊地导流、测试、做金丝雀发布，一切都是显得如此理所当然；而在无服务架构的视角下，我们甚至都不可能去关心服务所运行的基础设施，甚至连机器是哪台都不用知道，停机升级什么的就根本无从谈起了。</p>
<p><strong>流水不腐，有老朽、有消亡、有重生、有更迭，才是正常生态的运作合理规律。</strong></p>
<p>那么你来设想一下，如果你的系统中，每个部件都符合”Phoenix”的特性，哪怕其中的某些部件采用了极不靠谱的程序代码，哪怕存在严重的内存泄漏问题，最多只能服务三分钟就一定会崩溃。而即便这样，只要在整体架构设计中，有恰当的、自动化的错误熔断、服务淘汰和重建的机制，那在系统外部来观察，它在整体上仍然有可能表现出稳定和健壮的服务能力。</p>
<p>铺垫到这里，我就可以给你解释清楚，到底什么是”The Fenix Project”了。</p>
<h4 id="为什么叫做”The-Fenix-Project”？"><a href="#为什么叫做”The-Fenix-Project”？" class="headerlink" title="为什么叫做”The Fenix Project”？"></a>为什么叫做”The Fenix Project”？</h4><p>你应该也知道，在企业软件开发的历史中，当发布一项新技术的时候，常常会有伴以该技术开发的”宠物店（PetStore）”作为演示的传统（如J2EE PetStore、.NET PetShop、Spring PetClinic等）。</p>
<p>所以，在课程里，我在带你做不同架构风格的演示时，也希望能遵循这个传统。不过无奈的是，我从来没养过宠物，于是就改行开了书店（Fenix”s Bookstore），里面出售了几本我写过的书，算是夹带了一点私货，这样也避免了在使用素材时可能产生的版权问题。</p>
<p>另外，尽管我相信没有人会误解，但我还是想多强调一句，Oracle、Microsoft、Pivotal 等公司设计宠物店的目的，绝不是为了日后能在网上贩卖小猫小狗，他们只是在纯粹地演示技术。</p>
<p>所以说，你也不要以”实现这种学生毕业设计复杂度的需求，却引入如此规模的架构或框架，纯属大炮打苍蝇，肯定是过度设计”的眼光，来看待这个”Fenix”s Bookstore”项目。</p>
<p>相反，如果可能的话，我会在有新的技术、框架发布出来的时候，持续更新，以恰当的形式添加到项目的不同版本中，让它的技术栈越来越复杂。我希望把这些新的、不断发展的知识，融合进已有的知识框架之中，让自己学习、理解、思考，然后将这些技术连同自己的观点看法，分享给你。</p>
<p>说到这儿，我和”Fenix”这个名字还有一段奇妙的缘分。在二十多年前，我就开始用”IcyFenix”这个网名了。这个名字来源于暴雪公司的即时战略游戏《星际争霸》，里面有一个 Protoss（普罗托斯）英雄叫Fenix（菲尼克斯）。就像这个名字所预示的那样，Fenix 曾经是 Zealot（狂热者），牺牲后以 Dragoon（龙骑兵）的形式重生，带领 Protoss 与刀锋女王 Kerrigan（凯瑞甘）继续抗争。</p>
<p>所以，既然我们要开始一段关于”Phoenix”的代码与故事，那便叫它”The Fenix Project”，如何？</p>
<h2 id="演进中的架构"><a href="#演进中的架构" class="headerlink" title="演进中的架构"></a>演进中的架构</h2><h3 id="01-原始分布式时代：Unix设计哲学下的服务探索"><a href="#01-原始分布式时代：Unix设计哲学下的服务探索" class="headerlink" title="01 | 原始分布式时代：Unix设计哲学下的服务探索"></a>01 | 原始分布式时代：Unix设计哲学下的服务探索</h3><p>架构并不是被”发明”出来的，而是持续进化的结果。所以在这一模块中，我会借着讨论历史之名，从全局性的视角，来带你一起梳理下微服务的发展历程中，出现的大量技术名词、概念。</p>
<p>我会和你一起去分析，它们都是什么、取代了什么，以及为什么能够在技术发展的斗争中取得成功，为什么会成为软件架构不可或缺的支撑；又或者它们为什么会失败，为什么会逐渐被我们遗忘。</p>
<p>了解了这些技术的时代背景和探索过程，在后续的课程中，我再去讲解它们的原理、它们是如何解决问题的时候，你就能与它们当初的设计思想产生共鸣，能更容易深入理解其本质了。</p>
<p>今天这一讲，让我们先把时间拨回到半个世纪之前，一起来探讨下计算机最开始进入公众视野的时候，在 Unix 设计哲学的指导下，分布式架构的第一次服务化探索的得与失。</p>
<blockquote>
<p><strong>Unix 的分布式设计哲学</strong></p>
<p>Simplicity of both the interface and the implementation are more important than any other attributes of the system — including correctness, consistency, and completeness.</p>
<p>保持接口与实现的简单性，比系统的任何其他属性，包括准确性、一致性和完整性，都来得更加重要。</p>
<p>—— <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Richard_P._Gabriel">Richard P. Gabriel</a>，<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Worse_is_better">The Rise of ‘Worse is Better</a>，1991</p>
</blockquote>
<p>分布式架构的目标是使用多个独立的分布式服务，来共同构建一个更大型的系统。不过，可能跟绝大多数人心中的认知有点儿差异，分布式系统的设想和它实际的尝试，反而要比你今天所了解的大型单体系统出现的时间更早。</p>
<p>在 20 世纪 70 年代末到 80 年代初，计算机科学刚经历了从以大型机为主，到向以微型机为主的蜕变，计算机也逐渐从一种存在于研究机构、实验室当中的科研设备，转变为了存在于商业企业中的生产设备，甚至是面向家庭、个人用户的娱乐设备。</p>
<p>这个时候的微型计算机系统，通常具有 16 位寻址能力、不足 5MHz（兆赫）时钟频率的处理器和 128KB 左右的内存地址空间。比如说，著名的英特尔处理器的鼻祖，<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-tw/Intel_8086">Intel 8086 处理器</a> 就是在 1978 年研制成功，流行于 80 年代中期的，甚至一直到 90 年代初期还在生产销售。</p>
<p>不过，因为当时的计算机硬件的运算处理能力还相当薄弱，已经直接妨碍了单台计算机上信息系统软件能够达到的最大规模。所以，为了突破硬件算力的限制，各个高校、研究机构、软硬件厂商，都开始分头探索，想看看到底能不能使用多台计算机共同协作，来支撑同一套软件系统的运行。</p>
<p>这个阶段其实是对分布式架构最原始的探索与研究。你可能会觉得奇怪， <strong>计算机科学这个技术发展一日千里的领域，半个世纪之前的研究对今天还能有什么指导意义？</strong> 那个时候探索的分布式如果是可行的，又怎么会拖到今时今日，软件系统才逐步进入微服务时代？</p>
<p>然而并非如此，从结果来看，历史局限决定了它不可能一蹴而就地解决分布式的难题，但仅从过程来看，这个阶段的探索可以称得上是硕果累累、成绩斐然。因为在这个时期提出的很多技术、概念，对 Unix 系统后续的发展，甚至是对今天计算机科学的很多领域，都产生了巨大而深远的影响，直接带动了后续的软件架构演化进程。</p>
<p>我们看一些比较熟悉的例子吧。</p>
<p>比如，惠普公司（及后来被惠普收购的 Apollo），在 80 年代初期提出的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Network_Computing_System">网络运算架构（Network Computing Architecture，NCA）</a> ，就可以说是未来远程服务调用的雏形。</p>
<p>再比如，卡内基 · 梅隆大学提出的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Andrew_File_System">AFS 文件系统（Andrew File System）</a> ，可以看作是分布式文件系统的最早实现（顺便一提，Andrew 的意思是纪念 Andrew Carnegie 和 Andrew Mellon）。</p>
<p>再比如，麻省理工学院提出的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Kerberos_(protocol">Kerberos 协议</a>) ，是服务认证和访问控制（ACL）的基础性协议，是分布式服务安全性的重要支撑，目前包括 Windows 和 macOS 在内的众多操作系统的登录、认证功能，等等，都会利用到这个协议。</p>
<p>而为了避免 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Unix_wars">Unix 系统的版本战争</a> 在分布式领域中重演，负责制定 Unix 系统技术标准的 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%96%8B%E6%94%BE%E8%BB%9F%E9%AB%94%E5%9F%BA%E9%87%91%E6%9C%83">开放软件基金会（Open Software Foundation，OSF，也就是后来的”国际开放标准组织”）</a> 就邀请了各个主要的研究厂商一起参与，共同制订了 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%88%86%E6%95%A3%E5%BC%8F%E9%81%8B%E7%AE%97%E7%92%B0%E5%A2%83">“分布式运算环境”（Distributed Computing Environment，DCE）</a> 的分布式技术体系。</p>
<p><strong>DCE 包括了一整套完整的分布式服务组件的规范与实现。</strong></p>
<p>比如，源自 NCA 的远程服务调用规范（Remote Procedure Call，RPC，在当时被称为是 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/DCE/RPC">DCE/RPC</a> ），跟后来不局限于 Unix 系统的、基于通用 TCP/IP 协议的远程服务标准 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%96%8B%E6%94%BE%E7%B6%B2%E8%B7%AF%E9%81%8B%E7%AE%97%E9%81%A0%E7%AB%AF%E7%A8%8B%E5%BA%8F%E5%91%BC%E5%8F%AB">ONC RPC</a> ，一起被认为是现代 RPC 的共同鼻祖（这是 Sun 公司向互联网工程任务组提交的）；源自 AFS 的分布式文件系统（Distributed File System，DFS）规范，在当时被称为 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/DCE_Distributed_File_System">DCE/DFS</a> ；源自 Kerberos 的服务认证规范；还有时间服务、命名与目录服务，就连现在程序中很常用的通用唯一识别符 UUID，也是在 DCE 中发明出来的。</p>
<p>因为 OSF 本身的背景（它是一个由 Unix 开发者组成的 Unix 标准化组织），所以在当时研究这些分布式技术，通常都会有一个预设的重要原则，也就是在实现分布式环境中的服务调用、资源访问、数据存储等操作的时候，要尽可能地透明化、简单化，让开发人员不用去过于关注他们访问的方法，或者是要知道其他资源是位于本地还是远程。</p>
<p>这样的主旨呢，确实非常符合 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Unix_philosophy#cite_note-0">Unix 设计哲学</a> （有过几个版本的不同说法，这里我指的是 Common Lisp 作者 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Richard_P._Gabriel">Richard P. Gabriel</a> 提出的简单优先” <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/KISS_principle">Worse is Better</a> “原则），但这个目标其实是过于理想化了，它存在一些在当时根本不可能完美解决的技术困难。</p>
<p>“调用远程方法”与”调用本地方法”尽管只是两字之差，但要是想能同时兼顾到简单、透明、性能、正确、鲁棒（Robust）、一致的目标的话，两者的复杂度就完全不能相提并论了。</p>
<p>我们先不说，远程方法是不可能做到像本地方法一样，能用内联等传统编译原理中的优化算法，来提升程序运行速度的，光是”远程”二字带来的网络环境下的新问题。</p>
<p>比如说，远程的服务在哪里（服务发现）、有多少个（负载均衡）、网络出现分区、超时或者服务出错了怎么办（熔断、隔离、降级）、方法的参数与返回结果如何表示（序列化协议）、如何传输（传输协议）、服务权限如何管理（认证、授权）、如何保证通信安全（网络安全层）、如何令调用不同机器的服务能返回相同的结果（分布式数据一致性）等一系列问题，就需要设计者耗费大量的心思。</p>
<p>那么，面对重重的困难与压力， <strong>DCE 不仅从零开始、从无到有地回答了其中大部分问题，构建出了大量的分布式基础组件与协议，而且它还真的尽力去做到了相对意义的”透明”。</strong></p>
<p>比如说，你在 DFS 上访问文件，如果不考虑性能上的差异的话，就很难感受到，它与本地磁盘文件系统有什么不同。可是，一旦考虑性能上的差异，分布式和本地的鸿沟是无比深刻的，这是数量级上的差距，是不可调和的。</p>
<p>尤其是在那个年代，在机器硬件的限制下，开发者为了让程序在运行效率上可以接受，就只有在方法本身的运行时间很长，可以相对忽略远程调用成本时的情况下，才去考虑使用分布式。如果方法本身的运行时长不够，就要人为地用各种奇技淫巧来刻意构造出这样的场景，比如可能会将几个原本毫无关系的方法打包到一个方法内，一块进行远程调用。</p>
<p>一方面，刻意构造长时间运行的方法这本身就与使用分布式来突破硬件算力、提升性能的初衷相互矛盾，需要我们小心平衡；另一方面，此时的开发人员，实际上仍然必须无时无刻地都要意识到，自己是在编写分布式的程序，不能随随便便地踏过本地与远程的界限，让软件系统的设计向性能做出妥协，让 DCE”尽量简单透明”的努力几乎全部付诸东流。</p>
<p>因为本地与远程，无论是从编码、部署，还是从运行效率的角度上看，都有着天壤之别，所以在设计一个能运作良好的分布式应用的时候，就变得需要极高的编程技巧和各方面的知识来作为支撑，这个时候，反而是人员本身对软件规模的约束，超过机器算力上的约束了。</p>
<p>对 DCE 的研究呢，算得上是计算机科学中第一次有组织领导、有标准可循、有巨大投入的分布式计算的尝试。但无论是 DCE，还是稍后出现的 CORBA（Common ObjectRequest Broker Architecture，公共对象请求代理体系结构），我们从结果来看，都不能说它们取得了成功。</p>
<p>因为把一个系统直接拆分到不同的机器之中，这样做带来的服务的发现、跟踪、通讯、容错、隔离、配置、传输、数据一致性和编码复杂度等方面的问题，所付出的代价远远超过了分布式所取得的收益。</p>
<p>而亲身经历过那个年代的计算机科学家、IBM 院士凯尔 · 布朗（Kyle Brown），在事后曾经评价道，”这次尝试最大的收获就是对 RPC、DFS 等概念的开创，以及得到了一个价值千金的教训：某个功能能够进行分布式，并不意味着它就应该进行分布式，强行追求透明的分布式操作，只会自寻苦果”。</p>
<blockquote>
<p><strong>原始分布式时代的教训</strong></p>
<p>Just because something can be distributed doesn”t mean it should be distributed. Trying to make a distributed call act like a local call always ends in tears.</p>
<p>某个功能能够进行分布式，并不意味着它就应该进行分布式，强行追求透明的分布式操作，只会自寻苦果。</p>
<p>—— Kyle Brown，IBM Fellow，Beyond buzzwords: A brief history of microservices patterns，2016</p>
</blockquote>
<p>其实，从设计角度来看，以上的结论是有违 Unix 哲学的，但这也是在当时的现实情况下，不得不做出的让步。在当时计算机科学面前，有两条通往更大规模软件系统的道路， <strong>一条路是尽快提升单机的处理能力，以避免分布式的种种问题；另一条路是找到更完美的解决方案，来应对如何构筑分布式系统的问题。</strong></p>
<p>在 20 世纪 80 年代，正是 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%91%A9%E5%B0%94%E5%AE%9A%E5%BE%8B">摩尔定律</a> 开始稳定发挥作用的黄金时期，微型计算机的性能以每两年就增长一倍的惊人速度在提升，硬件算力束缚软件规模的链条，很快就松动了，我们用单台或者几台计算机，就可以作为服务器来支撑大型信息系统的运作了，信息系统进入了单体时代，而且在未来很长的一段时间内，单体系统都将是软件架构的主流。</p>
<p>不过尽管如此，对于另外一条路径，也就是对分布式计算、远程服务调用的探索，开发者们也从没有中断过。关于远程服务调用这个关键问题的历史、发展与现状，我还会在服务设计风格的”远程服务调用”部分（第 7~10 讲），以现代 RPC 和 RESTful 为主角，来进行更详细的讲述。而对于在原始分布式时代中遭遇到的其他问题，我也还会在软件架构演进的后面几个时代里，反复提起它们。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>今天，我给你介绍了计算机科学对分布式和服务化的第一次探索，着重分析了这次探索的主旨思想，也就是追求简单、符合 Unix 哲学的分布式系统，以及它当时所面临的困难，比如在捉襟见肘的运算能力、网络带宽下，设计不得不做出的妥协。</p>
<p>在这个过程中，我们接触到了 DCE、CORBA 等早期的分布式基础架构。其中许多的技术，比如远程服务调用、分布式文件系统、Kerberos 认证协议等。如果你对这些技术觉得还有点陌生、或者还有很多疑惑，没有关系，我还会在后面的课程中为你着重介绍。</p>
<p>原始分布式时代提出的构建”符合 Unix 的设计哲学的”，以及”如同本地调用一般简单透明的”分布式系统的这个目标，是软件开发者对分布式系统最初的美好愿景。不过迫于现实，它会在一定时期内被妥协、被舍弃，分布式将会经过一段越来越复杂的发展进程。</p>
<p>但是，到了三十多年以后的今天，随着微服务的逐渐成熟完善，成为大型软件的主流架构风格以后，这个美好的愿景终将还是会重新被开发者拾起。</p>
<h4 id="一课一思"><a href="#一课一思" class="headerlink" title="一课一思"></a>一课一思</h4><p>Richard P. Gabriel 提出的 Unix 设计哲学中写到：”保持接口与实现的简单性，比系统的任何其他属性，包括准确性、一致性和完整性，都来得更加重要。”</p>
<p>现在你来思考一下： <strong>今天以微服务为代表的分布式系统，是如何看待”简单”的？</strong> 欢迎在留言区分享你的见解，我也将会在 <a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/312589">第 5 讲”后微服务时代”</a> 中，带你一起重新审视这个问题。</p>
<h4 id="精选留言"><a href="#精选留言" class="headerlink" title="精选留言"></a>精选留言</h4><ol>
<li><p>Jxin</p>
<p> 1.这个简单需要从两方面来看待，分别是业务和技术。</p>
<p> 2.先说业务。现代的软件系统的业务复杂性越来越高。而分离关注点无疑是应对日益增长的业务复杂性的有效手段。但如果依旧是是一个大单体系统（所有业务单元都在一个容器下），那么跨业务单元的知识诉求便很难避免，并且开发迭代以及版本发布中彼此还会相互影响。而微服务的出现为其提供了设定物理边界的技术基础。使得多个特性团队对业务知识的诉求可以收敛在自身领域，降低单个特性团队所需了解的业务知识。</p>
<p> 3.再说下技术。这里我认为主要提现在技术隔离上。就像rpc让你像调用本地方法一样调用远程方法，微服务技术组件的出现，大多是为了让开发人员可以基于意图去使用各种协调分布式系统的工具，而不用深入具体工具的实现细节去研究怎么解决的分布式难题。</p>
<p> 4.同时就像 springboot 提到的生产就绪，微服务的生态已经不局限于开发的阶段。在部署和运行阶段都有健全组件支持。它可以让开发人员基于意图就可以简便的实现金丝雀发布，基于意图就能拿到所有系统运行期的数据。所有的这些便利都算是技术隔离带来的好处。</p>
<blockquote>
<p>作者回复: 上述观点是比较深刻的。整个”演进中的架构”这部分，一条重要的逻辑线索就是软件工业对如何拆分业务、隔离技术复杂性的探索。从最初的不拆分，到通过越来越复杂的技术手段逐渐满足了业务的拆分与协作，再到追求隔离掉这些复杂技术手段，将它们掩埋于基础设施之中，到未来（有可能的）重新回到无需考虑算力、无需拆分的云端系统。</p>
</blockquote>
</li>
<li><p>LYy</p>
<p> 计算机技术一个关键命题是使用有限的”成本”尽可能”高效(性能)”的解决”复杂(度)”问题。</p>
<p> 分布式的初期探索，其实就是在单机性能有限的情况下，期望通过”集群化”、”分离变化点”的架构手段来提升性能，但由于时代限制，这条路线的成本过高，同时随着摩尔定律+时间，性能问题在单机上得到了阶段性解决，所以才有了后面的单体时代。</p>
<p> 但要解决的复杂度随着时代发展爆炸性增长，摩尔定律+时间这一法宝也日渐失灵，人们其实也不得不回到分布式这条路线上，于是有了后面微服务，云原生的故事。</p>
</li>
</ol>
<h3 id="02-单体系统时代：应用最广泛的架构风格"><a href="#02-单体系统时代：应用最广泛的架构风格" class="headerlink" title="02 | 单体系统时代：应用最广泛的架构风格"></a>02 | 单体系统时代：应用最广泛的架构风格</h3><p>这一讲，我会带你去了解以单体架构构建的软件系统，都有哪些优势和缺点，还有哪些容易让人产生错误理解的误区。在探索的过程中，你可以同时思考一下，为什么单体架构能够在相当长的时间里成为软件架构的主流风格，然后再对比下我在这一讲最后给出答案。</p>
<h4 id="大型单体系统"><a href="#大型单体系统" class="headerlink" title="大型单体系统"></a>大型单体系统</h4><p>单体架构是绝大部分软件开发者都学习和实践过的一种软件架构，很多介绍微服务的图书和技术资料中，也常常会把这种架构形式的应用称作 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Monolithic_application">“巨石系统”（Monolithic Application）</a> 。</p>
<p>在整个软件架构演进的历史进程里，单体架构是出现时间最早、应用范围最广、使用人数最多、统治历史最长的一种架构风格。但”单体”这个名称，却是从微服务开始流行之后，才”事后追认”所形成的概念。在这之前，并没有多少人会把”单体”看成一种架构。</p>
<p>如果你去查找软件架构的开发资料，可以轻轻松松找到很多以微服务为主题的图书和文章，但却很难能找到专门教我们怎么开发单体系统的任何形式的材料。</p>
<p>这一方面体现了单体架构本身的简单性；另一方面也体现出，在相当长的时间里，我们都已经习惯了，软件架构就应该是单体这种样子的。</p>
<p>那在剖析单体架构之前呢，我们有必要 <strong>先搞清楚一个思维误区</strong> ，那就是单体架构是落后的系统架构风格，最终会被微服务所取代。</p>
<p>因为在许多微服务的研究资料里，单体系统往往是以”反派角色”的身份登场的，比如著名的微服务入门书《 <a target="_blank" rel="noopener" href="https://book.douban.com/subject/33425123/">微服务架构设计模式</a> 》，第一章的名字就是”逃离单体的地狱”。而这些材料所讲的单体系统，其实都有一个没有明说的隐含定语：”大型的单体系统”。</p>
<p>对于小型系统，也就是用单台机器就足以支撑其良好运行的系统来说，这样的单体不仅易于开发、易于测试、易于部署，而且因为各个功能、模块、方法的调用过程，都是在进程内调用的，不会发生 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B%E9%96%93%E9%80%9A%E8%A8%8A">进程间通讯</a> ，所以程序的运行效率也要比分布式系统更高，完全不应该被贴上”反派角色”的标签。要我说的话，反倒是那些爱赶技术潮流，却不顾需求现状的微服务吹捧者更像是个反派。</p>
<blockquote>
<p>进程间通讯：Inter-Process Communication，IPC。RPC 属于 IPC 的一种特例，但请注意，这里两个”PC”不是同个单词的缩写，关于 IPC 与 RPC 的知识，在”远程服务调用”这个小章节中我会详细讲解。</p>
</blockquote>
<p>所以，当我们在讨论单体系统的缺陷的时候，必须基于软件的性能需求超过了单机，软件的开发人员规模明显超过了” <a target="_blank" rel="noopener" href="https://wiki.mbalib.com/wiki/%E4%B8%A4%E4%B8%AA%E6%8A%AB%E8%90%A8%E5%8E%9F%E5%88%99">2 Pizza Teams</a> “范畴的前提下，这样才有讨论的价值。那么，在咱们课程后续讨论中，我所说的单体，都应该是特指的”大型的单体系统”。</p>
<p>也正因如此，在这一讲的开篇中”单体是出现最早的架构风格”，跟我在上一讲介绍”原始分布式时代”时，在开篇中提到的”使用多个独立的分布式服务共同构建一个更大型系统的设想与实际尝试，反而要比今天你所了解的大型单体系统出现的时间更早”，这两句话实际上并没有矛盾的地方。</p>
<h4 id="可拆分的单体系统"><a href="#可拆分的单体系统" class="headerlink" title="可拆分的单体系统"></a>可拆分的单体系统</h4><p>好了，回到主题，接下来我就带你来详细、深入地了解一下单体系统，看看”巨石系统”为何仍然是可以拆分的。</p>
<p>尽管”Monolithic”这个词语本身的意思”巨石”，确实是带有一些”不可拆分”的隐含意味，但我们也不能简单粗暴地把单体系统在维基百科上的定义”All in One Piece”，翻译成”铁板一块”，它其实更接近于自给自足（Self-Contained）的含义。</p>
<blockquote>
<p><strong>单体系统</strong></p>
<p>Monolith means composed all in one piece. The Monolithic application describes a single-tiered software application in which different components combined into a single program from a single platform.</p>
<p>—— Monolithic Application，Wikipedia</p>
</blockquote>
<p>当然了，这种”铁板一块”的译法也不全是段子。我相信肯定有一部分人说起单体架构、巨石系统的缺点，脑海中闪过的第一印象就是”不可拆分”，难以扩展，所以它才不能支撑起越来越大的软件规模。这种想法我觉得其实是有失偏颇的，至少不完整。</p>
<p>我为什么会这么判断呢？</p>
<p>因为从 <strong>纵向角度</strong> 来看，在现代信息系统中，我从来没有见到过实际的生产环境里，有哪个大型的系统是完全不分层的。</p>
<p>分层架构（Layered Architecture）已经是现在几乎所有的信息系统建设中，都普遍认可、普遍采用的软件设计方法了。无论是单体还是微服务，或者是其他架构风格，都会对代码进行纵向拆分，收到的外部请求会在各层之间，以不同形式的数据结构进行流转传递，在触及到最末端的数据库后依次返回响应。</p>
<p>那么，对于单体架构来说，在这个意义上的”可拆分”，单体其实完全不会展露出丝毫的弱势，反而还可能因为更容易开发、部署、测试而更加便捷。比如说，当前市面上所有主流的 IDE，如 Intellij IDEA、Eclipse 等，都对单体架构最为友好。IDE 提供的代码分析、重构能力，以及对编译结果的自动化部署和调试能力，都是主要面向单体架构而设计的。</p>
<p><img src="https://fastly.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《周志明的软件架构课》学习笔记/分层架构（LayeredArchitecture）.webp" alt="分层架构（LayeredArchitecture）"></p>
<p>（上图来自 O’Reilly 的开放文档《 <a target="_blank" rel="noopener" href="https://www.oreilly.com/programming/free/files/software-architecture-patterns.pdf">Software Architecture Patterns</a> 》）</p>
<p>而在 <strong>横向角度</strong> 的”可拆分”上，单体架构也可以支持按照技术、功能、职责等角度，把软件拆分为各种模块，以便重用和团队管理。</p>
<p>实际上，单体系统并不意味着就只能有一个整体的程序封装形式，如果有需要，它完全可以由多个 JAR、WAR、DLL、Assembly 或者其他模块格式来构成。</p>
<p>即使是从 <strong>横向扩展（Scale Horizontally）</strong> 的角度来衡量，如果我们要在负载均衡器之后，同时部署若干个单体系统的副本，以达到分摊流量压力的效果，那么基于单体架构，也是轻而易举就可以实现的。</p>
<h4 id="非独立的单体"><a href="#非独立的单体" class="headerlink" title="非独立的单体"></a>非独立的单体</h4><p>不过，在”拆分”这方面， <strong>单体系统的真正缺陷实际上并不在于要如何拆分，而在于拆分之后，它会存在隔离与自治能力上的欠缺。</strong></p>
<p>在单体架构中，所有的代码都运行在同一个进程空间之内，所有模块、方法的调用也都不需要考虑网络分区、对象复制这些麻烦事儿，也不担心因为数据交换而造成性能的损失。</p>
<p>可是，在获得了进程内调用的简单、高效这些好处的同时，也就意味着，如果在单体架构中，有任何一部分的代码出现了缺陷，过度消耗进程空间内的公共资源，那所造成的影响就是全局性的、难以隔离的。</p>
<p><strong>我们要怎么理解这个问题呢？</strong></p>
<p>首先，一旦架构中出现了内存泄漏、线程爆炸、阻塞、死循环等问题，就都将会影响到整个程序的运行，而不仅仅是某一个功能、模块本身的正常运作；而如果消耗的是某些更高层次的公共资源，比如端口占用过多或者数据库连接池泄漏，还将会波及到整台机器，甚至是集群中其他单体副本的正常工作。</p>
<p>此外，同样是因为所有代码都共享着同一个进程空间，如果代码无法隔离，那也就意味着，我们无法做到单独停止、更新、升级某一部分代码，因为不可能有”停掉半个进程，重启 1/4 个进程”这样不合逻辑的操作。所以， <strong>从动态可维护性的角度来说</strong> ，单体系统也是有所不足的，对于程序升级、修改缺陷这样的工作，我们往往需要制定专门的停机更新计划，而且做灰度发布也相对会更加复杂。</p>
<blockquote>
<p>补充：这里我说的”代码无法隔离，无法做到单独停止、更新……”，其实严谨来说还是有办法的，比如可以使用 OSGi 这种运行时模块化框架，只是会很别扭、很复杂。</p>
</blockquote>
<p>这里就涉及到一个需要权衡的问题：如果说共享同一进程获得简单、高效这些优势的代价，是损失了各个功能模块的自治、隔离能力，那这两者孰轻孰重呢？这个问题很有代表性，我们还可以换个角度思考一下，它的潜台词其实是在比较微服务、单体架构哪种更好用、优秀？</p>
<p>在我看来，”好用和优秀”不一定是绝对的。我们看一个例子吧。</p>
<p>比如说，沃尔玛将超市分为仓储部、采购部、安保部、库存管理部、巡检部、质量管理部、市场营销部，等等，来划清职责，明确边界，让管理能力可以支持企业的成长规模；但如果你家楼下开的小卖部，爸、妈加儿子，再算上看家的中华田园犬小黄，一共也就只有四名员工，也去追求”先进管理”，来划分仓储部、采购部、库存管理部……的话，那纯粹是给自己找麻烦。</p>
<p>在单体架构下，哪怕是信息系统中两个毫无关联的子系统，我们也都必须部署到一起。当系统规模小的时候，这是个优势；但当系统规模扩大、程序需要修改的时候，相应的部署成本、技术升级时的迁移成本，都会变得非常高。</p>
<p>就拿沃尔玛例子来说，也就是当公司规模比较小的时候，让安保部和质检部两个不相干的部门在同一栋大楼中办公，算是节约资源。但当公司的人数增加了，办公室已经变得拥挤不堪的时候，我们也最多只能在楼顶加盖新楼层（相当于增强硬件性能），而不能让安保、质检分开地方办公，这才是缺陷所在。</p>
<p>另外，由于隔离能力的缺失，除了会带来难以阻断错误传播、不便于动态更新程序的问题，还会给带来难以 <strong>技术异构</strong> 等困难。</p>
<blockquote>
<p><strong>技术异构</strong> ：后面在介绍微服务时，我会提到马丁 · 福勒（Martin Fowler）提出的 9 个特征，技术异构就是其中之一。它的意思是说允许系统的每个模块，自由选择不一样的程序语言、不一样的编程框架等技术栈去实现。单体系统的技术栈异构不是一定做不到，比如 JNI 就可以让 Java 混用 C/C++，但是这也是很麻烦的事，是迫不得已下的选择。</p>
</blockquote>
<p>不过，在我看来，我们提到的这些问题，还不是我们今天以微服务去代替单体系统的根本原因。我认为最根本的原因是：单体系统并不兼容” <a target="_blank" rel="noopener" href="http://icyfenix.cn/introduction/about-the-fenix-project.html#%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E8%BF%9B">Phoenix</a> “的特性。</p>
<p>单体这种架构风格，潜在的观念是希望系统的每一个部件，甚至每一处代码都尽量可靠，不出、少出错误，致力于构筑一个 7×24 小时不间断的可靠系统。</p>
<p>这种观念在小规模软件上能运作良好，但当系统越来越大的时候，交付一个可靠的单体系统就会变得越来越有挑战性。就像我在 <a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/309747">导读《什么是”The Fenix Project”？》</a> 中所说的，正是随着软件架构的不断演进，我们构﻿建可靠系统的观念，开始从”追求尽量不出错”，转变为了正视”出错是必然”。实际上，这才是微服务架构能够挑战，并且能逐步开始代替运作了几十年的单体架构的根本驱动力。</p>
<p>不过，即使是为了允许程序出错，为了获得隔离、自治的能力，为了可以技术异构等目标，也并不意味着一定要依靠微服务架构。在新旧世纪之交，人们曾经探索过几种服务的拆分方法，把一个大的单体系统拆分为若干个更小的、不运行在同一个进程的独立服务，这些服务拆分的方法，后来导致了面向服务架构（Service-Oriented Architecture）的一段兴盛期，我们把它称作是” <a target="_blank" rel="noopener" href="http://icyfenix.cn/architecture/architect-history/soa.html">SOA 时代</a> “。</p>
<h3 id="03-SOA时代：成功理论与失败实践"><a href="#03-SOA时代：成功理论与失败实践" class="headerlink" title="03 | SOA时代：成功理论与失败实践"></a>03 | SOA时代：成功理论与失败实践</h3><p>SOA 架构是第一次被广泛使用过的、通过分布式服务来构建信息系统的工程实践。它有完善的理论和工具，可以说，它解决了分布式系统中，几乎所有主要的技术问题。</p>
<p>但遗憾的是，虽然 SOA 架构曾经被视为更大规模的软件发展的方向，但它最终还是没能成为一种普适的软件架构。</p>
<p>所以今天，我们就来探索一下 SOA 架构，一起来找找，它没能成为普适的软件架构的原因。通过这一讲，你能从中体会到 SOA 的设计思想与原则，理解它为什么不能成功。</p>
<h4 id="三种代表性的服务拆分架构模式"><a href="#三种代表性的服务拆分架构模式" class="headerlink" title="三种代表性的服务拆分架构模式"></a>三种代表性的服务拆分架构模式</h4><p>在上一讲，我曾经提到过，为了对大型的单体系统进行拆分，让每一个子系统都能独立地部署、运行、更新，开发者们尝试了很多种方案。</p>
<p>所以，在介绍 SOA 架构模式之前，我还要先带你学习三种比较有代表性的服务拆分的架构模式。这些架构是 SOA 演化过程的中间产物，你也可以理解为，它们是 SOA 架构出现的必要前提。</p>
<h5 id="烟囱式架构（Information-Silo-Architecture）"><a href="#烟囱式架构（Information-Silo-Architecture）" class="headerlink" title="烟囱式架构（Information Silo Architecture）"></a>烟囱式架构（Information Silo Architecture）</h5><p>第一种架构模式是 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Information_silo">烟囱式架构</a> 。</p>
<p>信息烟囱也被叫做信息孤岛（Information Island），使用这种架构的系统呢，也被称为孤岛式信息系统或者烟囱式信息系统。这种信息系统，完全不会跟其他相关的信息系统之间进行互操作，或者是进行协调工作。</p>
<p>那你就会发现，这样的系统其实并没有什么”架构设计”可言。你还记不记得，我在上一讲中举的那个”企业与部门”的例子？如果两个部门真的完全不会发生任何交互，那我们就并没有什么理由，一定要强迫他们必须在一栋楼里办公。</p>
<p>所以，两个不发生交互的信息系统，让它们使用独立的数据库、服务器，就可以完成拆分了。</p>
<p>而唯一的问题，也是这个架构模式的致命问题，那就是： <strong>企业中真的存在完全不发生交互的部门吗？</strong></p>
<p><img src="https://fastly.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《周志明的软件架构课》学习笔记/烟囱式架构模式示意图.webp" alt="烟囱式架构模式示意图"></p>
<p>对于两个信息系统来说，哪怕真的毫无业务往来关系，但系统的人员、组织、权限等主数据，会是完全独立、没有任何重叠的吗？这样”独立拆分””老死不相往来”的系统，显然不可能是企业所希望见到的。</p>
<h5 id="微内核架构（Microkernel-Architecture）"><a href="#微内核架构（Microkernel-Architecture）" class="headerlink" title="微内核架构（Microkernel Architecture）"></a>微内核架构（Microkernel Architecture）</h5><p>第二种是 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Microkernel">微内核架构</a> ，它也被称为插件式架构（Plug-in Architecture）。</p>
<p>既然在烟囱式架构中，我们说两个没有业务往来关系的系统，也可能需要共享人员、组织、权限等一些公共的主数据，那就不妨把这些主数据，连同其他可能被各个子系统使用到的公共服务、数据、资源，都集中到一块，成为一个被所有业务系统共同依赖的核心系统（Kernel，也称为 Core System）。</p>
<p>这样的话，具体的业务系统就能以 <strong>插件模块（Plug-in Modules）</strong> 的形式存在了，就可以为整个系统提供可扩展的、灵活的、天然隔离的功能特性。</p>
<p><img src="https://fastly.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《周志明的软件架构课》学习笔记/微内核架构模式示意图.webp" alt="微内核架构模式示意图"></p>
<p>（上图来自 O’Reilly 的开放文档《 <a target="_blank" rel="noopener" href="https://www.oreilly.com/programming/free/files/software-architecture-patterns.pdf">Software Architecture Patterns</a> 》）</p>
<p>以更高层次的抽象程度来看，任何计算机系统都是由各种架构的软件互相配合来实现各种功能的，这一讲我介绍的各种架构模式，一般都可以看作是整个系统的一种插件。对于产品型应用程序来说，如果我们想将新特性或者功能及时加入系统，微内核架构会是一个不错的选择。</p>
<p>微内核架构也可以嵌入到其它架构模式之中，通过插件的方式，来提供逐步演化的功能和增量开发。所以，如果你准备实现一个能够支持二次开发的软件系统，微内核就是一种良好的架构模式。</p>
<p>不过，微内核架构也有它的局限和使用前提，它会假设系统中各个插件模块之间是互不认识的（不可预知系统会安装哪些模块），这些插件会访问内核中一些公共的资源，但不会发生直接交互。</p>
<p>可是，无论是在企业信息系统还是在互联网，在许多场景中这一假设都不成立。比如说，你要建设一个购物网站，支付子系统和用户子系统是独立的，但当交易发生时，支付子系统可能需要从用户子系统中得到是否是 VIP、银行账号等信息，而用户子系统也可能要从支付子系统中获取交易金额等数据，来维护用户积分。</p>
<p>所以，我们必须找到一个办法，它既能拆分出独立的系统，也能让拆分后的子系统之间可以顺畅地互相调用通讯。</p>
<h5 id="事件驱动架构（Event-Driven-Architecture）"><a href="#事件驱动架构（Event-Driven-Architecture）" class="headerlink" title="事件驱动架构（Event-Driven Architecture）"></a>事件驱动架构（Event-Driven Architecture）</h5><p>那么，为了能让子系统之间互相通讯， <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Event-driven_architecture">事件驱动架构</a> 就应运而生了。</p>
<p>这种架构模式的运作方案是，在子系统之间建立一套事件队列管道（Event Queues），来自系统外部的消息将以事件的形式发送到管道中，各个子系统可以从管道里获取自己感兴趣、可以处理的事件消息，也可以为事件新增或者是修改其中的附加信息，甚至还可以自己发布一些新的事件到管道队列中去。</p>
<p>这样一来，每一个消息的处理者都是独立的、高度解耦的，但它又能与其他处理者（如果存在该消息处理者的话）通过事件管道来进行互动。</p>
<p><img src="https://fastly.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《周志明的软件架构课》学习笔记/事件驱动架构模式示意图.webp" alt="事件驱动架构模式示意图"></p>
<p>（上图来自 O’Reilly 的开放文档《 <a target="_blank" rel="noopener" href="https://www.oreilly.com/programming/free/files/software-architecture-patterns.pdf">Software Architecture Patterns</a> 》）</p>
<p>那么，当系统演化至事件驱动架构的时候，我在 <a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/309761">原始分布式时代</a> 这一讲的结尾中，提到的第二条通往大规模软件的路径，也就是仍然在并行发展的远程服务调用，就迎来了 SOAP 协议的诞生（我在后面第 7~10 讲分享远程服务调用的时候，还会给你详细介绍它，你到时可以再次印证一下这一讲的内容）。</p>
<p>此时”面向服务的架构”（Service Oriented Architecture，SOA），就已经有了登上软件架构舞台所需要的全部前置条件了。</p>
<h5 id="SOA-架构时代的探索"><a href="#SOA-架构时代的探索" class="headerlink" title="SOA 架构时代的探索"></a>SOA 架构时代的探索</h5><p>SOA 的概念最早是由 Gartner 公司在 1994 年提出的。当时的 SOA 还不具备发展的条件，直到 2006 年情况才有所变化，IBM、Oracle、SAP 等公司，共同成立了 OSOA 联盟（Open Service Oriented Architecture），来联合制定和推进 SOA 相关行业标准。</p>
<p>到 2007 年，在 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/OASIS_(organization">结构化资讯标准促进组织（Organization for the Advancement of Structured Information Standards，OASIS）</a>) 的倡议与支持下，OSOA 就由一个软件厂商组成的松散联盟，转变为了一个制定行业标准的国际组织。它联合 OASIS 共同新成立了 <a target="_blank" rel="noopener" href="http://www.oasis-opencsa.org/">Open CSA组织（Open Composite Services Architecture）</a> ，也就是 SOA 的”官方管理机构”。</p>
<p>当软件架构发展至 SOA 时代的时候，其中的许多概念、思想都已经能在今天的微服务中，找到对应的身影了。比如说，服务之间的松散耦合、注册、发现、治理、隔离、编排等等，都是微服务架构中耳熟能详的概念了，也大多是在分布式服务刚被提出的时候，就已经可以预见到的困难。</p>
<p>所以，SOA 就针对这些问题，乃至于针对”软件开发”这件事儿本身，进行了更具体、更系统的探索。</p>
<h6 id="更具体"><a href="#更具体" class="headerlink" title="更具体"></a>更具体</h6><p>“更具体”体现在，尽管 SOA 本身还是属于一种抽象概念，而不是特指某一种具体的技术，但它比单体架构和烟囱式架构、微内核架构、事件驱动架构，都要更具可操作性，细节也充实了很多。所以，我们已经不能简单地把 SOA 看作是一种架构风格了，而是可以称之为一套软件架构的基础平台了。</p>
<p>那，我们怎么理解”基础平台”这个概念呢？在我看来，主要是下面几个方面：</p>
<ul>
<li>SOA 拥有领导制定技术标准的组织 Open CSA；</li>
<li>SOA 具有清晰的软件设计的指导原则，比如服务的封装性、自治、松耦合、可重用、可组合、无状态，等等；</li>
<li>SOA 架构明确了采用 SOAP 作为远程调用的协议，依靠 SOAP 协议族（WSDL、UDDI 和一大票 WS-* 协议）来完成服务的发布、发现和治理；</li>
<li>SOA 架构会利用一个被称为是 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-hans/%E4%BC%81%E4%B8%9A%E6%9C%8D%E5%8A%A1%E6%80%BB%E7%BA%BF">企业服务总线（Enterprise Service Bus，ESB）</a> 的消息管道，来实现各个子系统之间的通讯交互，这就让各个服务间在 ESB 的调度下，不需要相互依赖就可以实- 现相互通讯，既带来了服务松耦合的好处，也为以后可以进一步实现 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86">业务流程编排（Business Process Management，BPM）</a> 提供了基础；</li>
<li>SOA 架构使用了 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1">服务数据对象（Service Data Object，SDO）</a> 来访问和表示数据，使用 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E7%BB%84%E4%BB%B6%E6%9E%B6%E6%9E%84">服务组件架构（Service Component Architecture，SCA）</a> 来定义服务封装的形式和服务运行的容器；</li>
<li>……</li>
</ul>
<p>在这一整套成体系、可以互相精密协作的技术组件的支持下，我们从技术可行性的角度来评判的话，SOA 实际上就可以算是成功地解决了分布式环境下，出现的诸如服务注册、发现、隔离、治理等主要技术问题了。</p>
<h6 id="更系统"><a href="#更系统" class="headerlink" title="更系统"></a>更系统</h6><p>这里我说的”更系统”，指的是 SOA 的宏大理想。因为 SOA 最根本的目标，就是希望能够总结出一套自上而下的软件研发方法论，让企业只需要跟着它的思路，就能够一揽子解决掉软件开发过程中的全套问题。比如，如何挖掘需求、如何将需求分解为业务能力、如何编排已有服务、如何开发测试部署新的功能，等等。</p>
<p>如果这个目标真的能够达成，那么软件开发就有可能从此迈进工业化大生产的阶段。你可以试想一下，如果有一天，你在写符合客户需求的软件时，就像写八股文一样有迹可循、有法可依，那对你来说或许很无趣，但这肯定可以大幅提升整个社会实施信息化的效率。</p>
<p>SOA 在 21 世纪最初的十年里，曾经盛行一时，有 IBM 等一众巨头为其摇旗呐喊，吸引了不少软件开发商，尤其是企业级软件开发商的跟随，但最终却还是偃旗息鼓，沉寂了下去。</p>
<p>原因也很简单，开发信息系统毕竟不是写八股文，SOA 架构过于严谨精密的流程与理论，导致了软件开发的全过程，都需要有懂得复杂概念的专业人员才能够驾驭。从 SOA 诞生的那一天起，就已经注定了它只能是少数系统的阳春白雪式的精致奢侈品：它可以实现多个异构大型系统之间的复杂集成交互，却很难作为一种具有广泛普适性的软件架构风格来推广。</p>
<p>我在后面第 7~10 讲介绍远程服务调用时，我还会为你介绍 Web  Service 的兴起与衰落。Web  Service 之所以被逐渐边缘化，最本质的原因就是过于严格的规范定义，给架构带来了过度的复杂性。</p>
<p>而构建在 Web Service 基础之上的 ESB、BPM、SCA、SDO 等诸多的上层建筑，就进一步加剧了这种复杂性。</p>
<p><strong>SOA 最终没有获得成功的致命伤，其实跟当年的 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/EJB">EJB（Enterprise JavaBean，企业级 JavaBean）</a> 的失败如出一辙。</strong></p>
<p>尽管在当时，EJB 有 Sun Microsystems（被甲骨文收购）和 IBM 等一众巨头在背后力挺，希望能把它发展成一套面向信息系统的编程范式，但它仍然被以 Spring、Hibernate 为代表的”草根框架”给打败了。可见，任何事物一旦脱离了人民群众，最终都会淹没在群众的海洋之中，就连信息技术也不曾例外过。</p>
<p>最后，当你读到这一段的时候，你不妨再重新思考下我们这一讲的开头提到的，”如何使用多个独立的分布式服务共同构建一个更大型系统”这个问题，再回顾下”原始分布式时代”这一讲中，Unix DCE 提出的分布式服务的主旨：”让开发人员不必关心服务是远程还是本地，都能够透明地调用服务或者访问资源”。</p>
<p>经过了三十年的技术发展，信息系统经历了巨石、烟囱、微内核、事件驱动、SOA 等架构模式，应用受架构复杂度的牵绊却是越来越大，距离”透明”二字已经越来越远了。这是否算不自觉间忘记了当年的初心呢？</p>
<p>接下来我们要探索的微服务时代，似乎正是带着这样自省式的问句而开启的。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>这一讲，我带你学习了解了 SOA 架构，重点了解了从原始分布式架构、单体架构演进到 SOA 架构这段过程中的一些中间产物，如烟囱式架构、微内核架构、事件驱动架构等。</p>
<p>另外，我之所以带你解构 SOA 架构，就是要帮助你弄清楚它成功的部分，比如它是如何提出了哪些技术、解决问题的方法论是什么，它是如何看待分布式、乃至是如何看待软件开发的；你也要弄清楚它失败的部分，要清楚为什么 SOA 在众多软件业巨头的推动下，仍然没能成为软件开发者所普遍接受的普适的软件开发方法。这是你了解和掌握推动架构时代演进原因的重要方式。</p>
<h3 id="04-微服务时代：SOA的革命者"><a href="#04-微服务时代：SOA的革命者" class="headerlink" title="04 | 微服务时代：SOA的革命者"></a>04 | 微服务时代：SOA的革命者</h3><p>其实”微服务”这个词儿，Peter Rodgers 博士在 2005 年的云计算博览会（Web Services Edge 2005）上，就已经提出和使用了。当时的说法是”Micro-Web-Service”，指的是一种专注于单一职责的、与语言无关的、细粒度的 Web 服务（Granular Web Services）。</p>
<p>“微服务”这个词，并不是 Peter Rodgers 直接凭空创造出来的概念。最开始的微服务，可以说是在 SOA 发展的同时被催生出来的产物，就像是 EJB 在推广的过程中，催生出了 Spring 和 Hibernate 框架那样。这一阶段的微服务，是作为 SOA 的一种轻量化的补救方案而被提出来的。</p>
<p>到今天为止，在英文版的维基百科上，人们仍然是把微服务定义成了 SOA 的一个变种。所以，微服务在诞生和最初的发展阶段，跟 SOA、Web Service 这些概念有所牵扯，也是完全可以理解的。</p>
<blockquote>
<p><strong>What is microservices</strong></p>
<p>Microservices is a software development technique — a variant of the service-oriented architecture （SOA） structural style.</p>
<p>—— Wikipedia，<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Microservices">Microservices</a></p>
</blockquote>
<p>但我们现在再来看，维基百科对微服务的定义，其实已经有些过时了。至于为什么这样说，就是我在这一讲中要和你解释的了。</p>
<p>在微服务的概念被提出后将近 10 年的时间里面，它都没有受到太多人的追捧。毕竟，如果只是对现有的 SOA 架构的修修补补，确实难以唤起广大技术人员的更多激情。</p>
<p>不过，也是在这 10 年的时间里，微服务本身其实一直在思考、蜕变。</p>
<p>2012 年，在波兰克拉科夫举行的”33rd Degree Conference”大会上，Thoughtworks 首席咨询师 James Lewis 做了题为《 <a target="_blank" rel="noopener" href="http://2012.33degree.org/talk/show/67">Microservices - Java, the Unix Way</a> 》的主题演讲。其中，他提到了单一服务职责、 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Conway%27s_law">康威定律</a> 、自动扩展、领域驱动设计等原则，却只字未提 SOA，反而号召大家，应该重拾 Unix 的设计哲学（As Well Behaved Unix Services）。这一点跟我在上一讲中所说的”初心与自省”，可以说是一个意思。</p>
<p>微服务已经迫不及待地要脱离 SOA 的附庸，想要成为一种独立的架构风格，也许，它还将会是 SOA 的革命者，找到一条能被广大开发者普遍接受且愿意接受的、实现服务化系统的目标。</p>
<p>微服务真正崛起是在 2014 年。相信我们大多数程序员，也是从 Martin Fowler 和 James Lewis 合写的文章” <a target="_blank" rel="noopener" href="https://martinfowler.com/articles/microservices.html">Microservices: a definition of this new architectural term</a> “里面，第一次了解到微服务的。这篇文章虽然不是最早提出”微服务”这个概念的，但却是真正丰富的、广为人知的和可操作的微服务指南。也就是说，这篇文章才是微服务的真正起源。</p>
<p>这篇文章定义了现代微服务的概念：微服务是一种通过多个小型服务的组合，来构建单个应用的架构风格，这些服务会围绕业务能力而非特定的技术标准来构建。各个服务可以采用不同的编程语言、不同的数据存储技术、运行在不同的进程之中。服务会采取轻量级的通讯机制和自动化的部署机制，来实现通讯与运维。</p>
<p>此外，在这篇论文中，作者还列举出了微服务的九个核心的业务与技术特征。接下来，我就一一解读为你解读下，希望你可以从中领悟到，微服务在团队、开发、运维等一系列研发过程中的核心思想。</p>
<ol>
<li><p><strong>第一，围绕业务能力构建（Organized around Business Capabilities）</strong></p>
<p> 这个核心技术特征，实际上再次强调了 <strong>康威定律</strong> 的重要性。它的意思是， <strong>有怎样的结构、规模和能力的团队，就会产生出对应结构、规模、能力的产品。</strong> 这个结论不是某个团队、某个公司遇到的巧合，而是必然的演化结果。</p>
<p> 如果本应该归属同一个产品内的功能，被划分在了不同的团队当中，那就必然会产生大量的跨团队沟通协作，而跨越团队边界，无论是在管理、沟通，还是在工作安排上，都会产生更高的成本。高效的团队，自然会针对这个情况进行改进，而当团队和产品磨合调节稳定了之后，就会拥有一致的结构。</p>
</li>
<li><p><strong>第二，分散治理（Decentralized Governance）</strong></p>
<p> 这个技术特征，表达的是”谁家孩子谁来管”。微服务对应的开发团队，有着直接对服务运行质量负责的责任，也应该有着不受外界干预，掌控服务各个方面的权力，可以选择与其他服务异构的技术来实现自己的服务。</p>
<p> 这一点在真正实践的时候，其实多少都会留点儿宽松的处理余地。因为大多数的公司都不会在某一个服务用 Java，另一个用 Python，下一个用 Golang，而是通常都会统一主流语言，甚至会有统一的技术栈或专有的技术平台。</p>
<p> 微服务不提倡也并不反对这种”统一”，它只负责提供和维护基础技术栈的团队，有被各方依赖的觉悟，要有”经常被凌晨 3 点的闹钟吵醒”的心理准备就好。</p>
<p> 微服务更加强调的是， <strong>在确实有必要进行技术异构的时候，一个开发团队应该能有选择”不统一”的权利。</strong> 比如说，我们不应该强迫用 Node.js 去开发报表页面；要做人工智能计算的时候，也可以选择用 Python，等等。</p>
</li>
<li><p><strong>第三，通过服务来实现独立自治的组件（Componentization via Services）</strong></p>
<p> 这里，Martin Fowler 与 James Lewis 之所以强调要通过”服务”（Service）而不是”类库”（Library）来构建组件，是因为类库是在编译期静态链接到程序中的，会通过本地调用来提供功能，而服务是进程外组件，它是通过远程调用来提供功能的。在 <a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/309772">第 2 讲</a> 中，我们已经分析过，尽管远程服务有更高昂的调用成本，但这是为组件带来隔离与自治能力的必要代价。</p>
</li>
<li><p><strong>第四，产品化思维（Products not Projects）</strong></p>
<p> 产品化思维的意思就是，我们要 <strong>避免把软件研发看作是要去完成某种功能，而要把它当做是一种持续改进、提升的过程。</strong> 比如，我们不应该把运维看作就是运维团队的事，把开发看作就是开发团队的事。</p>
<p> 开发团队应该为软件产品的整个生命周期负责。开发者不仅应该知道软件是如何开发的，还应该知道它会如何运作、用户如何反馈，乃至售后支持工作是怎样进行的。这里服务的用户，不一定是最终用户，也可能是消费这个服务的另外一个服务。</p>
<p> 以前在单体的架构模式下，程序的规模决定了我们无法让全部的开发人员，都关注到一个完整的产品，在组织中会有开发、运维、支持等细致分工的成员，他们只关注于自己的一块工作。但在微服务下，我们可以让团队中的每一位成员，都具有产品化思维。因为在”2 Pizza Teams”的团队规模下，每一个人都了解全过程是完全有可能实现的。</p>
</li>
<li><p><strong>第五，数据去中心化（Decentralized Data Management）</strong></p>
<p> 微服务这种架构模式也明确地提倡，数据应该按领域来分散管理、更新、维护和存储。</p>
<p> 在单体服务中，通常一个系统的各个功能模块会使用同一个数据库，虽然这种中心化的存储确实天生就更容易避免一致性的问题，但是，同一个数据实体在不同服务的视角里，它的抽象形态往往也是不同的。</p>
<p> 比如，Bookstore 应用中的书本，在销售领域中关注的是价格，在仓储领域中关注的是库存数量，在商品展示领域中关注的是书籍的介绍信息。如果是作为中心化的存储，那么这里所有的领域，都必须修改和映射到同一个实体之中，就会导致不同的服务之间，可能会互相产生影响，从而丧失了各自的独立性。</p>
<p> 另外，尽管在分布式中，我们要想处理好一致性的问题也很困难，很多时候都没法使用传统的事务处理来保证不出现一致性问题。但是两害相权取其轻，一致性问题这些必要的代价是值得付出的。</p>
</li>
<li><p><strong>第六，轻量级通讯机制（Smart Endpoints and Dumb Pipes）</strong></p>
<p> 这个弱管道（Dumb Pipes）机制，可以说几乎算是在直接指名道姓地反对 ESB、BPM 和 SOAP 等复杂的通讯机制。</p>
<p> ESB 可以处理消息的编码加工、业务规则转换等；BPM 可以集中编排企业的业务服务；SOAP 有几十个 WS-* 协议族在处理事务、一致性、认证授权等一系列工作。这些构筑在通讯管道上的功能，也许在某个系统中的确有一部分服务是需要的，但对于另外更多的服务来说是强加进来的负担。</p>
<p> <strong>如果服务需要上面的某一种功能或能力，那就应该在服务自己的 Endpoint（端点）上解决，而不是在通讯管道上一揽子处理。</strong></p>
<p> 微服务提倡的是类似于经典 Unix 过滤器那样，简单直接的通讯方式。比如说，RESTful 风格的通讯，在微服务中就是比较适合的。</p>
</li>
<li><p><strong>第七，容错性设计（Design for Failure）</strong></p>
<p> 容错性设计，是指软件架构不再虚幻地追求服务永远稳定，而是接受服务总会出错的现实。</p>
<p> 这个技术特征要求，在微服务的设计中，有自动的机制能够对其依赖的服务进行快速故障检测，在持续出错的时候进行隔离，在服务恢复的时候重新联通。所以 <strong>“断路器”这类设施，对实际生产环境的微服务来说，并不是可选的外围组件，而是一个必须的支撑点。</strong> 如果没有容错性的设计，系统很容易就会因为一两个服务的崩溃带来的雪崩效应而被淹没。</p>
<p> 我想说的是，可靠系统完全可以由会出错的服务来组成，这是微服务最大的价值所在，也是咱们这门课的开篇导读标题中”The Fenix Project”的含义。</p>
</li>
<li><p><strong>第八，演进式设计（Evolutionary Design）</strong></p>
<p> 容错性设计承认服务会出错，而演进式设计则是 <strong>承认服务会被报废淘汰。</strong></p>
<p> 一个良好设计的服务，应该是能够报废的，而不是期望得到长久的发展。如果一个系统中出现不可更改、无可替代的服务，这并不能说明这个服务有多么重要，反而是系统设计上脆弱的表现。微服务带来的独立、自治，也是在反对这种脆弱性。</p>
</li>
<li><p><strong>第九，基础设施自动化（Infrastructure Automation）</strong></p>
<p> 基础设施自动化，如 CI/CD 的长足发展，大大降低了构建、发布、运维工作的复杂性。</p>
<p> 由于微服务架构下，运维的服务数量比起单体架构来说，要有数量级的增长，所以使用微服务的团队，会更加依赖于基础设施的自动化。毕竟，人工是无法运维成百上千，乃至成千上万级别的服务的。</p>
<p> 好，到这里，通过我的解读，你是不是已经大概理解了微服务核心的业务和技术特征了？</p>
</li>
</ol>
<p><strong>以上 9 个特征，是一个合理的微服务系统展示出来的内、外在表现，它能够指导你该如何应用微服务架构，却不必作为一种强加于系统中的束缚来看待。</strong></p>
<p><a target="_blank" rel="noopener" href="https://martinfowler.com/articles/microservices.html">“Microservices: a definition of this new architectural term”</a> 一文中，对微服务特征的描写已经非常具体了，除定义了微服务是什么，还专门申明了微服务不是什么：微服务不是 SOA 的衍生品，应该明确地与 SOA 划清界线，不再贴上任何 SOA 的标签。</p>
<p>这样一来，微服务才算是一种真正丰满、独立、具体的架构风格，为它在未来的几年时间里，如同明星一般闪耀崛起于技术舞台奠定了坚实的基础。</p>
<blockquote>
<p><strong>Microservices and SOA</strong></p>
<p>This common manifestation of SOA has led some microservice advocates to reject the SOA label entirely, although others consider microservices to be one form of SOA , perhaps service orientation done right. Either way, the fact that SOA means such different things means it”s valuable to have a term that more crisply defines this architectural style.</p>
<p>由于与 SOA 具有一致的表现形式，这让微服务的支持者更加迫切地拒绝再被打上 SOA 的标签。一些人坚持认为微服务就是 SOA 的一种变体，尽管仅从面向服务这个角度来考虑，这个观点可以说也是正确的。但无论如何，从整体上看 SOA 与微服务都是两种不同的东西。也因此，使用一个别的名称，来简明地定义这种架构风格就显得非常有必要了。</p>
<p>—— Martin Fowler / James Lewis，Microservices</p>
</blockquote>
<p>从上面我对微服务的定义和特征的解读当中，你还可以明显地感觉到，微服务追求的是更加自由的架构风格，它摒弃了 SOA 中几乎所有可以抛弃的约束和规定，提倡以”实践标准”代替”规范标准”。</p>
<p><strong>可是，如果没有了统一的规范和约束，以前 SOA 解决的那些分布式服务的问题，不又都重新出现了吗？</strong></p>
<p>没错，的确如此。服务的注册发现、跟踪治理、负载均衡、故障隔离、认证授权、伸缩扩展、传输通讯、事务处理等问题，在微服务中，都不再会有统一的解决方案。</p>
<p>即使我们只讨论 Java 范围内会使用到的微服务，那么光一个服务间通讯的问题，可以列入候选清单的解决方案就有很多很多。比如，RMI（Sun/Oracle）、Thrift（Facebook）、Dubbo（阿里巴巴）、gRPC（Google）、Motan2（新浪）、Finagle（Twitter）、brpc（百度）、Arvo（Hadoop）、JSON-RPC、REST，等等。</p>
<p>再来举个例子，光一个服务发现问题，我们可以选择的解决方案就有：Eureka（Netflix）、Consul（HashiCorp）、Nacos（阿里巴巴）、ZooKeeper（Apache）、etcd（CoreOS）、CoreDNS（CNCF），等等。</p>
<p>其他领域的情况也很类似。总之，完全就是”八仙过海，各显神通”的局面。</p>
<p>所以说，微服务所带来的自由是一把双刃开锋的宝剑。当软件架构者拿起这把宝剑的时候，它的一刃指向的是 SOA 定下的复杂技术标准，而在将选择的权力夺回的同一时刻，另外一刃也正朝向着自己映出冷冷的寒光。</p>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>在微服务时代中，软件研发本身的复杂度应该说是有所降低，一个简单服务，并不见得就会同时面临分布式中所有的问题，也就没有必要背上 SOA 那百宝袋般沉重的技术包袱。 <strong>微服务架构下，我们需要解决什么问题，就引入什么工具；团队熟悉什么技术，就使用什么框架。</strong></p>
<p>此外，像 Spring Cloud 这样的胶水式的全家桶工具集，通过一致的接口、声明和配置，进一步屏蔽了源自于具体工具、框架的复杂性，降低了在不同工具、框架之间切换的成本。所以，作为一个普通的服务开发者，作为一个”螺丝钉”式的程序员，微服务架构对我们来说是很友善的。</p>
<p>可是，微服务对架构者来说却是满满的恶意，因为它对架构能力的要求可以说是史无前例。要知道， <strong>技术架构者的第一职责就是做决策权衡</strong> ，有利有弊才需要决策，有取有舍才需要权衡。如果架构者本身的知识面不足以覆盖所需要决策的内容，不清楚其中的利弊，也就不可避免地会陷入选择困难症的困境之中。</p>
<p>总而言之，微服务时代充满着自由的气息，也充斥着迷茫的选择。软件架构不会止步于自由，微服务仍然不可能是架构探索的终点。如果有下一个时代，我希望信息系统能同时拥有微服务的自由权利，围绕业务能力构建自己的服务而不受技术规范管束，但同时又不必承担自行解决分布式问题的代价。管他什么利弊权衡！小孩子才做选择题，成年人全部都要！</p>
<h3 id="05-后微服务时代：跨越软件与硬件之间的界限"><a href="#05-后微服务时代：跨越软件与硬件之间的界限" class="headerlink" title="05 | 后微服务时代：跨越软件与硬件之间的界限"></a>05 | 后微服务时代：跨越软件与硬件之间的界限</h3><p>在开始探讨这一讲的主题之前呢，我想先跟你讨论一个问题。我们都知道，在微服务架构中，会面临一些必须解决的问题，比如注册发现、跟踪治理、负载均衡、传输通讯等。但这些问题，其实在 SOA 时代甚至可以说自原始分布式时代，就一直存在了。既然只要是分布式系统，就没办法完全避免这些问题，那我们就回过头来想一下：这些问题一定要由分布式系统自己来解决吗？</p>
<p>既然这样，那我们就先不去纠结到底是用微服务还是什么别的架构，直接看看面对这些问题，现在最常见的解决方法是怎样的：</p>
<ul>
<li>如果某个系统需要 <strong>伸缩扩容</strong> ，我们通常会购买新的服务器，多部署几套副本实例来分担压力；</li>
<li>如果某个系统需要解决 <strong>负载均衡</strong> 的问题，我们通常会布置负载均衡器，并选择恰当的均衡算法来分流；</li>
<li>如果需要解决 <strong>安全传输</strong> 的问题，我们通常会布置 TLS 传输链路，配置好 CA 证书，以保证通讯不被窃听篡改；</li>
<li>如果需要解决 <strong>服务发现</strong> 的问题，我们通常会设置 DNS 服务器，让服务访问依赖稳定的记录名而不是易变的 IP 地址，等等。</li>
</ul>
<p>所以你会发现，计算机科学经过了这么多年的发展，这些问题已经大多都有了专职化的基础设施来帮助解决了。</p>
<p>那么，在微服务时代，我们之所以不得不在应用服务层面，而不是基础设施层面去解决这些分布式问题， <strong>完全是因为由硬件构成的基础设施，跟不上由软件构成的应用服务的灵活性。</strong> 这其实是一种无奈之举。</p>
<p>软件可以做到只使用键盘就能拆分出不同的服务，只通过拷贝、启动就能够伸缩扩容服务。那么，硬件难道也可以通过敲键盘就变出相应的应用服务器、负载均衡器、DNS 服务器、网络链路等等的这些设施吗？嗯？好像也可以啊！</p>
<p>到这里，你是不是已经知道了，注册发现、跟踪治理等等问题的解决，依靠的就是 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Virtualization">虚拟化</a> 技术和 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/OS-level_virtualization">容器化</a> 技术。我们也就明白了， <strong>微服务时代所取得的成就，本身就离不开以 Docker 为代表的早期容器化技术的巨大贡献。</strong></p>
<p>不知道你注意到没有，在这之前，我从来没有提起过”容器”二字。其实，这并不是我想刻意冷落它，而是因为早期的容器只是被简单地视为一种可快速启动的服务运行环境，使用它的目的是方便程序的分发部署。所以，早期阶段针对单个服务的容器，并没有真正参与到分布式问题的解决之中。</p>
<p>尽管 2014 年，微服务真正崛起的时候，Docker Swarm（2013 年）和 Apache Mesos（2012 年）就已经存在了，更早之前也出现过 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Software-defined_networking">软件定义网络（Software-Defined Networking，SDN）</a> 、 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Software-defined_storage">软件定义存储（Software-Defined Storage，SDS）</a> 等技术，但是，被业界广泛认可、普遍采用的通过虚拟化的基础设施，去解决分布式架构问题的方案，应该要从 2017 年 Kubernetes 赢得容器战争的胜利开始算起。</p>
<p><strong>2017 年，可以说是容器生态发展历史中具有里程碑意义的一年。</strong></p>
<p>在这一年，长期作为 Docker 竞争对手的 <a target="_blank" rel="noopener" href="https://coreos.com/rkt/docs/latest/">RKT</a> 容器一派的领导者 CoreOS，宣布放弃了自己的容器管理系统 Fleet，未来将会把所有容器管理功能，转移到 Kubernetes 之上去实现。</p>
<p>在这一年，容器管理领域的独角兽 Rancher Labs，宣布放弃其内置了数年的容器管理系统 Cattle，提出了”All-in-Kubernetes”战略，从 2.0 版本开始，把 1.x 版本能够支持多种容器管理工具的 Rancher，”升级”为只支持 Kubernetes 一种的容器管理系统。</p>
<p>在这一年，Kubernetes 的主要竞争者 Apache Mesos，在 9 月正式宣布了” <a target="_blank" rel="noopener" href="https://k8smeetup.github.io/docs/getting-started-guides/mesos/">Kubernetes on Mesos</a> “集成计划，开始由竞争关系，转为了对 Kubernetes 提供支持，使其能够与 Mesos 的其他一级框架（如 <a target="_blank" rel="noopener" href="https://docs.mesosphere.com/latest/usage/service-guides/hdfs/">HDFS</a>、<a target="_blank" rel="noopener" href="https://docs.mesosphere.com/latest/usage/service-guides/spark/">Spark</a> 和 <a target="_blank" rel="noopener" href="https://mesos.github.io/chronos/docs/getting-started.html">Chros</a> 等）进行集群资源动态共享、分配与隔离。</p>
<p>在这一年，Kubernetes 的最大竞争者，Docker Swarm 的母公司 Docker，终于在 10 月被迫宣布 Docker 要同时支持 Swarm 与 Kubernetes 两套容器管理系统，也就是承认了 Kubernetes 的统治地位。</p>
<p>至此，这场已经持续了三、四年时间，以 Docker Swarm、Apache Mesos 与 Kubernetes 为主要竞争者的”容器战争”，终于有了明确结果。可以说，Kubernetes 最后从众多的容器管理系统中脱颖而出、”登基加冕”，就代表了容器发展中一个时代的结束。而且我可以说，它带来的容器间网络、服务、负载均衡、配置等虚拟化基础设施，也将会是开启下一个软件架构发展新纪元的钥匙。</p>
<p>我为什么会这么肯定呢？</p>
<p>针对同一个分布式服务的问题，对比下 Spring Cloud 中提供的应用层面的解决方案，以及 Kubernetes 中提供的基础设施层面的解决方案，你就可以明白其中缘由了。</p>
<p><img src="https://fastly.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《周志明的软件架构课》学习笔记/Kubernetes对比SprintCloud.webp" alt="Kubernetes对比SprintCloud"></p>
<p>虽然 Spring Cloud 和 Kubernetes 的出发点不同，解决问题的方法和效果也不一样，但不容忽视的是，Kubernetes 的确提供了一条全新的、前途更加广阔的解题思路。</p>
<p>我说的”前途广阔”，不仅仅是一句恭维赞赏的客气话。当虚拟化的基础设施，开始从单个服务的容器发展到由多个容器构成的服务集群，以及集群所需的所有通讯、存储设施的时候，软件与硬件的界限就开始模糊了。</p>
<p>一旦硬件能够跟得上软件的灵活性，那么这些与业务无关的技术问题，便很可能从软件的层面剥离出来，在硬件的基础设施之内就被悄悄解决掉，让软件可以只专注于业务，真正”围绕业务能力构建”团队与产品。那么原来只能从软件层面解决的分布式架构问题，于是有了另外一种解法：应用代码与基础设施软硬一体，合力应对。</p>
<p>这样一来，在 DCE 中未能实现的”透明的分布式应用”就成为了可能，Martin Fowler 设想的” <a target="_blank" rel="noopener" href="https://martinfowler.com/bliki/PhoenixServer.html">凤凰服务器</a> “就成为了可能，Chad Fowler 提出的” <a target="_blank" rel="noopener" href="http://chadfowler.com/2013/06/23/immutable-deployments.html">不可变基础设施</a> “也会成为可能。</p>
<p>没错，我们借此就来到了现在媒体文章中常说的”云原生”时代。这样理解下来，”云原生”这个概念，是不是没那么抽象了。</p>
<p>云原生时代追求的目标，跟此前微服务时代中追求的目标相比，并没有什么本质的改变，它们都是通过一系列小型服务去构建大型系统。在服务架构演进的历史进程中，我更愿意把”云原生时代”称为 <strong>“后微服务时代”</strong> 。</p>
<p><strong>不过还有一点值得注意的是</strong> ，前面我说，Kubernetes 成为了容器战争的胜利者，标志着后微服务时代的开端， <strong>但 Kubernetes 其实并没有完美地解决全部的分布式问题。</strong></p>
<p>这里所说的”不完美”的意思是，仅从功能灵活强大这点来看，Kubernetes 反而还不如之前的 Spring Cloud 方案。这是因为有一些问题处于应用系统与基础设施的边缘，我们很难能完全在基础设施的层面中，去精细化地解决掉它们。</p>
<p>给你举个例子，微服务 A 调用了微服务 B 中发布的两个服务，我们称之为 B1 和 B2，假设 B1 表现正常，但 B2 出现了持续的 500 错，那在达到一定的阈值之后，我们就应该对 B2 进行熔断，以避免产生 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Snowball_effect">雪崩效应</a> 。如果我们仅在基础设施的层面来做处理，这就会遇到一个两难问题，也就是切断 A 到 B 的网络通路，会影响到 B1 的正常调用，而不切断的话则会持续受到 B2 的错误影响。</p>
<p><img src="https://fastly.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《周志明的软件架构课》学习笔记/是否要熔断对服务B的访问.webp" alt="是否要熔断对服务B的访问"></p>
<p>这种问题在通过 Spring Cloud 这类应用代码实现的微服务中，其实并不难处理，反正是使用代码（或者配置）来解决问题，只要合乎逻辑，我们想做什么功能都是可以的，只是会受限于开发人员的想象力与技术能力。但基础设施是针对整个容器来做整体管理的，它的粒度就相对粗犷。</p>
<p>实际上，类似的情况不仅仅会在断路器上出现，服务的监控、认证、授权、安全、负载均衡等功能，都有细化管理的需求。比如，服务调用时的负载均衡，往往需要根据流量特征，调整负载均衡的层次、算法等，而 DNS 尽管能实现一定程度的负载均衡，但它通常并不能满足这些额外的需求。</p>
<p>所以，为了解决这一类问题，微服务基础设施很快就进行了第二次进化，引入在今天被我们叫做是 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Service_mesh">“服务网格”（Service Mesh）</a> 的 <strong>“边车代理模式”（Sidecar Proxy）</strong> 。</p>
<p>所谓的”边车”，是指一种带挎斗的三轮摩托，我小时候还算常见，现在基本就只在抗日神剧中才会看到了。</p>
<p><img src="https://fastly.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《周志明的软件架构课》学习笔记/边车（Sidecar）.webp" alt="边车（Sidecar）"></p>
<p>具体到咱们现在的语境里，”边车”的意思是，微服务基础设施会由系统自动地在服务的资源容器（指 Kubernetes 的 Pod）中注入一个通讯代理服务器（相当于那个挎斗），用类似网络安全里中间人攻击的方式进行流量劫持，在应用毫无感知的情况下，悄悄接管掉应用的所有对外通讯。</p>
<p>这个代理除了会实现正常的服务调用以外（称为数据平面通讯），同时还接受来自控制器的指令（称为控制平面通讯），根据控制平面中的配置，分析数据平面通讯的内容，以实现熔断、认证、度量、监控、负载均衡等各种附加功能。</p>
<p>这样，就实现了既不需要在应用层面附带额外的代码，也提供了几乎不亚于应用代码的精细管理能力的目的。</p>
<p><img src="https://fastly.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《周志明的软件架构课》学习笔记/边车代理流量.webp" alt="边车代理流量"></p>
<p>（来自 Istio 的 <a target="_blank" rel="noopener" href="https://istio.io/docs/reference/config/policy-and-telemetry/mixer-overview/">配置文档</a> ，图中的 Mixer 在 Istio 1.5 之后已经取消，这里仅作示意）</p>
<h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p>今天，我带着你一起游览了后微服务时代，一起了解了容器化技术兴起对软件架构、软件开发的改变，并一起探讨了微服务如何通过虚拟化基础设施，来解决分布式问题的办法，即今天服务网格中的”边车代理模式”。</p>
<p>服务网格在 2018 年才火了起来，到今天它仍然是一个新潮的概念，Istio 和 Envoy 的发展时间还很短，仍然没有完全成熟，甚至连 Kubernetes 也还算是个新生事物（以它开源的日期来计算）。</p>
<p>但我相信，未来几年，Kubernetes 将会成为服务器端标准的运行环境，如同在此之前的 Linux 一样；服务网格将会成为微服务之间通讯交互的主流模式，它会把”选择什么通讯协议””如何做认证授权”之类的技术问题隔离于应用软件之外，取代今天的 Spring Cloud 全家桶中的大部分组件的功能。这是最理想的 <a target="_blank" rel="noopener" href="https://martinfowler.com/articles/microservices.html#SmartEndpointsAndDumbPipes">Smart Endpoints</a> 解决方案，微服务只需要考虑业务本身的逻辑就行了。</p>
<p>上帝的归上帝，凯撒的归凯撒，业务与技术完全分离，远程与本地完全透明，我想也许这就是分布式架构最好的时代吧。</p>
<h3 id="06-无服务时代：”不分布式”云端系统的起点"><a href="#06-无服务时代：”不分布式”云端系统的起点" class="headerlink" title="06 | 无服务时代：”不分布式”云端系统的起点"></a>06 | 无服务时代：”不分布式”云端系统的起点</h3><p>今天是探索”演进中的架构”的最后一讲，我们来聊聊最近一两年才开始兴起的 <strong>“无服务架构”</strong> 。</p>
<p>我们都知道，分布式架构出现的最初目的，是要解决单台机器的性能成为整个软件系统的瓶颈的问题。后来随着技术的演进，容错能力、技术异构、职责划分等其他因素，也都成了分布式架构要考虑的问题。但不可否认的是，获得更好的性能，仍然在架构设计中占有非常大的比重。</p>
<p>在前面几讲我们也说，分布式架构也会引入一些新问题（比如服务的安全、容错，分布式事务的一致性），因此对软件开发这件事儿来说，不去做分布式无疑是最简单的。如果单台服务器的性能可以是无限的，那架构演进的结果，肯定会跟今天不一样。不管是分布式和容器化，还是微服务，恐怕都未必会出现了，最起码不会是今天的模样。</p>
<p>当然了，绝对意义上的无限性能肯定是不存在的，但相对意义上的无限性能其实已经实现了，云计算的成功落地就可以说明这一点。对基于云计算的软件系统来说，无论用户有多少、逻辑如何复杂，AWS、阿里云等云服务提供商都能在算力上满足系统对性能的需求，只要你能为这种无限的性能支付得起对应的代价。</p>
<p>在工业界，2012 年，<a target="_blank" rel="noopener" href="https://www.iron.io/">iron.io 公司</a> 率先提出了”无服务”（Serverless，应该翻译为”无服务器”才合适，但现在用”无服务”已形成习惯了）的概念；2014 年开始，AWS 发布了命名为 Lambda 的商业化无服务应用，并在后续的几年里逐步得到了开发者的认可，发展成目前世界上最大的无服务的运行平台；到了 2019 年，中国的阿里云、腾讯云等厂商，也发布了无服务的产品。”无服务”成了近期技术圈里的”新网红”之一。</p>
<p>我们再看看学术界对无服务的态度。在 2009 年云计算刚提出的时候，UC Berkeley 大学就发表了一篇论文 <a target="_blank" rel="noopener" href="https://www2.eecs.berkeley.edu/Pubs/TechRpts/2009/EECS-2009-28.pdf">“Above the Clouds: A Berkeley View of Cloud Computing”</a> ，文中预言的云计算的价值、演进和普及，在过去的十年（2009~2019 年）里一一得到了验证。十年之后的 2019 年，UC Berkeley 的第二篇命名风格相同的论文 <a target="_blank" rel="noopener" href="https://arxiv.org/abs/1902.03383">“Cloud Programming Simplified: A Berkeley View on Serverless Computing”</a> ，再次预言”无服务将会成为日后云计算的主流方式”。</p>
<p>由此可见，主流学术界也同样认可无服务是未来的一个发展方向。</p>
<p>虽然工业界和学术界在”无服务”这件事儿上都取得了些成果，但是到今天”无服务”也还没有一个特别权威的定义。不过这也不是什么问题，毕竟它没有我们前面讲到的微服务、SOA 等各种架构那么复杂， <strong>它最大的卖点就是简单</strong> ，只涉及了后端设施（Backend）和函数（Function）两块内容。</p>
<ul>
<li><strong>后端设施</strong> 是指数据库、消息队列、日志、存储等这一类用于支撑业务逻辑运行，但本身无业务含义的技术组件。这些后端设施都运行在云中，也就是无服务中的 <strong>“后端即服务”（Backend as a Service，BaaS）</strong> 。</li>
<li><strong>函数</strong> 指的就是业务逻辑代码。这里函数的概念与粒度，都已经和程序编码角度的函数非常接近了，区别就在于，无服务中的函数运行在云端，不必考虑算力问题和容量规划（从技术角度可以不考虑，但从计费的角度来看，你还是要掂量一下自己的钱包够不够用），也就是无服务中的 <strong>“函数即服务”（Function as a Service，FaaS）</strong> 。</li>
</ul>
<p><strong>无服务的愿景是让开发者只需要纯粹地关注业务：</strong> 一是，不用考虑技术组件，因为后端的技术组件是现成的，可以直接取用，没有采购、版权和选型的烦恼；二是，不需要考虑如何部署，因为部署过程完全是托管到云端的，由云端自动完成；三是，不需要考虑算力，因为有整个数据中心的支撑，算力可以认为是无限的；四是，也不需要操心运维，维护系统持续地平稳运行是云服务商的责任，而不再是开发者的责任。</p>
<p>你看，这是不是就像从汇编语言发展到高级语言后，开发者不用再去关注寄存器、信号、中断等与机器底层相关的细节？没错儿，UC Berkeley 的论文 <a target="_blank" rel="noopener" href="https://arxiv.org/abs/1902.03383">“Cloud Programming Simplified: A Berkeley View on Serverless Computing”</a> 中，就是这样描述无服务给生产力带来的极大解放的。</p>
<p>不过，无服务架构的远期前景也许很美好，但我自己对无服务中短期内的发展，并没有那么乐观。为什么这么说呢？</p>
<p><strong>与单体架构、微服务架构不同，无服务架构天生的一些特点，比如冷启动、 无状态、运行时间有限制等等，决定了它不是一种具有普适性的架构模式。</strong> 除非是有重大变革，否则它也很难具备普适性。</p>
<p>一方面，对一些适合的应用来说，使用无服务架构确实能够降低开发和运维环节的成本，比如不需要交互的离线大规模计算，又比如多数 Web 资讯类网站、小程序、公共 API 服务、移动应用服务端等，都跟无服务架构擅长的短链接、无状态、适合事件驱动的交互形式很契合。</p>
<p>但另一方面，对于那些信息管理系统、网络游戏等应用来说，又或者说对所有具有业务逻辑复杂、依赖服务端状态、响应速度要求较高、需要长连接等特征的应用来说，无服务架构至少在目前来看并不是最合适的。</p>
<p>这是因为，无服务天生”无限算力”的假设，就决定了它必须要按使用量（函数运算的时间和内存）来计费，以控制消耗算力的规模，所以函数不会一直以活动状态常驻服务器，只有请求到了才会开始运行。这导致了函数不便于依赖服务端状态，也导致了函数会有冷启动时间，响应的性能不可能会太好（目前，无服务的云函数冷启动过程大概是在百毫秒级别，对于 Java 这类启动性能差的应用，甚至能到秒级）。</p>
<p>但无论如何，云计算毕竟是大势所趋，今天信息系统建设的概念和观念，在较长尺度的”明天”都是会转变成适应云端的。我并不怀疑 Serverless+API 的这种设计方式，随着云计算的持续发展，将会成为一种主流的软件架构形式，无服务到时候也应该会有更广阔的应用空间。</p>
<p><strong>如果说微服务架构是分布式系统这条路当前所能做到的极致，那无服务架构，也许就是”不分布式”的云端系统这条路的起点。</strong></p>
<p>虽然在顺序上，我把”无服务”安排到了”微服务”和”云原生”时代之后，但它们并没有继承替代关系。我之所以要强调这一点，是为了避免你可能会从两者的名称和安排顺序的角度，产生”无服务比微服务更加先进”的错误想法。我相信，软件开发的未来，不会只存在某一种”最先进的”架构风格，而是会有多种具有针对性的架构风格并存。这才是软件产业更有生命力的形态。</p>
<p>我同样也相信，软件开发的未来，多种架构风格将会融合互补，”分布式”与”不分布式”的边界将会逐渐模糊，两条路线将会在云端的数据中心交汇。</p>
<p>今天，我们已经能初步看见一些使用无服务的云函数去实现微服务架构的苗头了，所以把无服务作为技术层面的架构，把微服务视为应用层面的架构，这样的组合使用也是完全合理可行的。比如，根据腾讯公开的资料，企业微信、QQ 小程序、腾讯新闻等产品，就是使用自己的无服务框架构成的微服务系统。以后，无论是通过物理机、虚拟机、容器，或者是无服务云函数，都会是微服务实现方案的一个候选项。</p>
<h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><p>今天是架构演进历史的最后一讲，如 <a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/309761">第 1 讲</a> 的开篇所说，我们谈历史重点不在考古，而是要借历史之名，来理解每种架构出现的意义以及被淘汰的原因。这样，我们才能更好地解决今天遇到的各种实际的问题，看清楚未来架构演进的发展道路。</p>
<p>对于架构演进的未来，2014 年的时候，Martin Fowler 和 James Lewis 在 <a target="_blank" rel="noopener" href="https://martinfowler.com/articles/microservices.html">《Microservices》</a> 的结束语中分享的观点是，他们对于微服务日后能否被大范围地推广，最多只能持谨慎的乐观态度。无服务方兴未艾的今天，与那时微服务的情况十分相近，我对无服务日后的推广也是持有谨慎的乐观态度。软件开发的最大挑战就在于，只能在不完备的信息下决定当前要处理的问题。</p>
<p>时至今日，我们依然很难预想在架构演进之路的前方，微服务和无服务之后，还会出现什么形式的架构风格，这也正契合了图灵的那句名言：尽管目光所及之处，只是不远的前方，即使如此，依然可以看到那里有许多值得去完成的工作在等待我们。</p>
<blockquote>
<p>We can only see a short distance ahead, but we can see plenty there that needs to be done.</p>
<p>尽管目光所及之处，只是不远的前方，即使如此，依然可以看到那里有许多值得去完成的工作在等待我们。</p>
<p>—— Alan Turing, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Computing_Machinery_and_Intelligence">Computing Machinery and Intelligence</a>, 1950</p>
</blockquote>
<h2 id="架构师的视角"><a href="#架构师的视角" class="headerlink" title="架构师的视角"></a>架构师的视角</h2><h3 id="07-远程服务调用（上）：从本地方法到远程方法的桥梁"><a href="#07-远程服务调用（上）：从本地方法到远程方法的桥梁" class="headerlink" title="07 | 远程服务调用（上）：从本地方法到远程方法的桥梁"></a>07 | 远程服务调用（上）：从本地方法到远程方法的桥梁</h3><p>“架构师”这个词，其实指向非常宽泛，你可以说做企业战略设计的是架构师，也可以说做业务流程分析的是架构师。而在这门课程中，我所针对的架构师视角，特指软件系统中技术模型的系统设计者。在这个模块当中，我会带你系统性地了解，在做架构设计的时候，架构师都应该思考哪些问题、可以选择哪些主流的解决方案和行业标准做法，以及这些主流方案都有什么优缺点、会给架构设计带来什么影响，等等。</p>
<p>理解了架构师的这些职责，你对”架构设计”这种听起来就很抽象的工作，是不是有个更具体的认识了？</p>
<p>从今天开始，我会花两讲的时间，和你一起学习 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Remote_procedure_call">“远程服务调用（Remote Procedure Call，RPC）”</a> 这个话题。我会尽可能地从根源到现状、从表现到本质，为你解释清楚 RPC 的一些常见的问题。</p>
<p>那今天，我们就先从”什么是 RPC”开始，一起去学习”远程服务”这个构建分布式系统的最基本的前置条件，看看它是如何出现、如何发展的，以及当前业界的主流实现手段。</p>
<p>其实，RPC 这个词儿在计算机科学中已经有超过 40 年的历史了，肯定不是一个新概念。但是直到今天，我们还是会在知乎等网站上，看到很多人提问”什么是 RPC？””如何评价某某 RPC 技术？””RPC 好还是 REST 好？”，仍然”每天”都有新的不同形状的 RPC 轮子被发明出来，仍然有层出不穷的文章，去比对 Google gRPC、Facebook Thrift 等各个厂家的 RPC 技术的优劣。</p>
<p>像计算机科学这种知识快速更迭的领域，一项 40 岁高龄的技术能有如此的关注度，可以说是相当稀罕的现象了。那为什么会出现这种现象呢？</p>
<p>我分析了其中的原因：一方面，可能是微服务风潮带来的热度；另一方面，也不得不承认，作为开发者，我们很多人对 RPC 本身可以解决什么问题、如何解决这些问题、为什么要这样解决，都或多或少存在些认知模糊的情况。</p>
<p>那接下来，我就给你详细解读一下，关于 RPC 的各种分歧和普遍的错误认知。</p>
<h4 id="进程间通讯"><a href="#进程间通讯" class="headerlink" title="进程间通讯"></a>进程间通讯</h4><p>尽管今天的大多数 RPC 技术已经不再追求”与本地方法调用一致”这个目标了，但不可否认的是，RPC 出现的最初目的，就是为了让计算机能够跟调用本地方法一样，去调用远程方法。所以，我们先来看一下在本地方法调用的时候，都会发生些什么。</p>
<p>我们先通过下面这段 Java 风格的伪代码，来定义几个概念：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
<span class="token comment">// 调用者（Caller）      ： main()</span>
<span class="token comment">// 被调用者（Callee）    ： println()</span>
<span class="token comment">// 调用点（Call Site）   ： 发生方法调用的指令流位置</span>
<span class="token comment">// 调用参数（Parameter） ： 由Caller传递给Callee的数据，即"hello world"</span>
<span class="token comment">// 返回值（Retval）      ： 由Callee传递给Caller的数据，如果方法正常完成，返回值是void，否则是对应的异常</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过这段伪代码，你可以发现，在完全不考虑编译器优化的前提下，程序运行至调用 println() 这一行的时候，计算机（物理机或者虚拟机）会做以下这些事情：</p>
<ol>
<li><strong>传递方法参数</strong> ：将字符串 hello world 的引用压栈。</li>
<li><strong>确定方法版本</strong> ：根据 println() 方法的签名，确定它的执行版本其实并不是一个简单的过程，不管是编译时的静态解析也好，还是运行时的动态分派也好，程序都必须根据某些语言规范中明确定义的原则，找到明确的被调用者 Callee。这里的”明确”是指唯一的一个 Callee，或者有严格优先级的多个 Callee，比如不同的重载版本。我曾在 <a target="_blank" rel="noopener" href="https://book.douban.com/subject/34907497/">《深入理解 Java 虚拟机》</a> 中用一整章介绍过这个过程。如果你感兴趣的话，可以去深入了解一下。</li>
<li><strong>执行被调方法</strong> ：从栈中获得 Parameter，以此为输入，执行 Callee 内部的逻辑。</li>
<li><strong>返回执行结果</strong> ：将 Callee 的执行结果压栈，并将指令流恢复到 Call Site 处，继续向下执行。</li>
</ol>
<p>接下来，我们就需要考虑一下，当 println() 方法不在当前进程的内存地址空间中，会出现什么问题。不难想到，此时至少面临 <strong>两个直接的障碍</strong> ：</p>
<ul>
<li>第一个障碍，前面的第一步和第四步所做的传递参数、传回结果都依赖于栈内存的帮助，如果 Caller 与 Callee 分属不同的进程，就不会拥有相同的栈内存，那么在 Caller 进程的内存中将参数压栈，对于 Callee 进程的执行毫无意义。</li>
<li>第二个障碍，第二步的方法版本选择依赖于语言规则的定义，而如果 Caller 与 Callee 不是同一种语言实现的程序，方法版本选择就将是一项模糊的不可知行为。</li>
</ul>
<p>所以为了简化，我们暂时忽略第二个障碍，假设 Caller 与 Callee 是使用同一种语言实现的，先来解决两个进程之间如何交换数据的问题，这件事情在计算机科学中被称为”进程间通讯”（Inter-Process Communication，IPC）。那么我们可以考虑的解决办法就有以下几种：</p>
<ol>
<li><p><strong>第一，管道（Pipe）或具名管道（Named Pipe）</strong></p>
<p> 管道其实类似于两个进程间的桥梁，用于进程间传递少量的字符流或字节流。 <strong>普通管道</strong> 可用于 <strong>有亲缘关系进程间的通信（由一个进程启动的另外一个进程）</strong> ；而 <strong>具名管道</strong> 摆脱了普通管道没有名字的限制，除了具有普通管道所具有的功能以外，它还允许 <strong>无亲缘关系进程间的通信</strong> 。</p>
<p> 管道典型的应用就是命令行中的” | “操作符，比如说，命令”ps -ef | grep java”  ，就是管道操作符” | “将 ps 命令的标准输出通过管道，连接到 grep 命令的标准输入上。</p>
</li>
<li><p><strong>第二，信号（Signal）</strong></p>
<p> 信号是用来通知目标进程有某种事件发生的。除了用于进程间通信外，信号还可以被进程发送给进程自身。信号的典型应用是 kill 命令，比如”kill -9 pid”，意思就是由 Shell 进程向指定 PID 的进程发送 SIGKILL 信号。</p>
</li>
<li><p><strong>第三，信号量（Semaphore）</strong></p>
<p> 信号量是用于两个进程之间同步协作的手段，相当于操作系统提供的一个特殊变量。我们可以在信号量上，进行 wait() 和 notify() 操作。</p>
</li>
<li><p><strong>第四，消息队列（Message Queue）</strong></p>
<p> 前面所说的这三种方式，只适合传递少量信息，而 POSIX 标准中，有定义”消息队列”用于进程间通讯的方法。也就是说，进程可以向队列中添加消息，而被赋予读权限的进程则可以从队列中消费消息。消息队列就克服了信号承载信息量少、管道只能用于无格式字节流，以及缓冲区大小受限等缺点  ，但实时性相对受限。</p>
</li>
<li><p><strong>第五，共享内存（Shared Memory）</strong></p>
<p> 允许多个进程可以访问同一块内存空间，这是效率最高的进程间通讯形式。进程的内存地址空间是独立隔离的，但操作系统提供了让进程主动创建、映射、分离、控制某一块内存的接口。由于内存是多进程共享的，所以往往会与其它通信机制，如信号量等结合使用，来达到进程间的同步及互斥。</p>
</li>
<li><p><strong>第六，本地套接字接口（IPC Socket）</strong></p>
<p> 消息队列和共享内存这两种方式，只适合单机多进程间的通讯。而 <strong>套接字接口，是更为普适的进程间通信机制，可用于不同机器之间的进程通信。</strong></p>
<p> 套接字（Socket）起初是由 Unix 系统的 BSD 分支开发出来的，但现在已经移植到所有的 Unix 和 Linux 系统上了。基于效率考虑，当仅限于本机进程间通讯的时候，套接字接口是被优化过的，不会经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等操作，只是简单地将应用层数据从一个进程拷贝到另一个进程，这种进程间通讯方式有个专有的名称：Unix Domain Socket，又叫做 IPC  Socket。</p>
</li>
</ol>
<h4 id="通信的成本"><a href="#通信的成本" class="headerlink" title="通信的成本"></a>通信的成本</h4><p>我之所以花这么多篇幅来介绍 IPC 的手段，是因为计算机科学家们最初的想法，就是将 RPC 作为 IPC 的一种特例来看待（其实现在分类上这么说也仍然合适，只是在具体操作手段上不会这么做了）。</p>
<p>这里，我们需要特别关注的是最后一种 <strong>基于套接字接口的通讯方式（IPC Socket）</strong> 。因为它不仅适用于本地相同机器的不同进程间通讯，而且因为 Socket 是网络栈的统一接口，它也理所当然地能支持基于网络的跨机器、跨进程的通讯。比如 Linux 系统的图形化界面中，X Window 服务器和 GUI 程序之间的交互，就是由这套机制来实现的。</p>
<p>此外，这样做还有一个看起来无比诱人的好处。因为 IPC Socket 是操作系统提供的标准接口，所以它完全有可能把远程方法调用的通讯细节，隐藏在操作系统底层，从应用层面上来看，可以做到远程调用与本地方法调用几乎完全一致。</p>
<p>事实上，在 <a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/309761">原始分布式时代</a> 的初期确实是奔着这个目标去做的， <strong>但这种透明的调用形式反而让程序员们误以为通信是无成本的，从而被滥用，以至于显著降低了分布式系统的性能。</strong></p>
<p>1987 年，当”透明的 RPC 调用”一度成为主流范式的时候，安德鲁 · 塔能鲍姆（Andrew Tanenbaum）教授曾发表了一篇论文 <a target="_blank" rel="noopener" href="https://www.cs.vu.nl/~ast/Publications/Papers/euteco-1988.pdf">“A Critique of the Remote Procedure Call Paradigm”</a> ，对这种透明的 RPC 范式提出了一系列质问：</p>
<ul>
<li>两个进程通讯，谁作为服务端，谁作为客户端？</li>
<li>怎样进行异常处理？异常该如何让调用者获知？</li>
<li>服务端出现多线程竞争之后怎么办？</li>
<li>如何提高网络利用的效率，比如连接是否可被多个请求复用以减少开销？是否支持多播？</li>
<li>参数、返回值如何表示？应该有怎样的字节序？</li>
<li>如何保证网络的可靠性，比如调用期间某个链接忽然断开了怎么办？</li>
<li>服务端发送请求后，收不到回复该怎么办？</li>
<li>……</li>
</ul>
<p><strong>论文的中心观点</strong> 是：把本地调用与远程调用当作一样的来处理，是犯了方向性的错误，把系统间的调用做成透明的，反而会增加程序员工作的复杂度。</p>
<p>此后几年，关于 RPC 应该如何发展、如何实现的论文层出不穷，有支持的也有反对，有冷静分析的也有狂热唾骂的，但历史逐渐证明了 Andrew Tanenbaum 的预言是正确的。</p>
<p>最终，1994 年至 1997 年间，由 ACM 和 Sun 的院士 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/L._Peter_Deutsch">Peter Deutsch</a>、套接字接口发明者 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bill_Joy">Bill Joy</a> 、Java 之父 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/James_Gosling">James Gosling</a> 等众多在 Sun Microsystems 工作的大佬们，共同总结了 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing">通过网络进行分布式运算的八宗罪（8 Fallacies of Distributed Computing）</a> ：</p>
<ul>
<li>网络是可靠的（The network is reliable）</li>
<li>延迟是不存在的（Latency is zero ）</li>
<li>带宽是无限的（Bandwidth is infinite）</li>
<li>网络是安全的（The network is secure）</li>
<li>拓扑结构是一成不变的（Topology doesn’t change）</li>
<li>总会有一个管理员（There is one administrator）</li>
<li>不考虑传输成本（Transport cost is zero）</li>
<li>网络是同质化的（The network is homogeneous）</li>
</ul>
<p>这八宗罪，被认为是程序员在网络编程中经常忽略的八大问题，潜台词就是如果远程服务调用要弄透明化的话，就必须为这些罪过买单。这算是给 RPC 能否等同于 IPC 来实现，暂时定下了一个具有公信力的结论。</p>
<p>到这时为止，RPC 应该是一种高层次的，或者说语言层次的特征，而不是像 IPC 那样，是低层次的，或者说系统层次的特征，就成为了工业界、学术界的主流观点。</p>
<p>在 1980 年代初期，传奇的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/PARC_(company">施乐 Palo Alto 研究中心</a>) ，发布了基于 Cedar 语言的 RPC 框架 Lupine，并实现了世界上第一个基于 RPC 的商业应用 Courier。这里施乐 PARC 定义的”远程服务调用”的概念，就是符合上面针对 RPC 的结论的。所以，尽管此前已经有用其他名词指代 RPC 的操作，我们也一般认为 RPC 的概念，最早是由施乐公司所提出的。</p>
<blockquote>
<p><strong>首次提出远程服务调用的定义</strong></p>
<p>Remote procedure call is the synchronous language-level transfer of control between programs in address spaces whose primary communication is a narrow channel.</p>
<p>—— Bruce Jay Nelson， <a target="_blank" rel="noopener" href="http://www.bitsavers.org/pdf/xerox/parc/techReports/CSL-81-9_Remote_Procedure_Call.pdf">Remote Procedure Call</a> ，Xerox PARC，1981</p>
</blockquote>
<p><img src="https://fastly.jsdelivr.net/gh/kibaamor/kibaamor.github.io/images/《周志明的软件架构课》学习笔记/施乐提出RPC论文的封面.webp" alt="施乐提出RPC论文的封面"></p>
<p>到这里，我们就可以得出 RPC 的定义了：RPC 是一种语言级别的通讯协议，它允许运行于一台计算机上的程序以某种管道作为通讯媒介（即某种传输协议的网络），去调用另外一个地址空间（通常为网络上的另外一台计算机）。</p>
<h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><p>这一讲，我们讨论了 RPC 的起源、概念，以及它发展上的一些分歧。以此为基础，我们才能更好地理解后面几讲要学习的内容，包括 RPC 本身要解决的三大问题、RPC 框架的现状与发展，以及它与 REST 的区别。</p>
<p>RPC 以模拟进程间方法调用为起点，许多思想和概念都借鉴的是 IPC，因此这一讲我也介绍了 IPC 中的一些关键概念和实现方法。但是，RPC 原本想照着 IPC 的发展思路，却在实现层面上遇到了很大的困难。RPC 作为一种跨网络的通讯手段，能否无视通讯的成本去迁就编程和设计的原则，这一点从几十年前的 DCE 开始，直到今天学术界、工业界都还有争议。</p>
<p>在下一讲，我会和你一起学习在 RPC 的定义提出之后，工业界中出现过的、著名的 RPC 协议，以及当今常用的各种 RPC 框架，学习它们的共性，也就是它们都必须解决哪几个问题，各自以什么为关注点，以及为何不会出现”完美的”RPC 框架。</p>
<h3 id="08-远程服务调用（下）：如何选择适合自己的RPC框架？"><a href="#08-远程服务调用（下）：如何选择适合自己的RPC框架？" class="headerlink" title="08 | 远程服务调用（下）：如何选择适合自己的RPC框架？"></a>08 | 远程服务调用（下）：如何选择适合自己的RPC框架？</h3><p>上一讲，我们主要是从学术的角度出发，一起学习了 RPC 概念的形成过程。今天这一讲，我会带你从技术的角度出发，去看看工业界在 RPC 这个领域曾经出现过的各种协议，以及时至今日还在层出不穷的各种框架。你会从中了解到 RPC 要解决什么问题，以及如何选择适合自己的 RPC 框架。</p>
<h4 id="RPC-框架要解决的三个基本问题"><a href="#RPC-框架要解决的三个基本问题" class="headerlink" title="RPC 框架要解决的三个基本问题"></a>RPC 框架要解决的三个基本问题</h4><p>在第 1 讲 <a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/309761">“原始分布式时代”</a> 中，我曾提到过，在 80 年代中后期，惠普和 Apollo 提出了 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Network_Computing_System">网络运算架构（Network Computing Architecture，NCA）</a> 的设想，并随后在 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Distributed_Computing_Environment">DCE 项目</a> 中，发展成了在 Unix 系统下的远程服务调用框架 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/DCE/RPC">DCE/RPC</a> 。</p>
<p>这是历史上第一次对分布式有组织的探索尝试。因为 DCE 本身是基于 Unix 操作系统的，所以 DCE/RPC 也仅面向于 Unix 系统程序之间的通用。</p>
<blockquote>
<p>补充：这句话其实不全对，微软 COM/DCOM 的前身 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Microsoft_RPC">MS RPC</a>，就是 DCE 的一种变体版本，而它就可以在 Windows 系统中使用。</p>
</blockquote>
<p>在 1988 年，Sun Microsystems 起草并向互联网工程任务组（Internet Engineering Task Force，IETF）提交了RFC 1050规范，此规范中设计了一套面向广域网或混合网络环境的、基于 TCP/IP 网络的、支持 C 语言的 RPC 协议，后来也被称为是ONC RPC（Open Network Computing RPC/Sun RPC）。</p>
<p>这两个 RPC 协议，就可以算是如今各种 RPC 协议的鼻祖了。从它们开始，一直到接下来的这几十年，所有流行过的 RPC 协议，都不外乎通过各种手段来解决三个基本问题：</p>
<ol>
<li><p><strong>如何表示数据？</strong></p>
<p> 这里的数据包括了传递给方法的参数，以及方法的返回值。无论是将参数传递给另外一个进程，还是从另外一个进程中取回执行结果，都会涉及 <strong>应该如何表示</strong> 的问题。</p>
<p> 针对进程内的方法调用，我们使用程序语言内置的和程序员自定义的数据类型，就很容易解决数据表示的问题了；而远程方法调用，则可能面临交互双方分属不同程序语言的情况。</p>
<p> 所以，即使是只支持同一种语言的 RPC 协议，在不同硬件指令集、不同操作系统下，也完全可能有不一样的表现细节，比如数据宽度、字节序的差异等。</p>
<p> 行之有效的做法，是 <strong>将交互双方涉及的数据，转换为某种事先约定好的中立数据流格式来传输，将数据流转换回不同语言中对应的数据类型来使用</strong> 。这个过程说起来比较拗口，但相信你一定很熟悉它，这其实就是序列化与反序列化。</p>
<p> 每种 RPC 协议都应该有对应的序列化协议，比如：</p>
<ul>
<li>ONC RPC 的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/External_Data_Representation">External Data Representation （XDR）</a></li>
<li>CORBA 的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Common_Data_Representation">Common Data Representation（CDR）</a></li>
<li>Java RMI 的 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/platform/serialization/spec/protocol.html#a10258">Java Object Serialization Stream Protocol</a></li>
<li>gRPC 的 <a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers">Protocol Buffers</a></li>
<li>Web Service 的 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/standard/serialization/xml-serialization-with-xml-web-services">XML Serialization</a></li>
<li>众多轻量级 RPC 支持的 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7159">JSON Serialization</a></li>
<li>……</li>
</ul>
</li>
<li><p><strong>如何传递数据？</strong></p>
<p> 准确地说，如何传递数据是指如何通过网络，在两个服务 Endpoint 之间相互操作、交换数据。这里”传递数据”通常指的是应用层协议，实际传输一般是基于标准的 TCP、UDP 等传输层协议来完成的。<br> 两个服务交互不是只扔个序列化数据流来表示参数和结果就行了，诸如异常、超时、安全、认证、授权、事务等信息，都可能存在双方交换信息的需求。</p>
<p> 在计算机科学中，专门有一个 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Wire_protocol">“Wire Protocol”</a> ，用来表示两个 Endpoint 之间交换这类数据的行为。常见的 Wire Protocol 有以下几种：</p>
<ul>
<li>Java RMI 的 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/platform/rmi/spec/rmi-protocol3.html">Java Remote Message Protocol</a> （JRMP，也支持 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=RMI-IIOP&amp;action=edit&amp;redlink=1">RMI-IIOP</a> ）</li>
<li>CORBA 的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/General_Inter-ORB_Protocol">Internet Inter ORB Protocol</a> （IIOP，是 GIOP 协议在 IP 协议上的实现版本）</li>
<li>DDS 的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Data_Distribution_Service">Real Time Publish Subscribe Protocol（RTPS）</a></li>
<li>Web Service 的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/SOAP">Simple Object Access Protocol（SOAP）</a></li>
<li>如果要求足够简单，双方都是 HTTP Endpoint，直接使用 HTTP 也可以（如 JSON-RPC）</li>
<li>……</li>
</ul>
</li>
<li><p><strong>如何表示方法？</strong></p>
</li>
</ol>
<p>“如何表示方法”，这在本地方法调用中其实也不成问题，因为编译器或者解释器会根据语言规范，把调用的方法转换为进程地址空间中方法入口位置的指针。</p>
<p>不过一旦考虑到不同语言，这件事儿又麻烦起来了，因为每门语言的方法签名都可能有所差别，所以，针对”如何表示一个方法”和”如何找到这些方法”这两个问题，我们还是得有个统一的标准。<br>这个标准做起来其实可以很简单：只要给程序中的每个方法，都规定一个通用的又绝对不会重复的编号；在调用的时候，直接传这个编号就可以找到对应的方法。这种听起来无比寒碜的办法，还真的就是 DCE/RPC 最初准备的解决方案。</p>
<p>虽然最后，DCE 还是弄出了一套跟语言无关的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Interface_description_language">接口描述语言（Interface Description Language，IDL）</a> ，成为了此后许多 RPC 参考或依赖的基础（如 CORBA 的 OMG IDL），但那个唯一的”绝不重复”的编码方案 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Universally_unique_identifier">UUID</a> ，却意外地流行了起来，已经被广泛应用到了程序开发的方方面面。</p>
<p>这类用于表示方法的协议还有：</p>
<ul>
<li>Android 的 <a target="_blank" rel="noopener" href="https://developer.android.com/guide/components/aidl">Android Interface Definition Language（AIDL）</a></li>
<li>CORBA 的 <a target="_blank" rel="noopener" href="https://www.omg.org/spec/IDL">OMG Interface Definition Language（OMG IDL）</a></li>
<li>Web Service 的 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/WSDL">Web Service Description Language（WSDL）</a></li>
<li>JSON-RPC 的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/JSON-WSP">JSON Web Service Protocol（JSON-WSP）</a></li>
<li>……</li>
</ul>
<p>你看，如何表示数据、如何传递数据、如何表示方法这三个 RPC 中的基本问题，都可以在本地方法调用中找到对应的操作。RPC 的思想始于本地方法调用，尽管它早就不再追求要跟本地方法调用的实现完全一样了，但 RPC 的发展仍然带有本地方法调用的深刻烙印。因此，我们在理解 PRC 的本质时，比较轻松的方式是，以它和本地调用的联系来对比着理解。</p>
<p>好，理解了 RPC 要解决的三个基本问题以后，我们接着来看一下，现代的 RPC 框架都为我们提供了哪些可选的解决方案，以及为什么今天会有这么多的 RPC 框架在并行发展。</p>
<h4 id="统一的-RPC"><a href="#统一的-RPC" class="headerlink" title="统一的 RPC"></a>统一的 RPC</h4><p>DCE/RPC 与 ONC RPC 都有很浓厚的 Unix 痕迹，所以它们其实并没有真正地在 Unix 系统以外大规模流行过，而且它们还有一个”大问题”：只支持传递值而不支持传递对象（ONC RPC 的 XDR 的序列化器能用于序列化结构体，但结构体毕竟不是对象）。这两个 RPC 协议都是面向 C 语言设计的，根本就没有对象的概念。</p>
<p>而 90 年代，正好又是 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Object-oriented_programming">面向对象编程（Object-Oriented Programming，OOP）</a> 风头正盛的年代，所以在 1991 年， <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E7%BB%84%E7%BB%87">对象管理组织（Object Management Group，OMG）</a> 便发布了跨进程、面向异构语言的、支持面向对象的服务调用协议：CORBA 1.0（Common Object Request Broker Architecture）。</p>
<p>CORBA 1.0 和 1.1 版本只提供了对 C 和 C++ 的支持，而到了末代的 CORBA 3.0 版本，不仅支持了 C、C++、Java、Object Pascal、Python、Ruby 等多种主流编程语言，还支持了 Smalltalk、Lisp、Ada、COBOL 等已经”半截入土”的非主流语言，阵营不可谓不强大。</p>
<p>可以这么说，CORBA 是一套由国际标准组织牵头、由多个软件提供商共同参与的分布式规范。在当时，只有微软私有的 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Distributed_COM">DCOM</a> 的影响力可以稍微跟 CORBA 抗衡一下。但是，与 DCE 一样，DCOM 也受限于操作系统（不过比 DCE 厉害的是，DCOM 能跨语言哟）。所以，能够同时支持跨系统、跨语言的 CORBA，其实原本是最有机会统一 RPC 这个细分领域的竞争者。</p>
<p>但很无奈的是，CORBA 并没有抓住这个机会。一方面，CORBA 本身的设计实在是太过于啰嗦和繁琐了，甚至有些规定简直到了荒谬的程度。比如说，我们要写一个对象请求代理（ORB，这是 CORBA 中的关键概念）大概要 200 行代码，其中大概有 170 行是纯粹无用的废话（这句带有鞭尸性质的得罪人的评价不是我说的，是 CORBA 的首席科学家 Michi Henning 在文章《 <a target="_blank" rel="noopener" href="https://dl.acm.org/doi/pdf/10.1145/1142031.1142044">The Rise and Fall of CORBA</a> 》中自己说的）。</p>
<p>另一方面，为 CORBA 制定规范的专家逐渐脱离实际了，所以做出的 CORBA 规范非常晦涩难懂，导致各家语言的厂商都有自己的解读，结果弄出来的 CORBA 实现互不兼容，实在是对 CORBA 号称支持众多异构语言的莫大讽刺。这也间接造就了后来 W3C Web Service 的出现。</p>
<p>所以，Web Service 一出现，CORBA 就在这场竞争中，犹如十八路诸侯讨董卓，互乱阵脚、一触即溃，局面可以说是惨败无比。最终下场就是，CORBA 和 DCOM 一起被扫进了计算机历史的博物馆中，而 Web Service 获得了一统 RPC 的大好机会。</p>
<p>1998 年，XML 1.0 发布，并成为了 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/World_Wide_Web_Consortium">万维网联盟（World Wide Web Consortium，W3C）</a> 的推荐标准。1999 年末，以 XML 为基础的 SOAP 1.0（Simple Object Access Protocol）规范的发布，代表着一种被称为”Web Service”的全新 RPC 协议的诞生。</p>
<p>Web Service 是由微软和 DevelopMentor 公司共同起草的远程服务协议，随后被提交给 W3C，并通过投票成为了国际标准。所以，Web Service 也被称为是 W3C Web Service。</p>
<p>Web Service 采用了 XML 作为远程过程调用的序列化、接口描述、服务发现等所有编码的载体，当时 XML 是计算机工业最新的银弹，只要是定义为 XML 的东西，几乎就都被认为是好的，风头一时无两，连微软自己都主动宣布放弃 DCOM，迅速转投 Web Service 的怀抱。</p>
<p>交给 W3C 管理后，Web Service 再没有天生属于哪家公司的烙印，商业运作非常成功，很受市场欢迎，大量的厂商都想分一杯羹。但从技术角度来看，它设计得也并不优秀，甚至同样可以说是有显著缺陷。</p>
<p>对于开发者而言， <strong>Web Service 的一大缺点，就是过于严格的数据和接口定义所带来的性能问题。</strong></p>
<p>虽然 Web Service 吸取了 CORBA 的教训，不再需要程序员手工去编写对象的描述和服务代理了，但是 XML 作为一门描述性语言，本身的信息密度就很低（都不用与二进制协议比，与今天的 JSON 或 YAML 比一下就知道了）。同时，Web Service 是一个跨语言的 RPC 协议，这使得一个简单的字段，为了在不同语言中不会产生歧义，要以 XML 描述去清楚的话，往往比原本存储这个字段值的空间多出十几倍、几十倍乃至上百倍。</p>
<p>这个特点就导致了，要想使用 Web Service，就必须要有专门的客户端去调用和解析 SOAP 内容，也需要专门的服务去部署（如 Java 中的 Apache Axis/CXF）；更关键的是，这导致了每一次数据交互都包含大量的冗余信息，性能非常差。</p>
<p>如果只是需要客户端、传输性能差也就算了， <a target="_blank" rel="noopener" href="https://www.zhihu.com/topic/20003839/hot">又不是不能用</a> 。既然选择了 XML 来获得自描述能力，也就代表着没打算把性能放到第一位。但是，Web Service 还有另外一点原罪：贪婪。</p>
<p>“贪婪”是指，它希望在一套协议上，一揽子解决分布式计算中可能遇到的所有问题。这导致 Web Service 生出了一整个家族的协议出来。</p>
<p>Web Service 协议家族中，除它本身包括了的 SOAP、WSDL、UDDI 协议之外，还有一堆以 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/List_of_web_service_specifications">WS-*</a> 命名的子功能协议，来解决事务、一致性、事件、通知、业务描述、安全、防重放等问题。这些几乎数不清个数的家族协议，对开发者来说学习负担极其沉重。结果就是，得罪惨了开发者，谁爱用谁用去。</p>
<p>当程序员们对 Web Service 的热情迅速燃起，又逐渐冷却之后，也不禁开始反思：那些 <strong>面向透明的、简单的 RPC 协议</strong> ，如 DCE/RPC、DCOM、Java RMI，要么依赖于操作系统，要么依赖于特定语言，总有一些先天约束；那些 <strong>面向通用的、普适的 RPC 协议</strong> ，如 CORBA，就无法逃过使用复杂性的困扰；而那些 <strong>意图通过技术手段来屏蔽复杂性的 RPC 协议</strong> ，如 Web Service，又不免受到性能问题的束缚。</p>
<p>简单、普适和高性能，似乎真的难以同时满足。</p>
<h4 id="分裂的-RPC"><a href="#分裂的-RPC" class="headerlink" title="分裂的 RPC"></a>分裂的 RPC</h4><p>由于一直没有一个能同时满足以上简单、普适和高性能的”完美 RPC 协议”，因此远程服务器调用这个小小的领域就逐渐进入了群雄混战、百家争鸣的”战国时代”，距离”统一”越来越远，并一直延续至今。</p>
<p>我们看看相继出现过的 RPC 协议 / 框架，就能明白了：RMI（Sun/Oracle）、Thrift（Facebook/Apache）、Dubbo（阿里巴巴 /Apache）、gRPC（Google）、Motan2（新浪）、Finagle（Twitter）、brpc（百度）、.NET Remoting（微软）、Arvo（Hadoop）、JSON-RPC 2.0（公开规范，JSON-RPC 工作组）……</p>
<p>这些 RPC 的功能、特点都不太一样，有的是某种语言私有，有的能支持跨越多门语言，有的运行在 HTTP 协议之上，有的能直接运行于 TCP/UDP 之上，但没有哪一款是”最完美的 RPC”。据此，我们也可以发现一个规律，任何一款具有生命力的 RPC 框架，都不再去追求大而全的”完美”，而是会找到一个独特的点作为主要的发展方向。</p>
<p>我们看几个典型的发展方向：</p>
<ul>
<li><strong>朝着面向对象发展。</strong> 这条线的缘由在于，在分布式系统中，开发者们不再满足于 RPC 带来的面向过程的编码方式，而是希望能够进行跨进程的面向对象编程。因此，这条线还有一个别名叫作 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Distributed_object">分布式对象（Distributed Object）</a> ，它的代表有 RMI、.NET Remoting。当然了，之前的 CORBA 和 DCOM 也可以归入这一类。</li>
<li><strong>朝着性能发展</strong> ，代表为 gRPC 和 Thrift。决定 RPC 性能主要就两个因素：序列化效率和信息密度。序列化效率很好理解，序列化输出结果的容量越小，速度越快，效率自然越高；信息密度则取决于协议中，有效荷载（Payload）所占总传输数据的比例大小，使用传输协议的层次越高，信息密度就越低，SOAP 使用 XML 拙劣的性能表现就是前车之鉴。gRPC 和 Thrift 都有自己优秀的专有序列化器，而在传输协议方面，gRPC 是基于 HTTP/2 的，支持多路复用和 Header 压缩，Thrift 则直接基于传输层的 TCP 协议来实现，省去了额外的应用层协议的开销。</li>
<li><strong>朝着简化发展</strong> ，代表为 JSON-RPC。要是说选出功能最强、速度最快的 RPC 可能会有争议，但要选出哪个功能弱的、速度慢的，JSON-RPC 肯定会是候选人之一。它牺牲了功能和效率，换来的是协议的简单。也就是说，JSON-RPC 的接口与格式的通用性很好，尤其适合用在 Web 浏览器这类一般不会有额外协议、客户端支持的应用场合。</li>
<li>……</li>
</ul>
<p>经历了 RPC 框架的”战国时代”，开发者们终于认可了，不同的 RPC 框架所提供的不同特性或多或少是互相矛盾的，很难有某一种框架说”我全部都要”。</p>
<p>要把面向对象那套全搬过来，就注定不会太简单（比如建 Stub、Skeleton 就很烦了，即使由 IDL 生成也很麻烦）；功能多起来，协议就要弄得复杂，效率一般就会受影响；要简单易用，那很多事情就必须遵循约定而不是配置才行；要重视效率，那就需要采用二进制的序列化器和较底层的传输协议，支持的语言范围容易受限。</p>
<p>也正是因为每一种 RPC 框架都有不完美的地方，才会有新的 RPC 轮子不断出现。</p>
<p>而到了最近几年，RPC 框架有明显朝着更高层次（不仅仅负责调用远程服务，还管理远程服务）与插件化方向发展的趋势， <strong>不再选择自己去解决表示数据、传递数据和表示方法这三个问题，而是将全部或者一部分问题设计为扩展点，实现核心能力的可配置</strong> ，再辅以外围功能，如负载均衡、服务注册、可观察性等方面的支持。这一类框架的代表，有 Facebook 的 Thrift 和阿里的 Dubbo（现在两者都是 Apache 的）。</p>
<p>尤其是断更多年后重启的 Dubbo 表现得更为明显，它默认有自己的传输协议（Dubbo 协议），同时也支持其他协议，它默认采用 Hessian 2 作为序列化器，如果你有 JSON 的需求，可以替换为 Fastjson；如果你对性能有更高的需求，可以替换为 <a target="_blank" rel="noopener" href="https://github.com/EsotericSoftware/kryo">Kryo</a> 、 <a target="_blank" rel="noopener" href="https://github.com/RuedigerMoeller/fast-serialization">FST</a> 、Protocol Buffers 等；如果你不想依赖其他包，直接使用 JDK 自带的序列化器也可以。这种设计，就在一定程度上缓解了 RPC 框架必须取舍，难以完美的缺憾。</p>
<h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><p>今天，我们一起学习了 RPC 协议在工业界的发展，包括它要解决的三个基本问题，以及层出不穷的 RPC 协议 / 框架。</p>
<p>表示数据、传递数据和表示方法，是 RPC 必须解决的三大基本问题。要解决这些问题，可以有很多方案，这也是 RPC 协议 / 框架出现群雄混战局面的一个原因。</p>
<p>出现这种分裂局面的另一个原因，是简单的框架很难能达到功能强大的要求。</p>
<p>功能强大的框架往往要在传输中加入额外的负载和控制措施，导致传输性能降低，而如果既想要高性能，又想要强功能，这就必然要依赖大量的技巧去实现，进而也就导致了框架会变得过于复杂，这就决定了不可能有一个”完美”的框架同时满足简单、普适和高性能这三个要求。</p>
<p>认识到这一点后，一个 RPC 框架要想取得成功，就要选择一个发展方向，能够非常好地满足某一方面的需求。因此，我们也就有了朝着面向对象发展、朝着性能发展和朝着简化发展这三条线。</p>
<p>以上就是这一讲我要和你分享的 RPC 在工业界的发展成果了。这也是，你在日后工作中选择 RPC 实现方案的一个参考。</p>
<p>最后，我再和你分享一点我的心得。我在讲到 DCOM、CORBA、Web Service 的失败的时候，虽然说我的口吻多少有一些戏谑，但我们得明确一点：这些框架即使没有成功，但作为早期的探索先驱，并没有什么应该被讽刺的地方。而且其后续的发展，都称得上是知耻后勇，反而值得我们的掌声赞赏。</p>
<p>比如，说到 CORBA 的消亡，OMG 痛定思痛之后，提出了基于 RTPS 协议栈的” <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Data_Distribution_Service">数据分发服务</a> “商业标准（Data Distribution Service，DDS，”商业”就是要付费使用的意思）。这个标准现在主要用在物联网领域，能够做到微秒级延时，还能支持大规模并发通讯。</p>
<p>再比如，说到 DCOM 的失败和 Web Service 的衰落，微软在它们的基础上，推出了 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Windows_Communication_Foundation">.NET WCF（Windows Communication Foundation，Windows 通信基础）</a> 。</p>
<p>.NET WCF 的优势主要有两点：一是，把 REST、TCP、SOAP 等不同形式的调用，自动封装为了完全一致的、如同本地方法调用一般的程序接口；二是，依靠自家的”地表最强 IDE”Visual Studio，把工作量减少到只需要指定一个远程服务地址，就可以获取服务描述、绑定各种特性（如安全传输）、自动生成客户端调用代码，甚至还能选择同步还是异步之类细节的程度。</p>
<p>虽然.NET WCF 只支持.NET 平台，而且也是采用 XML 语言描述，但使用体验真的是非常畅快，足够挽回 Web Service 得罪开发者丢掉的全部印象分。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://kibazen.cn" rel="external nofollow noreferrer">Kiba Amor</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                    </span>
                <span class="reprint-info">
                    <a href="https://kibazen.cn/zhou-zhi-ming-de-ruan-jian-jia-gou-ke-xue-xi-bi-ji-shang/">https://kibazen.cn/zhou-zhi-ming-de-ruan-jian-jia-gou-ke-xue-xi-bi-ji-shang/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY-NC-ND 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://kibazen.cn" target="_blank">Kiba Amor</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                                    <span class="chip bg-color">极客时间</span>
                                </a>
                            
                                <a href="/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/">
                                    <span class="chip bg-color">软件架构</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="qq,wechat,weibo,douban" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/zhou-zhi-ming-de-ruan-jian-jia-gou-ke-xue-xi-bi-ji-shang/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/16.jpg" class="responsive-img" alt="《周志明的软件架构课》学习笔记（上）">
                        
                        <span class="card-title">《周志明的软件架构课》学习笔记（上）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-03-06
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                    学习笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                        <span class="chip bg-color">极客时间</span>
                    </a>
                    
                    <a href="/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/">
                        <span class="chip bg-color">软件架构</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/rong-qi-shi-zhan-gao-shou-ke-xue-xi-bi-ji/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/medias/featureimages/17.jpg" class="responsive-img" alt="《容器实战高手课》学习笔记">
                        
                        <span class="card-title">《容器实战高手课》学习笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-09-02
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                    学习笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">
                        <span class="chip bg-color">极客时间</span>
                    </a>
                    
                    <a href="/tags/docker/">
                        <span class="chip bg-color">docker</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (true) {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 木叶禅<br />'
            + '文章作者: Kiba Amor<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者木叶禅所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('2'),
            headingSelector: 'h2, h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2023</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">Kiba Amor</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">1370.2k</span>&nbsp;字
            
            
            
            
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/kibaamor" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>









    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=562236616" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 562236616" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>





    <a href="https://www.zhihu.com/people/kibaamor" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/kibaamor" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    

    

    

	
    

    

    

    
    <script src="https://cdn.jsdelivr.net/gh/kibaamor/kibaamor.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
